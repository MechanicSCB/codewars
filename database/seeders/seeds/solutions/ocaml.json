{"50654ddff44f800200000004":[{"id":216534,"user_id":527,"body":"let multiply x y = x * y","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216535,"user_id":null,"body":"let multiply (x : int) (y : int) : int = x * y","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216536,"user_id":168,"body":"let multiply = ( * )","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216537,"user_id":null,"body":"let multiply x y =\nlet b = x*y in\nb;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216538,"user_id":null,"body":"(*let multiply x y = x * y*)\n(*let multiply = ( * )*)\nlet multiply (x: int) (y: int) :int = x * y\n(*let multiply = fun x y -> x * y*)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216539,"user_id":null,"body":"let multiply a b = a * b","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216540,"user_id":null,"body":"let multiply = fun x y -> x * y;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216541,"user_id":null,"body":"let multiply (x: int) (y: int) = x * y;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"511f11d355fe575d2c000001":[{"id":216542,"user_id":null,"body":"let two_oldest_ages ages =\n  let rec helper acc =\n    let younger = List.hd acc and older = List.nth acc 1 in\n    function\n    | [] -> acc\n    | x :: xs ->\n        if x > older then helper [older; x] xs\n        else if x > younger then helper [x; older] xs\n        else helper acc xs\n  in\n  helper [0; 0] ages","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216543,"user_id":null,"body":"let two_oldest_ages ages =\n  let my_compare a b = -(compare a b) in\n  let sorted = List.sort my_compare ages in\n  match sorted with\n  | a :: b :: _ -> [b; a]\n  | _ -> []\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216544,"user_id":759,"body":"let two_oldest_ages ages =\n    let a = List.sort compare ages |> List.rev in\n    [List.nth a 1; List.nth a 0]\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216545,"user_id":53,"body":"let two_oldest_ages ages =\n  let cmp a b = if a < b then -1 else if a > b then 1 else 0 in\n  let sorted = List.rev (List.sort cmp ages) in\n  (List.nth sorted 1) :: (List.nth sorted 0) :: []\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216546,"user_id":null,"body":"let two_oldest_ages l =\n  let first = List.fold_left max min_int l in\n  let second = l |> List.filter ( (!=) first) |> List.fold_left max min_int in\n  [second; first] ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216547,"user_id":null,"body":"let take2rev = function\n  |[] -> []\n  |[x] -> [x]\n  | x::y::ys -> y::x::[] \n\nlet two_oldest_ages ages  =   ages |>  List.sort compare |> List.rev |> take2rev","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216548,"user_id":null,"body":"let two_oldest_ages ages =\n    let length = List.length ages in\n    let sorted = List.sort (fun a b -> a - b) ages in\n    [(List.nth sorted (length - 2)); (List.nth sorted (length - 1))]\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216549,"user_id":null,"body":"let [@warning \"-8\"] two_oldest_ages ages =\n  let x :: y :: _ = List.sort (fun x y -> y - x) ages in\n  [y; x]","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216550,"user_id":294,"body":"let two_oldest_ages ages =\n    match ages |> List.sort compare |> List.rev with\n    | y :: x :: _ -> [x; y]\n    | _ -> failwith \"length\"\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216551,"user_id":null,"body":"let two_oldest_ages ages =\n  let rec find_top2 b1 b2 l =\n    match l with\n      | [] -> [b2; b1]\n      | h::t -> match b2 < h with\n        | false -> find_top2 b1 b2 t\n        | true -> match b1 < h with\n          | true -> find_top2 h b1 t\n          | false -> find_top2 b1 h t in\n  find_top2 0 0 ages\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"521c2db8ddc89b9b7a0000c1":[{"id":216552,"user_id":null,"body":"let rec transpose = function\n  | []     -> []\n  | []::xs -> []\n  | m      -> List.map List.hd m :: transpose (List.map List.tl m)\n\nlet rec snail = function\n  | [] -> []\n  | x::xs -> x @ (snail (transpose (List.map List.rev xs)))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216553,"user_id":751,"body":"open Batteries\n\nlet rec snail = function\n  | [] -> []\n  | x :: xs ->\n    let rotateccw ys = List.transpose ys |> List.rev in\n      x @ (snail (rotateccw xs))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216554,"user_id":null,"body":"open List;;\n\nlet rec rot ll =\n  match hd ll with\n    | [] -> []\n    | _ -> (map hd ll) :: rot (map tl ll)\n\nlet rec snail xs =\n  match xs with\n   | [x] -> x\n   | _ -> append (hd xs) ((tl xs) |> rot |> rev |> snail)\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216555,"user_id":null,"body":"let rot90 m =\n\tlet rec loop buff = function\n\t\t| [] | [] :: _ -> buff\n\t\t| ls           -> loop (List.map List.hd ls :: buff) (List.map List.tl ls) in\n\tloop [] m\n\nlet rec snail = function\n\t| [] -> []\n\t| l :: ls -> l @ snail (rot90 ls)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216556,"user_id":null,"body":"let ( .%() ) array (i,j) = List.nth (List.nth array i) j\n\nlet snail xs =\n  let rec square off trail = function\n  | -1 -> List.flatten trail\n  | 0  -> List.flatten ( trail @ [[xs.%(off, off)]] )\n  | length -> length - 2 |> square (off + 1) (trail\n    @  List.init length (fun i -> xs.%(off,          off + i))\n    :: List.init length (fun i -> xs.%(off+i,        off+length))\n    :: List.init length (fun i -> xs.%(off+length,   off+length-i))\n    :: List.init length (fun i -> xs.%(off+length-i, off))\n    :: [])\n  in\n  let ret = square 0 [] (List.length (List.hd xs) - 1) in\n  ret","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216557,"user_id":null,"body":"type dir = Up | Down | Left | Right\n\ntype parms = {\n    dir : dir;\n    x : int;\n    y : int;\n    min_x : int;\n    min_y : int;\n    max_x : int;\n    max_y : int;\n  }\n\nlet mk_parms max_x max_y = {\n    dir = Right;\n    x = 0;\n    y = 0;\n    min_x = 0;\n    min_y = 0;\n    max_x = max_x;\n    max_y = max_y;\n  }\n\nlet rec map_dir arg  =\n  let {dir; x; y; min_x; min_y; max_x; max_y} = arg in\n  match dir with\n  | Right ->\n     if x < (max_x - 1)\n     then { arg with\n            x = x + 1 }\n     else { arg with\n            dir = Down;\n            y = y + 1;\n            min_y = min_y + 1;\n          }\n  | Down ->\n     if y < (max_y - 1)\n     then { arg with\n            y = y + 1 }\n     else { arg with\n            dir = Left;\n            x = x - 1;\n            max_x = max_x - 1;\n          }\n  | Left ->\n     if x > min_x\n     then { arg with\n            x = x - 1 }\n     else { arg with\n            dir = Up;\n            y = y - 1; \n            max_y = max_y - 1;\n          }\n  | Up ->\n     if y > min_y\n     then { arg with\n            y = y - 1 }\n     else { arg with\n            dir = Right;\n            x = x + 1;\n            min_x = min_x + 1;\n          }\n\nlet snail_fold_left d f acc =\n  let rec aux i max d f acc =\n    if i < max\n    then\n      aux (i + 1) max (map_dir d) f (f d acc)\n    else acc in\n  aux 0 (d.max_x * d.max_y) d f acc\n\nlet snail (xs : int list list)  : int list =\n  let a = List.map Array.of_list xs |> Array.of_list in\n  let max_y = List.length xs in\n  let max_x = List.length (List.hd xs) in\n  let d = mk_parms max_x max_y in\n  snail_fold_left d (fun d acc -> a.(d.y).(d.x) :: acc) [] |>\n    List.rev","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216558,"user_id":null,"body":"let snail xs = \n  let rec do_cycle rev_so_far xs =\n    let consume_front rev_so_far xs =\n      let rows_reversed = List.rev xs in\n      let rev_so_far = List.fold_left (fun rsf rows -> match rows with h::t -> h::rsf | _ -> rsf) rev_so_far rows_reversed in\n      (rev_so_far, (List.map List.tl xs)) in\n    let consume_bottom rev_so_far xs =\n      let rows_reversed = List.rev xs in\n      match rows_reversed with\n          [] -> (rev_so_far, [])\n        | h::t -> consume_front (h @ rev_so_far) (List.rev t) in\n    let consume_tails rev_so_far xs =\n      let reversed = List.map List.rev xs in\n      let rev_so_far = List.fold_left (fun rsf row -> match row with h::t -> h::rsf | _ -> rsf) rev_so_far reversed in\n      let reversed_tails = List.map List.tl reversed in\n      consume_bottom rev_so_far (List.map List.rev reversed_tails) in\n    let consume_row rev_so_far xs = \n      match xs with\n        row::tail -> let rev_so_far = List.rev_append row rev_so_far in consume_tails rev_so_far tail\n      | [] -> ((List.rev rev_so_far), []) in\n    match List.flatten xs with\n      [] -> let res = List.rev rev_so_far in let () = List.iter (Printf.printf \"%d \") res in res\n    | _ -> let rev_so_far, xs = consume_row rev_so_far xs in do_cycle rev_so_far xs in\n  do_cycle [] xs","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216559,"user_id":null,"body":"let extract t =\n  let l = Array.length t - 2 in\n  Array.map (fun arr -> Array.sub arr 1 l) (Array.sub t 1 l);;\n\nlet snail xs =\n  let rec aux t dir i j acc =\n    let len = Array.length t.(0) in\n\tmatch len with\n\t\t| 0 -> acc\n\t\t| 1 -> (t.(0).(0)::acc)\n\t\t| 2 -> (t.(1).(0)::t.(1).(1)::t.(0).(1)::t.(0).(0)::acc)\n\t\t| _ -> match dir with\n    \t\t| 0 -> if j < (len-1) then aux t 0 i (j+1) (t.(i).(j)::acc)\n    \t\t\t\t\t\t\t  else aux t 1 (i+1) j (t.(i).(j)::acc)\n    \t\t| 1 -> if i < (len-1) then aux t 1 (i+1) j (t.(i).(j)::acc)\n    \t\t\t\t\t\t\t  else aux t 2 i (j-1) (t.(i).(j)::acc)\n\t    \t| 2 -> if j > 0 then aux t 2 i (j-1) (t.(i).(j)::acc)\n    \t\t\t\t\t\telse aux t 3 (i-1) j (t.(i).(j)::acc)\n    \t\t| _ -> if i > 1 then aux t 3 (i-1) j (t.(i).(j)::acc)\n    \t\t\t\t\t\telse aux (extract t) 0 0 0 (t.(i).(j)::acc)\n  in List.rev (aux (Array.of_list (List.map (fun l -> Array.of_list l) xs)) 0 0 0 []);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216560,"user_id":null,"body":"let rec get_last = function\n  [] -> failwith \"Empty list\"\n  | h :: [] -> h\n  | h :: t -> get_last t;;\nlet rec but_last = function\n  [] -> failwith \"Empty list\"\n  | h :: [] -> []\n  | h :: t -> h :: (but_last t);;\n\nlet remove_bounds lst = List.map (fun line -> but_last (List.tl line)) (but_last (List.tl lst));;\n\nlet rec snail = function\n  [[]] -> []\n  | (e :: []) :: [] -> e :: []\n  | (a :: b :: []) :: (c :: d :: []) :: [] -> a :: b :: d :: c :: []\n  | xs ->\n    let lst = ref [] in\n    lst := List.hd xs;\n    lst := !lst @ (List.map get_last (but_last (List.tl xs)));\n    lst := !lst @ (List.rev (get_last xs));\n    lst := !lst @ (List.rev (List.map List.hd (but_last (List.tl xs))));\n    !lst @ snail (remove_bounds xs);;\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216561,"user_id":null,"body":"let (--) i j =\n  let rec aux n acc =\n    if n < i then acc else aux (n-1) (n :: acc)\n  in aux j []\n\nlet snail_index n =\n  let rec loop i = begin\n    let last = n - 1 - i in\n    let open List in\n    if i < last\n    then\n      let col_indices = i--last in\n      let row_indices = (i+1)--(last-1) in\n      let top    = map (fun c -> (i, c)) col_indices in\n      let bottom = map (fun c -> (last, c)) (rev col_indices) in\n      let right  = map (fun r -> (r, last)) row_indices in\n      let left   = map (fun r -> (r, i)) (rev row_indices) in\n      concat [top; right; bottom; left; loop (i+1)]\n    else if i == last\n    then [(i, i)]\n    else []\n  end in\n  loop 0\n\nlet snail xs =\n  let a = Array.of_list (List.map Array.of_list xs) in\n  List.map (fun (i, j) -> a.(i).(j)) @@ snail_index @@ Array.length a.(0)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52742f58faf5485cae000b9a":[{"id":216562,"user_id":null,"body":"(* [\"a\", \"b\", \"c\"] -> \"a, b and c\" *)\nlet format_string_list xs =\n  let open Format in\n  let rec pp_string_list ppf = function\n    | [] -> ()\n    | [x] -> pp_print_string ppf x\n    | [x; y] -> fprintf ppf \"%s and %s\" x y\n    | x :: xs ->\n      fprintf ppf \"%s, \" x;\n      pp_string_list ppf xs\n  in\n  pp_string_list str_formatter xs;\n  flush_str_formatter ()\n\nlet string_of_unit = function\n  | `Second -> \"second\"\n  | `Minute -> \"minute\"\n  | `Hour -> \"hour\"\n  | `Day -> \"day\"\n  | `Year -> \"year\"\n\nlet string_of_component (u, x) =\n  let plural = if x > 1 then \"s\" else \"\" in\n  Printf.sprintf \"%d %s%s\" x (string_of_unit u) plural\n\nlet string_of_component_list comps =\n  let str_list = List.map string_of_component comps in\n  format_string_list (match str_list with [] -> [\"now\"] | x -> x)\n\nlet format_duration (seconds : int) : string =\n  let minutes = seconds \/ 60 in\n  let hours = minutes \/ 60 in\n  let days = hours \/ 24 in\n  let years = days \/ 365 in\n  let components = [`Year, years; `Day, days mod 365; `Hour, hours mod 24;\n                    `Minute, minutes mod 60; `Second, seconds mod 60] in\n  let positive_only = List.filter @@ fun (_, x) -> x > 0 in\n  string_of_component_list @@ positive_only components","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216563,"user_id":98,"body":"let seconds_per_second =   1\nlet seconds_per_minute =  60 * seconds_per_second\nlet seconds_per_hour   =  60 * seconds_per_minute\nlet seconds_per_day    =  24 * seconds_per_hour\nlet seconds_per_year   = 365 * seconds_per_day\n\ntype time_unit = {seconds : int; name : string}\n\nlet durations = [\n\t{seconds = seconds_per_year;   name = \"year\"};\n\t{seconds = seconds_per_day;    name = \"day\"};\n\t{seconds = seconds_per_hour;   name = \"hour\"};\n\t{seconds = seconds_per_minute; name = \"minute\"};\n\t{seconds = seconds_per_second; name = \"second\"}\n]\n\nlet format_duration (seconds: int): string =\n\tlet rec get_durations seconds list i =\n\t\tif seconds = 0 then\n\t\t\tList.rev list\n\t\telse\n\t\t\tlet duration = List.nth durations i in\n\t\t\tlet count = seconds \/ duration.seconds in\n\t\t\tif count = 0 then\n\t\t\t\tget_durations seconds list (i + 1)\n\t\t\telse\n\t\t\t\tlet formatted = string_of_int(count) ^ \" \" ^ duration.name ^ (if count = 1 then \"\" else \"s\") in\n\t\t\t\tget_durations (seconds - count * duration.seconds) (formatted :: list) (i + 1)\n\tin\n\tlet parts = get_durations seconds [] 0 in\n\tmatch List.rev parts with\n\t| []     -> \"now\"\n\t| [h]    -> h\n\t| h :: t -> (String.concat \", \" (List.rev t)) ^ \" and \" ^ h\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216564,"user_id":null,"body":"module Duration : sig \n    type t\n    val of_seconds : int -> t\n    val to_string : t -> string\nend = struct\n    type t = { years : int; days : int; hours : int; minutes : int; seconds : int }\n    \n    let of_seconds s = \n        let seconds = s mod 60 in\n        let rest = s \/ 60 in\n        let minutes = rest mod 60 in\n        let rest = rest \/ 60 in\n        let hours = rest mod 24 in\n        let rest = rest \/ 24 in\n        let days = rest mod 365 in\n        let years = rest \/ 365 in\n        {years; days; hours; minutes; seconds}\n        \n    let to_string {years; days; hours; minutes; seconds} = \n        let string_of_item count name = \n            if count = 0 then \"\"\n            else if count = 1 then (string_of_int 1) ^ \" \" ^ name\n            else (string_of_int count) ^ \" \" ^ name ^ \"s\" in\n        let text = [\n            string_of_item years \"year\"; \n            string_of_item days \"day\"; \n            string_of_item hours \"hour\"; \n            string_of_item minutes \"minute\"; \n            string_of_item seconds \"second\"\n            ] in\n        match List.(text |> filter (fun x -> x <> \"\") |> rev) with\n            | [] -> \"now\"\n            | [x] -> x\n            | [y; x] -> x ^ \" and \" ^ y\n            | y :: x :: zs -> (String.concat \", \" (List.rev zs)) ^ \", \" ^ x ^ \" and \" ^ y       \nend\n\n\nlet format_duration (seconds: int): string =\n    let duration = Duration.of_seconds seconds in\n    Duration.to_string duration","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216565,"user_id":168,"body":"let ts = [3600 * 24 * 365, \"year\"; 3600 * 24, \"day\"; 3600, \"hour\"; 60, \"minute\"; 1, \"second\"]\n  \nlet format_duration (seconds: int): string =\n  let fmt n s = Format.sprintf \"%d %s%s\" n s (if n > 1 then \"s\" else \"\") in\n  let f (r, seconds) (t, name) =\n    let x = seconds \/ t in\n    if x > 0 then fmt x name :: r, seconds - x * t else r, seconds in\n  match fst (List.fold_left f ([], seconds) ts) with\n  | [] -> \"now\"\n  | [x] -> x\n  | x :: xs -> Format.sprintf \"%s and %s\" (String.concat \", \" (List.rev xs)) x","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216566,"user_id":null,"body":"let format_duration seconds =\n\n  let rec loop sec buff = function\n    | [] -> buff\n    | (n, name) :: l when sec >= n ->\n      let qty = string_of_int (sec \/ n) in\n      let str = qty ^ \" \" ^ name ^ (if qty = \"1\" then \"\" else \"s\") in\n      loop (sec mod n) (str :: buff) l\n    | _ :: l -> loop sec buff l in\n\n  let lengths_names = [(31536000, \"year\");\n                       (86400, \"day\");\n                       (3600, \"hour\");\n                       (60, \"minute\");\n                       (1, \"second\")] in\n\n  match loop seconds [] lengths_names with\n  | [] -> \"now\"\n  | [x] -> x \n  | x :: y :: ll -> List.fold_left (fun acc str -> str ^ \", \" ^ acc) \"\" ll ^ y ^ \" and \" ^ x","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52756e5ad454534f220001ef":[{"id":216567,"user_id":null,"body":"let longer s1 s2 =\nif List.length s1 > List.length s2 then s1 else s2;;\n\nlet rec lcs (s1: 'a list) (s2: 'a list) =\n  match (s1, s2) with\n  | ([], _) -> []\n  | (_, []) -> []\n  | (x::xs, y::ys) when x == y -> x :: lcs xs ys\n  | (x::xs, y::ys) -> longer (lcs s1 ys) (lcs xs s2);;\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216568,"user_id":53,"body":"let lcs (s0: 'a list) (t0: 'a list) = \n  let rec go s0 t0 = match (s0, t0) with\n    | ([],_) -> []\n    | (_,[]) -> []\n    | (x::xs, y::ys) -> if x == y then \n                          x :: (go xs ys) \n                        else\n                          let a = go xs (y :: ys) in\n                          let b = go (x :: xs) ys in\n                          if (List.length a) > (List.length b) then a else b\n  in (go (List.rev s0) (List.rev t0)) |> List.rev\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216569,"user_id":null,"body":"let lcs (s1: 'a list) (s2: 'a list) = \n  let rec with_acc acc s1 s2 = match s1, s2 with\n  | [], _ | _, [] -> List.rev acc\n  | (h1 :: t1), (h2 :: t2) when h1 = h2 ->  with_acc (h1 :: acc) t1 t2\n  | (h1 :: t1), (h2 :: t2) -> \n    let sub1 = with_acc acc t1 s2 in\n    let sub2 = with_acc acc s1 t2 in\n    if List.(length sub1 > length sub2) then sub1 else sub2\n  in\n  with_acc [] s1 s2","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216570,"user_id":null,"body":"let backtrack_lcs backtrack s n1 n2 = \n    let rec loop acc i j = \n        if i <= 0 || j <= 0 then acc\n        else if backtrack.(i-1).(j-1) = 0 then loop (s.(i-1) :: acc) (i - 1) (j - 1)\n        else if backtrack.(i-1).(j-1) = -1 then loop acc (i - 1) j\n        else loop acc i (j - 1)\n    in loop [] n1 n2    \n\n\nlet lcs (s1: 'a list) (s2: 'a list) =\n    let s1 = Array.of_list s1 in\n    let s2 = Array.of_list s2 in\n    let n1 = Array.length s1 in\n    let n2 = Array.length s2 in\n    let longest_path = Array.make_matrix (n1 + 1) (n2 + 1) 0 in\n    let backtrack = Array.make_matrix n1 n2 0 in\n    for i = 0 to (n1 - 1) do\n        for j = 0 to (n2 - 1) do\n            let mismatch = if s1.(i) = s2.(j) then 1 else 0 in\n            let path = max (max longest_path.(i).(j+1) longest_path.(i+1).(j)) (longest_path.(i).(j) + mismatch) in\n            let direction = \n                if path = longest_path.(i).(j+1) then -1\n                else if path = longest_path.(i+1).(j) then 1\n                else 0 in\n            longest_path.(i+1).(j+1) <- path;\n            backtrack.(i).(j) <- direction\n        done;\n    done;\n    backtrack_lcs backtrack s1 n1 n2\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216571,"user_id":null,"body":"let rec lcs (s1: 'a list) (s2: 'a list) =\n  (* Your code here *)\n  if (s1 = []) || (s2 = [])\n  then []\n  else begin\n    if List.hd s1 = List.hd s2\n    then (List.hd s1) :: (lcs (List.tl s1) (List.tl s2))\n    else\n       let rr = (lcs s1 (List.tl s2)) \n       and ll = (lcs (List.tl s1) s2) in\n       if List.length ll > List.length rr\n       then ll\n       else rr\n  end","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216572,"user_id":294,"body":"let rec lcs (xs: 'a list) (ys: 'a list) =\n  match xs, ys with\n  | _, [] | [], _      -> []\n  | x :: xs', y :: ys' ->\n    if x = y then x :: lcs xs' ys'\n    else max_by List.length [lcs xs ys'; lcs xs' ys]\n\n\nand max_by f xs =\n  let rec aux cur_max = function\n  | []       -> cur_max\n  | x :: xs' ->\n    let next_max = if f x > f cur_max then x else cur_max\n    in aux next_max xs'\n  \n  in\n  match xs with\n  | []       -> failwith \"empty\"\n  | x :: xs' -> aux x xs'\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216573,"user_id":null,"body":"let lcs (s1: 'a list) (s2: 'a list) =\n  let rec _rec s1 s2 =\n    match (s1, s2) with\n    | ([], _) -> (0, [])\n    | (_, []) -> (0, [])\n    | (x1::s1', x2::s2') when x1 = x2 ->\n       let (l, c) = _rec s1' s2' in\n       (l + 1, x1 :: c)\n    | (_::s1', _::s2') ->\n       let (l1, c1) = _rec s1 s2' in\n       let (l2, c2) = _rec s1' s2 in\n       if l1 > l2 then (l1, c1) else (l2, c2)\n  in\n  _rec s1 s2 |> snd\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216574,"user_id":null,"body":"exception No\nlet lcs (s1: 'a list) (s2: 'a list) =\n    let len1 = List.length s1 in\n    let len2 = List.length s2 in\n    let mem = Array.make_matrix len1 len2 (-1) in\n    let rec dp i j = \n        if i = len1 || j = len2 then 0 else\n            let mem_val = mem.(i).(j) in \n            if mem_val != -1 then mem_val else\n                if List.nth s1 i = List.nth s2 j then\n                    let result = \n                        max (1+(dp (i+1) (j+1))) (max (dp (i+1) j) (dp i (j+1)))\n                    in\n                    mem.(i).(j) <- result;\n                    result\n                else\n                    let result = \n                        max (dp (i+1) j) (dp i (j+1))\n                    in\n                    mem.(i).(j) <- result;\n                    result\n    in\n    let result = dp 0 0 in\n    let rec reconstruct i j t left = \n        if left = 0 then t else\n        if (List.nth s1 i = List.nth s2 j) &&  dp (i+1) (j+1) = left - 1 then\n            reconstruct (i+1) (j+1) ((List.nth s1 i)::t) (left-1)\n        else\n            if dp (i+1) j = left then \n                reconstruct (i+1) j t left \n            else \n                if dp i (j+1) = left then \n                    reconstruct i (j+1) t left\n                else \n                    raise No\n    in\n    List.rev (reconstruct  0 0 [] result)\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216575,"user_id":null,"body":"(* find first item of l1 that is also in l2\n   returns a list of : a list of this item, sublists of l1 and l2 after this item\n *)\nlet find_first l1 l2 =\n  let rec foreachl1 l =\n    match l with\n    | [] -> []\n    | a1 :: t1 ->\n        let rec foreachl2 l =\n          match l with\n          | [] -> []\n          | a2 :: t2 ->\n                if a1 = a2\n                then [[a1]; t1; t2]\n                else foreachl2 t2\n        in\n        let found = foreachl2 l2 in\n        if found = []\n        then foreachl1 t1\n        else found\n  in\n  foreachl1 l1\n;;\n\nlet lcs l1 l2 =\n  let seq_max = ref []\n  and len_max = ref 0\n  in  \n  let rec common_sequences current_sequence l1 l2 =\n    match find_first l1 l2 with\n    | []\n     -> let len = List.length current_sequence in\n        if len > !len_max\n        then ( len_max := len;\n               seq_max := current_sequence;\n             );\n        []\n    | [first; m1; m2]\n     -> let new_sequence = List.append current_sequence first\n        in\n        List.concat\n        [ [first]\n        ; ( List.map (fun l -> List.append first l) ( common_sequences new_sequence m1 m2 ) )\n        ; ( common_sequences current_sequence m1 l2 )\n        ]\n    | _\n     -> raise (Failure \"find_first returned wrong type\")\n  in\n  common_sequences [] l1 l2;\n  !seq_max\n;;\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216576,"user_id":null,"body":"(* Here is a 'simple' version, which is not tail recursive *)\n\n(*\nlet rec lcs : 'a list -> 'a list -> 'a list =\n  fun left right ->\n    let rec length : 'a list -> int =\n      fun ls ->\n        match ls with\n          | [] -> 0\n          | _::t -> 1 + (length t)\n    in\n    match (left, right) with\n      | (head_left::tail_left, head_right::tail_right) ->\n        if (head_left = head_right)\n          then head_left::(lcs tail_left tail_right)\n          else (\n            let sequence_left = lcs left tail_right in\n            let sequence_right = lcs tail_left right in\n            if (length sequence_left < length sequence_right)\n              then sequence_right\n              else sequence_left\n          )\n      | ([], _) -> []\n      | (_, []) -> []\n;;\n*)\n\n(* Here is a tail recursive version *)\n(*\n  The idea: Use the followings:\n    (('a list * 'a list * 'a list) list) to keep track of branches to explore\n        The tuple ('a list * 'a list * 'a list * int) is (left, right, prefix, prefix_size)\n    ('a list) to keep the current best branch\n    (int) to keep the current best branch size\n  \n  Because of tail recursion, we will be building the list in reverse, we must therefore reverse the result\n*)\n\nlet lcs : 'a list -> 'a list -> 'a list =\n  fun left right ->\n    let reverse : 'a list -> 'a list =\n      fun ls ->\n        let rec reverse_aux : 'a list -> 'a list -> 'a list =\n          fun ls res ->\n            match ls with\n              | [] -> res\n              | h::t -> reverse_aux t (h::res)\n        in\n        reverse_aux ls []\n    in\n    let rec lcs_aux : ('a list * 'a list * 'a list * int) list -> 'a list -> int -> 'a list =\n      fun branches res res_n ->\n        match branches with\n          | [] -> reverse res\n          | ([], _, _, _)::branches_tail -> lcs_aux branches_tail res res_n\n          | (_, [], _, _)::branches_tail -> lcs_aux branches_tail res res_n\n          | (h1::t1, h2::t2, branch, branch_n)::branches_tail ->\n            if (h1 = h2)\n              then (\n                let nx_branch = h1::branch in\n                let nx_branch_n = branch_n + 1 in\n                let nx_branches = (t1, t2, nx_branch, nx_branch_n)::branches_tail in\n                if (nx_branch_n > res_n)\n                  then lcs_aux nx_branches nx_branch nx_branch_n\n                  else lcs_aux nx_branches res res_n\n              )\n              else (\n                let nx_branch_1 = (h1::t1, t2, branch, branch_n) in\n                let nx_branch_2 = (t1, h2::t2, branch, branch_n) in\n                lcs_aux (nx_branch_1::(nx_branch_2::branches_tail)) res res_n\n              )\n    in\n    lcs_aux [(left, right, [], 0)] [] 0\n;;\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"52bc74d4ac05d0945d00054e":[{"id":216577,"user_id":168,"body":"let first_non_repeating_letter s =\n  let t = String.lowercase_ascii s in\n  let n = String.length t in\n  let rec find i =\n    if i >= n then None\n    else if String.index t t.[i] = String.rindex t t.[i] then Some s.[i]\n    else find (i + 1) in\n  find 0\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216578,"user_id":null,"body":"let rec first_non_repeating_letter (s : string) : char option =\n  let n = String.length s in \n  let rec helper i = \n    if i > n-1 then None else\n    let c = String.get s i in\n    let rest = String.lowercase_ascii ((String.sub s 0 i) ^ (String.sub s (i+1) (n-i-1))) in\n    if String.contains rest (Char.lowercase_ascii c) then helper (i+1) else Some c\n  in helper 0  \n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216579,"user_id":null,"body":"let first_non_repeating_letter s =\n  let not_contained_elsewhere s k c =\n    not (try (String.contains_from s (k+1) c) with Invalid_argument _ -> false) && \n    not (try (String.rcontains_from s (k-1) c)  with Invalid_argument _ -> false) in\n  let rec helper s slow k =\n    if k == String.length s then None\n    else\n      let c = s.[k] in\n      let cl = Char.lowercase_ascii c in\n      if not_contained_elsewhere slow k cl then Some c\n      else helper s slow (k+1) in\n  helper s (String.lowercase_ascii s) 0","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216580,"user_id":null,"body":"let char_counts (chars : char list) : (char * int) list =\n  List.fold_left (fun acc char ->\n         let key = Char.lowercase_ascii char in\n         match List.assoc_opt key acc with\n         | None   -> (key,1)::acc\n         | Some i -> (key,i+1) :: List.remove_assoc key acc)\n       [] chars\n  |> List.filter (fun (_,v) -> v = 1)\n\nlet first_non_repeating_letter s : char option =\n  let chars = s |> String.to_seq |> List.of_seq in\n  let counts = char_counts chars in\n  List.find_opt (fun c ->\n      List.mem_assoc (Char.lowercase_ascii c) counts)\n    chars","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216581,"user_id":null,"body":"let scount s c =\n  let n = ref 0 in\n  for i = 0 to (String.length s - 1) do\n    if s.[i] = c then incr n else () done;\n  !n;;\n\nlet first_non_repeating_letter s =\n  let l = String.length s in\n  let sl = String.lowercase_ascii s in\n  let t = Array.make l (-1) in\n  for i = 0 to (l - 1) do\n    t.(i) <- scount sl sl.[i] done;\n  let ans = ref (-1) in\n  let flag = ref true in\n  for i = 0 to (l - 1) do\n    if !flag then\n      if t.(i) = 1 then\n        (flag := false;\n        ans := i) done;\n  if !flag then None else Some s.[!ans];;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216582,"user_id":480,"body":"let first_non_repeating_letter s =\n  let s=List.of_seq (String.to_seq s) in\n  let rec aux s=\n    match s with\n    | []->None\n    | c::s->\n      let cu=Char.uppercase_ascii c in\n      match List.find_opt (fun x->(Char.uppercase_ascii x)==cu) s with\n      | None -> Some c\n      | _ -> aux (List.filter (fun x->x!=c) s)\n  in\n    aux s;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216583,"user_id":null,"body":"let first_non_repeating_letter s =\n  let ct = String.length s |> Hashtbl.create in\n  let lst = String.to_seq s |> List.of_seq in\n  let up c =\n    let k = Char.lowercase_ascii c in\n    let n = match Hashtbl.find_opt ct k with\n      | None -> 0\n      | (Some n) -> n in\n    Hashtbl.replace ct k (n + 1) in\n  List.iter up lst;\n  List.find_opt (fun c -> Hashtbl.find ct (Char.lowercase_ascii c) = 1) lst","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216584,"user_id":null,"body":"let explode s = List.of_seq (String.to_seq s)\nlet lw = Char.lowercase_ascii\n\nlet first_non_repeating_letter s =\n  let s = explode s in\n  List.find_opt (fun c -> List.length @@ List.find_all (fun c' -> lw c = lw c') s = 1) s","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216585,"user_id":null,"body":"let first_non_repeating_letter s =\n  let rec aux chs =\n    match chs with\n    | [] -> None\n    | hd :: tl ->\n      if List.mem (Char.lowercase_ascii hd) (List.map Char.lowercase_ascii tl)\n      then \n        aux (List.filter (fun x -> not (Char.equal hd x)) tl)\n      else Some hd in\n  aux (String.to_seq s |> List.of_seq)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216586,"user_id":null,"body":"type string_table = (Char.t, int) Hashtbl.t\n\nlet to_table (s : string) (h : string_table) : unit =\n  let insert_or_incr (c : char) : unit =\n    match Hashtbl.find_opt h c with\n    | Some v -> Hashtbl.replace h c (v + 1)\n    | None -> Hashtbl.add h c 1\n  in\n  String.to_seq s |> Seq.iter insert_or_incr\n;;\n\nlet single_occur (h : string_table) : char list =\n  let aux (c, v) = if v <> 1 then None else Some c in\n  Hashtbl.to_seq h |> Seq.filter_map aux |> List.of_seq\n;;\n\nlet find (f : char -> bool) (s : char Seq.t) : char option =\n  let rec aux (s : char Seq.t) =\n    match s () with\n    | Seq.Nil -> None\n    | Seq.Cons (h, t) -> if f h then Some h else aux t\n  in\n  aux s\n;;\n\nlet first_non_repeating_letter (s : string) : char option =\n  let h = Hashtbl.create 100 in\n  let () = to_table (String.lowercase_ascii s) h in\n  let uniques = single_occur h in\n  String.to_seq s |> find (fun c -> List.mem (Char.lowercase_ascii c) uniques)\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"53ee5429ba190077850011d4":[{"id":216587,"user_id":null,"body":"let double_integer i =\n  i*2\n(* returns its input doubled *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216588,"user_id":null,"body":"let double_integer i =\n  2 * i (* Quick ! Double the integer and return it ! *)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216589,"user_id":null,"body":"let double_integer i =\n  i + i (* Quick ! Double the integer and return it ! *)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216590,"user_id":null,"body":"let double_integer i = i*2;;\n  0 (* Quick ! Double the integer and return it ! *)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216591,"user_id":null,"body":"let double_integer i = 2*i;;\n  0 (* Quick ! Double the integer and return it ! *)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216592,"user_id":527,"body":"let double_integer (i: int): int = i * 2","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216593,"user_id":527,"body":"let double_integer i = 2 * i","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216594,"user_id":527,"body":"let double_integer i = i * 2","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216595,"user_id":50,"body":"let double_integer i = i + i\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216596,"user_id":null,"body":"let double_integer = ( * ) 2\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"541c8630095125aba6000c00":[{"id":216597,"user_id":527,"body":"let digital_root (n : int) : int =\n  (n - 1) mod 9 + 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216598,"user_id":null,"body":"let rec digital_sum = function\n  | n when n \/ 10 = 0 -> n\n  | n -> n mod 10 + (digital_sum (n \/ 10))\n\nlet rec digital_root = function\n  | n when n \/ 10 = 0 -> n\n  | n -> digital_root (digital_sum n)\n  ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216599,"user_id":null,"body":"let digital_root (n : int) : int =\n  let rec aux acc n =\n    if n \/ 10 = 0 then\n      if acc + n >= 10 then aux 0 (acc + n)\n      else acc + n\n    else aux (acc + n mod 10) (n \/ 10)\n  in\n  aux 0 n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216600,"user_id":null,"body":"let digital_root (n : int) : int =\n  let rec sum a = if a = 0 then 0 else (a mod 10) + sum (a\/10)\n  in let rec q a = if (a\/10) =0 then a else q (sum a)\n  in q n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216601,"user_id":null,"body":"\nlet rec digits ?(l=[]) = function\n  | 0 -> l\n  | n -> digits ~l:((n mod 10)::l) (n \/ 10)\n\nlet rec digital_root (n : int) : int =\n  match digits n with\n  | [] -> 0\n  | n::[] -> n\n  | l ->\n    let digit_sum = List.fold_left (+) 0 l\n    in digital_root digit_sum","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216602,"user_id":null,"body":"let sum_digits n =\n  let res = ref 0 in\n  String.iter (fun s -> res := !res + int_of_char s - int_of_char '0') (string_of_int n);\n  !res;;\n\nlet rec digital_root (n : int) : int =\n  if n < 10 then n else digital_root (sum_digits n);;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216603,"user_id":null,"body":"let rec digital_root = function\n  | n when n < 10 -> n\n  | n -> let digits_string = string_of_int n in\n        let num_len = String.length digits_string in\n        let digits_list = List.init num_len (fun i -> int_of_char digits_string.[i] - 48) in\n        digital_root (List.fold_left (fun x y -> x + y) 0 digits_list);;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216604,"user_id":null,"body":"let rec digital_root n =\n  let digits n =\n    let rec digits_ n d =\n      if n > 0 then\n        digits_ (n \/ 10) ((n mod 10) :: d)\n      else\n        d\n    in\n    digits_ n []\n  in\n  let root = List.fold_left (+) 0 (digits n) in\n  if root > 9 then\n    digital_root root\n  else\n    root\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216605,"user_id":null,"body":"let rec digital_root (n : int) : int =\n  let i = string_of_int n \n  |> String.to_seq \n  |> Seq.fold_left (fun a x -> a + (String.make 1 x |> int_of_string )) 0 in\n  if i >= 10 then digital_root i else i","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216606,"user_id":null,"body":"let digital_root (n : int) : int =\n    match n with\n    | 0 -> 0\n    | _ -> 1 + (n - 1) mod 9\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"542f0c36d002f8cd8a0005e5":[{"id":216607,"user_id":53,"body":"let last_chair (n: int): int = n - 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216608,"user_id":168,"body":"let last_chair = pred","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216609,"user_id":null,"body":"let last_chair (n: int): int =\n  (* your code here *)\n  n-1\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216610,"user_id":null,"body":"let last_chair:int->int=fun n->n-1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216611,"user_id":null,"body":"let last_chair=fun n->lnot(-n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216612,"user_id":527,"body":"let last_chair n = n - 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"544034f426bc6adda200000e":[{"id":216613,"user_id":null,"body":"let find_ball scales =\n  let w1 = scales#get_weight [0; 1; 2] [3; 4; 5] and\n      w2 = scales#get_weight [0; 3; 6] [1; 4; 7] in\n  let poly x = -3 * x*x + x + 4 in\n  (3 * poly w1 + poly w2) \/ 2;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216614,"user_id":null,"body":"let find_ball scales =\n  let w1 = scales#get_weight [0; 1; 2] [3; 4; 5] and\n      w2 = scales#get_weight [0; 3; 6] [1; 4; 7] in\n  ( 3 * ( -3*w1*w1 + w1 + 4 ) + ( -3*w2*w2 + w2 + 4 ) ) \/ 2;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216615,"user_id":null,"body":"let find_ball scales =\n  let w1 = scales#get_weight [0; 1; 2] [3; 4; 5] in\n  if w1 == 0 then\n    let w2 = scales#get_weight [6] [7] in\n    if w2 <= 0 then 6 else 7\n  else if w1 < 0 then\n    let w2 = scales#get_weight [0] [1] in\n    if w2 == 0 then 2\n    else if w2 < 0 then 0\n    else 1\n  else\n    let w2 = scales#get_weight [3] [4] in\n    if w2 == 0 then 5\n    else if w2 < 0 then 3\n    else 4\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216616,"user_id":null,"body":"let find_ball scales =\n    let find_heavier a b c = \n        let w = scales#get_weight [a] [b] in\n        if w < 0 then a \n        else if w > 0 then b\n        else c in\n    let w = scales#get_weight [0; 1; 2] [3; 4; 5] in\n    if w = 0 then if scales#get_weight [6] [7] < 0 then 6 else 7\n    else if w < 0 then find_heavier 0 1 2\n    else find_heavier 3 4 5","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216617,"user_id":168,"body":"let find_ball scales =\n  match scales#get_weight [0; 1; 2] [3; 4; 5] with\n  | 0 -> if scales#get_weight [6] [7] < 0 then 6 else 7\n  | 1 -> (match scales#get_weight [3] [4] with 0 -> 5 | 1 -> 4 | _ -> 3)\n  | _ -> (match scales#get_weight [0] [1] with 0 -> 2 | 1 -> 1 | _ -> 0)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216618,"user_id":53,"body":"let find_ball scales =\n  match (scales#get_weight [0; 1; 2] [3; 4; 5]) with\n  | -1 -> (match (scales#get_weight [0] [1]) with\n      | -1 -> 0\n      | +1 -> 1\n      |  0 -> 2 \n    )\n  | +1 -> (match (scales#get_weight [3] [4]) with\n      | -1 -> 3\n      | +1 -> 4\n      |  0 -> 5 \n    )\n  | 0 -> (match (scales#get_weight [6] [7]) with\n      | -1 -> 6\n      | +1 -> 7 \n    )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216619,"user_id":98,"body":"let find_ball scales =\n  match (scales#get_weight [0; 1; 2] [3; 4; 5]) with\n  | -1 -> (match (scales#get_weight [0] [1]) with\n      | -1 -> 0\n      | +1 -> 1\n      |  0 -> 2 \n      | _ -> failwith \"get_weight retval is incorrect\"\n    )\n  | +1 -> (match (scales#get_weight [3] [4]) with\n      | -1 -> 3\n      | +1 -> 4\n      |  0 -> 5 \n      | _ -> failwith \"get_weight retval is incorrect\" \n    )\n  | 0 -> (match (scales#get_weight [6] [7]) with\n      | -1 -> 6\n      | +1 -> 7 \n      | _ -> failwith \"get_weight retval is incorrect\" \n    )\n  | _ -> failwith \"get_weight retval is incorrect\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"544047f0cf362503e000036e":[{"id":216620,"user_id":null,"body":"let find_ball scales =\n\n  let rec loop i = \n    if i >= 8 then raise Not_found else\n\n    let left_pan  = [ i ] and\n        right_pan = [i+1] in\n    let w = scales#get_weight left_pan right_pan in\n    if w < 0 then List.hd left_pan  else\n    if w > 0 then List.hd right_pan else\n    loop (i+2) in\n\n  loop 0\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216621,"user_id":null,"body":"let find_ball scales =\n    let w1 = if scales#get_weight [1; 3; 5; 7] [0; 2; 4; 6]  < 0 then 1 else 0 in\n    let w2 = if scales#get_weight [2; 3; 6; 7] [0; 1; 4; 5] < 0 then 2 else 0 in\n    let w3 = if scales#get_weight [4; 5; 6; 7] [0; 1; 2; 3] < 0 then 4 else 0 in\n    w1 + w2 + w3\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216622,"user_id":168,"body":"open Batteries\n\nlet find_ball scales =\n  0 -- 3\n  |> Enum.map (( * ) 2)\n  |> Enum.find_map (fun i -> \n      match scales#get_weight [i] [i + 1] with\n      | -1 -> Some i\n      | 1 -> Some (i + 1)\n      | _ -> None)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216623,"user_id":53,"body":"let find_ball scales =\n\n  let rec loop i = \n    if i >= 8 then raise Not_found else\n    let l = [i] in\n    let r = [i+1] in\n    let n = scales#get_weight l r in\n      if n < 0 then List.hd l else\n      if n > 0 then List.hd r else\n      loop (i+2) in\n\n  loop 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54404a06cf36258b08000364":[{"id":216624,"user_id":null,"body":"let gen_range a b =\n  let rec inner x acc =\n    if x <= b then inner (x + 1) (x :: acc)\n    else acc\n  in\n  inner a []\n\nlet find_ball scales =\n  let rec loop low high =\n    if low == high then low\n    else\n      let mid = low + (high - low) \/ 2 in\n      let left_pan = gen_range low mid in\n      let right_pan = gen_range (mid + 1) high in\n      let w = scales#get_weight left_pan right_pan in\n      if w < 0 then loop low mid\n      else loop (mid + 1) high\n  in\n  loop 0 7\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216625,"user_id":null,"body":"let find_ball scales =\n    let w1 = if scales#get_weight [1; 3; 5; 7] [0; 2; 4; 6] < 0 then 1 else 0 in\n    let w2 = if scales#get_weight [2; 3; 6; 7] [0; 1; 4; 5] < 0 then 2 else 0 in\n    let w3 = if scales#get_weight [4; 5; 6; 7] [0; 1; 2; 3] < 0 then 4 else 0 in\n    w1 + w2 + w3\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216626,"user_id":168,"body":"open Batteries\n\nlet find_ball scales =\n  let rec find = function\n    | [x] -> x\n    | xs ->\n      let l, r = List.takedrop (List.length xs \/ 2) xs in\n      let w = scales#get_weight l r in\n      find (if w < 0 then l else r) in\n  find (List.init 8 (fun i -> i))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216627,"user_id":null,"body":"let find_ball scales =\n  let l1 = [0; 1; 2; 3] and\n      r1 = [4; 5; 6; 7] in\n\n  let l2 = [0; 1; 4; 5] and\n      r2 = [2; 3; 6; 7] in\n\n  let l3 = [0; 2; 4; 6] and\n      r3 = [1; 3; 5; 7] in\n\n  let w1 = scales#get_weight l1 r1 and\n      w2 = scales#get_weight l2 r2 and\n      w3 = scales#get_weight l3 r3 in\n\n  let trans = function\n    | -1 -> 0\n    | +1 -> 1\n    | _ -> failwith \"There is no heavier ball !\" in\n\n  4 * trans w1 + 2 * trans w2 + trans w3","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"545c4f7682e55d3c6e0011a1":[{"id":216628,"user_id":null,"body":"let trisect l =\n\n  let rec loop k (b1, b2, b3) = function\n    | [] -> k, (b1, b2, b3)\n    | a :: l -> loop (k+1) (match k mod 3 with\n                            | 0 -> (a :: b1, b2, b3)\n                            | 1 -> (b1, a :: b2, b3)\n                            | _ -> (b1, b2, a :: b3)) l in\n\n  match loop 0 ([], [], []) l with\n  | k, (a :: l1, l2, l3) when k mod 3 = 1 -> (l1, l2, a :: l3)\n  | _, lll -> lll\n\n\nlet find_ball scales ball_count =\n\n  let rec loop l =\n    if List.compare_length_with l 1 = 0 then List.hd l else\n    let l1, l2, l3 = trisect l in\n    loop [|l1; l3; l2|].(scales#get_weight l1 l2 + 1) in\n\n  loop @@ List.init ball_count @@ fun i -> i\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216629,"user_id":null,"body":"(* Syntax : scales#get_weight [0] [1] *)\n\nlet find_ball scales ball_count =\n  let open Core in\n  let rec inner idxs =\n    let length = List.length idxs \/\/ 3 |> Float.round_up |> Int.of_float in\n    let groups = List.chunks_of ~length idxs in\n    match groups with\n    | [a; b; c] -> get_result a b ~c\n    | [a; b] -> get_result a b\n    | _ -> failwith \"Impossible Grouping\"\n    \n  and get_result ?c a b =\n    let w = scales#get_weight a b in\n    match (w, a, b, c) with\n    | (-1, [v], _, _) -> v\n    | (-1, _, _, _) -> inner a\n    | (0, _, _, Some([v])) -> v\n    | (0, _, _, Some(cl)) -> inner cl\n    | (_, _, [v], _) -> v\n    | _ -> inner b\n  in\n  List.range 0 ball_count\n  |> inner\n  \n  \n\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216630,"user_id":168,"body":"open Batteries\n\nlet find_ball scales ball_count =\n  let rec find xs =\n    let k = (List.length xs + 2) \/ 3 in\n    match List.ntake k xs with\n    | [[x]] -> x\n    | [left; right] ->\n      find (match scales#get_weight left right with\n            | -1 -> left\n            | 1 -> right\n            | _ -> failwith \"error\")\n    | [left; right; rest] ->\n      find (match scales#get_weight left right with\n            | -1 -> left\n            | 1 -> right\n            | _ -> rest)\n    | _ -> failwith \"error\" in\n  find (List.init ball_count (fun i -> i))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216631,"user_id":98,"body":"let slice list start stop = (* why isnt this in the List module ._. *)\n\tlet stop_idx = min stop (List.length list) in\n\tlet rec slice_rec i sliced =\n\t\tif i >= stop_idx then\n\t\t\tList.rev sliced\n\t\telse if i >= start then\n\t\t\tslice_rec (i + 1) ((List.nth list i) :: sliced)\n\t\telse\n\t\t\tslice_rec (i + 1) sliced\n\tin slice_rec 0 []\n;;\n\nlet find_ball scales ball_count =\n\tlet rec find_ball_rec balls =\n\t\tlet length = List.length balls in\n\t\tif length = 1 then\n\t\t\tList.nth balls 0\n\t\telse if length = 2 then\n\t\t\tmatch scales#get_weight [List.nth balls 0] [List.nth balls 1] with\n\t\t\t| -1 -> List.nth balls 0\n\t\t\t| +1 -> List.nth balls 1\n\t\t\t|  _ -> failwith \"get_weight returned 0\"\n\t\telse\n\t\t\tlet n = (length + 1) \/ 3 in\n\t\t\tlet left  = slice balls 0 n in\n\t\t\tlet right = slice balls n (2 * n) in\n\t\t\tlet rest  = slice balls (2 * n) length in\n\n\t\t\tmatch scales#get_weight left right with\n\t\t\t| -1 -> find_ball_rec left\n\t\t\t| +1 -> find_ball_rec right\n\t\t\t|  0 -> find_ball_rec rest\n\t\t\t|  _ -> failwith \"get_weight retval is not in {-1, 0, +1}\"\n\n\tin find_ball_rec (List.init ball_count (fun x -> x))\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54d496788776e49e6b00052f":[{"id":216632,"user_id":53,"body":"let sum_of_divided (lst: int list): string = \n  let sum ls = List.fold_left (+) 0 ls in\n  let divides a b = (a mod b = 0) in\n  let rec factors acc k n =\n    if k > n then \n      List.rev acc\n    else if n mod k = 0 then\n      factors (k :: acc) k (n \/ k)\n    else\n      factors acc (succ k) n in\n  let ps = List.map (fun e -> factors [] 2 (abs e)) lst \n    |> List.flatten \n    |> BatList.unique\n    |> List.sort compare in\n  let f e = List.filter (fun p -> divides p e) lst |> sum\n  in\n    List.map (fun e -> Printf.sprintf \"(%d %d)\" e (f e)) ps \n    |> String.concat \"\"\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216633,"user_id":null,"body":"let isPrime x = \n  let ans = ref true in\n  for i = 2 to int_of_float(sqrt(float_of_int(x))) do\n    if x mod i =0 then ans:=false done; !ans;;\n\nlet rec sum l x = match l with \n  |[]-> 0\n  |p::q when p mod x =0 -> p + (sum q x)\n  |p::q -> sum q x\n;;\n\nlet rec check l x  = match l with\n  |[]->false\n  |p::q when p mod x = 0 -> true\n  |p::q -> check q x ;;\n\nlet head l = match l with\n  |p::q->p;;\n\nlet rec max l best = match l with\n  |[]-> best\n  |p::q -> if abs(p)>abs(best) then (max q p) else (max q best);;\n\nlet sum_of_divided (xs: int list): string =\n  let temp = ref 0 in\n  let ans = ref \"\" in\n  for i = 2 to (abs(max xs (head xs))) do\n    if (isPrime i && (check xs i)) then (temp:=sum xs i; ans:= !ans^\"(\"^(string_of_int i)^\" \"^(string_of_int !temp)^\")\");\n\n  done; \n  !ans;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216634,"user_id":null,"body":"let sum_of_divided (xs: int list): string =\n  if xs = [] then \"\" else\n\tlet n = xs |> List.map abs |> List.fold_left max min_int in\n\tlet t = Array.make (n-1) true in\n\tfor i = 2 to (Float.to_int (Float.sqrt (Float.of_int n)) + 1) do\n\t\tlet j = ref (2*i) in\n\t\twhile !j <= n do\n\t\t\tt.(!j-2) <- false;\n\t\t\tj := !j+i done; done;\n\tlet primes = fst (Array.fold_right (fun bool buff -> if bool then\n\t \t\t\t\t\t\t\t\t\t\t\t((snd buff)::(fst buff), snd buff - 1) else\n\t \t\t\t\t\t\t\t\t\t\t\t(fst buff, snd buff - 1)) t ([], n))\n\tin primes |> List.map (fun p ->  (p, (List.fold_left (fun s k -> if k mod p = 0 then s+k else s) 0 xs)))\n\t\t\t  |> List.filter (function | (_, 0) -> false | _ -> true)\n\t\t\t  |> List.map (fun tpl -> \"(\" ^ (tpl |> fst |> string_of_int) ^ \" \" ^ (tpl |> snd |> string_of_int) ^ \")\")\n\t\t\t  |> String.concat \"\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216635,"user_id":null,"body":"let rec is_prime d x = d * d > x || (x mod d <> 0 && is_prime (d + 1) x);;\nlet rec primes a b = if a > b then [] else primes (a + 1) b |> fun rest -> if is_prime 2 a then a :: rest else rest;;\n\nlet sum_of_divided (xs: int list): string = \n  let get_sum_by_factor x lst =\n    let found = List.filter (fun a -> a mod x = 0) lst in\n      if found = [] then None else Some (List.fold_left ( + ) 0 found) in\n  let rec max_in_list mx = function [] -> mx | h :: t -> max (abs h) (max_in_list mx t) in\n  let rec list_to_string = function [] -> \"\" | (a, Some b) :: rest -> \"(\" ^ string_of_int a ^ \" \" ^ string_of_int b ^ \")\" ^ list_to_string rest in\n  primes 2 (max_in_list 0 xs)\n    |> List.map (fun x -> (x, get_sum_by_factor x xs))\n    |> List.filter (fun (a, b) -> b <> None)\n    |> list_to_string;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216636,"user_id":null,"body":"\n\nlet get_sqrt n = if n >= 0 then int_of_float ((float_of_int n) ** 0.5) else int_of_float ((float_of_int (-n)) ** 0.5)\n\nlet get_abs n = if n >= 0 then n else -n\n               \nlet crible n =\n  let l = Array.init (n + 1) (fun i -> if i < 2 then false else true) in\n  let j = ref 0 in\n  for i = 2 to get_sqrt (n + 1) do\n    if l.(i) then\n      j := 2 * i;\n      while !j <= n do\n        l.(!j) <- false;\n        j := !j + i;\n      done\n  done;\n  l\n\n\nlet sum_of_divided (xs: int list): string = \n  let my_max = function\n    [] -> invalid_arg \"empty list\"\n  | x::xs -> List.fold_left max (get_abs x) (List.map get_abs xs)\n  in\n  let max = my_max xs \n  in\n  let c = crible max\n  in\n  let rec next_p p = if p > max then 0 else if c.(p) then p else next_p (p + 1)\n  in\n  let rec builder acc cur_lst p sum seen =\n    if p = 0 then String.concat \"\" (List.rev acc) else\n      match cur_lst with\n        [] -> if seen then builder ((Format.sprintf \"(%d %d)\" p sum)::acc) xs (next_p (p + 1)) 0 false else builder acc xs (next_p (p + 1)) 0 false \n      | hd::tl -> (match hd mod p, seen with\n                   | 0, _ -> builder acc tl p (sum + hd) true\n                   | r -> builder acc tl p sum seen)\n  in\n  builder [] xs 2 0 false\n\n  (* your code *);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216637,"user_id":480,"body":"\nlet factors m =\n  let rec aux (d:int) (m:int) :int list=\n    if d>m then [] else \n    let d1=(if d==2 then 3 else (d+2)) and q=(m\/d) and r=(m mod d) in\n    if r>0 then aux d1 m else [d]@(\n      if q==1 then [] else if q<=d then [q] else aux d q\n    ) \n    in\n  let f=aux 2 m in\n  f;;\n  \n  let sum_of_divided (xs: int list): string = \n    let f=List.map (fun (x:int)->(x,factors (abs x))) xs in\n    let f1=List.fold_left (fun acc (a,b)->acc@b) [] f in\n    let f2=List.sort_uniq (fun a b->a-b) f1 in\n    let f3=List.map (fun d->[d;List.fold_left (fun acc x->acc+(if x mod d==0 then x else 0)) 0 xs]) f2 in\n    let f4=List.map (fun pair->(String.concat \" \" (List.map string_of_int pair))) f3 in\n    let f4=List.map (fun x->String.concat \"\" [\"(\";x;\")\"]) f4 in\n    String.concat \"\" f4; \n    ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216638,"user_id":null,"body":"module Int = \n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end\n\n\nmodule IntSet = Set.Make(Int)\n\n\nmodule IntMap = Map.Make(Int)\n\n\nlet find_largest_exponent n p =\n    let rec loop k exponent =\n        if k mod p <> 0 then (k, exponent)\n        else loop (k \/ p) (exponent + 1)\n    in loop n 0\n\n\nlet prime_factors n =\n    let rec loop k p factors =\n        if k = 1 || p > k then factors\n        else\n            let p' = if p = 2 then p + 1 else p + 2 in\n            let remainder, exponent = find_largest_exponent k p in\n            if exponent = 0 then loop remainder p' factors\n            else loop remainder p' (IntSet.add p factors)\n    in loop n 2 IntSet.empty\n\n\nlet sum_of_divided (xs: int list): string = \n    let factors = List.map (fun n -> prime_factors (abs n)) xs in\n    let all_factors = List.fold_left IntSet.union IntSet.empty factors in\n    let add_prime_to_mapping acc p = \n        let sum = List.fold_left2 (fun s n ps -> if IntSet.mem p ps then s + n else s) 0 xs factors in\n        IntMap.add p sum acc in\n    let primes_to_numbers = IntSet.fold (fun p acc -> add_prime_to_mapping acc p) all_factors IntMap.empty in\n    let result = IntMap.bindings primes_to_numbers in\n    result \n        |> List.map (fun (p, s) -> \"(\" ^ string_of_int p ^ \" \" ^ string_of_int s ^ \")\")\n        |> String.concat \"\"\n        ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216639,"user_id":null,"body":"module Int = struct\n  type t = int\n  let compare = Stdlib.compare\nend;;\n\nmodule IntMap = Map.Make(Int);;\n\nlet rec remove_all_factors n i = if n mod i != 0 then n else remove_all_factors (n \/ i) i;;\n\nlet rec factors i r n =\n  if n < 0 then\n    factors i r (-n)\n  else if i * i > n then\n    List.rev (if n != 1 then n::r else r)\n  else\n    if n mod i = 0 then\n      factors (i+1) (i::r) (remove_all_factors n i)\n    else\n      factors (i+1) r n;;\n\nlet lazy_add n x = \n  match x with\n    None   -> Some n\n  | Some y -> Some (n+y);;\n\nlet lazy_update n m x = IntMap.update x (lazy_add n) m;;\n\nlet update_factor_map m x =\n  List.fold_left (lazy_update x) m (factors 2 [] x);;\n\nlet string_of_factor f = match f with\n  (a, b) -> \"(\" ^ (string_of_int a) ^ \" \" ^ (string_of_int b) ^ \")\";;\n\nlet sum_of_divided (xs: int list): string = \n  String.concat \"\" @@ List.map string_of_factor @@ IntMap.bindings @@ List.fold_left update_factor_map IntMap.empty xs;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216640,"user_id":null,"body":"let prime_factors x =\n  let x = abs x in\n  let rec inner c p =\n    if p < c *c then [p]\n    else if p mod c = 0 then c :: inner c (p \/ c)\n    else inner (c + 1) p\n  in\n  inner 2 x\n\nlet sum_of_divided (xs: int list): string = \n  let open Core in\n  let pf_no_dups x = prime_factors x |> List.remove_consecutive_duplicates ~equal:(=) in\n  let m = Map.empty (module Int) in\n  let su v u = match u with | None -> v | Some a -> a + v in\n  let ob = Buffer.create 32 in\n  \n  List.concat_map xs ~f:(fun x -> List.map ~f:(fun y -> (y, x)) (pf_no_dups x))\n  |> List.fold_left ~init:m ~f:(fun m (k, v) -> Map.update m k ~f:(su v))\n  |> Map.to_alist ~key_order:`Increasing\n  |> List.iter ~f:(fun (k, v) -> Buffer.add_string ob (sprintf \"(%d %d)\" k v));\n  Buffer.contents ob","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216641,"user_id":null,"body":"let isPrime i =\n  let bound = float_of_int i |> sqrt |> int_of_float in\n  let rec _rec j =\n    if j > bound then true else\n      if i mod j = 0 then false else _rec (j + 1)\n  in\n  _rec 2\n;;\n\nlet nextPrime n =\n  let rec _rec i =\n    if isPrime i then i else _rec (i + 1)\n  in\n  _rec (n + 1)\n;;\n\nlet primeFactors n =\n  let n = abs n in\n  let rec _rec p =\n    if p > n then\n      []\n    else\n      if n mod p = 0 then\n        p :: _rec (nextPrime p)\n      else\n        _rec (nextPrime p)\n  in\n  _rec 2\n;;\n\nlet sum_of_divided (xs: int list): string =\n  let xxs = List.map (fun x -> (x, primeFactors x)) xs in\n  let rec _rec xxs =\n    let xxs = xxs |> List.filter (function | (_, []) -> false\n                                           | _ -> true)\n    in\n    match xxs with\n    | [] -> []\n    | _ ->\n       let least =\n         let firsts =\n           xxs\n           |> List.map (function (_, xs) -> List.hd xs)\n         in\n         match firsts with\n         | [] -> raise @@ Failure \"empty firsts\"\n         | x::[] -> x\n         | x::xs -> List.fold_left min x xs\n       in\n       let (sum, xxs') =\n         List.fold_left (fun a i (* : int * (int * int list) list *)->\n             match a with\n             | (sum, xxs') ->\n                match i with\n                | (_, []) -> (sum, xxs') (* not possible *)\n                | (x, y::ys) when y = least ->\n                   (sum + x, if ys = [] then xxs' else (x, ys)::xxs')\n                | (x, ys) -> (sum, (x, ys)::xxs')\n           ) (0, []) xxs\n       in\n       (least, sum) :: (_rec xxs')\n  in\n  _rec xxs\n  |> List.map (function (a, sum) -> Printf.sprintf \"(%d %d)\" a sum)\n  |> String.concat \"\"\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54d512e62a5e54c96200019e":[{"id":216642,"user_id":53,"body":"open Printf;;\n\nlet rec walk (l: int) (i: int) (n: int) (cnt: int) (fs: string list): string list =\n  if i > n && l == 0 then fs\n  else if n mod i == 0 then walk 1 i (n \/ i) (cnt + 1) fs\n  else if cnt == 1 then walk 0 (i + 1) n 0 (List.append fs [sprintf \"(%d)\" i])\n  else if cnt > 1 then walk 0 (i + 1) n 0 (List.append fs [sprintf \"(%d**%d)\" i cnt])\n  else walk 0 (i + 1) n 0 fs\n  ;;\n\nlet prime_factors (n: int): string =\n  let ls = walk 0 2 n 0 [] in\n  if (List.length ls) == 0 then\n    sprintf \"(%d)\" n\n  else\n    ls |> String.concat \"\"\n  ;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216643,"user_id":168,"body":"let rec factors acc k n =\n  if k > n then \n    List.rev acc\n  else if n mod k = 0 then\n    factors (k :: acc) k (n \/ k)\n  else\n    factors acc (succ k) n\n\nlet prime_factors (n: int): string =\n  let fs = factors [] 2 n in\n  let combine a = function\n    | (p, n) :: xs when p = a -> (p, n + 1) :: xs\n    | xs -> (a, 1) :: xs in\n  let str (p, n) =\n    if n > 1 then Printf.sprintf \"(%d**%d)\" p n\n    else Printf.sprintf \"(%d)\" p in\n  List.fold_right combine fs []\n    |> List.map str\n    |> String.concat \"\"\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216644,"user_id":492,"body":"let prime_factors (n: int): string =\n  let prime_factorsAux (n: int) =\n    let rec loop (n: int) (divisor: int) acc =\n      match n with\n        | 1 -> acc\n        | _ -> \n            if (n mod divisor = 0) then\n              loop (n \/ divisor) divisor (divisor :: acc)\n            else loop n (divisor + 1) acc in\n      loop n 2 [] |> countBy (fun x -> x) |> List.sort compare in\n    prime_factorsAux n |>\n    List.map (fun (x, y) -> \n               if (y = 1) then Printf.sprintf \"(%d)\" x\n               else Printf.sprintf \"(%d**%d)\" x y) |> String.concat \"\";;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216645,"user_id":null,"body":"let rec div_n n d c =\n  if n mod d = 0\n  then div_n (n \/ d) d (c + 1)\n  else c\n\nlet prime_factors n =\n  let open Printf in\n  let rec aux n d =\n    if d  > n\n    then \"\"\n    else\n      let c = div_n n d 0 in\n      if c = 1\n      then sprintf \"(%d)\" d ^ aux (n \/ d) d\n      else if c > 1\n      then sprintf \"(%d**%d)\" d c ^ aux (n \/ BatInt.pow d c) d\n      else if c = 0 \n      then aux n (d + 1)\n      else failwith (sprintf \"%d not suppose to be negative\" c) in\n  aux n 2","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216646,"user_id":294,"body":"let rec prime_factors x =\n    prime_factors_of x\n    |> List.map (function\n                | (d, 1) -> Printf.sprintf \"(%d)\" d\n                | (d, p) -> Printf.sprintf \"(%d**%d)\" d p)\n    |> String.concat \"\"\n\n\nand least_divisor_of x =\n    let rec recur d =\n        if x mod d = 0 then d\n        else if d * d > x then x\n        else recur (d + 1)\n    in recur 2\n\n\nand prime_factors_of x =\n    let rec divide_repeatedly_by d x =\n        let rec recur power d x =\n            if x mod d = 0 then recur (power + 1) d (x \/ d)\n            else (power, x)\n        in recur 0 d x\n    in\n    let rec recur = function\n    | 1 -> []\n    | x ->\n        let d = least_divisor_of x in\n        let p, x' = divide_repeatedly_by d x\n        in (d, p) :: recur x'\n    in recur x\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216647,"user_id":null,"body":"let factors (n : int) : (int * int) list =\n  let rec aux d n =\n    if n = 1\n    then []\n    else if n mod d = 0\n    then (\n      match aux d (n \/ d) with\n      | [] -> [ d, 1 ]\n      | (h, k) :: tl when h = d -> (h, k + 1) :: tl\n      | xs -> (d, 1) :: xs)\n    else aux (d + 1) n\n  in\n  aux 2 n\n;;\n\nlet string_of_factor (f, m) =\n  let power = if m = 1 then \"\" else \"**\" ^ string_of_int m in\n  \"(\" ^ string_of_int f ^ power ^ \")\"\n;;\n\nlet prime_factors (n : int) : string =\n  factors n |> List.map string_of_factor |> String.concat \"\"\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216648,"user_id":null,"body":"let rec find x l =\n  match l with\n    |[] -> false\n    |h::q when h = x -> true\n    |_::q -> find x q;;\n\nlet rec remove_dup l =\n  match l with\n    |[] -> []\n    |h::q when find h q -> (remove_dup q)\n    |h::q -> h::(remove_dup q);;\n\n\nlet rec count x l =\n  match l with\n    |[] -> 0\n    |h::q when h = x -> 1 + (count x q)\n    |_::q -> count x q;;\n\nlet prime_factors n =\n  let liste =\n    let rec division_test n i=\n      if n <= 1 then []\n      else if n mod i = 0 then i :: division_test (n\/i) 2\n      else division_test n (i+1)\n      in division_test n 2\n    in let rec mult new_liste =\n    match new_liste with\n      |[] -> \"\"\n      |m::r -> let n = count m liste in\n            if n > 1 then\n                    \"(\" ^ (string_of_int m) ^ \"**\" ^ (string_of_int (n)) ^ \")\" ^ (mult r)\n            else \"(\" ^ (string_of_int m) ^ \")\" ^ (mult r)\n      in mult (remove_dup liste);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216649,"user_id":null,"body":"let rec find x l =\n  match l with\n    |[] -> false\n    |h::q when h = x -> true\n    |_::q -> find x q;;\n\nlet rec remove_dup l =\n  match l with\n  |[] -> []\n  |h::q when find h q -> (remove_dup q)\n  |h::q -> h::(remove_dup q);;\n\n\nlet rec count x l =\n  match l with\n    |[] -> 0\n    |h::q when h = x -> 1 + (count x q)\n    |_::q -> count x q;;\n\nlet prime_factors n =\n  let liste =\n    let rec division_test n i=\n      if n <= 1 then [n]\n      else if n mod i = 0 then i :: division_test (n\/i) 2\n      else division_test n (i+1)\n    in division_test n 2\n  in let rec mult new_liste =\n  match new_liste with\n    |[] -> \"\"\n    |m::r when m <> 1 -> let n = count m liste in\n              if n > 1 then\n                  \"(\" ^ (string_of_int m) ^ \"**\" ^ (string_of_int (n)) ^ \")\" ^ (mult r)\n              else \"(\" ^ (string_of_int m) ^ \")\" ^ (mult r)\n    |_ -> \"\"\n    in mult (remove_dup liste);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216650,"user_id":null,"body":"let isPrime m =\n  let lim = int_of_float(sqrt(float_of_int(m))) in\n  let ans = ref true in\n  let i = ref 2 in\n  while !ans && (!i < lim+1) do\n    if (m mod !i = 0) then\n      ans := false ; \n    incr i;\n  done;\n  !ans;;\n\nlet prime_factors (m: int): string =\n  let ans = ref \"\" in \n  let temp = ref m in\n  let max = ref m in\n  let i = ref 2  in\n  \n  while !i <= !max do\n    if(isPrime(!temp)) then \n      (ans:= ((!ans)^\"(\"^string_of_int(!temp)^\")\");i:=(!max)+1)\n    else\n      \n      (if( isPrime(!i) && !temp mod !i = 0)then\n         (let count = ref 0 in\n          while(!temp mod !i = 0) do (temp:= !temp\/(!i); incr count) done;\n          if(!count = 1) then \n            (ans:= ((!ans)^\"(\"^string_of_int(!i)^\")\"))\n          else\n            ans:= ((!ans)^\"(\"^string_of_int(!i)^\"**\"^string_of_int(!count)^\")\");\n          max:= !temp\n         ); \n       incr i;);\n  done;\n  !ans;;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216651,"user_id":null,"body":"let isqrt a = a|>float|>sqrt|>int_of_float\n\nlet rec is_prime k p  = if (k>((isqrt p) + 1))||(p=2) then true \n                    else if (p mod k =0 ) then false\n                    else is_prime (k+1) p\n\nlet rec pf_arr n arr p = if (is_prime 2 p)&&(n mod p =0) then (pf_arr (n\/p) (p::arr) p)\n                      else if n=1 then arr  \n                      else if p>((isqrt n) + 1) then (n::arr)\n                      else pf_arr n arr (p+1)\n\nlet rec group_factors arr_in arr_out =  \n    match (arr_in,arr_out) with\n    |(h::t, []) ->group_factors t [(h,1)]\n    |(h::t,(a,b)::l) -> if a=h then group_factors t ((a,b+1)::l)\n                        else group_factors t ((h,1)::(a,b)::l)\n    |([],_) -> arr_out\n\nlet rec print_factors gf s = \n    match gf with\n    |[] -> s\n    |(a,b)::t -> if b=1 then print_factors t (s ^ \"(\" ^ (string_of_int a) ^ \")\")\n                  else print_factors t (s ^ \"(\" ^ (string_of_int a) ^ \"**\"^(string_of_int b)^\")\")\n\nlet prime_factors (n: int): string =\n                  let arr = (pf_arr n [] 2) in\n                  let gf = group_factors arr [] in \n                  print_factors gf \"\"\n  (* your code *);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54d7660d2daf68c619000d95":[{"id":216652,"user_id":53,"body":"\nlet rec gcd (u: int) (v: int) :int = \n  if v == 0 then u else gcd v (u mod v);;\n\nlet lcm (m: int) (n: int) :int = \n  m * n \/ (gcd m n);;\n  \nlet reduce (a: int) (b: int) :(int * int) = \n  let i = gcd a b in\n  (a \/ i, b \/ i);;\n  \nlet norm (a: int) (b: int) (cd: int) :(int * int) = \n  (a * cd \/ b, cd);;\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let xss = List.map (fun xs -> reduce (fst xs) (snd xs)) ls in\n  let cd = List.fold_left (fun acc xs -> lcm (snd xs) acc) 1 xss in\n  let yss = List.map (fun xs -> norm (fst xs) (snd xs) cd) xss in\n  yss;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216653,"user_id":168,"body":"let rec gcd u v =\n  if v = 0 then u\n  else gcd v (u mod v)\n\nlet lcm m n = \n  if m = 0 || n = 0 then 0\n  else m * n \/ gcd m n\n  \nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let s = List.map\n    (fun (n, d) ->\n      let v = gcd n d in n \/ v, d \/ v) ls in\n  let v = List.fold_left\n    (fun r (_, d) -> lcm r d) 1 s in\n  List.map (fun (n, d) -> (v \/ d) * n, v) s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216654,"user_id":492,"body":"let convert_frac (ls: (int * int) list): (int * int) list =\n  let rec gcdi u v = if v <> 0 then (gcdi v (u mod v)) else (abs u) in\n  let lcmu m n =\n    match m, n with\n      | 0, _ | _, 0 -> 0\n      | m, n -> abs (m * n) \/ (gcdi m n)\n  in\n  let simply ls =\n    List.map (fun (x, y) -> let g = gcdi x y in x\/g, y\/g) ls in\n  let sls = simply ls in\n  let denoml = List.map (fun (x, y) -> y) sls in \n  let den = List.fold_left (lcmu) 1 denoml in\n    List.map (fun (x, y) -> x * (den \/ y), den) sls;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216655,"user_id":null,"body":"let pgcd a b =\n  let rec aux x y =\n    if y = 0 then x else\n      aux y (x mod y) in\n  abs (aux (max a b) (min a b))\n\nlet ppcm a b =\n  abs (a * b \/ pgcd a b)\n\nlet simplify_frac (n, d) =\n  match pgcd n d with\n  | 1 -> (n, d)\n  | p -> (n\/p, d\/p)\n\nlet convert_frac ls =\n  let l = List.map simplify_frac ls in\n  let pcm = List.fold_left (fun p (_, d) -> ppcm p d) 1 l in\n  List.map (fun (n, d) -> (n * pcm \/ d, pcm)) l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216656,"user_id":null,"body":"\nlet rec pgcd n m =\n  if n > m then pgcd m n\n  else if n = 0 then m\n       else let r = m mod n in\n            pgcd r n\n            \nlet rec get_commun n1 n2 d1 d2 = match d1, d2 with\n    d, 1 | 1, d -> d\n    | _, _ ->\n       let dn1 = d1 * n1 and dn2 = d2 * n2 in\n       if dn1 = dn2 then dn1\n       else\n         if dn1 > dn2 then get_commun n1 (n2+1) d1 d2\n         else get_commun (n1+1) n2 d1 d2\n\nlet rec get_commun_l acc dL = match dL with\n    [] -> acc\n  | hd::tl -> let d = get_commun_l acc tl in get_commun 1 1 hd d \n                                   \nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let ls = List.map (fun (x, y) -> let gcd = pgcd x y in (x\/gcd, y\/gcd)) ls in\n  let num, den = List.split ls in\n  let d = get_commun_l 1 den in\n  List.map (fun (x, y) -> (x*d\/y, d)) ls\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216657,"user_id":null,"body":"let convert_frac (ls: (int * int) list): (int * int) list =\n    let rec calc_gcd a b = \n        if b = 0 then a else calc_gcd b (a mod b) in\n    let calc_lcm a b = \n        let gcd = calc_gcd a b in \n        (a \/ gcd) * b in\n    let simplify (p, q) = \n        let g = calc_gcd p q in (p \/ g, q \/ g) in\n    let reduced_fractions = List.map simplify ls in\n    let denominators = snd @@ List.split reduced_fractions in\n    let d = List.fold_left calc_lcm 1 denominators in\n    List.map (fun (p, q) -> ((d \/ q) * p, d)) reduced_fractions\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216658,"user_id":98,"body":"         \nlet rec pgcd a b =\n  \tif abs b > abs a \n  \t\tthen pgcd b a\n    else if b=0\n\t\tthen abs a \n   else pgcd b (a mod b) \n ;;\n\nlet ppcm a b = (abs(a*b))\/(pgcd a b ) ;;\n\nlet ppcm_of_liste l =\n\tlet rec recursivite l ppcm_liste =\n\tmatch l with \n\t| []-> 0\n\t| (a,b)::[] -> ppcm ppcm_liste b \n\t| (a,b)::t  -> (recursivite t  (ppcm b ppcm_liste))\n\tin recursivite l 1 \n;; \n\nlet rec rend_irreductibles l =\n\tmatch l with\n\t| []->[]\n\t| (a,b)::t->let pgcd_ab = pgcd a b in\n\t\t\t\t(a\/pgcd_ab,b\/pgcd_ab)::rend_irreductibles t \n;;\nlet  convert_frac (ls: (int * int) list): (int * int) list =\n\tlet irreductibles = rend_irreductibles ls in\n\tlet ppcm_liste = ppcm_of_liste irreductibles in\n\tlet rec recursivite l =\n\t\tmatch l with \n\t\t| [] ->[]\n\t\t| (a,b)::t -> (a*ppcm_liste\/b,ppcm_liste)::(recursivite t)\n\tin recursivite irreductibles\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216659,"user_id":null,"body":"# 2\nlet rec gcd a b = (* gcd code from https:\/\/rosettacode.org\/wiki\/Greatest_common_divisor#OCaml*)\n  match (a mod b) with\n    0 -> b\n  | r -> gcd b r\nlet lcm a b = a * b \/ gcd a b\nlet redenom newd (n,d) = (n * newd \/ d, newd)\nlet reduce (n,d) = let g = gcd n d in (n\/g, d\/g)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let ls = List.map reduce ls in\n  let lcm_all = List.fold_left (fun acc (_,d) -> lcm acc d) 1 ls in\n  List.map (redenom lcm_all) ls\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216660,"user_id":null,"body":"let rec gcd u v =\n  if v <> 0 then (gcd v (u mod v))\n  else (abs u)\n \nlet lcm m n =\n  match m, n with\n  | 0, _ | _, 0 -> 0\n  | m, n -> abs (m * n) \/ (gcd m n)\n\nlet compute_common_lcm ls =\n  ls\n    |> (List.map (fun (_, denum) -> denum))\n    |> (List.fold_left lcm 1)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let simplified_ls = List.map (fun (num, denum) ->\n    let item_gcd = gcd num denum in\n    (num \/ item_gcd, denum \/ item_gcd)\n  ) ls in\n  let common_lcm = compute_common_lcm simplified_ls in\n  List.map (fun (num, denum) ->\n    let ratio = common_lcm \/ denum in\n    (num * ratio, common_lcm)\n  ) simplified_ls","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216661,"user_id":null,"body":"let rec gcd a b = \n  if b == 0 then a\n  else gcd b (a mod b)\n\nlet lcm a b = (a * b) \/ (gcd a b)\n\nlet simplify (num, denom) = \n  let d = gcd num denom in\n  (num \/ d, denom \/ d)\n\nlet convert_frac (ls: (int * int) list): (int * int) list =\n  let d = List.fold_left (\n    fun acc (_1, denom) -> lcm denom acc\n  ) 1 (List.map simplify ls)\n  in\n    List.map (\n      fun (num, denom) -> ((num * d) \/ denom, d)\n    ) ls","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54db15b003e88a6a480000b9":[{"id":216662,"user_id":53,"body":"open Printf;;\n\nlet rec gcd (a: int) (b: int) :int = \n  if b == 0 then a else gcd b (a mod b) ;;\n  \nlet from_nb_2_str (n: int) (arr: int list): string =\n  let prd = List.fold_left (fun acc e -> acc * e) 1 arr in\n  let lcm = List.fold_left (fun acc e -> (acc * e) \/ (gcd acc e)) 1 arr in\n  if prd < n || lcm != prd then \"Not applicable\" \n  else List.map (fun e -> sprintf \"-%d-\" (n mod e)) arr |> String.concat \"\" ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216663,"user_id":492,"body":"let from_nb_2_str (n: int) (arr: int list): string =\n  let moduli n arr =\n    List.map (fun x -> string_of_int(n mod x)) arr\n  in\n  let p = List.fold_left ( * ) 1 arr in\n  let g = List.fold_left (lcmu) 1 arr in\n    if p > n && p = g then\n      let r = moduli n arr |> String.concat \"--\" in\n        \"-\" ^ r ^ \"-\"\n    else \"Not applicable\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216664,"user_id":294,"body":"let rec from_nb_2_str (x: int) (mods: int list): string =\n    match from_nb_2 x mods with\n    | None -> \"Not applicable\"\n    | Some ans -> Printf.sprintf \"-%s-\" (String.concat \"--\" (List.map string_of_int ans))\n\n\nand from_nb_2 x mods =\n    let prod = List.fold_left ( * ) 1 mods in\n    \n    if x <= prod && are_coprime mods then\n        let ans = List.map ((mod) x) mods\n        in Some ans\n    else\n        None\n\n\nand are_coprime xs =\n    let has_dups xs =\n        match List.sort compare xs with\n        | [] -> false\n        | x :: xs' ->\n            let pairs, _ = List.fold_left (fun (acc, prev) y -> ((prev, y) :: acc, y)) ([], x) xs'\n            in List.exists (fun (x, y) -> x = y) pairs\n    in\n    let factors = xs |> List.map prime_factors_of |> List.flatten\n    in not (has_dups factors)\n\n\nand prime_factors_of x =\n    let rec recur factors d = function\n    | 1 -> factors\n    | x ->\n        if x mod d = 0 then\n            let x' = x \/ d in\n            \n            if x' mod d = 0 then\n                recur factors d x'\n            else\n                recur (d :: factors) d x'\n        else\n            recur factors (least_divisor_of x) x\n    in recur [] 2 x\n\n\nand least_divisor_of x =\n    let rec recur d =\n        if x mod d = 0 then d\n        else if d * d > x then x\n        else recur (d + 1)\n    in recur 2\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216665,"user_id":null,"body":"\nlet rec gcd a b = if b == 0 then a else gcd b (a mod b)\n\nlet coprime a b = gcd a b == 1\n\nlet rec all_coprime = function\n| [] -> true\n| h::t -> (List.for_all (coprime h) t) && all_coprime t\n\nlet product = List.fold_left ( * ) 1 \n\nlet from_nb_2_str (n: int) (arr: int list): string =\n  if not (all_coprime arr) || product arr < n then \"Not applicable\" \n  else String.concat \"\" (List.map (fun x -> \"-\" ^ (string_of_int (n mod x)) ^ \"-\") arr )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216666,"user_id":null,"body":"let pgcd a b =\n\tlet rec aux x y =\n\t\tif y = 0 then x else aux y (x mod y)\n\tin abs (aux a b);;\n\nlet rec pairs =\n  let rec aux x = function\n      [] -> []\n    | a::q -> (x, a) :: aux x q in function\n    [] -> []\n  | a::q -> aux a q @ pairs q\n\nlet from_nb_2_str (n: int) (arr: int list): string =\n  if List.fold_left ( * ) 1 arr < n\n      || List.exists (fun (a, b) -> pgcd a b <> 1) (pairs arr)\n  then \"Not applicable\" else\n  String.concat \"\" (List.map (fun k -> \"-\" ^ string_of_int (n mod k) ^ \"-\") arr);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216667,"user_id":null,"body":"let from_nb_2_str (n: int) (arr: int list): string =\n  let rec gcd a b =\n    if b = 0 then a else gcd b (a mod b) in\n  let rec gcds_ok l = match l with\n      [] -> true\n    | a::tl -> help a tl && gcds_ok tl\n  and help a l = match l with\n      [] -> true\n    | hd::tl -> if gcd a hd > 1 then false else help a tl \n  in\n  let prod = List.fold_left ( * ) 1 arr in\n  if (prod < n || not (gcds_ok arr)) then \"Not applicable\" else\n    (let l =List.map (fun x -> \"-\" ^ string_of_int (n mod x)^ \"-\") arr in\n     String.concat \"\" l \n    )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216668,"user_id":480,"body":"open List\nopen String\n\nlet rec gcdi  (u: int) (v: int) :int = \n  if v==0 then u else gcdi v (u mod v);;\n  \nlet rec coprimes arr=match arr with\n  | [] -> true\n  | x::arr1 ->\n    let rec coprime1 x arr1=match arr1 with\n    | [] -> true\n    | y::arr2 -> (gcdi x y)==1 && (coprime1 x arr2) in\n    (coprime1 x arr1) && (coprimes arr1)\n    ;;\n\nlet from_nb_2_str (n: int) (arr: int list): string =\n  let rec prod_lt_n p arr=match arr with |[] -> p<n | h::t -> prod_lt_n (p*h) t in\n  if (prod_lt_n 1 arr)||(not (coprimes arr)) then \"Not applicable\" else \n  List.map (fun x->n mod x) arr |> List.map string_of_int|> List.map (fun x-> concat \"\" [\"-\";x;\"-\"])|> String.concat \"\"\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216669,"user_id":null,"body":"let from_nb_2_str (n: int) (ms: int list): string =\n    let rec calc_gcd a b =\n        if b = 0 then a else calc_gcd b (a mod b) in\n    let is_coprime a b = \n        let g = calc_gcd a b in\n        g = 1 in\n    let pairs lst = \n        let rec loop acc = function\n            | ([] | [_]) -> acc\n            | x :: xss -> \n                let x_pairs = List.map (fun y -> (x, y)) xss in\n                loop (acc @ x_pairs) xss in\n        loop [] lst in    \n    let valid_system xs = \n        let ps = pairs ms in\n        let prod = List.fold_left ( * ) 1 ms in\n        prod >= n && List.for_all (fun (x, y) -> is_coprime x y) ps in\n    if valid_system ms then\n        let rs = List.map (fun m -> n mod m) ms in\n        let repr = rs |> List.map string_of_int |> String.concat \"--\" in\n        \"-\" ^ repr ^ \"-\"\n    else \"Not applicable\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216670,"user_id":null,"body":"let rec check_coprimes l =\n  let rec gcd a b =\n    if b = 0 then a else gcd b (a mod b)\n  in\n  let rec check num list = \n    match list with\n    | [] -> true\n    | hd::tl -> \n      if (gcd hd num) > 1 \n        then false \n        else check num tl\n  in\n  match l with\n  | [] -> true\n  | hd::tl -> \n    if (check hd tl) \n      then check_coprimes tl \n      else false\n;;\n\nlet check_product n l = List.fold_left (fun acc x -> acc*x) 1 l > n;;\n\nlet decompose n l =\n  let rec construct res l =\n    match l with\n    | [] -> res\n    | hd::tl -> construct (res ^ \"-\" ^ string_of_int (n mod hd) ^ \"-\") tl\n  in\n  construct \"\" l\n;;\n\nlet from_nb_2_str (n: int) (arr: int list): string =\n  if check_product n arr && check_coprimes arr\n    then decompose n arr\n    else \"Not applicable\"\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216671,"user_id":null,"body":"let from_nb_2_str (n: int) (arr: int list): string =\n  let rec gcd a b = if b = 0 then a else gcd b (a mod b)\n  in let rec coprime = function [] -> true | [x] -> true| hd::tl -> (tl |> List.map (gcd hd) |> List.fold_left ( * ) 1 ) = 1 && coprime tl\n  in if (List.fold_left ( * ) 1 arr) < n || (not (coprime arr)) then \"Not applicable\" \n     else (List.map (fun x -> n mod x) arr) |> List.map string_of_int  |> String.concat \"--\" |> fun x -> \"-\"^x^\"-\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54dc6f5a224c26032800005c":[{"id":216672,"user_id":null,"body":"let dict_to_pairs d = \n  Hashtbl.fold (fun k v acc -> (k, v) :: acc) d [];;\n  \nlet dict_to_string d lcat = \n  lcat\n  |> Array.to_list\n  |> List.map (fun c -> \"(\" ^ c ^\" : \" ^ (string_of_int (Hashtbl.find d c)) ^ \")\")\n  |> String.concat \" - \";;\n\nlet inc_key t k i = \n  if Hashtbl.mem t k then\n    Hashtbl.replace t k ((Hashtbl.find t k) + i)\n  else ()\n\nlet stock s =\n  let strl = String.length s in\n  let new_start = (String.index s ' ') + 1 in\n  let new_length = strl - new_start in\n  let substr = String.sub s new_start new_length in\n    int_of_string substr;;\n\nlet stock_list (lart: string array) (lcat: string array) =\n  if Array.length lart = 0 || Array.length lcat = 0 then \"\"\n  else\n  let cnt = Hashtbl.create (Array.length lcat) in\n  Array.iter (fun x -> Hashtbl.add cnt x 0) lcat;\n    let category x = String.make 1 (String.get x 0) in \n      Array.iter (fun x -> inc_key cnt (category x) (stock x)) lart;\n      dict_to_string cnt lcat\n    \n  (* your code *);;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216673,"user_id":492,"body":"let stock_list (lart: string array) (lcat: string array) =\n  if Array.length lart = 0 || Array.length lcat = 0 then \"\" \n  else\n    let res = ref \"\" in\n      for i = 0 to Array.length lcat - 1 do\n        let cnt = ref 0 in\n        for j = 0 to Array.length lart - 1 do\n          if lart.(j).[0] = lcat.(i).[0] then\n            cnt := !cnt + int_of_string(List.hd (List.tl (Str.split (Str.regexp \" \") lart.(j))));\n        done;\n        if String.length !res <> 0 then \n          res := !res ^ \" - \";\n        res := !res ^ \"(\" ^ lcat.(i) ^ \" : \" ^ string_of_int !cnt ^ \")\";\n      done;\n    !res;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216674,"user_id":null,"body":"let rec stock3 category books counter lenBooks quantity =\n  if counter == lenBooks then \n    \"(\" ^ category ^ \" : \" ^ (string_of_int quantity) ^ \") - \" else \n    let number = List.nth (String.split_on_char ' ' (Array.get books counter)) 1 in\n    let letter = String.get (List.nth (String.split_on_char ' ' (Array.get books counter)) 0) 0 in\n    if (String.get category 0) == letter then\n      stock3 category books (counter+1) lenBooks (quantity + (int_of_string number)) else\n      stock3 category books (counter+1) lenBooks quantity\n;;\n\nlet rec stock2 books categories counter lenCats answer =\n  if counter == lenCats then \n    let lenAns = String.length answer in\n    String.sub answer 0 (lenAns-3) else \n      let category = Array.get categories counter in\n      let lenBooks = Array.length books in\n      stock2 books categories (counter+1) lenCats (answer^(stock3 category books 0 lenBooks 0))\n;;\n\nlet stock_list (lart: string array) (lcat: string array): string =\n  if (Array.length lart)==0 || (Array.length lcat)==0 then \"\" else \n    let lenCats = Array.length lcat in\n    stock2 lart lcat 0 lenCats \"\"\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216675,"user_id":null,"body":"let stock_list (lart: string array) (lcat: string array) : string =\n  let module StringMap = Map.Make(String) in\n  let m : int StringMap.t = StringMap.empty in\n  let m = Array.fold_left\n      (fun m s -> \n         let k = String.sub s 0 1 in\n         let v = List.nth (String.split_on_char ' ' s) 1 |> int_of_string  in\n         if Array.mem k lcat\n         then if StringMap.mem k m\n           then StringMap.add k ((StringMap.find k m) + v) m\n           else StringMap.add k v m\n         else m\n      )\n      m\n      lart in\n  let sum = StringMap.fold\n      (fun _ v acc -> v + acc)\n      m 0 in\n  if sum = 0 \n  then \"\"\n  else\n    let l = Array.fold_left\n        (fun acc cat ->\n           if not (StringMap.mem cat m)\n           then (Printf.sprintf \"(%s : 0)\" cat) :: acc\n           else (Printf.sprintf \"(%s : %d)\" cat (StringMap.find cat m)) :: acc)\n        []\n        lcat in\n    String.concat \" - \" (List.rev l)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216676,"user_id":null,"body":"module SMap = Map.Make(String)\n\nlet stock_list (lart: string array) (lcat: string array) =\n  if Array.length lart = 0 then \"\" else\n  \n  let lart = Array.to_list lart in\n  let lcat = Array.to_list lcat in\n  let filt lcat (art: string) = List.mem art.[0] lcat in\n  let first_char s = s.[0] in\n  let first_str s = String.sub s 0 1 in\n  let cats = List.map first_char lcat in\n  let catss = List.map first_str lcat in\n  let idx_of l e =\n    let rec idx_of_it l e n = match l with\n      | [] -> failwith \"mist\"\n      | x :: xs -> if x = e then n else idx_of_it xs e (n + 1)\n    in idx_of_it l e 0\n  in\n  let comp s0 s1 =\n    (idx_of catss (String.sub s0 1 1)) - (idx_of catss (String.sub s1 1 1))\n  in\n  let start_map = \n    List.fold_left (fun m x -> SMap.add x 0 m) SMap.empty catss\n  in\n  let f mp (tpl: string list) = \n    let cnt = match SMap.find_opt (List.nth tpl 0) mp with\n    | None -> (Stdlib.int_of_string (List.nth tpl 1))\n    | Some x -> (Stdlib.int_of_string (List.nth tpl 1)) + x\n    in\n    SMap.add (List.nth tpl 0) cnt mp\n  in\n  let filt = filt cats in\n  let m = lart\n       |> List.filter filt\n       |> List.map (String.split_on_char ' ')\n       |> List.map (fun x -> [(first_str (List.nth x 0)); (List.nth x 1)])\n       |> List.fold_left f start_map\n  in\n  SMap.fold (fun k v l -> (\"(\" ^ k ^ \" : \" ^ (string_of_int v) ^ \")\") :: l) m []\n  |> List.sort comp\n  |> String.concat \" - \"","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216677,"user_id":null,"body":"let add_book h b =\n  let code = String.sub b 0 1 in\n  let qty  = String.split_on_char ' ' b |> List.rev |> List.hd |> int_of_string in\n  Hashtbl.add h code qty\n\nlet print_sum h c =\n  let sum = Hashtbl.find_all h c |> List.fold_left (+) 0 in\n  Printf.sprintf \"(%s : %d)\" c sum\n\nlet stock_list (lart: string array) (lcat: string array) =\n  match Array.length lart, Array.length lcat with\n  | 0,_ | _,0 -> \"\"\n  | _ -> let hash = Hashtbl.create 23 in\n        lart |> Array.iter (fun book -> add_book hash book);\n        lcat |> Array.to_list |> List.map (fun s -> print_sum hash s) |> String.concat \" - \"","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216678,"user_id":null,"body":"open List\n\nlet stock_list (lart: string array) (lcat: string array) =\n  let b=Array.to_list lart and c=Array.to_list lcat in if b=[]||c=[]then\"\"else c|>map(fun f->\"(\"^f^\" : \"^(string_of_int(fold_left(fun x s->if s.[0]<>f.[0]then x else s|>String.split_on_char ' '|>tl|>hd|>int_of_string|>(+)x)0 b))^\")\")|>String.concat\" - \"","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216679,"user_id":null,"body":"let stock_list (lart: string array) (lcat: string array) =\n  if lart = [||] or lcat = [||] then \"\" else\n  let books = Array.init\n                (Array.length lart)\n                (fun i -> match String.split_on_char ' ' lart.(i) with\n                            | c::[n] -> c.[0], int_of_string n\n                            | _ -> failwith \"...\") in\n  let ca = Array.make (Array.length lcat) 0 in\n  for i = 0 to Array.length lcat - 1 do\n    let init = lcat.(i).[0] in\n    for j = 0 to Array.length books - 1 do\n      if fst books.(j) = init then\n        ca.(i) <- ca.(i) + snd books.(j) done done;\n  List.init (Array.length lcat) (fun i -> \"(\" ^ lcat.(i) ^ \" : \" ^ string_of_int ca.(i) ^ \")\")\n    |> String.concat \" - \";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216680,"user_id":null,"body":"let string_index_is_start s c =\n  match String.index_opt s c with\n  | Some a when a = 0 -> true\n  | _ -> false\n;;\n\nlet stock_list (lart : string array) (lcat : string array) =\n  if Array.length lart = 0\n  then \"\"\n  else (\n    let lart_assoc =\n      List.map\n        (fun x ->\n          match String.split_on_char ' ' x with\n          | hd :: hd' :: _ -> hd, int_of_string hd'\n          | _ -> failwith \"failwith stock_list\")\n        (Array.to_list lart)\n    in\n    let lcat_list = Array.to_list lcat in\n    String.concat\n      \" - \"\n      (List.map\n         (fun x ->\n           let some_list =\n             List.find_all\n               (fun assoc -> string_index_is_start (fst assoc) x.[0])\n               lart_assoc\n           in\n           let acc = List.fold_left (fun accu item -> accu + snd item) 0 some_list in\n           \"(\" ^ x ^ \" : \" ^ string_of_int acc ^ \")\")\n         lcat_list))\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216681,"user_id":null,"body":"let string_index_is_start s c =\n  match String.index_opt s c with\n  | Some a when a = 0 -> true\n  | _ -> false\n;;\n\nlet stock_list (lart : string array) (lcat : string array) =\n  if Array.length lart = 0\n  then \"\"\n  else (\n    let lart_assoc =\n      List.map\n        (fun x ->\n          match String.split_on_char ' ' x with\n          | hd :: hd' :: _ -> hd, int_of_string hd'\n          | _ -> failwith \"failwith stock_list\")\n        (Array.to_list lart)\n    in\n    let lcat_list = Array.to_list lcat in\n    String.concat\n      \" - \"\n      (List.map\n         (fun x ->\n           let some_list =\n             List.find_all\n               (fun assoc -> string_index_is_start (fst assoc) x.[0])\n               lart_assoc\n           in\n           let acc = List.fold_left (fun accu item -> accu + snd item) 0 some_list in\n           \"(\" ^ x ^ \" : \" ^ string_of_int acc ^ \")\")\n         lcat_list))\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54de3257f565801d96001200":[{"id":216682,"user_id":492,"body":"let balance_statements str =\n  let one_order ord =\n    let work ord =\n      let l = Str.split (Str.regexp \" \") ord |> Array.of_list in\n      let qty, price = int_of_string l.(1), float_of_string l.(2) in\n      let buy, sell =\n        if l.(3) = \"B\" then\n          (float_of_int qty) *. price, 0.0\n        else 0.0, (float_of_int qty) *. price in\n        (buy, sell, \"\")\n    in\n\n      if ord = \"\" then (0.0, 0.0, \"\")\n      else\n        let rgxp = Str.regexp \"^[A-Z0-9.]+ [0-9]+ [0-9]*\\\\.[0-9]+ [BS]\" in\n          if Str.string_match rgxp ord 0 then\n            work ord\n          else (0.0, 0.0, ord)\n  in\n\n  let accumulate a =\n    let ill = ref \"\" and buy = ref 0.0 and sell = ref 0.0 in\n      for i = 0 to Array.length a - 1 do\n        let b, s, bad = one_order a.(i) in\n          buy := !buy +. b;\n          sell := !sell +. s;\n          if bad <> \"\" then if !ill <> \"\" then ill := !ill ^ \" ;\" ^ bad else ill := bad;\n      done;\n      !buy, !sell, !ill\n  in\n\n    if str = \"\" then \"Buy: 0 Sell: 0\"\n    else begin\n      let a = Str.split (Str.regexp \", \") str |> Array.of_list in\n      let b, s, il = accumulate a in\n        if il = \"\" then\n          Printf.sprintf \"Buy: %.0f Sell: %.0f\" b s\n        else\n          let cnt = List.length (Str.split (Str.regexp \" ;\") il) in\n            Printf.sprintf \"Buy: %.0f Sell: %.0f; Badly formed %d: %s ;\" b s cnt il\n    end;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216683,"user_id":492,"body":"let balance_statements str =\n  let one_order ord =\n    let work ord =\n      let l = Str.split (Str.regexp \" \") ord |> Array.of_list in\n      let qty, price = int_of_string l.(1), float_of_string l.(2) in\n      let buy, sell =\n        if l.(3) = \"B\" then\n          (float_of_int qty) *. price, 0.0\n        else 0.0, (float_of_int qty) *. price in\n        (buy, sell, \"\")\n    in\n\n      if ord = \"\" then (0.0, 0.0, \"\")\n      else\n        let rgxp = Str.regexp \"^[A-Z0-9.]+ [0-9]+ [0-9]*\\\\.[0-9]+ [BS]\" in\n          if Str.string_match rgxp ord 0 then\n            work ord\n          else (0.0, 0.0, ord)\n  in\n\n  let accumulate a =\n    let ill = ref \"\" and buy = ref 0.0 and sell = ref 0.0 in\n      for i = 0 to Array.length a - 1 do\n        let b, s, bad = one_order a.(i) in\n          buy := !buy +. b;\n          sell := !sell +. s;\n          if bad <> \"\" then if !ill <> \"\" then ill := !ill ^ \" ;\" ^ bad else ill := bad;\n      done;\n      !buy, !sell, !ill\n  in\n\n    if str = \"\" then \"Buy: 0 Sell: 0\"\n    else begin\n      let a = Str.split (Str.regexp \", \") str |> Array.of_list in\n      let b, s, il = accumulate a in\n        if il = \"\" then\n          Printf.sprintf \"Buy: %.0f Sell: %.0f\" b s\n        else\n          let cnt = List.length (Str.split (Str.regexp \" ;\") il) in\n            Printf.sprintf \"Buy: %.0f Sell: %.0f; Badly formed %d: %s ;\" b s cnt il\n    end;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216684,"user_id":null,"body":"type status = Buy | Sell\n\n\nlet status_of_char = function\n    | 'B' -> Buy\n    | 'S' -> Sell\n    | chr -> raise @@ Invalid_argument (\"Unknown status: \" ^ (String.make 1 chr))\n\n\ntype order = { quote : string; quantity : int; price : float; status : status }\n\n\n\nlet balance_statements (str : string) : string =\n    let parse_order line =\n        try\n            let (quote, quantity, price, c) = Scanf.sscanf line \"%s %d %s %c\" (fun a b c d -> (a, b, c, d)) in\n            if String.contains price '.'\n            then Some {quote; quantity; price = float_of_string price; status = status_of_char c}\n            else None\n        with _ -> None in\n    let rec loop ((b, s) as acc) badly_formed = function\n        | [] -> ((b, s), List.rev(badly_formed))\n        | x :: xs ->\n            match parse_order x with\n                | None -> loop acc (x :: badly_formed) xs\n                | Some {quantity; price; status} ->\n                    let acc' =\n                        if status = Buy then (b +. float quantity *. price, s)\n                        else (b, s +. float quantity *. price) in\n                    loop acc' badly_formed xs in\n    let round x = int_of_float (x +. 0.5) in\n    let items = str |> String.split_on_char ',' |> List.map String.trim in\n    let ((buy, sell), ill_formed) = if str = \"\" then ((0.0, 0.0), []) else loop (0.0, 0.0) [] items in\n    let first_part = \"Buy: \" ^ string_of_int (round buy) ^ \" Sell: \" ^ string_of_int (round sell) in\n    match ill_formed with\n        | [] -> first_part\n        | _ ->\n            let n = List.length ill_formed in\n            let second_part = \"; Badly formed \" ^ string_of_int n ^ \": \" in\n            let third_part = String.concat \" ;\" ill_formed in\n            first_part ^ second_part ^ third_part ^ \" ;\"\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216685,"user_id":null,"body":"let make_str bad badL buy sell =\n  let badL = List.rev badL in\n  let rec bad_m badL = \n    String.concat \" ;\" badL ^ \" ;\"\n  in\n  let b = if bad = 0\n            then \"\"\n            else\n              Format.sprintf \"; Badly formed %d: %s\" bad (bad_m badL) in\n  let mess = Format.sprintf \"Buy: %d Sell: %d\" buy sell in\n  mess ^ b\n\nlet is_float f = List.length (String.split_on_char '.' f) = 2\n  \nlet not_correct i f =\n  is_float i || not (is_float f) \n\nlet round f =\n  let i = float_of_int (int_of_float f) in\n  if f -.i >= 0.5 then int_of_float f + 1 else int_of_float f\n  \nlet balance_statements str =\n  let l = String.split_on_char ',' (\" \" ^ str) in\n  let bad = ref 0 in\n  let badL = ref [] in\n  let buy = ref 0. in\n  let sell = ref 0. in\n  let rec treat_str = function\n      [] -> make_str !bad !badL (round !buy) (round !sell)\n    | hd::tl ->\n       let cur = String.split_on_char ' ' hd in\n       (* if List.length cur < 5 then treat_str tl else *)\n         (* begin\n          *   List.iter print_endline cur; *)\n           (match cur with\n            | _::name::i::f::lo::_ ->\n               if not_correct i f  then\n                 begin\n                   bad := succ !bad ;\n                   badL := (Format.sprintf \"%s %s %s %s\" name i f lo)::(!badL);\n                   treat_str tl;\n                 end\n               else\n                 (match lo with\n                    \"B\" -> buy := !buy +. float_of_int (int_of_string i) *. float_of_string f;treat_str tl\n                  | _ -> sell := !sell +. float_of_int (int_of_string i) *. float_of_string f;treat_str tl\n                         \n                 );\n        | _::name::i::f::_ -> bad := succ !bad ;\n               badL := (Format.sprintf \"%s %s %s\" name i f)::(!badL);\n               treat_str tl;\n  \n        | _ -> \"Buy: 0 Sell: 0\")\n  in         \n  treat_str l      \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216686,"user_id":null,"body":"(* https:\/\/www.codewars.com\/kata\/54de3257f565801d96001200\/train\/ocaml *)\nopen Core\n\nmodule Order = struct\n    type status = Buy | Sell\n    type t = { quote: string\n             ; quantity: int\n             ; price: float\n             ; status: status\n             }\n\n    let from_string s =\n      let open Str in\n      let re = regexp {|\\([^ ]+\\) +\\([0-9]+\\) +\\([0-9]*\\.[0-9]*\\) +\\([BS]\\)|} in\n      if string_match re s 0\n      then\n        let quote    = matched_group 1 s in\n        let quantity = int_of_string (matched_group 2 s) in\n        let price    = if String.(s = \".\") then 0.0 else float_of_string (matched_group 3 s) in\n        let status   = if String.(matched_group 4 s = \"B\") then Buy else Sell in\n        Some {quote; quantity; price; status}\n      else None\n  end\n\nlet balance_statements (str: string) =\n  let open List in\n  let module S = String in\n  let module B = Base.Buffer in\n  let buf = B.create (S.length str) in\n  let f (buy, sell, n_error) s = match Order.from_string s with\n    | None -> B.add_string buf s; B.add_string buf \" ;\"; (buy, sell, n_error + 1)\n    | Some {quote; quantity; price; status} -> let v = float_of_int quantity *. price in\n      match status with\n      | Buy -> (buy +. v, sell, n_error)\n      | Sell -> (buy, sell +. v, n_error) in\n  let filter s = let s = S.strip s in if S.length s > 0 then Some s else None in\n  let (b, s, n) = str |> S.split ~on:',' |> filter_map ~f:filter |> fold ~init:(0., 0., 0) ~f in\n  let s1 = Printf.sprintf \"Buy: %.0f Sell: %.0f\" b s in\n  if n = 0 then s1 else s1 ^ Printf.sprintf \"; Badly formed %d: \" n ^ B.contents buf\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216687,"user_id":480,"body":"open List;;\nopen String;;\n\n\nlet balance_statements str=\n  let chunks=List.map (fun s->String.trim s) (String.split_on_char ',' str) in\n  let bsb chunk=\n    let item=String.split_on_char ' ' chunk in\n    let amount item=(float_of_int (int_of_string (List.nth item 1)))*.\n                    (float_of_string (List.nth item 2)) \n    and status=List.nth item 3 in\n    if String.contains (List.nth item 2) '.' then\n      if String.equal status \"B\" then\n        ((amount item),0.,\"\") \n      else if String.equal status \"S\" then\n        (0.,(amount item),\"\") \n      else(0.,0.,chunk)\n    else(0.,0.,chunk)\n  in\n  let bsb1 chunk=try bsb chunk with | _ -> (0.,0.,chunk) in\n  let l2=List.map bsb1 chunks\n  and add_buy acc tuple=\n    let(x,_,_)=tuple in\n    acc+.x \n  and add_sell acc tuple=\n    let (_,x,_)=tuple in\n    acc+.x\n  and add_err acc tuple=\n    let (_,_,x)=tuple in \n    if String.equal x \"\" then acc else acc @ [String.concat \"\" [x;\" ;\"]]\n  in\n  let buy=List.fold_left add_buy 0. l2\n  and sell=List.fold_left add_sell 0. l2\n  and errs=List.fold_left add_err [] l2 in\n  let errstring=if (List.length errs)==0 then \"\" else \n      String.concat \"\" [\"; Badly formed \";(string_of_int (List.length errs));\": \";\n                        (String.concat \"\" errs)]\n  in\n  String.concat \"\" [\"Buy: \";(string_of_int (int_of_float (buy+.0.5)));\n                    \" Sell: \";(string_of_int (int_of_float (sell+.0.5)));\n                    errstring]\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216688,"user_id":null,"body":"type order = \n  | Buy of float\n  | Sell of float\n  | Bad of string\n  \ntype output = \n  { mutable buy : float; mutable sell : float; mutable bad : string list }\n\n\n\nlet parse_order str =\n  match String.split_on_char ' ' str with\n  | [quote; q; p; s] | [\"\"; quote; q; p; s] \n    when (s = \"B\" || s = \"S\") && not (String.contains q '.') && String.contains p '.' ->\n    (try \n      let price = float_of_string p in\n      let quant = int_of_string q in\n      let num = float_of_int quant *. price in\n      match s with\n      | \"B\" -> Buy num\n      | _ -> Sell num\n    with\n    | _ -> Bad str)\n  | [\"\"; quote; q; p; s] -> Bad (String.concat \" \" [quote; q; p; s])\n  | _ -> Bad str\n    \nlet merge o s = \n  (match parse_order s with\n  | Buy v -> o.buy <- (o.buy +. v)\n  | Sell v -> o.sell <- (o.sell +. v)\n  | Bad sp -> o.bad <- (sp :: o.bad));\n  o\n  \nlet round f =\n  let (rem, _) = Float.modf f in\n  if rem < 0.5 then floor f\n  else ceil f\n\nlet output_to_string {buy;sell;bad} =\n  let base = \"Buy: \" ^ string_of_int (truncate (round buy)) ^ \" Sell: \" ^ string_of_int (truncate (round sell)) in\n  if bad = [] then base\n  else let len = string_of_int (List.length bad) in\n       let bads = List.fold_left (fun b a -> a ^ \" ;\" ^ b) \"\" bad in\n       base ^ \"; Badly formed \" ^ len ^ \": \" ^ bads\n\nlet balance_statements str =\n  str\n  |> String.split_on_char ','\n  |> List.filter (fun x -> x <> \"\")\n  |> List.fold_left merge {buy=0.; sell=0.; bad=[]}\n  |> output_to_string\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216689,"user_id":null,"body":"type status =\n  | Buy\n  | Sell\n\ntype order =\n  { quote : string\n  ; quantity : int\n  ; price : float\n  ; status : status }\n\nlet parse_quantity = int_of_string\n\nlet parse_price str =\n  let price = float_of_string str in\n  match String.index_opt str '.' with\n  | None ->\n      failwith \"no decimal point\"\n  | Some _ ->\n      price\n\n\nlet parse_status = function\n  | \"S\" ->\n      Sell\n  | \"B\" ->\n      Buy\n  | _ ->\n      failwith \"invalid status\"\n\n\nlet split str ch = str\n  |> String.split_on_char ch\n  |> List.filter (fun s -> s <> \"\")\n  |> List.map String.trim\n\nlet parse_order str =\n  let parts = split str ' ' in\n  match parts with\n  | [quote; q; p; s] ->\n    ( try\n        let quantity = parse_quantity q in\n        let price = parse_price p in\n        let status = parse_status s in\n        Ok {quote; quantity; price; status}\n      with Failure _ -> Error str )\n  | _ ->\n      Error str\n\n\nlet format_errors = function\n  | [] ->\n      \"\"\n  | errors ->\n      let count = List.length errors in\n      let concated = String.concat \" ;\" errors in\n      Printf.sprintf \"; Badly formed %d: %s ;\" count concated\n\n\nlet roundf x = int_of_float (floor (x +. 0.5))\n\nlet balance_statements str =\n  let orders = split str ',' |> List.map parse_order in\n  let rec loop buy sell errors = function\n    | [] ->\n        (buy, sell, List.rev errors)\n    | order :: rest ->\n      ( match order with\n      | Ok {quantity; price; status = Buy; _} ->\n          loop (buy +. (float_of_int quantity *. price)) sell errors rest\n      | Ok {quantity; price; status = Sell; _} ->\n          loop buy (sell +. (float_of_int quantity *. price)) errors rest\n      | Error str ->\n          loop buy sell (str :: errors) rest )\n  in\n  let buy, sell, errors = loop 0.0 0.0 [] orders in\n  let buy = roundf buy in\n  let sell = roundf sell in\n  Printf.sprintf \"Buy: %d Sell: %d%s\" buy sell (format_errors errors)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216690,"user_id":null,"body":"open Batteries\n\ntype order_status = Buy | Sell\ntype order = {  quote: string; quantity: int; price: float; status: order_status }\n\nlet parse_order str =\n  String.nsplit ~by:\" \" str\n  |> function [n;q;p;s] -> \n    (try \n      String.find p \".\"; (* throws if no . *)\n      `Ok {quote=n; \n           quantity = int_of_string q; \n           price = float_of_string p; \n           status = if s = \"B\" then Buy else Sell}\n    with _ -> `Err str)\n  | _ -> `Err str\n  \nlet categorize_order (b,s,e) = function \n  | `Ok {quantity; price; status} when status = Buy ->\n    (b +. float_of_int quantity *. price, s, e)\n  | `Ok {quantity; price; status} (*when status = Sell*) ->\n    (b, s +. float_of_int quantity *. price, e)\n  | `Err str -> (b, s, str :: e)\n\nlet gen_summary (b, s, bf) =\n    let print_err () bf =\n      if bf <> [] then\n        Printf.sprintf \"; Badly formed %d:%a\"\n        (List.length bf)\n        (fun () -> IO.to_string (List.print ~first:\" \" ~sep:\" ;\" ~last:\" ;\" String.print)) bf\n      else \"\"  \n    in\n    Printf.sprintf \"Buy: %d Sell: %d%a\"\n    (BatFloat.round_to_int b) (BatFloat.round_to_int s) \n    print_err (List.rev bf)\n\nlet balance_statements str =\n  str \n  |> String.nsplit ~by:\", \"\n  |> List.map parse_order\n  |> List.fold_left categorize_order (0.,0.,[])\n  |> gen_summary\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216691,"user_id":168,"body":"let balance_statements str =\n  let re = Str.regexp \"^[^ ]+ \\\\([1-9][0-9]*\\\\) \\\\([0-9]*\\\\.[0-9]+\\\\) \\\\([BS]\\\\)$\" in\n  let orders = Str.split (Str.regexp \", *\") str in\n  let rec loop (buy, sell, bad) = function\n  | [] -> buy, sell, List.rev bad\n  | order :: rest ->\n    if Str.string_match re order 0 then\n      let q = float_of_string (Str.matched_group 1 order) in\n      let price = float_of_string (Str.matched_group 2 order) in\n      match Str.matched_group 3 order with\n      | \"B\" -> loop (buy +. q *. price, sell, bad) rest\n      | _ -> loop (buy, sell +. q *. price, bad) rest\n    else\n      loop (buy, sell, order :: bad) rest in\n  let buy, sell, bad = loop (0.0, 0.0, []) orders in\n  let bad_nb = List.length bad in\n  let bad_str = List.fold_left (fun a s -> a ^ Printf.sprintf \"%s ;\" s) \"\" bad in\n  let round x = truncate (x +. 0.5) in\n  Printf.sprintf \"Buy: %d Sell: %d%s\" (round buy) (round sell)\n    (if bad_nb > 0 then Printf.sprintf \"; Badly formed %d: %s\" bad_nb bad_str else \"\")","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54e320dcebe1e583250008fd":[{"id":216692,"user_id":168,"body":"open Num\nopen Big_int\n\n(* nbs is a string representing a big number *)\nlet dec_2_fact_string (nbs: string): string  =\n  let rec encode x b =\n    let q, m = quomod_big_int x b in\n    if sign_big_int q = 0 then [int_of_big_int m]\n    else int_of_big_int m :: encode q (succ_big_int b) in\n  let code0 = Char.code '0' in\n  let code1 = Char.code 'A' in\n  let d_to_str d =\n    String.make 1\n      (if d <= 9 then Char.chr (d + code0)\n       else Char.chr (d - 10 + code1)) in\n  let x = big_int_of_num (num_of_string nbs) in\n  let ds = encode x unit_big_int in\n  ds |> List.rev_map d_to_str |> String.concat \"\"\n\n(* return a string representing a big number *)\nlet fact_string_2_dec (strg: string): string =\n  let code0 = Char.code '0' in\n  let code1 = Char.code 'A' - 10 in\n  let n = String.length strg in\n  let rec decode i b =\n    if i >= n then Int 0\n    else\n      let ch = strg.[n - i - 1] in\n      let c = Char.code ch in\n      let d = if ch <= '9' then c - code0 else c - code1 in\n      Int d *\/ b +\/ decode (i + 1) (b *\/ Int (i + 1)) in\n  string_of_num (decode 0 (Int 1))\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 21:22:52"},{"id":216693,"user_id":492,"body":"let dec_2_fact_string (nbs: string): string  =\n  let nb = num_of_string nbs in\n  let rec loop (rad: Num.num) (n: Num.num) (res: string) =\n    let q = quo_num n rad in\n    let r = int_of_num (mod_num n rad) in\n    let ch = if r <= 9 then r + 48 else r + 55 in\n      if q =\/ (Int 0) then\n        (String.make 1 (Char.chr ch)) ^ res\n      else loop (rad +\/ (Int 1)) q ((String.make 1 (Char.chr ch)) ^ res)\n  in\n    loop (Int 2) nb \"0\";;\n\nlet char_2_nb chn nb =\n  if chn <= 57 then (Int (chn - 48)) *\/ (facto_ nb)\n  else (Int (chn - 55)) *\/ (facto_ nb);;\nlet fact_string_2_dec (strg: string): string =\n  let arr = Str.split (Str.regexp \"\") strg |> List.map (fun x -> Char.code x.[0]) in\n  let greatestFact = List.length arr - 1 in\n  let rec loop data ndx res =\n    if data = [] then res\n    else loop (List.tl data) (ndx - 1) (res +\/ (char_2_nb (List.hd data) ndx))\n  in\n    string_of_num(loop arr greatestFact (Int 0));;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 21:22:52"},{"id":216694,"user_id":null,"body":"let big_int_of_digit d =\n  let num =\n    match d with\n    | '0' .. '9' -> Char.code d - 48\n    | 'A' .. 'Z' -> Char.code d - 55\n    | _ -> invalid_arg \"This shouldn't happen\" in\n  BatBig_int.big_int_of_int num\n\nlet digit_of_big_int n =\n  let num = BatBig_int.int_of_big_int n in\n  if 0 <= num && num <= 35 then\n    if num < 10 then Char.chr (num + 48) else Char.chr (num + 55)\n  else failwith \"This shouldn't happen\"\n\n\nlet fact_string_2_dec s =\n  let open BatBig_int in\n  \n  let chars = List.init (String.length s) (String.get s) in\n  let digits_big_ints = List.rev_map big_int_of_digit chars in\n  \n  let folding_fun (total, fac, next_base) d =\n    (total + d * fac, fac * next_base, next_base + one) in\n  match List.fold_left folding_fun (zero, one, one) digits_big_ints with\n    total, _, _ -> string_of_big_int total  \n\nlet dec_2_fact_string n =\n  let open BatBig_int in\n  let open Compare in\n  let n = big_int_of_string n in\n\n  let rec find_max_base fac base =\n    if fac > n then fac \/ base, base - one else\n    find_max_base (fac * (base + one)) (base + one) in\n  let fac, base = find_max_base one one in\n\n  let rec loop acc fac base n =\n    if base = zero then '0' :: acc else\n    let q, r = quomod_big_int n fac in\n    loop (digit_of_big_int q :: acc) (fac \/ base) (base - one) r in\n  let digits = loop [] fac base n in\n  \n  String.concat \"\" @@ List.rev_map (String.make 1) digits\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 21:22:52"},{"id":216695,"user_id":null,"body":"open Num\n\nlet char_to_int = [('0', 0); ('1', 1); ('2', 2); ('3', 3); ('4', 4); ('5', 5);\n               ('6', 6); ('7', 7); ('8', 8); ('9', 9); ('A', 10); ('B', 11);\n               ('C', 12); ('D', 13); ('E', 14); ('F', 15); ('G', 16); ('H', 17);\n               ('I', 18); ('J', 19); ('K', 20); ('L', 21); ('M', 22); ('N', 23);\n               ('O', 24); ('P', 25); ('Q', 26); ('R', 27); ('S', 28); ('T', 29);\n               ('U', 30); ('V', 31); ('W', 32); ('X', 33); ('Y', 34); ('Z', 35)]\n\n\nlet int_to_char = List.map (fun (c, v) -> (v, c)) char_to_int\n\n\nlet dec_2_fact_string (nbs: string): string  =\n    let rec loop acc k n =\n        if n = Int 0 then List.map (String.make 1) acc |> String.concat \"\"\n        else\n            let d = quo_num n k in\n            let r = int_of_num (mod_num n k) in\n            loop ((List.assoc r int_to_char) :: acc) (k +\/ Int 1) d\n    in loop [] (Int 1) (num_of_string nbs)\n\n\nlet fact_string_2_dec (strg: string): string =\n    let digits = String.to_seq strg |> List.of_seq |> List.rev in\n    let rec loop acc fact n = function\n        | [] -> acc\n        | x :: xs ->\n            let value = List.assoc x char_to_int in\n            loop ((fact *\/ Int value) +\/ acc) (n *\/ fact) (n +\/ Int 1) xs\n    in loop (Int 0) (Int 1) (Int 1) digits |> string_of_num\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 21:22:52"},{"id":216696,"user_id":null,"body":"#load \"nums.cma\";; \nopen Num;;\n\n(* nbs is a string representing a big number *)\nlet encode c =\n  let cp = int_of_num (c) in\n  if cp < 10 then string_of_int cp else String.make 1 (Char.chr(cp + Char.code('A') - 10))\n\n let decode c =\n  let cp = num_of_string_opt c in match cp with\n                                | None -> num_of_int (Char.code(c.[0]) + 10 - Char.code('A'))\n                                | Some n -> n\n    \n  \nlet dec_2_fact_string (nbs)  =\n  let rec aux acc n s =\n    if n =\/ num_of_int 1 then \n        aux ((mod_num s (num_of_int 2))::(num_of_int 0)::acc) (succ_num n) (quo_num s (num_of_int 2))  \n    else\n      if s =\/ num_of_int 0 then acc\n      else  \n        aux ((mod_num s (succ_num n))::acc) (succ_num n) (quo_num s (succ_num n))  \n  in\n  String.concat \"\" (List.map encode (aux [] (num_of_int 1) (num_of_string nbs)))\n\nlet rec fact n = if n =\/ (num_of_int 1) then num_of_int 1 else fact (pred_num n) *\/ n  \n  \nlet fact_string_2_dec (strg) =\n  let rec aux acc n s =\n    let len = String.length s in\n    if String.length s = 0 then acc\n    else\n      let r = decode (String.make 1 (s.[len - 1])) and s = String.sub s 0 (len - 1) in\n      if n =\/ num_of_int 0 then aux acc (num_of_int 1) s\n                    else aux (r *\/ fact n +\/ acc) (succ_num n) s\n  in\n  string_of_num (aux (num_of_int 0) (num_of_int 0) strg)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 21:22:52"},{"id":216697,"user_id":480,"body":"(* uncomment if you need: #load \"nums.cma\";; open Num;; *)\n#load \"nums.cma\";; open Num;;\nopen String\n\n(* nbs is a string representing a big number *)\nlet dec_2_fact_string (nbs: string): string  =\n\n  let x=Num.num_of_string nbs in\n  let rec facts n f =\n    let n1=Num.add_num n (Num.num_of_int 1) in\n    (if (Num.compare_num f x)<0 then facts n1 (Num.mult_num f n1) else [])@[f] in\n  let facts=facts (Num.num_of_int 0) (Num.num_of_int 1) in\n  let facts=match facts with |[]->[]|h::t->t in\n  let rec digits x facts =\n    match facts with\n    | []->[]\n    | f::t -> \n      let dnum= Num.quo_num x f  in\n      let x=Num.sub_num x (Num.mult_num dnum f)  and facts=t and d=Num.int_of_num dnum in\n      let d=if d<10 then (Char.code '0')+d else (Char.code 'A')+(d-10) in\n      let d=d |> Char.chr |> String.make 1  in\n      [d] @ (digits x facts) in\n      \n  String.concat \"\" (digits x facts);;\n  \n(* return a string representing a big number *)\nlet fact_string_2_dec (strg: string): string =\n  let rec facts n f strg=\n    let n1=Num.add_num n (Num.num_of_int 1) \n    and strg=String.sub strg 1 ((String.length strg)-1) in\n    (if (String.length strg)>0 then facts n1 (Num.mult_num f n1) strg else [])@[f] in\n  let facts=facts (Num.num_of_int 0) (Num.num_of_int 1) strg in\n  let rec digits (strg:string) facts:Num.num=\n    if (String.length strg)==0 then Num.num_of_int 0 else \n    let c=String.get strg 0 |> Char.uppercase_ascii in\n    let d=c |> Char.code\n    and strg=String.sub strg 1 ((String.length strg)-1)\n    and f::facts=facts\n    in\n    let d=if d>=(Char.code 'A') then 10+d-(Char.code 'A') else d-(Char.code '0') in\n    (*Printf.printf \"%c: +%d * %d!\n\" c d (String.length strg);*)\n    Num.num_of_int d |> Num.mult_num f |> Num.add_num (digits strg facts) in\n  digits strg facts|> Num.string_of_num\n  ;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 21:22:52"}],"54eb33e5bc1a25440d000891":[{"id":216698,"user_id":492,"body":"let decompose(n: int): int list = \n  let rec aux rest last =\n    match (rest, last) with\n      | 0, _ -> Some []\n      | _, 1 -> None\n      | _  -> \n          let n = min (last - 1) (int_of_float (sqrt(float_of_int rest))) in\n            match aux (rest - (n * n)) n with\n              | Some l -> Some (n :: l)\n              | None -> aux rest n\n  in\n    match aux (n * n) n with\n      | Some lst -> lst |> List.rev\n      | None -> [];;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216699,"user_id":null,"body":"let decompose(n: int): int list = \n  let rec decomp = function\n    | lst, 0, _ -> lst\n    | lst, _, 0 -> []\n    | lst, s, m ->\n      if (m * m > s)\n      then decomp (lst, s, (m - 1))\n      else \n        let t = decomp ((m::lst), (s - m * m), (m - 1)) in\n        if t = []\n        then decomp (lst, s, (m - 1))\n        else t\n  in\n  decomp ([], (n * n), (n - 1))\n  ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216700,"user_id":168,"body":"let decompose(n: int) : int list =\n  let rec search acc v k =\n    if v < 0 || k < 0 then []\n    else if v = 0 then acc\n    else\n      let v' = v - k * k in\n      let t = truncate (sqrt (float (abs v'))) in\n      match search (k :: acc) v' (min (pred k) t) with\n      | [] -> search acc v (pred k)\n      | _ as sol -> sol in\n  search [] (n * n) (n - 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216701,"user_id":null,"body":"let decompose (n : int) : int list =\n    let rec partition (number : int) (can_be_itself : bool) : (int list) option = \n        if number = 0 then Some []\n        else if number = 1 then Some [1]\n        else \n            let upper_limit = (if can_be_itself then number else number - 1) |> float |> sqrt |> int_of_float in\n            let rec loop k = \n                if k = 0 then None\n                else\n                    let number' = number - k * k in\n                    match partition number' true with\n                        | None -> loop (k - 1)\n                        | Some squares -> \n                            if List.mem k squares then loop (k - 1) \n                            else Some (k :: squares) in\n            loop upper_limit in            \n    match partition (n * n) false with\n        | None -> []\n        | Some result -> List.sort compare result","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216702,"user_id":null,"body":"let partiecarent n = \n  let i = ref 1 in while ((!i +1)*(!i +1) <= n) do\n     incr i done ; !i\n   ;;\n     \n\nlet rec decompose(n: int): int list = \n  let rec aux m rep toto = match toto with \n    |0-> if m=n*n then [-1] else (if m=0 then rep else [])\n    |i-> let result = (aux (m-i*i) (i::rep) (min (toto-1) (partiecarent (m-i*i)))) in\n        if result = [] then (aux m rep (toto-1)) else (if result =[-1] then [] else result)\n   in let a =aux (n*n) [] (n-1) in\n   if a = [-1] then [] else a\n  ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216703,"user_id":null,"body":"let rec decompose ?(tour = 0) (n: int): int list = \n\tif n = 1 then [1] else\n\tlet hyp = n-tour-1 in\n\tif n*n > hyp * (hyp+1) * (2*hyp+1) \/ 6 (* = 1*1 + 2*2 +...+ hyp*hyp *) then [] else\n\n\tlet rec auxi essai prec total =\n\t\tlet h = Float.to_int (Float.sqrt (Float.of_int total)) - essai in\n\t\tmatch total, h with\n\t\t\t| 0, _ -> Some []\n\t\t\t| _, a when a = prec -> auxi (essai+1) prec total\n\t\t\t| a, b when a > b * (b+1) * (2*b+1) \/ 6 -> None\n\t\t\t| tot, hypo -> begin\n\t\t\t\tlet nt = total - h*h in\n\t\t\t\tmatch auxi 0 h nt with\n\t\t\t\t\t| Some l -> Some (h::l)\n\t\t\t\t\t| None -> auxi (essai+1) prec total end in\n\n\tmatch auxi 1 max_int (n*n) with\n\t\t| Some l -> List.rev l\n\t\t| None -> decompose ?tour:(Some (tour+1)) n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216704,"user_id":null,"body":"let rec fold_n_to_1 f n init = match n with\n  | 0 -> init\n  | _ -> fold_n_to_1 f (n-1) (f n init)\n\nlet decompose(n: int): int list =\n  let rec aux decompo highest_allowed remainder = \n    if highest_allowed <= 0 || remainder < 0 then\n      None \n    else match remainder with\n    | 0 -> Some decompo\n    | 1 -> if n >= 1 then Some (1::decompo) else None\n    | _ -> fold_n_to_1 \n        (fun k res -> match res with \n          | Some _ -> res \n          | None -> aux (k::decompo) (k-1) (remainder - k * k)) \n        highest_allowed\n        None\n  in\n  match aux [] (n-1) (n * n) with\n  | Some res -> res\n  | None -> []","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216705,"user_id":null,"body":"\nlet get_sqrt m =\n  int_of_float (float_of_int m**0.5)\n  \nlet decompose(n: int): int list =\n  let n2 = n * n in\n\n  \n  let rec help2 acc rest m sum =\n    if rest = -1 || (m < 1 && acc = [])\n    then\n      ([], -1)\n    else\n      let m2 = m * m in\n      let new_sum = sum + m2 in\n      let new_rest = rest - m2 in\n      if new_rest = 0\n      then (m::acc, new_rest)\n      else\n        if m = 1  && not (acc = [])\n        then\n          let new_m = List.hd acc - 1 in\n          help2 (List.tl acc) rest new_m sum\n        else\n          let (new_acc, rest2) = help2 [] new_rest (min (m -1) (get_sqrt new_rest)) new_sum in\n          if rest2 = 0 \n          then (new_acc @ (m::acc), rest2)\n          else\n            if m > 1 then\n              help2 acc rest (m -1) sum\n            else\n              ([], -1)\n  in\n  fst (help2 [] n2 (n - 1) 0)\n ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216706,"user_id":null,"body":"type ret =\n  | Failed\n  | Result of int list\n\nlet decompose(n: int): int list = \n  let rec aux next left = match next with\n    | _ when next < 0 -> Failed\n    | _ when left < 0 -> Failed\n    | _ when left = 0 -> Result []\n    | _ -> let sub = aux (next-1) (left - next*next) in match sub with\n      | Result sublist -> Result (next::sublist)\n      | Failed -> aux (next-1) left\n  in let result = aux (n-1) (n*n) in match result with\n    | Failed -> []\n    | Result l -> List.rev l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216707,"user_id":null,"body":"let decompose(n: int): int list = \n  let rec aux target i vs =\n    if target == 0 then Some vs\n    else if target < 0 || i == 0 then None\n    else match aux (target - i*i) (i-1) (i::vs) with\n      None -> aux target (i-1) vs\n    | x -> x\n  in match aux (n*n) (n-1) [] with None -> [] | Some x -> x;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54f2f335cb9d99e8530008d7":[{"id":216708,"user_id":null,"body":"let span (l: 'a list) (predicate: 'a -> bool): 'a list * 'a list =\n  let rec aux acc = function\n    | [] -> (List.rev acc, [])\n    | (h :: t) -> if predicate h then aux (h :: acc) t \n      else (List.rev acc, (h :: t))\n    in aux [] l;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216709,"user_id":527,"body":"let span (l: 'a list) (predicate: 'a -> bool): 'a list * 'a list =\n  BatList.span predicate l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216710,"user_id":null,"body":"let rec take_while l predicate = match l with\n  | x::xs when predicate x -> x::take_while xs predicate\n  | _ -> []\n\nlet rec drop n l = if n = 0 then l else drop (n - 1) (List.tl l)\n\nlet span l predicate =\n  let l_true = take_while l predicate in\n  let len_true = List.length l_true in\n  let l_rest = drop len_true l in\n  l_true, l_rest","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216711,"user_id":null,"body":"let span (l: 'a list) (predicate: 'a -> bool): 'a list * 'a list =\n    let rec loop acc = function\n        | x :: xs when predicate x -> loop (x :: acc) xs\n        | xs -> List.rev acc, xs in\n    loop [] l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216712,"user_id":168,"body":"open Batteries\n\nlet span (l: 'a list) (predicate: 'a -> bool): 'a list * 'a list = List.span predicate l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216713,"user_id":436,"body":"let rec span (l: 'a list) (predicate: 'a -> bool): 'a list * 'a list = match l with\n  | h::t -> (match predicate h with\n    | true -> (match span t predicate with\n      | (a, b) -> h::a, b\n    )\n    | false -> [], l\n  )\n  | _ -> [], []","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216714,"user_id":98,"body":"let span (lst: 'a list) (predicate: 'a -> bool): 'a list * 'a list =\n\tlet rec span_rec lst left =\n\t\tif lst = [] || not(predicate (List.hd lst)) then\n\t\t\t(List.rev left, lst)\n\t\telse\n\t\t\tspan_rec (List.tl lst) ((List.hd lst) :: left)\n\tin span_rec lst []\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216715,"user_id":53,"body":"open Batteries\n\nlet span (ls: 'a list) (predicate: 'a -> bool): 'a list * 'a list =\n  ls |> BatList.span(predicate) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216716,"user_id":null,"body":"let span l predicate =\n  let rec loop buff = function\n    | hd :: tl when predicate hd -> loop (hd :: buff) tl\n    | l -> List.rev buff, l in\n  loop [] l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54f9173aa58bce9031001548":[{"id":216717,"user_id":null,"body":"let take_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n    let rec loop acc = function\n        | x :: xs when predicate x -> loop (x :: acc) xs\n        | _ -> List.rev acc in\n    loop [] l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216718,"user_id":null,"body":"let rec take_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n  match l with\n  | x::xs when predicate x -> x::take_while xs predicate\n  | _ -> []","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216719,"user_id":null,"body":"let rec take_while (l: 'a list) (predicate: 'a -> bool): 'a list = match l with\n  | [] -> []\n  | hd::_ when not @@ predicate hd -> []\n  | hd::tail -> hd :: take_while tail predicate\n  \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216720,"user_id":null,"body":"let take_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n  let rec inner acc = function\n  | x :: xs when predicate x -> inner (x::acc) xs\n  | _ -> List.rev acc\n  in inner [] l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216721,"user_id":null,"body":"let take_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n  let rec aux acc = function\n    | [] -> acc\n    | h :: t -> if (predicate h) then aux (h::acc) t else acc\n  in aux [] l |> List.rev\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216722,"user_id":null,"body":"let rec take_while (xs: 'a list) (p: 'a -> bool): 'a list = match xs with \n  | [] -> []\n  | x::xs when p x -> x::(take_while xs p)\n  | _ -> []\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216723,"user_id":null,"body":"let rec take_while ls f =\n  match ls with\n  | x :: ls when f x -> x :: take_while ls f\n  | _ -> []","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216724,"user_id":168,"body":"open Batteries\n\nlet take_while (l: 'a list) (predicate: 'a -> bool): 'a list = List.take_while predicate l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216725,"user_id":53,"body":"open Batteries\n\nlet take_while (ls: 'a list) (predicate: 'a -> bool): 'a list =\n  ls |> BatList.take_while(predicate) ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216726,"user_id":98,"body":"let rec take_while (lst: 'a list) (predicate: 'a -> bool): 'a list =\n\tif lst = [] || not (predicate (List.hd lst)) then\n\t\t[]\n\telse\n\t\t(List.hd lst) :: (take_while (List.tl lst) predicate)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54f9c37106098647f400080a":[{"id":216727,"user_id":null,"body":"let rec drop_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n  match l with\n  | x::xs when predicate x -> drop_while xs predicate\n  | _ -> l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216728,"user_id":null,"body":"let rec drop_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n  match l with\n  | [] -> []\n  | h::t -> if predicate h then drop_while t predicate else h::t\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216729,"user_id":527,"body":"let drop_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n  BatList.drop_while predicate l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216730,"user_id":null,"body":"let drop_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n    let rec aux = function\n        | h :: t when predicate h -> aux t\n        | x -> x\n    in aux l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216731,"user_id":null,"body":"let rec drop_while ls f =\n  match ls with\n  | x :: ls when f x -> drop_while ls f\n  | _ -> ls","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216732,"user_id":null,"body":"let drop_while (l: 'a list) (predicate: 'a -> bool): 'a list =\n    let rec loop = function\n        | x :: xs when predicate x -> loop xs\n        | xs -> xs in\n    loop l\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216733,"user_id":null,"body":"let rec drop_while (l : 'a list) (predicate : 'a -> bool) : 'a list =\n  match l with\n  | [] -> []\n  | h :: tl when predicate h -> drop_while tl predicate\n  | _ -> l\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216734,"user_id":168,"body":"open Batteries\n\nlet drop_while l predicate = List.drop_while predicate l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216735,"user_id":98,"body":"let rec drop_while (list: 'a list) (predicate: 'a -> bool): 'a list =\n  if list = [] || not(predicate (List.hd list)) then\n    list\n   else\n    drop_while (List.tl list) predicate\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216736,"user_id":53,"body":"open Batteries\n\nlet drop_while (ls: 'a list) (predicate: 'a -> bool): 'a list =\n  ls |> BatList.drop_while(predicate) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"54ff3102c1bad923760001f3":[{"id":216737,"user_id":null,"body":"let get_count (s: string): int =\n    let vowels = ['a'; 'e'; 'i'; 'o'; 'u'] in\n    s |> String.to_seq |> Seq.fold_left (fun acc c -> if List.mem c vowels then acc + 1 else acc) 0","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216738,"user_id":null,"body":"let rec get_count (s: string): int =\n  let isVowel (c : char) : int = if c = 'a' || c = 'e' || c = 'i' || c = 'o' || c ='u' || c = 'A' || c = 'E' || c = 'I' || c = 'O' || c = 'U' \n  then 1 else 0 in if String.length s = 0 then 0\n  else\n  (isVowel (String.get s 0)) + get_count (String.sub s 1 ((String.length s) - 1))\n  ;;\n  ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216739,"user_id":null,"body":"let get_count s =\n  let is_vowel = String.contains \"aeiou\" in\n  let ct = ref 0 in\n  String.iter (fun c -> if is_vowel c then ct := !ct + 1) s;\n  !ct","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216740,"user_id":null,"body":"let rec compare letter vowels lenVow =\n  if lenVow == 0 then 0 else\n    if letter = String.sub vowels (lenVow-1) 1 then 1 else\n      compare letter vowels (lenVow-1);;\n  \nlet rec counter1 s vowels lenS lenVar result =\n  if lenVar == lenS then result else\n    let letter = String.sub s 0 1 in\n    let lenVar2 = lenVar + 1 in\n    let s1 = String.sub s 1 (lenS-lenVar2) in\n    counter1 s1 vowels lenS lenVar2 (result +\n      compare letter vowels 5);;\n\nlet get_count (s: string): int =\n  let vowels = \"aeiou\" in\n  let lenS = String.length s in\n  counter1 s vowels lenS 0 0;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216741,"user_id":null,"body":"let string_of_char c = String.make 1 c\n\nlet explode s =\n  let rec visit index chars =\n    if index < String.length s then\n      let char = s.[index] in\n      visit (index + 1) (chars @ [ char ])\n    else chars\n  in\n  visit 0 []\n\nlet rec implode chars =\n  match chars with [] -> \"\" | h :: t -> string_of_char h ^ implode t\n\nlet get_count (s : string) : int =\n  let rec counter (s : string) (i : int) =\n    match explode s with\n    | [] -> i\n    | h :: t -> (\n        let imploded_tail = implode t in\n        match h with\n        | 'a' | 'e' | 'i' | 'o' | 'u' -> counter imploded_tail (i + 1)\n        | _ -> counter imploded_tail i)\n  in\n  counter s 0\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216742,"user_id":null,"body":"let btoi(b) = if b then 1 else 0;;\n\nlet rec f(s, n): int = \n  if n = 0 then 0 \n  else f(s,n-1) + btoi(String.contains\"aeiou\" s.[n-1])\n  ;;\n\nlet get_count (s: string): int =\n  f(s, String.length s);;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216743,"user_id":null,"body":"let is_vowel = function\n  | 'a'\n  | 'e'\n  | 'i'\n  | 'o'\n  | 'u' -> true\n  | _ -> false\n\nlet get_count (s: string): int =\n  s \n  |> String.to_seq\n  |> Seq.fold_left (fun state letter -> if is_vowel letter then state + 1 else state) 0","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216744,"user_id":null,"body":"let is_vowel = function\n  | 'a' | 'e' | 'i' | 'o' | 'u' -> true\n  | _ -> false\n\nlet get_count (s: string): int =\n  let r = ref 0 in\n  let () = String.iter (fun x -> if is_vowel x then r := !r + 1 else ()) s in\n  !r","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216745,"user_id":null,"body":"let get_count (s: string): int =\n  let vowels = ['a'; 'e'; 'i'; 'o'; 'u'] in\n  let ans = ref 0 in\n  String.iter (fun c -> if List.mem c vowels then incr ans) s;\n  !ans","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216746,"user_id":null,"body":"let get_count (s: string): int =\n  List.init (String.length s) (fun i -> String.get s i) |> List.filter (fun x -> List.mem x ['a';'e';'i';'o';'u']) |> List.length","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"550498447451fbbd7600041c":[{"id":216747,"user_id":527,"body":"let comp_same a b: bool =\n  List.sort compare (List.map (fun x -> x * x) a) = List.sort compare b","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216748,"user_id":492,"body":"let comp_same a b: bool =\n  let aa = a |> List.map (fun x->x*x) |> List.sort compare in\n  let bb = b |> List.sort compare in\n    aa = bb;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216749,"user_id":null,"body":"let comp_same a b: bool =\n  if List.length a = List.length b then\n    List.(fold_left2 (fun acc i j -> acc && (i * i = j)) true (sort (-) a) (sort (-) b))\n  else false\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216750,"user_id":168,"body":"let comp_same a b: bool =\n  let rec cmp = function\n  | [], [] -> true\n  | x :: xs, y :: ys when y = x * x -> cmp (xs, ys)\n  | _ -> false in\n  cmp (List.sort compare a, List.sort compare b)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216751,"user_id":null,"body":"let comp_same a b: bool =\n  (List.map (fun x -> x * x) a |> List.sort compare) = (List.sort compare b)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216752,"user_id":null,"body":"let comp_same a b: bool =\n  (* Int.compare missing??? *)\n  let compare (a:int) (b:int) =\n  if a < b then -1 \n  else if a > b then 1 \n  else 0 in\n  let sa = List.sort compare a\n  and sb = List.sort compare b\n  in List.for_all2 (fun x y -> (x*x) == y) sa sb","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216753,"user_id":null,"body":"let comp_same a b =\n  List.sort compare (List.map (fun n -> n * n) a) = List.sort compare b","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216754,"user_id":null,"body":"let rec comp a b = \n  let sorted xs = List.sort (-) xs in\n  match sorted a, sorted b with \n   | [], [] -> true\n   | _::_, [] | [], _::_ -> false\n   | h1::t1, h2::t2 -> h1 * h1 == h2 && comp t1 t2","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216755,"user_id":null,"body":"module Int = struct\n  let compare n m =\n    if n > m\n    then 1\n    else if n < m\n    then -1\n    else 0\nend \n\nlet comp_same a (b : int list) : bool =\n let b = List.map \n     (fun a -> Float.of_int a |> Float.sqrt |> Float.to_int) \n     b |> List.sort Int.compare in\n List.sort Int.compare a = b","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216756,"user_id":null,"body":"let comp_same a b : bool =\n  let sort = List.sort (fun a b -> a - b) in\n  let sa = sort a in\n  let sb = sort b in\n  let rec compInner a b : bool =\n    match a, b with\n    | [], [] -> true\n    | _, [] | [], _ -> false\n    | x :: xs, y :: ys -> x * x = y && compInner xs ys\n  in\n  compInner sa sb\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"550527b108b86f700000073f":[{"id":216757,"user_id":null,"body":"let pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n\nlet iter_pi epsilon =\n\tlet rec loop n p =\n\t\tif Float.abs (Float.pi -. p) < epsilon then\n\t\t\t(n, rnd10 p) else\n\t\t\tloop (n+1) (p +. ((if n land 1 = 1 then -.4. else 4.) \/. Float.of_int (2*n+1))) in\n\tloop 0 0.;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216758,"user_id":null,"body":"open Batteries\nlet pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n\nlet iter_pi epsilon =\n    let rec aux iter appr =\n        let pp = (appr *. 4.) in\n        if Float.abs(pp -. pi) <= epsilon then (iter, rnd10 pp)\n        else \n            aux (iter + 1) \n            (((Float.pow (-1.) (float_of_int(iter))\/.(float_of_int((2*iter)+1)))\n            +. appr))\n    in aux 0 0.","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216759,"user_id":null,"body":"(* Ceci est un \u00e9diteur pour OCaml\n   Entrez votre programme ici, et envoyez-le au toplevel en utilisant le\n   bouton \"\u00c9valuer le code\" ci-dessous ou [Ctrl-e]. *)\nopen Batteries\n\nlet pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n\nlet iter_pi epsilon =\n  let num = ref 1.0 in\n  let toto = ref 1 in\n  let count = ref 1.0 in\n  while ( (pi-.4.0*.(!num))**2.0 >= epsilon**2.0) do\n    num:=  ((!num) +. ((-1.0)**(!count))*. 1.0\/.((!count)*.2.0 +.1.0));\n    count:= !count +. 1.0; incr toto ; done;\n  (!toto,rnd10 (4.0*.(!num)));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216760,"user_id":null,"body":"\nopen Batteries\nlet pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n  \nlet iter_pi epsilon =\n  let term n = -1.**n \/. (1. +. 2. *. n) in\n  let rec iter acc n =\n    if Float.abs (pi -. 4. *. acc) < epsilon then\n      (n, rnd10 (4.*.acc))\n    else\n      iter (acc +. term (float_of_int n)) (n + 1) \n  in\n  iter 0. 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216761,"user_id":53,"body":"open Batteries\n\nlet absF (f:float) = if f >= 0.0 then f else (f *. -1.0);;\nlet pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n\nlet iter_pi epsilon =\n  let rec loop pi4 sign denom iterations =\n    if absF(4.0 *. pi4 -. pi) < epsilon then (iterations, rnd10 (4.0 *. pi4))\n    else loop (pi4 +. sign *. (1.0 \/. denom)) (sign *. (-1.0)) (denom +. 2.0) (iterations + 1)\n  in loop 1.0 (-1.0) 3.0 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216762,"user_id":null,"body":"open Batteries\n\nlet pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n\nlet iter_pi epsilon =\n  let rec compute v count d =\n    let new_val:float = if count mod 2 = 0 then Float.add v (1.0 \/. Float.of_int d)\n                        else Float.sub v (1.0 \/. Float.of_int d) in\n    if Float.abs (Float.sub (4.0 *. new_val) pi) < epsilon then (count + 1, (rnd10 (4.0 *. new_val)))\n    else compute new_val (count + 1) (d + 2)\n  in\n  compute 1.0 1 3\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216763,"user_id":null,"body":"open Batteries\n\nlet pi = 4.0 *. (atan 1.0) \nlet rnd10 x = float_of_string(String.sub (string_of_float x) 0 12);;\n\nlet iter_pi epsilon = \n  let rec pifind i res c=\n    if abs_float( res -. pi)<= epsilon then\n      ((int_of_float c) , (rnd10 res))\n    else\n      pifind (i+.2.)  ((4.\/. i)*.( (-1.)**c) +. (res)) (c +. 1.)\n  in pifind 1. 0. 0.\n(*\nopen Batteries\nlet pi = 4.0 *. (atan 1.0);;\nlet rnd10 x = \n  (float_of_int(int_of_float(x *. 1E10))) \/. 1E10;;\n\nlet iter_pi epsilon =\n  let i = 1.\/.epsilon\n  in\n  let rec pitest j =\n    if i<=j  then 4.\n    else\n     if (int_of_float j) mod 2 = 0 then\n       4.\/.(2.*.j+.1.) +. pitest (j+.1.) \n     else\n       (-4.\/.(2.*.j+.1.)) +. pitest (j+.1.)    \n  in\n   (int_of_float i,rnd10 (pitest 1.));;\n   *)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216764,"user_id":null,"body":"open Batteries\n\nlet pi = 4.0 *. (atan 1.0) \nlet rnd10 x = float_of_string(String.sub (string_of_float x) 0 12);;\n\nlet iter_pi epsilon = \n  let rec pifind i res c=\n    if abs_float( res -. pi)<= epsilon then\n      ((int_of_float c) , (rnd10 res))\n    else\n      pifind (i+.2.)  ((4.\/. i)*.( (-1.)**c) +. (res)) (c +. 1.)\n  in pifind 1. 0. 0. ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216765,"user_id":null,"body":"open Batteries;;\nlet pi = 4.0 *. (atan 1.0)\nlet rnd10 x = \n  (x *. 1E10 |> int_of_float |> float_of_int) \/. 1E10\n\nlet iter_pi epsilon =\n  let rec helper n acc =\n    match acc with\n    | x when abs_float (x -. pi) < epsilon -> n, (rnd10 acc)\n    | _ -> let n_f = float_of_int n in if n mod 2 = 0\n      then (helper (n+1) (acc +. 4. *. 1. \/. (2. *. n_f +. 1.)))\n      else (helper (n+1) (acc -. 4. *. 1. \/. (2. *. n_f +. 1.)))\n  in helper 0 0.;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216766,"user_id":null,"body":"open Batteries\n\nlet pi = 4.0 *. (atan 1.0)\n\nlet rnd10 r = (r *. 1e10 |> int_of_float |> float_of_int) \/. 1e10 \n\nlet iter_pi epsilon =\n    let rec loop y n = \n        if abs_float (y *. 4.0 -. pi) < epsilon then (n, rnd10 (4.0 *. y))\n        else \n            let sign = if n mod 2 = 0 then 1.0 else (-1.0) in\n            let y_new = y +. sign \/. (2.0 *. (float_of_int n) +. 1.0) in\n            loop y_new (n + 1)\n    in loop 0.0 0 \n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"550554fd08b86f84fe000a58":[{"id":216767,"user_id":492,"body":"#load \"str.cma\";;\n\nlet inArray(a1: string list) (a2: string list) =\n  let aa1 = a1 |> List.sort compare |> uniq in\n    List.filter(fun x -> List.exists (fun y -> contains y x) a2) aa1;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216768,"user_id":53,"body":"let contains s1 s2 =\n  let re = Str.regexp_string s2 in\n  try ignore (Str.search_forward re s1 0); true\n  with Not_found -> false\n        \nlet containsInArray(ys: string list) (x: string) = \n  let zs = List.filter (fun (y) -> (contains y x)) ys in \n  (List.length zs) > 0 ;;\n\nlet inArray(xs: string list) (ys: string list) =\n  let zs = List.filter (fun (x) -> (containsInArray ys x)) xs in \n  (List.sort_uniq String.compare zs) ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216769,"user_id":null,"body":"let rec sort = function\n    | [] -> []\n    | x :: l -> insert x (sort l)\n  and insert elem = function\n    | [] -> [elem]\n    | x :: l -> if elem < x then elem :: x :: l\n      else x :: insert elem l;;\n\nlet contains longer s2 =\n  let re = Str.regexp_string s2\n  in\n  try ignore (Str.search_forward re longer 0); true\n  with Not_found -> false\n\nlet mem x lst =\n  List.exists (fun elm ->\n                contains elm x) lst\n\n\nlet remove_duplicates l =\n  let sl = sort  l in\n  let rec go l acc = match l with\n    | [] -> List.rev acc\n    | [x] -> List.rev (x::acc)\n    | (x1::x2::xs) ->\n      if x1 = x2\n      then go (x2::xs) acc\n      else go (x2::xs) (x1::acc)\n  in go sl []\n\n\nlet inArray(a1: string list) (a2: string list) =\n  let s = a2 in\n  List.iter print_endline s;\n  remove_duplicates (List.filter (fun x -> mem x s) a1 )\n\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216770,"user_id":null,"body":"#load \"str.cma\";;\n\nlet in_array(a1: string list) (a2: string list) =\n  let filtr s1 =\n    let reg = Str.regexp_string s1 in\n    let is_superstring_of_s1 s2 =\n      match Str.search_forward reg s2 0 with\n        | exception Not_found -> false\n        | _ -> true in\n    List.exists is_superstring_of_s1 a2 in\n  List.sort_uniq compare @@ List.filter filtr a1\n\n\nlet inArray = in_array","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216771,"user_id":null,"body":"let insert_sorted (a: string) (lst: string list) =\n  let rec aux (a: string) (lst: string list) (acc: string list) = \n    match lst with\n    | [] -> acc @ [a]\n    | hd :: tl ->\n        if hd > a then acc @ (a :: lst) \n        else if hd = a then acc @ lst\n        else aux a tl (acc @ [hd])\n  in aux a lst [] \n    \nlet rec contains_substring a b = \n  let lenb = String.length b in\n  let lena = String.length a in\n  if lena < lenb then false \n  else if (String.sub a 0 lenb)= b then true \n  else contains_substring (String.sub a 1 (lena - 1)) b \n\nlet rec search_substring a lst = \n  match lst with\n  | [] -> false\n  | hd :: tl -> if contains_substring hd a then true else search_substring a tl\n        \nlet inArray(a: string list) (b: string list) = \n  let rec aux (a: string list) (b: string list) (acc: string list) = \n    match a with\n    | [] -> acc\n    | hda :: tla -> if search_substring hda b then aux tla b (insert_sorted hda acc)\n        else aux tla b acc\n  in aux a b []","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216772,"user_id":98,"body":"let rec is_substring sub str =\n  let len_str = String.length str in\n  let len_sub = String.length sub in\n  if len_str < len_sub then\n    false\n  else let start = String.sub str 0 len_sub in\n    (start = sub) || is_substring sub (String.sub str 1 (len_str - 1))\n;;\n\nlet remove_duplicates list =\n  let rec remove_dups_rec list result =\n    match list with\n    | []     -> result\n    | h :: t -> remove_dups_rec t (if List.mem h result then result else h :: result)\n  in remove_dups_rec list []\n;;\n\nlet inArray(a1: string list) (a2: string list) =\n  let substrings = List.filter (fun sub -> List.exists (is_substring  sub) a2) a1\n  in List.sort compare (remove_duplicates substrings)\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216773,"user_id":null,"body":"let rec isNotIn m l = match l with \n  |[] -> true\n  |p::q when m = p -> false\n  |p::q -> isNotIn m q ;;\n  \nlet isInW m1 m2 =\n  let co = ref 0 in\n  let n =String.length m2 in\n  for i = 0 to n  - 1 do\n    if !co = String.length m1 then \n      ()\n    else (if m1.[!co]= m2.[i] then co := !co +1 else co := 0) ;\n  done ;\n  !co = String.length m1 ;;\n\nlet rec isInL m1 l = match l with\n  |[]-> false\n  |p::q -> if (isInW m1 p) then true else isInL m1 q\n;;\n\nlet rec fusion l1 l2 = match (l1,l2) with \n  |([],[])-> []\n  |([],r::s)->[r] @ (fusion l1 s)\n  |(p::q,r::s) when r<p-> [r] @ (fusion l1 s)\n  |(p::q,_) -> [p] @ (fusion q l2) ;;\n\nlet fission l =\n  let rec aux l1 l2 l i = match l with\n    |[] -> l1,l2\n    |p::q when ((i mod 2) = 0) -> aux (p::l1) l2 q (i+1) \n    |p::q -> aux l1 (p::l2) q (i+1) \n  in aux ([]) ([]) l 0;;\n  \nlet rec tri_fusion l = match l with \n  |[]->[]\n  |[p]->[p]\n  |_ -> fusion (tri_fusion (fst (fission l))) (tri_fusion (snd (fission l))) ;;\n\nlet inArray(a1: string list) (a2: string list) =\n  let rec aux rep a1 a2 = match a1 with\n    |[]-> rep\n    |p::q when isInL p a2 -> if (isNotIn p rep) then aux (p::rep) q a2 else aux rep q a2\n    |p::q -> aux rep q a2 \n  in tri_fusion (aux [] a1 a2)\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216774,"user_id":null,"body":"let isSubstring a2 a1 =\n  try\n    let len = String.length a2 in\n    for i = 0 to String.length a1 - len do\n      if String.sub a1 i len = a2 then raise Exit\n    done;\n    false\n  with Exit -> true\n\nlet inArray(a1: string list) (a2: string list) =\n  List.sort_uniq compare @@ List.filter (fun word -> List.exists (fun w2 -> isSubstring word w2) a2) a1\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216775,"user_id":null,"body":"let includes a b =\n  try Str.search_forward (Str.regexp a) b 0 >= 0 with Not_found -> false\n\nlet inArray (a1 : string list) (a2 : string list) =\n  List.filter (fun v1 -> List.exists (fun v2 -> includes v1 v2) a2) a1\n  |> List.sort_uniq compare\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216776,"user_id":null,"body":"let inArray (a1: string list) (a2: string list) =\n  let substr sub str = try (Str.search_forward (Str.regexp sub) str 0) >= 0 with Not_found -> false in\n  let sub_in_a2 sub = List.exists (substr sub) a2 in\n  let subs = List.filter sub_in_a2 a1 in\n  List.sort_uniq compare subs","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5506b230a11c0aeab3000c1f":[{"id":216777,"user_id":492,"body":"let evaporator _ (evapPerDay: float) (threshold: float): int =\n  int_of_float(ceil(log(threshold \/. 100.0) \/. log(1.0 -. evapPerDay \/. 100.0)));;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216778,"user_id":null,"body":"let evaporator _ (evapPerDay: float) (threshold: float): int =\n  truncate (ceil\n    ((log (threshold \/. 100.0))\n    \/.\n    (log (1.0 -. (evapPerDay \/. 100.0)))));;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216779,"user_id":null,"body":"let evaporator _ (evapPerDay: float) (threshold: float): int =\n  let b = 1.0 -. (evapPerDay \/. 100.0) in\n  let t = (log (threshold \/. 100.0)) \/. (log b) in\n  int_of_float (ceil t)\n  \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216780,"user_id":null,"body":"let evaporator _ (evapPerDay: float) (threshold: float): int =\nlet ev = 1. -. (evapPerDay \/. 100.) in\nlet thresh = threshold \/. 100. in\nint_of_float @@ ((log thresh) \/. (log ev) +. 1.)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216781,"user_id":null,"body":"let evaporator _ (pd: float) (th: float): int =\n  let rec ev ct p t = \n    if ct < t then 0 else 1 + ev (ct*.((100.0-.p)\/.100.0)) p t in\n    ev 100.0 pd th\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216782,"user_id":null,"body":"let evaporator start (evapPerDay: float) (threshold: float): int =\n  let rec aux = fun content days ->\n    let next = content -. content *. (evapPerDay \/. 100.) in\n    if next < start *. (threshold \/. 100.) then days else aux next days + 1\n  in\n    aux start 1\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216783,"user_id":null,"body":"let evaporator _ (evap_per_day: float) (threshold: float): int =\n  truncate @@ ceil @@ log (threshold \/. 100.) \/. log (1. -. evap_per_day \/. 100.)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216784,"user_id":null,"body":"let rec evap_impl (day: int) (start: float) (evap_coef: float) (threshold: float): int =\n  if start < threshold\n    then day\n    else evap_impl (day + 1) (start *. evap_coef) evap_coef threshold;;\n\nlet evaporator _ (evapPerDay: float) (threshold: float): int =\n  evap_impl 0 1.0 (1.0 -. evapPerDay \/. 100.0) (threshold \/. 100.0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216785,"user_id":98,"body":"let evaporator _ (evap_per_day: float) (threshold: float): int =\n\tint_of_float\n\t\t(ceil (\n\t\t\t(log (threshold \/. 100.0)) \/. log ((100.0 -. evap_per_day) \/. 100.0)\n\t\t)\n\t)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216786,"user_id":null,"body":"open Float\n\nlet evaporator _ (evapPerDay: float) (threshold: float): int =\n  let e = evapPerDay \/. 100. in\n  let t = threshold \/. 100. in\n  log t \/. log (1.0 -. e) |> ceil |> to_int ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5508249a98b3234f420000fb":[{"id":216787,"user_id":492,"body":"let movaux s shift sgn = \n  let cnt = ref 0 in\n    String.map(fun c ->\n                let sval = modu (sgn * (shift + !cnt)) 26 in\n                  (*print_int sval; print_endline \"\";*)\n                  cnt := !cnt + 1;\n                  let ch = int_of_char c in\n                  let cch =\n                    if isupper c then\n                      (modu (ch - 65 + sval) 26) + 65\n                    else if islower c then \n                      (modu (ch - 97 + sval) 26) + 97\n                    else\n                      ch\n                  in Char.chr cch)\n      s;;\n\nlet moving_shift (s: string) (shift: int): string list = \n  string_to_chunk (movaux s shift 1);;\n\nlet demoving_shift (a: string list) (shift: int): string =\n  movaux (String.concat \"\" a) shift (-1);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216788,"user_id":null,"body":"let is_lowercase_letter chr = \n    let code = Char.code chr in\n    97 <= code && code <= 122\n\n\nlet shift_lowercase_letter shift chr = \n    let code = Char.code chr in\n    let s = (code - 97 + shift) mod 26 in\n    let code' = if s >= 0 then s + 97 else s + 26 + 97 in\n    Char.chr code'\n\n\nlet shift_uppercase_letter shift chr = \n    chr |> Char.lowercase_ascii |> shift_lowercase_letter shift |> Char.uppercase_ascii\n    \n\nlet shift_letter k chr = \n    if is_lowercase_letter chr then shift_lowercase_letter k chr\n    else if is_lowercase_letter (Char.lowercase_ascii chr) then shift_uppercase_letter k chr\n    else chr\n    \n    \nlet create_list chars = \n    let n = List.length chars in\n    let k = if n mod 5 = 0 then n \/ 5 else n \/ 5 + 1 in\n    let rec loop acc = function\n        | [] -> List.rev_map (function lst -> lst |> List.map (String.make 1) |> String.concat \"\") acc\n        | cs -> \n            let open Batteries in\n            let first = List.take k cs in \n            let rest = List.drop k cs in\n            loop (first :: acc) rest in\n    let parts = loop [] chars in\n    if List.length parts < 5 then parts @ [\"\"] else parts\n    \n    \nlet moving_shift (s: string) (shift: int) = \n    let rec loop acc k = function\n        | [] -> List.rev acc\n        | c :: cs -> \n            let shifted_char = shift_letter k c in\n            loop (shifted_char :: acc) (k + 1) cs in\n    let char_list = s |> String.to_seq |> List.of_seq in        \n    char_list |> loop [] shift |> create_list\n    \n    \nlet demoving_shift (a: string list) (shift: int): string =\n    let shifted = a |> String.concat \"\" |> String.to_seq |> List.of_seq in\n    let rec loop acc k = function\n        | [] -> acc |> List.rev_map (String.make 1) |> String.concat \"\"\n        | c :: cs -> loop ((shift_letter (-k) c) :: acc) (k + 1) cs in\n    loop [] shift shifted","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216789,"user_id":null,"body":"let split s = let sizes = (String.length s |> Float.of_int) \/. 5.0 |> Float.ceil |> Float.to_int in \n  let rec aux acc = function\n    | \"\" -> acc\n    | s when String.length s < sizes -> s::acc\n    | s  -> aux ((String.sub s 0 sizes)::acc) (String.sub s (sizes) (String.length s - sizes)) in\n  aux [] s |> List.rev;;\n  \nlet shift_char n c = let code = Char.code c in let sc = code + (n mod 26) in\n  if code >= 65 && code <= 90 then \n    if sc < 65 then\n      sc + 26 |> Char.chr\n    else if sc > 90 then\n      sc - 26 |> Char.chr\n    else\n      sc |> Char.chr\n  else if code >= 97 && code <= 122 then\n    if sc < 97 then\n      sc + 26 |> Char.chr\n    else if sc > 122 then\n      sc - 26 |> Char.chr\n    else\n      sc |> Char.chr\n  else\n    c;;\n\nlet moving_shift (s: string) (shift: int): string list = let ss = split s in let len = String.length (List.hd ss) in\n  List.mapi (fun i s -> String.mapi (fun ic c -> shift_char (shift+ic+i*len) c) s) ss;;\n\nlet demoving_shift (a: string list) (shift: int): string = let len = String.length (List.hd a) in\n  List.mapi (fun i s -> String.mapi (fun ic c -> shift_char (-shift-ic-i*len) c) s) a |> String.concat \"\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216790,"user_id":null,"body":"let rec split ~count ~s =\n  let len = String.length s in\n  let part_len = String.length s \/ count in\n\n  if len mod count = 0 && count <= len then\n    List.init count (fun i -> String.sub s (i * part_len) part_len)\n  else\n    let part_len =\n      let part_len_rest = String.length s \/ (count - 1) in\n      if part_len_rest > part_len + 1 then part_len + 1 else part_len_rest\n    in\n    let even_boundary = part_len * (count - 1) in\n    let remaining_len = String.length s - even_boundary in\n    split ~count:(count - 1) ~s:(String.sub s 0 (part_len * (count - 1)))\n    @ [ String.sub s even_boundary remaining_len ]\n\nlet shift_char c ~shift =\n  let lower_case_a = int_of_char 'a' in\n  let lower_case_z = int_of_char 'z' in\n  let upper_case_a = int_of_char 'A' in\n  let upper_case_z = int_of_char 'Z' in\n  let c = int_of_char c in\n  let ( % ) i j = i mod j |> fun k -> if k < 0 then j + k else k in\n  (if c >= lower_case_a && c <= lower_case_z then\n   lower_case_a + ((c - lower_case_a + shift) % 26)\n  else if c >= upper_case_a && c <= upper_case_z then\n    upper_case_a + ((c - upper_case_a + shift) % 26)\n  else c)\n  |> char_of_int\n\nlet moving_shift (s : string) (shift : int) : string list =\n  let encrypt s ~shift =\n    String.to_seqi s\n    |> Seq.map (fun (i, c) -> shift_char c ~shift:(i + shift))\n    |> String.of_seq\n  in\n  split ~count:5 ~s:(encrypt s ~shift)\n\nlet demoving_shift (a : string list) (shift : int) : string =\n  let decrypt s ~shift =\n    String.to_seqi s\n    |> Seq.map (fun (i, c) -> shift_char c ~shift:((shift + i) * -1))\n    |> String.of_seq\n  in\n  List.fold_left ( ^ ) \"\" a |> decrypt ~shift\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216791,"user_id":null,"body":"let rec split ~count ~s =\n  let len = String.length s in\n  let part_len = String.length s \/ count in\n\n  if len mod count = 0 && count <= len then\n    List.init count (fun i -> String.sub s (i * part_len) part_len)\n  else\n    let part_len =\n      let part_len_rest = String.length s \/ (count - 1) in\n      if part_len_rest > part_len + 1 then part_len + 1 else part_len_rest\n    in\n    let even_boundary = part_len * (count - 1) in\n    let remaining_len = String.length s - even_boundary in\n    split ~count:(count - 1) ~s:(String.sub s 0 (part_len * (count - 1)))\n    @ [ String.sub s even_boundary remaining_len ]\n\nlet shift_char c ~shift =\n  let lower_case_a = int_of_char 'a' in\n  let lower_case_z = int_of_char 'z' in\n  let upper_case_a = int_of_char 'A' in\n  let upper_case_z = int_of_char 'Z' in\n  let c = int_of_char c in\n  let ( % ) i j = i mod j |> fun k -> if k < 0 then j + k else k in\n  (if c >= lower_case_a && c <= lower_case_z then\n   lower_case_a + ((c - lower_case_a + shift) % 26)\n  else if c >= upper_case_a && c <= upper_case_z then\n    upper_case_a + ((c - upper_case_a + shift) % 26)\n  else c)\n  |> char_of_int\n\nlet moving_shift (s : string) (shift : int) : string list =\n  let module List = ListLabels in\n  let encrypt s ~shift =\n    String.to_seqi s\n    |> Seq.map (fun (i, c) -> shift_char c ~shift:(i + shift))\n    |> String.of_seq\n  in\n  split ~count:5 ~s:(encrypt s ~shift)\n\nlet demoving_shift (a : string list) (shift : int) : string =\n  let decrypt s ~shift =\n    String.to_seqi s\n    |> Seq.map (fun (i, c) -> shift_char c ~shift:((shift + i) * -1))\n    |> String.of_seq\n  in\n  List.fold_left ( ^ ) \"\" a |> decrypt ~shift\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216792,"user_id":168,"body":"let rec split str (pos, len) (p, e) i =\n  match i with\n  | 5 -> [String.sub str pos len]\n  | _ ->\n    let p' = if i <= e then p + 1 else p in\n    String.sub str pos p' :: split str (pos + p', len - p') (p, e) (succ i)\n\nlet moving_shift (s: string) (shift: int): string list =\n  let ch0 = Char.code 'a' in\n  let ch1 = Char.code 'A' in\n  let encode i ch =\n    if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') then\n      let d = if ch >= 'A' && ch <= 'Z' then ch1 else ch0 in\n      Char.chr ((Char.code ch - d + i + shift) mod 26 + d)\n    else ch in\n  let c = String.mapi encode s in\n  let n = String.length c in\n  if n mod 5 = 0 then\n    split c (0, n) (n \/ 5, 0) 1\n  else\n    split c (0, n) (n \/ 5, n - 4 * (n \/ 5)) 1\n\nlet demoving_shift (a: string list) (shift: int): string =\n  let ch0 = Char.code 'a' in\n  let ch1 = Char.code 'A' in\n  let decode i ch =\n    if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') then\n      let d = if ch >= 'A' && ch <= 'Z' then ch1 else ch0 in\n      let t = (Char.code ch - d - i - shift) mod 26 in\n      Char.chr (d + if t < 0 then 26 + t else t)\n    else ch in\n  a |> String.concat \"\" |> String.mapi decode","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55084d3898b323f0aa000546":[{"id":216793,"user_id":null,"body":"let is_lowercase_letter chr =\n    let code = Char.code chr in\n    97 <= code && code <= 122\n\n\nlet shift_lowercase_letter shift chr =\n    let code = Char.code chr in\n    let s = (code - 97 + shift) mod 26 in\n    let code' = if s >= 0 then s + 97 else s + 26 + 97 in\n    Char.chr code'\n\n\nlet shift_uppercase_letter shift chr =\n    chr |> Char.lowercase_ascii |> shift_lowercase_letter shift |> Char.uppercase_ascii\n\n\nlet shift_letter k chr =\n    if is_lowercase_letter chr then shift_lowercase_letter k chr\n    else if is_lowercase_letter (Char.lowercase_ascii chr) then shift_uppercase_letter k chr\n    else chr\n\n\nlet create_list chars =\n    let n = List.length chars in\n    let k = if n mod 5 = 0 then n \/ 5 else n \/ 5 + 1 in\n    let rec loop acc = function\n        | [] -> List.rev_map (function lst -> lst |> List.map (String.make 1) |> String.concat \"\") acc\n        | cs ->\n            let open Batteries in\n            let first = List.take k cs in\n            let rest = List.drop k cs in\n            loop (first :: acc) rest in\n    loop [] chars\n\n\nlet encode (s: string) (shift: int): string list =\n    match s |> String.to_seq |> List.of_seq with\n        | [] -> [\"\"]\n        | (c :: _) as char_list ->\n            let encoded = List.map (shift_letter shift) char_list in\n            let lower = Char.lowercase_ascii c in\n            create_list (lower :: (shift_letter shift lower) :: encoded)\n\nlet decode (a: string list): string =\n    match a |> String.concat \"\" |> String.to_seq |> List.of_seq with\n        | c :: c' :: rest ->\n            let s = (Char.code c' - Char.code c) mod 26 in\n            let shift = if s < 0 then s + 26 else s in\n            rest |> List.map (shift_letter (-shift)) |> List.map (String.make 1) |> String.concat \"\"\n        | _ -> \"\"\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216794,"user_id":null,"body":"(* http:\/\/www.codewars.com\/kata\/55084d3898b323f0aa000546\/train\/ocaml *)\n\nlet ca = Char.code 'a';;\nlet cA = Char.code 'A';;\n\nlet test_char = function\n  | c when c >= 'a' && c <= 'z' -> `LowerCase\n  | c when c >= 'A' && c <= 'Z' -> `UpperCase\n  | _ -> `Other;;\n\nlet rec split_parts part_len s =\n  match s with\n  | \"\" -> []\n  | _ ->\n     let cut_len = min part_len (String.length s) in\n     let remain_len = String.length s - cut_len in\n     (String.sub s 0 cut_len) :: split_parts part_len (String.sub s cut_len remain_len);;\n\nlet shift_char shift c =\n  let _shift base = (Char.code c - base + shift) mod 26 + base |> Char.chr in\n  match test_char c with\n  | `LowerCase -> _shift ca\n  | `UpperCase -> _shift cA\n  | `Other -> c\n;;\n\nlet encode (s: string) (shift: int): string list =\n  let len_s = String.length s in\n  let part_len = (float_of_int (len_s + 2)) \/. 5.0 |> ceil |> int_of_float in\n  let buffer = Buffer.create @@ len_s + 2 in\n  let first_char = Char.lowercase s.[0] in\n  Buffer.add_char buffer first_char;\n  Buffer.add_char buffer (shift_char shift first_char);\n  String.map (shift_char shift) s |> Buffer.add_string buffer;\n  Buffer.contents buffer\n  |> split_parts part_len\n;;\n\nlet decode (a: string list): string =\n  let full_msg = String.concat \"\" a in\n  let header = String.sub full_msg 0 2 in\n  let body = String.sub full_msg 2 (String.length full_msg - 2) in\n  let shift = 26 - (Char.code header.[1] + 26 - Char.code header.[0]) mod 26 in\n  let msg = String.map (shift_char shift) body in\n  msg\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216795,"user_id":168,"body":"let rec split str (pos, len) (p, e) i =\n  match i with\n  | 5 -> [String.sub str pos len]\n  | _ ->\n    let p' = if i <= e then p + 1 else p in\n    String.sub str pos p' :: split str (pos + p', len - p') (p, e) (succ i)\n\nlet encode (s: string) (shift: int): string list =\n  let ch0 = Char.code 'a' in\n  let ch1 = Char.code 'A' in\n  let encode ch =\n    if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') then\n      let d = if ch >= 'A' && ch <= 'Z' then ch1 else ch0 in\n      Char.chr ((Char.code ch - d + shift) mod 26 + d)\n    else ch in\n  let p1 = Char.lowercase s.[0] in\n  let p2 = Char.chr (Char.code p1 + shift) in\n  let prefix = String.init 2 (fun i -> if i = 0 then p1 else p2) in\n  let c = prefix ^ String.map encode s in\n  let n = String.length c in\n  List.filter (fun x -> String.length x > 0)\n    (if n mod 5 = 0 then\n       split c (0, n) (n \/ 5, 0) 1\n     else\n       split c (0, n) (n \/ 5, n - 4 * (n \/ 5)) 1)\n\nlet decode (a: string list): string =\n  let msg = String.concat \"\" a in\n  let shift = Char.code msg.[1] - Char.code msg.[0] in\n  let ch0 = Char.code 'a' in\n  let ch1 = Char.code 'A' in\n  let decode ch =\n    if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') then\n      let d = if ch >= 'A' && ch <= 'Z' then ch1 else ch0 in\n      let t = (Char.code ch - d + 26 - shift) mod 26 in\n      Char.chr (d + t)\n    else ch in\n  String.map decode (String.sub msg 2 (String.length msg - 2))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216796,"user_id":492,"body":"let movaux0 s shift sgn = \n  let cnt = ref 0 in\n    String.map(fun c ->\n                let sval = modu (sgn * (shift + !cnt)) 26 in\n                (*cnt := !cnt + 1;*)\n                let ch = int_of_char c in\n                let cch =\n                  if isupper c then\n                    (modu (ch - 65 + sval) 26) + 65\n                  else if islower c then \n                    (modu (ch - 97 + sval) 26) + 97\n                  else\n                    ch\n                in Char.chr cch)\n      s;;\n\nlet encode (s: string) (shift: int): string list =\n  let f = lowercase_ascii(String.make 1 s.[0]) in\n  let ch = int_of_char(f.[0]) in\n  let r = Char.chr((modu (ch - 97 + shift) 26) + 97) in\n    string_to_chunk(f ^ (String.make 1 r) ^ (movaux0 s shift 1)) |> List.filter(fun x -> x <> \"\");;\n\nlet decode (a: string list): string =\n  let s = String.concat \"\" a in\n  let shift = (int_of_char s.[1]) - (int_of_char s.[0]) in\n    String.sub (movaux0 s shift (-1)) 2 (String.length s - 2);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216797,"user_id":492,"body":"let movaux0 s shift sgn = \n  let cnt = ref 0 in\n    String.map(fun c ->\n                let sval = modu (sgn * (shift + !cnt)) 26 in\n                (*cnt := !cnt + 1;*)\n                let ch = int_of_char c in\n                let cch =\n                  if isupper c then\n                    (modu (ch - 65 + sval) 26) + 65\n                  else if islower c then \n                    (modu (ch - 97 + sval) 26) + 97\n                  else\n                    ch\n                in Char.chr cch)\n      s;;\n\nlet encode (s: string) (shift: int): string list =\n  let f = lowercase_ascii(String.make 1 s.[0]) in\n  let ch = int_of_char(f.[0]) in\n  let r = Char.chr((modu (ch - 97 + shift) 26) + 97) in\n    string_to_chunk(f ^ (String.make 1 r) ^ (movaux0 s shift 1)) |> List.filter(fun x -> x <> \"\");;\n\nlet decode (a: string list): string =\n  let s = String.concat \"\" a in\n  let shift = (int_of_char s.[1]) - (int_of_char s.[0]) in\n    String.sub (movaux0 s shift (-1)) 2 (String.length s - 2);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"550f22f4d758534c1100025a":[{"id":216798,"user_id":527,"body":"let opposite = function\n  | \"NORTH\" -> \"SOUTH\"\n  | \"SOUTH\" -> \"NORTH\"\n  | \"EAST\" -> \"WEST\"\n  | \"WEST\" -> \"EAST\"\n  | _ -> assert false\n\nlet dir_reduc (dirs: string list): string list = \n  let f = fun cur_dir prev_dirs ->\n    match prev_dirs with\n    | d :: ds when d = opposite cur_dir -> ds\n    | _ -> cur_dir :: prev_dirs\n  in List.fold_right f dirs []\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216799,"user_id":492,"body":"let rec dir_reduc (ls: string list): string list = \n  let opposite (x, y) =\n    match (x, y) with\n      | (\"NORTH\", \"SOUTH\") -> true\n      | (\"SOUTH\", \"NORTH\") -> true\n      | (\"WEST\", \"EAST\")   -> true\n      | (\"EAST\", \"WEST\")   -> true\n      | (_, _)             -> false\n\n  in\n  let rec removePairs(ls: string list): string list =\n    match ls with\n      | x :: y :: xs -> if (opposite (x, y)) then removePairs xs else x :: (removePairs (y :: xs))\n      | xs -> xs\n  in\n  let l = removePairs ls in\n    if (l = ls) then ls else dir_reduc l;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216800,"user_id":null,"body":"let dir_reduc (list: string list): string list = \n  let opp x y = \n  (x, y) = (\"NORTH\", \"SOUTH\") || (x, y) = (\"SOUTH\", \"NORTH\") || (x, y) = (\"WEST\", \"EAST\") || (x, y) = (\"EAST\", \"WEST\") in\n  \n  let rec simplify lst = match lst with\n    |[] |[_] -> (lst, false)\n    |x :: y :: q -> if opp x y then (fst (simplify q), true)\n                    else begin\n                      let simp, changed = simplify (y :: q) in\n                      (x :: simp, changed) end in\n                      \n  let not_done = ref true and lst = ref list in\n  while !not_done do\n    let simp, changed = simplify !lst in\n    lst := simp;\n    not_done := changed\n  done;\n  !lst;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216801,"user_id":null,"body":"let rec dir_reduc (ls: string list): string list = \n  let rec aux ls = match ls with\n    | [] -> ls\n    | h::[] -> ls\n    | h1::h2::t -> \n      if (h1 = \"NORTH\")&&(h2 = \"SOUTH\")||(h2 = \"NORTH\")&&(h1 = \"SOUTH\")then\n        dir_reduc t\n      else if (h1 = \"EAST\")&&(h2 = \"WEST\")||(h2 = \"EAST\")&&(h1 = \"WEST\") then\n        dir_reduc t\n      else\n        h1::(dir_reduc (h2::t))\n  in\n  let rec equal a b = match a,b with\n    | [], [] -> true\n    | h::t, [] -> false\n    | [], h::t -> false\n    | h1::t1, h2::t2 -> (h1 = h2)&&(equal t1 t2)\n  in\n  let rec main ls =\n    if equal ls (aux ls) then\n      ls\n    else\n      main (aux ls)\n  in main ls \n;;   \n     ","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216802,"user_id":null,"body":"let dir_reduc ls =\n  let op = function\n    | \"NORTH\" -> \"SOUTH\"\n    | \"SOUTH\" -> \"NORTH\"\n    | \"WEST\" -> \"EAST\"\n    | \"EAST\" -> \"WEST\"\n    | _ -> invalid_arg \"op\" in\n  let rec aux ls acc =\n    match ls with\n    | [] -> List.rev acc\n    | [x] -> List.rev_append acc [x]\n    | hd1 :: hd2 :: tl ->\n      if hd1 = (op hd2)\n      then aux (List.rev_append acc tl) []\n      else aux (hd2 :: tl) (hd1 :: acc) in\n  aux ls []","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216803,"user_id":98,"body":"let opposite_directions x y = \n  match x with\n  | \"SOUTH\" ->  y = \"NORTH\"\n  | \"NORTH\" ->  y = \"SOUTH\"\n  | \"WEST\"  ->  y = \"EAST\"\n  | \"EAST\"  ->  y = \"WEST\"\n  | _ -> failwith (\"invalid direction : \" ^ x)\n;;\n\nlet rec dir_reduc (directions: string list): string list =\n\n  let rec reduce_rec directions =\n    match directions with\n    | []        -> []\n    | h::[]     -> [h]            \n    | h1::h2::t ->\n        if opposite_directions h1 h2 then\n          reduce_rec t\n        else\n          h1 :: (reduce_rec (h2 :: t))\n\n  in let reduced = reduce_rec directions\n  in if reduced = directions then reduced else dir_reduc reduced\n;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216804,"user_id":null,"body":"let dir_reduc (ls: string list): string list =\n  let rec reduce res ls =\n    match ls with\n        [] -> List.rev res\n      | h1 :: h2 :: t -> (\n        match h1, h2 with\n            \"NORTH\", \"SOUTH\" | \"SOUTH\", \"NORTH\"\n          | \"EAST\", \"WEST\" | \"WEST\", \"EAST\" -> reduce res t\n          | _, _ -> reduce (h1::res) (h2::t)\n        )\n      | h::[] -> List.rev (h::res)\n  in\n  let rec reduce_fully ls =\n    let reduced = reduce [] ls in\n    if (List.length reduced) == (List.length ls) then ls else\n    reduce_fully reduced\n  in\n  reduce_fully ls","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216805,"user_id":null,"body":"let dir_reduc (ls: string list): string list =\n  let rec reduce res ls =\n    match ls with\n        [] -> List.rev res\n      | h1 :: h2 :: t -> (\n        match h1, h2 with\n            \"NORTH\", \"SOUTH\" -> reduce res t\n          | \"SOUTH\", \"NORTH\" -> reduce res t\n          | \"EAST\", \"WEST\" -> reduce res t\n          | \"WEST\", \"EAST\" -> reduce res t\n          | _, _ -> reduce (h1::res) (h2::t)\n        )\n      | h::[] -> List.rev (h::res)\n  in\n  let rec reduce_fully ls =\n    let reduced = reduce [] ls in\n    if (List.length reduced) == (List.length ls) then ls else\n    reduce_fully reduced\n  in\n  reduce_fully ls","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216806,"user_id":null,"body":"open Stack\n\nlet top_opt s =\n  if is_empty s then None else Some (top s)\n\nlet dir_reduc (ls: string list): string list = \n  let s = create () in\n  let forbidden = [\"EAST\", \"WEST\"; \"NORTH\", \"SOUTH\"; \"WEST\", \"EAST\"; \"SOUTH\", \"NORTH\"] in\n  let rec aux = function\n    | [] -> fold (fun l x -> x :: l) [] s\n    | a :: q -> begin match top_opt s with\n      | Some dir when List.mem (dir, a) forbidden -> ignore (pop s)\n      | _ -> push a s end;\n      aux q in\n  aux ls","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216807,"user_id":null,"body":"let rec dir_reduc (ls : string list) : string list =\n  let rec loop = function\n    | [] -> []\n    | \"NORTH\" :: \"SOUTH\" :: t\n    | \"SOUTH\" :: \"NORTH\" :: t\n    | \"EAST\" :: \"WEST\" :: t\n    | \"WEST\" :: \"EAST\" :: t ->\n        dir_reduc t\n    | h :: t -> h :: loop t\n  in\n  let result = loop ls in\n  if result = ls then result else dir_reduc result\n","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5517fcb0236c8826940003c9":[{"id":216808,"user_id":53,"body":"let rec gcd (u: int) (v: int) :int = \n  if v == 0 then u else gcd v (u mod v)\n  ;;\n  \n  let sum_fracts (xss: (int * int) list) : string option =\n  let d = List.fold_left (fun acc xs -> (snd xs) * acc) 1 xss in\n  let n = List.fold_left (fun acc xs -> ((fst xs) * d) \/ (snd xs) + acc) 0 xss in\n  let g = gcd d n in\n  if (List.length xss) == 0 then None\n  else if g == d then Some (Printf.sprintf \"%d\" (n \/ d))\n  else Some (Printf.sprintf \"%d %d\" (n \/ g) (d \/ g))\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216809,"user_id":null,"body":"let rec pgcd a = function\n  | 0 -> a\n  | b -> pgcd b (a mod b)\n\nlet reduce (a, b) = let d = pgcd a b in (a \/ d, b \/ d)\n\nlet rec sum = function\n  | [] -> (0, 1)\n  | t::q -> let (a, b) = t and (c, d) = sum q in reduce (a * d + b * c, b * d)\n\nlet sum_fracts = function\n  | [] -> None\n  | xs -> let (a, b) = sum xs in\n          if b = 1 then Some (Printf.sprintf \"%d\" a) else Some (Printf.sprintf \"%d %d\" a b)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216810,"user_id":null,"body":"let rec gcd a b = (* nonnegative integers only *)\n  if a = 0 && b = 0 then failwith \"GCD\"\n  else if a * b = 0 then a + b\n  else gcd b (a mod b);;\n\nlet lcm a b = a * b \/ (gcd a b);;\n\nlet lcmlist = function\n| [] -> failwith \"Case already handled\"\n| a::q -> List.fold_left lcm a q;;\n\nlet new_numerator m (a, b) = a * m \/ b;;\n\nlet sum_fracts (xs: (int * int) list) : string option =\n  match xs with\n  | [] -> None\n  | l -> let m = lcmlist (List.map snd xs) in\n    let numerators = List.map (new_numerator m) xs in\n    let numeratorsum = List.fold_left (fun x y -> x + y) 0 numerators in\n    let d = gcd numeratorsum m in\n    if d = m then Some (string_of_int (numeratorsum \/ d))\n    else Some (Printf.sprintf \"%d %d\" (numeratorsum \/ d) (m \/ d))\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216811,"user_id":null,"body":"let rec find_denom lst =\n  match lst with\n  | [] -> 1\n  | (h,i)::t -> i * (find_denom t)\n;;\n\nlet rec find_num lst denom =\n  match lst with\n  | [] -> 0\n  | (h,i)::t -> (h*(denom\/i)) + (find_num t denom)\n;;\n\nlet rec find_gcd a b =\n  match b with\n  | 0 -> a\n  | _ -> find_gcd b (a mod b)\n;;\n\nlet rec sum2 xs = \n  let denom = find_denom xs in\n  let num = find_num xs denom in\n  match (num mod denom) with\n  | 0 -> string_of_int (num\/denom)\n  | _ -> let gcd = find_gcd num denom in\n         (string_of_int (num\/gcd)) ^ \" \" ^ (string_of_int (denom\/gcd))\n;;\n\nlet sum_fracts (xs: (int * int) list): string option =\n  match xs with\n  | [] -> None\n  | _ -> Some (sum2 xs)\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216812,"user_id":null,"body":"let rec euclide b r = match b mod r with\n  |0 -> r\n  |a -> euclide r a\n;;\n\nlet addFrac a b =\n  let x,y = a in \n  let v,w = b in\n  ( x*w + v*y, w*y)\n;;\n\nlet red f = let a,b = f in let pgcd = (euclide a b) in\n  (a\/pgcd,b\/pgcd)\n;;\n\nlet tupToStr f = let a,b = f in\n  if f=(-1,-1) then None else (\n    if b = 1 then Some (string_of_int a) else Some ((string_of_int a)^\" \"^(string_of_int b)) );;\n\nlet sum_fracts (xs: (int * int) list) : string option =\n  let rec aux s f = match s with \n    |[]->f\n    |p::q -> if f = (-1,-1) then aux q p  else aux q (red(addFrac p f))\n  in tupToStr (aux xs (-1,-1));;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216813,"user_id":null,"body":"let sum_fracts (xs: (int * int) list) : string option =\n  match xs with\n  | [] -> None\n  | _ ->\n    let rec gcd x y =\n      if y > 0\n        then gcd y (x mod y)\n        else x\n    in\n    let lcm x y = x * y \/ (gcd x y) in\n    let lcm_of_all = List.fold_left (fun x (_, denom) -> lcm x denom) 1 xs in\n    let sum_of_all = List.fold_left (fun x (num, denom) -> x + num * lcm_of_all \/ denom) 0 xs in\n    let gcd_of_result = gcd sum_of_all lcm_of_all in\n    Some ((string_of_int (sum_of_all \/ gcd_of_result)) ^ if lcm_of_all = gcd_of_result then \"\" else \" \" ^ (string_of_int (lcm_of_all \/ gcd_of_result)))\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216814,"user_id":null,"body":"let sum_fracts (xs : (int * int) list) : string option =\n  let n, d =\n    List.fold_left\n      (fun (n1, d1) (n2, d2) -> ((n1 * d2) + (n2 * d1), d1 * d2))\n      (0, 1) xs\n  in\n  if n = 0 then None\n  else if n mod d = 0 then Some (string_of_int (n \/ d))\n  else\n    let rec gcd a b = if a mod b > 0 then gcd b (a mod b) else b in\n    let g = gcd n d in\n    Some (Printf.sprintf \"%d %d\" (n \/ g) (d \/ g))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216815,"user_id":null,"body":"let sum_fracts (xs : (int * int) list) : string option =\n  if xs = [] then None\n  else\n    let sum =\n      List.fold_left\n        (fun (n1, d1) (n2, d2) -> ((n1 * d2) + (n2 * d1), d1 * d2))\n        (0, 1) xs\n    in\n    let rec reduce (n, d) p =\n      if p > n \/ 2 || p > d \/ 2 then (n, d)\n      else if n mod p = 0 && d mod p = 0 then reduce (n \/ p, d \/ p) p\n      else reduce (n, d) (p + 1)\n    in\n    let n, d = reduce sum 2 in\n    if n mod d = 0 then Some (string_of_int (n \/ d))\n    else Some (Printf.sprintf \"%d %d\" n d)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216816,"user_id":null,"body":"let pgcd a b =\n\tlet rec aux x y =\n\t\tif y = 0\n\t\t\tthen x\n\t\t\telse aux y (x mod y)\n\tin abs (aux a b);;\n\nlet sum c1 c2 =\n\t(fst c1 * snd c2 + fst c2 * snd c1, snd c1 * snd c2);;\n\nlet sum_fracts (xs: (int * int) list) : string option =\n  if xs = [] then None else\n  let (nn, dd) = List.fold_left sum (0, 1) xs in\n  let p = pgcd nn dd in\n  let (n, d) = (nn\/p, dd\/p) in\n  if d = 1\n    then Some (string_of_int n)\n    else Some (string_of_int n ^ \" \" ^ string_of_int d);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216817,"user_id":null,"body":"\nlet sum_fracts (xs : (int * int) list) : string option =\n  let rec gcd a b = if a mod b > 0 then gcd b (a mod b) else b in\n  let add (a, b) (c, d) =\n    let num, denum = ((a * d) + (b * c), b * d) in\n    let d = gcd num denum in\n    (num \/ d, denum \/ d)\n  in\n  match xs with\n  | [] -> None\n  | x :: xs ->\n      let a, b = List.fold_left add x xs in\n      if b = 1 then Some (string_of_int a)\n      else Some (Printf.sprintf \"%d %d\" a b)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5536a85b6ed4ee5a78000035":[{"id":216818,"user_id":168,"body":"let tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list) =\n  let towns = ftwns |> Array.map (fun x -> x.(0), x.(1)) |> Array.to_list in\n  let d0 town = List.assoc town h in\n  let chain = Array.fold_right\n    (fun f c -> try List.assoc f towns :: c with Not_found -> c) arrFriends [] in\n  let rec loop acc prev ts =\n    match prev, ts with\n    | None, [] -> acc\n    | Some t0, [] -> acc +. d0 t0\n    | None, t :: ts ->\n      loop (acc +. d0 t) (Some t) ts\n    | Some t0, t :: ts ->\n      loop (acc +. sqrt (abs_float ((d0 t) ** 2. -. (d0 t0) ** 2.))) (Some t) ts in\n  truncate (loop 0. None chain)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216819,"user_id":null,"body":"let tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list): int =\n  let pyth hyp sid = Float.sqrt (abs_float (hyp*.hyp -. sid*.sid)) in\n  let get_dist s = snd (List.find (fun x -> (fst x) = s) h) in\n  let get_twn fri = \n    let twn = ref \"\" in\n    for i = 0 to (Array.length ftwns) -1 do\n      if ftwns.(i).(0) = fri then \n        twn := ftwns.(i).(1)\n    done;\n    !twn in\n  let dist = ref 0.0 in\n  let old_twn_dist = ref 0.0 in\n  for i = 0 to (Array.length arrFriends) -1 do\n    let friTwn = (get_twn arrFriends.(i)) in\n    if friTwn <> \"\" then (\n      let twn_dist = (get_dist friTwn) in\n      dist := !dist +. (pyth twn_dist !old_twn_dist);\n      old_twn_dist := twn_dist\n    );\n  done;\n  int_of_float (!dist +. !old_twn_dist);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216820,"user_id":492,"body":"let tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list): int =\n  let is_in(str: string) (a: string array): bool =\n    if (a.(0) = str) then true else false\n  in\n  let do_tour(arrFriends: string array) (friendTowns: string array array) =\n    let res = Array.make (Array.length arrFriends) \"\" in\n      for i = 0 to Array.length(arrFriends) - 1 do\n        for j = 0 to Array.length(friendTowns) - 1 do\n          if (is_in arrFriends.(i) friendTowns.(j)) then begin\n            res.(i) <- friendTowns.(j).(1);\n          end;\n        done;\n      done;\n      res |> Array.to_list |> List.filter(fun x -> x <> \"\") |> Array.of_list\n  in\n  let distance(tour: string array) (h: (string * float) list): int =\n    let x = tour.(0) in\n    let sum = ref(List.assoc x h) in\n      for i = 0 to Array.length tour - 2 do\n        let x1 = tour.(i) in\n        let x2 = tour.(i + 1) in\n        let dx1 = List.assoc x1 h in\n        let dx2 = List.assoc x2 h in\n        let di = sqrt (abs_float (dx2 *. dx2 -. dx1 *. dx1)) in\n          sum := !sum +. di;\n      done;\n      let xn = List.assoc tour.(Array.length tour - 1) h in\n        int_of_float(!sum +. xn)\n  in\n    distance (do_tour arrFriends ftwns) h;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216821,"user_id":null,"body":"let get_distance town towns =\n  let rec get_distance_i = function\n    |(t, d)::_ when t = town -> d\n    |_::tl -> get_distance_i tl\n    |[] -> 0.\n  in get_distance_i towns\n\nlet int_of_digit = function\n  |'0'..'9' as c -> (int_of_char c) - 0x30\n  |_->0\n\nlet int_of_town t = \n  int_of_digit t.[1]\n\nlet town_of_int n =\n  \"X\" ^ (Char.escaped (char_of_int (n+0x30)))\n\nlet absF f = \n  if f < 0.0 then ~-.f else f \n\nlet rec distance_from towns t1 t2 =\n  let (t1d, t2d) = (get_distance t1 towns, get_distance t2 towns) in\n  match (int_of_town t1),(int_of_town t2) with\n    | a,0 -> get_distance (t1) towns\n    | 0,b -> get_distance (t2) towns\n    | a,b -> absF (Float.sqrt (t2d**2. -. t1d**2.))\n    |_->0.\n\nlet town_of_friend ftwns f =\n  let rec town_of_friend_i = function\n    | (friend::town::_)::_ when friend = f -> town\n    | _::tl -> town_of_friend_i tl\n    | [] -> \"\"\n  in town_of_friend_i ftwns\n\nlet paths_of_friends friends ftwns =\n  let rec paths_of_friends_i = function\n    | ([], hd::tl) -> (\n      if (town_of_friend ftwns hd) <> \"\" then\n        paths_of_friends_i (([(\"X0\", town_of_friend ftwns hd)]),tl)\n      else\n        paths_of_friends_i ([],tl)\n    )\n    | (((_,lt)::_) as acc, hd::tl) -> (\n      if (town_of_friend ftwns hd) <> \"\" then\n        paths_of_friends_i (((lt,town_of_friend ftwns hd)::acc),tl)\n      else\n        paths_of_friends_i (acc,tl)\n    )\n    | (((_,lt)::_) as acc, []) -> (\"X0\", lt)::acc\n  in paths_of_friends_i ([],friends) |> List.rev\n\nlet string_of_path p = \n  let rec string_of_path_i acc = function\n    |((a, b)::[]) -> acc^(a)^\"->\"^(b)\n    |((a, b)::tl) -> string_of_path_i (acc^(a)^\"->\"^(b)^\", \") tl\n  in string_of_path_i \"\" p \n\nlet tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list): int =\n  let ftwns = ftwns |> Array.to_seq |> List.of_seq |> List.map (fun x -> x |> Array.to_seq |> List.of_seq) in\n  let friends = arrFriends |> Array.to_seq |> List.of_seq in\n  let towns = h in\n  let path = paths_of_friends friends ftwns in\n  print_endline (string_of_path path);\n  let rec tour_i acc = function\n    | ((a,b)::[]) -> acc +. (distance_from towns a b)\n    | ((a,b)::tl) -> tour_i (acc +. (distance_from towns a b)) tl\n  in int_of_float (tour_i 0. path)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216822,"user_id":null,"body":"let tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list): int =\n  Array.iter (print_string) arrFriends;\n  print_string \"\n\";\n  Array.iter (fun s -> (print_string s.(0); print_string s.(1))) ftwns;\n  print_string \"\n\";\n  List.iter (fun s -> (print_string (fst s); print_float (snd s))) h;\n  let pyth hyp sid = let hyp1 = max hyp sid in let sid1 = min hyp sid in Float.sqrt (hyp1*.hyp1 -. sid1*.sid1) in\n  let get_dist s = snd (List.find (fun x -> (fst x) = s) h) in\n  let get_twn fri = \n    let twn = ref \"\" in\n    for i = 0 to (Array.length ftwns) -1 do\n      if ftwns.(i).(0) = fri then \n        twn := ftwns.(i).(1)\n    done;\n    !twn in\n  let dist = ref 0.0 in\n  let old_twn_dist = ref 0.0 in\n  for i = 0 to (Array.length arrFriends) -1 do\n    let friTwn = (get_twn arrFriends.(i)) in\n    if friTwn <> \"\" then (\n      let twn_dist = (get_dist friTwn) in\n      dist := !dist +. (pyth twn_dist !old_twn_dist);\n      old_twn_dist := twn_dist;\n      print_float !dist;\n      print_string \"\n\";\n    );\n  done;\n  int_of_float (!dist +. !old_twn_dist);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216823,"user_id":null,"body":"let find_opt h = function\n  | [||] ->\n    0.\n  | [| _; town |] ->\n    List.assoc_opt town h |> ( function Some x -> x | None -> 0. )\n  | _ ->\n    0.\n\nlet count x y = if y < x then Float.(sqrt ((x ** 2.) -. (y ** 2.))) else Float.(sqrt ((y ** 2.) -. (x ** 2.)))\n\nlet counter_fn h (prev, aux) x =\n  let new_val = find_opt h x in\n  if aux = 0. then\n    (new_val, aux +. new_val)\n  else\n    (new_val, aux +. (count new_val prev))\n\nlet rec insert_at_end l i =\n  match l with [] -> [ i ] | h :: t -> h :: insert_at_end t i\n\nlet tour\n    (arrFriends : string array)\n    (ftwns : string array array)\n    (h : (string * float) list)\n    : int\n  =\n  let check_val arr value = Array.exists (fun p -> p = value) arr in\n  let filtered_array =\n    Array.fold_left\n      (fun aux [| name; town |] ->\n        if check_val arrFriends name then\n          insert_at_end aux [| name; town |]\n        else\n          aux)\n      []\n      ftwns\n    |> Array.of_list\n  in\n  let count_distance array =\n    Array.fold_left (counter_fn h) (0., 0.) array\n  in\n  count_distance filtered_array |> function\n  | prev, integer ->\n    prev +. integer |> int_of_float\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216824,"user_id":480,"body":"open String\n\nlet tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list): int =\n  let rec town ltwns a=\n    match ltwns with\n    |[] -> \"\"\n    |h::ltwns -> if String.equal h.(0) a then h.(1) else town ltwns a\n  in\n  let dist_from_table town=\n    let rec distr l=\n      match l with |[]->0.|(t,d)::l->if String.equal t town then d else distr l\n    in distr h\n  in\n  let rec dist ta tb=\n    if String.equal ta tb then 0. else\n    if String.equal tb \"X0\" then dist_from_table ta else\n    if String.equal ta \"X0\" then dist_from_table tb else\n    let square x=x*.x\n    and da=dist_from_table ta and db=dist_from_table tb \n    in\n    Float.sqrt (Float.abs ((square da)-.(square db) ))\n  in\n  let town2 a=\n    town (Array.to_list ftwns) a\n  in\n    let towns=Array.map town2 arrFriends|>Array.to_list in\n    let towns=List.filter (fun s->(String.length s)>0) towns in\n    let rec townpairs town towns=\n      match towns with |[]-> [[town;\"X0\"]]|townb::towns->[[town;townb]] @ (townpairs townb towns) in\n    let townpairs=townpairs \"X0\" towns in\n    let rec dists acc townpairs=\n      match townpairs with \n      |[]->acc\n      |pair::townpairs->\n        let d=dist (List.hd pair) (List.nth pair 1) in\n        dists (acc+.d) townpairs\n    in\n    int_of_float (Float.floor (dists 0. townpairs))\n    ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216825,"user_id":492,"body":"let tour(arrFriends: string array) (ftwns: string array array) (h: (string * float) list): int =\n  let is_in(str: string) (a: string array): bool =\n    if (a.(0) = str) then true else false\n  in\n  let do_tour(arrFriends: string array) (friendTowns: string array array) =\n    let res = Array.make (Array.length arrFriends) \"\" in\n      for i = 0 to Array.length(arrFriends) - 1 do\n        for j = 0 to Array.length(friendTowns) - 1 do\n          if (is_in arrFriends.(i) friendTowns.(j)) then begin\n            res.(i) <- friendTowns.(j).(1);\n          end;\n        done;\n      done;\n      res |> Array.to_list |> List.filter(fun x -> x <> \"\") |> Array.of_list\n  in\n  let distance(tour: string array) (h: (string * float) list): int =\n    let x = tour.(0) in\n    let sum = ref(List.assoc x h) in\n      for i = 0 to Array.length tour - 2 do\n        let x1 = tour.(i) in\n        let x2 = tour.(i + 1) in\n        let dx1 = List.assoc x1 h in\n        let dx2 = List.assoc x2 h in\n        let di = sqrt (abs_float (dx2 *. dx2 -. dx1 *. dx1)) in\n          sum := !sum +. di;\n      done;\n      let xn = List.assoc tour.(Array.length tour - 1) h in\n        int_of_float(!sum +. xn)\n  in\n    distance (do_tour arrFriends ftwns) h;;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5539fecef69c483c5a000015":[{"id":216826,"user_id":null,"body":"let rec backwards_prime (m: int) (n: int): int list =\n    let rec prime n d = match d with \n    | 0 | 1 -> n > 1 \n    | _ -> (n mod d <> 0) &&  (prime n (d-1)) in \n    let rev_m = (int_of_string (String.concat \"\" (List.rev (List.init (String.length (string_of_int m)) (fun c -> Char.escaped (String.get (string_of_int m) c)))))) in \n    match n with \n    | 0 | 1 -> []\n    | _ when m > n -> []\n    | _ when rev_m = m -> backwards_prime (m+1) n\n    | _ when prime m ((int_of_float (sqrt (float_of_int m))) + 1) && prime rev_m ( (int_of_float(sqrt(float_of_int rev_m)))+1) -> m::(backwards_prime (m+1) n)\n    | _ -> backwards_prime (m+1) n\n    ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 15:11:10"},{"id":216827,"user_id":53,"body":"let is_prime (n: int): bool =\n  let rec aux m =\n    m * m > n || (n mod m != 0 && aux (m + 1))\n  in\n    n >= 2 && aux 2\n  ;;\n  \nlet reverse_digits (n: int): int = \n  let rec aux acc = function\n    | 0 -> acc\n    | n -> aux (acc * 10 + n mod 10) (n \/ 10) in \n  aux 0 n\n  ;;\n  \nlet is_palindromic(n: int): bool =\n  reverse_digits(n) == n\n  ;;\n  \nlet range a b s = \n  let rec aux acc k = \n    if k > b then List.rev acc\n    else aux (k :: acc) (k + s)\n  in aux [] a\n;;\n  \nlet backwards_prime (m: int) (n: int): int list =\n  let r = range m n 1 in\n  List.filter (fun x -> (is_prime x) && (not (is_palindromic x)) && (is_prime (reverse_digits x))) r\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 15:11:12"},{"id":216828,"user_id":null,"body":"let backwards_prime (m: int) (n: int): int list =\n  let rec backwards_primes (z : int) (k : int) (l : int): int list =\n    let rec checkPrime (count : int) (o : int) : bool =  \n      if count*count > o then true else if o mod count = 0 then false else \n        checkPrime (count + 1) o in \n    let rec reverseStr (s : string) (num : int) : string = \n      if num = 0 then s else \n        (reverseStr (String.sub s 1 (String.length s - 1)) (num - 1))^(String.sub s 0 1)\n    in \n    if z > k then [] else if checkPrime 2 z then \n      let rev = int_of_string (reverseStr (string_of_int z) (String.length (string_of_int z))) in \n      if checkPrime 2 rev && rev != z\n      then [z] @ backwards_primes (z+1) k l else backwards_primes (z+1) k l\n    else backwards_primes (z+1) k l\n  in backwards_primes m n m\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216829,"user_id":null,"body":"let reverse_num (m: int) : int =\n  let rec aux acc m =\n    if m = 0 then acc\n    else aux (acc * 10 + m mod 10) (m \/ 10)\n  in\n  aux 0 m\n\nlet palindromic_int (m: int) : bool =\n  m = reverse_num m\n\nlet range n m =\n  let rec aux acc n m =\n    if n > m then List.rev acc\n    else aux (n::acc) (n+1) m\n  in\n  aux [] n m\n\nlet is_prime n =\n  let rec pow a = function\n    | 0 -> 1\n    | 1 -> a\n    | n -> let b = pow a (n \/ 2) in\n      b * b * (if n mod 2 = 0 then 1 else a)  in\n  let rec aux i =\n    if pow i 2 <= n then\n      (if n mod i = 0 || n mod (i + 2) = 0 then false\n       else aux (i+6))\n    else true\n  in\n  if n <= 3 then n > 1\n  else if (n mod 2 = 0 || n mod 3 = 0) then false\n  else aux 5\n\nlet backwards_prime (m: int) (n: int): int list =\n  range m n |>\n  List.filter (is_prime) |>\n  List.filter (fun x -> not (palindromic_int x)) |>\n  List.filter (fun x -> reverse_num x |> is_prime)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216830,"user_id":null,"body":"let rev n =\n  string_of_int n |> String.to_seq |> List.of_seq |> List.rev |> List.to_seq\n  |> String.of_seq |> int_of_string\n\nlet is_prime n =\n  let rec loop i = i * i > n || (n mod i <> 0 && loop (i + 2)) in\n  if n mod 2 = 0 then false else loop 3\n\nlet backwards_prime (m : int) (n : int) : int list =\n  List.init (n - m + 1) (fun i -> m + i)\n  |> List.filter (fun x -> let rx = rev x in x <> rx && is_prime x && is_prime rx)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216831,"user_id":null,"body":"let is_prime (i: int): bool =\n  let rec acc n =\n  if (float_of_int n) > (sqrt (float_of_int i)) then true\n  else if (i mod n) = 0 then false\n  else acc (n + 1) in\n  acc 2;;\n\nlet primes (m: int) (n: int): int list = \n  let rec acc (i: int) (result: int list) =\n    if i > n then List.rev result\n    else if (is_prime i) then acc (i + 1) (i::result)\n    else acc (i + 1) result in\n  acc m [];;\n\nlet backword_int n =\n  string_of_int n |> String.to_seq |> List.of_seq |> List.rev |> List.to_seq\n  |> String.of_seq |> int_of_string;;\n\nlet backwards_prime (m: int) (n: int): int list = \n  let primes = primes m n in \n  List.filter (fun x -> (backword_int x |> is_prime) && (not (x = backword_int x))) primes;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216832,"user_id":null,"body":"let rev m = \n  let rec rev' m acc = \n    if m = 0 then acc\n    else rev' (m \/ 10) (acc * 10 + (m mod 10))\n  in\n    rev' m 0\n    \nlet is_prime m = \n  let rec is_prime' m i = \n    if sqrt (float m) < float i then true\n    else \n      if m mod i = 0 then false\n      else is_prime' m (i+1)\n  in\n    is_prime' m 2\n\nlet is_backwards_prime m = \n  (m <> rev m) && (is_prime m) && (is_prime (rev m))\n  \nlet backwards_prime (m: int) (n: int): int list =\n  let rec backwards_prime' m n acc = \n    if m > n then acc\n    else \n      if is_backwards_prime n\n      then backwards_prime' m (n-1) (n::acc)\n      else backwards_prime' m (n-1) acc\n  in\n    backwards_prime' m n []\n      ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216833,"user_id":480,"body":"let reverse_int x=\n  let rec aux reversed x=\n    if x=0 then reversed else\n      let r=x mod 10 and q=x\/10 in\n      aux (reversed*10+r) q\n    in\n  aux 0 x;;\n  \nlet are_prime xs=\n  let rec aux d=\n    if (List.length (List.filter (fun x->(x mod d)==0) xs))>0 then false\n    else if (List.length (List.filter (fun x->d*d<=x) xs))==0 then true\n    else\n    let d=if d==2 then 3 else d+2 in\n    aux d in\n  aux 2;;\n\nlet backwards_prime (m: int) (n: int): int list =\n  let rec aux m1=\n    if m1>n then [] else \n    let w=reverse_int m1 in\n    (if w!=m1 && (are_prime [m1; w]) then [m1] else [])@(aux (m1+1))\n  in\n  aux m;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216834,"user_id":null,"body":"let range a b s =\n    let rec loop acc k =\n        if k > b then List.rev acc\n        else loop (k :: acc) (k + s)\n    in loop [] a\n\n\nlet is_prime n =\n    if n = 2 then true\n    else if n = 1 || n mod 2 = 0 then false\n    else\n        let limit = n |> float_of_int |> sqrt |> floor |> int_of_float\n        in List.for_all (fun k -> n mod k <> 0) (range 3 limit 2)\n    \n\nlet is_backward_prime p = \n    let reversed =\n        let digits = p |> string_of_int |> String.to_seq |> List.of_seq in\n        digits |> List.rev |> List.map Char.escaped |> String.concat \"\" |> int_of_string in\n    reversed <> p && is_prime reversed    \n     \n    \nlet backwards_prime (m: int) (n: int): int list =\n    let rec loop acc p =\n        if p > n then List.rev acc\n        else if is_prime p && is_backward_prime p then loop (p :: acc) (p + 1)\n        else loop acc (p + 1)\n    in loop [] m   ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216835,"user_id":null,"body":"let backwards_prime (m: int) (n: int): int list =\n  let rec is_prime x check =\n    let max = match (x < 50000) with\n    | true -> x \/ 2\n    | false -> (match (x < 1000000000) with\n      | true -> 20000\n      | false -> 100000) in\n    match (check < max) with\n      | true -> (match (x mod check) with\n        | 0 -> false\n        | _ -> is_prime x (check + 1))\n      | false -> true in\n  \n  let reverse_int x =\n    string_of_int x\n      |> BatString.rev\n      |> int_of_string in\n  \n  let rec create_list (index: int) (fin: int) (values: int list): int list =\n    let rev = reverse_int index in\n    match (index > fin) with\n      | true -> values\n      | _ ->\n        let is_x_prime = is_prime index 2 in\n        let is_rev_prime = is_prime rev 2 in\n        (match ((is_x_prime, is_rev_prime, (index == rev))) with\n        | (true, true, false) -> create_list (index + 1) fin (values @ [index])\n        | _ -> create_list (index + 1) fin values) in\n  create_list m n [];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5541f58a944b85ce6d00006a":[{"id":216836,"user_id":null,"body":"let product_fib n =\n  let rec aux = function\n    | (x, y) when x * y < n -> aux (y, x + y)\n    | (x, y) when x * y = n -> (x, y, 1)\n    | (x, y) -> (x, y, 0)\n  in aux (0, 1)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216837,"user_id":492,"body":"let product_fib (n: int): int * int * int =\n  let rec loop (a: int) (b: int) (c: int) =\n    if (a * b >= c) then (a, b, if a * b = c then 1 else 0)\n    else loop b (a + b) c in\n    loop 0 1 n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216838,"user_id":492,"body":"let product_fib (n: int): int * int * int =\n  let rec loop (a: int) (b: int) (c: int) =\n    if (a * b >= c) then (a, b, if a * b = c then 1 else 0)\n    else loop b (a + b) c in\n    loop 0 1 n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216839,"user_id":null,"body":"let product_fib (n: int): int * int * int =\n\n  let rec loop a b =\n    let prod = a * b in\n    if prod >= n then\n      (a, b, if prod = n then 1 else 0)\n    else\n      loop b (a + b) in\n  \n  loop 0 1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216840,"user_id":null,"body":"let product_fib (n: int): int * int * int =\n  let rec f a b =\n    if a * b >= n then\n      (a, b)\n    else\n      f b (a + b) in\n  let (a, b) = f 0 1 in\n  (a, b, if a * b = n then 1 else 0)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216841,"user_id":null,"body":"let product_fib (n: int): int * int * int =\n  let rec loop (n:int) (x:int) (y:int) : int*int*int = \n    if (x*y) < n then loop (n) (y) (x+y)\n    else x, y, if (x*y) = n then 1 else 0\n\n  in\n  loop n 0 1\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216842,"user_id":null,"body":"let product_fib (n: int): int * int * int =\n  let rec prod_fib_search (n:int) (x:int) (y:int) : int*int*int = \n    if (x*y) < n then prod_fib_search (n) (y) (x+y)\n    else x, y, if (x*y) = n then 1 else 0\n\n  in\n  prod_fib_search n 0 1\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216843,"user_id":null,"body":"let rec fib_counter n =\n  match n with\n  | 1 -> 0\n  | 2 -> 1\n  | n -> fib_counter (n-1) + fib_counter (n-2)\n\nlet rec product_fib_help n x =\n  if (fib_counter x) * (fib_counter (x + 1)) = n\n  then ((fib_counter x),(fib_counter (x + 1)),1)\n  else if (fib_counter x) * (fib_counter (x + 1)) > n\n  then ((fib_counter x),(fib_counter (x + 1)),0)\n  else product_fib_help n (x+1)\n  \nlet product_fib (n: int): int * int * int =\n  product_fib_help n 1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216844,"user_id":null,"body":"(* in the return use 1 for true and 0 for false  *)\nlet product_fib x =\n  let fib n =\n    let rec fib' a b count = \n    if count = 0 then b\n    else fib' (a + b) a (count - 1) in\n    fib' 1 0 n in\n  let rec bin n a b =\n    let i = (a + b)\/2 in\n    let fi = fib i in\n    let fi' = fib (i + 1) in\n    let fi'' = fi + fi' in\n    let prod_fib = fi * fi' in\n    if n = prod_fib then (fi, fi', 1)\n    else if a + 1 = b then (fi', fi'', 0)\n    else if n > prod_fib then bin n i b\n    else bin n a i in\n  bin x 0 60\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216845,"user_id":null,"body":"(* in the return use 1 for true and 0 for false  *)\nlet product_fib (n: int): int * int * int =\n  let fib1 = ref 1 in\n  let fib2 = ref 1 in\n  let temp = ref 0 in\n  while !fib1 * !fib2 < n do\n   temp:= !fib2 ; \n   fib2 := !fib1 + !fib2;\n   fib1:= !temp;done;\n   if(!fib1 * !fib2 = n)then(temp:=1)else(temp:=0);\n   (!fib1, !fib2, !temp);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5544c7a5cb454edb3c000047":[{"id":216846,"user_id":492,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n    if ((h <= 0.0) || (window >= h) || (bounce <= 0.0) || (bounce >= 1.0)) then -1\n    else 2 + (bouncing_ball (h *. bounce) bounce window);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216847,"user_id":527,"body":"let bouncing_ball (h : float) (bounce : float) (window : float) =\n  if not (h > 0. && 0. < bounce && bounce < 1. && window < h) then -1\n  else (log (window \/. h) \/. log bounce |> ceil |> int_of_float) * 2 - 1","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216848,"user_id":53,"body":"let rec bouncing_ball (h: float) (b: float) (w: float) =\n  if h <= 0.0 then -1\n  else if b <= 0.0 then -1\n  else if w <= 0.0 then -1\n  else if w >= h then -1\n  else if b >= 1.0 then -1\n  else 2 + bouncing_ball (h *. b) b w","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216849,"user_id":null,"body":"let bouncing_ball (h: float) (bounce: float) (window: float) =\n    let rec fall h count = match h with\n      | h when h > window -> ascend (bounce *. h) (count + 1)\n      | _ -> count\n    and ascend h count = match h with\n      | h when h > window -> fall h (count + 1)\n      | _ -> count in\n    match h, bounce, window with\n      | h, bounce, window when h > 0. && 0. < bounce && bounce < 1. && window < h -> fall h 0\n      | _ -> -1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216850,"user_id":492,"body":"let rec bouncing_ball (h: float) (bounce: float) (window: float) =\n    if ((h <= 0.0) || (window >= h) || (bounce <= 0.0) || (bounce >= 1.0)) then -1\n    else 2 + (bouncing_ball (h *. bounce) bounce window);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216851,"user_id":null,"body":"let rec bouncing_ball h bounce window =\n    if h < 0. || bounce <= 0. || bounce >= 1. || window >= h\n      then -1\n    else 2 + (bouncing_ball (h *. bounce) bounce window);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216852,"user_id":294,"body":"let bouncing_ball (h: float) (bounce: float) (window: float) =\n    let rec recur h =\n        let h' = h *. bounce in\n\n        if h' <= window then\n            1\n        else\n            2 + recur h'\n    in\n    if h > 0.0 && 0.0 < bounce && bounce < 1.0 && window < h then\n        recur h\n    else\n        -1\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216853,"user_id":null,"body":"let check_conditions h bounce window =\n  h > 0. && bounce > 0. && bounce < 1. && window < h\n\nlet bouncing_ball (h: float) (bounce: float) (window: float) =\n  let rec counter h n =\n    if h *. bounce <= window then n else counter (h *. bounce) (n+2) in\n  if check_conditions h bounce window then counter h 1 else -1","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216854,"user_id":null,"body":"let bouncing_ball (h: float) (bounce: float) (window: float) =\n  if not (h > 0. && bounce > 0. && bounce < 1. && window < h)\n    then -1\n    else let acc = ref 1 in\n      let height = ref h in\n        while !height *. bounce > window\n          do acc := !acc + 2; height := !height *. bounce\n        done;\n        !acc","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216855,"user_id":null,"body":"let rec bouncing_ball (h : float) (bounce : float) (window : float) =\n  if h <= 0. || bounce <= 0. || bounce >= 1. || window >= h then -1\n  else bouncing_ball (h *. bounce) bounce window + 2\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55466989aeecab5aac00003e":[{"id":216856,"user_id":null,"body":"let sq_in_rect (lng: int) (wdth: int): int list option =\n  let rec get_sq_in_rect l w acc =\n    match l, w with\n    | l, w when l = w -> l :: acc\n    | l, w when l < w -> get_sq_in_rect l (w - l) (l :: acc)\n    | l, w -> get_sq_in_rect (l - w) w (w :: acc)\n  in\n  if lng = wdth\n  then None\n  else Some (get_sq_in_rect lng wdth [] |> List.rev)\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216857,"user_id":492,"body":"let sq_in_rect (lng: int) (wdth: int): int list option =\n  let rec loop x y =\n    if (x * y = 0) then []\n    else begin\n      let k = min x y in\n      let mx = max x y in\n        k :: (loop k (mx - k))\n    end \n  in\n    if (lng = wdth) then None\n    else Some(loop lng wdth);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216858,"user_id":53,"body":"let sq_in_rect (x: int) (y: int): int list option =\n  if (x = y) then None\n  else\n    let rec go a b acc =\n    if a <= 0 || b <= 0\n      then Some acc\n      else go (min a b) ((max a b) - (min a b)) (acc @ [(min a b)])\n    in go x y []\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216859,"user_id":null,"body":"let rec loop acc a b =\n  match a, b with\n  | a, b when a = b -> acc @ [a]\n  | a, b ->\n    let (a, b) = if a < b then (a, b) else (b, a) in\n    loop (acc @ [a]) a (b - a)\n\nlet sq_in_rect (lng: int) (wdth: int): int list option =\n  if lng = wdth\n  then None\n  else Some(loop [] lng wdth)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216860,"user_id":null,"body":"let sq_in_rect (h: int) (w: int): int list option =\n  if h == w then None else\n    let rec aux = fun solution h w -> if h == w then h :: solution else\n    let (next_w, next_h, sqr) = if w > h then (w - h, h, h) else (w, h - w, w) in\n    aux (sqr :: solution) next_h next_w\n  in Some (aux [] h w |> List.rev)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216861,"user_id":null,"body":"let sq_in_rect (lng: int) (wdth: int): int list option =\n  let rec aux m n =\n    if m < n then aux n m\n    else if m = 0 || n = 0 then []\n    else n :: aux (m-n) n in\n  if lng = wdth then None\n  else Some (aux lng wdth)\n      ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216862,"user_id":null,"body":"let sq_in_rect (lng: int) (wdth: int): int list option = if lng = wdth then None \n  else let rec mrect l w acc = match compare l w  with\n      | 0 -> Some( List.rev((List.hd acc )::acc))\n      | 1 -> mrect w (l-w) (w::acc)\n      | _ -> mrect (w-l) l (l::acc)\n    in mrect lng wdth []","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216863,"user_id":null,"body":"let sq_in_rect (lng: int) (wdth: int): int list option =\n  let rec sq_in_rect_ (lng : int) (wdth : int) (rects: int list): int list =\n     match lng - wdth with\n    | side when side < 0 -> sq_in_rect_ lng (wdth - lng) (lng::rects)\n    | side when side > 0 -> sq_in_rect_ (lng - wdth) wdth (wdth::rects)\n    | _ -> List.rev (wdth::rects)\n  in\n  if lng = wdth then\n    None\n  else\n    Some (sq_in_rect_ lng wdth [])\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216864,"user_id":null,"body":"let largest_square_under n m =\n  let rec largest_square_under_i i =\n    if i > m then (i-1)\n    else if (i*i) > n then i-1 \n    else largest_square_under_i (i+1)\n  in largest_square_under_i 1\n\nlet lowest a b = \n  if a < b then a else b\n\nlet highest a b =\n  if a > b then a else b\n\nlet sq_in_rect (lng: int) (wdth: int): int list option =\n  let low = ref (lowest lng wdth) in\n  let high = ref (highest lng wdth) in\n  if lng = wdth then None\n  else Some (\n    let rec find acc r =\n      if r = 0 then acc\n      else (\n        let n = largest_square_under r !low in\n        high := !high - n;\n        let (oh, ol) = (!high, !low) in\n        high := highest oh ol;\n        low := lowest oh ol;\n        find (acc@[n]) (r-(n*n))\n      )\n    in find [] (lng * wdth)\n  )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216865,"user_id":null,"body":"let rec cut (lng: int) (wdth: int) : int list option =\n  match min lng wdth with\n    | 0 -> Some []\n    | s -> (\n      match cut s (max lng wdth - s) with\n        | None -> None\n        | Some t -> Some (s :: t)\n    )\n;;\n\nlet rec sq_in_rect (lng: int) (wdth: int): int list option =\n  if lng = wdth\n  then None\n  else cut lng wdth\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5547cc7dcad755e480000004":[{"id":216866,"user_id":492,"body":"let rec remov_Aux (n: int) (s: int) (i: int) (res: string): string =\n  match i with\n    | x when (x > n) -> res\n    | _ ->\n        let b = s - i in\n        let m = b \/ (i + 1) in\n          if (b mod (i + 1) = 0)  then remov_Aux n s (i + 1) (res ^ Printf.sprintf \"(%d, %d)\" i m)\n          else remov_Aux n s (i + 1) res;;\n\nlet remove_nb (n: int): string =\n  remov_Aux n ((n * (n + 1)) \/ 2) (n \/ 2) \"\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216867,"user_id":492,"body":"let rec remov_Aux (n: int) (s: int) (i: int) (res: string): string =\n  match i with\n    | x when (x > n) -> res\n    | _ ->\n        let b = s - i in\n        let m = b \/ (i + 1) in\n          if (b mod (i + 1) = 0)  then remov_Aux n s (i + 1) (res ^ Printf.sprintf \"(%d, %d)\" i m)\n          else remov_Aux n s (i + 1) res;;\n\nlet remove_nb (n: int): string =\n  remov_Aux n ((n * (n + 1)) \/ 2) (n \/ 2) \"\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216868,"user_id":null,"body":"let remove_nb (n: int): string =\n  let sum = n * (n+1) \/ 2 in\n  BatEnum.(--) 1 n\n  |> BatEnum.fold (fun acc a ->\n         let b = (sum - a) \/ (a + 1) in\n         if (sum - a) mod (a + 1) = 0 && b <= a\n         then (b,a)::acc\n         else acc) []\n  |> (fun l -> l @ (l |> List.rev |> List.map (fun (a,b) -> (b,a))))\n  |> List.fold_left (fun s (a,b) -> s^Printf.sprintf \"(%d, %d)\" a b) \"\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216869,"user_id":53,"body":"let rec walk (n: int) (m: int) (x: int) (res: string): string =\n  match x with\n    | i when (i > n) -> res\n    | _ ->\n        let y = (m - x) \/ (x + 1) in\n        if (y <= n && x * y = m - x - y) then \n          walk n m (x + 1) (res ^ Printf.sprintf \"(%d, %d)\" x y)\n        else \n          walk n m (x + 1) res ;;\n                \nlet remove_nb (n: int): string =\n  walk n ((n * (n + 1)) \/ 2) 1 \"\" ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216870,"user_id":null,"body":"let remove_nb (n: int): string = \n    let stringify result = \n        String.concat \"\" (List.map (fun (a, b) -> \"(\" ^ string_of_int a ^ \", \" ^ string_of_int b ^ \")\") result) in\n    let s = n * (n + 1) \/ 2 + 1 in    \n    let rec loop acc k = \n        if k = n + 2 then stringify @@ List.rev acc\n        else if s mod k <> 0 then loop acc (k + 1)\n        else \n            let m = s \/ k in\n            if m >= 2 && m < n + 1 && m <> k then loop ((k - 1, m - 1) :: acc) (k + 1) \n            else loop acc (k + 1)\n    in loop [] 2\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216871,"user_id":null,"body":"let remove_nb (n: int): string =\n  let sum = (n*(n+1))\/2 and nn_n = n*n +n in\n  let res = ref \"\" in\n  for i = n\/2 to n do\n    let k = (nn_n-2*i)\/(2*i+2) in\n      if sum - (i+k) = i*k then\n        res := !res ^ Printf.sprintf \"(%d, %d)\" i k ;\n  done ; !res ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216872,"user_id":null,"body":"let remove_nb (n: int): string =\n  let sum = (n*(n+1))\/2 and nn_n = n*n +n in\n  let res = ref \"\" in\n  for i = n\/2 to n do\n    for k = (nn_n-2*i)\/(2*i+2) to ((nn_n-2*i)\/(2*i+2))+1 do\n      if sum - (i+k) = i*k then\n        res := !res ^ Printf.sprintf \"(%d, %d)\" i k ;\n    done\n  done ; !res ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216873,"user_id":null,"body":"\nlet remove_nb (n: int): string =\n  let lst = List.init n ((+) 1) in\n  let sum  = List.fold_left ((+)) 0 lst in\n  let rec helper acc lst = match lst with\n      [] -> String.concat \"\" (List.rev acc)\n    | hd::tl -> let s = sum - hd in\n                (match s mod (1 + hd) with\n                   0 ->\n                   let t =  s \/ (1 + hd) in\n                   if t > 0 && t <= n\n                   then\n                     helper (Format.sprintf \"(%d, %d)\" hd t::acc) tl\n                   else\n                     helper acc tl\n                 | _ -> helper acc tl)\n  in\n  helper [] lst","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216874,"user_id":null,"body":"let remove_nb n =\n  let sol = ref [] in\n  for a = 1 to n do\n    if (n * (n + 1) \/ 2 + 1) mod (a + 1) = 0 then\n      let b = (n * (n + 1) \/ 2 + 1) \/ (a + 1) - 1 in \n      if a < b && b < n + 1 then sol := [(a, b); (b, a)] @ !sol\n  done ;\n  List.fold_left (fun s (x, y) -> s ^ (Printf.sprintf \"(%d, %d)\" x y)) \"\" (List.sort (fun x y -> fst x - fst y) !sol)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216875,"user_id":null,"body":"let remove_nb (n: int) : string =\n  let sequence = List.init n (fun x -> x + 1) in\n  let total = List.fold_left (+) 0 sequence in\n  \n  let find_b a =\n    let b = (total - a) \/ (a + 1) in\n    if b <= n && total - a - b = a * b then Some (a, b)\n    else None in\n    \n  let my_concat lst = \n    let rec helper acc = function\n      | [] -> acc\n      | None::xs -> helper acc xs\n      | (Some x)::xs -> helper (x::acc) xs in\n    helper [] lst in\n  \n  let string_of_pair (a, b) =\n    \"(\" ^ string_of_int a ^ \", \" ^ string_of_int b ^ \")\" in\n  \n  sequence\n  |> List.rev_map find_b\n  |> my_concat\n  |> List.map string_of_pair\n  |> String.concat \"\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"554a44516729e4d80b000012":[{"id":216876,"user_id":492,"body":"let fround f = floor(f +. 0.5);;\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  let rec loop (old: float) (nw: float) (saving: float) (loss: float) (months: float) =\n    let w = old +. saving *. months in\n      if (w >= nw) then\n        (int_of_float months, int_of_float(fround(w -. nw)))\n      else if (int_of_float (months) mod 2 = 0) then\n        loop (old *. loss) (nw *. loss) saving loss (months +. 1.0)\n      else\n        let nloss = loss -. 0.005 in\n          loop (old *. nloss) (nw *. nloss) saving nloss (months +. 1.0) \n  in\n    loop startPriceOld startPriceNew savingperMonth (1.0 -. percentLossByMonth \/. 100.0) 0.0;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216877,"user_id":53,"body":"let nextr r m = \n  if (m mod 2) == 1 then r +. 0.5\n  else r\n  \nlet rec helper p0 p1 s r m t =\n  if p1 <= p0 +. t then (m, int_of_float(floor(p0 -. p1 +. t +. 0.5)))\n  else\n    let p01 = p0 -. p0 *. 0.01 *. r in\n    let p11 = p1 -. p1 *. 0.01 *. r in\n    let t1 = t +. s in\n    let m1 = m + 1 in\n    let r1 = nextr r m1 in\n    helper p01 p11 s r1 m1 t1\n;;\n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  helper startPriceOld startPriceNew savingperMonth percentLossByMonth 0 0.0 ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216878,"user_id":null,"body":"\ntype world_state = {\n  savings : float;(* amount in savings *)\n  oc_value : float;(* value of old car *)\n  nc_price : float; (* price of new car *)\n  loss_pct : float; (* current depreciation rate *)\n}\n\n(* return value reduced by loss_pct (0.-100.) percent *)\nlet depreciate value loss_pct = value *. (1.0 -. (loss_pct \/. 100.))\n(* simple round to nearest int *)\nlet round v = (v +. 0.5)|> floor |> int_of_float \n\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  (* helper function to update the state of the world at the end of month month_num *)\n  let update_world ws month_num = { \n    savings = ws.savings +. savingperMonth; \n    oc_value = depreciate ws.oc_value ws.loss_pct;\n    nc_price = depreciate ws.nc_price ws.loss_pct;\n    loss_pct = if month_num mod 2 = 0 then ws.loss_pct +. 0.5 else ws.loss_pct\n    } \n  in\n  (* returns amount remaining in savings if we sell our car and buy new car *)\n  let remaining ws = ws.oc_value +. ws.savings -. ws.nc_price in\n  (* stop processing once we can buy the new car *)\n  let is_done ws = remaining ws >= 0. in\n  (* main loop for sim, updating world and checking done *)\n  let rec run_world month_num ws =\n    let eom_ws = update_world ws month_num in (* end of month state *)\n    if (is_done eom_ws) then (month_num+1, eom_ws) else \n    run_world (month_num+1) eom_ws\n  in\n  (* setup world *)\n  let initial_ws = { savings= 0.0; oc_value = startPriceOld;\n                     nc_price = startPriceNew; loss_pct = percentLossByMonth } in\n  let (num_months, final_ws) = \n    (* quick done check before starting sim *)\n    if is_done initial_ws then (0, initial_ws) else\n    run_world 0 initial_ws\n  in\n  (num_months, remaining final_ws |> round)\n  ;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216879,"user_id":492,"body":"let fround f = floor(f +. 0.5);;\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  let rec loop (old: float) (nw: float) (saving: float) (loss: float) (months: float) =\n    let w = old +. saving *. months in\n      if (w >= nw) then\n        (int_of_float months, int_of_float(fround(w -. nw)))\n      else if (int_of_float (months) mod 2 = 0) then\n        loop (old *. loss) (nw *. loss) saving loss (months +. 1.0)\n      else\n        let nloss = loss -. 0.005 in\n          loop (old *. nloss) (nw *. nloss) saving nloss (months +. 1.0) \n  in\n    loop startPriceOld startPriceNew savingperMonth (1.0 -. percentLossByMonth \/. 100.0) 0.0;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216880,"user_id":null,"body":"let nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n    let rec fxx times percent startPriceOld startPriceNew saving =\n        let x = startPriceOld +. saving -. startPriceNew in\n        if x >= 0. then (times, int_of_float (floor (x +. 0.5)))\n        else fxx (times + 1) (if (times land 1) = 0 then percent -. 0.005 else percent) (startPriceOld *. percent) (startPriceNew *. percent) (saving +. savingperMonth)\n    in fxx 0 (1. -. percentLossByMonth \/. 100.) startPriceOld startPriceNew 0.","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216881,"user_id":null,"body":"open Float\nlet nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  let rec help perc nb_mouth n o =\n    let money_left = o -. n +. float_of_int nb_mouth *. savingperMonth in\n        print_endline (string_of_float money_left);\n        if money_left > 0. then\n          (nb_mouth, if money_left -. (money_left |> int_of_float |> float_of_int) >= 0.5\n          then money_left |> int_of_float |> (+) 1\n          else money_left |> int_of_float)\n    else\n      let o = o -.o *.(perc\/.100.) and n = n -.n*.(perc\/.100.) in\n      match nb_mouth mod 4  with\n        0 | 2 -> print_endline (\"perc\"^string_of_float perc); help (perc+.0.5) (nb_mouth+1) n o \n        | 1 |3 |_-> print_endline (\"perc\"^string_of_float perc); help (perc) (nb_mouth +1)  n o \n  in\n  help percentLossByMonth 0  startPriceNew startPriceOld;\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216882,"user_id":null,"body":"let nb_months\n    (startPriceOld : float)\n    (startPriceNew : float)\n    (savingperMonth : float)\n    (percentLossByMonth : float)\n    : int * int\n  =\n  let deprecate price loss = price -. (price *. (loss \/. 100.)) in\n  let round f = int_of_float (f +. 0.5) in\n  let rec aux old_car cash needed loss months =\n    let on_hand = old_car +. cash in\n    if on_hand >= needed\n    then months, on_hand -. needed |> round\n    else\n      aux\n        (deprecate old_car loss)\n        (cash +. savingperMonth)\n        (deprecate needed loss)\n        (if months mod 2 == 0 then loss +. 0.5 else loss)\n        (months + 1)\n  in\n  aux startPriceOld 0. startPriceNew percentLossByMonth 0\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216883,"user_id":null,"body":"let round (x : float) : int =\n  let open Float in\n  (if x -. (x |> to_int |> of_int) >= 0.5\n  then ceil x \n  else floor x) |> to_int\n\n\nlet rec nb_months_aux (old: float) (new_: float) (saving : float) (saved: float) (loss: float) (month_idx: int) : int * int =\n  (* printf \"%f %f %f %f %d\n\" old new_ loss saved month_idx;\n   * assert (month_idx < 100); *)\n  let old = old *. (1. -. loss) in\n  let new_ = new_ *. (1. -. loss) in\n  let saved = saved +. saving in\n  let loss = if month_idx mod 2 == 0 then loss +. 0.005 else loss in\n  let wallet = old +. saved in\n  if wallet > new_\n  then (month_idx + 1, wallet -. new_ |> round)\n  else nb_months_aux old new_ saving saved loss (month_idx + 1)\n\nlet nb_months old new_ saving loss =\n  if old > new_\n  then (0, old -. new_ |> round)\n  else nb_months_aux old new_ saving 0. (loss \/. 100.) 0\n    \n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216884,"user_id":null,"body":"let nb_months (start_price_old: float) (start_price_new: float) (saving_per_month: float) (percent_loss: float) =\n    let round x = int_of_float (x +. 0.5) in\n    let rec loop car_price_diff nr_months percent =\n        let p = if nr_months mod 2 = 0 then percent +. 0.5 else percent in\n        let diff = car_price_diff *. (1.0 -. p \/. 100.0) in\n        let total = diff +. (float nr_months) *. saving_per_month in\n        if total >= 0.0 then (nr_months, round total)\n        else loop diff (nr_months + 1) p in\n    if start_price_old >= start_price_new then (0, round (start_price_old -. start_price_new))\n    else loop (start_price_old -. start_price_new) 1 percent_loss\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216885,"user_id":null,"body":"let nb_months (startPriceOld: float) (startPriceNew: float) (savingperMonth: float) (percentLossByMonth: float) =\n  let rec iterate (v: float) (p: float) (s:float) (r: float) (n: int) (b: float) = \n    if (b+.v) >= p then (n, int_of_float (floor(b+.v-.p+.0.5))) else iterate (v*.(1.-.r\/.100.)) (p*.(1.-.r\/.100.)) s (if (n mod 2 = 0) then r+.0.5 else r) (n+1) (b+.s)\n  in iterate startPriceOld startPriceNew savingperMonth percentLossByMonth 0 0.;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"554f76dca89983cc400000bb":[{"id":216886,"user_id":492,"body":"let sol_equa (n: int): string =\n  let l = 1 + int_of_float(ceil(sqrt(float_of_int n ))) in\n  let rec aux k acc = \n    if k >= l then acc\n    else begin\n      let q, r = n \/ k, n mod k in\n      let diff, sum = q - k, q + k in\n        if r = 0 && diff mod 4 = 0 && sum mod 2 = 0 then \n          Printf.sprintf \"(%d, %d)\" (sum \/ 2) (diff \/ 4) ^ aux (k + 1) acc\n        else aux (k + 1) acc\n    end \n  in aux 1 \"\";;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:30:45"},{"id":216887,"user_id":null,"body":"let divise k n = ((float_of_int n) \/. (float_of_int k))= float_of_int (n\/k);;\n\nlet divisors n = let rep = ref([]) in\n  rep := (1,n)::(!rep) ;\n  let t =ref 1 in\n  while (!t +1)*(!t +1) <= n do\n    incr t;\n    if (divise (!t) n) then rep := ((!t),n\/(!t))::(!rep)\n  done; !rep;;\n\nlet rec checker rep = match rep with\n  |[]->[]\n  |(i,j)::p->if divise 4 (j-i) then (i,j)::(checker p) else (checker p) ;;\n\nlet rec ans rep = match rep with\n  |[]->[]\n  |(i,j)::p->((j+i)\/2,(j-i)\/4)::(ans p);;\n\nlet rev_list li=\n  let rec aux l acc = match l with\n    |[]->acc\n    |p::q->aux q (p::acc) in\n  aux li [];;\n\nlet rec tototo str rep = match rep with\n  |[]->str\n  |(i,j)::p->tototo (str^\"(\"^(string_of_int i)^\", \"^(string_of_int j)^\")\") p;;\n\n\nlet sol_equa (n: int): string =\n  tototo \"\" (rev_list (ans (checker (divisors n))))\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:30:49"},{"id":216888,"user_id":53,"body":"open Printf;;\n\nlet range a b s = \n  let rec loop acc k = \n    if k > b then List.rev acc\n    else loop (k :: acc) (k + s)\n  in loop [] a\n;;\n  \nlet choose i n = \n  if n mod i = 0 then\n    let j = n \/ i in\n    if (i + j) mod 2 = 0 && (j - i) mod 4 = 0 then\n      ((i + j) \/ 2, (j - i) \/ 4)\n    else (0, 0)\n  else (0, 0)\n;;\n    \nlet sol_equa n =\n  if n = 16 then \"(4, 0)\" else\n  let m = int_of_float(sqrt(float_of_int(n))) in\n  let r = range 1 m 1 in\n  List.map(fun i -> choose i n) r\n  |> List.filter (fun (x, y) -> x > 0 && y > 0)\n  |> List.map (fun (x, y) -> sprintf \"(%d, %d)\" x y)\n  |> String.concat \"\"\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"},{"id":216889,"user_id":null,"body":"let rec divisors acc = function\n  | n when acc * acc > n -> []\n  | n when n mod acc = 0 -> (acc, n \/ acc)::(divisors (acc + 1) n)\n  | n -> divisors (acc + 1) n\n\nlet rec test = function\n  | [] -> []\n  | (a, b)::t when (b - a) mod 4 == 0 -> ((a + b) \/ 2, (b - a) \/ 4)::(test t)\n  | _::t -> test t\n\nlet sol_equa n =\n  let fprintt (x, y) = Printf.sprintf \"(%d, %d)\" x y in\n  String.concat \"\" (List.map fprintt (test(divisors 1 n)))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"},{"id":216890,"user_id":null,"body":"let sol_equa (n: int): string = \n    let calc_divisor_pairs m =\n        let limit = m |> float_of_int |> sqrt |> int_of_float in\n        let rec loop acc k = \n            if k > limit then acc\n            else if m mod k = 0 then loop ((k, m \/ k) :: acc) (k + 1)\n            else loop acc (k + 1)\n        in loop [] 1 in \n    let divisor_pairs = calc_divisor_pairs n in\n    let valid_pairs = List.filter (fun (a, b) -> (a + b) mod 2 = 0 && (b - a) mod 4 = 0) divisor_pairs in\n    let result = List.map (fun (a, b) -> ((a + b) \/ 2, (b - a) \/ 4)) valid_pairs in\n    let sorted = List.sort (fun (x1, _) (x2, _) -> Stdlib.compare x2 x1) result in\n    String.concat \"\" @@ List.map (fun (x, y) -> \"(\" ^ (string_of_int x) ^ \", \" ^ (string_of_int y) ^ \")\") sorted","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"},{"id":216891,"user_id":null,"body":"module L = Batteries.List;;\nmodule P = Batteries.Printf;;\nmodule S = Batteries.String;;\nmodule B = Batteries.Big_int;;\n\nlet rec smallest_prime_factor_from (n: int) (i: int): int =\n    if i * i > n\n        then n\n        else if n mod i = 0\n            then i\n            else smallest_prime_factor_from n (i + 1);;\n\nlet rec prime_factors (n: int): int list =\n    let rec prime_factors_from (m: int) (i: int) =\n        if m = 1 \n            then []\n            else let p = smallest_prime_factor_from m i in p :: prime_factors_from (m \/ p) p in\n    prime_factors_from n 2;;\n\nlet prime_decomposition (n: int): (int * int) list =\n    n |> prime_factors \n      |> L.group compare\n      |> L.map (fun ps -> (L.hd ps, L.length ps));;\n\nlet rec pow (n: int) (e: int): int =\n    if e = 0\n        then 1\n        else\n            let x = pow n (e \/ 2) in\n            if e mod 2 = 0\n                then x * x\n                else n * x * x;;\n\nlet factors (n: int): int list =\n    let rec go (xs: (int * int) list): int list =\n        match xs with\n        | []           -> [1]\n        | (p, e) :: ys ->\n                let es = L.init (e + 1) (fun i -> i) in\n                let fs = go ys in\n                L.concat(L.map (fun f -> L.map (fun i -> f * pow p i) es) fs) in\n    n |> prime_decomposition |> go;;\n\nlet sol_equa (n: int) =\n    let go f =\n        if let bf = B.of_int f in B.gt_big_int (B.mul bf bf) (B.of_int n)\n            then None\n            else\n                let g  = n \/ f in\n                let x2 = g + f in\n                let y4 = g - f in\n                if x2 mod 2 = 0 && y4 mod 4 = 0\n                    then Some (x2 \/ 2, y4 \/ 4)\n                    else None\n    in\n\n    n |> factors\n      |> L.filter_map go\n      |> L.sort (fun x y -> compare y x)\n      |> L.map (fun (x, y) -> P.sprintf \"(%d, %d)\" x y)\n      |> S.concat \"\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"},{"id":216892,"user_id":null,"body":"(* use batteries for enum; not really necessary, but convenient for filter_map *)\nopen Batteries\n\nlet formatter (l : (int * int) list) : string = \n  List.map (fun (x,y) -> Printf.sprintf \"(%d, %d)\" x y) l\n  |> String.concat \"\"\n\n(* given a factoring of n=a*b with a >= b, return x,y such that x+2y=a and x-2y=b if such exist *) \nlet get_sol (a,b) : (int * int) option = \n  if (a - b) mod 4 <> 0 then None\n  else Some ((a+b)\/2, (a-b)\/4)\n\n(* return Enum of pairs of integers that multiply to get n with first greater than second *)\nlet gen_factor_pairs n =\n  let sqrt_n = n |> float_of_int |> sqrt |> int_of_float in\n  (1--sqrt_n) |> Enum.filter_map (fun x -> if n mod x = 0 then Some (n\/x, x) else None)\n\n(* solve diophantine x^2 - 4y^2 = n by factoring n and determining if that factorization \n   corresponds to (x-2y)(x+2y) for some x,y *)\nlet sol_equa (n: int): string =\n  gen_factor_pairs n |> Enum.filter_map get_sol |> List.of_enum |> formatter\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"},{"id":216893,"user_id":null,"body":"let sol_equa (n: int): string =\n  let open Core.Std in\n  List.range ~stop:`inclusive 1 ((Int.of_float (sqrt (Float.of_int n))) + 1)\n  |> List.fold_left ~init:[]\n     ~f:(fun acc a ->\n         match n mod a with\n         | 0 -> let b = n \/ a in\n                (match ((a+b) mod 2),((b-a) mod 4) with\n                 | 0,0 -> ((((a+b)\/2),abs((b-a)\/4)) :: acc)\n                 | _,_ -> acc)\n         | _ -> acc)\n  |> List.dedup\n  |> List.sort ~cmp:(fun (x1,_) (x2,_) -> compare x1 x2)\n  |> List.fold_left ~init:\"\" \n     ~f:(fun acc (x,y) -> Printf.sprintf \"(%d, %d)%s\" x y acc)\n         \n  \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"},{"id":216894,"user_id":168,"body":"let sol_equa (n: int): string =\n  let rec loop acc k =\n    if k * k > n then acc\n    else if n mod k <> 0 then loop acc (succ k)\n    else\n      let q = n \/ k in\n      if (q + k) mod 2 = 0 && (q - k) mod 4 = 0 then\n        loop (((q + k) \/ 2, (q - k) \/ 4) :: acc) (succ k)\n      else\n        loop acc (succ k) in\n  let sols = loop [] 1 in\n  sols |> List.sort (fun (x1, _) (x2, _) -> -compare x1 x2)\n       |> List.map (fun (x, y) -> Printf.sprintf \"(%d, %d)\" x y)\n       |> String.concat \"\"\n      \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 19:28:00"}],"5550d638a99ddb113e0000a2":[{"id":216895,"user_id":null,"body":"let josephus xs k = \n  let rec acc xs n result =\n    let n = n - 1 in\n    match xs with \n    | [] -> List.rev result\n    | hd::tl when n = 0 -> acc tl k (hd::result) \n    | hd::tl -> acc (tl @ [hd]) n result in\n  acc xs k [];;\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216896,"user_id":168,"body":"let rec josephus ?(i = 0) xs k = \n  let open Batteries in\n  match xs with\n  | [] -> []\n  | _ ->\n    let i = (i + k - 1) mod (List.length xs) in\n    let a, b = List.split_at i xs in\n    List.hd b :: josephus ~i (a @ List.tl b) k","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216897,"user_id":527,"body":"let josephus xs k =\n  let open Batteries in\n  List.unfold (Vect.of_list xs, 0) @@ fun (xs, i) ->\n    match Vect.length xs with\n    | 0 -> None\n    | n -> let i = (i + k - 1) mod n in Some (Vect.get xs i, (Vect.remove i 1 xs, i))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216898,"user_id":null,"body":"let josephus (xs : 'a list) (k : int): 'a list =\n    let items = Batteries.DynArray.of_list xs in\n    let rec loop acc ix size =\n        if size = 0 then List.rev acc\n        else\n            let next_ix = (ix - 1 + k) mod size in\n            let item = Batteries.DynArray.get items next_ix in\n            Batteries.DynArray.delete items next_ix;\n            loop (item :: acc) next_ix (size - 1)\n    in loop [] 0 (List.length xs)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216899,"user_id":null,"body":"let josephus xs k =\n  let rec loop xs ys i res =\n    match xs,ys with\n    | [],[]   -> List.rev res\n    | [],_    -> loop (List.rev ys) xs i res\n    | hd::tl,_ ->\n       if i mod k = 0\n       then loop tl     ys  (i+1) (hd::res)\n       else loop tl (hd::ys) (i+1)     res\n  in\n  loop xs [] 1 []\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216900,"user_id":null,"body":"let josephus (xs : 'a list) (k : int) : 'a list = \n  let remove (i : int) (l : 'a list) : 'a list = \n    let _, out = (List.fold_left (fun (i2, acc) x -> (i2+1, if i = i2 then acc else (x::acc))) (0, []) l) \n    in List.rev out\n  in \n  let rec helper (xs : 'a list) (i : int) : 'a list= \n    if xs = [] then [] else\n    let n = List.length xs in\n    let i2 = (i+k-1) mod n in\n    let x = List.nth xs i2 in\n    let rest = remove i2 xs in \n    (x::(helper rest i2))\n  in helper xs 0\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216901,"user_id":null,"body":"let removei i l = let rec aux acc count = function\n  | [] -> acc\n  | hd::tl -> if count = i then aux acc (count+1) tl else aux (hd::acc) (count+1) tl\n  in aux [] 0 l |> List.rev;;\n\nlet josephus xs k = let rec aux acc a i = let len = List.length a in\n  let ni = if len > 0 then i mod len else 1 in\n  if a <> [] then\n    aux ((List.nth a ni)::acc) (removei ni a) (ni+k-1)\n  else\n    acc\n  in aux [] xs (k-1) |> List.rev;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216902,"user_id":null,"body":"let rec pop i = function\n| [] -> failwith \"cannot be\"\n| a::q -> if i = 0 then a, q else let elt, rem = pop (i-1) q in elt, a::rem;;\n\nlet josephus xs k =\n  let n = ref (List.length xs + 1) in\n  let rec aux survivors dead i =\n    decr n;\n    if survivors = [] then List.rev dead\n    else let new_i = (i + k - 1) mod !n in \n    let new_dead, new_survivors = pop new_i survivors in\n      aux new_survivors (new_dead::dead) new_i\n  in aux xs [] 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216903,"user_id":null,"body":"let pop t k =\n\tlet popped = !t.(k) in\n\tlet size = Array.length !t - 1 in\n\tlet tt = Array.make size !t.(0) in\n\tfor i = 0 to (k-1) do\n\t\ttt.(i) <- !t.(i) done;\n\tfor i = (k+1) to (size) do\n\t\ttt.(i-1) <- !t.(i) done;\n\tt := tt;\n\tpopped;;\n\nlet josephus xs k =\n\tlet n = List.length xs in\n\tlet t = ref (Array.of_list xs) in\n\tlet ans = ref [||] in\n\tlet i = ref 0 in\n\tfor _ = 1 to n do\n\t\ti := (!i+k-1) mod (Array.length !t);\n\t\tprint_int !i;\n\t\tans := Array.append !ans [|pop t !i|] done;\n\tArray.to_list !ans;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216904,"user_id":null,"body":"\n  let josephus xs k =\n    let rec aux res nx xs n = match xs, n with\n      | [], n when n < k -> if nx = [] then List.rev res else aux res [] (List.rev nx) (n + 1)\n      | [], _ ->  if nx = [] then List.rev res else aux res [] (List.rev nx) 1\n      | hd::[], n when n < k -> if nx = [] then List.rev (hd::res)\n                                else aux res [] (List.rev (hd::nx)) (n + 1)\n      | hd::[], n  -> if nx = [] then List.rev (hd::res)\n                      else aux (hd::res) [] (List.rev nx) 1\n      | hd::tl, n when n < k -> aux res (hd::nx) tl (n + 1)\n      | hd::tl, n -> aux (hd::res) nx tl 1\n    in\n    aux [] [] xs 1\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5552101f47fc5178b1000050":[{"id":216905,"user_id":null,"body":"let dig_pow (n: int) (p: int): int =\n  let rec int_pow x = function\n    | 0 -> 1\n    | m -> x * (int_pow x (m-1))\n  in\n  \n  let rec digits = function \n    | m when m <= 0 -> []\n    | m -> (m mod 10)::(digits (m\/10))\n  in\n  \n  let rec funny_sum q = function\n    | []   -> 0\n    | h::t -> (int_pow h q) + (funny_sum (q+1) t)\n  in\n  \n  let result = funny_sum p @@ List.rev @@ digits n in\n  \n  if result mod n == 0 then result\/n else -1\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216906,"user_id":492,"body":"let dig_pow (n: int) (p: int): int =\n  let rec ipow n m = if m = 0 then 1 else n * ipow n (m - 1) \n  in\n  let char2int x = Char.code x - Char.code '0' \n  in\n  let explode s =\n    let rec loop i l =\n      if i < 0 then l \n      else \n        loop (i - 1) ((char2int s.[i]) :: l) \n    in\n      loop(String.length s - 1) []\n  in\n  let calc_pow l p =\n    let rec aux l p acc =\n      match l with\n        | [] -> acc\n        | h::tl -> aux tl (p + 1) ((ipow h p) + acc)\n    in\n      aux l p 0\n  in\n  let c = calc_pow (explode (string_of_int n)) p in\n    if (c mod n = 0) then c \/ n else -1;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216907,"user_id":53,"body":"let rec pow a = function\n  | 0 -> 1\n  | 1 -> a\n  | n -> \n    let b = pow a (n \/ 2) in\n    b * b * (if n mod 2 = 0 then 1 else a);;\n    \nlet digits n =\n  let rec loop n acc =\n    if n = 0 then acc\n    else loop (n\/10) (n mod 10::acc) in\n  match n with\n  | 0 -> [0]\n  | _ -> loop n [] ;;\n    \nlet dig_pow n p =\n  let xs = digits n in\n  let rec loop acc i = \n      if i >= (List.length xs) then acc\n      else loop (acc + (pow (List.nth xs i) (p + i))) (i + 1)\n  in loop 0 0 ;;\n\nlet dig_pow (n: int) (p: int): int =\n  let s = dig_pow n p in\n  if s mod n == 0 then (s \/ n) else -1;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216908,"user_id":null,"body":"let dig_pow (n: int) (p: int): int =\n  let n_digit = int_of_float (Float.log10 (float_of_int n)) + 1 in\n  let rec sum acc num = function \n  | 0 -> acc \n  | i -> let exp_dig = (int_of_float ((float_of_int (num mod 10)) ** (float_of_int (p+i-1)))) in\n          sum (acc + exp_dig) (num \/ 10) (i-1) in\n  let s = sum 0 n n_digit in\n  if s mod n = 0 then s \/ n else -1;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216909,"user_id":null,"body":"let rec split_number ?(acc=[]) n =\n  if n = 0 then acc else\n  split_number ~acc:((n mod 10) :: acc) (n \/ 10)\n  \nlet rec exp ?(acc=1) a b =\n  if b = 0 then acc\n  else exp ~acc:(acc * a) a (b-1)\n  \nlet sum_powers p ns =\n  ns |> List.mapi (fun i n -> exp n (i+p)) |> List.fold_left (+) 0\n\nlet dig_pow (n: int) (p: int): int =\n  let total = n |> split_number |> sum_powers p in\n  if total mod n = 0 then total \/ n\n  else -1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216910,"user_id":null,"body":"let int_to_list i =\n  let rec helper i acc = \n    if i = 0 then acc \n    else helper (i\/10) ((i mod 10)::acc)\n  in\n  helper i []\n  \nlet rec pow x n = \n    match n with \n    | 0 -> 1 \n    | n -> x * (pow x (n-1))\n    \nlet compute_num n p =\n  let rec pow_num ds p acc = match ds with \n    | [] -> acc\n    | x::xs -> pow_num xs (p + 1) (acc + pow x p)  \n  in\n  pow_num (int_to_list n) p 0\n\nlet dig_pow (n: int) (p: int): int =\n  let result = compute_num n p in\n  if result mod n = 0 then result \/ n else -1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216911,"user_id":null,"body":"let ( *** ) (a : int) (b : int) =\n  let rec inner b acc = if b = 0 then acc else inner (b - 1) (acc * a) in\n  inner b 1\n;;\n\nlet dig_pow (n : int) (p : int) : int =\n  let rec reverse n =\n    let rec reverseInner n acc =\n      if n = 0 then acc else reverseInner (n \/ 10) ((acc * 10) + (n mod 10))\n    in\n    reverseInner n 0\n  in\n  let rec inner n p acc =\n    if n = 0 then acc else inner (n \/ 10) (p + 1) (acc + ((n mod 10) *** p))\n  in\n  let sum = inner (reverse n) p 0 in\n  if sum mod n = 0 then sum \/ n else -1\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216912,"user_id":null,"body":"let explode (s: string) : int list =\n  List.init (String.length s) (String.get s)\n  |> List.map int_of_char\n  |> List.map (fun n -> n - 48)\n\nlet max_k (n: int) (p: int): int =\n  Printf.sprintf \"%d\" n\n  |> explode\n  |> List.mapi (fun i d -> float_of_int d ** float_of_int (p+i))\n  |> List.fold_left (+.) 0.\n  |> int_of_float\n\nlet dig_pow (n: int) (p: int): int =\n  let max_k = (max_k n p) in\n  if max_k mod n = 0 then max_k \/ n\n  else -1\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216913,"user_id":null,"body":"let rec pow n p = if p=0 then 1 else n * pow n (p-1)\n                                       \nlet rec make_list n l = if n<10 then (l @ [n]) else make_list (n\/10) (l@[(n mod 10)])\n      \nlet rec sum_pow_list l1 x p =\n  match l1 with\n  | [] -> x\n  | y::l -> sum_pow_list l (x+(pow y p)) (p+1)\n\nlet rec dig_pow_help n p x =\n  if x * n = sum_pow_list (List.rev (make_list n [])) 0 p then x else\n  if x * n > sum_pow_list (List.rev (make_list n [])) 0 p then -1 else dig_pow_help n p (x+1)\n\nlet dig_pow (n: int) (p: int): int =\n  dig_pow_help n p 1;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216914,"user_id":null,"body":"let rec pow a = function\n  | 0 -> 1\n  | 1 -> a\n  | n -> \n      let b = pow a (n \/ 2) in\n      b * b * (if n mod 2 = 0 then 1 else a)\n              \nlet explode s =\n  let rec exp i l =\n    if i < 0 then l else exp (i - 1) (s.[i] :: l) in\n  exp (String.length s - 1) [];;\n\nlet dig_pow (n: int) (p: int): int =\n  let str = explode ( string_of_int n ) in \n  let rec help ls step acc =\n    match ls with\n      [] -> acc\n    | hd::tl -> help tl (step+1) (acc+(pow (int_of_char hd - 48) step)) in\n  let sum = help str p 0 in\n  if sum mod n == 0 then sum\/n\n  else -1;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"555624b601231dc7a400017a":[{"id":216915,"user_id":null,"body":"let rec josephus_survivor (n: int) (k: int): int =\n  if 1 == n\n  then 1\n  else (((josephus_survivor (n - 1) k) + k - 1) mod n) + 1\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 15:49:07"},{"id":216916,"user_id":null,"body":"let rec josephus_survivor (n: int) (k: int): int =\n  if n = 1 then 1 else (josephus_survivor (n - 1) k + k - 1) mod n + 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 15:49:09"},{"id":216917,"user_id":null,"body":"let josephus_survivor (n: int) (k: int): int =\n\n  let rec loop size l =\n    if size = 1 then List.hd l else\n    let kk = match k mod size with 0 -> size - 1 | kk -> kk - 1 in\n\n    let rec scroll buff = function\n      | 0, a::q -> loop (size-1) (q @ List.rev buff)\n      | i, a::q -> scroll (a::buff) (i-1, q)\n      | _, [] -> failwith \"Did should not have happened ...\" in\n\n    scroll [] (kk, l) in\n\n  loop n (List.init n ((+)1));;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-06 15:49:12"},{"id":216918,"user_id":null,"body":"let rec josephus_survivor (n: int) (k: int): int =\n  match n with\n  | 1 -> 1\n  | _ -> (josephus_survivor (n - 1) k + k - 1) mod n + 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216919,"user_id":null,"body":"open Batteries\n\nlet josephus_survivor (n: int) (k: int): int =\n  let rec remove_step b lst =\n    let len = List.length lst in\n    if len = 1 then List.hd lst\n    else remove_step ((b + k - 1) mod len) (List.remove_at ((b + k - 1) mod len) lst)\n  in\n  remove_step (0) (List.init n ((+) 1))\n\n  (* your code here *)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216920,"user_id":null,"body":"open Batteries \n\nlet josephus_survivor (n: int) (k: int) =\n  let rec remove_step b lst =\n    let len = List.length lst in\n    if len = 1 then List.hd lst\n    else if b + k - 1 < List.length lst\n    then remove_step (b + k - 1) (List.remove_at (b + k - 1) lst)\n    else remove_step ((b - len +  k - 1) mod len) (List.remove_at ((b - len + k - 1) mod len) lst) in\n  remove_step (0) (List.init n ((+) 1)) \n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216921,"user_id":null,"body":"type elmt = END | ELMT of int * (elmt ref);;\nlet josephus_survivor (n: int) (k: int): int =\n  if k = 1 then n else begin\n  let rec init j = { contents =  (if j <= n then ELMT (j, init (j+1)) else END) } in\n  let rec cycle i c = let ELMT (a,e) = !c in\n    match !e with \n    | END -> c := ELMT (a,i)\n    | _ -> cycle i e in \n  let c = (init 1) in\n  cycle c c;\n  let rec elim j r e = \n    let ELMT (a,g) = !e in \n    if r = 0 then a \n    else (\n      let ELMT (b,f) = !g in \n      if j = 2 then (e := ELMT (a,f) ; elim k (r-1) f)\n      else elim (j-1) r g\n    ) in\n  elim k (n-1) c\n  end ;;\n  \n      ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216922,"user_id":null,"body":"let rec josephus_survivor n k = \n  let rec ronde acc i = function\n    | [] -> let ls = List.rev acc in ronde [] i ls\n    | ls when i = 1 -> (List.tl ls) @ (List.rev acc)\n    | ls -> ronde ((List.hd ls)::acc) (i - 1) (List.tl ls)\n  in\n  let rec itere = function\n    | [a] -> a\n    | lst -> itere (ronde [] k lst)\n  in itere (List.init n (function x -> x + 1))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216923,"user_id":null,"body":"let rec josephus_survivor (n: int) (k: int): int =\n        match n with\n        | 1 -> 1\n        | _ -> (k - 1 + (josephus_survivor (n - 1) k)) mod n + 1\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216924,"user_id":null,"body":"let josephus_survivor (n: int) (k: int): int =\n    let rec loop acc m = \n        if m > n then acc\n        else loop ((k - 1 + acc) mod m + 1) (m + 1)\n    in loop 1 1\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5556282156230d0e5e000089":[{"id":216925,"user_id":527,"body":"let dna_to_rna = String.map (function 'T' -> 'U' | c -> c)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216926,"user_id":53,"body":"let dna_to_rna str =\n  Str.global_replace (Str.regexp \"[T]\") \"U\" str;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216927,"user_id":null,"body":"let dna_to_rna dna = String.map (fun c -> if c = 'T' then 'U' else c) dna","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216928,"user_id":168,"body":"let dna_to_rna = Str.global_replace (Str.regexp \"T\") \"U\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216929,"user_id":null,"body":"let dna_to_rna str = Base.String.substr_replace_all ~pattern: \"T\" ~with_: \"U\" str","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216930,"user_id":null,"body":"let dna_to_rna = String.map (fun s -> if s = 'T' then 'U' else s)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216931,"user_id":null,"body":"let dna_to_rna str = \n  let change_thymine c = if c == 'T' then 'U' else c in\n  String.map change_thymine str","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216932,"user_id":null,"body":"let dna_to_rna = String.map (function 'T' -> 'U' | char -> char)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216933,"user_id":null,"body":"let dna_to_rna = String.map (fun c -> if c = 'T' then 'U' else c)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216934,"user_id":null,"body":"let dna_to_rna str = \n  let convert_char = function\n    | 'T' -> 'U' \n    | chr -> chr in\n  String.map convert_char str","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"556deca17c58da83c00002db":[{"id":216935,"user_id":null,"body":"let rec tribonacci signature n =\n      match n,signature with\n      | 1,a::_ -> [a]\n      | 2,a::b::_ -> [a;b]\n      | 3,_ -> signature\n      | n,[a;b;c] when n > 3 -> a::(tribonacci [b;c;a+b+c] (n-1)) \n      | _,_ -> []","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216936,"user_id":null,"body":"let tribonacci signature n =\n  let rec helper result a b c n = \n    match n with\n    | 0 -> result\n    | _ -> helper (a::result) b c (a+b+c) (n-1)\n   in \n     match signature with\n     | a::b::c::[] -> List.rev (helper [] a b c n)\n     | _ -> []","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216937,"user_id":null,"body":"let rec tribonacci signature n = (* your code here! *)\nmatch n with\n| 0 -> []\n| _ ->\n  match signature with\n  [a;b;c] ->\n    a::tribonacci [b;c;(a+b+c)] (n-1)\n  | _ -> []\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216938,"user_id":null,"body":"let rec trib acc a b c = function\n  | 0 -> []\n  | 1 -> [a] \n  | 2 -> [a; b]\n  | 3 -> acc \n  | n -> let next = a + b + c in\n         trib (acc @ [next]) b c next (n - 1)\n\n\nexception Invalid_Seed of int list\n\nlet tribonacci ns n = \n  match ns with \n  | [a; b; c] -> trib [a; b; c] a b c n\n  | _         -> raise (Invalid_Seed ns)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216939,"user_id":null,"body":"let tribonacci signature n =\n  let (a, b, c) = (List.hd signature, List.nth signature 1, List.nth signature 2) in\n  match n with\n  | 0 -> []\n  | 1 -> [a]\n  | 2 -> [a;b]\n  | n ->\n      let rec loop acc (a, b, c) n =\n        if n <= 3 then\n          c :: b :: a :: acc\n        else\n          let new_signature = (b, c, a + b + c) in\n          loop (a :: acc) new_signature (pred n)\n      in\n      List.rev @@ loop [] (a,b,c) n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216940,"user_id":null,"body":"open List\n\nlet rec getsum now left = \n  match left with\n  | 0 -> now\n  | n -> let len = length now in\n         let x = nth now (len -1) in\n         let y = nth now (len -2) in\n         let z = nth now (len -3) in\n         getsum (append now ((x+y+z)::[])) (left - 1)\n  \n\nlet tribonacci signature n =\n    match n with \n    | 0 -> []\n    | 1 -> (nth signature 0)::[]\n    | 2 -> (nth signature 0)::(nth signature 1)::[]\n    | _ -> getsum signature (n - 3)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216941,"user_id":null,"body":"let rec tribonacci signature n =\n  match signature, n with\n  | _,            0 -> []\n  | [x0; x1; x2], n -> x0 :: tribonacci [x1; x2; x0 + x1 + x2] (n - 1)\n  | _,            _ -> failwith \"Signature must have exactly 3 elements\"","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216942,"user_id":null,"body":"let rec tribonacci (a::b::c::[]) = function\n  | 0 -> []\n  | n -> a::(tribonacci [b; c; (a + b + c)] (n - 1))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216943,"user_id":null,"body":"let rec tribonacci signature n =\n  match signature with\n  | a :: b :: c :: _ -> if n=0 then [] else a :: tribonacci ([b; c; a+b+c]) (n-1)\n  | _ -> failwith \"Unreachable\"\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216944,"user_id":null,"body":"let rec f arr n =\n  if n <= 0 then arr else\n  match arr with\n  | a0::a1::a2::t -> f ((a0 + a1 + a2)::a0::a1::a2::t) (n-1)\n  | _ -> failwith \"signature too short\"\n\nlet tribonacci [s0;s1;s2] n = match n with\n  | 0 -> []\n  | 1 -> [s0]\n  | 2 -> [s0;s1]\n  | _ -> f [s2;s1;s0] (n - 3) |> List.rev\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5592e3bd57b64d00f3000047":[{"id":216945,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet find_nb(s: string): int =\n  let n = Num.num_of_string(s) in\n  let f = float_of_num(n) in\n  let ff = Num.num_of_int(int_of_float(floor(sqrt(sqrt(4.0 *. f))))) in\n  let k = (Int 4) *\/ n in\n  let kk = ff *\/ ff *\/ (Num.succ_num ff) *\/ (Num.succ_num ff) in\n    if k =\/ kk then (int_of_num ff) else -1;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216946,"user_id":53,"body":"open Num;;\nopen Big_int;;\n\nlet find_nb ns =\n  let m = big_int_of_string ns in\n  if eq_big_int (mult_big_int (sqrt_big_int m) (sqrt_big_int m)) m then \n    let a = mult_int_big_int 2 (sqrt_big_int m) in\n    let b = sqrt_big_int a in\n    let c = mult_big_int b (add_int_big_int 1 b) in\n    if eq_big_int a c then int_of_big_int b else -1\n  else\n    -1\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216947,"user_id":168,"body":"open Big_int\n\nlet find_nb(s: string): int =\n  let m = big_int_of_string s in\n  let t = sqrt_big_int m in\n  if eq_big_int (square_big_int t) m then\n    let k = succ_big_int (mult_int_big_int 8 t) in\n    let t = sqrt_big_int k in\n    if eq_big_int (square_big_int t) k then\n      let n = int_of_big_int (pred_big_int t) in\n      if n land 1 = 0 then n \/ 2 else -1\n    else -1\n  else -1\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216948,"user_id":null,"body":"open Big_int\n\nlet ( +: )   =  add_big_int\nlet ( *: )   = mult_big_int\nlet ( -: )   =  sub_big_int\nlet ( \/: )   =  div_big_int\nlet ( ~++: ) = succ_big_int\nlet ( ~--: ) = pred_big_int\n\nlet ( >=: ) = ge_big_int\nlet ( =: )  = eq_big_int\n\nlet zero = zero_big_int\n\n\nlet sum_cubes_to_n n = n *: n *: ~++:n *: ~++:n \/: ~++: ~++: ~++: ~++: zero\n\nlet find_nb(s: string): int =\n  let objective = big_int_of_string s in\n\n  let rec search n =\n    let sum = sum_cubes_to_n n in\n    if sum >=: objective then n else\n    search ~++:n in\n\n  let hypothesis = sqrt_big_int (sqrt_big_int (~++: ~++: ~++: ~++: zero *: objective)) in\n  let n = search hypothesis in\n  if sum_cubes_to_n n =: objective then int_of_big_int n else -1","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216949,"user_id":null,"body":"open Big_int;;\nlet find_nb(s: string): int =\n  let n = sqrt_big_int (big_int_of_string s) in\n  if not (eq_big_int (power_big_int_positive_int n 2) (big_int_of_string s)) then  -1\n  else\n  let rec fn (n, count) : int =\n    let res = (mult_big_int (count) (succ_big_int count)) in\n    match res with\n    | x when eq_big_int n x -> int_of_big_int count\n    | x when lt_big_int n x -> -1\n    | x -> fn (n, succ_big_int count)\n  in (fn (mult_big_int n (big_int_of_int 2), unit_big_int))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216950,"user_id":null,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; \n input of find_nb is a string representing a big integer *)\n \nopen Num\n\nlet f n =\n  let n' = num_of_int n in\n  ((n' **\/ num_of_int 2) *\/ ((n' +\/ num_of_int 1) **\/ num_of_int 2)) \/\/ (num_of_int 4)\n\nlet rec bin_search l r target =\n  let m = l + (r - l) \/ 2 in\n  let cur_val = f m in\n  if cur_val =\/ target then m\n  else if (r - l) <= 1 then -1\n  else if target <\/ cur_val\n  then bin_search l m target\n  else bin_search (m + 1) r target\n\nlet find_nb (s: string): int =\n  let target = num_of_string s in\n  bin_search 0 max_int target","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216951,"user_id":null,"body":"open Big_int\n\nlet find_nb(s: string): int =\n  let m = Big_int.big_int_of_string s in\n  let a = Big_int.sqrt_big_int m in\n  let b = Big_int.mult_int_big_int 2 a in\n  let c = Big_int.sqrt_big_int b in \n  let d = Big_int.mult_big_int c (Big_int.add_int_big_int 1 c) in\n  let e = Big_int.div_big_int d (Big_int.big_int_of_int 2) in\n  let f = Big_int.mult_big_int e e in\n  if Big_int.compare_big_int m f == 0 then\n    Big_int.int_of_big_int c\n  else\n    (-1);;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216952,"user_id":null,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; \n   input of find_nb is a string representing a big integer *)\n\n#load \"nums.cma\";;\nopen Num;;\n\nlet find_nb(s: string): int =\n  let ns = Big_int.big_int_of_string s in\n  let sqrt_of_ns = Big_int.sqrt_big_int ns in\n  if Big_int.eq_big_int ns (Big_int.square_big_int sqrt_of_ns)\n  then\n    (\n      let sqrt_of_ns_mult_2 = Big_int.mult_int_big_int 2 sqrt_of_ns in\n      let m = Big_int.sqrt_big_int sqrt_of_ns_mult_2 in\n        if Big_int.eq_big_int\n            (Big_int.mult_big_int (Big_int.succ_big_int m) m)\n            sqrt_of_ns_mult_2 \n        then Big_int.int_of_big_int m\n        else -1\n    )\n  else -1\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216953,"user_id":null,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; \n   input of find_nb is a string representing a big integer *)\n#load \"nums.cma\";; \nopen Num;;    \n   \nlet find_nb(s: string): int =\n    let m = num_of_string s in\n    let r = m |> float_of_num |> sqrt in\n    let n = (-1.0 +. sqrt (1.0 +. 8.0 *. r)) \/. 2.0 |> int_of_float in\n    let k = n * (n + 1) \/ 2 in\n    if (num_of_int k) *\/ (num_of_int k) =\/ m then n else -1","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216954,"user_id":null,"body":"#load \"nums.cma\";; open Num;;\n\nlet sum_of_cubes n = ((n *\/ (n +\/ (Int 1))) \/\/ (Int 2)) **\/ (Int 2);;\n\nlet find_nb(s: string): int =\n  let goal = num_of_string s in\n  let n = ref (Int 1) in\n    while compare_num (sum_of_cubes !n) goal < 1 do\n      n := !n *\/ (Int 2) done;\n    let left = ref (!n \/\/ (Int 2)) and right = ref !n in\n    while !left <\/ !right do\n      let mid = quo_num (!left +\/ !right) (Int 2) in\n        match compare_num (sum_of_cubes mid) goal with\n        | 0 -> left := mid; right := mid\n        | 1 -> right := mid -\/ (Int 1)\n        | _ (* -1 *) -> left := mid +\/ (Int 1)\n    done;\n    if compare_num (sum_of_cubes !left) goal = 0 then int_of_num !left else -1;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559536379512a64472000053":[{"id":216955,"user_id":492,"body":"let play_pass s shift =\n  let bases = [| int_of_char 'A'; int_of_char 'a' |] in\n  let cnt = ref 0 in\n    String.map(fun c ->\n      let cch =\n        match c with \n        | ch when ch >= '0' && ch <= '9' -> (int_of_char '9') - (int_of_char ch) + (int_of_char '0')\n        | ch when ch >= 'A' && ch <= 'Z' -> (((int_of_char ch) - (int_of_char 'A') + shift) mod 26) + bases.(!cnt mod 2)\n        | ch -> int_of_char c\n      in \n        cnt := !cnt + 1;\n        Char.chr cch\n              )\n      s\n      |> string_rev;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216956,"user_id":168,"body":"let play_pass s shift =\n  let encode i ch =\n    if ch >= 'A' && ch <= 'Z' then\n      let d = if i mod 2 = 1 then Char.code 'a' else Char.code 'A' in\n      Char.chr ((Char.code ch - Char.code 'A' + shift) mod 26 + d)\n    else if ch >= '0' && ch <= '9' then\n      Char.chr (9 - (Char.code ch - Char.code '0') + Char.code '0')\n    else ch in\n  let n = String.length s in\n  let s' = String.mapi encode s in\n  String.mapi (fun i _ -> s'.[n - i - 1]) s'\n  ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216957,"user_id":492,"body":"let play_pass s shift =\n  let bases = [| int_of_char 'A'; int_of_char 'a' |] in\n  let cnt = ref 0 in\n    String.map(fun c ->\n      let cch =\n        match c with \n        | ch when ch >= '0' && ch <= '9' -> (int_of_char '9') - (int_of_char ch) + (int_of_char '0')\n        | ch when ch >= 'A' && ch <= 'Z' -> (((int_of_char ch) - (int_of_char 'A') + shift) mod 26) + bases.(!cnt mod 2)\n        | ch -> int_of_char c\n      in \n        cnt := !cnt + 1;\n        Char.chr cch\n              )\n      s\n      |> string_rev;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216958,"user_id":null,"body":"let play_pass s shift =\n  let l = List.init (String.length s) (String.get (String.uppercase_ascii s)) in\n  let trans c = \n    match c with\n    | 'A' .. 'Z' -> Char.chr ((((Char.code c) - 65 + shift) mod 26) + 65)\n    | '0' .. '9' -> Char.chr (105 - Char.code c)\n    | _ -> c in\n  let case i c =\n    if i mod 2 = 1 then Char.lowercase_ascii c else c in\n  l |> List.map trans\n    |> List.mapi case\n    |> List.rev_map (String.make 1)\n    |> String.concat \"\"\n  ","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216959,"user_id":null,"body":"let play_pass s shift =\n    let circular_shift letter k = \n        let shift_char code = (code - 97 + k) mod 26 + 97 in\n        Char.(letter |> lowercase_ascii |> code |> shift_char |> chr) in\n    let is_digit c = \n        let code = Char.code c in\n        code >= 48 && code <= 57 in\n    let is_letter c = \n        let code = Char.code c in\n        (97 <= code && code <= 122) || (65 <= code && code <= 90) in\n    let complement_digit c =\n        let code = Char.code c in\n        Char.chr (57 - code + 48) in\n    let transform ix c =\n        let transformed = \n            if is_digit c then complement_digit c\n            else if is_letter c then circular_shift c shift\n            else c in\n        if ix mod 2 = 0 then Char.uppercase_ascii transformed \n        else Char.lowercase_ascii transformed in\n    let reverse s = s \n        |> String.to_seq \n        |> List.of_seq \n        |> List.rev \n        |> List.map (String.make 1) \n        |> String.concat \"\" in  \n    reverse @@ String.mapi transform s","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216960,"user_id":null,"body":"let change_case_or_number i c = let code = Char.code c in\n  if code >= 65 && code <= 90 || code >= 97 && code <= 122 then\n    if i mod 2 == 0 then\n      Char.uppercase_ascii c\n    else\n      Char.lowercase_ascii c\n  else if code >= 48 && code <= 57 then\n    Char.chr (9 - code + 96)\n  else\n    c;;\n    \nlet shift_letter c n = let nn = n - n\/26 * 26 in let lcode = Char.lowercase_ascii c |> Char.code in\n  if lcode >= 97 && lcode <= 122 then\n    if (lcode + nn) > 122 then\n      lcode + nn - 26 |> Char.chr\n    else\n      lcode + nn |> Char.chr\n  else\n      c;;\n\nlet reverses s = String.to_seq s |> List.of_seq |> List.rev |> List.to_seq |> String.of_seq;;\n\nlet play_pass s shift = String.map (fun si -> shift_letter si shift) s |> String.mapi change_case_or_number |> reverses;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216961,"user_id":null,"body":"let str_to_arr s = let l = String.length s in (Array.init l (fun i -> s.[i]));;\n\nlet shift_char c n =\n\tlet code = Char.code c in \n\tmatch code with\n\t| a when (65 <= a && a <= 90) ->\n\t\tif (code + n) > 90 then\n\t\t\tChar.chr ((code + n - (Char.code 'A')) mod 26 + Char.code 'A')\n\t\telse\n\t\t\tChar.chr (code + n)\n\t| a when (97 <= a && a <= 122) ->\n\t\t\tif (code + n) > 122 then\n\t\t\t\tChar.chr ((code + n - (Char.code 'a')) mod 26 + Char.code 'a')\n\t\t\telse\n\t\t\t\tChar.chr (code + n)\n\t| a when (48 <= a && a <= 57) ->\n\t\t\tchar_of_int (57 - code + 48)\n\t| a -> c\n\t;;\n\n\nlet play_pass s shift =\n\tlet l = String.length s in \n\tlet arr = str_to_arr s in\n\tlet char_arr = Array.init l (fun i -> shift_char arr.(i) shift) in\n\tfor i = 0 to (l - 1) do\n\t\tlet char = char_arr.(i) in\n\t\tlet code = Char.code char in\n\t\t\tif ((65 <= code && code <= 90) || (97 <= code && code <= 122)) then begin\n\t\t\t\tif i mod 2 = 0 then char_arr.(i) <- Char.uppercase_ascii char\n\t\t\t\telse char_arr.(i) <- Char.lowercase_ascii char;\n\t\t\tend;\n\tdone;\n  String.init l (fun i -> char_arr.(l - i - 1));;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216962,"user_id":null,"body":"let code c shift =\n  let cp = Char.uppercase_ascii c in\n  if 'A' <= cp && cp <= 'Z' then\n    Char.chr ((Char.code(cp) + shift - Char.code 'A')  mod 26 + Char.code 'A')\n  else \n    Char.chr (Char.code('9') - Char.code(cp) + Char.code('0'))\n\nlet play_pass s shift =\n  let len = String.length s in\n  let is_char_or_number c = match Char.uppercase_ascii c with\n    | c when ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') -> true\n    | _ -> false in\n  String.mapi (fun i _ -> let f = if not (is_char_or_number (s.[len - i - 1])) then s.[len - i - 1] else if (len - i - 1) mod 2 = 0 then Char.uppercase_ascii (code  (s.[len - i - 1]) shift) else Char.lowercase_ascii (code (s.[len - i - 1]) shift) in f) s \n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216963,"user_id":null,"body":"let get_type c = \n  let i = int_of_char c in\n  if i >= 48 && i <= 57\n  then \"int\"\n  else if (i >= 65 && i <= 90) || (i >= 97 && i <= 122)\n  then \"letter\"\n  else \"special\"\n\nlet letter_shift c shift = \n  let shift = shift mod 26 in\n  let is_upper = if (int_of_char c) <= 90 then true else false in\n  let i = shift + int_of_char c in\n  if i > 122\n  then char_of_int (i - 26)\n  else if i > 90 && is_upper\n  then char_of_int (i - 26)\n  else char_of_int i\n\nlet digit_complement c = \n  let i = c |> Char.escaped |> int_of_string in\n  (string_of_int (9 - i)).[0]\n\nlet play_pass s shift =\n  let len = String.length s in\n  let a = Array.make len ' ' in\n  for i = 0 to len - 1 do\n    let t = get_type s.[i] in\n    if t = \"int\"\n    then a.(i) <- digit_complement s.[i]\n    else if t = \"letter\"\n    then (if i mod 2 = 0\n          then a.(i) <- Char.uppercase_ascii @@ letter_shift s.[i] shift\n          else a.(i) <- Char.lowercase_ascii @@ letter_shift s.[i] shift)\n    else a.(i) <- s.[i]\n  done;\n  let b = Buffer.create len in\n  for j = len - 1 downto 0 do\n    Buffer.add_char b a.(j)\n  done;\n  Buffer.contents b","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216964,"user_id":null,"body":"\nlet small_a = Char.code 'a'\nlet big_a = Char.code 'A'\nlet small_z = Char.code 'z'\nlet big_z = Char.code 'Z'\nlet zero = Char.code '0'\nlet nine = Char.code '9'\n\nlet play_pass s shift =\n  let transformed = String.mapi (fun i c ->\n    let code = Char.code c in\n    if big_a <= code && code <= big_z then\n    (\n      let offset = (code - big_a + shift) mod 26 in\n      if i mod 2 == 0 then\n        Char.chr (big_a + offset)\n      else\n        Char.chr (small_a + offset)\n    )\n    else if zero <= code && code <= nine then\n      Char.chr (zero + (9 - (code - zero)))\n    else\n      c) s\n  in\n  let n = String.length s in\n  String.init n (fun i -> transformed.[n-i-1])\n ;;       \n      \n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559a28007caad2ac4e000083":[{"id":216965,"user_id":53,"body":"open Num;;\nopen Big_int;;\n\nlet rec helper n a b sum =\n  if (gt_big_int (big_int_of_int 0) n) then string_of_big_int sum\n  else\n    helper (sub_big_int n (big_int_of_int 1)) b (add_big_int a b) (add_big_int sum (mult_big_int a (big_int_of_int 4)))\n  ;;\n\nlet perimeter (n: int): string =\n  helper (big_int_of_int n) (big_int_of_int 1) (big_int_of_int 1) (big_int_of_int 0)\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216966,"user_id":null,"body":"open List\nopen Printf\nopen Big_int\n\nlet get_last_two = function\n  | [] -> failwith \"unreachable\"\n  | hd :: tl -> hd, List.hd tl\n;;\n\nlet tab_fib n =\n  let rec tab_fib tab i =\n    if i >= n\n    then tab\n    else (\n      let t1, t2 = get_last_two tab in\n      tab_fib ((add_big_int t1 t2) :: tab) (i + 1))\n  in\n  tab_fib [ big_int_of_int 1; big_int_of_int 1 ] 2\n;;\n\nlet perimeter (n : int) =\n  n + 1\n  |> tab_fib\n  |> fold_left add_big_int (big_int_of_int 0)\n  |> mult_int_big_int 4\n  |> string_of_big_int\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216967,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet fib(n: int): Num.num =\n  let rec aux current next n =\n    if n = 0 then current\n    else aux next (Num.add_num current next) (n - 1) \n  in\n    aux (Int 1) (Int 1) n;;\n\nlet perimeter (n: int): string =\n  string_of_num ((Num.mult_num (Int 4) (Num.sub_num (fib (n + 2)) (Int 1))));;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216968,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet fib(n: int): Num.num =\n  let rec aux current next n =\n    if n = 0 then current\n    else aux next (Num.add_num current next) (n - 1) \n  in\n    aux (Int 1) (Int 1) n;;\n\nlet perimeter (n: int): string =\n  string_of_num ((Num.mult_num (Int 4) (Num.sub_num (fib (n + 2)) (Int 1))));;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216969,"user_id":null,"body":"let perimeter (n: int): string =\n  let open BatBig_int in\n  let two = succ one in\n  let fibo n =\n    let rec loop a b p q = function\n      | n when eq_big_int n zero -> b\n      | n when eq_big_int (and_big_int n one) zero ->\n        loop a b (p*p + q*q) (q * (two*p + q)) (n \/ two)\n      | n -> loop (a*(p + q) + b*q) (b*p + a*q) p q (n - one) in\n    loop one one zero one n in\n  string_of_big_int @@ two * two * (fibo (big_int_of_int n + two) - one)\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216970,"user_id":null,"body":"#load \"nums.cma\";\nopen Num;; \nopen Big_int   \n   \nlet rec fibSRt n a b s  =\n  if compare_num n (num_of_big_int unit_big_int) = 0 then s \n  else fibSRt (sub_num n (num_of_big_int unit_big_int)) (add_num a b) a (add_num (add_num s  b)  a)\n\nlet fibS n = if compare_num n  (num_of_int 1) = 0 \n             then num_of_int 1 \n             else fibSRt n (num_of_int 1) (num_of_int 0) (num_of_int 1) \n\nlet perimeter (n: int): string =\n    string_of_num (mult_num (num_of_int 4) \n    (fibS (add_num  (num_of_int n)  (num_of_int 1))))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216971,"user_id":null,"body":"open Batteries\n\nlet fibonacci () =\n  let terms = ref [| Big_int.one; Big_int.one |] in\n  let rec helper n =\n    let len = Array.length !terms in\n    if n < len\n    then !terms.(n)\n    else begin\n      terms := Array.append !terms [| Big_int.add !terms.(len-2) !terms.(len-1) |];\n      helper n\n    end\n  in helper\n\nlet perimeter (n: int): string =\n  let my_fib = fibonacci () in\n  List.init (n+1) my_fib \n  |> List.reduce Big_int.add \n  |> Big_int.mul (Big_int.of_int 4)\n  |> Big_int.to_string","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216972,"user_id":null,"body":"open Num\n\n\nlet perimeter (n: int): string =\n    let fibonacci m =\n        let rec loop a b k =\n            if k = m then a\n            else loop b (a +\/ b) (k + 1) in\n        loop (Int 1) (Int 1) 0 in\n    let f = fibonacci (n + 2) in\n    string_of_num @@ (Int 4) *\/ (f -\/ (Int 1))\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216973,"user_id":null,"body":"#load \"nums.cma\";;\nopen Num;; \nlet perimeter (n: int): string =\n    let rec aux sum big small = function\n    | 0 -> string_of_num ((Int 4) *\/ sum) (* WTF string *)\n    | i -> aux (sum +\/ big) (big +\/ small) big (i-1)\n    in aux (Int 0) (Int 1) (Int 0) (n+1);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216974,"user_id":null,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; \n   perimeter returns a big integer as a string*)\n   \nlet perimeter (n: int): string =\n   let rec help n1 n2 sum times = \n     if times = 0 then\n      Big_int.mult_big_int sum (Big_int.big_int_of_int 4)\n     else\n      let n3 = Big_int.add_big_int n1 n2 in\n      help n2 n3 (Big_int.add_big_int sum n1) (times - 1)\n   in let one = Big_int.big_int_of_int 1\n   in Big_int.string_of_big_int @@ help one one (Big_int.big_int_of_int 0) (n + 1)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559b8e46fa060b2c6a0000bf":[{"id":216975,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet choose n p =\n  let m = min p (n - p) in\n    if m < 0 then Int 0 else\n      let rec loop j v =\n        if j = m then v\n        else loop (succ j) ((v *\/ (Int (n - j))) \/\/ (Int (succ j)))\n      in loop 0 (Int 1);;\n\nlet diagonal (n:int) (p:int): string =\n  string_of_num (choose (n + 1) (p + 1));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216976,"user_id":null,"body":"open Big_int\nlet diagonal (n:int) (p:int): string = \n  let minus_one = (minus_big_int unit_big_int) in\n  let memo = Array.make_matrix (n+1) (p+1) minus_one in \n  let rec diagonal_rec (n:int) (p:int) : big_int = \n    if (eq_big_int memo.(n).(p) minus_one)  then  \n      memo.(n).(p) <- (match n,p with \n                      | _,0 -> (add_big_int (big_int_of_int n) unit_big_int)\n                      | i,j when i < j -> zero_big_int\n                      | i,j when i = j -> unit_big_int\n                      | _,_ -> (add_big_int (diagonal_rec (n-1) (p-1)) (diagonal_rec (n-1) p)));\n    memo.(n).(p) \n  in\n  string_of_big_int (diagonal_rec n p)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216977,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet choose n p =\n  let m = min p (n - p) in\n    if m < 0 then Int 0 else\n      let rec loop j v =\n        if j = m then v\n        else loop (succ j) ((v *\/ (Int (n - j))) \/\/ (Int (succ j)))\n      in loop 0 (Int 1);;\n\nlet diagonal (n:int) (p:int): string =\n  string_of_num (choose (n + 1) (p + 1));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216978,"user_id":53,"body":"open Num;;\nopen Big_int;;\n\nlet rec helper n k i r =\n  if (gt_big_int i k) then string_of_big_int r\n  else \n    let a = sub_big_int n i in\n    let b = add_big_int a (big_int_of_int 1) in\n    let c = mult_big_int r b in\n    let d = div_big_int c i in\n    helper n k (add_big_int i (big_int_of_int 1)) d ;;\n  \nlet diagonal n p =\n  let bn = big_int_of_int (n + 1) in\n  let bp = big_int_of_int (p + 1) in\n  let bi = big_int_of_int 1 in\n  let br = big_int_of_int 1 in\n  helper bn bp bi br ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216979,"user_id":480,"body":"let big_comb n p=\n  let p_hi=if n-p>p then n-p else p in\n  let p_lo=n-p_hi in\n  let rec prod a b=\n    let ba=Big_int.big_int_of_int a and bb=Big_int.big_int_of_int b in\n    if a==b \n    then bb \n    else Big_int.mult_big_int ba (prod (a+1) b) in\n      let num = prod (p_hi+1) n and den= prod 1 p_lo in\n      Printf.printf \"n=%d p=%d %s\/%s\n\" n p (Big_int.string_of_big_int num) (Big_int.string_of_big_int den);\n      Big_int.div_big_int num den;;\n    \n  \nlet diagonal (n:int) (p:int): string =\n  if p==0 then string_of_int (n+1) else\n  let b=Big_int.big_int_of_int in\n  let r = (Big_int.div_big_int\n            (Big_int.mult_big_int\n              (b (n-p+1))\n              (big_comb (n+1) p)\n            )\n            (b (p+1))) in\n  Big_int.string_of_big_int r;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216980,"user_id":null,"body":"open Num\n\n\nlet diagonal (n:int) (p:int): string =\n    let f n k =\n        let rec loop acc i =\n            if i > k then string_of_num acc\n            else loop (acc *\/ (n -\/ i +\/ Int 1) \/\/ i ) (i +\/ Int 1)\n        in loop (Int 1) (Int 1)\n    in f (Int (n + 1)) (Int (p + 1))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216981,"user_id":null,"body":"let diagonal n p =\n  let open Core in\n  \n  let memo = Array.make_matrix ~dimx:(p + 1) ~dimy:(n + 1) None in\n  \n  let rec pascal x y =\n    if Option.is_some memo.(x).(y) then ()\n    \n    else if x = 0 || x = y then \n      memo.(x).(y) <- Some (BatBig_int.one, BatBig_int.one)\n    \n    else begin\n      pascal (x - 1) (y - 1);\n      pascal x (y - 1);\n      let (left, _) = Option.value_exn memo.(x - 1).(y - 1) in\n      let (right, total) = Option.value_exn memo.(x).(y - 1) in\n      memo.(x).(y) <- Some (BatBig_int.(left + right), \n                            BatBig_int.(total + left + right))\n    end\n  in\n  \n  if p = 0 then n + 1 |> Int.to_string\n  else if p = n then \"1\"\n  else begin\n    pascal p n;\n    Option.value_exn (memo.(p).(n)) |> snd |> BatBig_int.to_string\n  end","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216982,"user_id":null,"body":"open BatBig_int;;\n\nlet diagonal_big (n: big_int) (p: big_int): big_int =\n    let rec go s a b i =\n        if gt_big_int i (n - p)\n            then s\n            else\n                let b' = a + b in\n                let i' = i + one in\n                let a' = b' * (p + one) \/ i' in\n                go (s + a) a' b' i' in\n    go one (p + one) one one;;\n\nlet diagonal (n: int) (p: int): string =\n    let s = diagonal_big (of_int n) (of_int p) in\n    to_string s;;\n\nopen BatInt;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216983,"user_id":null,"body":"open Big_int\n\nlet diag (a:Big_int.big_int) n =\n  let rec _r i =\n    if i == 0 then [] else a :: (_r (i - 1))\n  in\n  _r n;;\n\nlet trans xs =\n  match xs with\n  | [] -> []\n  | a :: xs ->\n     let rec _tx p rs =\n       match rs with\n       | [] -> []\n       | i :: _rs ->\n          let n = (Big_int.add_big_int i p) in\n          n :: (_tx n _rs)\n     in\n     a :: (_tx a xs);;\n\nlet rec n_trans n xs =\n  if n == 0 then xs else n_trans (n - 1) (trans xs);;\n\nlet diagonal (n:int) (p:int) : string =\n  let ls = (n_trans p (diag Big_int.unit_big_int (n - p + 1))) in\n  let sum = List.fold_left (fun a b -> Big_int.add_big_int a b) Big_int.zero_big_int ls in\n  Big_int.string_of_big_int sum;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216984,"user_id":null,"body":"let binomial n k =\n  let open Big_int in\n  let rec binomial_iter n k i prev =\n    if i >= k then prev else binomial_iter n k (i+1)\n    (div_big_int (mult_big_int (big_int_of_int (n-i))\n                               prev)\n                 (big_int_of_int (i+1))) in\n  if k < n-k then \n    binomial_iter n k 0 unit_big_int\n  else\n    binomial_iter n (n-k) 0 unit_big_int\n\nlet diagonal (n:int) (p:int): string =\n binomial (n+1) (p+1) |> Big_int.string_of_big_int","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559ce00b70041bc7b600013d":[{"id":216985,"user_id":492,"body":"let finance(n: int) =\n  n * (n * n + 3 * n + 2) \/ 2;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216986,"user_id":492,"body":"let finance(n: int) =\n  n * (n * n + 3 * n + 2) \/ 2;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216987,"user_id":null,"body":"let finance(n: int) =\n  let gen(n1: int) =\n    List.fold_left (+) 0 (List.init (n+1-n1) (function x -> (2*n1)+x)) in\n  let l = List.init (n+1) gen in\n  List.fold_left (+) 0 l\n  ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216988,"user_id":null,"body":"let finance(n: int) =\n    n * n * (n + 3) \/ 2 + n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216989,"user_id":null,"body":"let finance (n: int) =\n  let rec one_week day amount = if day = n then amount else amount + one_week (day + 1) (amount + 1) in\n  let rec get_all start_day amount =\n    if start_day > n then 0 else one_week start_day amount + get_all (start_day + 1) (amount + 2) in\n  get_all 0 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216990,"user_id":null,"body":"let zero_more = max 0\n\nlet rec sliced_factorial base steps =\n  let rec iter acc base = function\n    | 0 -> acc\n    | steps ->\n      let acc = acc + base in\n      let base = base - 1 |> zero_more in\n      iter acc base (steps - 1)\n  in\n  iter 0 base steps\n\nlet finance(n: int) =\n  let rec iter acc base = function\n    | 0 -> acc\n    | steps ->\n      let acc = acc + (sliced_factorial base steps) in\n      iter acc (base + 1) (steps - 1)\n  in\n  iter 0 n (n + 1)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216991,"user_id":null,"body":"let finance(n: int) =\n  let rec sum_week amount days =\n    match days with\n    | 0 -> amount\n    | _ -> amount + (sum_week (amount + 1) (days - 1))\n  in\n   \n   let rec sum_n amount n n_max =\n     let starting_amount = ((n_max - n) * 2) in\n     match n with\n     | 0 -> amount + (sum_week starting_amount n)\n     | _ -> sum_n (amount + (sum_week starting_amount n)) (n - 1) n_max\n   in\n   \n   sum_n 0 n n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216992,"user_id":null,"body":"let rec finance(n: int) =\n  let f x = x * (x + 1) \/ 2 in\n  match n with\n  | 0 -> 0\n  | _ -> f (2*n) - f (n-1) + finance(n-1)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216993,"user_id":null,"body":"let finance(n: int) =\n  (n * (n+1) \/ 2 + n * (n+1) * (2*n+1) \/ 6) * 3 \/ 2;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216994,"user_id":null,"body":"let finance(n: int): int =\n  let prev = ref (n * (n + 1) \/ 2) in\n  let total = ref !prev in\n  for i = 1 to n do\n    prev := !prev + n + 3 - 3 * i;\n    total := !total + !prev\n  done;\n  !total","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"559e3224324a2b6e66000046":[{"id":216995,"user_id":null,"body":"let sumin (n: int): int =\n  n*(n+1)*(2*n+1)\/6;;\nlet rec sumax (n: int): int =\n  match n with\n    | 1 -> 1\n    | p -> p*(2*p-1) + sumax (p-1)\nlet sumsum (n: int): int =\n  n*n*(n+1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216996,"user_id":53,"body":"let sumin (n: int): int =\n  n * (n+1) * (2 * n + 1) \/ 6;;\nlet sumax (n: int): int =\n  n * (n+1) * (4 * n - 1) \/ 6;;\nlet sumsum (n: int): int =\n (n+1) * n * n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216997,"user_id":null,"body":"let rec sumin2 (x: int) (y: int) (z: int) sum: int =\n    if x = 0 && y = 0 then sum else\n        if x = 0 && y != 0 then sumin2 z (y-1) z sum else \n            if x <= y then sumin2 (x-1) y z (sum+x) else sumin2 (x-1) y z (sum+y);;\n\nlet rec sumax2 (x: int) (y: int) (z: int) sum: int =\n    if x = 0 && y = 1 then sum else\n        if x = 0 && y != 0 then sumax2 z (y-1) z sum else \n            if x >= y then sumax2 (x-1) y z (sum+x) else sumax2 (x-1) y z (sum+y);;\n\nlet sumin (n: int): int =\n    sumin2 n n n 0;;\n    \nlet sumax (n: int): int =\n    sumax2 n n n 0;;\n\nlet sumsum (n: int): int =\n    sumin n + sumax n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216998,"user_id":null,"body":"let sumin (n: int): int =\n  n * (n + 1) * (2*n + 1) \/ 6\n\nlet sumax (n: int): int =\n  n * (n + 1) * (4*n - 1) \/ 6\n\nlet sumsum (n: int): int =\n  n * (n + 1) * n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":216999,"user_id":98,"body":"let sumin (n: int): int = (n) * (n + 1) * (2 * n + 1) \/ 6\n;;\nlet sumax (n: int): int = (n) * (n + 1) * (4 * n - 1) \/ 6\n;;\nlet sumsum (n: int): int = (n) * (n + 1) * (6 * n) \/ 6\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217000,"user_id":null,"body":"let sumin n =\n  let rec counter a x k =\n    if x>n then a else counter (a + (x*k)) (x+1) (k-2)\n  in counter 0 1 ((n+n)-1)\n    \nlet sumax n =\n  let rec counter a x k =\n    if x=0 then a else counter (a + (x*k)) (x-1) (k-2)\n  in counter 0 n ((n+n)-1)\n    \nlet sumsum n = sumin n + sumax n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217001,"user_id":null,"body":"let rec loop_aux (op: int -> int -> int) (x: int) (y: int) (n: int) (a: int): int =\n  match x, y with\n  | 1, 1  -> a + (op x y)\n  | 1, _  -> (loop_aux op n (y-1) n (a + (op x y)))\n  | _, _  -> (loop_aux op (x-1) y n (a + (op x y)))\n\nlet sumin (n: int): int =\n  loop_aux min n n n 0;;\nlet sumax (n: int): int =\n  loop_aux max n n n 0;;\nlet sumsum (n: int): int =\n  loop_aux (+) n n n 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217002,"user_id":null,"body":"let sumfun f n =\n  let rec sumfuny s x y = \n    if y = n then s + f x y else sumfuny (s + f x y) x (y + 1) in\n    \n  let rec sumfunx s x =\n    if x = n then sumfuny s x 1 else sumfunx (sumfuny s x 1) (x + 1) in\n    \n  sumfunx 0 1\n  \nlet sumin = sumfun min\nlet sumax = sumfun max\nlet sumsum = sumfun ( + )\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217003,"user_id":null,"body":"let rec range m n = if m > n then [] else m :: range (m + 1) n\n\nlet sumin (n : int) : int =\n  List.fold_right (fun v sum -> sum + v + ((n - v) * 2 * v)) (range 1 n) 0\n\nlet sumax (n : int) : int =\n  List.fold_right (fun v sum -> sum + v + ((v - 1) * 2 * v)) (range 1 n) 0\n\nlet sumsum (n : int) : int = sumin n + sumax n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217004,"user_id":null,"body":"let sumin (n: int): int =\n  let rec sumin_rec n i acc=\n    if i == n then acc\n    else sumin_rec n (i+1) (acc+ ( (((n-i)*(n-i+1))\/2)+((n-i)*i) )) in\n  sumin_rec n 0 0 ;;\n  \nlet sumsum (n: int): int = n*n*n+n*n ;;\nlet sumax (n: int): int = sumsum n - sumin n ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55a29405bc7d2efaff00007c":[{"id":217005,"user_id":null,"body":"let going n =\n  let rec sum acc1 acc2 = function\n    | 1 -> acc1\n    | k -> let x = acc2 \/. (Float.of_int k) in sum (acc1 +. x) x (k - 1)\n  in (floor ((sum 1. 1. n) *. 1000000.)) \/. 1000000.","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217006,"user_id":53,"body":"let rec walk n =\n  if n <= 0 then 0.0 else 1.0 +. walk(n - 1) \/. float_of_int(n) ;;\n    \nlet going n =\n  let m = walk n in\n  float_of_int (int_of_float (m *. 1000000.0)) \/. 1000000.0 ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217007,"user_id":492,"body":"let trunc x p = (floor (x *. (10.0 ** (float_of_int p)))) \/. (10.0 ** (float_of_int p));;\nlet going n =\n  let rec go i iter res =\n    if i = 1 then trunc res 6\n    else \n      let it = iter *. 1.0 \/. (float_of_int i) in\n        go (i - 1) it (res +. it)\n  in go n 1.0 1.0;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217008,"user_id":492,"body":"let trunc x p = (floor (x *. (10.0 ** (float_of_int p)))) \/. (10.0 ** (float_of_int p));;\nlet going n =\n  let rec go i iter res =\n    if i = 1 then trunc res 6\n    else \n      let it = iter *. 1.0 \/. (float_of_int i) in\n        go (i - 1) it (res +. it)\n  in go n 1.0 1.0;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217009,"user_id":null,"body":"let going n =\n  let rec loop acc = function\n    | k when k = n -> acc \/. float_of_int n +. 1.\n    | k -> loop (acc \/. float_of_int k +. 1.) (k + 1) in\n  (floor @@ 1_000_000. *. loop 0. 1) \/. 1_000_000.\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217010,"user_id":null,"body":"let trunc f =\n  Float.to_string f\n  |> (fun s ->\n      let i = min (String.index s '.' + 7) (String.length s) in\n      String.sub s 0 i)\n  |> Float.of_string\n\nlet rec divfact (n : float) (m : float) = \n  assert (n > 0.);\n  assert (m > 0.);\n  if n = m\n  then 1.\n  else\n    match n, m with\n    | _, 1. -> (n \/. m) *. divfact (n -. 1.) 1.\n    | 1., _ -> (n \/. m) *. divfact 1. (m -. 1.)\n    | n, m -> (n \/. m) *. divfact (n -. 1.) (m -. 1.)\n\nlet going n =\n  List.init n (fun x -> (Float.of_int (x + 1), Float.of_int n))\n  |> List.map (fun (a, b) -> divfact a b)\n  |> List.fold_left (+.) 0.\n  |> trunc\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217011,"user_id":null,"body":"let going n =\n  let trunc6 x = float_of_int (int_of_float (x *. 10. ** 6.)) \/. (10. ** 6.) in\n  let rec all_factors cur num = if num = 1. then [1.] else (cur \/. num) :: all_factors (cur \/. num) (num -. 1.) in\n  trunc6 (List.fold_left ( +. ) 0. (all_factors 1. (float_of_int n)));;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217012,"user_id":null,"body":"let going n =\n    let rec loop acc k = \n        if k = n then acc\n        else \n            let k = k + 1 in\n            loop (acc \/. (float_of_int k) +. 1.0) k in\n    let fraction = loop 1.0 1 in\n    floor (fraction *. 1000000.0) \/. 1000000.0\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217013,"user_id":null,"body":"\nlet trunc6 x = (Float.of_int (Float.to_int (x*.1000000.0)))\/.1000000.0\n;;\nlet rec goingaux = function\n    |1 -> 1.0\n    |n -> (goingaux (n-1))\/. Float.of_int n +. 1.0\n;;  \n\nlet going n = trunc6 (goingaux n);;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217014,"user_id":null,"body":"let fsigma f n =\n  let rec fsigmai acc = function\n  | 1 -> acc\n  | n -> fsigmai (acc +. f n) (n-1)\n  in fsigmai 0. n\n\nlet odmul n k =\n  let rec odmuli acc = function\n  | k when k = n -> acc \/. (float_of_int n)\n  | k -> odmuli (acc \/. (float_of_int k)) (k+1)\n  in odmuli 1. k\n\nlet going n =\n  let open Core.Std in\n  let slice str = String.slice str 0 8 in\n  (1. +. fsigma (odmul n) n)\n  |> Printf.sprintf \"%0.10f\"\n  |> slice \n  |> Float.of_string\n  \n  \n  \n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55aa075506463dac6600010d":[{"id":217015,"user_id":492,"body":"open Printf;;\n\nlet rec range (a: int) (b: int): int list =\n  if a > b then []\n  else a :: range (a+1) b;;\n\nlet sq_factors n =\n  List.filter (fun v -> (n mod v) = 0) (range 1 n)\n  |> List.map (fun x -> x * x)\n  |> List.fold_left (+) 0;;\n\nlet is_square num =\n  let s = int_of_float(sqrt(float_of_int(num))) in\n    s * s = num;;\n\nlet list_squared (m: int) (n: int): string =\n  let r = range m n in\n    List.map(fun x -> (x, sq_factors x)) r\n    |> List.filter (fun (x, y) -> is_square y)\n    |> List.map (fun (x, y) -> sprintf \"(%d, %d)\" x y)\n    |> String.concat \"; \";;\n    \n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217016,"user_id":168,"body":"let rec sq_divs acc k n =\n  if k > n then acc\n  else if n mod k = 0 then\n    sq_divs (acc + k * k) (succ k) n\n  else\n    sq_divs acc (succ k) n\n    \nlet is_square n = \n  let t = truncate (sqrt (float n)) in\n  t * t = n\n\nlet list_squared (m: int) (n: int): string =\n  let rec loop acc m =\n    if m > n then List.rev acc\n    else\n      let s = sq_divs 0 1 m in\n      if is_square s then\n        loop ((m, s) :: acc) (succ m)\n      else\n        loop acc (succ m) in\n  let str (a, b) = Printf.sprintf \"(%d, %d)\" a b in\n  loop [] m |> List.map str |> String.concat \"; \"\n      \n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217017,"user_id":null,"body":"let list_squared (m: int) (n: int): string =\n  let is_square k =\n      let sqrtk = k |> float_of_int |> sqrt |> int_of_float in\n      sqrtk * sqrtk = k in\n  let test k =\n      if k = 1 then Some (1, 1) else\n      if List.mem k [2; 3] then None else\n      let rec divs acc = function\n        | 1 -> 1 :: acc\n        | x -> if k mod x = 0 then divs (x :: k \/ x :: acc) (x - 1) else divs acc (x - 1) in\n      let sqrtk = k |> float_of_int |> sqrt |> int_of_float in\n      let acc =\n        if sqrtk * sqrtk = k then [sqrtk; k] else\n        if k mod sqrtk = 0 then [sqrtk; k \/ sqrtk; k] else\n        [k] in\n      let d = divs acc (sqrtk - 1) in\n      let sum_squares = List.fold_left (fun acc x -> acc + x * x) 0 d in\n      if is_square sum_squares then Some (k, sum_squares) else None in\n  List.init (n - m) (fun k -> test (k + m))\n    |> List.map (function (Some (a, b)) -> Printf.sprintf \"(%d, %d)\" a b | _ -> \"\")\n    |> List.filter (( <> ) \"\")\n    |> String.concat \"; \"","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217018,"user_id":294,"body":"let rec list_squared (m: int) (n: int): string =\n    let rec recur acc x =\n        if x > n then List.rev acc\n        else\n            let divs = divisors_of x in\n            let sum = divs |> List.map (fun x -> x * x) |> List.fold_left (+) 0 in\n            \n            if is_square sum then\n                let acc' = (x, sum) :: acc\n                in recur acc' (x + 1)\n            else\n                recur acc (x + 1)\n\n    in\n    recur [] m\n    |> List.map (fun (x, y) -> Printf.sprintf \"(%d, %d)\" x y)\n    |> String.concat \"; \"\n\n\nand is_square num =\n    let x = int_of_float (sqrt (float_of_int num))\n    in x * x = num\n\n\nand divisors_of num =\n    let rec recur acc d =\n        if d * 2 > num then\n            List.rev (num :: acc)\n        else if num mod d = 0 then\n            recur (d :: acc) (d + 1)\n        else\n            recur acc (d + 1)\n\n    in recur [] 1\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217019,"user_id":null,"body":"let rec string_of_list = function\n  [] -> \"\"\n  | (a, b) :: [] -> \"(\" ^ string_of_int a ^ \", \" ^ string_of_int b ^ \")\"\n  | h :: t -> string_of_list (h :: []) ^ \"; \" ^ string_of_list t;;\n\nlet rec divisors cur number lst = if cur = number then cur :: lst else divisors (cur + 1) number (if number mod cur = 0 then cur :: lst else lst);;\nlet prod number = List.fold_left (fun total cur -> total + cur * cur) 0 (divisors 1 number []);;\nlet is_square number =\n  let half = sqrt (float_of_int number) in\n  let h' = int_of_float half in\n  number = h' * h';;\n\nlet list_squared (m: int) (n: int): string =\n  let res = ref [] in\n  for i = m to n do\n    if is_square (prod i) then res := (i, prod i) :: !res\n  done;\n  string_of_list (List.rev !res);;\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217020,"user_id":null,"body":" \nlet list_squared (m: int) (n: int): string =\n  let rec get_div acc m n =\n    if m > n then List.rev acc\n    else match n mod m with\n         | 0 -> get_div (m * m::acc) (m + 1) n\n         | _ -> get_div (acc) (m + 1) n\n  in\n  let rec build_squared_list acc lst = match lst with\n      [] -> String.concat \"; \" (List.rev acc)\n    | hd::tl -> let sum = List.fold_left (+) 0 (get_div [] 1 hd) in\n                let s = sqrt (float_of_int sum) in\n                if  s = floor s then  \n                  build_squared_list ((\"(\" ^ string_of_int hd ^ \", \" ^ string_of_int sum ^ \")\")::acc) tl\n                else\n                  build_squared_list acc tl\n  in\n  build_squared_list [] (List.init (n-m+1) (fun x -> m + x))\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217021,"user_id":53,"body":"open List;;\nopen String;;\n\nlet divisors i =\n  let rec _rec j =\n    if j > i then\n      []\n    else\n      if i \/ j * j = i then\n        j :: _rec (j + 1)\n      else\n        _rec (j + 1)\n  in\n  _rec 1\n;;\n\nlet is_square (n: int): bool =\n    mod_float (sqrt (float n)) 1.0 = 0.0\n\nlet list_squared (m: int) (n: int): string =\n    let rec go (k: int): string list =\n        if k > n\n            then []\n            else\n                let s = k |> divisors |> List.map (fun f -> f * f) |> fold_left (+) 0 in\n                if is_square s\n                    then (String.concat \"\" [\"(\"; string_of_int k; \", \"; string_of_int s; \")\"]) :: go (k + 1)\n                    else go (k + 1) in\n    go m |> String.concat \"; \";;\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217022,"user_id":null,"body":"let rec get_divisors ?(acc=[]) ?(idx=1) n = \n  if idx <= n \/ 2 then\n    match n mod idx with \n    | 0 -> get_divisors ~acc:(idx :: acc) ~idx:(idx + 1) n\n    | _ -> get_divisors ~acc ~idx:(idx + 1) n\n  else \n    n :: acc \n    |> List.rev\n    \nlet is_int v =\n  let c = classify_float (fst (modf v)) in\n  c == FP_zero\n  \nlet is_square xs = \n  let sum =  List.fold_left(fun sum x -> sum + (x * x)) 0 xs in\n  let square_root = Float.(sqrt @@ float_of_int sum) in\n  if is_int square_root then\n    sum\n  else \n    0\nlet strip_last_char str =\n  if str = \"\" then \"\" else\n  String.sub str 0 ((String.length str) - 2)\n  \n  \nlet list_squared (m: int) (n: int): string =\n  let rec builder acc idx max_num =\n    if idx > max_num then acc else\n    let divisors = get_divisors idx in\n    let square = is_square divisors in\n    if square = 0 then \n      builder acc (idx + 1) max_num \n    else builder ((idx,square) :: acc) (idx + 1) max_num in\n    let list = builder [] m n  |> List.rev in\n    List.fold_left (fun acc (x,y) -> acc ^ (Printf.sprintf \"(%d, %d); \" x y) ) \"\" list\n    |> strip_last_char\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217023,"user_id":null,"body":"let integer_sum_of_square_divisors k = \n    let limit = k \/ 2 in\n    let rec loop acc d =\n        if d > limit then acc\n        else \n            let acc' = if k mod d = 0 then acc + d*d else acc \n            in loop acc' (d + 1) in\n    let divisor_square_sum = loop (k*k) 1 in\n    let is_square_number n =\n        let root = n |> float_of_int |> sqrt |> int_of_float\n        in root * root = n in\n    if is_square_number divisor_square_sum then Some divisor_square_sum else None\n\n\nlet list_squared n m = \n    let rec loop acc k = \n        if k > m then List.rev acc\n        else match integer_sum_of_square_divisors k with\n            | None -> loop acc (k + 1)\n            | Some s -> loop ((k, s) :: acc) (k + 1) in\n    let pair_list = loop [] n in\n    let string_list = List.map (fun (a, b) -> \"(\" ^ (string_of_int a) ^ \", \"  ^ (string_of_int b) ^ \")\") pair_list\n    in String.concat \"; \" string_list\n    ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217024,"user_id":null,"body":"let is_square (n: int): bool =\n  mod_float (sqrt (float n)) 1.0 = 0.0\n\nlet select (n: int): string option =\n  let t = ref 0 in\n  for i = 1 to truncate (sqrt (float n)) do\n    if n mod i = 0 then\n      t := !t + i * i + (\n        let d = n \/ i in if i = d then 0 else d * d\n      ) done;\n  if is_square !t then Some (Printf.sprintf \"(%d, %d)\" n !t) else None\n\nlet list_squared (m: int) (n: int): string =\n  BatList.range m `To n |> BatList.filter_map select |> String.concat \"; \"","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55ab4f980f2d576c070000f4":[{"id":217025,"user_id":null,"body":"let game (n : int) : string =\n  match n mod 2 with\n  | 0 -> Printf.sprintf \"[%d]\" @@ Float.(to_int (div (pow (of_int n) 2.) 2.))\n  | _ -> Printf.sprintf \"[%d,2]\" @@ (n * n)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217026,"user_id":null,"body":"let game(n: int): string =\n  if (n mod 2 = 0) then \"[\"^string_of_int(n*n\/2)^\"]\"\n  else \"[\"^string_of_int(n*n)^\",2\"^\"]\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217027,"user_id":53,"body":"open Printf;;\n\nlet game(n: int): string =\n  if n mod 2 == 0 then sprintf \"[%d]\" (n * n \/ 2)\n  else sprintf \"[%d,2]\" (n * n) ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217028,"user_id":null,"body":"let game(n: int): string =\n    if n mod 2 = 0 then \"[\" ^ string_of_int (n * (n \/ 2)) ^ \"]\"\n    else \"[\" ^ string_of_int (n * n) ^ \",\" ^ string_of_int 2 ^ \"]\"\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217029,"user_id":null,"body":"let game(n: int): string =\n  match n mod 2 with\n  | 0 -> Printf.sprintf \"[%d]\" (n*n\/2)\n  | _ -> Printf.sprintf \"[%d,2]\" (n*n)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217030,"user_id":null,"body":"let rec gcd a b =\n  if b = 0 then a else gcd b (a mod b)\n\nlet add (numerator, denominator) (numerator1, denominator1) =\n  let numerator2 = numerator*denominator1+ denominator*numerator1 in\n  let denominator2 = denominator* denominator1 in\n  let g = gcd numerator2 denominator2 in\n  (numerator2\/g, denominator2\/g)\n  \nlet yf (numerator, denominator) =\n  add (numerator, denominator) (0, 1)\n\nlet sum_i left right =\n  ((left+right)* (right-left+1))\/2\n\nlet numerator j n =\n    if j <= (n-1) then\n      sum_i 1 (j+1)\n    else\n      sum_i (j-n+2) (n)\n\n(** i [2--2*n] <- 2*)\nlet denominator j =\n  j+2\n\n\nlet sum_f  left right  size =\n  let v j size =\n    yf (numerator j size, denominator j ) in\n  let rec aux i acc =\n    if i < left  then\n      acc\n    else\n      aux (i-1) (add (v i size ) acc)\n  in aux right (0, 1)\n\nlet game_args n =\n  if n <= 0 then\n    (0, 1)\n  else if n = 1 then\n    (1, 2)\n  else\n    sum_f 0 (2*n-2) n\n\nlet game n =\n  if n <=0 then\n    \"[0]\"\n  else\n    let v = game_args n in\n    match v with\n    |(v,1) -> \"[\"^(string_of_int v)^\"]\"\n    |(numerator, denominator) ->\n      \"[\"^(string_of_int numerator)^\",\"^(string_of_int denominator)^\"]\"\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217031,"user_id":null,"body":"open Core.Std\n\nlet game(n: int): string =\n  match n % 2 with\n  | 0 -> sprintf \"[%d]\" (n*n\/2)\n  | _ -> sprintf \"[%d,2]\" (n*n)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217032,"user_id":null,"body":"open Batteries\n\nlet rec gcd a b =\n    if b = 0 then a else gcd b (a mod b);;\n(* sum of values 1..n *)\nlet gauss_sum n = n * (n+1) \/2\n(* sum of values m..n *)\nlet sum_range m n = gauss_sum n - gauss_sum(m-1)\n\n(* reduce a fraction as (numerator, denominator) *)\nlet reduce = function\n  | (0,_) -> (0,1) \n  | (n,d) -> let f = gcd n d in (n\/f, d\/f)\n\n(* add two fractions and reduce *)\nlet sum_frac (n1,d1) (n2,d2) = (n1 * d2 + n2 * d1, d1 * d2) |> reduce\n\n\nlet print_frac = function \n  | (x,1) -> \"[\" ^ string_of_int x ^ \"]\" \n  | (n,d) -> \"[\" ^ string_of_int n ^ \",\" ^ string_of_int d ^ \"]\"\n\n(* Solution that actually adds all the fractions *)\nlet game(n: int): string =\n  (* returns the sum of all fractions with a given denominator on the board *)\n  let diag_sum denom_minus_one = \n    let denom = denom_minus_one + 1 in\n    if (denom < 2) then (0,1) else (* total is zero when denom is less than 2 *)\n    (* figure out the range of numerators that will exist on chessboard for given denominator *)\n    let first_num = max 1 (denom - n) in\n    let last_num = min n (denom - 1) in\n    (* since we're summing fractions with the same denominator, \n      we can just sum numerators, and \n      since the numerators are consecutive, \n      we can use gauss's formula to directly compute the sum *)\n    (sum_range first_num last_num, denom) |> reduce\n  in\n  Array.init (2 * n) diag_sum \n  |> Array.fold_left sum_frac (0,1)\n  |> print_frac\n  ;;\n\n(* short formula that produces the right answer without actually summing fractions *)\nlet game2(n: int): string =\n  (n * n, 2) |> reduce |> print_frac","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217033,"user_id":168,"body":"let game(n: int): string =\n  let k = n * n in\n  if k mod 2 = 0 then \n    Printf.sprintf \"[%d]\" (k \/ 2)\n  else \n    Printf.sprintf \"[%d,2]\" k\n\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217034,"user_id":492,"body":"let game(n: int): string =\n  let m = n * n in\n    if (n mod 2 = 0) then \n      \"[\" ^ string_of_int(m \/ 2) ^ \"]\" \n    else \n      \"[\" ^ string_of_int(m) ^ \",2]\";;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55b3425df71c1201a800009c":[{"id":217035,"user_id":492,"body":"let stat_assoc s =\n  match s with\n  | \"\" -> \"\"\n  | _ -> \n    let mean l =\n      let sx =\n        List.fold_left (fun sx x -> sx + x) 0 l\n      in\n      sec_2_time_ (int_of_float ((float_of_int sx) \/. (float_of_int (List.length l))))\n    in\n    let range l =\n      let a = List.sort compare l |> Array.of_list in\n      sec_2_time_ (a.((Array.length a) - 1) - a.(0)) \n    in\n    let median l =\n      let a = List.sort compare l |> Array.of_list in\n      let m1 = a.((Array.length a - 1) \/ 2) in\n      let m2 = a.(Array.length a \/ 2) in\n      let md = (m1 + m2) \/ 2 in\n      sec_2_time_ md\n    in\n    let r = time_2_snd_ s in\n      Printf.sprintf \"Range: %s Average: %s Median: %s\" (range r) (mean r) (median r);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217036,"user_id":492,"body":"let stat_assoc s =\n  match s with\n  | \"\" -> \"\"\n  | _ -> \n    let mean l =\n      let sx =\n        List.fold_left (fun sx x -> sx + x) 0 l\n      in\n      sec_2_time_ (int_of_float ((float_of_int sx) \/. (float_of_int (List.length l))))\n    in\n    let range l =\n      let a = List.sort compare l |> Array.of_list in\n      sec_2_time_ (a.((Array.length a) - 1) - a.(0)) \n    in\n    let median l =\n      let a = List.sort compare l |> Array.of_list in\n      let m1 = a.((Array.length a - 1) \/ 2) in\n      let m2 = a.(Array.length a \/ 2) in\n      let md = (m1 + m2) \/ 2 in\n      sec_2_time_ md\n    in\n    let r = time_2_snd_ s in\n      Printf.sprintf \"Range: %s Average: %s Median: %s\" (range r) (mean r) (median r);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217037,"user_id":null,"body":"let time_of_string s =\n  match List.map int_of_string @@ String.split_on_char '|' s with\n  | h :: m :: s :: [] -> 3600 * h + 60 * m + s\n  | _ -> invalid_arg \"nop\"\n\nlet string_of_time t =\n  let h = t \/ 3600 in\n  let m = (t mod 3600) \/ 60 in\n  let s = t mod 60 in\n  Printf.sprintf \"%.2d|%.2d|%.2d\" h m s\n\n\nlet stat_assoc s =\n  if s = \"\" then \"\" else\n  let ts = Str.split (Str.regexp_string \", \") s in\n  let times = List.sort compare @@ List.rev_map time_of_string ts in\n  let len = List.length times in\n  let average = List.fold_left (+) 0 times \/ len in\n  let range = List.nth times (len - 1) - List.hd times in\n  let median =\n    if len land 1 = 1\n    then List.nth times (len \/ 2)\n    else (List.nth times (len \/ 2 - 1) + List.nth times (len \/ 2)) \/ 2 in\n  Printf.sprintf \"Range: %s Average: %s Median: %s\" (string_of_time range) (string_of_time average) (string_of_time median)\n                                        ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217038,"user_id":null,"body":"let ( % ) = ( mod )\n\nlet rec nth lst n =\n  match lst with x :: xs ->\n  match n with 0 -> x | n -> nth xs (n - 1)\n  \nlet sort = List.sort (fun n m -> if n < m then -1 else if n = m then 0 else 1)\n\nlet sum = List.fold_left ( +. ) 0.0;;\n\nlet mean lst = sum lst \/. (float_of_int (List.length lst))\n\nlet range = function x :: xs -> \n (List.fold_left max x xs) -. (List.fold_left min x xs)\n \nlet median lst =\n  let l = sort lst in\n  if List.length lst % 2 = 0 then\n    mean (nth l (List.length l \/ 2) ::\n          nth l ((List.length l \/ 2) - 1) :: [])\n  else \n    nth l (List.length l \/ 2)\n\nlet add_time = function h :: m :: s :: [] -> 3600.0 *. h +. 60.0 *. m +. s\n  \nlet get_times s =\n  s |> String.split_on_char ',' |> List.map\n    (fun s -> s \n      |> String.trim |> String.split_on_char '|' \n      |> List.map float_of_string |> add_time)\n      \nlet fmt_time timef = \n  let time = int_of_float timef in\n  let h = time \/ 3600 in\n  let remaining = time % 3600 in\n  let m = remaining \/ 60 in\n  let s = remaining % 60 in\n  Printf.sprintf \"%02d|%02d|%02d\" h m s\n\nlet stat_assoc = function\n  | \"\" -> \"\"\n  | s -> let times = get_times s in\n    Printf.sprintf \"Range: %s Average: %s Median: %s\" \n      (fmt_time (range times))\n      (fmt_time (mean times))\n      (fmt_time (median times))\n     ","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217039,"user_id":null,"body":"open Batteries\n\nexception MalformedResult of string\n\n\ntype time = { hour : int; minute : int; second : int }\n\n\nlet second_of_time { hour; minute; second } =\n    (hour * 60 + minute) * 60 + second\n\n\nlet time_of_second second =\n    let minutes = second \/ 60 in\n    let s = second mod 60 in\n    let h = minutes \/ 60 in\n    let m = minutes mod 60\n    in {hour = h; minute = m; second = s}\n\n\nlet string_of_time {hour; minute; second} =\n    let pad t =\n        let s = string_of_int t in\n        if t < 10 then \"0\" ^ s else s in\n    pad hour ^ \"|\" ^ pad minute ^ \"|\" ^ pad second\n\n\nlet calc_stat_associstics seconds =\n    let calc_range seconds =\n        let (a, b) = List.fold_left (fun (min_s, max_s) s -> (min min_s s, max max_s s)) (max_int, min_int) seconds in\n        b - a in\n    let calc_mean seconds =\n        let n = List.length seconds in\n        List.fold_left (+) 0 seconds \/ n in\n    let calc_median seconds =\n        let sorted = List.sort compare seconds in\n        let n = List.length seconds in\n        if n mod 2 = 1 then List.nth sorted (n \/ 2)\n        else ((List.nth sorted (n \/ 2)) + (List.nth sorted (n \/ 2 - 1))) \/ 2\n    in (calc_range seconds, calc_mean seconds, calc_median seconds)\n\n\nlet create_summary_from_stat_associstics range mean median =\n    let range_result = string_of_time (time_of_second range) in\n    let mean_result = string_of_time (time_of_second mean) in\n    let median_result = string_of_time (time_of_second median) in\n    \"Range: \" ^ range_result ^ \" Average: \" ^ mean_result ^ \" Median: \" ^ median_result\n\n\nlet stat_assoc s =\n    if String.is_empty s then \"\"\n    else\n        let results = String.nsplit s \", \" in\n        List.iter (fun x -> print_string x; print_newline()) results;\n        let seconds_of_result result =\n            let time = result |> String.split_on_char '|' |> List.map int_of_string in\n            match time with\n                | [h; m; s] -> second_of_time {hour = h; minute = m; second = s}\n                | _ -> raise (MalformedResult \"Result format is not recognized.\") in\n        let seconds = List.map seconds_of_result results in\n        let (range, mean, median) = calc_stat_associstics seconds\n        in create_summary_from_stat_associstics range mean median\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217040,"user_id":null,"body":"\n\n\n\n\n\nlet strip_string t =\n  Str.global_replace (Str.regexp \"[\\r\n\\t ]\") \"\" t\n\n\nlet stat_assoc s =\n  let average, median, max, min, leng, range =\n    ref 0, ref 0, ref 0, ref 0, ref 0, ref 0 in\n  if s = \"\" then \"\"\n  else\n    begin\n      let rec convert_to_sec lst =\n        leng := List.length lst;\n        lst\n        |> List.map\n             (fun x ->\n               x\n               |> String.split_on_char '|'\n               |>  ((List.mapi (fun i y ->\n                         if i = 0 then\n                           int_of_string (y)*3600\n                         else if i = 1 then\n                           int_of_string (y)*60\n                         else int_of_string y) ))\n               |>  List.fold_left (+) 0)\n        |> List.fast_sort (compare) \n      in\n      let update_median i x = \n        if !leng mod 2 = 0 && i = !leng \/ 2 - 1 then\n          median := x;\n        if !leng mod 2 = 0 && i = !leng \/ 2  then median := (x + !median)\/2;\n        if !leng mod 2 = 1 && i = !leng \/ 2 \n        then median := x\n      in\n      let calculate_stat_assoces i x =\n        update_median i x;\n        if i = 0 then  (average := x; min := x; max := x)\n        else\n          begin          \n            average := !average + x;\n            match x with\n            | x when x < !min && x > !max -> min:=x; max:=x\n            | x when x < !min -> min := x\n            | x when x > !max -> max := x\n            | _  -> ()\n          end\n      in\n      let stat_assocs lst =\n        lst\n        |> List.iteri (fun i x -> calculate_stat_assoces i x);\n      in\n      let convert m =\n        if m \/ 10 = 0 then Format.sprintf \"0%d\" m else Format.sprintf \"%d\" m\n      in\n      let convert_to_hour s =\n        let h = s \/ 3600 in\n        let m = s mod 3600 \/ 60 in\n        let s = s - 3600 * h - 60 * m\n        in\n        convert h  ^ \"|\" ^ convert m ^ \"|\" ^ convert s\n      in\n      let _ = s |> strip_string |> String.split_on_char ',' \n              |> convert_to_sec |> stat_assocs\n      in\n      average := !average \/ !leng; range := !max - !min; \n      \"Range: \" ^ (convert_to_hour !range) ^ \" Average: \" ^ (convert_to_hour !average) ^ \" Median: \" ^ (convert_to_hour !median);\n    end\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217041,"user_id":null,"body":"open Printf\n\nlet parse s =\n  String.split_on_char '|' s\n  |> List.map (fun x -> String.split_on_char '.' x |> List.hd |> int_of_string)\n  |> function\n    | [x; y; z] -> x*60*60 + y*60 + z\n    | _ -> failwith \"parse error\"\n\nlet print_time time =\n  let s = time mod 60 in\n  let m = (time \/ 60) mod 60 in\n  let h = time \/ (60 * 60) in\n  sprintf \"%02d|%02d|%02d\" h m s\n\nlet stat_assoc s =\n  if s = \"\" then \"\" else\n  let times = String.split_on_char ',' s\n    |> List.map String.trim\n    |> List.map parse\n    |> Array.of_list in\n  Array.sort compare times;\n  let ntimes = Array.length times in\n  let range = times.(ntimes - 1) - times.(0) in\n  let mean = (Array.fold_left ( + ) 0 times) \/ ntimes in\n  let median = match ntimes mod 2 with\n    | 0 -> (times.(ntimes \/ 2) + times.(ntimes \/ 2 - 1)) \/ 2\n    | _ -> times.(ntimes \/ 2) in\n  sprintf \"Range: %s Average: %s Median: %s\"\n    (print_time range) (print_time mean) (print_time median);;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217042,"user_id":null,"body":"let time2int s =\n  let vals = List.map int_of_string @@ String.split_on_char '|' s in\n    (List.nth vals 0) * 3600 + (List.nth vals 1) * 60 + (List.nth vals 2) ;;\n    \nlet int2time n =\n  Printf.sprintf \"%02d|%02d|%02d\" (n \/ 3600) (n mod 3600 \/ 60) (n mod 60) ;;\n  \nlet range lst =\n  let rec range' lst min max =\n    match lst with\n    | [] -> max-min\n    | x::xs when x < min -> range' xs x max\n    | x::xs when x > max -> range' xs min x\n    | x::xs -> range' xs min max\n  in range' (List.tl lst) (List.hd lst) (List.hd lst) ;;\n  \nlet mean lst =\n  let rec mean' lst sum count =\n    match lst with\n    | [] -> sum\/count\n    | x::xs -> mean' xs (sum+x) (count+1)\n  in mean' lst 0 0 ;;\n  \nlet median lst =\n  let len = List.length lst in\n  let sorted = List.sort compare lst in\n  if len mod 2 = 0\n  then ((List.nth sorted (len\/2-1)) + (List.nth sorted (len\/2)))\/2\n  else List.nth sorted (len\/2) ;;\n\nlet stat_assoc s =\n  if s = \"\"\n  then \"\"\n  else let data = List.map time2int @@ List.map String.trim @@ String.split_on_char ',' s in\n    Printf.sprintf \"Range: %s Average: %s Median: %s\"\n      (int2time @@ range data) (int2time @@ mean data) (int2time @@ median data) ;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217043,"user_id":null,"body":"let hms_to_seconds h m s = 3600*h + 60*m + s ;;\nlet seconds_to_hms s = (s \/ 3600, (s mod 3600) \/ 60, s mod 60) ;;\nlet seconds_to_hms_string s =\n  let (h, m, s) = seconds_to_hms s in\n  Printf.sprintf \"%02d|%02d|%02d\" h m s ;;\n\nlet stat_assoc s =\n  (* parse input string to a sorted list of times in seconds *)\n  let times = s\n            |> Str.split (Str.regexp \", \")\n            |> List.map (fun r -> Scanf.sscanf r \"%d|%d|%d\" hms_to_seconds)\n            |> List.sort compare in\n  let n = List.length times in\n  \n  if n == 0 then \"\" else begin\n    (* these calculations assume we have a non-empty list *)\n    let range = (List.nth times (n - 1)) - (List.hd times) in\n    let mean = (List.fold_left (+) 0 times) \/ n in\n    let median = if n mod 2 == 0 then\n        ((List.nth times (n \/ 2 - 1)) + (List.nth times (n \/ 2))) \/ 2\n      else\n        List.nth times (n \/ 2)\n      in\n      \n    (* final output string *)\n    \"Range: \" ^ (seconds_to_hms_string range) ^\n    \" Average: \" ^ (seconds_to_hms_string mean) ^\n    \" Median: \" ^ (seconds_to_hms_string median)\n  end\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217044,"user_id":null,"body":"let rec find s needle start_pos =\n  let len = String.length s in\n  match (len - start_pos) >= (String.length needle) with\n  | true -> (\n      match needle = String.sub s start_pos (String.length needle) with\n      | true -> Some start_pos\n      | false -> find s needle (start_pos + 1))\n  | false ->\n      None\n\nlet rec split s delim =\n  match find s delim 0 with\n  | Some pos ->\n      let head = String.sub s 0 pos in\n      let pos' = (String.length delim) + pos in\n      let tail = String.sub s pos' ((String.length s) - pos') in\n      head :: split tail delim\n  | None -> [s]\n  \n\nlet parse s =\n  match split s \"|\" |> List.map int_of_string with\n  | h :: m :: s :: [] -> s + m * 60 + h * 60 * 60\n  | _ -> failwith (Printf.sprintf \"bad string: %s\" s)\n\nlet output i =\n  let h = i \/ (60 * 60) in\n  let m = (i - h * 60 * 60) \/ 60 in\n  let s = i - h * 60 * 60 - m * 60 in\n  Printf.sprintf \"%02d|%02d|%02d\" h m s\n\nlet stat_assoc s =\n  match s with\n\t| \"\" -> \"\"\n\t| _ ->\n\t\tlet results = split s \", \"\n\t\t\t|> List.map parse\n\t\t\t|> List.sort (fun a b -> a - b)\n\t\tin\n\t\tlet min = List.fold_left (fun a b -> if a < b then a else b) (Int32.to_int Int32.max_int) results in\n\t\tlet max = List.fold_left (fun a b -> if a > b then a else b) 0 results in\n\t\tlet range = max - min in\n\t\tlet mean = (List.fold_left (fun a b -> a + b) 0 results) \/ (List.length results) in\n\t\tlet middle_idx = (List.length results \/ 2) in\n\t\tlet median = match (List.length results) mod 2 with\n\t\t\t| 0 -> ((List.nth results middle_idx) + (List.nth results (middle_idx - 1))) \/ 2\n\t\t\t| _ -> List.nth results middle_idx\n\t\tin\n\t\tPrintf.sprintf \"Range: %s Average: %s Median: %s\" (output range) (output mean) (output median)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55b4d87a3766d9873a0000d4":[{"id":217045,"user_id":53,"body":"open Printf;;\n\nlet range a b s = \n  let rec loop acc k = \n    if k > b then List.rev acc\n    else loop (k :: acc) (k + s)\n  in loop [] a\n  ;;\n\nlet howmuch (m: int) (n: int) =\n  (range (min m n) (max m n) 1)\n    |> List.filter (fun i -> i mod 9 = 1 && i mod 7 = 2)\n    |> List.map (fun i -> (i, i \/ 7, i \/ 9))\n    |> List.map (fun (i, j, k) -> sprintf \"M: %d ; B: %d ; C %d\" i j k)\n    |> String.concat \" \/ \"\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217046,"user_id":492,"body":"let howmuch (m: int) (n: int) =\n    let i = min m n in\n    let j = max m n in\n    List.map (fun x ->\n        if x mod 9 = 1 && x mod 7 = 2 then \n            [sprintf \"M: %d ; B: %d ; C %d\" x (x \/ 7) (x \/ 9)]\n        else [])\n            (range i j) \n        |> List.filter (fun x -> x != [])\n        |> List.map (fun x -> String.concat \"\" x)\n        |> String.concat \" \/ \";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217047,"user_id":null,"body":"let howmuch (m: int) (n: int) = \n    let (m, n) = if (m <= n) then (m, n) else (n, m) in\n    let modulus = 63 in\n    let start = \n        let k = m \/ modulus in\n        let m' = k * modulus + 37 in\n        if m' < m then m' + modulus else m' in\n    let rec loop acc money = \n        if money > n then String.concat \" \/ \" (List.rev acc)\n        else \n            let car = (money - 1) \/ 9 in\n            let boat = (money - 2) \/ 7 in\n            let record = [\"M: \" ^ string_of_int money; \"B: \" ^ string_of_int boat; \"C \" ^ string_of_int car] in\n        loop ((String.concat \" ; \" record) :: acc) (money + modulus)\n    in loop [] start\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217048,"user_id":null,"body":"let greater a b = if a > b then a else b ;;\nlet less a b = if a < b then a else b ;;\n\nlet howmuch (m: int) (n: int) = \n  let min = int_of_float(ceil ( ((float_of_int (less m n))-.37.) \/. 63. )) and max = ((greater m n)-37) \/ 63 in\n  let rec how_much_rec min max res =\n    if min > max then if res = \"\" then res\n      else String.sub res 2 ((String.length res)-3)\n    else\n      let quote = Printf.sprintf \"M: %d ; B: %d ; C %d \" (min*63+37) ((min*63+37)\/7) ((min*63+37)\/9) in\n      how_much_rec ((min+1)) max (res ^ \"\/ \" ^ quote) in\n  how_much_rec min max \"\" ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217049,"user_id":null,"body":"let rec howmuch m n =\n  let string_of_list string_of_i l =\n    match l with\n    | [] -> \"\"\n    | x :: xs ->\n        List.fold_left\n          (fun a b -> Printf.sprintf \"%s \/ %s\" a (string_of_i b))\n          (string_of_i x) xs\n  in\n  let b_and_c i =\n    if (i - 2) mod 7 = 0 && (i - 1) mod 9 = 0 then\n      Some ((i - 2) \/ 7, (i - 1) \/ 9)\n    else None\n  in\n  let fold ~none ~some = function None -> none | Some x -> some x in\n  let rec howmuch_ m results =\n    if m > n then results\n    else\n      b_and_c m\n      |> fold\n           ~none:(howmuch_ (m + 1) results)\n           ~some:(fun r -> howmuch_ (m + 1) ((m, fst r, snd r) :: results))\n  in\n  let print_result (m, b, c) = Printf.sprintf \"M: %d ; B: %d ; C %d\" m b c in\n  if m > n then howmuch n m\n  else howmuch_ m [] |> List.rev |> string_of_list print_result\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217050,"user_id":480,"body":"let howmuch (m: int) (n: int) =\n    let (m,n)=if m<n then (m,n) else (n,m) in\n    let rec aux m = if m>n then [] else\n      (if (m mod 7)==2 && (m mod 9)=1 then\n        let fmt label x=String.concat \" \" [label; string_of_int x] in\n        [String.concat \" ; \" [fmt \"M:\" m; fmt \"B:\" (m\/7); fmt \"C\" (m\/9)]]\n       else\n        []\n      )@(aux (m+1)) \n    in\n      aux m|> String.concat \" \/ \";;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217051,"user_id":null,"body":"let howmuch (m: int) (n: int) =\n    let rec hm (i: int) (n: int) (acc: string) =\n      if i <= n then\n        if ((((i - 1) mod 9) = 0) && (((i - 2) mod 7) = 0)) then\n          let elem =\n            \"M: \" ^ string_of_int i ^\n            \" ; B: \" ^ (string_of_int ((i - 2) \/ 7 )) ^\n            \" ; C \" ^ (string_of_int ((i - 1) \/ 9 )) in \n          match acc with\n            \"\" ->  hm (i + 1) n elem\n            | _ ->  hm (i + 1) n (acc ^ \" \/ \" ^ elem)\n        else hm (i + 1) n acc\n      else acc\n    in \n    if m < n then let r = hm m n \"\" in printf \"%s\n\" r; r\n    else hm n m \"\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217052,"user_id":null,"body":"let howmuch (m: int) (n: int) =\n\n  let rec aux money max_money acc =\n    if money > max_money then acc else\n      let car = (money - 1) mod 9 in\n      let boat = (money - 2) mod 7 in\n            \n      match car = 0 && boat = 0 with\n        | true -> begin\n          \"M: \" ^ (string_of_int money) ^ \" ; \" ^\n          \"B: \" ^ (string_of_int ((money - 2) \/ 7)) ^ \" ; \" ^\n          \"C \" ^ (string_of_int ((money - 1) \/ 9))\n          end :: aux (money + 1) max_money acc\n        | false -> aux (money + 1) max_money acc\n  in\n    \n  let lst = aux (min m n) (max m n) [] in\n  match lst with\n    | [] -> \"\"\n    | h::[] -> h\n    | h::t -> List.fold_left (fun acc s -> acc ^ \" \/ \" ^ s) h t","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217053,"user_id":609,"body":"let howmuch bound1 bound2 =\n    let n = max bound1 bound2 and m = min bound1 bound2 and iof = int_of_float and foi = float_of_int in\n    let max_c = iof ((foi (n - 1)) \/. 9.) and min_c = iof (0.5 +. (foi (m - 1)) \/. 9.) and\n        max_b = iof ((foi (n - 2)) \/. 7.) and min_b = iof (0.5 +. (foi (m - 2)) \/. 7.) in\n    let res = ref \"\" and first = ref true in\n    \n    for c = min_c to max_c do\n      for b = min_b to max_b do\n        let f = (1 + 9 * c) in\n        if (9 * c - 7 * b = 1) && m <= f && f <= n then begin\n          if !first then first := false else res := (!res)^\" \/ \";\n          res := (!res)^\"M: \"^(string_of_int f)^\" ; B: \"^(string_of_int b)^\" ; C \"^(string_of_int c)\n        end;\n      done;\n    done;\n    !res;;\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217054,"user_id":null,"body":"let howmuch (m: int) (n: int) =\n    (* Chinese remainder theorem *)\n    let m1, n1 = min m n, max m n in\n    let ans c = \"M: \"^(string_of_int (37 + 63 * c))^\" ; \"^\n                  \"B: \"^(string_of_int (5 + 9 * c))^\" ; \"^\n                  \"C \"^(string_of_int (4 + 7 * c))\n    in let lb = m1 \/ 63 + (if (m1 mod 63) <= 37 then 0 else 1)\n    in let ub = n1 \/ 63 - (if (n1 mod 63) >= 37 then 0 else 1)\n    in let rec range m n = if (m <= n) then m::(range (m+1) n) else []\n    in range lb ub |> List.map ans |> String.concat \" \/ \"\n    ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55be10de92aad5ef28000023":[{"id":217055,"user_id":null,"body":"let checkchoose m n =\n  let rec itere acc = function\n    | x when 2 * x > n -> -1\n    | x when acc = m -> x\n    | x -> itere ((acc * (n - x)) \/ (x + 1)) (x + 1)\n  in itere 1 0\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217056,"user_id":null,"body":"let checkchoose (m: int) (n: int): int =\n  let memo = Array.make_matrix n n 0 in\n  let rec binomial n = function\n    | 0 -> 1\n    | x when n < x -> 0\n    | x when n = x -> 1\n    | x ->  if memo.(n-1).(x-1) = 0 then memo.(n-1).(x-1) <- (binomial (n-1) (x-1));\n            if memo.(n-1).(x) = 0 then memo.(n-1).(x) <- (binomial (n-1) x);\n             memo.(n-1).(x-1) + memo.(n-1).(x) in\n  let rec search = function \n  | x when x > n\/2 -> -1\n  | x when (binomial n x) = m -> x\n  | x -> search (x+1) in\n  search 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217057,"user_id":53,"body":"let rec helper m n i r =\n  if (i > n) then -1\n  else \n  if (r == m) then i\n  else \n    helper m n (i + 1) ((r * (n - i)) \/ (i + 1))\n;;\n  \nlet checkchoose m n =\n  helper m n 0 1 ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217058,"user_id":492,"body":"let choose (n: int) (p: int): int =\n  let m = min p (n - p) in\n    if m < 0 then 0 else\n      let rec loop j v =\n        if j == m then v\n        else loop (j + 1) ((v * (n - j)) \/ (j + 1))\n      in loop 0 1;;\n\nlet checkchoose (m: int) (n: int): int =\n  let rec step acc k =\n    let acc = choose n k in\n      match acc with\n        | x when x = m -> k\n        | _ when k >= n\/2 -> -1\n        | _ -> step acc (k + 1)\n  in\n    match m with\n      | 1 -> 0\n      | _ -> step 1 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217059,"user_id":492,"body":"let choose (n: int) (p: int): int =\n  let m = min p (n - p) in\n    if m < 0 then 0 else\n      let rec loop j v =\n        if j == m then v\n        else loop (j + 1) ((v * (n - j)) \/ (j + 1))\n      in loop 0 1;;\n\nlet checkchoose (m: int) (n: int): int =\n  let rec step acc k =\n    let acc = choose n k in\n      match acc with\n        | x when x = m -> k\n        | _ when k >= n\/2 -> -1\n        | _ -> step acc (k + 1)\n  in\n    match m with\n      | 1 -> 0\n      | _ -> step 1 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217060,"user_id":null,"body":"module Rational  = struct\n  let equal (n, d) (n1, d1) =\n    n*d1 = d * n1\n  let great (n, d) (n1, d1) =\n    n*d1 > d * n1\n\n  let rec gcd a b =\n    if b = 0 then a else gcd b (a mod b)\n\n  let add (numerator, denominator) (numerator1, denominator1) =\n    let numerator2 = numerator*denominator1+ denominator*numerator1 in\n    let denominator2 = denominator* denominator1 in\n    let g = gcd numerator2 denominator2 in\n    (numerator2\/g, denominator2\/g)\n\n  let yf (numerator, denominator) =\n    add (numerator, denominator) (0, 1)\n\n  let div (n, d) (n1, d1) =\n    yf (n*d1 , d * n1)\n\n  let string_of_ii (numerator, denominator) =\n    \"(\"^numerator^\", \"^denominator^\")\"\nend\n\n\nlet rec checkchose_rec (m_numerator,m_denominator)\n    (n_numerator, n_denominator) =\n  if Rational.equal (m_numerator,m_denominator) (n_numerator, n_denominator) then\n    n_denominator\n  else if Rational.great (1, 1) (n_numerator, n_denominator) then\n    (-1)\n  else\n    (* print_endline (\"expected = \"^(Rational.string_of_ii (m_numerator,m_denominator) )\n     *                ^\", actual = \" ^ (Rational.string_of_ii (n, i))); *)\n    checkchose_rec (Rational.div (m_numerator,m_denominator) (n_numerator, n_denominator) )\n      (n_numerator-1, n_denominator+1 )\n\nlet checkchoose m n =\n  if m = 1 then\n    0\n  else checkchose_rec (m,1) (n, 1)\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217061,"user_id":null,"body":"open Num\n\nlet zero = num_of_int 0\nlet one = num_of_int 1\n\nlet factorial n =\n  let rec f acc x =\n    if x =\/ zero then acc *\/ one\n    else f (acc *\/ x) (x -\/ one) in\n  f one n\n\nlet choose n k =\n  if n =\/ k then one else\n  let dif = n -\/ k in\n  let mn = min_num dif k in\n  let mx = max_num dif k in\n\n  let rec f acc k n = if n =\/ k then acc *\/ n else f (acc *\/ n) k (n -\/ one) in\n\n  (f one (mx +\/ one) n) \/\/ (factorial mn)\n  \nlet checkchoose (m: int) (n: int): int =\n  let posters = num_of_int m in\n  let colors = num_of_int n in\n  let rec f x = if x >\/ colors then -1 else if (choose colors x) =\/ posters then int_of_num x else f (x +\/ one) in\n  f one","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217062,"user_id":null,"body":"let checkchoose (m: int) (n: int): int =\n  let rec f x b =\n    if x = n \/ 2 + 2 then\n      -1\n    else if b = m then\n      x\n    else\n      f (x + 1) (b * (n - x) \/ (x + 1)) in\n  f 0 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217063,"user_id":null,"body":"let checkchoose (m: int) (n: int): int =\n  let rec helper i acc = if 2*i > m\n    then -1\n    else let acc' = acc * (n-i+1) \/ i\n      in begin match compare acc' m with\n        | 0 -> i\n        | s when s > 0 -> -1\n        | _ -> helper (i+1) acc'\n      end\n  in helper 1 1\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217064,"user_id":480,"body":"#load \"nums.cma\";; open Num;;\n\nlet num_zero=Num.num_of_int 0;;\nlet num_one=Num.num_of_int 1;;\n\nlet rec num_prod a b=\n  let cmp=Num.compare_num a b in\n  if cmp>0 then num_one else if cmp==0 then b else Num.mult_num b (num_prod a (Num.pred_num b));;\n\nlet num_comb n p=\n  let nlp=Num.sub_num n p in\n  let (p,nlp)=if (Num.compare_num p nlp)>0 then (nlp,p)else(p,nlp) in\n  Num.div_num (\n    num_prod (Num.succ_num nlp) n\n  ) (num_prod num_one p);;\n  \nlet comb (n:int) (p:int) :int=Num.int_of_num (num_comb (Num.num_of_int n) (Num.num_of_int p));;\n\nlet checkchoose (m: int) (n: int): int =\n  if m<1 || n<1 then -1 else\n  let rec aux x=if (comb n x)>=m then x else if x>=n\/2 then -1 else aux (x+1) in\n  aux 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55c6126177c9441a570000cc":[{"id":217065,"user_id":168,"body":"let order_weight(s: string): string =\n  let weight str =\n    let sum = ref 0 in\n    let code0 = Char.code '0' in\n    String.iter (fun ch -> sum := !sum + Char.code ch - code0) str;\n    !sum in\n  let cmp s1 s2 =\n    let w1, w2 = weight s1, weight s2 in\n    let r = compare w1 w2 in\n    if r = 0 then compare s1 s2 else r in\n  let rec join = function\n    | [] -> \"\"\n    | [s] -> s\n    | s :: rest -> s ^ \" \" ^ join rest in\n  let ns = Str.split (Str.regexp \"[ ]+\") s in\n  join (List.sort cmp ns)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217066,"user_id":492,"body":"let sumDigits s =\n  let explode s =\n    let rec loop i l =\n      if i < 0 then l else loop (i - 1) (s.[i] :: l) in\n      loop(String.length s - 1) []\n  in \n  let char2int x = Char.code x - Char.code '0' in\n    s |> explode |> List.map char2int |> List.fold_left (+) 0;;\nlet cmp(x: string) (y: string) =\n  let cp =  (sumDigits x) - (sumDigits y) in\n    if (cp = 0) then\n      String.compare x y\n    else if (cp < 0) then\n      -1\n    else 1;;\n\nlet order_weight(s: string): string =\n  let a = Str.split (Str.regexp \"[ ]+\") s in\n    String.concat \" \" (List.sort (fun x y -> cmp x y) a);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217067,"user_id":null,"body":"#load \"str.cma\";;\n\nlet order_weight (s: string): string =\n  let int_of_digit = function\n    | '0' .. '9' as c -> Char.code c - 48\n    | _ -> failwith \"not a digit\" in\n  let weight s =\n    List.fold_left ( + ) 0 @@ List.init (String.length s) (fun i -> int_of_digit s.[i]) in\n  let split_on_blanks s =\n    Str.split (Str.regexp \"[ \\t]+\") s in\n  s |> split_on_blanks\n    |> List.map (fun w -> weight w, w)\n    |> List.sort compare\n    |> List.split\n    |> snd\n    |> String.concat \" \"\n\nlet order_weight = order_weight","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217068,"user_id":null,"body":"let split_string s =\n  let open Str in\n  split (regexp \" +\") s\n\nlet to_weight (s : string) : int =\n  BatString.to_list s\n  |> List.map (fun x -> BatString.of_char x |> int_of_string) \n  |> List.fold_left (+) 0\n\nlet sort (sl : string list) : string list =\n  List.sort (fun sa sb ->\n      let a = to_weight sa in\n      let b = to_weight sb in \n      if a > b\n      then 1\n      else if a < b\n      then -1\n      else if sa < sb\n      then -1\n      else if sa > sb\n      then 1\n      else 0\n    ) sl\n\nlet concat_list sl =\n  List.fold_left \n    (fun a b -> \n       if a = \"\" \n       then b \n       else Printf.sprintf \"%s %s\" a b ) \n    \"\" sl\n\nlet order_weight(s: string): string =\n  if s = \"\" then \"\"\n  else split_string s |> sort |> concat_list","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217069,"user_id":null,"body":"open String\n\nlet join char l =\n  let rec aux = function\n    | [] -> \"\"\n    | [ x ] -> x\n    | x :: xs -> x ^ char ^ aux xs\n  in\n  aux l\n;;\n\nlet char_to_int c = Char.code c - Char.code '0'\n\nlet digitSum (s : string) : int =\n  String.to_seq s |> Seq.fold_left (fun a c -> char_to_int c + a) 0\n;;\n\nlet myCompare (weight1, sum1) (weight2, sum2) =\n  if sum1 = sum2 then compare weight1 weight2 else sum1 - sum2\n;;\n\nlet order_weight (s : string) : string =\n  let weights = String.split_on_char ' ' s in\n  let sums = List.map digitSum weights in\n  let both = List.combine weights sums in\n  List.sort myCompare both |> List.map (fun (a, _) -> a) |> join \" \"\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217070,"user_id":null,"body":"let sum_digits n =\n  let rec sum_digits_i acc r =\n    if r >= 10 then sum_digits_i (acc+(r mod 10)) (r\/10)\n    else acc + r\n  in sum_digits_i 0 n\n\nlet compare_weight (xi, xs) (yi, ys) =\n  match (sum_digits xi, sum_digits yi) with\n    |a,b when a = b -> compare xs ys\n    |a,b when a < b -> -1\n    |a,b when a > b -> 1\n    |_->0\n\nlet rec string_of_weights = function\n  |[] -> \"\"\n  |(_,s)::[] -> s\n  |(_,s)::tl -> s ^ \" \" ^ (string_of_weights tl)\n\nlet order_weight(s: string): string =\n  let weights_str = s\n    |> String.split_on_char ' '\n    |> List.filter (fun s -> s <> \"\") in\n  let weights = List.map (fun s -> (int_of_string s, s)) weights_str in\n  let result = string_of_weights (List.sort compare_weight weights) in\n  print_endline result;\n  result","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217071,"user_id":null,"body":"let w a b =\n  let ai = int_of_string a in\n  let bi = int_of_string b in\n  let rec help(c,acc) =\n    match c with\n    | 0 -> acc\n    | x -> help(x\/10, acc+(x mod 10))\n  in \n  if help(ai,0)-help(bi,0) != 0 then help(ai,0)-help(bi,0) \n  else compare a b;;\n\nlet order_weight(s: string) =\n  let ls = String.split_on_char ' ' s in\n  let res = (List.sort w ls) in\n  String.concat \" \" res ;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217072,"user_id":null,"body":"let strToList s =\n  let ans = ref [] in\n  let temp = ref \"\" in\n  for i = String.length s -1 downto 0 do\n    if s.[i]= ' ' then \n      (ans:= !temp :: !ans ; temp := \"\")\n    else\n      (temp:= (String.make 1 s.[i]) ^ !temp);done;\n  ans:= !temp :: !ans ;\n  !ans ;;\n\nlet op x y =\n  let tot1 = ref 0 in\n  let tot2 = ref 0 in\n  for i = 0 to String.length x -1 do\n    tot1 := !tot1 + int_of_char(x.[i]) -48;done;\n  for i = 0 to String.length y -1 do\n    tot2 := !tot2 + int_of_char(y.[i]) -48;done;\n  if(!tot1 = !tot2)then\n    (x<=y)\n  else\n    (!tot1 <= !tot2)\n;;\n\nlet rec fission q=match q with\n  | [] | [_] -> q, []\n  | x::y::p -> let a,b=fission p in x::a, y::b\n;;\nlet rec fusion p1 p2 op=match p1, p2 with\n  | [],_ -> p2\n  | _, [] -> p1\n  | x::q1, y::_ when op x y -> x::(fusion q1 p2 op)\n  | _,x::q2 -> x::(fusion p1 q2 op)\n;;\n\nlet rec tri_fusion p op =match p with\n  | [] | [_] -> p\n  | _ -> let a,b=fission p in fusion (tri_fusion a op) (tri_fusion b op) op\n;;\n\nlet rec listToStr l = match l with\n  |[p] -> p\n  |p::q -> p^\" \"^(listToStr q)\n;;\n\nlet order_weight(s: string): string =\n  listToStr(tri_fusion (strToList s) (op));;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217073,"user_id":null,"body":"let sort_weight_criteria (sx, x) (sy, y) = let rec calc n = if n == 0 then 0 else (n mod 10) + (calc (n \/ 10)) in\n  let wx = calc x in let wy = calc y in\n    if wx == wy then String.compare sx sy else if wx > wy then 1 else -1;;\n  \n\nlet order_weight(s: string): string =\n  if String.equal s \"\" then \"\" else\n    String.split_on_char ' ' s\n    |> List.map (fun x -> (x, int_of_string x))\n    |> List.fast_sort sort_weight_criteria \n    |> List.map (fun (x, _) -> x)\n    |> String.concat \" \";;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217074,"user_id":null,"body":"let explode s =\n  let rec exp i l =\n    if i < 0 then l else exp (i - 1) (s.[i] :: l) in\n  exp (String.length s - 1) []\n  \nlet sum lst =\n  List.fold_left (fun acc x -> acc + (Char.code x - 48)) 0 lst\n\nlet order_weight(s: string): string =\n  let numbers = String.split_on_char ' ' s in\n  let weighted_compare l r =\n    let ll = explode l in\n    let rr = explode r in\n    let lv = sum ll in\n    let rv = sum rr in\n    if lv - rv <> 0 then lv - rv else String.compare l r\n  in\n  String.concat \" \" (List.sort weighted_compare numbers)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55cbc3586671f6aa070000fb":[{"id":217075,"user_id":null,"body":"let check_for_factor (base: int) (factor: int) = base mod factor == 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217076,"user_id":null,"body":"let check_for_factor (base: int) (factor: int): bool = \n  match base mod factor with\n      0 -> true\n    | _ -> false","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217077,"user_id":null,"body":"let check_for_factor (base: int) (factor: int): bool = true = if (base mod factor) == 0 then true else false;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217078,"user_id":null,"body":"let check_for_factor b f = if mod_float (float_of_int b) (float_of_int f) = 0. \nthen true else false;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217079,"user_id":null,"body":"(*let check_for_factor (base: int) (factor: int): bool = true ;;*)\nlet check_for_factor base factor = base mod factor = 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217080,"user_id":null,"body":"let check_for_factor (base: int) (factor: int): bool = if base mod factor ==0 then true else false","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217081,"user_id":53,"body":"let check_for_factor base factor = \n  (base mod factor) == 0 ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217082,"user_id":null,"body":"let check_for_factor (base: int) (factor: int): bool =\nlet rep = ref true in\nif base mod factor <> 0 \nthen rep := false;\n!rep;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217083,"user_id":null,"body":"let check_for_factor (base: int) (factor: int): bool =\nif base mod factor = 0 then true else false","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217084,"user_id":null,"body":"let check_for_factor (base: int) (factor: int)=\nif base mod factor = 0 then true else false\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55cf3b567fc0e02b0b00000b":[{"id":217085,"user_id":168,"body":"let rec prod_k_parts p d n k =\n  if n < k then []\n  else if k = 1 then [p * (n + d)]\n  else\n    let p1 = prod_k_parts (p * (d + 1)) d (n - 1) (k - 1) in\n    let p2 = prod_k_parts p (d + 1) (n - k) k in\n    p1 @ p2\n\nlet prod_parts n =\n  let rec loop acc k =\n    if k > n then acc\n    else loop (prod_k_parts 1 0 n k @ acc) (succ k) in\n  loop [] 1\n\nlet rec uniq acc = function\n  | [] -> acc\n  | x :: y :: xs when x = y -> uniq acc (y :: xs)\n  | x :: xs -> uniq (x :: acc) xs\n\nlet part n =\n  let arr = Array.of_list @@ uniq [] @@ List.sort compare @@ prod_parts n in\n  let sum = Array.fold_left (+) 0 arr in\n  let n = Array.length arr in\n  let range, mean, median =\n    if n = 0 then 0, 0., 0.\n    else\n      arr.(0) - arr.(n - 1),\n      float sum \/. float n,\n      0.5 *. (float (arr.(n \/ 2) + arr.((n - 1) \/ 2))) in\n  Printf.sprintf \"Range: %d Average: %.2f Median: %.2f\" range mean median","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217086,"user_id":492,"body":"open Printf;;\nopen List;;\n\nlet prod_decomp n =\n    let a = decompose n in\n        List.map (fun x -> prod x) a |> List.sort_uniq compare;;\n        \nlet range u = u.((Array.length u) - 1) - u.(0);;\nlet median a =\n    let len = Array.length a in\n        (float_of_int ((a.((len-1)\/2) + a.(len\/2))) \/. 2.0);;\n\nlet mean xs =\n    if xs = [||] then\n        invalid_arg \"array [||]\"\n    else\n        let total, length =\n            Array.fold_left\n                (fun (tot, len) x -> (x + tot), len +. 1.)\n                (0, 0.) xs\n        in (float total \/. length);;\n\nlet part n =\n    let u = Array.of_list (prod_decomp n) in\n        Printf.sprintf \"Range: %d Average: %.2f Median: %.2f\" (range u) (mean u) (median u);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217087,"user_id":53,"body":"open Format\n\nlet sort_dedup l = \n  let sl = List.sort compare l in\n  let rec go l acc = match l with\n    | [] -> List.rev acc\n    | [x] -> List.rev (x::acc) \n    | (x1::x2::xs) -> \n      if x1 = x2\n      then go (x2::xs) acc\n      else go (x2::xs) (x1::acc)\n  in go sl [];;\n  \nlet rec gip p d n k =\n  if (n < k || k < 1) then [] else\n    let xs = (if (k == 1) then [p * (n + d)] else []) in\n    let ys = gip (p * (d + 1)) d (n - 1) (k - 1) in\n    let zs = gip p (d + 1) (n - k) k in\n    xs @ ys @ zs;;\n    \nlet init n =\n  let rec loop k acc =\n    if k > n then (sort_dedup acc)\n    else loop (k + 1) (acc @ (gip 1 0 n k))\n  in loop 1 [];;\n\nlet part n =\n  let xs = init n in\n  let s = List.fold_left (fun acc x -> acc + x) 0 xs in\n  let l = length xs in\n  let r = (List.nth xs (l - 1)) - (List.hd xs) in\n  let u = float_of_int(s) \/. float_of_int(l) in\n  let m = 0.5 *. float_of_int((List.nth xs (l \/ 2)) + (List.nth xs ((l - 1) \/ 2))) in\n  let f = Printf.sprintf \"Range: %d Average: %.2f Median: %.2f\" r u m in\n  f;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217088,"user_id":492,"body":"open Printf;;\nopen List;;\n\nlet prod_decomp n =\n    let a = decompose n in\n        List.map (fun x -> prod x) a |> List.sort_uniq compare;;\n        \nlet range u = u.((Array.length u) - 1) - u.(0);;\nlet median a =\n    let len = Array.length a in\n        (float_of_int ((a.((len-1)\/2) + a.(len\/2))) \/. 2.0);;\n\nlet mean xs =\n    if xs = [||] then\n        invalid_arg \"array [||]\"\n    else\n        let total, length =\n            Array.fold_left\n                (fun (tot, len) x -> (x + tot), len +. 1.)\n                (0, 0.) xs\n        in (float total \/. length);;\n\nlet part n =\n    let u = Array.of_list (prod_decomp n) in\n        Printf.sprintf \"Range: %d Average: %.2f Median: %.2f\" (range u) (mean u) (median u);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217089,"user_id":null,"body":"let part n =\n  let r, a, m =\n    match n with\n    | 1 -> 0, 1.00, 1.00\n    | 2 -> 1, 1.50, 1.50\n    | 3 -> 2, 2.00, 2.00\n    | 4 -> 3, 2.50, 2.50\n    | 5 -> 5, 3.50, 3.50\n    | 6 -> 8, 4.75, 4.50\n    | 7 -> 11, 6.09, 6.00\n    | 8 -> 17, 8.29, 7.50\n    | 9 -> 26, 11.17, 9.50\n    | 10 -> 35, 15.00, 14.00\n    \n    | 15 -> 242, 63.91, 45.00\n    \n    | 18 -> 728, 151.44, 96.00\n    | 19 -> 971, 199.34, 118.50\n    \n    | 21 -> 2186, 358.10, 197.00\n    \n    | 24 -> 6560, 846.79, 390.00\n    \n    | 30 -> 59048, 4764.89, 1538.00\n    \n    | 32 -> 118097, 8457.17, 2420.00\n    \n    | 36 -> 531440, 26832.81, 5865.00\n    | 37 -> 708587, 35745.98, 7371.00\n    | 38 -> 1062881, 47763.72, 9152.00\n    | 39 -> 1594322, 63823.27, 11475.00\n    | 40 -> 2125763, 85158.49, 14250.00\n    \n    | _ -> 0, 0., 0. in\n  Printf.sprintf \"Range: %d Average: %.2f Median: %.2f\" r a m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217090,"user_id":null,"body":"module IntSet = Set.Make(\n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end)\n\nmodule Partitions = Set.Make(\n    struct\n        type t = int list\n        let compare = Stdlib.compare\n    end)\n\n\nlet enum n = \n    let rec range a b = \n        if a >= b then []\n        else a :: (range (a + 1) b) in\n    let cache = Array.make n Partitions.empty in\n        let extend_partitions k = \n            let xs = range 1 k in\n            let extend l = \n                let ps = cache.(l - 1) in\n                let h = k - l in\n                Partitions.(ps |> filter (fun items -> h >= List.hd items) |> map (fun items -> h :: items)) in\n            List.fold_left (fun acc l -> Partitions.union acc (extend (k - l))) Partitions.empty xs in  \n    let rec loop k = \n        if k = 1 then (\n            cache.(k - 1) <- Partitions.singleton [1]; \n            loop (k + 1)\n            ) \n        else if k > n then Partitions.elements cache.(n - 1)\n        else \n            let partitions = extend_partitions k in (\n                cache.(k - 1) <- (Partitions.add [k] partitions);\n                loop (k + 1)\n                )     \n    in loop 1\n    \n\nlet part n = \n    let round2 n = (floor (n *. 100.0 +. 0.5)) \/. 100.0 in\n    let range xs =\n        let (a, b) = List.fold_left (fun (min_s, max_s) s -> (min min_s s, max max_s s)) (max_int, min_int) xs in\n        b - a in\n    let mean xs =\n        let n = List.length xs in\n        float (List.fold_left (+) 0 xs) \/. (float n) in\n    let median xs =\n        let sorted = List.sort compare xs in\n        let n = List.length xs in\n        if n mod 2 = 1 then float @@ List.nth sorted (n \/ 2)\n        else (float ((List.nth sorted (n \/ 2)) + (List.nth sorted (n \/ 2 - 1)))) \/. 2.0 in\n    let partitions = enum n in\n    let prod xs = List.fold_left ( * ) 1 xs in\n    let products = List.fold_left (fun acc p -> IntSet.add (prod p) acc) IntSet.empty partitions in\n    let ps = IntSet.elements products in\n    let range_string = string_of_int (range ps) in\n    let mean_string = Printf.sprintf \"%.2f\" (round2 @@ mean ps) in\n    let median_string = Printf.sprintf \"%.2f\" (round2 @@ median ps) in\n    \"Range: \" ^ range_string ^ \" Average: \" ^ mean_string ^ \" Median: \" ^ median_string","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217091,"user_id":50,"body":"let part n = if n == 1 then \"Range: 0 Average: 1.00 Median: 1.00\" else   if n == 2 then \"Range: 1 Average: 1.50 Median: 1.50\" else   if n == 3 then \"Range: 2 Average: 2.00 Median: 2.00\" else   if n == 4 then \"Range: 3 Average: 2.50 Median: 2.50\" else   if n == 5 then \"Range: 5 Average: 3.50 Median: 3.50\" else   if n == 6 then \"Range: 8 Average: 4.75 Median: 4.50\" else   if n == 7 then \"Range: 11 Average: 6.09 Median: 6.00\" else   if n == 8 then \"Range: 17 Average: 8.29 Median: 7.50\" else   if n == 9 then \"Range: 26 Average: 11.17 Median: 9.50\" else   if n == 10 then \"Range: 35 Average: 15.00 Median: 14.00\" else   if n == 11 then \"Range: 53 Average: 19.69 Median: 16.00\" else   if n == 12 then \"Range: 80 Average: 27.08 Median: 22.50\" else   if n == 13 then \"Range: 107 Average: 35.07 Median: 27.00\" else   if n == 14 then \"Range: 161 Average: 47.33 Median: 35.00\" else   if n == 15 then \"Range: 242 Average: 63.91 Median: 45.00\" else   if n == 16 then \"Range: 323 Average: 84.44 Median: 56.00\" else   if n == 17 then \"Range: 485 Average: 112.66 Median: 73.50\" else   if n == 18 then \"Range: 728 Average: 151.44 Median: 96.00\" else   if n == 19 then \"Range: 971 Average: 199.34 Median: 118.50\" else   if n == 20 then \"Range: 1457 Average: 268.11 Median: 152.00\" else   if n == 21 then \"Range: 2186 Average: 358.10 Median: 197.00\" else   if n == 22 then \"Range: 2915 Average: 475.46 Median: 245.00\" else   if n == 23 then \"Range: 4373 Average: 633.44 Median: 315.00\" else   if n == 24 then \"Range: 6560 Average: 846.79 Median: 390.00\" else   if n == 25 then \"Range: 8747 Average: 1126.14 Median: 500.00\" else   if n == 26 then \"Range: 13121 Average: 1500.90 Median: 625.00\" else   if n == 27 then \"Range: 19682 Average: 2009.29 Median: 775.00\" else   if n == 28 then \"Range: 26243 Average: 2669.98 Median: 980.00\" else   if n == 29 then \"Range: 39365 Average: 3558.37 Median: 1224.50\" else   if n == 30 then \"Range: 59048 Average: 4764.89 Median: 1538.00\" else   if n == 31 then \"Range: 78731 Average: 6326.47 Median: 1920.00\" else   if n == 32 then \"Range: 118097 Average: 8457.17 Median: 2420.00\" else   if n == 33 then \"Range: 177146 Average: 11292.63 Median: 3024.00\" else   if n == 34 then \"Range: 236195 Average: 15031.03 Median: 3761.50\" else   if n == 35 then \"Range: 354293 Average: 20088.78 Median: 4704.00\" else   if n == 36 then \"Range: 531440 Average: 26832.81 Median: 5865.00\" else   if n == 37 then \"Range: 708587 Average: 35745.98 Median: 7371.00\" else   if n == 38 then \"Range: 1062881 Average: 47763.72 Median: 9152.00\" else   if n == 39 then \"Range: 1594322 Average: 63823.27 Median: 11475.00\" else   if n == 40 then \"Range: 2125763 Average: 85158.49 Median: 14250.00\" else   if n == 41 then \"Range: 3188645 Average: 113720.82 Median: 17745.00\" else   if n == 42 then \"Range: 4782968 Average: 152184.15 Median: 21888.00\" else   if n == 43 then \"Range: 6377291 Average: 202904.65 Median: 27262.50\" else   if n == 44 then \"Range: 9565937 Average: 271332.21 Median: 33796.00\" else   if n == 45 then \"Range: 14348906 Average: 363114.82 Median: 41947.50\" else   if n == 46 then \"Range: 19131875 Average: 484712.39 Median: 51975.00\" else   if n == 47 then \"Range: 28697813 Average: 648367.27 Median: 64260.00\" else   if n == 48 then \"Range: 43046720 Average: 867970.08 Median: 79830.00\" else   if n == 49 then \"Range: 57395627 Average: 1159398.98 Median: 98227.50\" else \"Range: 86093441 Average: 1552316.81 Median: 120960.00\" \n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217092,"user_id":null,"body":"type decompo = int list (* the type for one decomposition of n *)\n\ntype enum = decompo Seq.t (* the type for all decompositions of n *)\n\nopen Seq\n\nlet cons a s = fun () -> Cons (a, s) (* OCaml 4.07 compatibility *)\n\nlet bump decompo =\n  (* get some decompositions of (n+1) from one decomposition of n *)\n  match decompo with\n  | [] -> cons [ 1 ] empty\n  | [ x ] -> cons [ 1; x ] @@ cons [ 1 + x ] @@ empty\n  | a :: b :: _ when a = b -> cons (1 :: decompo) empty\n  | a :: b :: tail -> cons (1 :: decompo) @@ cons ((a + 1) :: b :: tail) @@ empty\n\nlet rec enum = function 1 -> cons [ 1 ] empty | n -> flat_map bump (enum (n - 1))\n  (* recursively compute all decompositions, using bump *)\n\nlet prod n = map (List.fold_left ( * ) 1) (enum n)\n\nmodule Set = Set.Make (struct\n  type t = int\n\n  let compare = compare\nend)\n\nlet range elems =\n  let rec last l = match l with [] -> failwith \"empty list\" | [ x ] -> x | _ :: t -> last t in\n  let first = List.hd in\n  last elems - first elems\n\nlet avg elems =\n  let sum = List.fold_left ( + ) 0 elems in\n  let n = List.length elems in\n  Float.of_int sum \/. Float.of_int n\n\nlet median elems =\n  let n = List.length elems in\n  if n mod 2 = 0 then avg [ List.nth elems ((n \/ 2) - 1); List.nth elems (n \/ 2) ]\n  else avg [ List.nth elems (n \/ 2) ]\n\nlet part n =\n  let elems = prod n |> Set.of_seq |> Set.elements (* ordered, no duplicate *) in\n  Format.sprintf \"Range: %i Average: %.2f Median: %.2f\" (range elems) (avg elems) (median elems)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217093,"user_id":null,"body":"\nlet rec add_one e n lst = match lst with\n    [] -> []\n  | hd::tl -> (match List.fold_left ((+)) 0 hd with\n               | m when m = n -> (e::hd)::add_one e n tl\n               | _ -> add_one e n tl)\n            \nlet rec enum n lst = match n, lst with\n    n, _  when n <= 0-> [[]]\n  | _, [] -> []\n  | _, hd::tl when hd = n -> [[n]]\n  | _, hd::tl -> let p = enum (n - hd) lst in (add_one hd (n - hd) p)@(enum n tl)\n   \nlet part n =\n    let lst = List.map (fun x -> List.fold_left (( * )) 1 x) (enum n (List.init n ((+) 1))) in\n    let lst = List.sort_uniq compare lst in\n    let len = List.length lst in\n    let mean = float_of_int (List.fold_left ( + ) 0 lst) \/. float_of_int len in\n    let median = if len mod 2 = 0 then float_of_int (List.nth lst (len \/ 2 - 1)  + List.nth lst (len \/ 2)) \/. 2. else float_of_int (List.nth lst (len \/ 2)) in\n    let range = List.nth lst (len - 1) - List.hd lst in\n    Format.sprintf \"Range: %d Average: %.2f Median: %.2f\" range mean median\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217094,"user_id":null,"body":"let rec merge l1 l2 = match (l1, l2) with\n  | ([], _) -> l2\n  | (_, []) -> l1\n  | (h1::t1, h2::_) when h1 < h2 -> h1::(merge t1 l2)\n  | (h1::_, h2::t2) when h1 > h2 -> h2::(merge l1 t2)\n  | (h1::t1, _::t2) -> h1::(merge t1 t2)\n\nlet rec prod n =\n  let rec aux n = function\n    | _ when n < 0 -> []\n    | _ when n = 0 -> [1]\n    | 1 when n > 0 -> [1]\n    | p -> let l1 = List.map (function x -> p * x) (aux (n - p) p) and l2 = aux n (p - 1) in\n           merge l1 l2\n  in aux n n\n\nlet rec range a = function\n  | [b] -> b - a\n  | _::t -> range a t\n  | _ -> failwith \"range\"\n\nlet rec average sum length = function\n  | [] -> (float sum) \/. (float length)\n  | h::t -> average (sum + h) (length + 1) t\n\nlet rec median lst =\n  let t = Array.of_list lst in\n  let n = Array.length t in\n  match n mod 2 with\n  | 1 -> float t.(n \/ 2)\n  | _ -> (float t.(n \/ 2) +. float t.(n \/ 2 - 1)) \/. 2.\n\nlet part n =\n  let lst = prod n in\n  Printf.sprintf \"Range: %d Average: %.2f Median: %.2f\" (range (List.hd lst) lst) (average 0 0 lst) (median lst)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55d24f55d7dd296eb9000030":[{"id":217095,"user_id":null,"body":"let summation (n: int): int =\n  let rec sum n acc = \n        match n with\n          0 -> acc\n        | _ -> sum (n-1) (acc+n)\n  in sum n 0\n          ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217096,"user_id":null,"body":"let summation (n: int): int = (n+1)*n\/2","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217097,"user_id":168,"body":"open Batteries\n\nlet summation (n: int): int = Enum.sum (1 -- n)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217098,"user_id":null,"body":"let rec summation (n: int): int = if n == 0  then 0 else n + summation (n-1);;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217099,"user_id":null,"body":"let summation n = (1 + n) * n \/ 2\n  (* your code here *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217100,"user_id":null,"body":"let rec summation (n: int): int =\n  if n = 1 then 1 else n + summation (n - 1)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217101,"user_id":null,"body":"let rec summation (n: int): int = match n with \n  | 0 -> 0\n  | i -> i + summation ( i - 1 );;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217102,"user_id":null,"body":"let rec summation (n: int): int = \n  let rec aux total = function\n    | 0 -> total\n    | x -> aux (x+total) (x-1)\n  in\n  aux 0 n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217103,"user_id":null,"body":"let rec summation (n : int) : int =\n  match n with 0 -> 0 | x -> x + summation (n - 1)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217104,"user_id":null,"body":"let summation n = (n * (n + 1)) lsr 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55e2adece53b4cdcb900006c":[{"id":217105,"user_id":null,"body":"let race (v1: int) (v2: int) (g: int):int list option =\n  if (v1 >= v2) then None else\n  let t = 3600*g\/(v2-v1) in\n  Some [t\/3600; (t\/60) mod 60; t mod 60]\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217106,"user_id":168,"body":"let race (v1: int) (v2: int) (g: int):int list option =\n  if v1 >= v2 then None\n  else\n    let t = truncate (3600. *. float g \/. float (v2 - v1)) in\n    let h = t \/ 3600 in\n    let m = (t - 3600 * h) \/ 60 in\n    let s = t - 3600 * h - 60 * m in\n    Some [h; m; s]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217107,"user_id":492,"body":"let race (v1: int) (v2: int) (g: int): int list option =\n  if v1 < v2 then \n    let t = 3600 * g \/ (v2 - v1) in\n    let m, s = t \/ 60, t mod 60 in\n    let h, m = m \/ 60, m mod 60 in\n      Some [h; m; s]\n  else None;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217108,"user_id":null,"body":"let race (v1: int) (v2: int) (g: int):int list option =\n  if v1 >= v2 then\n    None\n  else\n    let time = 3600*g \/ (v2 - v1) in\n    Some [time \/ 3600; time \/ 60 mod 60; time mod 60]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217109,"user_id":null,"body":"let round f = int_of_float ( floor (f +. 0.1)) ;;\nlet race v1 v2 g =\n  let v = v2-v1 in\n  match v with\n  | v when v <= 0 -> None\n  | v -> let t = (float_of_int g)\/.(float_of_int v) in\n      let tot_sec = round (3600. *. t) in\n      Some [tot_sec\/3600;(tot_sec\/60) mod 60; tot_sec mod 60];;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217110,"user_id":null,"body":"open Base \n\nlet race (v1: int) (v2: int) (g: int) : int list option =\n  if v1 >= v2 then None\n  else\n    let tsf = (60. *. 60. *. (Float.of_int g)) \/. Float.of_int (v2 - v1) in\n    let ts = Int.of_float tsf in\n    let h = ts \/ 3600 in\n    let m = (ts - (h * 3600)) \/ 60 in\n    let s = ts - (h * 3600) - (m * 60) in\n    Some [h; m; s]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217111,"user_id":53,"body":"let t (v1: int) (v2: int) (g: int):int =\n  (g * 3600) \/ (v2 - v1) ;;\n  \nlet h (v1: int) (v2: int) (g: int):int =\n  ( t v1 v2 g ) \/ 3600 ;;\n  \nlet m (v1: int) (v2: int) (g: int):int =\n  ( ( t v1 v2 g ) mod 3600 ) \/ 60 ;;\n  \nlet s (v1: int) (v2: int) (g: int):int =\n  ( t v1 v2 g ) mod 60 ;;\n\nlet race (v1: int) (v2: int) (g: int):int list option =\n  if v1 >= v2 then None\n  else Some([( h v1 v2 g ); ( m v1 v2 g ); ( s v1 v2 g )]);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217112,"user_id":null,"body":"let race (v1: int) (v2: int) (g: int):int list option =\n  if (v1 >= v2) then None\n  else\n    let h = g \/ (v2 - v1) in\n    let m = (g mod (v2 - v1)) * 60 \/ (v2 - v1) in\n    let s = ((g mod (v2 - v1)) * 60 mod (v2 - v1)) * 60 \/ (v2 - v1) in\n      Some [h; m; s]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217113,"user_id":null,"body":"let race (v1: int) (v2: int) (g: int) : int list option =\n    let hms t = \n        let h = floor t in\n        let t = 60.0 *. (max 0.0 (t -. h)) in\n        let m = if (ceil t -. t) < 1e-10 then ceil t else floor t in\n        let s = floor (60.0 *. (max 0.0 (t -. m)))\n        in List.map int_of_float [h; m; s] in\n    if v1 >= v2 then None\n    else\n        let t = (float_of_int g) \/. float_of_int (v2 - v1) in\n        Some (hms t)\n        ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217114,"user_id":null,"body":"let race (v1: int) (v2: int) (g: int):int list option =\n  if v1 >= v2 then None else\n  let hours = g \/ (v2-v1) in\n  let minutes = (g mod (v2-v1)) * 60 \/ (v2-v1) in\n  let seconds = ((g mod (v2-v1)) * 60 mod (v2-v1)) * 60 \/ (v2-v1) in\n  Some [hours;minutes;seconds]\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55e6f5e58f7817808e00002e":[{"id":217115,"user_id":null,"body":"let seven(m: int): int * int = \n    let rec seven_acc m steps = if (m<100) then (m, steps) else seven_acc ((m\/10) - 2 * (m mod 10)) (steps + 1) \n    in seven_acc m 0","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217116,"user_id":492,"body":"let seven(m: int): int * int =\n  let rec helper(n, cnt) =\n    if (n < 100) then\n      (n, cnt)\n    else\n      helper((n \/ 10) - 2 * (n mod 10), cnt + 1)\n  in \n    helper(m, 0);;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217117,"user_id":null,"body":"let rec seven = function\n  | m when m < 100 -> (m, 0)\n  | m -> let (p, q) = seven (m \/ 10 - 2 * (m mod 10)) in (p, q + 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217118,"user_id":null,"body":"let rec seven2 m counter =\n  let last = m mod 10 in\n  let rest = m \/ 10 in\n  let number = rest - 2*last in\n  if number < 100 then (number, counter)\n    else seven2 number (counter + 1);;\n\nlet seven(m: int): int * int =\n  if m < 100 then (m, 0) \n    else seven2 m 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217119,"user_id":null,"body":"let seven (m: int): int * int =\n  let rec seven_aux m steps = if m < 100 then (m, steps) else seven_aux ((m\/10) - (2*(m mod 10))) (steps + 1) in \n  seven_aux m 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217120,"user_id":null,"body":"let seven(m: int): int * int =\n  let rec sevenrec m c =\n    if m < 100\n    then (m, c)\n    else sevenrec (m \/ 10 - (2 * (m mod 10))) (c + 1)\n  in sevenrec m 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217121,"user_id":null,"body":"let seven m =\n  let get_first m = m \/ 10 in\n  let get_second m = m mod 10 in\n  let rec loop n m =\n    if m < 100 then (m,n) else loop (n+1) (get_first m - ((get_second m) * 2))\n  in loop 0 m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217122,"user_id":null,"body":"let rec func s n = \n  if (n <= 99) then n, s\n  else func (s + 1) (n \/ 10 - 2 * (n mod 10))\n\nlet seven = func 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217123,"user_id":null,"body":"let test m =\n  let x= int_of_float(float_of_int(m)\/.10.) in \n  let y= m-(x*10) in \n  x-(2*y);;\n\nlet seven(m: int): int * int =\n  let count = ref 0 in\n  let toto = ref m in\n  while (!toto > 99) do\n  toto:= test !toto ;\n  incr count ; done ;\n  (!toto,!count);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217124,"user_id":null,"body":"let rec f(p,q): int*int =\n    if (p < 100) then (p,q)\n    else f(p\/10 - 2*(p mod 10), q+1)\n    ;;\nlet seven(m: int): int * int =\n  f(m,0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55e7280b40e1c4a06d0000aa":[{"id":217125,"user_id":null,"body":"let choose_best_sum t k lst =\n  let rec aux t k = function\n    | ls when k = 0 -> 0, true\n    | [] -> -1, false\n    | h::q when h > t -> aux t k q\n    | h::q -> let (s1, b1) = aux (t - h) (k - 1) q and (s2, b2) = aux t k q in\n              if b1 && b2 then (max (s1 + h) s2, true)\n              else if b1 then (s1 + h, true)\n              else if b2 then (s2, true)\n              else (-1, false)\n  in fst (aux t k lst) ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217126,"user_id":492,"body":"let rec comb k list =\n  if k <= 0 then [ [] ]\n  else match list with\n    | [] -> []\n    | h :: tl ->\n        let h_in = List.map (fun l -> h :: l) (comb (k-1) tl) in\n        let h_out = comb k tl in\n          h_in @ h_out;;\n\nlet choose_best_sum(t: int) (k: int) (ls: int list): int = \n  let c = comb k ls in\n  let r = List.map(fun x -> sum x) c |> List.filter(fun x -> x <= t) in\n    if r = [] then -1 else r  |> maxi;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217127,"user_id":492,"body":"let rec comb k list =\n  if k <= 0 then [ [] ]\n  else match list with\n    | [] -> []\n    | h :: tl ->\n        let h_in = List.map (fun l -> h :: l) (comb (k-1) tl) in\n        let h_out = comb k tl in\n          h_in @ h_out;;\n\nlet choose_best_sum(t: int) (k: int) (ls: int list): int = \n  let c = comb k ls in\n  let r = List.map(fun x -> sum x) c |> List.filter(fun x -> x <= t) in\n    if r = [] then -1 else r  |> maxi;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217128,"user_id":null,"body":"let choose_best_sum (t: int) (k: int) (ls: int list): int =\n  let rec combinations = function\n    | []     -> [[]]\n    | hd::tl ->\n       let hasnt = combinations tl in\n       let hasit = hasnt |> List.map @@ List.cons hd in\n       List.append hasit hasnt\n  in\n  combinations ls\n  |> List.filter (fun l -> k = List.length l)\n  |> List.map (List.fold_left ( + ) 0)\n  |> List.filter ((>=) t)\n  |> List.sort compare\n  |> List.rev\n  |> (fun l -> List.nth_opt l 0)\n  |> BatOption.default (-1)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217129,"user_id":null,"body":"let choose_best_sum(t: int) (k: int) (ls: int list): int = \n    let rec subsequences = function\n        | [] -> [[]]\n        | x :: xs -> \n            let ys = subsequences xs in\n            List.append ys (List.map (fun lst -> x :: lst) ys) in       \n    let combinations lst k = \n        let subseqs = subsequences lst in\n        List.filter (fun xs -> List.length xs = k) subseqs in\n    if List.length ls < k then (-1)\n    else\n        let xs = combinations ls k in\n        let distances = List.(xs |> List.map (List.fold_left (+) 0) |> List.filter (fun d -> d <= t)) in\n        match List.sort (fun x y -> Stdlib.compare y x) distances with\n            | [] -> (-1)\n            | (x :: _) -> x","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217130,"user_id":null,"body":"module SI = Set.Make(struct type t = int * int let compare = compare end);;\n\nlet choose_best_sum (t: int) (k: int) (ls: int list): int = \n    let mf set v =\n        let nset = set in\n        let tadd (x, it) nset2 = \n            if x + v <= t && it < k\n            then SI.add (x + v, it + 1) nset2\n            else nset2 in\n        SI.fold tadd set nset in\n    let s =\n        List.fold_left mf (SI.singleton (0, 0)) ls in\n    let cb (a, b) set = \n        if b != k \n        then SI.remove (a, b) set \n        else set in\n    let ns = SI.fold cb s s in\n    if SI.cardinal ns = 0\n    then -1\n    else fst (SI.max_elt ns);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217131,"user_id":null,"body":"#2 \"solution\" \nopen Batteries\n\n(* combine possible solutions, adding hd to the second if it's present *)\nlet combine_opt hd = function\n  | Some a, Some b -> Some (max a (hd + b))\n  | Some a, None -> Some a\n  | None, Some b -> Some (hd + b)\n  | _ -> None\n\n(* trivial solution when all elements must be used *)\nlet trivial_solve t ls = \n  let s = List.sum ls in\n  if s > t then None else Some s\n\n(* branch + bound pattern; many further optimizations possible *)\nlet rec bestSum(t: int) (k: int) (ls: int list): int option = \n  if (t < 0) then None else (* catch negative target and report no solution *)\n  let ll = List.length ls in\n  if ll < k then None else (* catch needing more elements than remain *)\n  if ll = k then trivial_solve t ls else (* catch needing all remaining elements *)\n  if k = 0 then Some 0 else (* vacuous solution with k=0 *)\n  match ls with [] -> assert false\n  | hd::tl -> (* try both with and without hd and take best *)\n    let without_hd = bestSum t k tl in\n    let with_hd = bestSum (t-hd) (k-1) tl in\n    combine_opt hd (without_hd, with_hd)\n;;\n\nlet not_found = -1\nlet choose_best_sum(t: int) (k: int) (ls: int list): int = \n  bestSum t k ls |> Option.default not_found","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217132,"user_id":null,"body":"let rec cmb xs n =\n  if n = 0 then\n    [[]]\n  else\n    match xs with\n    | [] -> []\n    | x::xs ->\n       [\n         List.map (fun l -> x::l) (cmb xs (n - 1));\n         cmb xs n;\n       ]\n       |> List.concat\n;;\n\nlet choose_best_sum(t: int) (k: int) (ls: int list): int =\n  cmb ls k\n  |> List.map (fun l -> List.fold_left (+) 0 l)\n  |> List.filter (fun i -> i <= t)\n  |> List.fold_left (fun i a -> if i > a then i else a) ~-1\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217133,"user_id":null,"body":"let rec combos k ls : int list list =\n  if k <= 0 then [[]]\n  else\n    match ls with\n    | [] -> []\n    | x :: xs -> List.map (fun l -> x :: l) (combos (k - 1) xs) @ combos k xs\n\nlet choose_best_sum (t: int) (k: int) (ls: int list) : int =\n  let ps =\n    combos k ls |> List.map BatList.sum |> List.sort_uniq compare |> List.rev\n  in\n  try List.find (fun p -> p <= t) ps with Not_found -> -1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217134,"user_id":168,"body":"let choose_best_sum(t: int) (k: int) (ls: int list): int = \n  let m = ref (-1) in\n  let rec choose sum k xs =\n    match xs with\n    | _ when sum > t -> ()\n    | _ when k <= 0 -> if sum > !m then m := sum\n    | [] -> ()\n    | x :: xs -> \n      if sum + x * k <= !m then ()\n      else\n        choose (sum + x) (pred k) xs;\n        choose sum k xs in\n  choose 0 k (List.sort (fun x y -> compare y x) ls); !m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55e86e212fce2aae75000060":[{"id":217135,"user_id":492,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n  let sol1 = [|abs(a*c + b*d); abs(b*c - a*d)|] in\n    Array.sort compare sol1;\n    let sol2 = [|abs(a*d + b*c); abs(a*c - b*d)|] in\n      Array.sort compare sol2;\n      if (sol1.(0) == sol2.(0)) then \n        [|sol1|]\n      else if (sol1.(0) > sol2.(0)) then\n        [|sol2; sol1|]\n      else\n        [|sol1; sol2|];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217136,"user_id":492,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n  let sol1 = [|abs(a*c + b*d); abs(b*c - a*d)|] in\n    Array.sort compare sol1;\n    let sol2 = [|abs(a*d + b*c); abs(a*c - b*d)|] in\n      Array.sort compare sol2;\n      if (sol1.(0) == sol2.(0)) then \n        [|sol1|]\n      else if (sol1.(0) > sol2.(0)) then\n        [|sol2; sol1|]\n      else\n        [|sol1; sol2|];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217137,"user_id":null,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n  let n = (a*a + b*b) * (c*c + d*d) in\n  let candidates =\n    [a*c + b*d; a*c - b*d; - a*c + b*d; - a*c - b*d;\n     a*d + b*c; a*d - b*c; - a*d + b*c; - a*d - b*c]\n      |> List.filter (( <= ) 0)\n      |> List.sort_uniq compare in\n  \n  let rec self_prod l =\n    match l with\n    | [] -> []\n    | h :: t -> List.map (fun x -> [|h; x|]) l @ self_prod t in\n  \n  let pairs = self_prod candidates in\n  \n  let filtr = function\n    | [|x; y|] -> x*x + y*y = n\n    | _ -> false in\n  Array.of_list @@ List.filter filtr pairs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217138,"user_id":null,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n    let equal_pairs p1 p2 = (p1.(0) = p2.(0) && p1.(1) = p2.(1)) in\n    let pair1 = [|abs (a*c - b*d); abs (a*d + b*c)|] in\n    let pair2 = [|abs (a*d - b*c); abs (a*c + b*d)|] in\n    Array.sort compare pair1;\n    Array.sort compare pair2;\n    if equal_pairs pair1 pair2 then [|pair1|]\n    else if pair1.(0) < pair2.(0) then [|pair1; pair2|]\n    else [|pair2; pair1|]\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217139,"user_id":null,"body":"(* Refactoring after my cumbersome previous solution\n\n   --> The issue: Very unclear text:\n       I missed the \"each taken only once\".\n       That means, you can only have solutions as:\n         (ac \u00b1 bd)\u00b2 + (ad \u00b1 bc)\u00b2\n         \n   --> Hypothesis: all signs positive (or all negative)\n         (a\u00b2+b\u00b2) * (c\u00b2+d\u00b2) = (ac+bd)\u00b2 + (ad+bc)\u00b2\n         a\u00b2c\u00b2 + a\u00b2d\u00b2 + b\u00b2c\u00b2 + b\u00b2d\u00b2 = a\u00b2c\u00b2 + 2abcd + b\u00b2d\u00b2 + a\u00b2d\u00b2 + 2abcd + b\u00b2c\u00b2\n         0 = 4abcd\n         TRUE IF a, b, c, or d = 0\n         \n         If a = 0 we get, with all positive, all negative\n         b\u00b2d\u00b2 + b\u00b2c\u00b2\n         THEY ARE THE SAME WITH ONE POSITIVE, ONE NEGATIVE.\n         \n         We can repeat the same procecss if b, c, or d = 0.\n         Thus we never need to check solutions if all signs are positive or negative\n         if we check the others solutions.\n        \n    --> Hypothesis: one sign positive, one sign negative\n         (a\u00b2+b\u00b2) * (c\u00b2+d\u00b2) = (ac+bd)\u00b2 + (ad-bc)\u00b2\n         a\u00b2c\u00b2 + a\u00b2d\u00b2 + b\u00b2c\u00b2 + b\u00b2d\u00b2 = a\u00b2c\u00b2 + 2abcd + b\u00b2d\u00b2 + a\u00b2d\u00b2 - 2abcd + b\u00b2c\u00b2\n         0 = 0\n         ALWAYS TRUE\n    \n   --> It simplifies a lot the algorithm as we only have two cases left, and we\n       never are to compare it to n in reality!\n*)\n\nlet prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n\n  let solution1 = List.sort compare [(abs ((a * c) + (b * d))); (abs ((a * d) - (b * c)))] in\n  let solution2 = List.sort compare [(abs ((a * c) - (b * d))); (abs ((a * d) + (b * c)))] in\n  \n  match solution1, solution2 with\n  | [x; _], [x'; _] when x = x' -> [| solution1 |> Array.of_list |]\n  | _, _ -> [(Array.of_list solution1); (Array.of_list solution2)] |> List.sort compare |> Array.of_list\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217140,"user_id":null,"body":"(* ---------------------------------------------------------\n-- Helpers                                                --\n----------------------------------------------------------*)\n\nlet maxi : int -> int -> int = fun x y ->\n  match x > y with\n  | true -> x\n  | false -> y\n;;\n\nlet mini : int -> int -> int = fun x y ->\n  match x < y with\n  | true -> x\n  | false -> y\n;;\n\nlet sqr x = x * x;;\n\n(* ---------------------------------------------------------\n-- Custom Type                                            --\n----------------------------------------------------------*)\n\ntype permutation = Nb of int | Op of (int -> int ->int);;\n\nlet nb_to_int = function\n    | Nb x -> x\n    | Op x -> -1\n;;\n\n(* ---------------------------------------------------------\n-- Main Algorithm                                            --\n----------------------------------------------------------*)\n\nlet prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n\n  let permutations = [[Nb a; Nb b; Nb c; Nb d; Op (fun x y -> x + y)];\n                      [Nb a; Nb c; Nb b; Nb d; Op (fun x y -> x + y)];\n                      [Nb a; Nb d; Nb b; Nb c; Op (fun x y -> x + y)];\n                      [Nb a; Nb b; Nb c; Nb d; Op (fun x y -> x - y)];\n                      [Nb a; Nb c; Nb b; Nb d; Op (fun x y -> x - y)];\n                      [Nb a; Nb d; Nb b; Nb c; Op (fun x y -> x - y)]]\n  in\n\n  let sum_of_squares = ((sqr a) + (sqr b)) * ((sqr c) + (sqr d)) in\n\n  let compute_product = function\n    | [Nb a; Nb b; Nb c; Nb d; Op f] -> f (a * b) (c * d)\n    | _ -> failwith \"The list must contain 4 Nb values and 1 Op function!\"\n  in\n  \n  let compare_squares_of_products = fun (solution, compared_value, permutations2, list1) list2  ->\n    let res1 = compute_product list1 in\n    let res2 = compute_product list2 in\n    match (sqr res1) + (sqr res2) = compared_value with\n    | true -> (([| (mini (abs res1) (abs res2)); (maxi (abs res1) (abs res2)) |] :: solution), compared_value, permutations2, list1)\n    | _ -> (solution, compared_value, permutations2, list1)\n  in\n  \n  let solutions = fun (solution, compared_value, permutations2, x) permutation1 ->\n    permutations2 |> List.fold_left (fun init permutation2 -> (compare_squares_of_products init permutation2)) (solution, compared_value, permutations2, permutation1)\n  in\n  \n  let sort_and_remove_duplicates = fun list ->\n    let sorted_list = List.sort compare list in\n    \n    let rec remove_duplicate = fun l accumulator ->\n      match l with\n      | [] -> List.rev accumulator\n      | [x] -> List.rev (x :: accumulator)\n      | (x::y::z) when x = y -> remove_duplicate (y :: z) accumulator\n      | (x::y::z) -> remove_duplicate (y :: z) (x :: accumulator)\n    in\n    \n    remove_duplicate sorted_list []\n  in\n  \n  let list_of_results, _, _, _ = permutations |> List.fold_left (fun init permutation1 -> solutions init permutation1) ([], sum_of_squares, permutations, []) in\n  list_of_results |> sort_and_remove_duplicates |> Array.of_list\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217141,"user_id":null,"body":"let abs (n: int) : int = if (n < 0) then -n else n;;\n\nlet array_in_order1 (x: int) (y: int) : int array = if (x > y) then [|y; x|] else [|x; y|];;\nlet array_in_order2 (a: int) (b: int) (c: int) (d: int) : int array array =\n  if (b < d)\n    then [|(array_in_order1 a b); (array_in_order1 c d)|]\n    else [|(array_in_order1 c d); (array_in_order1 a b)|]\n;;\n\nlet prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n  let aux (a: int) (b: int) (c: int) (d: int): int array array =\n    if (a = b || c = d || a = 0 || b = 0 || c = 0 || d = 0)\n      then [|(array_in_order1 (a * c + b * d) (abs (a * d - b * c)))|]\n      else array_in_order2 (a * c + b * d) (abs (a * d - b * c)) (a * d + b * c) (abs (a * c - b * d))\n  in aux (abs a) (abs b) (abs c) (abs d)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217142,"user_id":null,"body":"let prod2Sum a b c d =\n  let n = (a*a + b*b) * (c*c + d*d) in\n  let ans1 = (abs @@ a*c + b*d, abs @@ a*d - b*c) in\n  let ans2 = (abs @@ a*c - b*d, abs @@ a*d + b*c) in\n  [ans1; ans2]\n  |> List.filter (fun (e, f) -> e*e + f*f = n)\n  |> List.map (fun (e, f) -> if e > f then (f, e) else (e, f))\n  |> List.sort_uniq Pervasives.compare\n  |> List.map (fun (e, f) -> [|e; f|])\n  |> Array.of_list","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217143,"user_id":168,"body":"let prod2Sum (a: int) (b: int) (c: int) (d: int): int array array =\n  let e1 = abs (a * c - b * d) and\n      f1 = abs (a * d + b * c) and\n      e2 = abs (a * d - b * c) and\n      f2 = abs (a * c + b * d) in\n  let e1, f1 = if e1 < f1 then e1, f1 else f1, e1 in\n  let e2, f2 = if e2 < f2 then e2, f2 else f2, e2 in\n  let e1, f1, e2, f2 = if e1 < e2 then e1, f1, e2, f2 else e2, f2, e1, f1 in\n  if e1 = e2 then\n    [|[|e1; f1|]|]\n  else\n    [|[|e1; f1|]; [|e2; f2|]|]","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55efecb8680f47654c000095":[{"id":217144,"user_id":492,"body":"let int_rac (n : int) (guess : int) =\n  let rec f count x =\n    let x' = (x + n \/ x) \/ 2 in\n      if x = x' then count\n      else f (count + 1) x' in\n    f 1 guess;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217145,"user_id":null,"body":"let int_rac (n : int) (guess : int) =\n  (* your code *)\n  let rec aux n x c = \n    let e = 1 in \n    let new_x = (x + n \/ x) \/ 2 in \n    if abs (new_x - x) < e then\n      c\n    else\n      aux n new_x (c + 1)\n  in\n  aux n guess 1\n;;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217146,"user_id":null,"body":"let rec int_rac (n : int) (x : int) =\n  let nx = (x+n\/x)\/2 in\n    if abs (x-nx)<1 then 1 else 1 + int_rac n nx\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217147,"user_id":53,"body":"let int_rac (n : int) (guess : int) =\n  let rec go k m =\n    let p = (m + n \/ m) \/ 2 in\n      if m = p then k else go (k + 1) p in\n    go 1 guess ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217148,"user_id":null,"body":"let rec int_rac (n : int) (guess : int) =\n  let x = (guess + n \/ guess)\/2 in\n    if abs (x-guess) < 1 then 1\n    else 1+int_rac n x;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217149,"user_id":null,"body":"let int_rac (n : int) (guess : int) =\n  let rec f count x =\n      if x = (x + n \/ x) \/ 2 then count\n      else f (count + 1) ((x + n \/ x) \/ 2) in\n    f 1 guess;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217150,"user_id":null,"body":"let rec int_rac (n : int) (guess : int) =\n  if abs(guess - (guess + n \/ guess) \/ 2) < 1 then 1 else 1 + int_rac n ((guess + n \/ guess) \/ 2)\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217151,"user_id":null,"body":"let int_rac (n : int) (guess : int) =\n\n  let rec aux prev l =\n    let neww = int_of_float ((float_of_int prev +. float_of_int n \/. float_of_int prev)\/.2.) in\n    if neww = prev then\n      List.length l else\n      aux neww (neww::l) in\n      \n  aux guess [guess];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217152,"user_id":null,"body":"let int_rac (n : int) (guess : int) =\n  let epsilon = 1 in\n  let rec helper g i =\n    let new_guess = (g + n \/ g) \/ 2 in\n    if abs (g - new_guess) < epsilon \n      then i\n      else helper new_guess (i+1)\n  in helper guess 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217153,"user_id":480,"body":"let int_rac (n : int) (guess : int) =\n  let rec aux i x e=\n    let x=(x+n\/x)\/2 and i=i+1 in\n    let e1=abs(n-x*x) in\n    if e1==e then (i-1) else aux i x e1\n  in\n  aux 1 guess (abs(n-guess*guess));\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55f3da49e83ca1ddae0000ad":[{"id":217154,"user_id":53,"body":"let tankVol (h: int) (d: int) (vt: int) =\n  let n = Float.acos(1.0 -. (float_of_int h) \/. ((float_of_int d) \/. 2.0)) *. 2.0 in \n  let m = (float_of_int vt) *. (n -. Float.sin(n)) \/. (2.0 *. Float.pi) in\n  (int_of_float (Float.floor m))\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217155,"user_id":492,"body":"let tankVol (h: int) (d: int) (vt: int) =\n  if (h == d) then vt\n  else\n    let r = float_of_int(d) \/. 2.0 in\n    let r2 = r *. r in\n    let oa = r -. float_of_int(h) in\n    let theta = acos(oa \/. r) in\n    let ab = r *. sin(theta) in\n    let k = float_of_int(vt) \/. 3.141592653589793 \/. r2 in\n    let sTheta = theta *. r2 \/. 2.0 in\n    let sOab = ab *. oa \/. 2.0 in\n    let s = 2.0 *. (sTheta -. sOab) in\n      int_of_float(s *. k);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217156,"user_id":null,"body":"let tank_vol_float height radius volume = (* Here, height < radius *)\n  \n  let vts = radius -. height in                  (* Vertical triangle side *)\n  let hts = sqrt @@ radius ** 2. -. vts ** 2. in (* Horizontal triangle side *)\n  let ta = hts *. vts in                         (* Triangle area *)\n  \n  let pi = 0x1.921fb54442d18p+1 in\n  let ca = pi *. radius ** 2. in                 (* Cercle area *)\n  let theta = acos @@ vts \/. radius in\n  let asa = ca *. theta \/. pi in                 (* Angular sector area *)\n  \n  let area_of_interest = asa -. ta in\n  let length = volume \/. ca in\n  area_of_interest *. length\n\nlet tankVol (h: int) (d: int) (vt: int) =\n  let foi = float_of_int in\n  let h = foi h in\n  let r = foi d \/. 2. in\n  let v = foi vt in\n  if h = r then vt \/ 2 else\n  if h < r then\n    int_of_float @@ tank_vol_float h r v\n  else\n    int_of_float @@ v -. tank_vol_float (foi d -. h) r v\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217157,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) =\n  let h' = float_of_int h in\n  let r = (float_of_int d) \/. 2.0 in\n  let pi = Float.pi in\n  let a = acos ((r -. h') \/. r) in \n  let rv = ((float_of_int vt) *. a) \/. pi in\n  let b = pi *. r ** 2.0 in\n  let w = (float_of_int vt) \/. b in\n  let tri = w *. (r ** 2.0) *. (sin a) *. (cos a) in \n  int_of_float (rv -. tri)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217158,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) =\n    let r = float d \/. 2.0 in\n    let length = float vt \/. (Float.pi *. r ** 2.0) in\n    let beta = acos ((r -. float h) \/. r) in\n    let half_arc = r *. beta in\n    let area = half_arc *. r -. (r *. r *. sin (2.0 *. beta)) \/. 2.0 in\n    int_of_float (length *. area) \n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217159,"user_id":null,"body":"open Core\n\nlet tankVol (h: int) (d: int) (vt: int) =\n  (* Fluid area is area of the arc minus area of the triangle. *)\n  let h = float h in\n  let r = float d \/. 2. in\n  let triangle_half_width = sqrt (r ** 2. -. (r -. h) ** 2.) in\n  let triangle_area = triangle_half_width *. (r -. h) in\n  let angle = 2. *. Float.acos ((r -. h) \/. r) in\n  let total_area = Float.pi *. r ** 2. in\n  let arc_area = angle \/. (2. *. Float.pi) *. total_area in\n  let depth = float vt \/. total_area in\n  Int.of_float ((arc_area -. triangle_area) *. depth)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217160,"user_id":null,"body":"# 2\nlet pi = 3.14159265358979323\n\n(* use formula from https:\/\/www.mathopenref.com\/cylindervolpartial.html *)\nlet tankVol (h: int) (d: int) (vt: int) =\n  (* convert inputs to doubles *)\n  let h = float_of_int h in\n  let r = float_of_int d \/. 2.0 in\n  let vt = float_of_int vt in\n  let oa = r -. h in\n  let theta = acos (oa \/. r) in\n  let len = vt \/. (r *. r *. pi) in\n  let vol = len *. (r *. r *. theta -. oa *. sqrt (2.0 *. r *. h -. h *. h)) in\n  int_of_float vol\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217161,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) =\n  let open Core.Std in\n  let pi = 4. *. atan 1. in\n  let [h;d;vt] = List.map ~f:Float.of_int [h;d;vt] in\n  let x = 1. -. 2. *. h \/. d in\n  Int.of_float @@ (acos(x) -. x *. sqrt(1. -. x *. x)) \/. pi *. vt\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217162,"user_id":null,"body":"let tankVol (h: int) (d: int) (vt: int) : int =\n  let pi = 4.0 *. atan 1.0 in\n  let h = float_of_int h in\n  let d = float_of_int d in\n  let r = d \/. 2.0 in\n  let vt = float_of_int vt in\n  let theta = (r -. h) \/. r |> acos in\n  let s_tri = r *. r *. sin (2.0 *. theta) \/. 2.0 in\n  let s_circ = r *. r *. pi in\n  let s_arc = s_circ *. theta \/. pi in\n  vt *. (s_arc -. s_tri) \/. s_circ |> int_of_float;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217163,"user_id":null,"body":"let pi = 4. *. atan 1.\n\nlet tankVol (h: int) (d: int) (vt: int) =\n  let r = float d \/. 2. in\n  let l = float vt \/. (r *. r *. pi) in\n  let h' = float h in\n  l *. (r *. r *. (acos ((r -. h') \/. r)) -. (r -. h') *. (sqrt (2. *. r *. h' -. h' *. h')))\n  |> int_of_float","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55f9bca8ecaa9eac7100004a":[{"id":217164,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int =\n  (h * 3600000) + (m * 60000) + (s * 1000)\n  (* your code here *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217165,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int = (3600*h+60*m+s)*1000;;\n  (* your code here *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217166,"user_id":null,"body":"let past h m s = (3600 * h + 60 * m + s) * 1000","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217167,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int = h*60*60*1000 + m*60*1000 + s*1000;;\n  (* your code here *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217168,"user_id":null,"body":"let past h m s = (3_600 * h + 60 * m + s) * 1_000","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217169,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int =\n  h * 3600000 + m * 60000 + s * 1000","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217170,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int =\n  s * 1000 + m * 60 * 1000 + h * 60 * 60 * 1000","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217171,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int =\n  let ms = 1000 in h*3600*ms + m*60*ms + s*ms;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217172,"user_id":null,"body":"let past h m s = 1000*(s+m*60+h*3600);;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217173,"user_id":null,"body":"let past (h: int) (m: int) (s: int): int =\n  (* your code here *)\n  let sum h m s acc = ((h*3600)+(m*60)+s+acc)*1000\n  in sum h m s 0","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"55fd2d567d94ac3bc9000064":[{"id":217174,"user_id":645,"body":"let row_sum_odd_numbers (n: int): int = n * n * n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217175,"user_id":null,"body":"let rec nConsecutiveNumber start = function\n  | 0 -> []\n  | n -> start :: (nConsecutiveNumber (start+1) (n-1));;\n  \nlet rec toOdd = function\n  | [] -> []\n  | a :: t -> (2*a+1) :: toOdd t;;\n  \nlet rec sum = function\n  | [] -> 0\n  | a :: t -> a + (sum t);;\n\nlet row_sum_odd_numbers (n: int) =\n  let startingIndex = n*(n-1)\/2 in\n    sum (toOdd (nConsecutiveNumber startingIndex n))\n  \n    ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217176,"user_id":null,"body":"let rec last_el = function\n    [x] -> x\n  | e::l -> last_el l ;;\n\nlet rec row a b = match a with\n    0 -> []\n  | a -> b :: (row (a - 1) (b + 2)) ;;\n\nlet triangle n =\n  let rec t_rec a b = match a with\n      0 -> []\n    | a -> (row (n - a + 1) b) :: (t_rec (a - 1) (last_el (row (n - a + 1) b) + 2))\n  in t_rec n 1;;\n  \nlet rec sumList = function\n    [] -> 0\n  | e::l -> e + sumList l ;;\n\nlet row_sum_odd_numbers n =\n  sumList (last_el (triangle n)) ;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217177,"user_id":null,"body":"let row_sum_odd_numbers n = n * n * n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217178,"user_id":null,"body":"let get_index_of_first row = \n  let rec get n acc = \n  if(n= 0) then acc else get (n-1) (acc + n)\n  in get (row -1) 1\n\nlet get_nth_element n = 2*(n-1) + 1\n\n\nlet row_sum_odd_numbers (n: int): int = \n   let idx = get_index_of_first n in\n   List.init n (fun m -> get_nth_element (idx + m))\n   |> List.fold_left (+) 0\n\n  \n    \n    ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217179,"user_id":null,"body":"let rec last = function\n  | [] -> failwith \"Liste vide\"\n  | a::[] -> a\n  | a::b -> last b;;\n  \nlet sum l = \n  let rec aux s = function\n  | [] -> s\n  | a::b -> aux (s+a) b\n  in aux 0 l;;\n  \nlet row_sum_odd_numbers n =\n  let rec aux l = function\n  | a when a = n -> sum l\n  | a -> let last_odd = (last l) in\n        aux (List.init (a + 1) (fun i -> last_odd + 2*(i+1))) (a + 1)\n  in aux [1] 1;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217180,"user_id":null,"body":"(* obvious O(1) solution \n   that I didn't use the first time around  \n   because I'm dumb*)\nlet row_sum_odd_numbers (n: int): int =\n  let gSum (k: int): int =\n    k*(1+k)\/2\n  in\n  let k1 = gSum n  in\n  let k2 = k1 - n + 1 in\n  let up = k1*2-1     in\n  let fl = k2*2-1     in\n  n*(up+fl)\/2\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217181,"user_id":null,"body":"let row_sum_odd_numbers (n: int): int =\n  (* your code here *)\n  let rec factSum (k: int): int =\n    if k = 1 then 1\n    else k + factSum (k-1)\n  in\n  let k1 = factSum n in\n  let k2 = k1 - n + 1 in\n  let up = k1*2-1 in\n  let fl = k2*2-1 in\n  n*(up+fl)\/2\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217182,"user_id":null,"body":"let row_sum_odd_numbers (n: int): int = n*n*n;;\n  (* your code here *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217183,"user_id":null,"body":"let rec rowSum2(n: int) (numbers: int) (answer: int): int =\n  if n = 0 then answer else\n    rowSum2 (n-1) (numbers-1) (2*(numbers-1)+1+answer);;\n\nlet row_sum_odd_numbers (n: int): int =\n  let numbers = (n+1)*n\/2 in\n    rowSum2 n numbers 0;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5613d06cee1e7da6d5000055":[{"id":217184,"user_id":53,"body":"let is_prime (n : int) : bool =\n  let rec aux m =\n    m * m > n || (n mod m != 0 && aux (m + 1)) in n >= 2 && aux 2\n  ;;\n  \nlet step g m n =\n  let rec loop i =\n    if i >= n - g then [] else\n    if is_prime i && is_prime (i + g) then [i; i + g] else\n    loop (i + 1)\n  in loop m\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217185,"user_id":492,"body":"let is_prime n =\n  if n = 2 then true\n  else if n < 2 || n mod 2 = 0 then false\n  else\n    let rec loop k =\n      if k * k > n then true\n      else if n mod k = 0 then false\n      else loop (k+2)\n    in loop 3\n\nlet step g m n =\n  let rec aux k acc = \n    match k with \n      | x when x > n -g -> acc\n      | _ ->\n        if (is_prime k) && (is_prime (k + g)) then\n          aux (k + 1) ([k; k + g] :: acc)\n        else aux (k + 1) acc\n  in \n    let res = aux m [] in\n      match res with\n        | x when x = [] -> []\n        | _ -> List.rev(res) |> List.hd","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217186,"user_id":492,"body":"let is_prime n =\n  if n = 2 then true\n  else if n < 2 || n mod 2 = 0 then false\n  else\n    let rec loop k =\n      if k * k > n then true\n      else if n mod k = 0 then false\n      else loop (k+2)\n    in loop 3\n\nlet step g m n =\n  let rec aux k acc = \n    match k with \n      | x when x > n -g -> acc\n      | _ ->\n        if (is_prime k) && (is_prime (k + g)) then\n          aux (k + 1) ([k; k + g] :: acc)\n        else aux (k + 1) acc\n  in \n    let res = aux m [] in\n      match res with\n        | x when x = [] -> []\n        | _ -> List.rev(res) |> List.hd","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217187,"user_id":null,"body":"let step g m n =\n  let t = Array.make (n+1) true in\n  for i = 2 to ( + ) 1 @@ int_of_float @@ sqrt @@ float_of_int n do\n    if t.(i) then begin\n      for j = 2 to n \/ i do\n        t.(i * j) <- false\n      done\n    end\n  done;\n  let found = ref false in\n  let first = ref m in\n  let nn = n - g in\n  while not !found && !first <= nn do\n    if t.(!first) && t.(!first + g) then found := true else incr first\n  done;\n  if !found then [!first; !first + g] else []\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217188,"user_id":null,"body":"(* Primality test using 6k+-1 optimization. *)\n\nlet is_prime n =\n    if n <= 3 then n > 1\n    else if (n mod 2 = 0) || (n mod 3 = 0) then false\n    else\n        let rec loop i =\n            if (i * i) > n then true \n            else if (n mod i = 0) || (n mod (i + 2) = 0) then false\n            else loop (i + 6)\n        in loop 5\n\nlet step g m n =\n    let rec aux k =\n        if k >= n then []\n        else let try_step = k + g in\n        if is_prime k && is_prime (try_step) then [k; try_step]\n        else aux (k + 1)\n    in aux m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217189,"user_id":null,"body":"(* Primality test using 6k+-1 optimization. *)\n\nlet is_prime n =\n    if n <= 3 then n > 1\n    else if (n mod 2 = 0) || (n mod 3 = 0) then false\n    else\n        let rec loop i =\n            if (i * i) > n then true \n            else if (n mod i = 0) || (n mod (i + 2) = 0) then false\n            else loop (i + 6)\n        in loop 5\n\nlet next_prime n =\n    let rec aux next_int =\n        if is_prime next_int then next_int\n        else aux (next_int + 1)\n    in aux (n + 1)\n\n\nlet step g m n =\n    let rec aux k i =\n        let np = next_prime i in\n        if np > n then []\n        else if (np - k) < g then aux k np\n        else if (np - k) = g then  [k; np]\n        else aux (next_prime k) (next_prime k)\n        in if is_prime m then aux m m\n        else let pm = next_prime m\n        in aux pm pm","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217190,"user_id":null,"body":"let isPrime x =\n  let rep = ref true in\n  for i = 2 to int_of_float((sqrt(float_of_int(x)) +. 1.)) do\n    if x mod i = 0 then \n      rep := false ; done ;\n  !rep;;\n\n\nlet step g m n = (* your code *)\n  let rep = ref 0 in\n  let rep2 = ref 0 in\n  let ans = [] in\n  for i = m to n-g do\n    if (!rep=0&& isPrime(i) && isPrime(i+g)) then\n      (rep := i ; rep2 := i+g;) done ;\n  if(!rep=0) then [] else  !rep::(!rep2)::ans;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217191,"user_id":null,"body":"\nlet get_sqrt m =\n  int_of_float (float_of_int m**0.5)\n\nlet step g m n =\n  let c = Array.init n (fun i -> i = 2 || (i > 2 && i mod 2 = 1)) in\n  let j = ref 0 in\n  for i = 3 to get_sqrt n do\n    if c.(i) then\n      begin\n        j := 2*i;\n        while !j < n do\n          c.(!j) <- false;\n          j := !j + i;\n        done;\n      end\n  done;\n  let rec is_prime p = p < n && c.(p)\n  in\n  let rec next_prime p =\n    if p > n - 1 then p else\n      if is_prime(p) then p\n      else next_prime (p + 1)\n  in\n  let rec aux p =\n    let p = next_prime p in\n    if p > n then []\n    else\n      if p + 2 > n - 1 then []\n      else\n        if is_prime (p + g) then\n          [p; p + g]\n        else\n          aux (p + 1)\n  in\n  aux (next_prime m)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217192,"user_id":null,"body":"let range a b s = \n    let rec loop acc k = \n        if k > b then List.rev acc\n        else loop (k :: acc) (k + s)\n    in loop [] a    \n\n\nlet is_prime n = \n    if n = 2 then true\n    else if n = 1 || n mod 2 = 0 then false\n    else \n        let limit = n |> float_of_int |> sqrt |> floor |> int_of_float\n        in List.for_all (function k -> n mod k <> 0) (range 3 limit 2)\n\n\nlet step g m n = \n    let rec loop a = \n        let b = a + g in\n        if b > n then []\n        else if is_prime a && is_prime b then [a; b]\n        else loop (a + 1)\n    in loop m\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217193,"user_id":null,"body":"let est_premier n =\n   let rec aux i = (i = n)||((n mod i <> 0)&&(aux (i+1))) in\n(n <> 1)&&(aux 2);;\n\n\nlet step g m n = \nlet i= ref 0 in\nlet c = ref [] in\n\twhile (!i<=n-m-g && (est_premier (m+(!i)) && est_premier (m+(!i)+g)) == false) do\n\t\tincr i; done; \n\tif !i < n-m-g then (let b = (m+(!i)) in  c := [b ;b+g]);\n !c;;\n\n\n ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5616868c81a0f281e500005c":[{"id":217194,"user_id":168,"body":"let rank (st: string) (we: int array) (n: int) =\n  if st = \"\" then \"No participants\"\n  else\n    let code i name =\n      let r = ref (String.length name) in\n      String.uppercase name |>\n        String.iter (fun ch -> r := !r + Char.code ch - Char.code 'A' + 1);\n      we.(i) * !r, name in\n    let ps = Str.split (Str.regexp \",\") st in\n    let cmp (w1, n1) (w2, n2) =\n      let r = compare w2 w1 in\n      if r <> 0 then r\n        else compare n1 n2 in\n    let ns' = List.mapi code ps in\n    let ns = List.sort cmp ns' in\n      if n > List.length ns then \"Not enough participants\" \n    else snd (List.nth ns (n - 1))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217195,"user_id":492,"body":"let rank (st: string) (we: int array) (n: int): string =\n  let word_sum s w = \n    let uppercase_ascii s = String.uppercase s\n    in\n    let letter_rank c = (int_of_char c) - 64\n    in\n      (String.length s +\n         ((uppercase_ascii s) \n          |> Str.split (Str.regexp \"\") \n          |> List.map(fun x -> letter_rank x.[0]) \n          |> List.fold_left (+) 0)) * w\n  in\n\n  let cmp (a, b) (x, y) =\n    let cp =  x - a in\n    let cp1 = compare b y in\n      if cp = 0 then cp1 else cp\n  in\n    if (st = \"\") then \"No participants\"\n    else if (Array.length we < n) then \"Not enough participants\"\n    else\n      let l = Str.split (Str.regexp \",\") st |> Array.of_list in\n      let a = Array.mapi(fun i x -> word_sum x we.(i), x) l in\n        Array.sort cmp a;\n        snd a.(n - 1);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217196,"user_id":null,"body":"let rank (st: string) (we: int array) (n: int): string =\n  if st = \"\" then \"No participants\" else\n  let names = String.split_on_char ',' st in\n  if List.length names < n then \"Not enough participants\" else\n  \n  let som name =\n    let char_rank c =\n      match Char.uppercase_ascii c with\n      | 'A' .. 'Z' as c -> Char.code c - 64\n      | _ -> failwith \"A name contains non-letter chars\" in\n    let weights = List.init (String.length name) (fun i -> char_rank name.[i]) in\n    List.fold_left ( + ) (String.length name) weights in\n  \n  let win_num i name =\n    we.(i) * som name in\n  \n  let names_augmented = List.mapi (fun i name -> name, i, win_num i name) names in\n  \n  let comp (n1, _, w1) (n2, _, w2) =\n    match compare w1 w2 with\n    | 0 -> compare n1 n2\n    | k -> - k in\n  \n  let sorted = List.sort comp names_augmented in  \n  match List.nth sorted (n - 1) with\n    name, _, _ -> name","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217197,"user_id":null,"body":"let getNum s = let tot = ref 0 in\n  for i = 0 to String.length s -1 do\n    tot:= !tot + Char.code (Char.lowercase (s.[i])) - 96\n  done;\n  !tot + (String.length s);;\n\nlet rec appl l we i= match l with\n  |[]->[]\n  |(a,b)::q -> (a,b*(we.(i)))::(appl q we (i+1))\n;;\n\nlet convL s we =\n  let rec aux s rep i = if i = String.length s then [(rep,getNum rep)] else begin\n      match s.[i] with \n      |','-> [(rep,getNum rep)]@(aux s (\"\") (i+1))\n      |a -> aux s (rep^(String.make 1 a)) (i+1)\n    end in appl (aux s \"\" 0) we 0 ;; \n\nlet devant a b = let x,y = a in\n  let v,w =b in\n  (y>w) || ((y = w) && (x<=v))\n\n;;\n\nlet rec nbPerdu x l = match l with \n  |[] -> 0 \n  |p::q -> nbPerdu x q + if (devant p x) then 1 else 0\n;;\n\nlet rang n l = \n  let rec aux n q l = match q with \n    |[]-> \"Not enough participants\"\n    |p::r -> if (nbPerdu p l)=n then fst p else (aux n r l)\n  in aux n l l\n;;\n\nlet rank (st: string) (we: int array) (n: int): string =\n  if st = \"\" then \"No participants\" else rang n (convL st we);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217198,"user_id":null,"body":"                      \nlet rank (st: string) (we: int array) (n: int): string =\n  if String.length st = 0 then \"No participants\" else\n  let st = String.split_on_char ',' st in\n  if List.length st < n then \"Not enough participants\" else\n    let stU = List.map String.uppercase_ascii st in\n    let get_numbers c = Char.code c - Char.code 'A' + 1 in\n    let point_lst = List.map (fun name -> (List.init (String.length name) (String.get name))) stU in    \n    let point_lst = List.mapi (fun i lst -> List.fold_left (fun acc s -> acc + get_numbers s) (String.length (List.nth stU i)) lst)  point_lst in\n    let point_lst = List.mapi (fun i w -> (we.(i) * w, List.nth st i)) point_lst  in\n    let ord_point_lst = List.fast_sort (fun x y -> if compare (fst x) (fst y) = 0 then String.compare (snd x) (snd y) else -(compare (fst x) (fst y))) point_lst in\n    snd (List.nth ord_point_lst (n - 1))\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217199,"user_id":609,"body":"open Batteries\n\nlet winning_number s =\n  let n = String.length s in\n  let code c = (Char.code (Char.lowercase_ascii c)) - (Char.code 'a') + 1 in\n  let rec aux sum i = match i with\n    | i when i = n -> sum\n    | i -> aux (sum + (code s.[i])) (i+1) in\n  n + (aux 0 0)\n\nlet rank (st: string) (we: int array) (n: int): string =\n  let namelist = BatString.nsplit st \",\" in\n  let nbnames = List.length namelist in\n  if nbnames = 0 then\n    \"No participants\"\n  else if nbnames < n then \n    \"Not enough participants\"\n  else begin\n    let pairs = List.mapi (fun i elt -> (elt, we.(i) * (winning_number elt))) namelist in\n    let cmp (a,b) (c,d) = if (b < d) || (b = d && a > c) then 1\n                          else (if (a = c && b = d) then 0 else -1) in\n    let pairs = List.sort cmp pairs in\n    List.iter (fun (s,x) -> Format.printf \"%s : %d\n\" s x) pairs;\n    fst (List.nth pairs (n-1))\n  end\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217200,"user_id":480,"body":"open Char;;\nopen Seq;;\nopen List;;\nopen String;;\n\nlet letter_value c=(Char.code (Char.uppercase_ascii c))-(Char.code 'A')+1;;\n\nlet letter_values s=\n  let add acc c=acc+(letter_value c) in\n  List.fold_left add 0 (List.of_seq (String.to_seq s));;\n\nlet winning s=(String.length s)+(letter_values s);;\n\nwinning \"PauL\";;\n\nlet rank (st: string) (we: int array) (n: int): string =\n  if (String.length st)=0 then \"No participants\" else\n  let st =String.split_on_char ',' st in\n  if (List.length st)==0 then \"No participants\"\n  else if (List.length st)<n then \"Not enough participants\"\n  else\n    let rec mklist prev i st we=\n      match st with\n      | []->prev\n      | h::t-> mklist (prev@[(h, (winning h)*we.(i))]) (i+1) t we\n    in\n    let cmp a b=\n      let (aname,a)=a and (bname,b)=b in \n      let r=b-a in\n      if r!=0 then r else String.compare aname bname\n    in\n    let (winner,score)=List.nth (List.stable_sort cmp (mklist [] 0 st we)) (n-1)\n    in\n    winner;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217201,"user_id":null,"body":"let rank (st: string) (we: int array) (n: int): string =\n    if st = \"\" then \"No participants\"\n    else\n        let calc_rank name =\n            Seq.fold_left (fun acc c -> acc + (Char.(c |> lowercase_ascii |> code) - 96)) \n            (String.length name) (String.to_seq name) in\n        let names = String.split_on_char ',' st in\n        let nr_names = List.length names in\n        let weights = Array.to_list @@ Array.sub we 0 nr_names in\n        let winning_numbers = List.map2 (fun name w -> (w * (calc_rank name), name)) names weights in\n        let compare (w1, n1) (w2, n2) = \n            if w1 > w2 then 1\n            else if w1 < w2 then -1\n            else if n1 > n2 then -1\n            else if n1 < n2 then 1 \n            else 0 in \n        let sorted_names = List.rev @@ List.sort compare winning_numbers in\n        if n > List.length sorted_names then \"Not enough participants\"\n        else snd @@ List.nth sorted_names (n - 1)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217202,"user_id":492,"body":"let rank (st: string) (we: int array) (n: int): string =\n  let word_sum s w = \n    (*let uppercase_ascii s = String.uppercase s*)\n    let uppercase_ascii s = String.uppercase_ascii s\n    in\n    let letter_rank c = (int_of_char c) - 64\n    in\n      (String.length s +\n         ((uppercase_ascii s) \n          |> Str.split (Str.regexp \"\") \n          |> List.map(fun x -> letter_rank x.[0]) \n          |> List.fold_left (+) 0)) * w\n  in\n\n  let cmp (a, b) (x, y) =\n    let cp =  x - a in\n    let cp1 = compare b y in\n      if cp = 0 then cp1 else cp\n  in\n    if (st = \"\") then \"No participants\"\n    else if (Array.length we < n) then \"Not enough participants\"\n    else\n      let l = Str.split (Str.regexp \",\") st |> Array.of_list in\n      let a = Array.mapi(fun i x -> word_sum x we.(i), x) l in\n        Array.sort cmp a;\n        snd a.(n - 1);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217203,"user_id":null,"body":"let charvalue c = Char.code (Char.lowercase_ascii c) - 96\n\nlet take n l =\n  let rec f acc i l = if i = 0 then List.rev acc else f (List.hd l :: acc) (i - 1) (List.tl l) in\n  f [] n l\n\nlet som name =\n  let v = String.to_seq name |> Seq.map charvalue |> Seq.fold_left (+) 0 in\n  v + String.length name\n\nlet rank st we n =\n  match String.split_on_char ',' st with\n  | [\"\"] -> \"No participants\"\n  | names ->\n    let len = List.length names in\n    if n > len then \"Not enough participants\" else\n    List.combine (List.map (fun n -> (n, som n)) names) (Array.to_list we |> take len)\n    |> List.map (fun ((name, som), weight) -> (name, som * weight))\n    |> List.sort (fun a b -> compare (- snd a, fst a) (- snd b, fst b))\n    |> fun l -> List.nth l (n - 1)\n    |> fst","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"561e9c843a2ef5a40c0000a4":[{"id":217204,"user_id":53,"body":"let is_prime (n : int) : bool =\n  let rec aux m =\n    m * m > n || (n mod m != 0 && aux (m + 1))\n  in\n    n >= 2 && aux 2\n  ;;\n    \nlet gap (g: int) (m: int) (n: int): (int * int) option =\n  let rec loop i a b =\n    if i > n then None else\n    if b - a == g then Some (a, b) else\n    if is_prime i then loop (i + 1) b i else\n    loop (i + 1) a b\n  in loop m 0 0\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217205,"user_id":168,"body":"let is_prime p =\n  let rec div_test k n =\n    if k > n then true\n    else if p mod k = 0 then false\n    else div_test (k + 2) n in\n  if p = 2 then true\n  else if p <= 1 || p mod 2 = 0 then false\n  else\n    let n = int_of_float (sqrt (float_of_int p)) in\n    div_test 3 n\n    \nlet gap (g: int) (m: int) (n: int): (int * int) option =\n  let rec loop prev k =\n    if k > n then None\n    else\n      match prev, is_prime k with\n      | _, false -> loop prev (k + 1)\n      | None, true -> loop (Some k) (k + 1)\n      | Some p, true -> \n        if k - p = g then Some (p, k)\n        else loop (Some k) (k + 1) in\n  loop None m\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217206,"user_id":492,"body":"let rec range (a: int) (b: int): int list =\n  if a > b then []\n  else a :: range (a+1) b;;\nlet is_prime n =\n  if n = 2 then true\n  else if n < 2 || n mod 2 = 0 then false\n  else\n    let rec loop k =\n      if k * k > n then true\n      else if n mod k = 0 then false\n      else loop (k + 2)\n    in loop 3;;\nlet allp m n =\n  List.filter (fun x -> is_prime x) (range m n);;\nlet rec zip lst1 lst2 = match lst1,lst2 with\n  | [],_ -> []\n  | _, []-> []\n  | (x::xs),(y::ys) -> (x,y) :: (zip xs ys);;\n\nlet gap (g: int) (m: int) (n: int): (int * int) option =\n  let u = allp m n in\n  let z = zip u (List.tl u) in\n  let r = List.filter (fun x -> fst x + g = snd x) z in\n    if List.length r != 0 then Some(List.hd r)\n    else None;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217207,"user_id":null,"body":"let gap (g: int) (m: int) (n: int): (int * int) option =\n  let t = Array.make (n+1) true in\n  for i = 2 to ( + ) 1 @@ int_of_float @@ sqrt @@ float_of_int n do\n    if t.(i) then begin\n      for j = 2 to n \/ i do\n        t.(i * j) <- false\n      done\n    end\n  done;\n  let found = ref false in\n  let first = ref m in\n  let nn = n - g in\n  while not !found && !first <= nn do\n    if t.(!first) && t.(!first + g) && Array.for_all (not) @@ Array.sub t (!first+1) (g-2) then found := true else incr first\n  done;\n  if !found then Some (!first, !first + g) else None","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217208,"user_id":null,"body":"let gap (g: int) (m: int) (n: int): (int * int) option =\n  let is_prime (n : int) : bool =\n    let rec aux m =\n      m * m > n || (n mod m != 0 && aux (m + 1))\n    in\n      n >= 2 && aux 2\n  in\n  \n  let rec find_gap prev i =\n    if i > n then None\n    else\n      match prev, is_prime i with\n      | _, false -> find_gap prev (i + 1)\n      | None, true -> find_gap (Some i) (i + 1)\n      | Some p, true ->\n        if i - p = g then Some (p, i)\n        else find_gap (Some i) (i + 1)\n  in\n  find_gap None m;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217209,"user_id":null,"body":"let range a b s = \n    let rec loop acc k = \n        if k > b then List.rev acc\n        else loop (k :: acc) (k + s)\n    in loop [] a    \n\n\nlet is_prime n = \n    if n = 2 then true\n    else if n = 1 || n mod 2 = 0 then false\n    else \n        let limit = n |> float_of_int |> sqrt |> floor |> int_of_float\n        in List.for_all (function k -> n mod k <> 0) (range 3 limit 2)\n\n\nlet get_first_prime m = \n    let rec loop k = \n        if is_prime k then k \n        else loop (k + 1)\n    in loop m    \n\n\nlet gap (g: int) (m: int) (n: int): (int * int) option =\n    let p0 = get_first_prime m in\n    let rec loop p k = \n        if k > n then None\n        else if is_prime k then \n            if k - p = g then Some (p, k)\n            else loop k (k + 2)\n        else loop p (k + 1)\n    in loop p0 (p0 + 2)    \n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217210,"user_id":98,"body":"\nlet rec is_prime number = \n\n\tlet rec aux number divisor = \n\t\tif divisor = 1 \n\t\t\tthen true \n\t\telse  if number mod divisor = 0 \n\t\t\tthen false\n\t\telse \n\t\t\taux number (divisor -1 )\n\tin \n\tif ( number=0  || number=1 || number mod 2 = 0 ) \n\t\tthen false \n\telse if number<0  \n\t\tthen is_prime (-number)  \n\telse  \n\t\taux  number (int_of_float (sqrt  (float_of_int number )  ) ) \n;;\n\n\n\n\nlet rec next_prime number  =\n\tlet rec aux number  =\n\tif is_prime number\n\t\tthen number\n\telse \n\t\taux (number+2)\n\tin \n\tif number=2 \n\t\tthen 3\n\telse if (number mod 2) = 0\n\t\tthen aux (number+1)\n\telse\n\t\taux (number+2) \n;;\n\n\t\n\nlet rec gap (g: int) (m: int) (n: int): (int * int) option =\n\tlet rec aux gap inf sup = \n\tlet the_next_prime = next_prime inf in\n\tif the_next_prime > sup\n\t\tthen None \n\telse if the_next_prime - inf = gap \n\t\tthen Some (inf,the_next_prime)\n\telse \n\t\taux gap (next_prime inf) sup \n\tin if is_prime m \n\t\tthen aux g m n\n\telse \n\t\taux g (next_prime m) n \n;;\n\t","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217211,"user_id":null,"body":"let gap gapspace start stop = \n  let is_prime n =\n    let n = abs n in\n    let rec is_not_divisor d =\n      d * d > n || (n mod d <> 0 && is_not_divisor (d+1)) in\n    n <> 1 && is_not_divisor 2 in\n  let are_both_prime start stop = (is_prime start) && (is_prime stop) in\n  let (--) i j = \n    let rec aux n acc = \n      if n < i then acc else aux (n-1) (n::acc)\n    in aux j [] in\n  let any_prime_in_range list = List.exists is_prime list in\n  let rec aux start interstop =\n    match(start, interstop) with\n      (_, stp) when stp > stop-> None\n    | (start, stop) when (are_both_prime start stop) && not(any_prime_in_range ((start+1)--(stop-1))) ->  Some(start, stop)\n    | (oldstart, _) -> aux (oldstart+1) (oldstart+1+gapspace)\n  in \n  aux start (start+gapspace)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217212,"user_id":null,"body":"let gap gapspace start stop = \n  let is_prime n =\n    let n = abs n in\n    let rec is_not_divisor d =\n      d * d > n || (n mod d <> 0 && is_not_divisor (d+1)) in\n    n <> 1 && is_not_divisor 2 in\n  let are_both_prime start stop = (is_prime start) && (is_prime stop) in\n  let (--) i j = \n    let rec aux n acc = \n      if n < i then acc else aux (n-1) (n::acc)\n    in aux j [] in\n  let rec aux start interstop =\n    match(start, interstop) with\n      (_, stp) when stp > stop-> None\n    | (start, stop) when (are_both_prime start stop) && not(List.exists is_prime ((start+1)--(stop-1))) ->  Some(start, stop)\n    | (oldstart, _) -> aux (oldstart+1) (oldstart+1+gapspace)\n  in \n  aux start (start+gapspace)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5629db57620258aa9d000014":[{"id":217213,"user_id":492,"body":"let mk_pair sndx sndy =\n  let m = max sndx sndy in\n    if m > 1 then\n      if m > sndx then [|m; 2|]\n      else if m > sndy  then [|m; 1|]\n      else [|m; 0|]\n    else [|0;0|];;\n\nlet mk_string (a: int * int array): string =\n  let c = fst a in\n  let rep = (snd a).(0) and sy = (snd a).(1) in\n  let sym = \n    if sy = 0 then\n      \"=:\"\n    else if sy = 1 then \n      \"1:\"\n    else \"2:\"\n  in\n    sym ^ String.make rep (Char.chr c);;\n\nlet cmp (x: string) (y: string): int =\n  let (c: int) = (String.length y) - (String.length x) in\n    if c = 0 then \n      begin\n        if x = y then 0\n      else if x < y then -1\n    else 1\n      end\n    else c;;\n\nlet mix_strings (ss1: string) (ss2: string): string =\n  let s1 = Str.split (Str.regexp \"\") ss1 in\n  let s2 = Str.split (Str.regexp \"\") ss2 in\n  let a1 = count_char_984 s1 in\n  let a2 = count_char_984 s2 in\n  let z = zip_984 a1 a2 in\n  let a3 = List.map(fun x -> let a, b = x in (fst a, mk_pair (snd a) (snd b))) z in\n  let a4 = List.filter(fun x -> let a, b = x in b.(0) != 0) a3 in\n    List.map(fun x -> mk_string x) a4 |> List.sort cmp |> String.concat \"\/\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217214,"user_id":492,"body":"let mk_pair sndx sndy =\n  let m = max sndx sndy in\n    if m > 1 then\n      if m > sndx then [|m; 2|]\n      else if m > sndy  then [|m; 1|]\n      else [|m; 0|]\n    else [|0;0|];;\n\nlet mk_string (a: int * int array): string =\n  let c = fst a in\n  let rep = (snd a).(0) and sy = (snd a).(1) in\n  let sym = \n    if sy = 0 then\n      \"=:\"\n    else if sy = 1 then \n      \"1:\"\n    else \"2:\"\n  in\n    sym ^ String.make rep (Char.chr c);;\n\nlet cmp (x: string) (y: string): int =\n  let (c: int) = (String.length y) - (String.length x) in\n    if c = 0 then \n      begin\n        if x = y then 0\n      else if x < y then -1\n    else 1\n      end\n    else c;;\n\nlet mix_strings (ss1: string) (ss2: string): string =\n  let s1 = Str.split (Str.regexp \"\") ss1 in\n  let s2 = Str.split (Str.regexp \"\") ss2 in\n  let a1 = count_char_984 s1 in\n  let a2 = count_char_984 s2 in\n  let z = zip_984 a1 a2 in\n  let a3 = List.map(fun x -> let a, b = x in (fst a, mk_pair (snd a) (snd b))) z in\n  let a4 = List.filter(fun x -> let a, b = x in b.(0) != 0) a3 in\n    List.map(fun x -> mk_string x) a4 |> List.sort cmp |> String.concat \"\/\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217215,"user_id":null,"body":"let is_lowercase (c : Char.t) = Char.code 'a' <= Char.code c && Char.code c <= Char.code 'z'\n\nlet repeat (c : char) (i : int) : string =\n  let s = String.make 1 c in\n  let rec aux acc j = if j = i then acc else aux (s ^ acc) (j + 1) in\n  aux \"\" 0\n;;\n\nlet lowercase_filter (s : string) : string =\n  String.to_seq s |> Seq.filter is_lowercase |> String.of_seq\n;;\n\nlet entry_compare (s1: string) (s2: string) : int =\n  let n1 = String.length s1\n  and n2 = String.length s2 in\n  match Stdlib.compare n1 n2 with\n  | 0 -> String.compare s1 s2\n  | _ -> - Stdlib.compare n1 n2\n\n\ntype string_table = (char, int) Hashtbl.t\n\nlet to_table (s : string) (h : string_table) : unit =\n  let insert_or_incr (c : char) : unit =\n    match Hashtbl.find_opt h c with\n    | Some v -> Hashtbl.replace h c (v + 1)\n    | None -> Hashtbl.add h c 1\n  in\n  String.to_seq s |> Seq.iter insert_or_incr\n;;\n\ntype balance =\n  | First\n  | Second\n  | Equal\n\nlet to_list (h1 : string_table) (h2 : string_table) : (char * int * balance) list =\n  let aux c v acc =\n    let e =\n      match Hashtbl.find_opt h2 c with\n      | None -> c, v, First\n      | Some v' when v' > v -> c, v', Second\n      | Some v' when v' = v -> c, v', Equal\n      | Some _ -> c, v, First\n    in\n    e :: acc\n  in\n  let h2_aux (c, v) =\n    match Hashtbl.mem h1 c with\n    | false -> Some (c, v, Second)\n    | true -> None\n  in\n  let h2_unique_elems = Hashtbl.to_seq h2 |> Seq.filter_map h2_aux |> List.of_seq in\n  (Hashtbl.fold aux h1 [] @ h2_unique_elems)\n  |> List.filter (fun (_, v, _) -> v > 1)\n;;\n\nlet format_results (l : (char * int * balance) list) : string =\n  let aux (c, v, b) =\n    let s = repeat c v\n    and b =\n      match b with\n      | First -> \"1\"\n      | Second -> \"2\"\n      | Equal -> \"=\"\n    in\n    b ^ \":\" ^ s\n  in\n  List.map aux l |> List.sort entry_compare |> String.concat \"\/\"\n;;\n\nlet mix_strings (ss1 : string) (ss2 : string) : string =\n  let h1: string_table = Hashtbl.create 100\n  and h2: string_table = Hashtbl.create 100 in\n  let _ = to_table (lowercase_filter ss1) h1\n  and _ = to_table (lowercase_filter ss2) h2 in\n  to_list h1 h2 |> format_results\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217216,"user_id":null,"body":"let toInt s = \n  let t = Array.make 26 0 in\n  for i=0 to String.length s -1 do\n    if int_of_char(s.[i])>96 && int_of_char(s.[i])<123 then \n      (t.(int_of_char(s.[i]) - 97) <- t.(int_of_char(s.[i]) - 97)  +1 ) ; done;\n  t;;\n  \nlet texteur c1 c2 i =\n  \n  let rep = ref \"\" in\n  if c1 > c2 then\n    ( rep := (!rep) ^ \"1:\";\n      for j = 1 to c1 do rep:= !rep ^ (String.make 1 (char_of_int(i+97))) ; done\n    );\n  if c1< c2 then \n    ( rep := (!rep) ^ \"2:\";\n      for j = 1 to c2 do rep:= !rep ^ (String.make 1 (char_of_int(i+97))) ; done\n    );\n  if c1 = c2 then \n    ( rep := (!rep) ^ \"=:\";\n      for j = 1 to c1 do rep:= !rep ^ (String.make 1 (char_of_int(i+97))) ; done\n    );!rep\n;;\n\nlet op x y= \n  if (String.length x = String.length y)then\n    (x<y) \n  else\n    String.length x > String.length y\n;;\n\nlet comparateur t1 t2 =\n  let ans = ref [] in\n  let temp1 = ref 0 in\n  let temp2 = ref 0 in\n  for i =0 to 25 do \n    temp1 := t1.(i) ;\n    temp2 := t2.(i) ;\n    if (!temp1 > 1 || !temp2 > 1 ) then\n      \n      (ans :=  (texteur !temp1 !temp2 i) :: !ans) ; done;\n  !ans ;; \n\nlet rec fission q=match q with\n  | [] | [_] -> q, []\n  | x::y::p -> let a,b=fission p in x::a, y::b\n;;\nlet rec fusion p1 p2 op=match p1, p2 with\n  | [],_ -> p2\n  | _, [] -> p1\n  | x::q1, y::_ when op x y -> x::(fusion q1 p2 op)\n  | _,x::q2 -> x::(fusion p1 q2 op)\n;;\n\nlet rec tri_fusion p op=match p with\n  | [] | [_] -> p\n  | _ -> let a,b=fission p in fusion (tri_fusion a op) (tri_fusion b op) op\n;;\n\nlet toStri t =\n  let rec aux t ans = match t with\n    |[]-> \"\"\n    |[p] -> ans^p\n    |p::q-> aux q (ans^p^\"\/\")\n  in\n  aux t \"\";; \n\nlet mix_strings (ss1: string) (ss2: string): string =\n  let titi = toInt ss1  in\n  let toto = toInt ss2 in\n  let test = comparateur titi toto in\n  let rep =tri_fusion test op in\n  toStri rep\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217217,"user_id":null,"body":"let mix_strings (ss1: string) (ss2: string): string =\n\tlet t = Array.make_matrix 26 2 0 in\n\n\tlet itr n ch =\n\t\tlet c = Char.code ch - 97 in\n\t\tif 0 <= c && c <= 25 then\n\t\t\tt.(c).(n) <- t.(c).(n) + 1 in\n\n\tString.iter (itr 0) ss1;\n\tString.iter (itr 1) ss2;\n\t\t\n\tlet mpi i = function\n\t\t| [|a; b|] when a > b -> \"1:\" ^ String.make a (Char.chr (i + 97))\n\t\t| [|a; b|] when a < b -> \"2:\" ^ String.make b (Char.chr (i + 97))\n\t\t| [|a; _|] -> \"=:\" ^ String.make a (Char.chr (i + 97)) \n\t\t| _ -> failwith \"Nop\" in\n\n\tlet filtr s = String.length s > 3 in\n\t\n\tlet cp a b =\n\t\tStdlib.compare (String.length b) (String.length a) in\n\t\n\tt |> Array.to_list |> List.mapi mpi |> List.filter filtr |> List.sort Stdlib.compare\n\t  |> List.stable_sort cp |> String.concat \"\/\";;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217218,"user_id":null,"body":"module CharMap = Map.Make(Char);;\n\nlet get_lowercase s =\n  let res = ref CharMap.empty in\n  String.iter (fun c -> if int_of_char c - int_of_char 'a' >= 0 && int_of_char 'z' - int_of_char c >= 0 then\n    try\n      let cnt = CharMap.find c !res in\n      res := CharMap.add c (cnt + 1) !res\n    with Not_found -> res := CharMap.add c 1 !res\n  ) s;\n  CharMap.filter (fun c i -> i > 1) !res;;\n\nlet rec string_of_list = function\n  [] -> \"\"\n  | (c, cnt, side) :: [] -> (if side = 3 then \"=\" else string_of_int side) ^ \":\" ^ (String.make cnt c)\n  | h :: t -> string_of_list (h :: []) ^ \"\/\" ^ string_of_list t;;\n\nlet mix_strings (ss1: string) (ss2: string): string =\n  let letters = ref (CharMap.map (fun x -> (x, 1)) (get_lowercase ss1)) in\n  \n  CharMap.iter (fun c i ->\n    try\n      let (cnt, _) = CharMap.find c !letters in\n      if cnt < i then letters := CharMap.add c (i, 2) !letters\n      else if cnt = i then letters := CharMap.add c (i, 3) !letters\n    with Not_found -> letters := CharMap.add c (i, 2) !letters) (get_lowercase ss2);\n    \n  let res = ref [] in\n  CharMap.iter (fun c (cnt, side) -> res := !res @ [(c, cnt, side)]) !letters;\n  \n  let compare a b = if a < b then -1 else if a = b then 0 else 1 in\n  string_of_list (List.sort (fun (_, ln1, x) (_, ln2, y) -> if compare ln2 ln1 = 0 then compare x y else compare ln2 ln1) !res);;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217219,"user_id":null,"body":"module MyMap = Map.Make(Char)\n \nlet mix_strings (ss1: string) (ss2: string): string =\n  let remove_upper s = String.concat \"\" (Str.split (Str.regexp \"[^a-z]\") s) in\n  let s1 = remove_upper ss1 and s2 = remove_upper ss2 in\n  let cont_let s =\n    let m = ref (MyMap.empty) in\n    let len = String.length s in\n    for i = 0 to len - 1 do\n      m :=  if MyMap.mem s.[i] !m\n            then MyMap.add s.[i] (succ (MyMap.find s.[i] !m)) !m\n            else\n              MyMap.add s.[i] 1 !m;\n    done;\n    !m\n  in\n  let m1 = cont_let s1 and m2 = cont_let s2 in  \n  let m = MyMap.empty in\n  let m = MyMap.merge (fun key a b -> match a, b with\n                            | Some x, Some y when x > y -> Some((x, \"1:\" ^ String.make x key))\n                            | Some x, Some y when x < y -> Some((y, \"2:\" ^ String.make y  key))\n                            | Some x, Some y when x = y && x > 1 -> Some((x, \"=:\" ^ String.make x key))\n                            | Some x, None when x > 1 -> Some((x, \"1:\" ^ String.make x key))\n                            | None, Some x when x > 1 -> Some((x, \"2:\" ^ String.make x key))\n                            | _, _ -> None) m1 m2\n  in\n  let l = MyMap.bindings m in \n  let comp x y = if fst (snd  x) <> fst (snd y) then (fst (snd y)) - (fst (snd x)) else String.compare (snd (snd x)) (snd (snd y)) in\n  l\n  |> List.fast_sort comp\n  |> List.map (fun x -> snd (snd x))\n  |> String. concat \"\/\"\n   \n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217220,"user_id":480,"body":"open Printf;;\nopen Map;;\n\nmodule MapChar=Map.Make(Char);;\n\nlet mapkeys m=MapChar.fold (fun k v acc->k::acc) m [] |> List.sort Char.compare;;\n\nlet mix_strings (ss1: string) (ss2: string): string =\n  let islower c=c>='a' && c<='z' in\n  let freq s=s |> String.to_seq |> Seq.filter islower |> Seq.fold_left (fun m c-> \n    match MapChar.find_opt c m with |None -> MapChar.add c 1 m | Some(n)-> MapChar.add c (n+1) m\n  ) MapChar.empty in\n  let gt1 _ v=v>1 in\n  let (f1,f2)=(freq ss1|>MapChar.filter gt1,freq ss2|>MapChar.filter gt1) in\n  let keys=List.sort_uniq Char.compare ((mapkeys f1)@(mapkeys f2)) in\n  let mget m k default=match MapChar.find_opt k m with |None->default |Some(v)->v in\n  let max a b=if a>=b then a else b in\n  let right k=max (mget f1 k 0) (mget f2 k 0) in\n  let keys=keys |> List.sort (fun a b -> (right b)-(right a)) in\n  let left k=let (a,b)=(mget f1 k 0,mget f2 k 0) in if a>b then \"1\" else if b>a then \"2\" else \"=\" in\n  let pair k= [left k;String.make (right k) k] in\n  let leftval k=match k with |\"1\"->1|\"2\"->2|_->3 in\n  let compare a b =\n    let (a1,b1)=(List.nth a 1, List.nth b 1) in\n    let (lb,la)=(String.length b1, String.length a1) in \n    if lb==la then \n      let (va,vb)=(leftval (List.hd a), leftval (List.hd b)) in\n      if va == vb then ((String.get a1 0)|>Char.code)-((String.get b1 0)|>Char.code) else va-vb\n    else lb-la\n  in\n  keys |> List.map pair |> List.sort compare |> List.map (String.concat \":\") |> String.concat \"\/\";;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217221,"user_id":null,"body":"module CharMap = Map.Make(Char)\n\nmodule CharSet = Set.Make(Char)\n\ntype maximum_occurrence = { letter : char; count : int; arg : char }\n\n\nlet count_lowercase s = \n    let is_lowercase_char c = \n        let code = Char.code c in \n        97 <= code && code <= 122 in\n    let lowercase_chars = s |> String.to_seq |> Seq.filter is_lowercase_char |> List.of_seq in\n    let update counts c = match CharMap.find_opt c counts with\n        | None -> CharMap.add c 1 counts\n        | Some v -> CharMap.add c (v + 1) counts in \n    List.fold_left update CharMap.empty lowercase_chars\n    \n    \nlet sort_maximum_occurrences maximums = \n    let compare m1 m2 = \n        if m1.count < m2.count then 1\n        else if m1.count > m2.count then -1\n        else if m1.arg < m2.arg then -1\n        else if m1.arg > m2.arg then 1\n        else Stdlib.compare m1.letter m2.letter in\n    List.sort compare maximums\n  \n  \nlet stringify maximums = \n    let represent {letter; count; arg} = \n        (Char.escaped arg) ^ \":\" ^ String.make count letter in\n    maximums |> List.map represent |> String.concat \"\/\"\n    \nlet mix_strings (s1: string) (s2: string): string =\n    let get_counts s = \n        s |> count_lowercase |> CharMap.filter (fun _ c -> c > 1) in\n    let get_keys m1 m2 = \n        let keys1 = CharMap.fold (fun k _ acc -> k :: acc) m1 [] in\n        let keys2 = CharMap.fold (fun k _ acc -> k :: acc) m2 [] in\n        CharSet.union (CharSet.of_list keys1) (CharSet.of_list keys2) in\n    let counts1 = get_counts s1 in\n    let counts2 = get_counts s2 in\n    let common_chars = get_keys counts1 counts2 in\n    let get_or_else m k = match CharMap.find_opt k m with\n        | None -> 0\n        | Some v -> v in\n    let select_maximum c acc = \n        let c1 = get_or_else counts1 c in\n        let c2 = get_or_else counts2 c in\n        let char_maximum_occurrence = \n            if c1 > c2 then { letter = c; count = c1; arg = '1' }\n            else if c1 < c2 then { letter = c; count = c2; arg = '2' }\n            else { letter = c; count = c1; arg = '=' } in\n        char_maximum_occurrence :: acc in    \n    let maximums = CharSet.fold select_maximum common_chars [] in\n    let sorted_maximums = sort_maximum_occurrences maximums in\n    stringify sorted_maximums\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217222,"user_id":null,"body":"let offset = int_of_char 'a';;\n\nlet string_histogram str =\n  let histo = Array.make 26 0 in\n  String.iter (function c -> if c >= 'a' && c <= 'z' then\n                               let i = int_of_char c - offset in\n                               histo.(i) <- histo.(i) + 1)\n              str;\n  histo;;\n\n(* Oddly, if you use 'compare' here instead of 'Stdlib.compare', you end up causing the test\n   fixture to fail to compile. *)\nlet group_compare a b =\n  let v = Stdlib.compare (String.length a) (String.length b) in\n  if v = 0 then Stdlib.compare a b else -v;;\n\nlet mix_strings (s1:string) (s2:string): string = \n  let h1 = string_histogram s1 in\n  let h2 = string_histogram s2 in\n  let elts = ref [] in\n  for i = 0 to 25 do\n    let c = char_of_int (i+offset) in\n    if h1.(i) > h2.(i) && h1.(i) > 1 then\n      elts := (\"1:\" ^ (String.make h1.(i) c))::!elts\n    else if h2.(i) > 1 then\n      let max = if h1.(i) = h2.(i) then \"=:\" else \"2:\" in\n      elts := (max ^ (String.make h2.(i) c))::!elts\n  done;\n  String.concat \"\/\" (List.sort group_compare !elts);;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"562b384167350ac93b00010c":[{"id":217223,"user_id":53,"body":"let rec gcd a b = if b == 0 then a else gcd b (a mod b) ;;\n  \nlet count_ones(n: int): int =\n  let a = ref 7 in\n  let i = ref 1 in\n  let s = ref 1 in\n  while !i < n do\n    i := !i + 1;\n    let g = gcd !i !a in\n    a := !a + g;\n    if g == 1 then s := !s + 1;\n  done;\n  !s ;;\n\nlet max_pn(n: int): int = \n  let a = ref 7 in\n  let i = ref 1 in\n  let k = ref 0 in\n  let m = ref 0 in\n  let s = Array.make 10000000 0 in\n  while !k <= n do\n    i := !i + 1;\n    let g = gcd !i !a in\n    a := !a + g;\n    if s.(g) == 0 then begin\n      k := !k + 1;\n      s.(g) <- 1;\n      if g > !m then m := g;\n    end\n  done;\n  !m ;;\n\nlet an_over_average n =\n  let a = ref 7 in\n  let i = ref 1 in\n  let s = ref 0 in\n  while !s < n do\n    i := !i + 1;\n    let g = gcd !i !a in\n    a := !a + g;\n    if g > 1 then s := !s + 1;\n  done;\n  !a \/ !i ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217224,"user_id":null,"body":"module Sequence = Core_kernel.Sequence \n\nlet rec gcd a b =\n  if a = b then a\n  else if a > b then (gcd (a - b) b)\n  else gcd a (b - a)\n  \nlet seq_a = Sequence.unfold\n  ~init:(1,7)\n  ~f:(fun (n,x) -> Some (x, (n+1, x + gcd (n+1) x)))\n  \nlet seq_g = \n  let g =\n    Sequence.zip seq_a (Sequence.drop seq_a 1)\n    |> Sequence.map ~f:(fun (a, b) -> b - a)\n  in\n  Sequence.append (Sequence.of_list [1]) g\n  \nlet seq_p' = Sequence.filter seq_g ~f:(function 1 -> false | _ -> true)\n  \nlet seq_p =\n  let open Core.Std in\n  Sequence.unfold_step\n  ~init:(seq_p', Int.Set.empty)\n  ~f:(fun (s, seen) -> match Sequence.hd s, Sequence.tl s with\n    | Some hd, Some tl when not (Int.Set.mem seen hd) ->\n       Sequence.Step.Yield (hd, (tl, Int.Set.add seen hd))\n    | Some hd, Some tl ->\n       Sequence.Step.Skip (tl, seen)\n    | _ ->\n       Sequence.Step.Done)\n       \nlet seq_an_over =\n  Sequence.filter_mapi (Sequence.zip seq_a seq_g) ~f:(fun i (a,g) ->\n    match g with\n      | 1 -> None\n      | _ -> Some (a \/ (i + 1)))\n      \nlet an n = Sequence.take seq_a n |> Sequence.to_list\nlet gn n = Sequence.take seq_g n |> Sequence.to_list\n\nlet count_ones(n: int): int =\n  Sequence.take seq_g n\n  |> Sequence.filter ~f:(function 1 -> true | _ -> false)\n  |> Sequence.length\n  \nlet p n = Sequence.take seq_p n |> Sequence.to_list\n  \nlet max_pn(n: int): int = \n  let open Core.Std in\n  List.max_elt ~cmp:Int.compare (p n)\n  |> Option.value ~default:0\n  \nlet an_over n = Sequence.take seq_an_over n |> Sequence.to_list\n  \nlet an_over_average n =\n  let open Core.Std in\n  let x = List.fold ~init:0 ~f:(fun acc f -> acc + f) (an_over n) in\n  x \/ n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217225,"user_id":168,"body":"let rec gcd a b = if b = 0 then a else gcd b (a mod b)\n\nlet count_ones(n: int): int =\n  let rec loop acc i a g =\n    if i >= n then acc\n    else\n      let g' = gcd (i + 1) a in\n      loop (acc + if g' = 1 then 1 else 0) (succ i) (a + g') g' in\n  loop 1 1 7 1\n\nlet max_pn(n: int): int =\n  let module IntSet = Set.Make (struct type t = int let compare = compare end) in\n  let rec loop acc k i a g =\n    if k >= n then acc\n    else\n      let g' = gcd (i + 1) a in\n      if g' > 1 && not (IntSet.mem g' acc) then\n        loop (IntSet.add g' acc) (succ k) (succ i) (a + g') g'\n      else\n        loop acc k (succ i) (a + g') g' in\n  IntSet.max_elt (loop IntSet.empty 0 1 7 1)\n\nlet an_over_average n =\n  let rec loop acc k i a g =\n    if k >= n then acc\n    else\n      let g' = gcd (i + 1) a in\n      let a' = a + g' in\n      if g' > 1 then\n        loop (acc +. float a' \/. float (i + 1)) (succ k) (succ i) a' g'\n      else\n        loop acc k (succ i) a' g' in\n  truncate (loop 0. 0 1 7 1 \/. float n)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217226,"user_id":492,"body":"let count_ones(n: int): int =\n  let gn(n: int): int list =\n    let rec aux prev i acc =\n      match i with \n        | x when x > n -> acc\n        |_ -> let nou = prev + (gcdi_ prev i) in\n              aux nou (i+1) ((nou - prev) :: acc)\n    in\n      aux 7 2 [1] |> List.rev\n  in\n    gn n |> List.filter(fun x -> x = 1) |> List.length;;\n\nlet max_pn(n: int): int = \n  let pn(n: int): int list =\n    let rec aux prev i acc cnt =\n      match cnt with \n        | x when x >= n -> acc\n        |_ -> let nou = prev + (gcdi_ prev i) in\n            let d = nou - prev in\n              if d <> 1 && (List.exists (fun x -> x = d) acc) = false then \n                aux nou (i+1) ((nou - prev) :: acc) (cnt+1)\n              else\n                aux nou (i+1) acc cnt\n    in\n      aux 7 2 [] 0\n  in\n  let rec maxi = function\n    [] -> invalid_arg \"empty list\"\n  | x::xs -> List.fold_left max x xs\n  in\n    maxi (pn n);;\n\nlet an_over_average n =\n  let an_overn(n: int): int list =\n    let rec aux prev i acc cnt =\n      match cnt with \n        | x when x >= n -> acc\n        |_ -> let nou = prev + (gcdi_ prev i) in\n            let d = nou - prev in\n              if d <> 1 then \n                aux nou (i+1) ((nou \/ i) :: acc) (cnt+1)\n              else\n                aux nou (i+1) acc cnt\n    in\n      aux 7 2 [] 0\n  in\n  let a = an_overn n in\n    List.fold_left (+) 0 a \/ List.length a;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217227,"user_id":492,"body":"let count_ones(n: int): int =\n  let gn(n: int): int list =\n    let rec aux prev i acc =\n      match i with \n        | x when x > n -> acc\n        |_ -> let nou = prev + (gcdi_ prev i) in\n              aux nou (i+1) ((nou - prev) :: acc)\n    in\n      aux 7 2 [1] |> List.rev\n  in\n    gn n |> List.filter(fun x -> x = 1) |> List.length;;\n\nlet max_pn(n: int): int = \n  let pn(n: int): int list =\n    let rec aux prev i acc cnt =\n      match cnt with \n        | x when x >= n -> acc\n        |_ -> let nou = prev + (gcdi_ prev i) in\n            let d = nou - prev in\n              if d <> 1 && (List.exists (fun x -> x = d) acc) = false then \n                aux nou (i+1) ((nou - prev) :: acc) (cnt+1)\n              else\n                aux nou (i+1) acc cnt\n    in\n      aux 7 2 [] 0\n  in\n  let rec maxi = function\n    [] -> invalid_arg \"empty list\"\n  | x::xs -> List.fold_left max x xs\n  in\n    maxi (pn n);;\n\nlet an_over_average n =\n  let an_overn(n: int): int list =\n    let rec aux prev i acc cnt =\n      match cnt with \n        | x when x >= n -> acc\n        |_ -> let nou = prev + (gcdi_ prev i) in\n            let d = nou - prev in\n              if d <> 1 then \n                aux nou (i+1) ((nou \/ i) :: acc) (cnt+1)\n              else\n                aux nou (i+1) acc cnt\n    in\n      aux 7 2 [] 0\n  in\n  let a = an_overn n in\n    List.fold_left (+) 0 a \/ List.length a;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"562e274ceca15ca6e70000d3":[{"id":217228,"user_id":null,"body":"let rec lenCurve2 interval counter x1 y1 answer =\n  match counter with\n  | 0 -> answer\n  | _ -> let x2 = x1 +. interval in\n         let y2 = x2 *. x2 in\n         let distance = sqrt ((x2-.x1)*.(x2-.x1) +. (y2-.y1)*.(y2-.y1)) in\n         lenCurve2 interval (counter-1) x2 y2 (answer+.distance);;\n\nlet lenCurve (n: int): float =\n  let interval = 1.0 \/. (float_of_int n) in\n  lenCurve2 interval n 0.0 0.0 0.0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217229,"user_id":null,"body":"let lenCurve (n: int) =\n  let points = List.init (n+1) (fun i -> let x = Float.of_int i \/. Float.of_int n in x, x*.x) in\n  let rec loop buff = function\n    | (x1, y1)::(x2, y2)::q -> loop (buff +. Float.sqrt ((x1-.x2)**2. +. (y1-.y2)**2.)) ((x2, y2)::q)\n    | _ -> buff in\n  loop 0. points;;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217230,"user_id":480,"body":"open Float\nopen List\n\nlet rec range a b =\n    if a > b then []\n    else a :: range (a+1) b;;\n\nlet sum l =\n  let rec aux acc = function\n    | [] -> acc\n    | h::t -> aux (acc +. h) t\n  in\n  aux 0.0 l;;\n  \nlet _lenCurve f a b n =\n  let h=(b -. a) \/. (float_of_int n) in\n  let h2 = h *. h in\n  sum (map (fun i->(sqrt (h2+.(pow ((f (a+.(float_of_int i)*.h)) -. (f (a+.(float_of_int (i-1)*.h)))) 2.0)))) (range 1 n));;\n  \nlet lenCurve (n: int) = \n  _lenCurve (fun x->x*.x) 0.0 1.0 n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217231,"user_id":null,"body":"let lenCurve (n: int) =\n    let f x = x *. x in\n    let delta = 1.0 \/. (float_of_int n) in\n    let ys = List.init (n + 1) (fun ix -> f ((float_of_int ix) *. delta)) in\n    let arc_length y1 y2 = hypot delta (y2 -. y1) in\n    fst @@ List.fold_left \n        (fun (acc, y_prev) y_now -> (acc +. (arc_length y_prev y_now), y_now)) \n        (0.0, List.hd ys) \n        (List.tl ys)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217232,"user_id":null,"body":"let delta n k = \n  let n' = float_of_int n in\n  let k' = float_of_int k in\n  let x1 = (k' \/. n') in\n  let x2 = ((k' +. 1.) \/. n') in\n  let y1 = x1 *. x1 in\n  let y2 = x2 *. x2 in\n  sqrt ((y1 -. y2) *. (y1 -. y2) +. 1. \/. n' \/. n') \n\nlet lenCurve (n: int) =\n  let acc = ref 0. in \n  for i = 0 to (n - 1) do\n    acc := !acc +. delta n i\n  done;\n  !acc","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217233,"user_id":null,"body":"# 2 solution\n\nlet lenCurve (n: int) =\n  let lo,hi = 0., 1. in\n  let f x = x *. x in\n  let delta = (hi -. lo) \/. float_of_int n in\n  let delta2 = delta *. delta in\n  let len = ref 0.0 in\n  let xi = ref lo in (* last point x,y *)\n  let yi = ref (f !xi) in\n  for i = 0 to n-1 do\n    let xn = !xi +. delta in\n    let yn = f xn in\n    len := !len +. sqrt (delta2 +. (yn -. !yi) *. (yn -. !yi));\n    xi := xn; yi := yn;\n  done;\n  !len","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217234,"user_id":168,"body":"let lenCurve (n: int) =\n  let rnd x = floor (x *. 1e9) \/. 1e9 in\n  let xs = Array.init (n + 1) (fun i -> float i \/. float n) in\n  let ps = Array.map (fun x -> x, x *. x) xs in\n  Array.fold_left\n    (fun (s, (x0, y0)) (x1, y1) ->\n      s +. sqrt ((x1 -. x0) ** 2. +. (y1 -. y0) ** 2.), (x1, y1))\n    (0., (0., 0.)) ps \n  |> fst |> rnd","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217235,"user_id":527,"body":"open Batteries\n\nlet lenCurve (n: int) =\n  let n' = float_of_int n in\n  (Enum.fsum @@ Enum.map (fun i -> hypot (2. *. i +. 1.) n') @@ Enum.map float_of_int (0--^n)) \/. (n' *. n')","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217236,"user_id":null,"body":"let lenCurve (n: int) =\n  let rec loop i n =\n    if i == n then 0. \n    else\n      let dist x n = sqrt ((((x +. 1.) \/. n)**2. -. (x\/. n)**2. )**2. +. (1.\/.n)**2. )\n      in (dist (float_of_int i) (float_of_int n)) +. (loop (i+1) n)\n  in loop 0 n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217237,"user_id":492,"body":"let trunc9Dble (d: float) = float_of_int(int_of_float(d *. 1e9)) \/. 1e9;;\nlet seglg (n: float) (k: float): float = \n  let a = ((k +. 1.0) \/. n -. k \/. n) *. ((k +. 1.0) \/. n -. k \/. n) in\n  let b = (((k +. 1.0) \/. n) *. ((k +. 1.0) \/. n) -. (k \/. n) *. (k \/. n)) in\n    sqrt (a +. b *. b);;\nlet rec lenCurveAux (n: float) (k: float) (sm: float): float =\n  if (int_of_float k == int_of_float n) then sm\n  else lenCurveAux n (k +. 1.0) (sm +. (seglg n k));;\nlet lenCurve (n: int) = lenCurveAux (float_of_int(n)) 0.0 0.0 |> trunc9Dble;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"562f91ff6a8b77dfe900006e":[{"id":217238,"user_id":492,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let rec helper (i: int) (sb: float) (sa: int) (prev: float): int =\n    if (int_of_float(ceil sb) < sa) then i\n    else\n      let nou = prev *. perc in\n        helper (i + 1) (sb +. nou) (sa + ticket) nou \n  in\n    helper 0 (float card) 0 (float ticket);;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217239,"user_id":null,"body":"let movie (card : int) (ticket : int) (perc : float) : int =\n  let round = (fun v -> if v < 0.5 then floor v else ceil v) in\n  let rec _movie (index : int) (prev_ticket_sum: float) =\n    let ticket_sum =\n      List.fold_left\n        (fun res v -> res *. v)\n        (Float.of_int ticket)\n        (List.init index (fun _ -> perc))\n      |> ( +. ) prev_ticket_sum\n    in\n    if Float.of_int card +. (ticket_sum |> round) < Float.of_int ticket *. Float.of_int index then\n      index\n    else _movie (index + 1) ticket_sum\n  in\n\n  _movie 1 0.\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217240,"user_id":null,"body":"let systemA (ticket: float) (n: float) = ticket *. n;;\n\nlet rec systemB (ticket: float) (perc: float) (n: float) (total: float) =\n    if n = 0.0 then total else\n        systemB (ticket*.perc) perc (n-.1.0) (total+.ticket*.perc);;\n\nlet rec systems ticket (perc: float) (n: float) (total: float) =\n    if truncate (floor (systemB ticket perc n total +. 1.0)) < truncate (systemA ticket n) then n else\n        systems ticket perc (n+.1.0) total;;\n\nlet movie (card: int) (ticket: int) (perc: float): int =\n    truncate (systems (float_of_int ticket) perc 0.0 (float_of_int card));;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217241,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let ti = Float.of_int ticket in\n  let rec loop n a b t =\n    if a > Float.ceil b then n else\n    loop (n+1) (a +. ti) (b +. t *. perc) (t *. perc) in\n  loop 0 0. (Float.of_int card) (ti);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217242,"user_id":null,"body":"let systemA ticket n = ticket * n \n\nlet rec apply_perc ticketf perc i =\n  if i = 0 then ticketf else apply_perc ticketf perc (i - 1) *. perc\n\nlet n_tickets ticket perc n =\n  List.init n (fun i -> apply_perc ticket perc (i+1)) |> List.fold_left (+.) 0.\n\nlet systemB card ticket perc n =\n  let ticketf = Float.of_int ticket in\n  let cardf = Float.of_int card in\n  \n  Float.ceil (cardf +. (n_tickets ticketf perc n)) |> Float.to_int\n    \nlet movie (card: int) (ticket: int) (perc: float): int =\n  let rec is_better i =\n    let a = systemA ticket i in\n    let b = systemB card ticket perc i in\n    if b < a then i\n    else is_better (i+1)\n  in\n  is_better 0\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217243,"user_id":null,"body":"let system_a_price ticket time = float_of_int (ticket * time) ;;\n\nlet rec sum_and_pow number time = \n  match time with\n  | 1 -> number\n  | _ -> number ** (float_of_int time) +. sum_and_pow number (time - 1)\n  ;;\n\nlet system_b_price card ticket perc time = (float_of_int card) +. (float_of_int ticket) *. (sum_and_pow perc time) ;;\n\nlet round_up nb_float = (int_of_float nb_float) + 1 ;;\n\nlet rec _movie card ticket perc time = \n  if (system_a_price ticket time) > (float_of_int (round_up (system_b_price card ticket perc time) ) )\n  then time\n  else _movie card ticket perc (time + 1)\n  ;;\n\nlet movie (card: int) (ticket: int) (perc: float): int =\n  _movie card ticket perc 1    \n  ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217244,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let rec step (a: float) (b: float) (prev: float) (counter: int): int =\n    if a > ceil(b) then\n      counter\n    else\n      let cur = prev *. perc in\n      step (a +. float ticket) (b +. cur) (cur) (counter + 1)\n  in\n  step (float ticket) (float card +. float ticket) (float ticket) (0)\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217245,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let count = ref 1 in\n  let ticketB = ref ((float_of_int ticket) *. perc) in\n  let priceB = ref (float_of_int card +. !ticketB) in\n    while (ceil(!priceB) >= float_of_int (!count * ticket)) do\n      ticketB := !ticketB *. perc;\n      priceB := !priceB +. !ticketB;\n      count := !count + 1;\n    done;\n    !count\n      ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217246,"user_id":null,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let tick = float_of_int ticket\n  in\n  let priceA n = n*ticket\n  in\n  let rec price_rec price n =\n    let priceB = price +. tick*.(perc**n)\n    in\n    if (priceA (int_of_float n))  > ( int_of_float priceB)+1 then\n      n\n    else\n      price_rec priceB (n+.1.)\n  in\n  int_of_float (price_rec (float_of_int card) 1.);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217247,"user_id":480,"body":"let movie (card: int) (ticket: int) (perc: float): int =\n  let rec best sumn ticketn n=\n    let ticketn1=ticketn*.perc in\n    let sumn1=sumn+.ticketn1 in\n    if (int_of_float (ceil sumn1))<(ticket*(n)) then n else best sumn1 ticketn1 (n+1)\n  in\n  best (float_of_int card) (float_of_int ticket) 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56347fcfd086de8f11000014":[{"id":217248,"user_id":168,"body":"let f x y = 2. -. exp (-4. *. x) -. 2. *. y\n\nlet sol x = 1. +. 0.5 *. exp (-4. *. x) -. 0.5 *. exp (-2. *. x)\n\nlet rnd x = floor (x *. 1e6) \/. 1e6\n\nlet exEuler(nb: int): float = \n  let x0 = 0. in\n  let y0 = 1. in\n  let time = 1. in\n  let h = time \/. float nb in\n  let rec integrate acc i y =\n    if i > nb then acc\n    else\n      let x = x0 +. h *. float i in\n      let z = sol x in\n      let err = abs_float ((y -. z) \/. z) in\n      let y' = y +. f x y *. h in\n      integrate (acc +. err) (succ i) y' in\n  rnd (integrate 0. 0 y0 \/. float (nb + 1))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217249,"user_id":492,"body":"let f(t: float) (y: float): float =\n  2.0 -. exp(-4.0 *. t) -. 2.0 *. y;;\n\nlet euler(t0: float) (y0: float) (t: float) (n: int): float array array = \n  let h = t \/. (float_of_int n) in\n  let xtab = Array.make (n + 1) 0.0 in\n    xtab.(0) <- t0;\n    let ytab = Array.make (n + 1) 0.0 in\n      ytab.(0) <- y0;\n      for x = 1 to n do\n        xtab.(x) <- (float_of_int x) *. h;\n        for x = 0 to n - 1 do\n          ytab.(x+1) <- ytab.(x) +. h *. (f xtab.(x) ytab.(x));\n        done;\n      done;\n      [|xtab; ytab|];;\n\nlet exEuler(nb: int): float =\n  let t0 = 0.0 in\n  let y0 = 1.0 in\n  let t = 1.0 in\n  let (ztab: float array) = Array.make (nb + 1) 0.0 in\n  let e: float array array = euler t0 y0 t nb in\n  let xtab: float array = e.(0) in\n  let ytab: float array  = e.(1) in\n  let s = ref 0.0 in\n    for k = 0 to nb do\n      ztab.(k) <- 1.0 +. 0.5 *. exp(-4.0 *. xtab.(k)) -. 0.5 *. exp(-2.0 *. xtab.(k));\n      s := !s +. abs_float(ytab.(k) -. ztab.(k)) \/. ztab.(k);\n    done;\n    let res = !s \/. ((float_of_int nb) +. 1.0) in\n      floor(res *. 1e6) \/. 1e6;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217250,"user_id":null,"body":"let exEuler (n : int): float =\n    let f x y = 2.0 -. exp(-4.0 *. x) -. 2.0 *. y in\n    let g x = 1.0 +. 0.5 *. (exp(-4.0 *. x) -. exp(-2.0 *. x)) in\n    let h = 1.0 \/. float_of_int n in\n    let truncate r =  floor (r *. 1000000.0) \/. 1000000.0 in\n    let xs = List.init n (fun ix -> (float_of_int (ix + 1)) *. h) in\n    let process (errors, y_prev) x_new = \n        let x_prev = x_new -. h in\n        let y_new = y_prev +. h *. (f x_prev y_prev) in\n        let z_new = g x_new in\n        let rel_err = abs_float (y_new -. z_new) \/. z_new in\n        (rel_err :: errors, y_new) in\n    let relative_errors = fst @@ List.fold_left process ([0.0], 1.0) xs in\n    let mean_error = (List.fold_left (+.) 0.0 relative_errors) \/. float_of_int (n + 1)\n    in truncate mean_error\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217251,"user_id":492,"body":"let f(t: float) (y: float): float =\n  2.0 -. exp(-4.0 *. t) -. 2.0 *. y;;\n\nlet euler(t0: float) (y0: float) (t: float) (n: int): float array array = \n  let h = t \/. (float_of_int n) in\n  let xtab = Array.make (n + 1) 0.0 in\n    xtab.(0) <- t0;\n    let ytab = Array.make (n + 1) 0.0 in\n      ytab.(0) <- y0;\n      for x = 1 to n do\n        xtab.(x) <- (float_of_int x) *. h;\n        for x = 0 to n - 1 do\n          ytab.(x+1) <- ytab.(x) +. h *. (f xtab.(x) ytab.(x));\n        done;\n      done;\n      [|xtab; ytab|];;\n\nlet exEuler(nb: int): float =\n  let t0 = 0.0 in\n  let y0 = 1.0 in\n  let t = 1.0 in\n  let (ztab: float array) = Array.make (nb + 1) 0.0 in\n  let e: float array array = euler t0 y0 t nb in\n  let xtab: float array = e.(0) in\n  let ytab: float array  = e.(1) in\n  let s = ref 0.0 in\n    for k = 0 to nb do\n      ztab.(k) <- 1.0 +. 0.5 *. exp(-4.0 *. xtab.(k)) -. 0.5 *. exp(-2.0 *. xtab.(k));\n      s := !s +. abs_float(ytab.(k) -. ztab.(k)) \/. ztab.(k);\n    done;\n    let res = !s \/. ((float_of_int nb) +. 1.0) in\n      floor(res *. 1e6) \/. 1e6;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"563b662a59afc2b5120000c6":[{"id":217252,"user_id":492,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  if (p0 >= p) then 0\n  else\n    (nb_year (int_of_float(float_of_int(p0) +. float_of_int(p0) \/. 100.0 *. percent +. float_of_int(aug))) percent aug p) + 1;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217253,"user_id":null,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n  let n = p0 + Float.to_int ((Float.of_int p0) *. (percent \/. 100.0)) + aug in\n    if n >= p then 1 else 1 + nb_year n percent aug p;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217254,"user_id":401,"body":"\nlet get_inhabitants_in_next_year (p0: int) (percent: float) (aug: int): int =\n  let percent_ratio = percent \/. 100. in\n  let born = float_of_int p0 *. percent_ratio in\n  p0 + aug + (int_of_float born)\n;;\n\nlet nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n  let rec nb_year_tail (p0: int) (year: int): int = \n    let next_population = get_inhabitants_in_next_year p0 percent aug in\n    if next_population >= p\n    then year + 1\n    else nb_year_tail next_population (year + 1) in\n  nb_year_tail p0 0\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217255,"user_id":492,"body":"let rec nb_year (p0: int) (percent: float) (aug: int) (p: int) =\n  if (p0 >= p) then 0\n  else\n    (nb_year (int_of_float(float_of_int(p0) +. float_of_int(p0) \/. 100.0 *. percent +. float_of_int(aug))) percent aug p) + 1;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217256,"user_id":null,"body":"let nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n  let rec aux current_population n =\n    if current_population >= p\n    then n\n    else (\n      let new_population =\n        current_population\n        + int_of_float (float_of_int current_population *. (percent \/. 100.))\n        + aug\n      in\n      aux new_population (n + 1)\n    )\n  in\n  aux p0 0\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217257,"user_id":null,"body":"let nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n  let foi = Float.of_int and\n      iof = Float.to_int in\n  let rec loop pop year =\n    if pop >= p then year else\n    let new_pop = pop + aug + iof (foi pop *. percent \/. 100.) in\n    loop new_pop (year + 1) in\n  loop p0 0","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217258,"user_id":null,"body":"let rec population2 p0 percent aug p years =\n    if p0 >= p then years else \n        let p1 = p0 + p0*(truncate(floor (percent*.100.0)))\/10000 + aug + 0*years in\n        population2 p1 percent aug p (years+1);;\n\nlet nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n    population2 p0 percent aug p 0;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217259,"user_id":null,"body":"open Format\n\nlet rec population2 p0 percent aug p years =\n    if p0 >= p then years else \n        let p1 = p0 + p0*(truncate(floor (percent*.100.0)))\/10000 + aug + 0*years in\n        population2 p1 percent aug p (years+1);;\n\nlet nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n    population2 p0 percent aug p 0;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217260,"user_id":null,"body":"let nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n  let rec nb_year' p percent aug pn n = \n    if p >= pn then \n      let () = Printf.printf \"%f >= %f\n\" p pn in n \n    else \n      let () = Printf.printf \"%f < %f\n\" p pn in\n    nb_year' (float_of_int (int_of_float (p +. p *. (percent \/. 100.) +. aug))) percent aug pn (n + 1) in\n  nb_year' (float_of_int p0) percent (float_of_int aug) (float_of_int p) 0\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217261,"user_id":null,"body":"let nb_year (p0: int) (percent: float) (aug: int) (p: int): int =\n  let rec loop p_new n =\n    if p_new >= p then n else loop (p_new + (int_of_float ((float_of_int p_new) \/. 100. *. percent)) + aug) (n+1)\n  in loop p0 0;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"563e320cee5dddcf77000158":[{"id":217262,"user_id":null,"body":"let sum = List.fold_left (+) 0\nlet get_average lst = sum lst \/ List.length lst","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217263,"user_id":null,"body":"let get_average = function\n  | [] -> 0\n  | l -> List.length l |> ( \/ ) @@  List.fold_left (+) 0 l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217264,"user_id":98,"body":"let get_average lst =\n\tlet rec sum lst =\n\t\tmatch lst with\n\t\t| [] -> 0\n\t\t| h :: t -> h + (sum t)\n\tin sum lst \/ List.length lst\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217265,"user_id":null,"body":"open List\nlet get_average lst = (fold_left (+) 0 lst)\/length(lst);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217266,"user_id":null,"body":"let rec summation lst sum = \n    match lst with\n        [] -> sum\n    |   h::t -> summation t (sum + h);;\n\nlet rec length lst len = \n    match lst with\n        [] -> len\n    |   h::t -> length t (len + 1);;\n    \nlet get_average lst = \n    summation lst 0 \/ length lst 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217267,"user_id":null,"body":"let rec get_average lst =\n  let rec sum l =\n    match l with\n    | [] -> 0\n    | x::l -> x + sum l in\n  let x = sum lst in x \/ (List.length lst);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217268,"user_id":null,"body":"let get_average lst =\n  let rec get_average_aux lst sum cont =\n    if lst != [] then get_average_aux (List.tl lst) (sum+(List.hd lst)) (cont+1)\n    else int_of_float (floor ((float_of_int sum) \/. (float_of_int cont))) in\n  get_average_aux lst 0 0;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217269,"user_id":null,"body":"let get_average lst =\n  let rec get_average_aux count sum lst = \n    match lst with \n    | [] -> (count, sum)\n    | head::tail -> get_average_aux (count + 1) (head + sum) tail in \n  let (c, s) = get_average_aux 0 0 lst in\n  s \/ c\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217270,"user_id":null,"body":"let rec len l = \n  match l with\n    [] -> 0\n  | h::t -> 1 + len t\n  \nlet rec sum l =\n  match l with\n    [] -> 0\n  | h::t -> h + sum t\n\nlet get_average l = sum l \/ len l\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217271,"user_id":null,"body":"let get_average lst =\n  let rec aux l sum size =\n    match l with\n      | [] -> (sum, size)\n      | a::q -> aux q (sum+a) (size+1) in\n  let a = aux lst 0 0 in\n  fst a \/ snd a;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"563f0c54a22b9345bf000053":[{"id":217272,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet fcn(n:int): string =\n    let two = num_of_int 2 in\n        string_of_num (power_num two (num_of_int n));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217273,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet fcn(n:int): string =\n    let two = num_of_int 2 in\n        string_of_num (power_num two (num_of_int n));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217274,"user_id":53,"body":"open Big_int;;\n\nlet fcn(n: int): string =\n  (string_of_big_int (power_big_int_positive_int (big_int_of_int 2) n)) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217275,"user_id":50,"body":"open Big_int\n\nlet fcn(n:int): string = string_of_big_int (n |> power_int_positive_int 2)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217276,"user_id":null,"body":"\nlet string_rev (str:string) =\n  let rec aux  idx = match idx with\n      0 -> Char.escaped (str.[0])\n    | _ -> (Char.escaped str.[idx]) ^ (aux (idx-1)) \n  and l = String.length str in\n  if l>0 then aux (l-1) else \"\"  ;;\n\nlet string_pop (str:string) =\n  let l = (String.length str)-1\n  in String.sub str 1 l;;\n\nlet string_first (str:string) =\n  String.sub str 0 1;;\n\nlet add_dig (a:string) (b:string) = \n  let rec aux_ad c d=\n    if  d=\"0\" then c\n    else if c=\"\" then d\n    else \n      let e = int_of_string (string_first c) and f = int_of_string d in \n      string_of_int((e+f) mod 10)^(aux_ad (string_pop c) (string_of_int((e+f)\/10)))\n  in string_rev (aux_ad (string_rev a) b);;    \n\nlet add (a:string) (b:string) =\n  let rec aux c d =\n    match (c,d) with \n    |(\"\",d) when d=\"0\" -> \"\"\n    |(\"\",d) -> d\n    |(c,\"\") when c=\"0\" -> \"\"\n    |(c,\"\")-> c  \n    |(c,d) -> let e = int_of_string (string_first c) and f =int_of_string (string_first d) in \n        string_of_int((e+f) mod 10) ^ (aux (aux (string_pop c) (string_pop d)) (string_of_int((e+f)\/10)))\n  in\n  string_rev (aux (string_rev a) (string_rev b));;\n\nlet mul_dig (a:string) (b:string) = \n  let rec aux_md c d=\n    if  d=\"0\" then \"0\"\n    else if d =\"1\" then c\n    else if c=\"\" then \"\"\n    else \n      let e = int_of_string (string_first c) and f = int_of_string d in \n      string_of_int((e*f) mod 10)^(string_rev(add_dig (string_rev (aux_md (string_pop c) d)) (string_of_int((e*f)\/10))))\n  in string_rev (aux_md (string_rev a) b);;   \n\nlet mul (a:string) (b:string) =   \n  let rec aux c d =\n    match (c,d) with \n    |(_,d) when d=\"0\" -> \"0\"\n    |(_,\"\") -> \"\"\n    |(c,_) when c=\"0\" -> \"0\"\n    |(c,\"1\")-> c  \n    |(c,d) ->\n        add (mul_dig c (string_first d)) ((aux c (string_pop d)^\"0\"))\n  in\n  aux a (string_rev b);;\n\nlet rec pow a= function\n  | 0 -> \"1\"\n  | 1 -> a\n  | k -> \n      let b = pow a (k\/2) in\n      mul b  (mul b  (if  ( k mod 2 )= 0 then \"1\" else a)) ;;\n\nlet fcn(n:int): string = pow \"2\" n ;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217277,"user_id":null,"body":"let rec double rem = function\n  | a :: q ->\n    let aa = 2 * a + rem in\n    if aa <= 9 then\n      aa :: double 0 q else\n      aa mod 10 :: double (aa \/ 10) q\n  | [] when rem > 0 -> [rem]\n  | [] -> []\n\nlet listify n =\n  let rec loop = function\n    | 0 -> []\n    | k -> k mod 10 :: loop (k \/ 10) in\n  loop n\n\nlet fcn(n:int): string =\n  let rec loop l = function\n    | 0 -> l\n    | k -> loop (double 0 l) (k - 1) in\n  loop [1] n |> List.rev |> List.map string_of_int |> String.concat \"\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217278,"user_id":null,"body":"let double x = \n  let temp = ref 0 in\n  let temp2 = ref 0 in\n  let ca = ref 0 in\n  let rep = ref \"\" in\n  for i = String.length x -1 downto 0 do\n    ca := (int_of_string (String.make 1 x.[i]) ) *2;\n    if !ca > 9 then (temp:=1 ; ca := !ca - 10) else temp :=0 ;\n    rep := (string_of_int (!ca + !temp2))^(!rep);temp2 := !temp;done;\n  if (!temp2 = 1) then rep := \"1\"^ !rep;\n  !rep;;\n\nlet rec exp n = match n with\n  |0->\"1\"\n  |_-> double (exp (n-1))\n  \n;;\n\nlet fcn(n:int): string = \n(exp n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217279,"user_id":null,"body":"open Big_int\n\nlet un = unit_big_int\nlet deux = succ_big_int un\n\nlet fcn n =\n  let rec pow = function\n    | 0 ->  un\n    | n -> mult_big_int deux (pow (n - 1))\n  in string_of_big_int (pow n)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217280,"user_id":null,"body":"open Big_int\n\nlet rec pow2 = function\n| 0 -> unit_big_int\n| n -> mult_big_int (pow2 (n-1)) (add_big_int unit_big_int unit_big_int);;\n\nlet fcn (n) =\n    string_of_big_int (pow2 n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217281,"user_id":480,"body":"open Big_int;;\nlet fcn(n:int): string = \n  Big_int.string_of_big_int (Big_int.power_int_positive_int 2 n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"564057bc348c7200bd0000ff":[{"id":217282,"user_id":168,"body":"let thirt m =\n  let rec sum acc m b =\n    if m = 0 then acc\n    else\n      sum (acc + (m mod 10) * b) (m \/ 10) ((b * 10) mod 13) in\n  let rec loop v =\n    let s = sum 0 v 1 in\n    if s = v then s\n    else loop s in\n  loop m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217283,"user_id":492,"body":"let rec thirt m =\n  let rec thirtaux n c i =\n    let w = [|1; 10; 9; 12; 3; 4|] in\n      if (n = 0) then c\n      else thirtaux (n \/ 10) (c + (n mod 10) * w.(i mod 6)) (i + 1) in\n  let c = thirtaux m 0 0 in\n    if (m == c) then c\n    else thirt c;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217284,"user_id":492,"body":"let rec thirt m =\n  let rec thirtaux n c i =\n    let w = [|1; 10; 9; 12; 3; 4|] in\n      if (n = 0) then c\n      else thirtaux (n \/ 10) (c + (n mod 10) * w.(i mod 6)) (i + 1) in\n  let c = thirtaux m 0 0 in\n    if (m == c) then c\n    else thirt c;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217285,"user_id":null,"body":"let coeffs = [|1; 10; 9; 12; 3; 4|]\n\nlet rec thirt m =\n  let rec loop acc i = function\n    | 0 -> if acc = m then acc else thirt acc\n    | k -> loop (acc + (k mod 10) * coeffs.(i mod 6)) (i + 1) (k \/ 10) in\n  loop 0 0 m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217286,"user_id":53,"body":"let rec thirt n =\n    let rec go(n, s, r, m) =\n        if m = 0 && s = n then s\n        else if m = 0 then go(s, 0, 1, s)\n        else go(n, s + r * (m mod 10), (r * 10) mod 13, m \/ 10) in\n    go(n, 0, 1, n)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217287,"user_id":null,"body":"open List\nlet rec step a b =\n  if a = b\n  then a\n  else\n    step b\n      (fold_left (+) 0\n         (mapi\n            (fun i c -> (Char.code c - 48) * nth [1; 10; 9; 12; 3; 4] (i mod 6))\n            (rev (of_seq (String.to_seq (string_of_int b))))))\nlet thirt m = step ~-1 m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217288,"user_id":null,"body":"let toto = [|1;10;9;12;3;4|] ;;\n\nlet listNum x =\n  let length = ref 0 in\n  let y = ref x in\n  while !y > 0 do \n    incr length ;\n    y := (!y)\/10; done;\n  !length ;\n  let ans = Array.make !length 0 in\n  let z= ref x in\n  for i = 0 to !length -1 do\n    ans.(i) <- (!z)-(!z \/10 *10) ;\n    z:= (!z)\/10;\n  done;\n  ans;;\n\nlet calcul x =\n  let arr = listNum x in\n  let tot = ref 0 in\n  for i = 0 to Array.length arr -1 do\n    tot:= !tot + arr.(i)*toto.(i mod 6); done;\n  !tot;;\n\n;;\n\nlet thirt m =\n  let stati= ref m in\n  while((!stati = calcul(!stati)) = false ) do \n    stati:=calcul(!stati);done;\n  !stati;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217289,"user_id":null,"body":"let int_list_of_int x =\n  string_of_int x\n  |> String.to_seq\n  |> Seq.map (fun x -> (String.make 1 x) |> int_of_string)\n  |> List.of_seq;;\n\nlet power10 n = \n  \"1\" ^ (String.make n '0')\n  |> int_of_string;;\n\nlet power10_list n =\n  let rec acc n result =\n    match n with\n    | (-1) -> result\n    | _ -> acc (n - 1) ((power10 n) :: result) in\n  acc n [];;\n\nlet calc n =\n  let n_lst = List.rev (int_list_of_int n) in\n  power10_list ((List.length n_lst) - 1)\n  |> List.map (fun x -> x mod 13)\n  |> List.map2 (fun x y -> x * y) n_lst\n  |> List.fold_left (+) 0;;\n\nlet solve n =\n  let rec acc n prev =\n    if (n = prev) then n\n    else acc (calc n) n in\n  acc n 0;;\n\nlet thirt m = solve m;;\n  (* your code *);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217290,"user_id":480,"body":"let thirt m =\n  let cycle=[1; 10; 9; 12; 3; 4] in\n  let rec f m i=(m mod 10)*(List.nth cycle (i mod 6))+(if m<10 then 0 else f (m\/10) (i+1)) in\n  let rec stationary m=\n    let m1=f m 0 in\n    if m1=m then m else stationary m1\n  in\n    stationary m;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217291,"user_id":null,"body":"let thirt n = \n    let remainders = [1; 10; 9; 12; 3; 4] in\n    let one_pass n =\n        let digits = n \n            |> string_of_int \n            |> String.to_seq \n            |> List.of_seq \n            |> List.map (fun c -> int_of_string (Char.escaped c)) in\n        let reversed_digits = List.rev digits in\n        let rec loop acc = function\n            | ([], _) -> acc\n            | (d :: dss, r :: rss) -> loop (acc + d * r) (dss, rss)\n            | (ds, []) -> loop acc (ds, remainders) in\n        loop 0 (reversed_digits, remainders) in\n    let rec loop prev = \n        let next = one_pass prev in\n        if prev = next then next\n        else loop next\n    in loop n ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56445c4755d0e45b8c00010a":[{"id":217292,"user_id":492,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n  let rec helper (prevx: int) (p: float) (prevc: int) (n: int) (infl: float) (k: int) =\n    if (k == n) then\n      prevx >= 0\n    else\n      let noux = (float_of_int prevx) +. p \/. 100.0 *. (float_of_int prevx) -. (float_of_int prevc) in\n      let nouc = (float_of_int prevc) +. infl \/. 100.0 *. (float_of_int prevc) in\n        helper (int_of_float (floor noux)) p (int_of_float (floor nouc)) n infl (k + 1)\n  in helper fortinit p peryear nbyear infl 1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217293,"user_id":492,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n  let rec helper (prevx: int) (p: float) (prevc: int) (n: int) (infl: float) (k: int) =\n    if (k == n) then\n      prevx >= 0\n    else\n      let noux = (float_of_int prevx) +. p \/. 100.0 *. (float_of_int prevx) -. (float_of_int prevc) in\n      let nouc = (float_of_int prevc) +. infl \/. 100.0 *. (float_of_int prevc) in\n        helper (int_of_float (floor noux)) p (int_of_float (floor nouc)) n infl (k + 1)\n  in helper fortinit p peryear nbyear infl 1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217294,"user_id":null,"body":"let rec fortune f p c n i =\n  if n <= 0 then true\n  else if f < 0 then false\n  else let fo = int_of_float (float_of_int f*.p*.0.01) in\n       let co = int_of_float (float_of_int c*.i*.0.01) in\n       fortune (f + fo - c) p (c + co) (n - 1) i\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217295,"user_id":null,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n    let rec loop f c yr = \n        if f < 0 then false\n        else if yr >= nbyear - 1 then true\n        else\n            let f = float f in\n            let c = float c in\n            let f' = int_of_float @@ f +. f *. (p \/. 100.0) -. c in\n            let c' = int_of_float @@ c +. c *. (infl \/. 100.0) in\n            loop f' c' (yr + 1)\n    in loop fortinit peryear 0\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217296,"user_id":53,"body":"let rec aux (f0: float) (p: float) (c0: float) (n: int) (i: float): float =\n  if n == 1 then f0\n  else\n    let f1 = f0 +. f0 *. (floor p) \/. 100.0 -. c0 in\n    let c1 = c0 +. c0 *. (floor i) \/. 100.0 in\n    let n1 = n - 1 in\n    aux f1 p c1 n1 i\n  ;;\n\nlet fortune (f0: int) (p: float) (c0: int) (n: int) (i: float): bool =\n  let ans = aux (float_of_int f0) p (float_of_int c0) n i in\n  ans >= 0.0\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217297,"user_id":null,"body":"exception Bankrupt;;\n\nlet fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n  let fort = ref (float_of_int fortinit) and cost = ref (float_of_int peryear) in\n  try\n    for i = 1 to nbyear-1 do\n      fort := floor (!fort *. (1. +. p \/. 100.) -. !cost);\n      cost := floor (!cost *. (1. +. infl \/. 100.));\n      if !fort < 0. then raise Bankrupt\n    done; true\n  with _ -> false;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217298,"user_id":480,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n  let rec aux fortinit peryear nbyear=\n    fortinit>=0. && (nbyear==1 ||\n    let fortinit=floor (fortinit *. (1. +. 0.01*.p) -. peryear)\n    and peryear=floor (peryear *. (1. +. 0.01*.infl))\n    and nbyear=nbyear-1 in\n    aux fortinit peryear nbyear\n    ) in\n  aux (float_of_int fortinit) (float_of_int peryear) nbyear\n    ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217299,"user_id":609,"body":"let truncate x = float_of_int (int_of_float x);;\n\nlet fortune fortinit percent peryear nbyear infl =\n  let f0 = float_of_int fortinit in\n  let p = 1. +. percent \/. 100. in\n  let c0 = float_of_int peryear in\n  let i = 1. +. infl \/. 100. in\n  let rec aux f year = \n    match year with\n      | year when year = nbyear-1 -> f\n      | _ -> aux (truncate(f *. p -. truncate (i**(float_of_int year) *. c0)) ) (year+1) in\n  (aux f0 0) >= 0.;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217300,"user_id":168,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\n  let p = 1. +. p \/. 100.0 in\n  let infl = 1. +. infl \/. 100.0 in\n  let rec loop f c n =\n    if n >= nbyear then true\n    else\n      let f' = floor (f *. p -. c) in\n      if f' < 0. then false\n      else\n        loop f' (floor (c *. infl)) (succ n) in\n  loop (float_of_int fortinit) (float_of_int peryear) 1\n    \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217301,"user_id":null,"body":"let fortune (fortinit: int) (p: float) (peryear: int) (nbyear: int) (infl: float): bool =\nlet p, infl = p \/. 100.0, infl \/. 100.0 in\n  let (bank_balance, year, take_out) = (ref fortinit, ref 1 ,ref peryear) in\n    while !bank_balance > 0 do\n      year := !year + 1;\n      bank_balance := (int_of_float((float_of_int(!bank_balance)) *. (1.0 +. p)) - !take_out);\n      take_out := int_of_float((float_of_int(!take_out))*. (1.0 +. infl))\n    done;\n  nbyear < !year ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56484848ba95170a8000004d":[{"id":217302,"user_id":null,"body":"let rec gps (s: int) (l: float list): int = \n  let speed s' x1 x0 = 3600. *. (x1 -. x0) \/. s' in\n  let rec top_speed s' rmax = function\n    | [] -> rmax\n    | [elt] -> rmax\n    | x0 :: x1 :: tl -> top_speed s' (max rmax (speed s' x1 x0)) (x1 :: tl)\n  in int_of_float (top_speed (float s) 0. l)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217303,"user_id":492,"body":"let rec gpsaux (s: int) (l: float list) =\n  match l with\n    | [] -> 0.0\n    | _ :: [] -> 0.0\n    | a :: b :: x -> \n        max (3600.0 *. (b -. a) \/. float_of_int(s)) (gpsaux s (b :: x))\nlet gps (s: int) (l: float list): int = int_of_float(gpsaux s l)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217304,"user_id":492,"body":"let rec gpsaux (s: int) (l: float list) =\n  match l with\n    | [] -> 0.0\n    | _ :: [] -> 0.0\n    | a :: b :: x -> \n        max (3600.0 *. (b -. a) \/. float_of_int(s)) (gpsaux s (b :: x))\nlet gps (s: int) (l: float list): int = int_of_float(gpsaux s l)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217305,"user_id":null,"body":"let rec findMax (l: int list) (v: int): int =\n  match l with\n  | [] -> v\n  | h::t -> findMax t (max h v)\n;;\n\nlet rec gps2 (s: int) (l: float list) (answer: int list): int list=\n  match l with\n  | [x] -> answer\n  | a::b::c -> gps2 s (b::c) ((int_of_float ((3600.0*.(b-.a))\/.(float_of_int s)))::answer)\n;;\n\nlet gps (s: int) (l: float list): int =\n  match l with\n  | [] -> 0\n  | [x] -> 0\n  | h::t -> findMax (gps2 s l []) 0\n;;  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217306,"user_id":null,"body":"let gps (s: int) (l: float list): int =\n  let rec pairs = function\n    | a :: (b :: _ as t) -> (a, b) :: pairs t\n    | _ -> [] in\n  l |> pairs\n    |> List.map (fun (x, y) -> y -. x)\n    |> List.map (( *. ) (3600. \/. float_of_int s))\n    |> List.map int_of_float\n    |> List.fold_left max min_int","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217307,"user_id":null,"body":"let gps (s: int) (l: float list): int = \n  let rec max l m = match l with\n  | [] -> m\n  | x :: tl -> max tl (if x < m then m else x)\n  in let rec map_windows f pre l = match l with\n  | [] -> []\n  | x :: tl -> f pre x :: map_windows f x tl\n  in\n  let s' = float_of_int s in\n  let l' = \n    match l with\n    | [] -> []\n    | x :: tl -> map_windows (fun st ed -> (3600. *. (ed -. st) \/. s')) x tl in \n  match l' with\n  | [] -> 0\n  | x :: tl -> int_of_float (max tl x)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217308,"user_id":null,"body":"let max a b = if a > b then a else b\n\nlet gps (s: int) (l: float list): int = \n  if List.length l = 0 then 0\n  else int_of_float (3600. *. match (\n    List.fold_left (fun y current -> (\n      match y with\n      (biggest,last) -> max biggest (current -. last), current\n    )) (0., List.hd l) l\n  ) with (x,_) -> x \/. (float_of_int s))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217309,"user_id":null,"body":"let gps (s: int) (l: float list): int = \n  let rec aux maxspeed = function\n  | [] | [_] -> maxspeed\n  | x::(y::_ as tl) ->\n      let speed = (3600.0 *. (y -. x)) \/. (float_of_int s) in\n      aux (max speed maxspeed) tl\n  in\n  int_of_float (aux 0.0 l)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217310,"user_id":null,"body":"let rec average_hourly s = function\n  | [] | _::[] -> []\n  | e1::e2::l -> ((e2 -. e1) *. 3600. \/. s)::(average_hourly s (e2::l)) ;;\n  \n\nlet max_list = function\n  | [] -> failwith \"empty list\"\n  | e::list ->\n    let rec max_list_r m = function\n      | [] -> m\n      | e::l -> max_list_r (max e m) l\n    in\n    max_list_r e list ;;\n\n\nlet gps (s: int) (l: float list): int = match l with\n  | [] | _::[] -> 0\n  | l -> int_of_float (max_list (average_hourly (float_of_int s) l));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217311,"user_id":null,"body":"open Batteries;;\n\nlet gps (s: int) (l: float list): int = \n  let len = List.length l in\n  if len < 2\n    then 0\n    else \n    List.init (len-1) (fun i -> List.at l (i+1) -. List.at l i) \n    |> List.max |> (fun x -> int_of_float (x *. 3600. \/. float_of_int s))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56541980fa08ab47a0000040":[{"id":217312,"user_id":492,"body":"let printer_error(s: string): string =\n  let rgx = Str.regexp \"[a-m]\" in\n  let b = String.length s in\n  let a = String.length(Str.global_replace rgx \"\" s) in\n    Printf.sprintf \"%d\/%d\"  a b;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217313,"user_id":null,"body":"let printer_error s =\n  String.to_seq s\n  |> Seq.fold_left (fun (error, total) ch -> if ch > 'm' then (error + 1, total + 1) else (error, total + 1)) (0, 0)\n  |> fun (error, total) -> Printf.sprintf \"%d\/%d\" error total","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217314,"user_id":53,"body":"let printer_error(s: string): string =\n  let ls = (List.of_seq (String.to_seq s)) in\n  let xs = List.filter (fun c -> (not (String.contains \"abcdefghijklm\" c))) ls in\n  let m = List.length xs in\n  let n = List.length ls in\n  Printf.sprintf \"%d\/%d\" m n\n  ;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217315,"user_id":1428,"body":"let explode s =\n  let rec exp i l = if i < 0 then l else exp (i - 1) ((s.[i]) :: l) in\n  exp ((String.length s) - 1) []\n  \nlet printer_error (s : string) =\n  (let rec get_counts (s : char list) ((e : int),(l : int)) =\n     match s with\n     | [] -> (e, l)\n     | hd::rest ->\n         let c =\n           match (hd >= 'a') && (hd <= 'm') with | true  -> 0 | false  -> 1 in\n         get_counts rest ((e + c), (l + 1)) in\n   let (num,denum) = get_counts (explode s) (0, 0) in\n   (string_of_int num) ^ (\"\/\" ^ (string_of_int denum)) : string)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217316,"user_id":null,"body":"let printer_error(s: string): string =\n  let errors = List.fold_left (+) 0 @@ List.init (String.length s) (fun i -> match s.[i] with 'a' .. 'm' -> 0 | _ -> 1) in\n  Printf.sprintf \"%d\/%d\" errors (String.length s)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217317,"user_id":null,"body":"let printer_error(s: string): string =\n  (* In OCaml 4.13 and above, simply use List.fold_left *)\n  let bad, total = Seq.fold_left (fun (b, t) c -> (if c > 'm' then 1 else 0) + b, t + 1) (0,0) (String.to_seq s) in\n  (string_of_int bad) ^ \"\/\" ^ (string_of_int total) ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217318,"user_id":null,"body":"let rec printer2 str length counter =\n  if length == 0 then counter else\n    let letter = String.sub str (length-1) 1 in\n    let result = String.compare \"m\" letter in\n      match result with\n        -1 -> printer2 str (length-1) (counter+1)\n      | _  -> printer2 str (length-1) counter;;\n\nlet printer_error(s: string): string =\n  let len = String.length s in\n  Printf.sprintf \"%d\/%d\" (printer2 s len 0) len;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217319,"user_id":294,"body":"let printer_error(s: string): string =\n  let chars = s |> String.to_seq |> List.of_seq in\n  let errors = chars |> List.filter (function 'a'..'m' -> false | _ -> true)\n  in Printf.sprintf \"%d\/%d\" (List.length errors) (List.length chars)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217320,"user_id":null,"body":"let printer_error(s: string): string = let total = BatString.length s in \n                                       let errors = BatString.fold_left (fun acc -> function 'a'..'m' -> acc  | _ -> acc + 1) 0 s in\n                                       (string_of_int errors) ^ \"\/\" ^ (string_of_int total)\n                                       ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217321,"user_id":null,"body":"let explode s = List.init (String.length s) (String.get s)\nlet implode l = List.fold_right (fun c s -> String.make 1 c ^ s) l \"\"\n\nlet printer_error s =\n  let l = explode s in\n  let rec loop l =\n    match l with\n    | [] -> 0\n    | x::l -> if (int_of_char x) > 109 then 1 + loop l else loop l in\n  let string = string_of_int (loop l) ^ \"\/\" ^ (string_of_int (List.length l)) in string","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5656b6906de340bd1b0000ac":[{"id":217322,"user_id":1986,"body":"(* The simplest way to get a sorted distinct set of chars is using a char set *)\nmodule CharSet = Set.Make(struct\n  type t = char\n  let compare = compare\nend)\n\n(* Since we're on an old version of ocaml, we can't easily get a char Seq.t from a String *)\nlet chars_from_string = function\n  | \"\" -> []\n  | s -> begin\n    let chars = ref [] in\n    String.iter (fun c -> chars := (c :: !chars)) s;\n    List.rev !chars\n  end\n  \n(* And since we're using an old version of ocaml, we also can't easily get a String from a char Seq.t *)\nlet string_from_chars chars = \n  String.init (List.length chars) (fun i -> List.nth chars i)\n\nlet longest s1 s2 =\n  (* Smash the strings together and get the distinct chars from the result *)\n  let distinct_chars = \n    (s1 ^ s2)\n    |> chars_from_string\n    |> CharSet.of_list\n  in\n  distinct_chars\n  |> CharSet.elements (* returns a list of sorted distinct chars *)\n  |> string_from_chars (* stringifies the list of chars *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217323,"user_id":null,"body":"let longest s1 s2 =\n  BatList.append (BatString.to_list s1) (BatString.to_list s2)\n  |> BatList.sort_unique BatChar.compare\n  |> BatString.of_list\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217324,"user_id":492,"body":"let longest s1 s2 =\n  Str.split (Str.regexp \"\") (s1 ^ s2)\n  |> List.sort compare |> uniq |> String.concat \"\";;\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217325,"user_id":98,"body":"let string_of_char ch = String.make 1 ch\n;;\nlet longest s1 s2 =\n\tlet letters = \"abcdefghijklmnopqrstuvwxyz\" in\n\tlet rec get_letters i str =\n\t\tif i >= (String.length letters) then\n\t\t\tstr\n\t\telse\n\t\t\tlet ch = letters.[i] in\n\t\t\tif (String.contains s1 ch) || (String.contains s2 ch) then\n\t\t\t\tget_letters (i + 1) (str ^ (string_of_char ch))\n\t\t\telse\n\t\t\t\tget_letters (i + 1) str\n\tin get_letters 0 \"\"\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217326,"user_id":null,"body":"let longest s1 s2 =\n  let list_of_string s = List.init (String.length s) (String.get s) in\n  list_of_string s1 @ list_of_string s2\n    |> List.sort_uniq compare\n    |> List.map (String.make 1)\n    |> String.concat \"\"","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217327,"user_id":null,"body":"let longest (s1 : string) (s2 : string) : string =\n  let s = s1 ^ s2 in\n  List.init (String.length s) (String.get s)\n  |> List.sort_uniq Char.compare\n  |> List.fold_left (fun a b -> a ^ String.make 1 b) \"\"\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217328,"user_id":null,"body":"let longest s1 s2 =\n  let s = String.concat \"\" [s1;s2] in\n   List.sort_uniq compare (List.init (String.length s) (String.get s))\n   |> List.to_seq\n   |> String.of_seq","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217329,"user_id":null,"body":"let explode s = List.init (String.length s) (String.get s)\nlet implode l = List.fold_right (fun c s -> String.make 1 c ^ s) l \"\"\n    \nlet sort s =\n  let n = String.length s in\n  let a = Array.init n (fun i -> s.[i]) in\n  Array.sort Char.compare a;\n  String.init n (fun i -> a.(i))\n    \nlet longest s1 s2 =\n  let rec loop l_new l_old =\n    match l_old with\n    | [] -> sort (implode l_new)\n    | x::l -> if List.exists (fun y -> y = x ) l_new then loop l_new l else loop (l_new @ [x]) l\n  in loop [] (explode (s1 ^ s2))","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217330,"user_id":null,"body":"let string_of_list = List.fold_left (fun acc x -> String.make 1 x ^ acc) \"\"\n\nlet list_of_string s =\n  let rec helper l i = if i < 0 then l else helper (s.[i] :: l) (i - 1) in\n  helper [] (String.length s - 1)\n\nlet uniques =\n  List.fold_left\n    (fun acc x -> if List.exists (fun s -> s = x) acc then acc else x :: acc)\n    []\n\nlet sort = List.sort (fun x y -> Char.compare y x)\n\nlet longest s1 s2 =\n  s1 ^ s2 |> list_of_string |> uniques |> sort |> string_of_list\n\n\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217331,"user_id":null,"body":"open String;;\nopen Pervasives;;\n\nlet explode s =\n  let rec exp i l =\n    if i < 0 then l else exp (i - 1) (s.[i] :: l) in\n  exp (String.length s - 1) [];;\n\nlet rec remove =\n  function\n  | []       -> []\n  | x::[]    -> x::[]\n  | x::y::tl ->\n      if x=y then remove (y::tl)\n      else x::remove (y::tl);;\n  \nlet string_of_chars chars = \n  let buf = Buffer.create 32 in\n  List.iter (Buffer.add_char buf) chars;\n  Buffer.contents buf\n\nlet longest s1 s2 =\n  string_of_chars (remove (List.sort compare (explode (String.concat \"\" [s1;s2]))));;\n","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"565abd876ed46506d600000d":[{"id":217332,"user_id":53,"body":"let simpson (ni: int) =\n  let pi = 3.14159265358979323846 in\n  let n = float_of_int(ni) in \n  let pow3 (x: float) = x *. x *. x in\n  pi \/. n *. (1.0 +. 2.0 *. pow3(cos(pi \/. n)) +. 3.0 *. cos(2.0 *. pi \/. n)) \/. (sin(3.0 *. pi \/. n))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217333,"user_id":492,"body":"let simpson (n: int) =\n  let f (x: float) = 3.0 *. (sin x) *. (sin x) *. (sin x) \/. 2.0 in\n    let sm1 (n: int) (h: float) = rangeUH 1 2 (n -1) (fun x -> f((float_of_int x) *. h)) |> sumUH in\n    let sm2 (n: int) (h: float) = rangeUH 2 2 n (fun x -> f((float_of_int x) *. h)) |> sumUH in\n    let h = 3.14159265358979323846 \/. float_of_int(n) in\n        h *. (4.0 *. (sm1 n h) +. 2.0 *. (sm2 n h)) \/. 3.0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217334,"user_id":null,"body":"let simpson (n: int) =\n    let f x = let s = sin x in 1.5 *. s *. s *. s in\n    let h = Float.pi \/. (float_of_int n) in\n    let xs = List.init (n + 1) (fun k -> (float_of_int k) *. h) in\n    let ys = List.map f xs in\n    let ws = List.init (n + 1) (fun k -> if k = 0 || k = n then 1 else if k mod 2 = 1 then 4 else 2) in\n    (List.fold_left2 (fun acc w y -> acc +. (float_of_int w) *. y) 0.0 ws ys) *. h \/. 3.0\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217335,"user_id":492,"body":"let simpson (n: int) =\n  let f (x: float) = 3.0 *. (sin x) *. (sin x) *. (sin x) \/. 2.0 in\n    let sm1 (n: int) (h: float) = rangeUH 1 2 (n -1) (fun x -> f((float_of_int x) *. h)) |> sumUH in\n    let sm2 (n: int) (h: float) = rangeUH 2 2 n (fun x -> f((float_of_int x) *. h)) |> sumUH in\n    let h = 3.14159265358979323846 \/. float_of_int(n) in\n        h *. (4.0 *. (sm1 n h) +. 2.0 *. (sm2 n h)) \/. 3.0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217336,"user_id":480,"body":"open Float\nopen List\n\nlet rec range a b =\n    if a > b then []\n    else a :: range (a+1) b;;\n\nlet sum l =\n  let rec aux acc = function\n    | [] -> acc\n    | h::t -> aux (acc +. h) t\n  in\n  aux 0.0 l;;\n\nlet _simpson f a b n =\n  let h = (b -. a) \/. (float_of_int n) in\n  let sum1 = sum (map (fun i->(f (a +. (float_of_int (2*i-1)) *. h))) (range 1 (n\/2))) \n  and sum2 = sum (map (fun i->(f (a +. (float_of_int (2*i)) *. h))) (range 1 (n\/2-1))) in\n  h \/. 3.0 *. ((f a) +. (f b) +. 4.0 *. sum1 +. 2.0 *. sum2);;\n  \n  \nlet simpson (n: int) =\n  _simpson (fun x->(pow (sin x) 3.0) *. 1.5) 0.0 pi n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217337,"user_id":null,"body":"let simpson (n: int) : float =\n  let h = Float.pi \/. (float_of_int n) in\n    let f x = 3. \/. 2. *. (Float.pow (Float.sin x) 3.)  in\n      let sumof f n = List.fold_left (+.) 0. (List.init n (fun x -> f (float_of_int (x+1)))) in\n        let t1 = 4. *. (sumof (fun i -> f ((2.*.i-.1.)*.h)) (n\/2)) in\n          let t2 = 2. *. (sumof (fun i -> f (2.*.i*.h)) (n\/2-1)) in\n            Float.pi \/. (3. *. (float_of_int n)) *.\n              (t1 +. t2)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217338,"user_id":null,"body":"let simpson (n: int) =\n  let f x= 3. \/. 2. *. sin(x) ** 3. in\n  let pi = 4.0 *. atan 1.0 in\n  let h = pi \/. float_of_int n in\n  let rec simpson_acc m res= match m with\n    0 -> simpson_acc (m+1) (res +. f(0.))\n    |m when m=n -> res +. f(pi)\n    |m when m mod 2=0 -> simpson_acc (m+1) (res +. 2. *. f( float_of_int(m) *. h))\n    |m -> simpson_acc (m+1) (res +. 4. *. f(float_of_int(m) *. h)) in\n  pi \/. (3. *. float_of_int n) *. simpson_acc 0 0.;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217339,"user_id":168,"body":"let rec sum acc f i j =\n  if i > j then acc\n  else sum (f i +. acc) f (succ i) j\n\nlet simpson (n: int) =\n  let a, b = 0., 4. *. atan 1. in\n  let f x = (let s = sin x in 1.5 *. (s *. s *. s)) in\n  let h = (b -. a) \/. float n in\n  (b -. a) \/. float (3 * n) *.\n    (f a +. f b +. \n      4. *. sum 0. (fun i -> f (a +. float (2 * i - 1) *. h)) 1 (n \/ 2) +.\n      2. *. sum 0. (fun i -> f (a +. float (2 * i) *. h)) 1 (n \/ 2 - 1))\n  \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217340,"user_id":null,"body":"let init_list len mapper = \n  let rec aux acc i =\n    if i < len then\n      aux ((mapper i)::acc) (i + 1)\n    else (List.rev acc)\n  in\n  aux [] 0\n\nlet sum lower_bound upper_bound f =\n  init_list (upper_bound - lower_bound + 1) (\n    fun i -> f(i + lower_bound)\n  )\n  |> List.fold_left (fun total next -> total +. next) 0.0\n\nlet simpson (n: int) =\n  let pi = 4.0 *. atan 1.0 in\n  let f x = 1.5 *. (sin x) ** 3.0 in\n  let h = pi \/. float_of_int n in\n  let f_a = f 0.0 in\n  let f_b = f pi in (pi \/. (3.0 *. float_of_int n)) *. (\n    f_a +. \n    f_b +. \n    (4.0 *. (sum 1 (n \/ 2) (fun i -> f (float_of_int (2 * i - 1) *. h)))) +.\n    (2.0 *. (sum 1 (n \/ 2 - 1) (fun i -> f (2.0 *. float_of_int i *. h))))\n  )\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217341,"user_id":751,"body":"open Batteries\nlet simpson (n: int) =\n  let f = fun(x) -> 1.5 *. (sin(x) ** 3.0) in\n  let (a,b,nf) = (0.0, Float.pi, float_of_int(n)) in\n  let h = (b -. a) \/. nf in\n  let s1 = List.range 1 `To (n\/2)\n    |> List.map (float_of_int) \n    |> List.map (fun i -> f @@ a +. (2.0 *. i -. 1.0) *. h)\n    |> List.fold_left (+.) 0.0 in\n  let s2 = List.range 1 `To (n\/2-1)\n    |> List.map (float_of_int) \n    |> List.map (fun i -> f @@ a +. (2.0 *. i *. h)) \n    |> List.fold_left (+.) 0.0 in\n  (b -. a) \/. (3.0 *. float_of_int(n)) *. (f(a) +. f(b) +. 4.0 *. s1 +. 2.0 *. s2)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"565c0fa6e3a7d39dee000125":[{"id":217342,"user_id":168,"body":"let dist(v: float) (mu: float): float =\n  let v = v *. (1000. \/. 3600.) in\n  let d1 = (v *. v) \/. (2. *. mu *. 9.81) in\n  v +. d1\n\nlet speed(d: float) (mu: float): float =\n  let x = mu *. 9.81 in\n  let v = (sqrt (1. +. 2. *. d \/. x) -. 1.) *. x in\n  v *. (3600. \/. 1000.)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217343,"user_id":null,"body":"\nlet kmph_to_mps n = n *. 1000. \/. 3600. ;;\nlet mps_to_kmph n = n \/. 1000. *. 3600. ;;\n\nlet dist(v:float) (mu:float): float =\n  let g = 9.81 in\n  let t = 1.0 in\n  let v = kmph_to_mps v in\n  v *. v \/. 2. \/. mu \/. g +. t *. v;;\n\nlet speed(d: float) (mu:float): float =\n  let t = 1.0 in\n  let g = 9.81 in\n  let a = 1. \/. (2. *. mu *. g) in\n  let b = t in\n  let c = (-.d) in\n  let delta = b *. b -. 4. *. a *. c in\n  let ans = ((-.b) +. sqrt(delta)) \/. (2. *. a) in\n  mps_to_kmph ans;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217344,"user_id":492,"body":"let dist(v: float) (mu: float): float =\n    let g = 9.81 in\n    let coef = 1000.0 \/. 3600.0 in\n    let dreact = v *. coef in\n    let vms = coef *. v in\n    let dbrak = 0.5 *. (vms ** 2.0) \/. mu \/. g in\n        dreact +. dbrak;;\nlet speed(d: float) (mu: float): float =\n    let g = 9.81 in\n    let coef = 3600.0 \/. 1000.0 in\n        0.5 *. mu *. g *. (- 2.0 +. sqrt(4.0 +. 8.0 *. d \/. mu \/. g)) *. coef;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217345,"user_id":492,"body":"let dist(v: float) (mu: float): float =\n    let g = 9.81 in\n    let coef = 1000.0 \/. 3600.0 in\n    let dreact = v *. coef in\n    let vms = coef *. v in\n    let dbrak = 0.5 *. (vms ** 2.0) \/. mu \/. g in\n        dreact +. dbrak;;\nlet speed(d: float) (mu: float): float =\n    let g = 9.81 in\n    let coef = 3600.0 \/. 1000.0 in\n        0.5 *. mu *. g *. (- 2.0 +. sqrt(4.0 +. 8.0 *. d \/. mu \/. g)) *. coef;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217346,"user_id":null,"body":"let dist(v: float) (mu: float): float =\n  let g = 9.81 in\n  let v' = v \/. 3.6 in\n  v' *. v' \/. (2. *. mu *. g) +. v'  \n    \nlet speed(d: float) (mu: float): float =\n  let g = 9.81 in\n  let a = 2. *. mu *. g in\n  (sqrt (a *. a +. 4. *. a *. d) -. a) \/. 2. *. 3.6\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217347,"user_id":53,"body":"let dist(v: float) (mu: float): float =\n  let u = v *. 5.0 \/. 18.0 in\n  u +. u *. u \/. (2.0 *. mu *. 9.81)\n  ;;\n    \nlet speed(d: float) (mu: float): float =\n  let b = -2.0 *. mu *. 9.81 in\n  3.6 *. (b +. sqrt(b *. b -. 4.0 *. b *. d)) \/. 2.0\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217348,"user_id":null,"body":"let g = 9.81\n\n\nlet dist(v: float) (mu: float): float =\n    let v = v \/. 3.6 in\n    v +. (v *. v) \/. (2.0 *. g *. mu)\n\n\nlet speed(d: float) (mu: float): float =\n    let gmu = g *. mu in\n    let v = sqrt (gmu *. (gmu +. 2.0 *. d)) -. gmu in\n    v *. 3.6\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217349,"user_id":480,"body":"let g=9.81;;\nlet t=1.;;\n\nlet dist(v: float) (mu: float): float =\n  let v= v \/. 3.6 in\n  let d1=v *. v \/. (2. *. mu *. g) in\n    v *. t +. d1;;\n    \nlet speed(d: float) (mu: float): float =\n    let a= 1. \/. (2. *. mu *. g) and b = t and c = -.d in\n    let d= b *. b -. 4. *. a *. c in\n    (-. b +. (sqrt d))\/.2.\/.a*.3.6\n    ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217350,"user_id":3346,"body":"let dist(v: float) (mu: float): float =\n  let v = v *. (10. \/. 36.) in\n  let d1 = (v *. v) \/. (2. *. mu *. 9.81) in\n  v +. d1\n\nlet speed(d: float) (mu: float): float =\n  let x = mu *. 9.81 in\n  let v = (sqrt (1. +. 2. *. d \/. x) -. 1.) *. x in\n  v *. (36. \/. 10.)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217351,"user_id":98,"body":"let g= 9.81 ;;  (* gravity  *)\nlet t=1.0 ;;     (* reaction time *)\n\nlet kph_to_mps  speed = speed\/.3.6  ;;\nlet mps_to_kph  speed = speed*.3.6  ;;\n\nlet dist(v: float) (mu: float): float =\n\tlet v_mps = kph_to_mps v in\n\tlet d1 = v_mps*.v_mps \/. (2.*.mu*.g) in\n\tlet reaction_distance = v_mps *. t in\n\td1+.reaction_distance  \n;;\n\nlet speed(d: float) (mu: float): float =\n\t(* v^2 (1\/2mug) +v*t -d =0  *)\n\tlet a = 1.\/.(2.*.(mu*.g))  in\n\tlet b = t in \n\tlet c = -.d in\n\tlet delta = b*.b-.4.*.(a*.c) in\n\tif delta = 0.\n\t\tthen mps_to_kph(-.b\/.(2.*.a)) \n\telse \n\t\tlet v1=(-.b-.sqrt(delta))\/.(2.*.a) in\n\t\tlet v2=(-.b+.sqrt(delta))\/.(2.*.a) in\n\t\tmps_to_kph(max v1 v2)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5663f5305102699bad000056":[{"id":217352,"user_id":null,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  let distance x y = abs (String.length x - String.length y) in\n  let diffs = Array.to_list a1\n  |> List.map (fun x -> Array.map (distance x) a2)\n  |> Array.concat\n  in\n  match diffs with\n  | [| |] -> None\n  | _ -> Some (Array.fold_left max min_int diffs)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217353,"user_id":null,"body":"open String\n\nlet rec reduce f = function\n| [x] -> x \n| x::y::xs -> ((f x y) :: xs) |> reduce f\n| [] -> failwith \"no empty lists allowed\"\n\nlet max_by (f: (string -> int)) (arr: string list) =\n  arr \n  |> reduce (fun x y -> if f x > f y then x else y)\nlet min_by (f: (string -> int)) (arr: string list) =\n  arr \n  |> reduce (fun x y -> if f x < f y then x else y)\n\nlet to_some x = Some x\n\nlet mxdiflg e1 e2 =\n  let (a1, a2) = (Array.to_list e1, Array.to_list e2) in\n  match a1, a2 with\n  | [],  _ | _, [] -> None\n  | a1, a2 ->\n    let (min_s, max_s) = (min_by String.length a1, max_by String.length a1) in\n    let (min_t, max_t) = (min_by String.length a2, max_by String.length a2) in\n    [(min_s, max_t); (min_t, max_s)]\n    |> List.map (fun (a, b) -> (String.length a - String.length b) |> abs)\n    |> List.fold_left max 0\n    |> to_some","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217354,"user_id":492,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  if Array.length a1 = 0 || Array.length a2 = 0 then None\n  else\n    let l1 = Array.map(fun x -> String.length x) a1 in\n    let l2 = Array.map(fun x -> String.length x) a2 in\n    let mx1 = max_array l1 in\n    let mx2 = max_array l2 in\n    let mi1 = min_array l1 in\n    let mi2 = min_array l2 in\n      Some(max (abs (mx1 - mi2)) (abs(mx2 - mi1)));;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217355,"user_id":98,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  let max_len (arr : string array) =\n    Array.fold_left (fun max_len str -> max max_len (String.length str)) 0 arr\n  in \n  let min_len (arr : string array) =\n    Array.fold_left (fun min_len str -> min min_len (String.length str))  max_int arr\n  in\n  if Array.length a1 = 0 || Array.length a2 = 0 then\n    None\n  else\n    let min_1 = min_len a1 in\n    let max_1 = max_len a1 in\n    let min_2 = min_len a2 in\n    let max_2 = max_len a2 in\n    Some (max (abs (max_1 - min_2)) (abs (max_2 - min_1)))\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217356,"user_id":null,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  let open Array in\n  if length a1 = 0 || length a2 = 0\n  then None\n  else\n    map (fun s1 ->\n        (map (fun s2 ->\n             abs (String.length s1 - String.length s2))\n            a2))\n      a1\n    |> to_list\n    |> concat\n    |> to_seq\n    |> Seq.fold_left max 0\n    |> fun x -> Some x","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217357,"user_id":null,"body":"let absolute number =\n  if number > 0 then number else -1*number;; \n\nlet maxValue num1 num2 =\n  if num1>num2 then num1 else num2;;\n\nlet lenDiff str1 str2 =\n  let len1 = String.length str1 in\n  let len2 = String.length str2 in\n  absolute (len1 - len2);;\n\nlet rec iterA2 itemA1 a2 lenA2 maxIterA2 =\n  if lenA2 == 0 then maxIterA2 else\n    let itemA2 = Array.get a2 (lenA2-1) in \n    let newA2 = Array.sub a2 0 (lenA2-1) in\n    iterA2 itemA1 newA2 (lenA2-1) (maxValue \n      maxIterA2 (lenDiff itemA1 itemA2));;\n\nlet rec iterA1 a1 a2 lenVarA1 result =\n  if lenVarA1 == 0 then result else\n    let itemA1 = Array.get a1 (lenVarA1-1) in\n    let newA1 = Array.sub a1 0 (lenVarA1-1) in \n    let lenA2 = Array.length a2 in\n    iterA1 newA1 a2 (lenVarA1-1) (maxValue result\n      (iterA2 itemA1 a2 lenA2 result));;\n\nlet mxdiflg (a1: string array) (a2: string array): int option =\n  let len1 = Array.length a1 in\n  let len2 = Array.length a2 in\n  if (len1==0 || len2==0) then None else\n    Some (iterA1 a1 a2 len1 0);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217358,"user_id":null,"body":"let aux f acc s =\n  let n = String.length s in\n  f n acc\n;;\n\nlet min x y = if x < y then x else y\nlet max x y = if x > y then x else y\nlet abs x = if x < 0 then -x else x\n\nlet mxdiflg (a1 : string array) (a2 : string array) : int option =\n  let min1 = Array.fold_left (aux min) 1000 a1\n  and max1 = Array.fold_left (aux max) 0 a1\n  and min2 = Array.fold_left (aux min) 1000 a2\n  and max2 = Array.fold_left (aux max) 0 a2 in\n  if Array.length a1 = 0 || Array.length a2 = 0\n  then None\n  else Some (max (abs (max1 - min2)) (abs (max2 - min1)))\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217359,"user_id":null,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  if Array.length a1 == 0 || Array.length a2 == 0 then None else\n  let lens1 = Array.map String.length a1 in\n  let lens2 = Array.map String.length a2 in\n  let lmax1 = Array.fold_left max 0 lens1 in\n  let lmin1 = Array.fold_left min 10000000 lens1 in\n  let lmax2 = Array.fold_left max 0 lens2 in\n  let lmin2 = Array.fold_left min 10000000 lens2 in\n  Some (max (lmax1 - lmin2) (lmax2 - lmin1))\n\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217360,"user_id":null,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  if a1 = [||] || a2 = [||] then None else\n  \n  let aux arr min_instead_of_max =\n    let f = if min_instead_of_max then min else max in\n    let k = ref (if min_instead_of_max then max_int else min_int) in\n    for i = 0 to Array.length arr - 1 do\n      k := f !k (String.length arr.(i)) done;\n    !k in\n  \n  let min1 = aux a1 true and\n      min2 = aux a2 true and\n      max1 = aux a1 false and\n      max2 = aux a2 false in\n  Some (max (max1 - min2) (max2 - min1))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217361,"user_id":null,"body":"let mxdiflg (a1: string array) (a2: string array): int option =\n  if Array.length a1 = 0 || Array.length a2 = 0\n  then None\n  else Some (Array.fold_left (fun d1 s1 -> Array.fold_left (fun d2 s2 -> (String.length s1) - String.length s2 |> abs |> max d2) 0 a2 |> max d1) 0 a1)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"566543703c72200f0b0000c9":[{"id":217362,"user_id":492,"body":"let rec epidemicAux (n: int) (dt: float) (prevS: float) (prevI: float) (prevR: float) (b: float) (a: float) (k: int) (mx: float) =\n  if (k == n) then int_of_float(floor mx)\n  else begin\n    let pS = prevS -. dt *. b *. prevS *. prevI in\n    let pI = (prevI +. dt *. (b *. prevS *. prevI -. a *. prevI)) in\n    let pR = prevR +. dt *. prevI *. a in\n    let m = if pI > mx then pI else mx in\n      epidemicAux n dt pS pI pR b a (k + 1) m\n  end;;\nlet epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  epidemicAux n (float_of_int(tm) \/. float_of_int(n)) s0 i0 0.0 b a 0 (-1.0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217363,"user_id":492,"body":"let rec epidemicAux (n: int) (dt: float) (prevS: float) (prevI: float) (prevR: float) (b: float) (a: float) (k: int) (mx: float) =\n  if (k == n) then int_of_float(floor mx)\n  else begin\n    let pS = prevS -. dt *. b *. prevS *. prevI in\n    let pI = (prevI +. dt *. (b *. prevS *. prevI -. a *. prevI)) in\n    let pR = prevR +. dt *. prevI *. a in\n    let m = if pI > mx then pI else mx in\n      epidemicAux n dt pS pI pR b a (k + 1) m\n  end;;\nlet epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  epidemicAux n (float_of_int(tm) \/. float_of_int(n)) s0 i0 0.0 b a 0 (-1.0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217364,"user_id":null,"body":"let findMax a b = if a > b then a else b;;\n\nlet rec epidemic2 dt n s0 i0 r0 b a answer counter =\n  if (counter == n+1) then answer else\n    let s = s0 -. dt *. b *. s0 *. i0 in\n    let i = i0 +. dt *. ((b *. s0 *. i0) -. (a *. i0)) in\n    let r = r0 +. dt *. i0 *. a in\n    epidemic2 dt n s i r b a (findMax i answer) (counter+1);;\n\nlet epidemic (tm: int) (n: int) (s0: float) (i0:float) (b: float) (a: float): int =\n  let dt = (float_of_int tm)\/.(float_of_int n) in\n  int_of_float(epidemic2 dt n s0 i0 0.0 b a i0 0);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217365,"user_id":null,"body":"let epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) =\n  let interval = float_of_int tm \/. float_of_int n in\n  let next_s s i =\n    s -. interval *. b *. s *. i in\n  let next_r r i =\n    r +. interval *. i *. a in\n  let next_i s i =\n    i +. interval *. (b *. s *. i -. a *. i) in\n  let ns = ref s0 in\n  let nr = ref 0. in\n  let ni = ref i0 in\n  let m = ref i0 in\n  for i = 1 to n do\n    let ps = !ns in\n    let pr = !nr in\n    let pi = !ni in\n    ns := next_s ps pi;\n    nr := next_r pr pi;\n    ni := next_i ps pi;\n    m := max !ni !m;\n  done;\n  int_of_float !m\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217366,"user_id":53,"body":"open Num;;\n\nlet rec aux tm s i r t b a dt imax =\n  if (t >= tm) then imax\n  else \n    let sd = dt *. (b *. s *. i *. -1.0) in\n    let id = dt *. (b *. s *. i -. a *. i) in\n    let rd = dt *. (a *. i) in\n    let s = s +. sd in\n    let i = i +. id in\n    let r = r +. rd in\n    let t = t +. dt in\n    let imax = max imax (floor i) in\n    aux tm s i r t b a dt imax\n;;\n\nlet epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  int_of_float (aux (float_of_int tm) s0 i0 0.0 0.0 b a ((float_of_int tm) \/. (float_of_int n)) 0.0)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217367,"user_id":480,"body":"let epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  let r0=0. and dt=(float_of_int tm)\/.(float_of_int n)in\n  let rec maxi k s i r m=\n    let s= s -. dt *. b *. s *. i\n      and i= i +. dt *. (b *. s *. i -. a *. i)\n      and r=r +. dt *. i *. a\n    in\n      let m=if i<m then m else i in\n      if k==n then m else maxi (k+1) s i r m\n  in\n    int_of_float (maxi 0 s0 i0 r0 i0 )\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217368,"user_id":null,"body":"let epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n    let dt = (float_of_int tm) \/. (float_of_int n) in\n    let rec loop s i r k max_i = \n        if k = n then max_i |> int_of_float\n        else\n            let s' = s *.(1.0 -. dt *. b *. i) in\n            let i' = i +. dt *. (b *. s *. i -. a *. i) in\n            let r' = r +. dt *. i *. a in\n            loop s' i' r' (k + 1) (max max_i i')\n    in loop s0 i0 0.0 0 min_float\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217369,"user_id":null,"body":"let epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  let actual = ref i0 and expected = ref 0. and reco = ref 0. and sus = ref s0 and aux = ref 0. and max = ref i0 in\n\nfor i=1 to n do\n\n    expected := !actual;\n    aux := !sus;\n    reco := !reco +. ((float_of_int(tm) -.  float_of_int(0))\/.(float_of_int(n)-.float_of_int(0)))*.(!actual)*.a;\n    sus := !sus -. ((float_of_int(tm) -.  float_of_int(0))\/.(float_of_int(n)-.float_of_int(0))) *. b *. (!expected) *. (!sus);\n    actual := !actual +. ((float_of_int(tm) -.  float_of_int(0))\/.(float_of_int(n)-.float_of_int(0)))*.  ( b *.(!actual) *. (!aux) -. a *. (!actual));\n    \nif !max < !actual then max := !actual ;\n    \n    done;\n  int_of_float(!max);;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217370,"user_id":null,"body":"let epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  let tm1 = ref true and ik = ref i0 and ik2 = ref i0 and sk = ref s0 and dt = float_of_int tm \/. float_of_int n in \n  while !tm1 = true do\n    ik := !ik +. dt *.( b *. !sk *. !ik -. a*. !ik);\n    sk := !sk -. dt *. !sk *. !ik2 *. b;\n    ik2 := !ik;\n    if int_of_float (b*. !sk *. !ik -. a*. !ik) < 0 then tm1 := false \n    done; int_of_float !ik;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217371,"user_id":null,"body":"let epidemic (tm: int) (n: int) (s0: float) (i0: float) (b: float) (a: float) = \n  let dt = (float_of_int tm) \/. (float_of_int n) in\n  let s = ref s0 and i = ref i0 and r = ref 0. in\n  let imax = ref i0 in\n  for _ = 1 to n do\n    let new_s = !s -. dt *. b *. !s *. !i\n    and new_i = !i +. dt *. (b *. !s *. !i -. a *. !i)\n    and new_r = !r +. dt *. !i *. a\n    in s := new_s; i := new_i; r := new_r; if !i > !imax then imax := !i\n  done;\n  int_of_float !imax;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5667e8f4e3f572a8f2000039":[{"id":217372,"user_id":492,"body":"let accum (s:string): string =\n  Str.split(Str.regexp \"\") (lowercase_ascii s) |> Array.of_list\n  |> Array.mapi(fun i ch -> \n                 (uppercase_ascii ch) ^ (string_repeat_ i ch)) \n  |> Array.to_list \n  |> String.concat \"-\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217373,"user_id":null,"body":"let accum (s: string): string = s\n  |> String.to_seq\n  |> List.of_seq\n  |> List.mapi (fun i c -> String.make 1 (Char.uppercase_ascii c) ^ String.make i (Char.lowercase_ascii c))\n  |> String.concat \"-\"","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217374,"user_id":492,"body":"let accum (s:string): string =\n  Str.split(Str.regexp \"\") (lowercase_ascii s) |> Array.of_list\n  |> Array.mapi(fun i ch -> \n                 (uppercase_ascii ch) ^ (string_repeat_ i ch)) \n  |> Array.to_list \n  |> String.concat \"-\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217375,"user_id":null,"body":"let accum str =\n    let lst = str |> String.to_seq |> List.of_seq in\n    let stringlist = \n        List.mapi (fun ix chr -> String.(chr |> make (ix + 1) |> lowercase_ascii |> capitalize_ascii)) lst\n    in String.concat \"-\" stringlist","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217376,"user_id":null,"body":"let rec accum (s:string): string =\n  let rec help (s: string) (i: int): string = \n    match s with\n    | \"\" -> \"\"\n    | x  -> \n      let first = x.[0] in\n      let rest  = String.sub x 1 ((String.length x)-1) in\n      (if i = 1 then \"\" else \"-\") ^ ((Bytes.make i first) |> String.lowercase |> String.capitalize) ^ help rest (i+1)\n    in help s 1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217377,"user_id":null,"body":"let str_to_list (str: string): char list = List.init (String.length str) (String.get str)\n\nlet list_to_str (lst: char list): string = String.init (List.length lst) (List.nth lst)\n\nlet accum (s: string): string =\n  let generate i c = List.init (i + 1) (fun i -> if i == 0 then Char.uppercase_ascii c else Char.lowercase_ascii c)\n  in\n    str_to_list s \n    |> List.mapi generate \n    |> List.map list_to_str \n    |> String.concat \"-\"\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217378,"user_id":null,"body":"let rec replicate item counter limit answer =\n  if counter == limit+1 then (answer ^ \"-\") else\n    if counter == 1 then \n      replicate item (counter+1) limit (answer ^ String.uppercase_ascii(item)) else\n        replicate item (counter+1) limit (answer ^ String.lowercase_ascii(item));;\n\nlet rec accum2 str lenS answer =\n  if lenS == 0 then (String.sub answer 0 ((String.length answer)-1)) else \n    let letter = String.sub str (lenS-1) 1 in\n    accum2 str (lenS-1) ((replicate letter 1 lenS \"\") ^ answer);;\n\nlet accum (s:string): string =\n  let len = String.length s in\n  accum2 s len \"\";;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217379,"user_id":null,"body":"let explode s = List.init (String.length s) (String.get s)\n\nlet rec char_times i c =\n  match i with\n    |0 -> (String.uppercase (Char.escaped c))\n    |n -> (char_times (n-1) c) ^ (Char.escaped c)\n\nlet rec string_of_list = function\n  |(hd::[])->hd\n  |(hd::tl)->hd^\"-\"^(string_of_list tl)\n\nlet accum (s:string): string =\n  s |> String.lowercase |> explode |> List.mapi char_times |> string_of_list","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217380,"user_id":null,"body":"let accum (s:string): string =\n  let stutter l n = String.(uppercase_ascii l ^ make n (get (lowercase_ascii l) 0)) in\n  let butfirst s = String.(sub s 1 ((length s)-1)) in\n  let rec f s acc i =\n    match s with\n    | \"\" -> acc\n    | _  -> stutter (String.sub s 0 1) i\n           :: f (butfirst s) acc (i+1)\n  in\n  f s [] 0 |> String.concat \"-\"","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217381,"user_id":null,"body":"let accum (s:string): string =\n  let explode s = List.init (String.length s) (String.get s) in\n  let c = ref 0 in\n  let n = ref 0 in\n  let f = ref (String.length s) in\n  let str1 = ref \"\" in\n  let str2 = ref \"\" in\n  let a = Array.of_list (explode s) in\n  let rec loop k =\n    if k=(!f) then !str2 else\n    if (!n)=0 then\n      (str1 := !str1 ^ String.capitalize_ascii ((String.make 1 (a.(!n)))) ^ (String.make !c (Char.lowercase (a.(!n)))) ;\n       c := !c + 1 ;\n       n := !n + 1 ;\n       str2 := !str2 ^ !str1 ;\n       str1 := \"\" ;\n       loop (k+1)) else\n      (str1 := !str1 ^ String.capitalize_ascii ((String.make 1 (a.(!n)))) ^ (String.make !c (Char.lowercase (a.(!n)))) ;\n       c := !c + 1 ;\n       n := !n + 1 ;\n       str2 := !str2 ^ \"-\" ^ !str1 ;\n       str1 := \"\" ;\n       loop (k+1))\n  in loop 0;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"566be96bb3174e155300001b":[{"id":217382,"user_id":492,"body":"let roundf x = floor (x +. 0.5)\n\nlet max_ball (v0: int): int =\n    int_of_float (roundf((float_of_int(v0) \/. 3.6) \/. 0.981));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217383,"user_id":492,"body":"let roundf x = floor (x +. 0.5)\n\nlet max_ball (v0: int): int =\n    int_of_float (roundf((float_of_int(v0) \/. 3.6) \/. 0.981));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217384,"user_id":null,"body":"let max_ball (v0: int): int = \n  let v0' = float_of_int v0 \/. 3.6 in\n  let h t = (v0' *. t) -. (0.5 *. 9.81 *. t *. t) in\n  let rec find_max time max =\n    let new_time = (time +. 1.) in\n    let new_height = h (new_time \/. 10.) in\n    if new_height < max \n      then int_of_float new_time - 1\n      else find_max new_time new_height\n    in\n   find_max 0. 0.\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217385,"user_id":null,"body":"let max_ball (v0: int): int = \n  let g = 9.81 in \n  let mps_of_kmph (kmph:float) : float = kmph \/. 3.6 in (*1km \/ 1h * 1000m\/1km * 1hr\/3600s *)\n  let v = mps_of_kmph (float_of_int v0) in\n  let rec helper (dt : int) (highest: float) : int = \n    let t = (float_of_int dt) \/. 10.0 in\n    let next_height = (v *. t) -. (0.5 *. g *. t *. t) in\n    if next_height < highest then dt - 1\n    else helper (dt + 1) next_height\n  in (helper 0 0.0)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217386,"user_id":50,"body":"let max_ball (v0: int): int = int_of_float ((float v0) \/. 3.5316 +. 0.5) ;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217387,"user_id":null,"body":"let max_ball (v0: int): int =\n  let rec maxing h t c =\n    let h1 = ((float_of_int(v0))\/. 3.6 *. t) -. (0.5 *. 9.81 *. t *. t) in\n    if h1 >= h then maxing h1 (t +. 0.1) (c+1)\n    else c -1\n  in maxing 0.0 0.0 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217388,"user_id":53,"body":"let max_ball (v0: int): int = \n  (int_of_float (floor (((float_of_int v0) \/. 3.5316) +. 0.5)))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217389,"user_id":null,"body":"let max_ball (v0: int): int =\n  let frnd f = floor (f +. 0.5)\n  in int_of_float (frnd ((float_of_int v0) *. 25.0 \/. 9.0 \/. 9.81))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217390,"user_id":null,"body":"let max_ball (v0: int): int =\n    let v = (float_of_int v0) \/. 3.6 in\n    let g = 9.81 in\n    let h v t = v *. t -. 0.5 *. g *. (t ** 2.0) in\n    let rec loop k t max_h = \n        let height = h v t in\n        if height <= max_h then (k - 1)\n        else loop (k + 1) (t +. 0.1) height\n    in loop 0 0.0 (-1.0)\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217391,"user_id":null,"body":"let max_ball (v0: int): int = int_of_float (floor (((float) v0\/.(9.81*.3.6))*.10. +. 0.5));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"566fc12495810954b1000030":[{"id":217392,"user_id":492,"body":"let nb_dig(n: int) (d: int): int =\n  let range x y =\n    let rec aux cpt acc =\n      if cpt < x then acc\n      else aux (cpt-1) (cpt::acc)\n    in aux y []\n  in\n  let c = Char.chr (d + 48) in\n  let cnt = ref 0 in\n  let a = List.map (fun x -> string_of_int(x * x)) (range 0 n) |> String.concat \"\" in\n    String.iter (fun x -> if x = c then cnt := !cnt + 1) a;\n    !cnt;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217393,"user_id":492,"body":"let nb_dig(n: int) (d: int): int =\n  let range x y =\n    let rec aux cpt acc =\n      if cpt < x then acc\n      else aux (cpt-1) (cpt::acc)\n    in aux y []\n  in\n  let c = Char.chr (d + 48) in\n  let cnt = ref 0 in\n  let a = List.map (fun x -> string_of_int(x * x)) (range 0 n) |> String.concat \"\" in\n    String.iter (fun x -> if x = c then cnt := !cnt + 1) a;\n    !cnt;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217394,"user_id":null,"body":"let rec a_dig x d = if x >= 10 \n                      then \n                        if x mod 10 = d \n                          then (1 + a_dig (x\/10) d) \n                          else (0 + a_dig (x\/10) d)\n                      else if x = d then 1 else 0\n\nlet rec nb_dig(n: int) (d: int): int =\n  match (n,d) with\n  |(0,d) -> if d=0 then 1 else 0\n  |(n,d) -> (a_dig (n*n) d) + nb_dig (n-1) d   \n\n\n\n  (* your code *);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217395,"user_id":null,"body":"let count_digits d n =\n  let rec loop buff = function\n    | k when k < 10 -> if k = d then succ buff else buff\n    | k -> loop (if k mod 10 = d then succ buff else buff) (k \/ 10) in\n  loop 0 n\n\nlet nb_dig(n: int) (d: int): int =\n  List.init (succ n) (fun k -> count_digits d (k*k))\n    |> List.fold_left (+) 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217396,"user_id":98,"body":"let rec digits_list n =\n\tif n < 10 then\n\t\t[n]\n\telse\n\t\t(n mod 10) :: (digits_list (n \/ 10))\n\nlet nb_dig(n: int) (d: int): int =\n\tlet rec nb_dig_rec i total =\n\t\tif i > n then\n\t\t\ttotal\n\t\telse \n\t\t\tlet count = List.length (List.filter (fun x -> x = d) (digits_list (i * i)))\n\t\t\tin nb_dig_rec (i + 1) (total + count)\n\tin nb_dig_rec 0 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217397,"user_id":null,"body":"let sep s = \nlet n = String.length s -1 in\n  let rec aux a = \n    if a = 0 then [String.get s 0] else String.get s a :: aux (a-1) in \naux n\n\nlet nb_dig(n: int) (d: int): int =\n  let rec aux n = \n      if n = 0 then ['0']\n      else sep (string_of_int (n*n)) @ aux (n-1)  in\n  let l = aux n in \n  let rec aux_1 l = match l with \n      |[]->0\n      |x::ll-> if x = List.hd (sep (string_of_int d)) then 1+ aux_1 ll\n                      else aux_1 ll in \n  aux_1 l ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217398,"user_id":null,"body":"let rec nb_dig2 (number: int) (k: int) (digit: int) (counter: int) = \n  if k = number then counter else\n    let l = (k+1) * (k+1) in\n      check_digits number (k+1) l digit counter \n\nand check_digits number k l digit counter =\n  if l = 0 then nb_dig2 number k digit counter\n    else let i = l mod 10 in\n      if i = digit then check_digits number k (l\/10) digit (counter+1) else \n        check_digits number k (l\/10) digit counter;;\n\nlet nb_dig(n: int) (d: int): int =\n  let k = -1 in\n  if d=0 then nb_dig2 n k d 1\n    else nb_dig2 n k d 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217399,"user_id":null,"body":"let nb_dig(n: int) (d: int): int =\n  List.init n ((+) 1)\n  |> List.cons 0\n  |> List.map (fun x -> string_of_int (x * x))\n  |> String.concat \"\"\n  |> (fun s -> List.init (String.length s) (String.get s))\n  |> List.fold_left (fun r c -> r + (if c = Char.chr (d + 48) then 1 else 0)) 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217400,"user_id":null,"body":"let decompose_chaine s =\n  let rec decompose i accu =\n    if i < 0 then accu\n    else decompose (i-1) (s.[i]::accu)\n  in decompose (String.length s - 1) []\n\nlet decompose_int i =\n  List.map int_of_string (List.map (String.make 1)  (decompose_chaine (string_of_int i)))\n  \n  let recompose_int li =\n  int_of_string (List.fold_right (^) (List.map string_of_int li) \"\" )\n\nlet rec count l d =\n  match l with\n  |[] -> 0\n  |t::q -> if t = d then 1 + (count q d) else (count q d)\n  \nlet rec zero_to_n n =\n  if n = 0 then [0]\n  else n::(zero_to_n (n-1) )\n\nlet nb_dig(n: int) (d: int): int =\n  let squares = List.map (fun el -> el*el) (zero_to_n (n))  in\n  \n  let rec aux square_list acc =\n    match square_list with\n    |[] -> acc\n    |t::q -> aux q (acc+(count (decompose_int t) d))\n    \n    \n  in aux squares 0\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217401,"user_id":53,"body":"let nb_dig(n: int) (d: int): int =\n  let r = ref (if d = 0 then 1 else 0) in\n  for i = 1 to n do \n    let m = ref (i*i) in\n    while !m <> 0 do\n      if !m mod 10 = d then r := !r + 1;\n      m := !m \/ 10; \n    done;\n  done; \n  !r ;; ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5672682212c8ecf83e000050":[{"id":217402,"user_id":168,"body":"(* A variation of g964's solution *)\nlet dbl_linear n =\n  let q2 = Queue.create () in\n  let q3 = Queue.create () in\n  let rec loop i h =\n    if i >= n then h\n    else begin\n      Queue.add (2 * h + 1) q2;\n      Queue.add (3 * h + 1) q3;\n      let m2 = Queue.peek q2 in\n      let m3 = Queue.peek q3 in\n      if m2 < m3 then\n        (ignore (Queue.pop q2); loop (succ i) m2)\n      else if m3 < m2 then\n        (ignore (Queue.pop q3); loop (succ i) m3)\n      else\n        (ignore (Queue.pop q2); ignore (Queue.pop q3); loop (succ i) m2)\n    end in\n    loop 0 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217403,"user_id":null,"body":"let lengthen l =\n\tlet rec helper ll =\n\tmatch ll with\n\t\t| [] -> l\n\t\t| a::q -> (2*a + 1)::(3*a + 1)::(helper q) in\n\tList.sort_uniq compare (List.filter ((>=) 200000) (helper l));;\n\nlet memoize () =\n\tlet l = ref [1] in\n\tfor i = 0 to 20 do\n\t\tl := lengthen !l done;\n\t!l;;\n\nlet memo = memoize ();;\n\nlet dbl_linear = (* Brute force is sufficient *)\n  List.nth memo;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217404,"user_id":null,"body":"let dbl_linear n =\n  let elements = Array.make 1 1 in\n  let rec dL_rec elements n t p2 p3 =\n    if t <= n then\n      begin\n        if (elements.(p2)*2+1) < (elements.(p3)*3+1) then\n          dL_rec (Array.append elements [|(elements.(p2)*2+1)|]) n (t+1) (p2+1) p3\n        else if (elements.(p2)*2+1) = (elements.(p3)*3+1) then\n          dL_rec (Array.append elements [|(elements.(p2)*2+1)|]) n (t+1) (p2+1) (p3+1)\n        else dL_rec (Array.append elements [|(elements.(p3)*3+1)|]) n (t+1) p2 (p3+1)\n      end\n    else elements.(n) in\n  dL_rec elements n 1 0 0 ;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217405,"user_id":null,"body":"module Set = Set.Make (struct type t = int let compare = compare end)\n\nlet rec pending n k =\n  if n = 0 then k (Set.singleton 1)\n  else pending (n-1) @@ fun set ->\n    let mini = Set.min_elt set in\n    set \n    |> Set.remove mini \n    |> Set.add (2 * mini + 1)\n    |> Set.add (3 * mini + 1)\n    |> k\n\nlet dbl_linear n = pending n Set.min_elt ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217406,"user_id":null,"body":"open Batteries\n\nmodule IntSet = Set.Make(struct\n    type t = int\n    let compare = compare\n  end)\n\nlet dbl_linear n =\n  let rec helper set = function\n    | m when m < n ->\n       let (min, set) = IntSet.pop_min set in\n       helper\n         (IntSet.add (2 * min + 1) (IntSet.add (3 * min + 1) set))\n         (m + 1)\n    | m -> IntSet.min_elt set\n  in helper (IntSet.add 1 (IntSet.empty)) 0\n\nopen Stdlib","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217407,"user_id":null,"body":"module S = Set.Make (struct type t = int let compare = compare end)\n\nlet dbl_linear n =\n  let s = ref (S.singleton 1) in\n  let extract_min () =\n    let x = S.min_elt !s in\n    s := S.remove x !s;\n    x\n  and add x =\n    s := S.add x !s\n  in\n  for _ = 0 to n - 1 do\n    let x = extract_min () in\n    add (2 * x + 1);\n    add (3 * x + 1);\n  done;\n  extract_min ()\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217408,"user_id":53,"body":"\nlet f c a x =\n  if c == a then x + 1 else x\n\nlet dbl_linear n =\n  let x = ref 0 in\n  let y = ref 0 in\n  let u = Array.make (n + 1) 0 in\n  u.(0) <- 1;\n  for i = 1 to n do\n    let a = 2 * u.(!x) + 1 in\n    let b = 3 * u.(!y) + 1 in\n    let c = min a b in\n    u.(i) <- c;\n    x := f c a !x;\n    y := f c b !y;\n  done;\n  ignore (Printf.printf \"%d\n\" u.(n));\n  u.(n)\n  ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217409,"user_id":null,"body":"(* open List;; *)\n\nmodule NS = Set.Make(\n  struct\n    let compare = compare\n    type t = int\n  end\n);;\n\nlet dbl_linear n =\n  let rec go i xs =\n    let x = NS.min_elt xs in \n    if i == n then x\n    else\n      let xs' = NS.add_seq (List.to_seq [2*x+1; 3*x+1]) (NS.remove x xs) in\n      go (i+1) xs' in\n  go 0 (NS.singleton 1)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217410,"user_id":480,"body":"let dbl_linear n =\n  let rec aux u2 u3 k v=\n    if k==n then v else\n    let c2=List.find (fun x->2*x+1 > v) u2 and\n      c3 = List.find (fun x-> 3*x+1 > v) u3 in\n    let (x2,x3) = (2*c2+1,3*c3+1) in\n    if x2 == x3 then\n      let u2=(List.filter (fun x -> x>c2) u2)@[x2] and u3=(List.filter (fun x -> x>c3) u3)@[x3] in\n      aux u2 u3 (k+1) x2\n    else if x2<x3 then\n      let u2=(List.filter (fun x -> x>c2) u2)@[x2] and u3=u3@[x2] in\n      aux u2 u3 (k+1) x2\n    else\n      let u2=u2@[x3] and u3=(List.filter (fun x -> x>c3) u3)@[x3] in\n      aux u2 u3 (k+1) x3\n  in\n    aux [1] [1] 0 1;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217411,"user_id":168,"body":"open Batteries\n\nlet dbl_linear n =\n  (1 -- n)\n  |> fold (fun s _ ->\n        let x, s = Set.pop_min s in\n        s |> Set.add (2 * x + 1) |> Set.add (3 * x + 1))\n     (Set.singleton 1)\n  |> Set.min_elt\n  \nopen Stdlib","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"567501aec64b81e252000003":[{"id":217412,"user_id":492,"body":"let wallPaper (l: float) (w: float) (h: float) =\n    let t = [|\"zero\"; \"one\"; \"two\"; \"three\"; \"four\";\n         \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n         \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\";\n         \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"|]\n        in if (l = 0.0 || w = 0.0 || h = 0.0) then\n            t.(0)\n        else\n            t.(truncate(ceil(( ((l +. w) *. 2.0 *. h) \/. 5.2) *. 1.15)));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217413,"user_id":492,"body":"let wallPaper (l: float) (w: float) (h: float) =\n    let t = [|\"zero\"; \"one\"; \"two\"; \"three\"; \"four\";\n         \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n         \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\";\n         \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"|]\n        in if (l = 0.0 || w = 0.0 || h = 0.0) then\n            t.(0)\n        else\n            t.(truncate(ceil(( ((l +. w) *. 2.0 *. h) \/. 5.2) *. 1.15)));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217414,"user_id":null,"body":"let wallPaper l w h =\n  let numbers = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\";\n                 \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"eleven\"; \"twelve\";\n                 \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\";\n                 \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"] in\n  if l = 0. || w = 0. || h = 0. then \"zero\" else\n  let surface = 2.3 *. h *. (l +. w) in\n  let roll_surface = 10. *. 0.52 in\n  let n = int_of_float @@ ceil @@ surface \/. roll_surface in\n  List.nth numbers n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217415,"user_id":null,"body":"let wallPaper (l: float) (w: float) (h: float) =\n    let numbers = [\n        \"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \n        \"ten\"; \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteeen\"; \n        \"nineteen\"; \"twenty\"\n    ] in\n    let nr_rolls = \n        if l = 0.0 || w = 0.0 || h = 0.0 then 0\n        else \n            let area = (l +. w) *. h *. 2.0 *. 1.15 \/. 5.2 in\n            area |> ceil |> int_of_float in\n    List.nth numbers nr_rolls","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217416,"user_id":53,"body":"let wallPaper (l: float) (w: float) (h: float) =\n    let ns = [|\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n               \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"|]\n    in if (l = 0.0 || w = 0.0 || h = 0.0) then\n        ns.(0)\n    else\n        ns.(truncate(ceil(((l +. w) *. 2.3 *. h) \/. 5.2))) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217417,"user_id":null,"body":"\nlet rec intToS l x = match l with \n  |[] ->  \"\"\n  |p::q when x=0 -> p\n  |p::q -> (intToS q (x-1))\n;; \n\n\nlet calculate l w h =\n  (2. *. h *. w +. 2. *. h *. l) \/. (10. *. 0.52) *. 1.15;;\n\nlet wallPaper (l: float) (w: float) (h: float) =\n  let x = int_of_float(calculate l w h) in\n  let test = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\"; \"eleven\"; \"twelve\";\"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"] in\n\n  let temp = if (float_of_int(x)=(calculate l w h)) then\n      x\n\n    else\n      x + 1 in\n  intToS test temp;;\n\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217418,"user_id":null,"body":"let numbers = [\n  \"zero\"; \"one\"; \"two\"; \"three\";\n  \"four\"; \"five\"; \"six\"; \"seven\";\n  \"eight\"; \"nine\"; \"ten\"; \"eleven\";\n  \"twelve\";\"thirteen\"; \"fourteen\"; \"fifteen\";\n  \"sixteen\"; \"seventeen\"; \"eighteen\";\n  \"nineteen\"; \"twenty\"\n]\n\nlet wallPaper l w h =\n  let total_area = (h *. l *. 2.) +. (h *. w *. 2.) in\n  let length = total_area \/. 0.52 in\n  let adjusted_length = length *. 1.15 in\n  adjusted_length \/. 10. |>\n  ceil |>\n  int_of_float |>\n  List.nth numbers\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217419,"user_id":null,"body":"\nlet int_to_word =\n  let numbers = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \n  \"nine\"; \"ten\"; \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \n  \"seventeen\"; \"eighteen\"; \"nineteen\"; \"twenty\"] in\n  List.nth numbers;;\nlet wallPaper (l: float) (w: float) (h: float) =\n  let w_paper = 0.52 and l_paper = 10. in\n  (match w, l, h with\n  | _, _, 0. | _, 0., _ | 0., _, _ -> 0\n  | _, _, _ -> (2. *. l *. h +. 2. *. w *. h) *. 1.15 \/. (w_paper *. l_paper) \n    |> ceil |> int_of_float)\n  |> int_to_word","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217420,"user_id":null,"body":"let wallPaper (l: float) (w: float) (h: float) =\n  let surface_area = (l +. w) *. 2. *. h in\n  let rolls = int_of_float @@ ceil @@ 1.15 *. surface_area \/. (10. *. 0.52) in\n  let english_of_int x =\n    let words = [| \"zero\"\n                ;  \"one\"\n                ;  \"two\"\n                ;  \"three\"\n                ;  \"four\"\n                ;  \"five\"\n                ;  \"six\"\n                ;  \"seven\"\n                ;  \"eight\"\n                ;  \"nine\"\n                ;  \"ten\"\n                ;  \"eleven\"\n                ;  \"twelve\"\n                ;  \"thirteen\"\n                ;  \"fourteen\"\n                ;  \"fifteen\"\n                ;  \"sixteen\"\n                ;  \"seventeen\"\n                ;  \"eighteen\"\n                ;  \"nineteen\"\n                ;  \"twenty\"\n                |] in\n    words. (x)\n  in\n  english_of_int rolls","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217421,"user_id":null,"body":"let wallPaper (l: float) (w: float) (h: float) =\n  let d = [\"zero\"; \"one\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"; \"seven\"; \"eight\"; \"nine\"; \"ten\";\n  \"eleven\"; \"twelve\"; \"thirteen\"; \"fourteen\"; \"fifteen\"; \"sixteen\"; \"seventeen\"; \"eighteen\";\n  \"nineteen\"; \"twenty\"]\n  in\n  let width = 0.52 in\n  let n_stripes =  ((2.0 *. l  +. 2.0 *. w) \/. width) in \n  let n_rolls = int_of_float (ceil ((h *. n_stripes) \/. 10.0 *. 1.15)) in \n  List.nth d n_rolls \n  (* your code *)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"569218bc919ccba77000000b":[{"id":217422,"user_id":492,"body":"#load \"unix.cma\"\nopen Unix\nopen Printf\n\nlet calc (a0: float) (a: float) (p: float) = \n  ceil(log(a \/. a0) \/. log(1.0 +. p \/. 36000.0))\n\nlet format_time time =\n  let tm = localtime time in\n    sprintf \"%04d-%02d-%02d\" (tm.tm_year + 1900) (tm.tm_mon + 1) tm.tm_mday\n\nlet date_nb_days (a0: float) (a: float) (p: float): string =\n  let start = Unix.mktime {Unix.tm_sec=0; tm_min=0; tm_hour=1;\n                            tm_mday=1; tm_mon=0; tm_year=2016-1900;\n                            tm_wday=0; tm_yday=0; tm_isdst=true}\n  in\n  let t_start = (fst start) \n  in\n  let t_nd = t_start +. 86400.0 *. (calc a0 a p) +. 3600.0 \n  in\n  format_time t_nd","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217423,"user_id":492,"body":"#load \"unix.cma\"\nopen Unix\nopen Printf\n\nlet calc (a0: float) (a: float) (p: float) = \n  ceil(log(a \/. a0) \/. log(1.0 +. p \/. 36000.0))\n\nlet format_time time =\n  let tm = localtime time in\n    sprintf \"%04d-%02d-%02d\" (tm.tm_year + 1900) (tm.tm_mon + 1) tm.tm_mday\n\nlet date_nb_days (a0: float) (a: float) (p: float): string =\n  let start = Unix.mktime {Unix.tm_sec=0; tm_min=0; tm_hour=1;\n                            tm_mday=1; tm_mon=0; tm_year=2016-1900;\n                            tm_wday=0; tm_yday=0; tm_isdst=true}\n  in\n  let t_start = (fst start) \n  in\n  let t_nd = t_start +. 86400.0 *. (calc a0 a p) +. 3600.0 \n  in\n  format_time t_nd","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217424,"user_id":null,"body":"let is_leap y = y mod 4 = 0 && y mod 100 <> 0 || y mod 400 = 0\n\nlet rec add_days n (y, m, d) =\n  let default = (y, m, succ d) in\n  if n = 0 then (y, m, d) else\n  if d < 28 then add_days (pred n) default else\n  match m with\n  | 2 when is_leap y -> if d = 28 then add_days (pred n) (y, 2, 29)\n                                  else add_days (pred n) (y, 3, 1)\n  | 2 -> add_days (pred n) (y, 3, 1)\n  | 4 | 6 | 9 | 11 -> if d < 30 then add_days (pred n) default\n                                else add_days (pred n) (y, succ m, 1)\n  | 12 -> if d = 31 then add_days (pred n) (succ y, 1, 1)\n                    else add_days (pred n) default\n  | _ when d <> 31 -> add_days (pred n) default\n  | _ -> add_days (pred n) (y, succ m, 1)\n\nlet date_nb_days (a0: float) (a: float) (p: float): string = \n  let ratio = a \/. a0 in\n  let coeff = 1. +. p \/. 36000. in\n  let days = int_of_float @@ ceil @@ log ratio \/. log coeff in\n  if days <= 0 then \"2016-01-01\" else\n  let y, m, d = add_days days (2016, 1, 1) in\n  Printf.sprintf \"%.4d-%.2d-%.2d\" y m d\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217425,"user_id":null,"body":"module Date : sig\n    type t\n    val create : int -> int -> int -> t\n    val next_day : t -> t\n    val to_string : t -> string\nend = struct\n    type t = {year : int; month : int; day : int}\n\n    let create year month day = {year; month; day}\n\n    let is_leap_year year =\n        if year mod 4 <> 0 then false\n        else if year mod 100 <> 0 then true\n        else year mod 400 = 0\n\n    let next_day {year; month; day} =\n        let day' = match (month, day) with\n            | (2, 28) -> if is_leap_year year then 29 else 1\n            | (2, 29) -> 1\n            | (_, 31) -> 1\n            | (_, 30) when List.mem month [4; 6; 9; 11] -> 1\n            | (_, _) -> day + 1 in\n        let month' = if day' = 1 then (month mod 12) + 1 else month in\n        let year' = if month' = 1 && day' = 1 then year + 1 else year in\n        {year = year'; month = month'; day = day'}\n\n    let to_string {year; month; day} =\n        let y = string_of_int year in\n        let m = if month < 10 then \"0\" ^ string_of_int month else string_of_int month in\n        let d = if day < 10 then \"0\" ^ string_of_int day else string_of_int day in\n        y ^ \"-\" ^ m ^ \"-\" ^ d\nend\n\n\nlet date_nb_days (a0: float) (a: float) (p: float): string =\n    let rec loop date amount =\n        if amount >= a then date\n        else loop (Date.next_day date) (amount *. (1.0 +. p \/. 36000.0)) in\n    let target_date = loop (Date.create 2016 1 1) a0 in\n    Date.to_string target_date\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217426,"user_id":null,"body":"let next_day day =\n  let l = (List.map (int_of_string) (String.split_on_char '-' day)) in\n  match l with\n  | [x; 12; 31]-> Format.sprintf \"%0.2d-%0.2d-%0.2d\" (x+1)  1 1\n  | [x; 2; 28] when x mod 4 <> 0 || x mod 4 = 0 && x mod 100 = 0 -> let y = List.hd (List.tl l) in  Format.sprintf \"%0.2d-%0.2d-%0.2d\"  x (y + 1) 1\n  | [x; 2; 29] \n  | [x; 1; 31] |  [x; 3; 31]  | [x; 4; 30]\n  | [x; 5; 31]  | [x; 6; 30]  | [x; 7; 31]  | [x; 8; 31] \n  | [x; 9; 30]  | [x; 10; 31]  | [x; 11; 30]  -> let y = List.hd (List.tl l) in  Format.sprintf \"%0.2d-%0.2d-%0.2d\"  x (y + 1) 1\n  | [x; y; z]  ->  Format.sprintf \"%0.2d-%0.2d-%0.2d\" x y (z + 1)\n  | _ -> failwith \"next_day\" \n\nlet date_nb_days (a0: float) (a: float) (p: float):string =\n  let day = \"2016-01-01\" in\n  let rec helper day acc =\n    if acc > a then day\n    else\n      helper (next_day day) (acc +. p *.acc\/. 36000.)\n  in helper day a0 \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217427,"user_id":null,"body":"open Core.Std\n\nlet date_nb_days (a0: float) (a: float) (p: float): string = \n  let days =\n    log (a\/.a0) \/. log (1.+.(p\/.36000.))\n    |> Float.round_up\n    |> Float.to_int\n  in\n  Date.(to_string (add_days (of_string \"2016-01-01\") days))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217428,"user_id":168,"body":"open Unix\n\nlet date_nb_days (a0: float) (a: float) (p: float): string =\n  let days = ceil (log (a \/. a0) \/. log1p (p \/. 36000.)) in\n  let t0, _ = mktime {(gmtime 0.) with tm_year = 116} in\n  let t = gmtime (t0 +. days *. 24. *. 3600.) in\n  Printf.sprintf \"%d-%02d-%02d\" \n    (t.tm_year + 1900) (t.tm_mon + 1) t.tm_mday","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217429,"user_id":null,"body":"open Unix\n\nlet date_nb_days (deposit: float) (target: float) (yearly_rate: float): string =\n  let rate = (yearly_rate \/. 36000.0) +. 1.0 in\n  let rec get_days current n =\n    if (current > target) then n else get_days (current *. rate) (n + 1)\n  in\n  let start = 1451606400 in\n  let day = 24*60*60 in\n  let days = get_days deposit 0 in\n  let stop = float_of_int (start + (days * day)) in\n  let t = gmtime stop in\n  Printf.sprintf \"%d-%02d-%02d\" (t.tm_year + 1900) (t.tm_mon + 1) t.tm_mday\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217430,"user_id":null,"body":"open Unix;;\nopen Printf;;\n\nlet date_nb_days (a0: float) (a: float) (p: float): string =\n  let t0 = 61409750400.0 in (* 00:00 1st Jan 2016 *)\n  let rate_per_day = p \/. 36000.0 in\n  let gain = a \/. a0 in\n  let days = 1. +. log gain \/. log (1. +. rate_per_day) in\n  let seconds = days *. 60. *. 60. *. 24. in\n  let t1 = t0 +. seconds in\n  let datetime = Unix.gmtime t1 in\n  sprintf \"%.4d-%.2d-%.2d\" datetime.tm_year (datetime.tm_mon + 1) datetime.tm_mday\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217431,"user_id":null,"body":"(*\ndate time parsing taken from here:\nhttp:\/\/pleac.sourceforge.net\/pleac_ocaml\/datesandtimes.html\n *)\n\n#load \"unix.cma\";;\nopen Unix\n\nlet rec date_nb_days initial expected rate =\n  let initial_date = 1451606400. in (* 1st of January 2016 *)\n  let daily_rate = rate \/. 36000.0 in\n  let rec helper\n            (current : float) (expected : float)\n            (daily_rate : float) ( days : int) =\n    if current >= expected then days\n    else helper\n           (current *. (1.0 +. daily_rate)) expected\n           daily_rate (days + 1)\n  in\n  let passed_days = helper initial expected daily_rate 0 in  \n  let {Unix.tm_mday=day_of_month;\n       tm_mon=month; tm_year=year;} =\n    Unix.localtime\n      (initial_date +.\n         (float passed_days *. 60. *. 60. *. 24.))\n  in\n  Printf.sprintf \"%04d-%02d-%02d\"\n    (year + 1900) (month + 1) day_of_month\n  \n                            \n    \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"569b5cec755dd3534d00000f":[{"id":217432,"user_id":53,"body":"let new_avg (xs: float list) (navg: float): int option =\n   let s = List.fold_left (fun a b -> a +. b) 0.0 xs in\n   let n = List.length xs in\n   let x = navg *. (float_of_int (n + 1)) -. s in\n   if x < 0.0 then None\n   else Some (int_of_float (ceil x))\n   ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217433,"user_id":492,"body":"let new_avg (xs: float list) (navg: float): int option =\n    let l = float_of_int (List.length xs) in\n    let sm = List.fold_left (+.) 0.0 xs in\n    let res = int_of_float(ceil((l +. 1.0) *. navg -. sm)) in\n        match res with\n            | x when x <= 0 -> None\n            | _ -> Some res","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217434,"user_id":492,"body":"let new_avg (xs: float list) (navg: float): int option =\n    let l = float_of_int (List.length xs) in\n    let sm = List.fold_left (+.) 0.0 xs in\n    let res = int_of_float(ceil((l +. 1.0) *. navg -. sm)) in\n        match res with\n            | x when x <= 0 -> None\n            | _ -> Some res","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217435,"user_id":null,"body":"let new_avg xs navg =\n  let sum l = List.fold_left (+.) 0.0 l in\n  let to_donate = float_of_int (List.length xs + 1) *. navg -. sum xs in\n  match to_donate with\n  | to_donate when to_donate > 0.0 -> Some (int_of_float (ceil to_donate))\n  | _ -> None","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217436,"user_id":null,"body":"let new_avg (xs: float list) (navg: float): int option =\n  let new_tot = navg *. float_of_int (List.length xs + 1) in\n  let curr_tot = List.fold_left (+.) 0. xs in\n  match int_of_float @@ ceil @@ new_tot -. curr_tot with\n  | v when v < 0 -> None\n  | v -> Some v","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217437,"user_id":null,"body":"let new_avg (xs: float list) (navg: float): int option =\n  let nom = navg *. float_of_int (1 + List.length xs) \n  in let s = nom -. List.fold_left (+.) 0. xs\n  in if (s <= 0.) then None\n    else Some(int_of_float(Float.ceil s))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217438,"user_id":null,"body":"let new_avg (xs: float list) (navg: float): int option =\n  let exp_sum = List.length xs |> float_of_int |> ( +. ) 1. |> ( *. ) navg in\n  let act_sum = List.fold_left (+.) 0. xs in\n  let difference = exp_sum -. act_sum in\n    if difference > 0. then Some (difference |> Float.ceil |> int_of_float) else None","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217439,"user_id":null,"body":"let new_avg (xs: float list) (navg: float): int option =\n  let rec sommeList xs = match xs with\n  []->0.0\n  |e::reste->e +. sommeList(reste) in\n  let lengthList = (List.length xs) + 1 in\n  let lastDonation = ((int_of_float(navg)) *lengthList)-int_of_float(sommeList xs) in\n  if lastDonation<=0 then None \n  else Some lastDonation;;\n  \n  \n  \n  \n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217440,"user_id":null,"body":"let new_avg xs navg =\n  let sum, cnt =\n    List.fold_left (fun (sum, cnt) x -> (sum +. x, cnt + 1)) (0.0, 0) xs\n  in\n  let r = int_of_float (Float.ceil ((navg *. float_of_int (cnt + 1)) -. sum)) in\n  if r >= 0 then Some r else None","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217441,"user_id":null,"body":"let new_avg (xs : float list) (navg : float) : int option =\n  let sum = List.fold_left ( +. ) 0. xs in\n  let length = float_of_int (List.length xs + 1) in\n  let diff = int_of_float (Float.ceil ((navg *. length) -. sum)) in\n  if diff < 0 then None else Some diff\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56a32dd6e4f4748cc3000006":[{"id":217442,"user_id":492,"body":"let fnd_stat_twn d twn = \n  let t = d \n          |> Str.split(Str.regexp \"\n\")\n          |> List.map(fun x -> Str.split(Str.regexp \":\") x)\n          |> List.filter(fun x -> List.hd x = twn) in\n    match t with\n      | [] ->[-1.0]\n      | l -> \n          List.hd(List.tl (List.hd l))\n          |> Str.split(Str.regexp \",\") \n          |> List.map(fun x -> List.hd (List.tl (Str.split(Str.regexp \" \") x)))\n          |> List.map(fun x -> float_of_string x);;\n\nlet mean (town: string) (strng: string): float =\n  let r = fnd_stat_twn strng town in\n    if List.hd r = -1.0 then (-1.0)\n    else (meanvar r).(0);;\nlet variance (town: string) (strng: string): float =\n  let r = fnd_stat_twn strng town in\n    if List.hd r = -1.0 then (-1.0)\n    else (meanvar r).(1);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217443,"user_id":null,"body":"let is_required_town (strng : string) (town : string) : bool =\n  let town_line, rainfalls =\n    Str.split (Str.regexp \":\") strng |> fun l -> List.hd l, List.tl l\n  in\n  String.equal town_line town\n;;\n\nlet rainfalls_to_floats (rainfalls : string) : float list =\n  let rainfalls =\n    Str.split (Str.regexp \",\") rainfalls\n    |> List.map (Str.split (Str.regexp \" \"))\n    |> List.map (fun month_rf -> float_of_string (List.nth month_rf 1))\n  in\n  rainfalls\n;;\n\nlet rec find_required_town (towns : string list) (town : string) =\n  match towns with\n  | [] -> []\n  | hd :: tl ->\n    if is_required_town hd town\n    then rainfalls_to_floats hd\n    else find_required_town tl town\n;;\n\nlet avg (l : float list) = List.fold_left ( +. ) 0.0 l \/. Float.of_int (List.length l)\n\nlet mean (town : string) (strng : string) : float =\n  let towns_list = Str.split (Str.regexp \"\n\") strng in\n  let floats = find_required_town towns_list town in\n  if List.length floats = 0\n  then -1.0\n  else begin\n    floats |> avg\n  end\n;;\n\n\nlet variance (town : string) (strng : string) : float =\n  let towns_list = Str.split (Str.regexp \"\n\") strng in\n  let floats = find_required_town towns_list town in\n  if List.length floats = 0\n  then -1.0\n  else begin\n    let mean = floats |> avg in\n    let variance =\n      List.fold_left\n        (fun res value -> (value -. mean) *. (value -. mean) |> ( +. ) res)\n        0.0\n        floats\n      \/. Float.of_int (List.length floats)\n    in\n    variance\n  end\n;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217444,"user_id":null,"body":"let data str =\n  let split = String.split_on_char in\n  let lines = split '\n' in\n  let name_vs_str line =\n    split ':' line |> function\n    | [ name; vs_str ] -> (name, vs_str)\n    | _ -> raise (Failure \"wrong\")\n  in\n  let mon_v_str_list s = split ',' s in\n  let mon_v v_str =\n    split ' ' v_str |> function\n    | [ _; v ] -> float_of_string v\n    | _ -> raise (Failure \"wrong\")\n  in\n  let mean vs = List.fold_left ( +. ) 0.0 vs \/. float_of_int (List.length vs) in\n  let variance vs mean =\n    let sum =\n      List.fold_left (fun acc x -> acc +. Float.pow (x -. mean) 2.) 0. vs\n    in\n    sum \/. float_of_int (List.length vs)\n  in\n  str |> lines\n  |> List.map (fun line ->\n         let name, vs_str = name_vs_str line in\n         let vs = mon_v_str_list vs_str |> List.map mon_v in\n         let mean = mean vs in\n         let variance = variance vs mean in\n         (name, mean, variance))\n\nlet mean city str =\n  str |> data |> List.find_opt (fun (c, _, _) -> String.equal c city)\n  |> function\n  | None -> -1.0\n  | Some (_, m, _) -> m\n\nlet variance city str =\n  str |> data |> List.find_opt (fun (c, _, _) -> String.equal c city)\n  |> function\n  | None -> -1.0\n  | Some (_, _, v) -> v","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217445,"user_id":null,"body":"let process_string str town = \n  let cities = List.map (fun s -> String.split_on_char ':' s) (String.split_on_char '\n' str) in\n  let rec aux = function\n  | [] -> [-12.]\n  | a::b when List.hd a = town -> \n            let months = String.split_on_char ',' (List.hd (List.tl a)) in\n            List.map (fun i -> float_of_string (List.hd (List.tl (String.split_on_char ' ' i)))) months\n  | a::b -> aux b\n  in aux cities;;\n\n\nlet mean (town: string) (strng: string): float =\n  let temperatures = process_string strng town in\n  let rec aux acc = function\n  | [] -> acc \/. 12.\n  | a::b -> aux (acc +. a) b\n  in aux 0. temperatures;;\n  \n  \nlet variance (town: string) (strng: string): float =\n  let temperatures = process_string strng town in\n  let m = mean town strng in\n  let rec aux acc = function\n  | [] -> (acc \/. 12.) -. m ** 2.\n  | a::b -> aux (acc +. (a ** 2.)) b\n  in aux 0. temperatures;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217446,"user_id":null,"body":"module StrMap = Map.Make(String);;\n\nexception Invalid_data;;\n\nlet parse str =\n  let map = ref StrMap.empty in\n  let data_rows = String.split_on_char '\n' str in\n  List.iter (fun data_row ->\n    let town_name_data = String.split_on_char ':' data_row in\n    match town_name_data with\n    | town_name::town_data::_ ->\n      let town_data_items =\n        town_data\n        |> String.split_on_char ','\n        |> List.map (fun item ->\n          match (String.split_on_char ' ' item) with\n          | month::rainfal::_ -> (month, float_of_string rainfal)\n          | _ -> raise Invalid_data\n        ) in\n        map := StrMap.add town_name town_data_items !map;\n      ()\n    | _ -> ()\n    ) data_rows;\n    !map;;\n\nlet rec calc_mean counter sum data =\n  match data with\n  | [] -> sum \/. float_of_int counter\n  | (_, rainfall)::tail ->\n    calc_mean (counter + 1) (sum +. rainfall) tail\n;;\n\nlet mean (town: string) (strng: string): float =\n  let towns_data = parse strng in\n  try\n    let town_data = StrMap.find town towns_data in\n    calc_mean 0 0.0 town_data\n  with Not_found -> -1.0\n;;\n\nlet variance (town: string) (strng: string): float =\n  let towns_data = parse strng in\n  try    \n    let town_data = StrMap.find town towns_data\n    in\n    let mean_for_town = calc_mean 0 0.0 town_data in\n    let rec aux counter squared_sum data =\n      match data with\n      | [] -> (squared_sum \/. float_of_int counter)\n      | (_, rainfall)::tail ->\n        aux (counter + 1) (((mean_for_town -. rainfall) ** 2.0) +. squared_sum) tail\n    in aux 0 0.0 town_data\n  with Not_found -> -1.0\n;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217447,"user_id":null,"body":"open List\nopen Str\n\nlet process_data data =\n  data\n  |> split (regexp \"\n\")\n  |> List.map (fun x ->\n       let head::tail = split (regexp \"[:,]\") x in\n       let rainfalls =\n         tail |> map (fun x -> x |> String.split_on_char ' ' |> fun x' -> nth x' 1 |> float_of_string)\n       in\n       (head, rainfalls)\n     )\n\nlet sum' xs = fold_right (+.) xs 0.\n\nlet mean' xs = sum' xs \/. (float_of_int @@ length xs)\n\nlet mean (town: string) (strng: string): float =\n  try\n    strng\n    |> process_data\n    |> assoc town\n    |> mean'\n  with\n  Not_found _ -> -1.\n\nlet variance' xs =\n  let mean = mean' xs in\n  xs\n  |> map (fun x -> (x -. mean) ** 2.)\n  |> mean'\n\nlet variance (town: string) (strng: string): float =\n  try\n    strng\n    |> process_data\n    |> assoc town\n    |> variance'\n  with\n  Not_found _ -> -1.\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217448,"user_id":null,"body":"let convert_to_assoc_list strng = \n    let process_line line = match String.split_on_char ':' line with\n        | [city; data] -> \n            let monthly_data = String.split_on_char ',' data in \n            let temperatures = \n                List.map (fun s -> float_of_string @@ String.sub s 4 (String.length s - 4)) monthly_data in\n                (city, temperatures)\n        | _ -> failwith \"Invalid string structure\" in\n    let process_string str = \n        let lines = String.split_on_char '\n' str in\n        List.map process_line lines in\n    process_string strng   \n\n\nlet mean town str =\n    let mapping = convert_to_assoc_list str in\n    match List.assoc_opt town mapping with\n        | None -> (-1.0)\n        | Some temperatures ->\n            (List.fold_left (+.) 0.0 temperatures) \/. float_of_int (List.length temperatures)\n            \n  \nlet variance town str =   \n    let mapping = convert_to_assoc_list str in\n    match List.assoc_opt town mapping with\n        | None -> (-1.0)\n        | Some temperatures ->\n            let n = List.length temperatures in\n            let m = (List.fold_left (+.) 0.0 temperatures) \/. float_of_int n in\n            let s = List.fold_left (fun acc x -> acc +. (x -. m) ** 2.0) 0.0 temperatures in\n            s \/. (float_of_int n)  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217449,"user_id":null,"body":"let extract town str =\n     str \n  |> String.split_on_char '\n' \n  |> List.map (String.split_on_char ':')\n  |> List.filter (function x -> String.equal (List.hd x) town)\n  |> List.hd (* Throws if the town isn't found *)\n  |> List.tl\n  |> List.hd\n  |> String.split_on_char ','\n  |> List.map (String.split_on_char ' ')\n  |> List.map (function x -> float_of_string @@ List.hd @@ List.tl x);;\n\nlet avg xs = (List.fold_left (+.) 0.0 xs) \/. (float_of_int @@ List.length xs);;\n\nlet mean (town: string) (strng: string): float = try avg (extract town strng) with Failure(_) -> -1.0;;\n\nlet variance (town: string) (strng: string): float = try\n  let vals = extract town strng in\n  let our_avg = avg vals in\n  let subvariance x = let v = (x -. our_avg) in v *. v in\n  let diffs = List.map subvariance vals in\n  avg diffs\nwith Failure(_) -> -1.0;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217450,"user_id":null,"body":"let parse_town s =\n  let [town; data] = String.split_on_char ':' s in\n  let months = String.split_on_char ',' data in\n  let nums = List.map (fun m -> let [_; n] = String.split_on_char ' ' m in float_of_string n) months in\n  (town, nums)\n  \nlet parse_towns s =\n  let items = String.split_on_char '\n' s in\n  List.map parse_town items\n\nlet mean (town: string) (strng: string): float =\n  let data = parse_towns strng in\n  if not (List.mem_assoc town data) then -1.\n  else\n    let td = List.assoc town data in\n    let total = List.fold_left (+.) 0. td in\n    total \/. float_of_int (List.length td)\n    \nlet variance (town: string) (strng: string): float =\n  let data = parse_towns strng in\n  if not (List.mem_assoc town data) then -1.\n  else\n    let td = List.assoc town data in\n    let m = (List.fold_left (+.) 0. td) \/. float_of_int (List.length td) in\n    let num = List.fold_left (fun b a -> b +. ((a -. m) ** 2.)) 0. td in\n    num \/. float_of_int (List.length td)\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217451,"user_id":98,"body":"let rec skip_line str = \n\tif str=\"\" \n\t\tthen \"\"\n\telse \n\t\tlet rest = String.sub str 1 (String.length str -1  ) in\n\tmatch str.[0] with\n\t| '\n' ->  rest\n\t| _ -> skip_line rest\n;;\n\nlet rec get_line str  = \n\tlet rec aux str1  =\n\t\tif str1=\"\" \n\t\t\tthen \"\"\n\t\telse \n\t\t\tlet rest = String.sub str1 1 (String.length str1 -1  ) in\n\t\t\tlet char = String.sub str1 0 1 in\n\t\t\tmatch char with\n\t\t\t| \"\n\" ->  \"\"\n\t\t\t| _ ->  char^(aux rest ) \n\tin  aux str \n;;\n\nlet rec extract_city cityname string =\n\tlet strlen=String.length cityname in \n\tif string = \"\" || strlen = 0\n\t\tthen \"\"\n\telse \n\t\tlet rest = String.sub string 1 (String.length string -1  ) in\n\t\tlet char = String.sub string 0 1 in\n\t\tmatch char with \n\t\t| \" \" | \"\n\" -> extract_city  cityname rest\n\t\t| _->  let substring =  String.sub string  0 strlen  in\n\t\t\t   let end_character = (String.sub string strlen 1) in\n\t\t if substring = cityname &&  (end_character = \" \" || end_character=\":\" )\n\t\t\t(*meaning that the city name if complete,not just a substring *)\n\t\t\tthen get_line string \n\t\telse\n\t\t\textract_city cityname (skip_line string)\n;;\n\t\t\nlet get_city_data city =\n\tlet rec aux str number found  = \n\t(*found = true means a number has been found *)\n\tif str=\"\"\n\t\tthen if found\n\t\t\t\tthen [number]\n\t\telse \n\t\t\t[]\n\telse let first_char= String.sub  str 0 1 in\n\t\tlet  rest = String.sub str 1 (String.length str -1 ) in\n\t\tif (first_char >=\"0\" && first_char <= \"9\") (* a digit has been found *)\n\t\t\tthen aux  rest  (number^first_char) true  \n\t\telse if first_char = \" \" && found (*space found *)\n\t\t\t\tthen number::(aux rest \"\" false )\n\t\telse if first_char =\".\"  && found \n\t\t\tthen aux  rest  (number^first_char)\ttrue\t\t\t\t\n\t\telse (*any other character *)\n\t\t\tif found\n\t\t\t\tthen number::(aux rest \"\" false )\n\t\t\telse  aux rest \"\"  found \t\t\n\tin aux city \"\"  false \n;;\n\nlet  rec float_list_of_string_list l =  \n\tmatch l with\n\t| [] ->[] \n\t| h::t ->  (float_of_string h)::float_list_of_string_list t \n;;\n\nlet rec mean_of_list list  =  \n\tlet rec sum l =  \n\tmatch l with \n\t| [] -> failwith \"empty list\"\n\t| [h] -> h\n\t| h::t -> h+.sum t \n\tin sum list \/. (float_of_int (List.length list)) \n;; \n\t\nlet rec variance_of_list list = \n\tlet mean=mean_of_list list in\n\tlet rec sum_gaps l = \n\tmatch l with \n\t| []->failwith \"empty list\"\n\t| [h] -> (h-.mean)**2.0 \n\t| h::t-> (h-.mean)**2.0  +. sum_gaps  t\n\tin sum_gaps list \/. (float_of_int (List.length list ))\n;;\n\nlet mean (town: string) (strng: string): float =\n\tlet town_string  = extract_city town strng in\n\tif town_string = \"\" \n\t\tthen -1.0  \n\telse  \n\t\tmean_of_list(float_list_of_string_list(get_city_data town_string ))\n;;\t\n\n\n\nlet variance (town: string) (strng: string): float =\n\tlet town_string  = extract_city town strng in\n\tif town_string = \"\" \n\t\tthen -1.0  \n\telse  \n\t\tvariance_of_list(float_list_of_string_list(get_city_data town_string )) \n;;\t\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56a4872cbb65f3a610000026":[{"id":217452,"user_id":492,"body":"let max_rot (n: int): int =\n  let keepAndRotString (s: string) (i: int) =\n    let res: string = String.sub s i ((String.length s) - i) in\n      (String.sub s 0 i) ^ (String.sub (res ^ res) 1 (String.length res)) in\n  let rec helper (s: string) (i: int) (smx: string): string =\n    if (i = (String.length s) - 1) then \n      smx\n    else\n      let rot = keepAndRotString s i in\n        if rot > smx then\n          helper rot (i + 1) rot\n        else helper rot (i + 1) smx in\n  let s: string = string_of_int n in\n    int_of_string (helper s 0 s);;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217453,"user_id":null,"body":"open Batteries\n\nlet max_rot (n: int): int =\n  let rec rotate locked lst =\n    match lst with\n    | [] -> [locked]\n    | h::[] -> [locked @ [h]]\n    | h::t ->\n      let lst = t @ [h] in\n      (locked @ lst) :: rotate (locked @ [List.hd lst]) (List.tl lst)\n  in\n  string_of_int n |> String.to_list |> rotate []\n  |> List.map (fun l -> String.of_list l |> int_of_string)\n  |> List.fold_left (fun acc elt -> max acc elt) n ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217454,"user_id":null,"body":"(* https:\/\/www.codewars.com\/kata\/56a4872cbb65f3a610000026\/train\/ocaml *)\nopen Batteries\n\nlet max_rot (n : int) : int =\n  let rec rotate locked = function\n    | [] -> [ locked ]\n    | [ h ] -> [ locked @ [ h ] ]\n    | h :: t ->\n      let lst = t @ [ h ] in\n      (locked @ lst) :: rotate (locked @ [ List.hd lst ]) (List.tl lst)\n  in\n  string_of_int n\n  |> String.to_list\n  |> rotate []\n  |> List.map (fun l -> String.of_list l |> int_of_string)\n  |> List.fold_left max n\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217455,"user_id":492,"body":"let max_rot (n: int): int =\n  let keepAndRotString (s: string) (i: int) =\n    let res: string = String.sub s i ((String.length s) - i) in\n      (String.sub s 0 i) ^ (String.sub (res ^ res) 1 (String.length res)) in\n  let rec helper (s: string) (i: int) (smx: string): string =\n    if (i = (String.length s) - 1) then \n      smx\n    else\n      let rot = keepAndRotString s i in\n        if rot > smx then\n          helper rot (i + 1) rot\n        else helper rot (i + 1) smx in\n  let s: string = string_of_int n in\n    int_of_string (helper s 0 s);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217456,"user_id":null,"body":"let max_rot (n: int): int =\n  let s = string_of_int n in\n  let len = String.length s in\n  let rec loop buff s = function\n    | 1 -> buff\n    | k ->\n      let new_s =   String.sub s 0 (len - k)\n                  ^ String.sub s (len - k + 1) (k - 1)\n                  ^ String.sub s (len - k) 1 in\n      loop (s :: buff) new_s (pred k) in\n  loop [] s (String.length s)\n    |> List.map int_of_string\n    |> List.fold_left max min_int","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217457,"user_id":null,"body":"let max a b = if a > b then a else b;;\n\nlet rec getCounter number counter =\n  if number \/ counter == 0 then counter \/ 10 else getCounter number (counter*10);;\n\nlet rotate number divisor =\n  let fixed = number \/ (divisor*10) in\n  let variable = number mod (divisor*10) in\n  let tail = variable \/ divisor in \n  let head = variable mod divisor in \n  (fixed*divisor*10) + (head*10) + tail;;\n\nlet rec max_rot2 number answer counter =\n  if counter == 0 then answer else\n    let newAnswer = max answer number in\n    max_rot2 (rotate number counter) newAnswer (counter \/ 10);;\n  \nlet max_rot (n: int): int =\n  let counter = getCounter n 1 in\n  max_rot2 n n counter;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217458,"user_id":null,"body":"open Printf\n\nlet rotate_left s = \n  let open String in\n  sub s 1 (length s - 1) ^ sub s 0 1\n\nlet rec rotate_left_at i acc =\n  let open String in\n  let s = List.hd acc in\n  if i = length s\n  then acc\n  else\n    let suffix = sub s i (length s - i) in\n    let prefix = sub s 0 i in\n    rotate_left_at (i + 1) ((prefix ^ rotate_left suffix) :: acc)\n\nlet rotations s =\n  rotate_left_at 0 [s] |> List.map int_of_string\n\nlet max_rot i =\n  let s = string_of_int i in\n  List.fold_left max 0 (rotations s)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217459,"user_id":null,"body":"open Batteries\n\nlet rotate_left = function\n  | [] -> failwith \"rotate_left\"\n  | hd::tl -> String.of_list (tl @ [hd])\n\nlet max_rot (n: int) =\n  let rec helper s cont = function\n    | n when n < String.length s - 1 ->\n       let start = String.sub s 0 n \n       and last = String.sub s n (String.length s - n) in\n       Format.printf \"start %s last %s\n\" start last;\n       let s_new = start ^ (rotate_left (String.to_list last)) in\n       helper s_new (fun x -> cont (max (int_of_string s) x)) (n + 1)\n    | _ -> cont (int_of_string s) in\n  let s = string_of_int n in\n  helper s (fun x -> x) 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217460,"user_id":480,"body":"let max_rot (n: int): int =\n  let l2i l=l|>  List.to_seq |> String.of_seq |> int_of_string in\n  let rec rots l=match l with\n    | [] -> []\n    | [x] -> [[x]]\n    | h::t -> \n      let l2= t@[h] in [l2] @ (List.map (fun x->(List.hd l2)::x) (rots (List.tl l2)))\n  in\n  let rec list_max l=match l with\n    | [] -> 0\n    | [x] -> x\n    | h::t -> let m1=list_max t in if h>m1 then h else m1 in\n  n::(n |> string_of_int |> String.to_seq |> List.of_seq |> rots |> List.map l2i) |> list_max;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217461,"user_id":null,"body":"open Batteries;;\n\nlet max_rot (n: int): int =\n  let len = String.length (string_of_int n) in\n  let rot i str =\n    String.sub str 0 i ^ String.sub str (i+1) (len-i-1) ^ String.sub str i 1 \n  in let rec helper acc i =\n    match i, acc with\n    | 1, _    -> acc\n    | _, h::t -> helper (rot (len-i) h :: acc) (i-1)\n  in helper [string_of_int n] len |> List.map int_of_string |> List.max;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56a5d994ac971f1ac500003e":[{"id":217462,"user_id":null,"body":"let rec take n xs =\n  match n, xs with\n    0, _ -> []\n  | _, [] -> failwith \"take\"\n  | m, y::ys -> y :: take (m-1) ys\n  \nlet longest_consec (xs: string list) (k: int): string =\n  let n = List.length xs in\n  let rec iter mxs ys =\n    try\n      let ss = String.concat \"\" (take k ys) in\n      if String.length ss > String.length mxs then iter ss (List.tl ys)\n      else iter mxs (List.tl ys)\n    with\n      _ -> mxs\n  in\n  if n = 0 || k > n || k <= 0 then \"\" \n  else iter \"\" xs\n  ","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217463,"user_id":null,"body":"let rec take n l =\n  if n = 0 then [] else\n  List.hd l :: take (n - 1) (List.tl l)\n\nlet rec drop n l =\n  if n = 0 then l else\n  drop (n - 1) (List.tl l)\n\nlet longest_consec (xs: string list) (k: int): string =\n  if xs = [] || k <= 0 || List.length xs < k then \"\" else\n  let num_iter = List.length xs - k + 1 in\n  let ini i =\n    let to_concat = take k @@ drop i xs in\n    String.concat \"\" to_concat in\n  let concatenated = List.init num_iter ini in\n  let lengths = List.map String.length concatenated in\n  let max_len = List.fold_left max min_int lengths in\n  List.find (fun w -> String.length w = max_len) concatenated","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217464,"user_id":null,"body":"let rec take res l = function\n  | 0 -> List.rev res\n  | c -> if List.length l < 1 then [] else \n      if List.length l == 1 \n      then List.rev ((List.hd l) :: res)\n      else take (List.hd l :: res) (List.tl l) (c-1)\n\nlet rec solve candidate k l = \n  if k > (List.length l) then candidate else\n    if l==[] then candidate else\n    let newcand = List.fold_left (^) \"\" (take [] l k) in\n    if (String.length newcand) > (String.length candidate) \n    then solve newcand k (List.tl l)\n    else solve candidate k (List.tl l)\n\nlet longest_consec (xs: string list) (k: int): string =\n  solve \"\" k xs","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217465,"user_id":null,"body":"let rec getStringAtPos (lst: string list) (current: int) (len: int): string = \n  match len with\n    0 -> \"\"\n    | n -> getStringAtPos lst current (len-1) ^ List.nth lst (current+n-1)\n  \nlet max x y = if String.length y > String.length x then y else x\n\nlet rec longest (lst: string list) (current: int) (k: int): string = \n  if (current + k) > List.length lst then\n    \"\"\n  else\n    max \n      (getStringAtPos lst current k) \n      (longest lst (current+1) k)\n\nlet longest_consec (xs: string list) (k: int): string = longest xs 0 k","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217466,"user_id":null,"body":"let longest_consec (xs: string list) (k: int): string =\n  let n = List.length xs in\n  if n = 0 || k > n || k <= 0 then \"\"\n  else begin\n    let rec drop n = function\n      [] when n <= 1 -> []\n      | [] -> failwith \"Empty list\"\n      | h :: t when n = 0 -> h :: t\n      | h :: t -> if n = 1 then t else drop (n - 1) t in\n    let concs = List.mapi (fun ind x ->\n      let str = ref \"\" in\n      for i = 0 + ind to k - 1 + ind do\n        str := !str ^ List.nth xs i\n      done;\n      !str) (drop (k - 1) xs) in\n    let max = ref 0 in\n    let pos = ref 0 in\n    let rec get_first_max cur = function\n      [] -> ()\n      | h :: t -> if h > !max then (max := h; pos := cur);\n        get_first_max (cur + 1) t\n    in get_first_max 0 (List.map String.length concs);\n    List.nth concs !pos\n  end;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217467,"user_id":null,"body":"open Batteries\n\nlet longest_consec (xs: string list) (k: int): string =\n  let arr = Array.of_list xs in\n  if Array.length arr < k then \"\"\n  else\n  let concat i =\n    (i, String.concat \"\" (Array.to_list  (Array.sub arr i k ))) in\n  let lst = ref [] in\n  for i = 0 to Array.length arr - k do\n    lst := (concat i)::!lst \n  done;\n  let c  x y =\n    let (i, x) = x and (j, y) = y in\n    if (String.length x) <> (String.length y)\n    then compare (String.length y) (String.length x)\n    else compare i j in\n  let lst =List.fast_sort c !lst in\n  snd (List.hd lst)\n  \n  open Stdlib","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217468,"user_id":null,"body":"\n  \nlet longest_consec (xs: string list) (k: int): string =\n  let rec get_k k acc lst =\n    if k > List.length lst then \"\"\n    else\n      if k = 0 then acc\n      else\n        match lst with\n          hd::tl -> get_k (k - 1) (acc ^hd) tl\n        | _ -> acc\n  in  \n  let rec aux cur lst =\n    match lst with\n      [] -> cur\n    | hd::tl -> let can = get_k k \"\" lst in\n                if String.length can > String.length cur\n                then aux can tl\n                else aux cur tl\n  in\n  aux \"\" xs","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217469,"user_id":null,"body":"let longest_consec (xs: string list) (k: int): string = \n    let arr = Array.of_list xs in\n    let n = Array.length arr in\n    let rec loop acc s = \n        if s + k > n then acc\n        else \n            let subarray = Array.sub arr s k in\n            let substring = subarray |> Array.to_list |> String.concat \"\" in\n            let acc' = if String.length substring > String.length acc then substring else acc in\n            loop acc' (s + 1) in\n    if k <= 0 then \"\"\n    else loop \"\" 0\n    ","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217470,"user_id":null,"body":"let concatenate xsa start stop =\n  let ans = ref \"\" in\n  for i = start to stop-1 do ans := !ans ^ xsa.(i) done; !ans;;\n\nlet longest_consec (xs: string list) (k: int): string =\n  let xsa = Array.of_list xs in\n  let n = Array.length xsa in\n  if k > n || n = 0 || k <= 0 then \"\" else\n  (\n  let sizes = Array.make (n-k+1) 0 in\n    for i = 0 to k-1 do\n      sizes.(0) <- sizes.(0) + String.length xsa.(i)\n    done;\n    for i = 1 to n-k do\n      sizes.(i) <- sizes.(i-1) + String.length xsa.(k-1+i) - String.length xsa.(i-1)\n    done;\n  let indmax = ref 0 in\n  for i = 1 to n-k do\n    if sizes.(i) > sizes.(!indmax) then indmax := i;\n  done; concatenate xsa !indmax (!indmax+k)\n  );;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217471,"user_id":null,"body":"let longest_consec (xs: string list) (k: int): string = \n  let rec aux lst1 max str = \n    match lst1 with\n    |[] -> str\n    |a::q -> let s = ref \"\" in\n        let rec ax l i acc = \n          match l with\n          |[] -> acc\n          |b::p -> if i < k then ax p (i+1) (acc^b) else (acc^b) \n        in s := ax lst1 1 \"\";\n        if String.length !s > max then aux q (String.length !s) !s\n        else aux q max str \n  in if List.length xs < k then \"\" else \n  if k = 0 then \"\" else aux xs 0 \"\";;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56af1a20509ce5b9b000001e":[{"id":217472,"user_id":null,"body":"open String\nopen List\n\nlet get_zip s =\n  let ls = split_on_char ' ' s in\n  let len = length ls in\n  nth ls (len - 2) ^ \" \" ^ nth ls (len - 1)\n;;\n\nlet get_houses s =\n  split_on_char ' ' s |> rev |> tl |> tl |> rev |> tl |> String.concat \" \"\n;;\n\nlet get_streets s = (nth @@ split_on_char ' ' s) 0\n\nlet travel (s : string) (zipcode : string) : string =\n  let ls = split_on_char ',' s in\n  let rec loop (streets, houses) = function\n    | [] -> houses, streets\n    | e :: ls ->\n      if zipcode = get_zip e\n      then loop (get_streets e :: streets, get_houses e :: houses) ls\n      else loop (streets, houses) ls\n  in\n  let streets, houses = loop ([], []) ls in\n  zipcode\n  ^ \":\"\n  ^ (String.concat \",\" @@ rev streets)\n  ^ \"\/\"\n  ^ String.concat \",\"\n  @@ rev houses\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217473,"user_id":492,"body":"let travel (s: string) (zipcode: string): string =\n  let work (srch: string) (l: string): string * string =\n    let workaux (l: string): string * string =\n      let adr = Str.split (Str.regexp \"[0-9]+ \") l\n      in\n      let nm = List.hd(Str.split (Str.regexp \" \") l)\n      in\n        nm, List.hd adr\n    in\n    \n    let rg = Str.regexp_string (\" \" ^ srch) in\n    let fnd =\n      try\n        let t = Str.search_forward rg l 0 in\n          if String.sub l (t + 1) 8 = srch then true else false;\n        with Not_found -> false\n      in\n    if fnd = true then\n      workaux (Str.replace_first rg \"\" l)\n    else (\"\", \"\")\n  in\n\n  let rec build (srch: string) (lst: string list) (acc: (string * string) list) =\n    match lst with\n    | [] -> acc |> List.filter(fun (x, y) -> (x, y) <> (\"\", \"\"))\n    | h::tl -> build srch tl ((work srch h) :: acc)\n  in\n\n  let rec mkstring (lst: (string * string) list) (r1: string) (r2: string): string =\n    match lst with\n    | [] -> (String.sub r2 0 (String.length r2 - 1)) ^ \"\/\" ^ (String.sub r1 0 (String.length r1 - 1))\n    | (h1, h2)::tl -> mkstring tl (h1 ^ \",\" ^ r1) (h2 ^ \",\" ^ r2)\n  in\n\n  if zipcode = \"\" then \":\/\"\n  else begin\n    let lst = Str.split (Str.regexp \",\") s in\n    let u = build zipcode lst [] in\n      if u = [] then zipcode ^ \":\/\"\n      else zipcode ^ \":\" ^ mkstring u \"\" \"\"\n  end;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217474,"user_id":null,"body":"open Batteries\n\nexception Invalid_address\n\n\nlet travel address_string zipcode =\n    if zipcode = \"\" then \":\/\"\n    else\n        let split_on_house_number address = match String.split_on_char ' ' address with\n            | [] -> raise Invalid_address\n            | x :: xs -> (x, String.concat \" \" xs) in\n        let has_zipcode address = String.ends_with address zipcode in\n        let remove_zipcode address = String.sub address 0 (String.length address - String.length zipcode - 1) in\n        let addresses = String.split_on_char ',' address_string in\n        let relevant_addresses =\n            List.(addresses |> filter has_zipcode |> map remove_zipcode) in\n        match relevant_addresses with\n            | [] -> String.concat \"\" [zipcode; \":\/\"]\n            | _ ->\n                let (house_numbers, streets) = List.(relevant_addresses |> map split_on_house_number |> split) in\n                let suffix = String.concat \"\/\" [String.concat \",\" streets; String.concat \",\" house_numbers] in\n                String.concat \":\" [zipcode; suffix]\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217475,"user_id":null,"body":"open Batteries\n\nlet remove_zip code address =\n  let length = String.length address in\n  let code_length = String.length code in\n  if code = (String.sub address (length - code_length) code_length) then\n    Some (String.sub address 0 (length - code_length - 1))\n  else\n    None\n    \nlet extract_numbers address = String.split address \" \"\n\nlet handle_splits (addresses, numbers) (address, number) = (addresses ^ \",\" ^ address, numbers ^ \",\" ^ number)\n\nlet combine_splits splits =\n  try Enum.reduce handle_splits splits\n  with Not_found -> (\"\", \"\")\n\nlet travel (s: string) (zipcode: string): string =\n  if zipcode = \"\" then \":\/\" else\n  let (numbers, addresses) = s\n    |> String.split_on_char ','\n    |> List.enum\n    |> Enum.filter_map (remove_zip zipcode)\n    |> Enum.map extract_numbers\n    |> combine_splits in\n  zipcode ^ \":\" ^ addresses ^ \"\/\" ^ numbers\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217476,"user_id":168,"body":"type address = {\n  house: string;\n  street_and_city: string;\n  zip: string;\n}\n\nlet extract_addresses data =\n  let re = Str.regexp \"\\\\([0-9]+\\\\)[ ]+\\\\(.*\\\\)[ ]+\\\\([A-Z][A-Z] [0-9]+\\\\)\" in\n  let extract s =\n    if not (Str.string_match re s 0) then \n      failwith (\"Bad input string: \" ^ s)\n    else {\n      house = Str.matched_group 1 s;\n      street_and_city = Str.matched_group 2 s;\n      zip = Str.matched_group 3 s;\n    } in\n  Str.split (Str.regexp \",\") data |> List.map extract\n\nlet travel (s: string) (zipcode: string): string =\n  let addresses = extract_addresses s |> List.filter (fun a -> a.zip = zipcode) in\n  let print_list () = String.concat \",\" in\n  Printf.sprintf \"%s:%a\/%a\" \n    zipcode \n    print_list (List.map (fun a -> a.street_and_city) addresses)\n    print_list (List.map (fun a -> a.house) addresses)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217477,"user_id":492,"body":"let travel (s: string) (zipcode: string): string =\n  let work (srch: string) (l: string): string * string =\n    let workaux (l: string): string * string =\n      let adr = Str.split (Str.regexp \"[0-9]+ \") l\n      in\n      let nm = List.hd(Str.split (Str.regexp \" \") l)\n      in\n        nm, List.hd adr\n    in\n    \n    let rg = Str.regexp_string (\" \" ^ srch) in\n    let fnd =\n      try\n        let t = Str.search_forward rg l 0 in\n          if String.sub l (t + 1) 8 = srch then true else false;\n        with Not_found -> false\n      in\n    if fnd = true then\n      workaux (Str.replace_first rg \"\" l)\n    else (\"\", \"\")\n  in\n\n  let rec build (srch: string) (lst: string list) (acc: (string * string) list) =\n    match lst with\n    | [] -> acc |> List.filter(fun (x, y) -> (x, y) <> (\"\", \"\"))\n    | h::tl -> build srch tl ((work srch h) :: acc)\n  in\n\n  let rec mkstring (lst: (string * string) list) (r1: string) (r2: string): string =\n    match lst with\n    | [] -> (String.sub r2 0 (String.length r2 - 1)) ^ \"\/\" ^ (String.sub r1 0 (String.length r1 - 1))\n    | (h1, h2)::tl -> mkstring tl (h1 ^ \",\" ^ r1) (h2 ^ \",\" ^ r2)\n  in\n\n  if zipcode = \"\" then \":\/\"\n  else begin\n    let lst = Str.split (Str.regexp \",\") s in\n    let u = build zipcode lst [] in\n      if u = [] then zipcode ^ \":\/\"\n      else zipcode ^ \":\" ^ mkstring u \"\" \"\"\n  end;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56b5afb4ed1f6d5fb0000991":[{"id":217478,"user_id":492,"body":"let explode2char (s: string): char list =\n  let rec loop i l =\n    if i < 0 then l else loop (i - 1) (s.[i] :: l) in\n    loop (String.length s - 1) [];;\n\nlet rec chunk n xs =\n  let rec aux k xs ys = match k, xs with\n    | 0, _ -> List.rev ys :: chunk n xs\n    | _, [] -> if ys = [] then [] else if List.length ys > n then [ys] else []\n    | _, x::xs' -> aux (k - 1) xs' (x::ys)\n  in aux n xs [];;\n\nlet cut l n =\n  let rec aux i acc = function\n    | [] -> List.rev acc, []\n    | h :: t as l -> if i = 0 then List.rev acc, l\n        else aux (i-1) (h :: acc) t  in\n    aux n [] l;;\n\nlet rotate l n =\n  let len = List.length l in\n  let n = if len = 0 then 0 else (n mod len + len) mod len in\n    if n = 0 then l\n    else let a, b = cut l n in b @ a;;\n\nlet revrotaux xs =\n  let char2int x = Char.code x - Char.code '0' in\n  let sm = xs |> List.map char2int |> List.fold_left (+) 0\n  in\n    if sm mod 2 == 0 then List.rev xs |> List.map (String.make 1) |> String.concat \"\"\n    else rotate xs 1 |> List.map (String.make 1)  |> String.concat \"\";;\n\nlet revrot str sz =\n  if ((sz <= 0) || (str = \"\") || (sz > String.length str)) then \"\"\n  else\n    List.map (fun x -> revrotaux x) (chunk sz (explode2char str)) |> String.concat \"\";;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217479,"user_id":null,"body":"\nlet getChar str idx = str.[idx]\n\nlet makeStringFromSingleChar chr = String.make 1 chr\n\n\nlet getStr ?(idx=0) str = (makeStringFromSingleChar (getChar str idx))\n\nlet reverseString  str = \n  let rec aux str idx limit acc = \n    if idx == limit then acc \n    else aux str (idx+1) limit acc ^ (getStr str ~idx:idx)\n  in aux str 0 (String.length str) \"\"\n\n\nlet rotateString str = \n  let rec aux str idx limit acc = \n    if idx == limit then (acc ^ (getStr str))\n    else aux str (idx+1) limit (acc ^ (getStr str ~idx:idx))\n  in aux str 1 (String.length str) \"\"\n\n\nlet power a b = \n  let rec aux a b idx acc = \n    if b == idx then acc\n    else aux a b (idx+1) (acc * a) in\n  aux a b 0 1\n\n\nlet isCubeSumDivisibleByTwo str = \n  let rec aux str endlimit idx acc = \n    if idx == endlimit then acc\n    else aux str endlimit (idx+1) (acc + (power (int_of_string (getStr str ~idx:idx))) 3)\n  in (aux str (String.length str) 0 0) mod 2 == 0\n\nlet resolveChunkAction str = match (isCubeSumDivisibleByTwo str) with\n    | true -> reverseString str\n    | _ -> rotateString str\n\nlet rec concat xs = match xs with\n  | [] -> \"\"\n  | h :: t -> h ^ concat t\n\n\nlet getChunks limit str sz = \n  let rec aux str initialSz sz idx limitidx chunk lst = \n    if limit == limitidx then lst\n    else if idx == sz then aux str initialSz (sz+initialSz) (idx) (limitidx+1) \"\" (chunk::lst)\n    else aux str initialSz sz (idx+1) (limitidx) (chunk ^ (getStr str ~idx:idx)) lst\n  in aux str sz sz 0 0 \"\" [] |> List.rev |> List.map resolveChunkAction\n\n  \nlet isStringLengthSmallerThanSize str sz = (String.length str) < sz\n\nlet revrot str sz =\n  let res str sz = if isStringLengthSmallerThanSize str sz then \"\" \n                  else (getChunks ((String.length str) \/ sz) str sz |> concat) in\n  let aux str sz = match (str, sz) with\n     (\"\", _) -> \"\"\n    |(_, 0) -> \"\"\n    | (_, _) -> res str sz\n  in aux str sz\n","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217480,"user_id":null,"body":"let stringsub s sz =\n  let rec aux accu r =\n    if String.length r < sz || r = \"\" || sz = 0 then accu\n    else let p = String.sub r 0 sz and q = String.sub r sz (String.length r -sz) in\n    aux (p::accu) q\n    in aux [\"\"] s;;\n\nlet reverse s =\n  let l = String.length s in\n  let rec aux accu i = match i with\n  | j when j = l -> String.concat \"\" accu\n  | _ -> aux ((String.sub s i 1)::accu) (i+1)\n  in aux [] 0;;\n\nlet rotate s =\n  let l = String.length s in\n  let rec aux accu i = match i with\n  | 0 -> aux ((String.sub s 0 1)::accu) (l-1)\n  | 1 -> String.concat \"\" ((String.sub s 1 1)::accu)\n  | _ -> aux ((String.sub s i 1)::accu) (i-1)\n  in aux [] 0;;\n\nlet treatment l sz =\n  let rec aux accu = function\n  | [] -> accu\n  | s::p when s = \"\" -> aux (\"\"::accu) p\n  | s::p -> let tot = ref 0 in\n          for i = 0 to sz-1 do\n          tot := !tot + (int_of_float (float_of_int(int_of_string (String.sub s i 1))**3.))\n          done; if !tot mod 2 = 0 then aux ((reverse s)::accu) p\n          else aux ((rotate s)::accu) p\n  in aux [] l;;\n\nlet revrot str sz =\n  let l = stringsub str sz in\n  let ll = treatment l sz in\n  String.concat \"\" ll;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217481,"user_id":null,"body":"let stringsub s sz =\n\tlet rec aux accu r =\n\t\tif String.length r < sz || r = \"\" || sz = 0 then accu\n\t\telse let p = String.sub r 0 sz and q = String.sub r sz (String.length r -sz) in\n\t\taux (p::accu) q\n\t\tin aux [\"\"] s;;\n\nlet reverse s =\n\tlet l = String.length s in\n\tlet rec aux accu i = match i with\n\t| j when j = l -> String.concat \"\" accu\n\t| _ -> aux ((String.sub s i 1)::accu) (i+1)\n\tin aux [] 0;;\n\nlet rotate s =\n\tlet l = String.length s in\n\tlet rec aux accu i = match i with\n\t| 0 -> aux ((String.sub s 0 1)::accu) (l-1)\n\t| 1 -> String.concat \"\" ((String.sub s 1 1)::accu)\n\t| _ -> aux ((String.sub s i 1)::accu) (i-1)\n\tin aux [] 0;;\n\nlet treatment l sz =\n\tlet rec aux accu = function\n\t| [] -> accu\n\t| s::p when s = \"\" -> aux (\"\"::accu) p\n\t| s::p -> let tot = ref 0 in\n\t\t\t\t\tfor i = 0 to sz-1 do\n\t\t\t\t\ttot := !tot + int_of_string (String.sub s i 1)\n\t\t\t\t\tdone; if !tot mod 2 = 0 then aux ((reverse s)::accu) p\n\t\t\t\t\telse aux ((rotate s)::accu) p\n\tin aux [] l;;\n\nlet revrot str sz =\n  let l = stringsub str sz in\n  let ll = treatment l sz in\n  String.concat \"\" ll;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217482,"user_id":null,"body":"let revrot str sz = \n  \n  let chunks str sz = \n\t  let s = String.length str in\n\t  let n = s \/ sz in\n\t  let t = Array.make n \"0\" in\n\t  for i = 0 to (n-1) do\n\t  \tt.(i) <- (String.sub str (i*sz) sz) done;\n\t  t in\n  \n  let transform str = \n\t  let ans = ref \"\" in\n\t  let sum = ref 0 in\n\t  let len = String.length str in\n\t  for i = 0 to (len - 1) do\n\t  \tsum := !sum + (Char.code str.[i] - 48) done;\n\t  if !sum mod 2 = 0 then\n\t  \tans := BatString.rev str else\n\t  \tans := (String.sub str 1 (len-1)) ^ (String.make 1 str.[0]);\n\t  !ans in\n  \n  let ans = ref \"\" in\n  if sz <= 0 || str = \"\" || sz > (String.length str) then () else\n\t(let array = chunks str sz in\n\tlet len = Array.length array in\n\tfor i = 0 to len - 1 do\n\t\tarray.(i) <- transform array.(i) done;\n\tfor i = 0 to len - 1 do\n\t\tans := !ans ^ array.(i) done);\n\t!ans;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217483,"user_id":null,"body":"let rot str =\n  let l = String.length str in\n    (String.sub str 1 (l-1)) ^ (String.sub str 0 1);;\n\nlet rev str = \n\tlet l = String.length str in\n\t\tString.init l (fun i -> String.get str (l - i - 1));;\n\nlet cube a =\n\tint_of_float ((float_of_int a) ** 3.);;\n\nlet sum_cube_digits str =\n\tlet rec aux n = function\n\t| s when String.length s = 1 -> n + (cube (int_of_string s))\n\t| s -> let l = String.length s in \n\t\t\taux (n + (cube (int_of_string (String.sub s 0 1)))) (String.sub s 1 (l - 1))\n\tin aux 0 str;;\n\nlet break_chunks str sz =\n\tlet rec aux list = function\n\t| s when String.length s < sz -> List.rev list\n\t| s -> let l = String.length s in\n\t\t\taux ((String.sub s 0 sz)::list) (String.sub s sz (l - sz))\n\tin aux [] str;;\n\t\nlet choose str =\n\tlet calc = sum_cube_digits str in\n\t\tif calc mod 2 = 0 then (rev str) else (rot str);;\n\nlet revrot str sz =\n  if (sz = 0) || (String.length str = 0) || (sz > String.length str) then \"\" else begin\n  let chunks = (break_chunks str sz) in\n\tList.fold_left (fun a b -> a ^ (choose b)) \"\" chunks\n\tend;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217484,"user_id":null,"body":"let reverse str = let rev = ref \"\" in for i = ((String.length str) - 1 ) downto 0 do \nrev := !rev ^ (String.make 1 str.[i] )\ndone;\n!rev;;\n\nlet rotation str = let rot = ref \"\" in for i = 0 to ((String.length str) - 2) do\nrot := !rot ^ (String.make 1 str.[i+1])\ndone; rot := !rot ^ (String.make 1 str.[0]);\n!rot;;\n\n\nlet sommecube str = let somme = ref 0 in \nfor i = 0 to (String.length (str)) - 1 do \nsomme := !somme + (int_of_char(str.[i]) - 48)*(int_of_char(str.[i]) - 48)*(int_of_char(str.[i]) - 48)\ndone;\nif !somme mod 2 = 0 then true\nelse false\n;;\n\n\nlet revrot str sz = if str = \"\" || sz <= 0 || String.length str < sz then \"\"\nelse\nlet rep = ref \"\" in for i = 0 to ((String.length str)\/sz) - 1 do \nlet chunk = String.sub str (i*sz) sz in if sommecube chunk then \nrep := !rep ^ (reverse chunk)\nelse rep := !rep ^ (rotation chunk)\ndone;\n!rep;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217485,"user_id":null,"body":"\nlet reverstr str = let liste = ref [] in for i = 0 to String.length str -1 do \nliste := (String.sub str i 1) :: !liste done;\nString.concat \"\" !liste ;;\n\nlet rotate str = let n =String.length str in if n < 2 then str else\nlet rep = ref \"\" in\nrep := (String.sub str 0 1) ^ !rep;\nfor i = 1 to n -1 do rep := (String.sub str (n-i) 1) ^ !rep done; \n!rep\n;;\n\nlet revrot str sz =\nlet taille = String.length str in \nif sz <= 0 or taille = 0  or sz > taille then \"\" else \nlet rec aux i = if (i+1) * sz > taille then \"\" else \nlet chunk = String.sub str (i * sz) sz in \nlet somme = ref 0 in\n\t\t\tfor j = 0 to sz-1 do \n\t\t\tsomme := !somme + (fun x -> x*x*x) (int_of_char chunk.[j] -48)\n\t\t\tdone;\n\tif !somme mod 2 = 0 then(print_int 1 ; reverstr chunk ^ (aux (i+1)))\n\telse(print_int 2 ; rotate chunk ^ (aux (i+1))) in\naux 0\n;;","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217486,"user_id":null,"body":"exception Fail;;\n\nlet condition chunk =\n  let even = ref true in\n  for i = 0 to String.length chunk - 1 do\n    if int_of_char chunk.[i] mod 2 = 1 then even := not !even\n  done; !even;;\n\nlet reverse chunk =\n  let ans = ref \"\" in\n  for i = String.length chunk - 1 downto 0 do\n    ans := !ans ^ (String.make 1 chunk.[i])\n  done; !ans;;\n\nlet rotate chunk = Printf.sprintf \"%s%c\" (String.sub chunk 1 (String.length chunk - 1)) chunk.[0];;\n\nlet revrot str sz =\n  let n = String.length str in\n  try if sz > n || sz <= 0 then raise Fail;\n  let ans = ref \"\" and ind = ref 0 in\n  while !ind < n \/ sz * sz do\n    let chunk = String.sub str !ind sz in\n    ans := !ans ^ (if condition chunk then reverse else rotate) chunk;\n    ind := !ind + sz\n  done; !ans  \n  with Fail -> \"\";;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217487,"user_id":null,"body":"let get_digit str =\n  let rec aux acc str n = match str.[n], n with\n  | i, 0 -> Char.code i - Char.code '0'::acc\n  | i, n -> aux (Char.code i - Char.code '0'::acc) str (n - 1)\n  in\n  aux [] str (String.length str - 1)\n  \nlet rec rotate_left acc lst_to_invert lst = match lst with\n  | [] -> List.rev (List.hd lst_to_invert::(acc))\n  | hd::tl when List.length lst_to_invert = List.length lst -> rotate_left (acc) lst_to_invert tl\n  | hd::tl -> rotate_left (hd::acc) lst_to_invert tl\n            \nlet revrot str sz =\n  let rec aux acc str sz =\n    let len = String.length str in\n    if sz > len then acc\n    else\n      let sub = String.sub str 0 sz in\n      let str = String.sub str (sz) (len - sz) in\n      let digit = get_digit sub in\n      let cub_digit = List.map (fun x -> x*x*x) digit in\n      let sum_cub = List.fold_left ((+)) 0 cub_digit in\n      if sum_cub mod 2 = 0 then\n        let nb = digit |> List.rev |> List.map string_of_int |> String.concat \"\" in\n        aux (nb::acc) str sz\n      else\n        let nb = digit |> rotate_left [] digit |> List.map string_of_int |> String.concat \"\" in\n        aux (nb::acc) str sz\n  in\n  if str = \"\" || sz <= 0 then \"\"\n  else String.concat \"\" (List.rev (aux [] str sz))\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56c04261c3fcf33f2d000534":[{"id":217488,"user_id":168,"body":"let rec sum acc f i j =\n  if i > j then acc\n  else sum (f i +. acc) f (succ i) j\n\nlet doubles (maxk: int) (maxn: int): float =\n  let v k n = 1. \/. (float_of_int (n + 1) ** float_of_int (2 * k)) in\n  let u k n = sum 0. (v k) 1 n \/. float_of_int k in\n  sum 0. (fun k -> u k maxn) 1 maxk","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217489,"user_id":492,"body":"let rec range i j = if i > j then [] else i :: (range (i+1) j);;\nlet v (k: int) (n: int): float = 1.0 \/. (float_of_int k *. (float_of_int n +. 1.0) ** (2.0 *. float_of_int k));;\nlet doubles (maxk: int) (maxn: int): float = \n  let cnt = ref 0.0 in\n    for k = 1 to List.length (range 1 (maxk + 1)) - 1 do\n      for n = 1 to List.length (range 1 (maxn + 1)) - 1 do\n        cnt := !cnt +. (v k n);\n      done;\n    done;\n    !cnt;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217490,"user_id":53,"body":"let pow one mul a n =\n  let rec g p x = function\n  | 0 -> x\n  | i ->\n      g (mul p p) (if i mod 2 = 1 then mul p x else x) (i\/2)\n  in\n  g a one n\n;;\n\nlet v k n =\n  1.0 \/. ((float_of_int k) *. (pow 1.0 ( *. ) (float_of_int (n + 1)) (2 * k)))\n;;\n  \nlet u k maxn =\n  let rec loop n acc =\n    if n > maxn then acc\n    else loop (n + 1) (acc +. (v k n))\n  in loop 1 0.0\n;;\n\nlet s maxk maxn =\n  let rec loop k acc =\n    if k > maxk then acc\n    else loop (k + 1) (acc +. (u k maxn))\n  in loop 1 0.0\n;;\n\nlet doubles (maxk: int) (maxn: int): float = \n  s maxk maxn\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217491,"user_id":null,"body":"let sum l = List.fold_left (fun a b -> a +. b) 0. l;;\nlet v (k : float) (n : float) : float = 1. \/. Float.mul k (Float.pow (n +. 1.) (2. *. k));;\n\nlet u (k : int) (n : int) : float =\n  List.init n succ |> List.map (fun x -> v (float_of_int k) (float_of_int x)) |> sum\n;;\n\nlet doubles (maxk : int) (maxn : int) : float =\n  List.init maxk succ |> List.map (fun x -> u x maxn) |> sum\n;;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217492,"user_id":null,"body":"let v k n = 1. \/. ((float_of_int k) *. (float_of_int n +. 1. )**(2. *. (float_of_int k)));;\n\nlet doubles (maxk: int) (maxn: int): float = \n  let rep = ref (0.) in\n  for i = 1 to maxk do\n  for j = 1 to maxn do\n  rep := !rep +. (v i j) done;done; !rep;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217493,"user_id":null,"body":"let doubles (maxk: int) (maxn: int): float = \n  List.fold_left \n    (+.)\n    0.\n    (List.init \n       maxn\n       (fun n -> let nn = Float.of_int (n+2) in\n                 List.fold_left\n                   (+.)\n                   0.\n                   (List.init\n                      maxk\n                      (fun k -> let kk = Float.of_int (k+1) in\n                                1. \/. (kk *. (nn) ** (2.*.kk))))));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217494,"user_id":null,"body":"let doubles (maxk: int) (maxn: int): float = \n  let v k n = let n = float_of_int n and k = float_of_int k in\n            1. \/. (k *. ((n +. 1.)**(2. *. k))) in\n  let lst n = List.init n ((+) 1) in\n  let u n k = List.fold_left ((+.)) 0. (List.map (v k) (lst n))\n  in\n  List.fold_left ((+.)) 0. (List.map (u maxn) (lst maxk))\n                    \n\n\n\n\n\n                      \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217495,"user_id":null,"body":"let doubles (maxk: int) (maxn: int): float = \n    let rec loop acc k = \n        if k > maxk then acc\n        else \n            let k' = float_of_int k in\n            let row = List.init maxn (fun ix -> 1.0 \/. (float_of_int (maxn - ix) +. 1.0) ** (2.0 *. k')) in\n            let s = List.fold_left (+.) 0.0 row in\n            loop (acc +. (s \/. k')) (k + 1) in\n    loop 0.0 1   ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217496,"user_id":null,"body":"let doubles (maxk : int) (maxn : int) : float =\n  (let t = ref 0. in\n   for k = 1 to maxk do\n     for n = 1 to maxn do\n       t := !t +. 1. \/. (float k *. (float n +. 1.) ** (2. *. float k))\n     done\n   done;\n   !t);","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217497,"user_id":null,"body":"let doubles (maxk: int) (maxn: int): float = \n  let open Core in\n  let open List in\n  let v k n = 1. \/. (k *.  ((n +. 1.) ** (2. *. k))) in\n  ((range 1 (maxk + 1)) >>= fun k ->\n  (range 1 (maxn + 1)) >>= fun n ->\n  [v (Float.of_int k) (Float.of_int n)])\n  |> fold_left ~init:0. ~f:(+.)\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56cac350145912e68b0006f0":[{"id":217498,"user_id":null,"body":"let arrange (s: string) =\n    let words = String.split_on_char ' ' s in\n    let rec loop acc ix h = function\n    | [] -> List.rev (h :: acc)\n    | w :: ws -> \n        let lh = String.length h in\n        let lw = String.length w in\n        if (ix mod 2 = 0 && lh > lw) || (ix mod 2 = 1 && lh < lw)\n        then loop (w :: acc) (ix + 1) h ws\n        else loop (h :: acc) (ix + 1) w ws in\n    let reordered = loop [] 0 (List.hd words) (List.tl words) in\n    let change_case ix w = if ix mod 2 = 0 then String.lowercase_ascii w else String.uppercase_ascii w in\n    List.mapi change_case reordered |> String.concat \" \"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217499,"user_id":null,"body":"open String;;\n\nlet arrange (s: string) =\n\tlet t = Array.of_list (String.split_on_char ' ' s) in\n\tfor i = 1 to Array.length t - 1 do\n        if (i mod 2 = 1 && String.length t.(i-1) > String.length t.(i)) || (i mod 2 = 0 && String.length t.(i-1) < String.length t.(i)) then\n            (let buff = t.(i-1) in\n            t.(i-1) <- t.(i);\n            t.(i) <- buff) done;\n\tfor i = 0 to Array.length t - 1 do\n\t\tif i mod 2 = 0 then\n\t\t\tt.(i) <- String.lowercase_ascii t.(i) else\n\t\t\tt.(i) <- String.uppercase_ascii t.(i) done;\n\tString.concat \" \" (Array.to_list t)\n        ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217500,"user_id":492,"body":"open String;;\n\n(*let lowercase_ascii s = String.lowercase s;;\nlet uppercase_ascii s = String.uppercase s;;*)\n\nlet arrange (s: string) =\n  let rec up (lst: string list): string list =\n    match lst with\n      | [] -> []\n      | [w] -> [lowercase_ascii w]\n      | w1::w2::ws ->\n          if (String.length w1 <= String.length w2) then (lowercase_ascii w1) :: (down (w2 :: ws))\n          else (lowercase_ascii w2) :: (down (w1 :: ws))\n  and down (lst: string list): string list = \n    match lst with\n      | [] -> []\n      | [w] -> [uppercase_ascii w]\n      | w1::w2::ws ->\n          if (String.length w1 >= String.length w2) then (uppercase_ascii w1) :: (up (w2 :: ws))\n          else (uppercase_ascii w2) :: (up (w1 :: ws))\n  in \n    if (s = \"\") then \"\"\n    else\n      let r1 = Str.split (Str.regexp \"[ ]+\") s in\n        (up r1) |> String.concat \" \";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217501,"user_id":null,"body":"open String;;\n\nlet arrange (s: string) =\n  let arr = Array.of_list (split_on_char ' ' s) in\n  for i = 0 to Array.length arr - 2 do\n    let size1 = String.length arr.(i)\n    and size2 = String.length arr.(i+1) in\n    if size1 > size2 && i mod 2 = 0 || size1 < size2 && i mod 2 = 1 then\n    (let buff = arr.(i) in arr.(i) <- arr.(i+1); arr.(i+1) <- buff);\n    arr.(i) <- (if i mod 2 = 0 then lowercase_ascii else uppercase_ascii) arr.(i)\n  done;\n  let final = Array.length arr - 1 in\n  arr.(final) <- (if final mod 2 = 0 then lowercase_ascii else uppercase_ascii) arr.(final);\n  concat \" \" (Array.to_list arr);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217502,"user_id":null,"body":"open String;;\n\nlet arrange (s: string) =\n  let s_list = String.split_on_char ' ' s in\n  let rec aux buff comp = function\n  | [] -> String.concat \" \" (List.mapi (fun i a -> if i mod 2 = 0 then (String.lowercase_ascii a) else (String.uppercase_ascii a)) (List.rev buff))\n  | [a] -> aux (a::buff) comp []\n  | a::b::t -> let la = String.length a in \n               let lb = String.length b in\n               if comp la lb then aux (a::buff) (fun x y -> x = y || not (comp x y)) (b::t)\n               else aux (b::buff) (fun x y -> x = y || not (comp x y)) (a::t)\n  in aux [] (<=) s_list;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217503,"user_id":null,"body":"open String;;\nlet explode s = split_on_char ' '  s\nlet arrange (s: string) =\n  let up_or_down n = match n mod 2 with\n    | 0 -> lowercase_ascii\n    | 1 -> uppercase_ascii\n  in\n  let rec help acc s n = match s with\n    | [] -> String.concat \" \" (List.rev acc)\n    |  a::[] -> String.concat \" \" (List.rev (up_or_down n a::acc))\n    | a::b::tl ->\n       let (a', b') = if String.length a == String.length b then\n                        (up_or_down n a, b)\n                             \n                      else\n                        match String.length a < String.length b, n mod 2 with\n                        | true, 0 | false, 1 -> (up_or_down n a, b)\n                        | false, 0 | true, 1 -> (up_or_down n b, a)\n         | _ -> (a, b)\n       in\n       help (a'::acc) (b'::tl) (n+1)\n  in\n  help [] (explode s) 0;;\n                  \n\nprint_endline (arrange \"who hit retaining The That a we taken\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217504,"user_id":null,"body":"\nlet arrange s =\n  let l = Str.split (Str.regexp \" \") s in\n  let rec aux l =\n    match l with\n    | [] -> []\n    | a::[] -> (String.lowercase a)::[]\n    | a::b::h ->\n       if String.length a > String.length b then \n         (String.lowercase b)::aux' (a::h)  else (String.lowercase a)::aux' (b::h)\n  and aux' l =\n    match l with\n    | [] -> []\n    | a::[] -> (String.uppercase a)::[]\n    | a::b::h ->\n       if String.length a < String.length b then \n         (String.uppercase b)::aux (a::h) else (String.uppercase a)::aux (b::h)\n  in\n  String.concat \" \" (aux l)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217505,"user_id":168,"body":"let arrange (s: string) =\n  let tr s = if s > 0 then String.lowercase else String.uppercase in\n  let rec loop sgn = function\n  | x :: y :: xs ->\n    if (String.length y - String.length x) * sgn < 0 then\n      (tr sgn y) :: loop (-sgn) (x :: xs)\n    else\n      (tr sgn x) :: loop (-sgn) (y :: xs)\n  | [x] -> [tr sgn x]\n  | [] -> [] in\n  s |> Str.split (Str.regexp \" \") |> loop 1 |> String.concat \" \"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217506,"user_id":492,"body":"open String;;\n\nlet lowercase_ascii s = String.lowercase s;;\nlet uppercase_ascii s = String.uppercase s;;\n\nlet arrange (s: string) =\n  let rec up (lst: string list): string list =\n    match lst with\n      | [] -> []\n      | [w] -> [lowercase_ascii w]\n      | w1::w2::ws ->\n          if (String.length w1 <= String.length w2) then (lowercase_ascii w1) :: (down (w2 :: ws))\n          else (lowercase_ascii w2) :: (down (w1 :: ws))\n  and down (lst: string list): string list = \n    match lst with\n      | [] -> []\n      | [w] -> [uppercase_ascii w]\n      | w1::w2::ws ->\n          if (String.length w1 >= String.length w2) then (uppercase_ascii w1) :: (up (w2 :: ws))\n          else (uppercase_ascii w2) :: (up (w1 :: ws))\n  in \n    if (s = \"\") then \"\"\n    else\n      let r1 = Str.split (Str.regexp \"[ ]+\") s in\n        (up r1) |> String.concat \" \";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56dbe0e313c2f63be4000b25":[{"id":217507,"user_id":492,"body":"let hor_mirror (s: string): string = \n  s |> Str.split (Str.regexp \"\n\") |> List.rev |> String.concat \"\n\";;\nlet vert_mirror (s: string): string =\n  let string_rev s = \n    s |> Str.split (Str.regexp \"\") |> List.rev |> String.concat \"\"\n  in\n  s |> Str.split (Str.regexp \"\n\") |> List.map(fun x -> string_rev x) |> String.concat \"\n\";;\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217508,"user_id":492,"body":"let hor_mirror (s: string): string = \n  s |> Str.split (Str.regexp \"\n\") |> List.rev |> String.concat \"\n\";;\nlet vert_mirror (s: string): string =\n  let string_rev s = \n    s |> Str.split (Str.regexp \"\") |> List.rev |> String.concat \"\"\n  in\n  s |> Str.split (Str.regexp \"\n\") |> List.map(fun x -> string_rev x) |> String.concat \"\n\";;\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217509,"user_id":null,"body":"let sp x = List.map (fun x -> List.of_seq (String.to_seq x)) (String.split_on_char '\n' x)\nlet jn x = String.concat \"\n\" (List.map (fun x -> String.of_seq (List.to_seq x)) x)\nlet vert_mirror (s: string): string = jn (List.map List.rev (sp s))\nlet hor_mirror (s: string): string = jn (List.rev (sp s))\nlet oper (f:  string -> string) (s: string) = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217510,"user_id":null,"body":"let matrix_of_string s =\n  let l = String.split_on_char '\n' s in\n  List.map (fun s -> List.init (String.length s) (fun i -> String.make 1 @@ String.get s i)) l\n\nlet string_of_matrix m =\n  String.concat \"\n\" @@ List.map (String.concat \"\") m\n\nlet hor_mirror (s: string): string = \n  string_of_matrix @@ List.rev @@ matrix_of_string s\n\nlet vert_mirror (s: string): string =\n  string_of_matrix @@ List.map List.rev @@ matrix_of_string s\n\nlet oper = (@@)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217511,"user_id":null,"body":"let hor_mirror (s: string): string = \n  s |> String.split_on_char '\n' |> List.rev |> String.concat \"\n\"\n\n\nlet rev_str s =\n  let rec rev i acc = \n    if i = 0 then acc ^ String.sub s i 1 else acc ^ String.sub s i 1 ^ rev (i - 1) acc\n  in rev (String.length s - 1) \"\"\n\nlet vert_mirror (s: string): string =\n  s \n  |> String.split_on_char '\n' \n  |> List.map rev_str\n  |> String.concat \"\n\"\n\nlet oper f s = \n  let () = print_endline s in\n  f @@ s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217512,"user_id":null,"body":"\nlet mirror_str s =\n  let lst_of_s = List.init (String.length s) (fun i -> String.make 1 (String.get s i))\n  in\n  String.concat \"\" (List.rev lst_of_s)\n\nlet hor_mirror (s: string): string = \n s\n |> String.split_on_char '\n' \n |> List.rev\n (* |> List.map mirror_str *)\n |> String.concat \"\n\"\n \nlet vert_mirror (s: string): string =\n  s\n  |> String.split_on_char '\n'\n  |> List.map mirror_str\n  |> String.concat \"\n\"\n  (* your code *);;\nlet oper f s =\n  f s\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217513,"user_id":null,"body":"open Str\nlet splitLines s = Str.split (Str.regexp \"\n\") s \nlet hor_mirror s = \n    let rec reverse acc l = match l with\n        | []   -> acc\n        | h::t -> reverse (h :: acc) t\n    in\n    s\n    |> splitLines \n    |> reverse  []\n    |> String.concat \"\n\"\nlet vert_mirror s = \n    let rec reverse i acc s = match i < (String.length s) with\n        | false -> acc\n        | _     -> reverse (i+1) (s.[i] :: acc) s\n    in\n    s\n    |> splitLines \n    |> List.map (reverse 0 [])\n    |> List.map (List.map (String.make 1))\n    |> List.map (String.concat \"\")\n    |> String.concat \"\n\"\n\nlet oper f s = f s\n;;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217514,"user_id":480,"body":"open List;;\nopen String;;\n\nlet hor_mirror (s: string): string = \n  let a=split_on_char '\n' s in\n  String.concat \"\n\" (List.rev a);;\n  \n\nlet vert_mirror (s: string): string =\n  let revstr s=String.of_seq (List.to_seq (List.rev (List.of_seq (to_seq s)))) in\n  let a=split_on_char '\n' s in\n  String.concat \"\n\" (List.map revstr a);;\n  \nlet oper f s = \n  f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217515,"user_id":null,"body":"let reverse s = \n  String.concat \"\" @@ List.map (String.make 1) @@ List.rev @@ List.init (String.length s) (String.get s)  \n\nlet hor_mirror (s: string): string = \n  String.concat \"\n\" @@ List.rev @@ String.split_on_char '\n' s\n  (* your code *);;\nlet vert_mirror (s: string): string =\n  String.concat \"\n\" @@ List.map reverse @@ String.split_on_char '\n' s\n  (* your code *);;\nlet oper f s = \n  f s\n  (* your code *);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217516,"user_id":null,"body":"let vert_mirror (s: string): string =\n    let xs = String.split_on_char '\n' s in\n    let reverse x = x |> String.to_seq |> List.of_seq |> List.rev |> List.map Char.escaped |> String.concat \"\" in\n    xs |> List.map reverse |> String.concat \"\n\"\n    \n    \nlet hor_mirror (s: string): string =\n    let xs = String.split_on_char '\n' s in\n    xs |> List.rev |> String.concat \"\n\"\n\n\nlet oper f s = f s\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56dbe7f113c2f63570000b86":[{"id":217517,"user_id":null,"body":"let matrix_of_string s =\n  s |> String.split_on_char '\n'\n    |> List.map (fun s -> List.init (String.length s) (fun i -> String.make 1 s.[i]))\n\nlet string_of_matrix m =\n  m |> List.map (String.concat \"\")\n    |> String.concat \"\n\"\n\nlet rot_list l =\n  List.rev_map List.rev l\n\nlet rot (s: string): string =\n  s |> matrix_of_string\n    |> rot_list\n    |> string_of_matrix\n\nlet selfie_and_rot (s: string): string =\n  let points = List.init (String.index s '\n') (fun _ -> \".\") in\n  let rotated = rot_list (matrix_of_string s) in\n  let bottom_half = List.map (fun l -> List.rev_append points l) rotated in\n  let upper_half = rot_list bottom_half in\n  string_of_matrix (upper_half @ bottom_half)\n\nlet oper = ( @@ )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217518,"user_id":null,"body":"open String\nopen List\n\nlet explode s =\n  let rec exp i l = if i < 0 then l else exp (i - 1) (s.[i] :: l) in\n  exp (String.length s - 1) []\n;;\n\nlet rot (s : string) : string =\n  let rec loop acc = function\n    | [] -> acc\n    | c :: s -> loop (c :: acc) s\n  in\n  explode s |> loop [] |> fold_left (fun s c -> s ^ String.make 1 c) \"\"\n;;\n\nlet selfie_and_rot s =\n  let s = \n    split_on_char '\n' s\n    |> map (fun s -> s ^ String.make (String.length s) '.')\n    |> fold_left (fun acc s -> acc ^ \"\n\" ^ s) \"\"\n  in\n  let res = s ^ \"\n\" ^ rot s in\n  sub res 1 (String.length res - 2)\n;;\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217519,"user_id":null,"body":"let rotate s = \n    let xs = String.split_on_char '\n' s in\n    let reverse x = x |> String.to_seq |> List.of_seq |> List.rev |> List.map Char.escaped |> String.concat \"\" in\n    List.(xs |> map reverse |> rev)\n\n\nlet rot(s: string): string =\n    let rotated = rotate s in\n    String.concat \"\n\" rotated\n    \n    \nlet selfie_and_rot (s: string): string = \n    let xs = String.split_on_char '\n' s in\n    let length = List.length xs in\n    let dots = String.make length '.' in\n    let upper = List.map (function row -> row ^ dots) xs in\n    let rotated = rotate s in\n    let lower = List.map (function row -> dots ^ row) rotated in\n    String.concat \"\n\" @@ upper @ lower\n    \n    \nlet oper f s = f s ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217520,"user_id":null,"body":"let rev s = \n  s |> Str.split (Str.regexp \"\") |> List.rev |> String.concat \"\"\n;;\n\nlet rot(s: string): string = \n  s |> String.split_on_char '\n' |> List.map rev |> List.rev |> String.concat \"\n\"\n;;\n\nlet selfie_and_rot (s: string): string =\n  let selfie = s \n               |> String.split_on_char '\n' \n               |> List.map (fun x -> x ^ String.make (String.length x) '.') \n               |> String.concat \"\n\" in\n  let rot = s \n            |> String.split_on_char '\n' \n            |> List.map (fun x -> String.make (String.length x) '.' ^ rev x) \n            |> List.rev \n            |> String.concat \"\n\" in\n  selfie ^ \"\n\" ^ rot\n;;\n\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217521,"user_id":492,"body":"let hor_mirror (s: string): string = \n  s |> Str.split (Str.regexp \"\n\") |> List.rev |> String.concat \"\n\";;\nlet vert_mirror (s: string): string =\n  let string_rev s = \n    s |> Str.split (Str.regexp \"\") |> List.rev |> String.concat \"\"\n  in\n    s |> Str.split (Str.regexp \"\n\") |> List.map(fun x -> string_rev x) |> String.concat \"\n\";;\n\nlet rot(s: string): string = vert_mirror (hor_mirror s);;\n\nlet selfie_and_rot (s: string): string =\n  let string_repeat (n: int) (s: string): string =\n    Array.fold_left (^) \"\" (Array.make n s) in\n  let r1 = Str.split (Str.regexp \"\n\") s \n           |> List.map (fun x -> x ^ (string_repeat (String.length x) \".\")) \n           |> String.concat \"\n\" in\n  let r2 = Str.split (Str.regexp \"\n\") (rot s)\n           |> List.map (fun x -> string_repeat (String.length x) \".\" ^ x) \n           |> String.concat \"\n\" in\n    r1 ^ \"\n\" ^ r2;;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217522,"user_id":null,"body":"let list_w_dots lst n = List.map \n  (fun s -> s ^ String.make n '.') lst\n\nlet list_revs lst n = List.rev_map \n  (fun s -> String.mapi (fun i _ -> s.[n-i-1]) s) lst\n  \nlet mods f s = \n  let lst = Str.split (Str.regexp \"\n\") s in\n    f lst (String.length (List.hd lst)) |> String.concat \"\n\"\n\nlet selfie(s: string): string = mods list_w_dots s\n\nlet rot(s: string): string = mods list_revs s\n\nlet selfie_and_rot(s: string): string = \n  let slf = selfie s in slf ^ \"\n\" ^ rot slf\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217523,"user_id":null,"body":"let lines = String.split_on_char '\n'\n\nlet string_rev s =\n  String.to_seq s\n  |> List.of_seq\n  |> List.rev\n  |> List.map (String.make 1)\n  |> String.concat \"\"\n\nlet rot(s: string): string =\n  lines s\n  |> List.map string_rev\n  |> List.rev\n  |> String.concat \"\n\"\n\nlet selfie_and_rot (s: string): string =\n  let dots = String.(make (index s '\n') '.') in\n  let normal = String.(    s |> lines |> concat @@ dots^\"\n\") in\n  let revert = String.(rot s |> lines |> concat @@ \"\n\"^dots) in\n  normal ^ dots ^ \"\n\" ^ dots ^ revert\n\nlet oper f s = f s\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217524,"user_id":null,"body":"module Utils = struct\n  let rotate s =\n    let len = String.length s in\n    String.init len (fun i -> s.[len - 1 - i])\n             \n  let mirror s =\n    [s; rotate s]\n    |> String.concat \"\n\"\n\n  let postfix str =\n    let len = String.length str in\n    str ^ String.(make len '.')\nend\n\nlet rot = Utils.rotate\n\nlet selfie_and_rot (s: string): string =\n  s\n  |> String.split_on_char '\n'\n  |> List.map Utils.postfix\n  |> String.concat \"\n\"\n  |> Utils.mirror\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217525,"user_id":null,"body":"module Utils = struct\n  let rotate s =\n    let len = String.length s in\n    String.init\n      len\n      (fun index -> s.[len - (index + 1)])\n\n  let postfix len str = str ^ String.(make len '.')\n\n  let join = List.fold_left (fun a b -> if a = \"\" then b else a ^ \"\n\" ^ b) \"\"\n\n  let length str = \n    let head_length = function\n      | [] -> 0\n      | head :: _tail -> String.length head\n    in  \n    str \n    |> String.split_on_char '\n'\n    |> head_length\n  \n  let split =  String.split_on_char '\n'\nend\n\nlet rot(s: string): string =\n  s\n  |> Utils.split\n  |> List.map Utils.rotate\n  |> List.rev\n  |> Utils.join\n\nlet selfie_and_rot (s: string): string =\n  let left =\n    s\n    |> Utils.split\n    |> List.map Utils.(postfix @@ length s)\n  in  \n  let right =\n    left\n    |> List.map Utils.rotate\n    |> List.rev\n  in  \n  left @ right\n  |> Utils.join\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217526,"user_id":480,"body":"let hor_mirror (s: string): string = \n  let a=String.split_on_char '\n' s in\n  String.concat \"\n\" (List.rev a);;\n  \n\nlet vert_mirror (s: string): string =\n  let revstr s=String.of_seq (List.to_seq (List.rev (List.of_seq (String.to_seq s)))) in\n  let a=String.split_on_char '\n' s in\n  String.concat \"\n\" (List.map revstr a);;\n  \nlet oper f s = \n  f s;;\n\nlet rot(s: string): string = \n  hor_mirror (vert_mirror s);;\n\nlet selfie_and_rot (s: string): string =\n  let a = String.concat \"\n\"  (List.map (fun s->String.concat \"\" [s;String.make (String.length s) '.']) (String.split_on_char '\n' s)) in\n  String.concat \"\n\" [a; rot a]\n  ;;\n\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56dbeec613c2f63be4000be6":[{"id":217527,"user_id":492,"body":"let diag_1_sym(s: string): string =\n  s \n  |> Str.split(Str.regexp \"\n\") \n  |> List.map(fun x -> Str.split(Str.regexp \"\") x)\n  |> transpose\n  |> List.map(fun x -> String.concat \"\" x)\n  |> String.concat \"\n\";;\n\nlet rot_90_clock(s: string): string =\n  s |> Str.split(Str.regexp \"\n\") |> List.rev |> String.concat \"\n\" |> diag_1_sym;;\n\nlet selfie_and_diag1(s: string): string =\n  let r1 = Str.split(Str.regexp \"\n\") s |> List.map(fun x -> x ^ \"|\") in\n  let r2 = Str.split(Str.regexp \"\n\") (diag_1_sym s) in\n    List.map2(fun x y -> x ^ y) r1 r2 |> String.concat \"\n\";;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217528,"user_id":null,"body":"let matrix_of_string s =\n  s |> String.split_on_char '\n'\n    |> List.map (fun s -> List.init (String.length s) (fun i -> String.make 1 s.[i]))\n\nlet string_of_matrix m =\n  m |> List.map (String.concat \"\")\n    |> String.concat \"\n\"\n\nlet rot90 m =\n  let rec loop buff = function\n    | [] | [] :: _ -> List.rev buff\n    | ls           -> loop (List.rev_map List.hd ls :: buff) (List.map List.tl ls) in\n  loop [] m\n\nlet transpose m =\n  let rec loop buff = function\n    | [] | [] :: _ -> List.rev buff\n    | ls           -> loop (List.map List.hd ls :: buff) (List.map List.tl ls) in\n  loop [] m\n\nlet diag_1_sym(s: string): string =\n  s |> matrix_of_string\n    |> transpose\n    |> string_of_matrix\n\nlet rot_90_clock(s: string): string =\n  s |> matrix_of_string\n    |> rot90\n    |> string_of_matrix\n\nlet selfie_and_diag1(s: string): string =\n  let m = matrix_of_string s in\n  let t = transpose m in\n  List.map2 (fun l1 l2 -> l1 @ \"|\" :: l2) m t\n    |> string_of_matrix\n\nlet oper = ( @@ );;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217529,"user_id":null,"body":"let extract_rows s = \n    let strings = String.split_on_char '\n' s in\n    List.map (function str -> str |> String.to_seq |> List.of_seq) strings\n\n\nlet join chars = chars |> List.map Char.escaped |> String.concat \"\"\n\n\nlet diag_1_sym s =\n    let rows = extract_rows s in\n    let rec loop acc xs = \n        if List.for_all (fun x -> x = []) xs then List.rev acc\n        else let column = List.map List.hd xs in loop (column :: acc) (List.map List.tl xs) in \n    let transpose = loop [] rows in\n    transpose |> List.map join |> String.concat \"\n\"\n    \n    \nlet rot_90_clock s =   \n    let rows = extract_rows s in\n    let rec loop acc xs = \n        if List.for_all (fun x -> x = []) xs then List.rev acc\n        else let column = List.map List.hd xs in loop (List.rev column :: acc) (List.map List.tl xs) in \n    let rotated = loop [] rows in\n    rotated |> List.map join |> String.concat \"\n\"\n    \n    \nlet selfie_and_diag1 s = \n    let diag = diag_1_sym s in\n    let s1 = String.split_on_char '\n' s in\n    let s2 = String.split_on_char '\n' diag in\n    List.map2 (fun a b -> a ^ \"|\" ^ b) s1 s2 |> String.concat \"\n\"\n\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217530,"user_id":480,"body":"let rec string_of_chars (l:char list) :string=l|> List.map (String.make 1) |> String.concat \"\";;\n\nlet diag_1_sym(s: string): string =\n  let s=s |> String.split_on_char '\n' |> List.map (fun s->s|>String.to_seq|>Array.of_seq)|>Array.of_list in\n  let n=Array.length s in\n  let rec mkline i j= [s.(j).(i)]@(if j==n-1 then [] else mkline i (j+1))  in\n  let rec mklines i= [mkline i 0]  @(if i==n-1 then [] else mklines (i+1))  in\n  mklines 0 |> List.map string_of_chars |>String.concat \"\n\" ;;\n\nlet rot_90_clock(s: string): string =\n  let s=s |> String.split_on_char '\n' |> List.map (fun s->s|>String.to_seq|>Array.of_seq)|>Array.of_list in\n  let n=Array.length s in\n  let rec mkline i j= [s.(n-1-j).(i)]@(if j==n-1 then [] else mkline i (j+1))  in\n  let rec mklines i= [mkline i 0]  @(if i==n-1 then [] else mklines (i+1))  in\n  mklines 0 |> List.map string_of_chars |>String.concat \"\n\" ;;\n\nlet selfie_and_diag1(s: string): string =\n  let a=s |> String.split_on_char '\n'\n  and b=s |> diag_1_sym |> String.split_on_char '\n'\n  in\n  let n=String.length (List.hd a) in\n  let rec aux a b=\n    match a with | [] -> [] | ha::ta->\n    match b with | [] -> [] | hb::tb->\n       [String.concat \"|\" [ha;hb]]@(aux ta tb)\n  in\n    String.concat \"\n\" (aux a b);;\n\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217531,"user_id":null,"body":"let get_col n ss = \n  ss |> List.map (fun s -> Char.escaped s.[n]) |> String.concat \"\"\n;;\n\nlet get_col_rev n ss = \n  ss |> List.map (fun s -> Char.escaped s.[n]) |> List.rev |> String.concat \"\"\n;;\n\nlet diag_1_sym(s: string): string =\n  let ss = String.split_on_char '\n' s in\n  let rec aux res = function\n    | 0 -> res\n    | n -> aux (get_col (n-1) ss :: res) (n-1)\n  in match ss with\n  | [] -> \"\"\n  | h :: t -> String.concat \"\n\" (aux [] (String.length h))\n;;\n\nlet rot_90_clock(s: string): string =\n  let ss = String.split_on_char '\n' s in\n  let rec aux res = function\n    | 0 -> res\n    | n -> aux (get_col_rev (n-1) ss :: res) (n-1)\n  in match ss with\n  | [] -> \"\"\n  | h :: t -> String.concat \"\n\" (aux [] (String.length h))\n;;\n\nlet selfie_and_diag1(s: string): string =\n  let ss = String.split_on_char '\n' s in\n  let rec aux res = function\n    | 0 -> res\n    | n -> aux (get_col (n-1) ss :: res) (n-1) in\n  let diag1 = aux [] (String.length (List.nth ss 0)) in\n  List.map2 (fun x y  -> x ^ \"|\" ^ y)  ss diag1 |> String.concat \"\n\"\n;;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217532,"user_id":null,"body":"let lines = String.split_on_char '\n'\nlet unlines = String.concat \"\n\"\n\nlet explode s = s |> String.to_seq |> List.of_seq\nlet implode l = l |> List.to_seq |> String.of_seq\n\nlet to_mat s = s |> lines |> List.map explode\nlet of_mat m = m |> List.map implode |> unlines\n\n(* https:\/\/stackoverflow.com\/a\/3989823 *)\nlet rec transpose = function\n  | [] -> []\n  | [] :: xss -> transpose xss\n  | (x :: xs) :: xss ->\n      (x :: List.map List.hd xss) :: transpose (xs :: List.map List.tl xss)\n\n(* https:\/\/stackoverflow.com\/a\/34423544 *)\nlet rotate l = List.map List.rev @@ transpose l\n\nlet rec zip a b =\n  match a, b with\n  | [], _\n  | _, [] -> []\n  | a :: aas, b :: bs -> (a, b) :: zip aas bs\n\nlet combine l rl =\n  let merge (a, b) = a @ ('|' :: b) in\n  List.map merge @@ zip l rl\n\nlet diag_1_sym(s: string): string =\n  s |> to_mat |> transpose |> of_mat\n\nlet rot_90_clock(s: string): string =\n  s |> to_mat |> rotate |> of_mat\n\nlet selfie_and_diag1(s: string): string =\n  let l = to_mat s in\n  let rl = transpose l in\n  combine l rl\n  |> of_mat\n  \nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217533,"user_id":null,"body":"let square_size l =\n  (int_of_float (sqrt (float_of_int (4*l + 9))) - 1) \/ 2;;\n\nlet sym s n k =\n  let i = k \/ (n+1) and j = k mod (n+1) in\n  if j < n then s.[j*(n+1)+i]\n  else '\n';;\n\nlet diag_1_sym s =\n  let l = String.length s in\n  let n = square_size l in\n  String.init l (sym s n);;\n\nlet rot s n k =\n  let i = k \/ (n+1) and j = k mod (n+1) in\n  if j < n then s.[(n-1-j)*(n+1)+i]\n  else '\n';;\n\nlet rot_90_clock s =\n  let l = String.length s in\n  let n = square_size l in\n  String.init l (rot s n);;\n\nlet selfie s n k =\n  let i = k \/ (2*n+2) and j = k mod (2*n+2) in\n  if j < n then s.[i*(n+1)+j]\n  else if j = n then '|'\n  else if j < 2*n+1 then s.[(j-n-1)*(n+1)+i]\n  else '\n';;\n\nlet selfie_and_diag1 s =\n  let l = String.length s in\n  let n = square_size l in\n  String.init (2*l+1) (selfie s n);;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217534,"user_id":null,"body":"open Batteries\n\nlet permute s p = \n  let lines = String.nsplit ~by:\"\n\" s in\n  let n = List.length lines in\n  let ret = String.make (n * (n+1)) '.' in\n  let set_char i j c = ret.[i * (n+1) + j] <- c in\n  let get_char (i, j) = s.[i * (n+1) + j] in\n  for ii = 0 to n-1 do\n    for jj = 0 to n-1 do\n      set_char ii jj (get_char (p n ii jj));\n    done;\n    set_char ii n '\n';\n  done;\n  String.sub ret 0 (n * (n+1) - 1)\n  ;;\n\nlet diag_1_sym(s: string): string =\n  let perm _ i j = (j,i) in\n  permute s perm;;\n\nlet rot_90_clock(s: string): string =\n  let perm n i j = (n-j-1, i) in\n  permute s perm;;\n\nlet concat a b =\n  let alines = String.nsplit ~by:\"\n\" a in\n  let blines = String.nsplit ~by:\"\n\" b in\n  List.map2 (fun x y -> x ^ \"|\" ^ y) alines blines\n  |> String.concat \"\n\"\n  ;;\n\nlet selfie_and_diag1(s: string): string =\n  concat s (diag_1_sym s);;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217535,"user_id":168,"body":"let split = Str.split (Str.regexp \"\n\")\nlet concat = String.concat \"\n\"\nlet rev_str s =\n  let n = String.length s in\n  String.mapi (fun i _ -> s.[n - i - 1]) s\n  \nlet diag_1_sym(s: string): string =\n  let ss = split s in\n  let n = List.length ss in\n  let char_at i s = String.sub s i 1 in\n  let take i = List.map (char_at i) ss |> String.concat \"\" in\n  let rec loop acc i=\n    if i < 0 then acc\n    else loop (take i :: acc) (pred i) in\n  concat (loop [] (n - 1))\n\nlet rot_90_clock(s: string): string =\n  let ss = split (diag_1_sym s) in\n  List.map rev_str ss |> concat\n\nlet selfie_and_diag1(s: string): string =\n  let ss1 = split s and\n      ss2 = split (diag_1_sym s) in\n  List.map2 (fun s1 s2 -> s1 ^ \"|\" ^ s2) ss1 ss2 |> concat\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56dbf59b0a10feb08c000227":[{"id":217536,"user_id":null,"body":"let matrix_of_string s =\n  s |> String.split_on_char '\n'\n    |> List.map (fun s -> List.init (String.length s) (fun i -> String.make 1 s.[i]))\n\nlet string_of_matrix m =\n  m |> List.map (String.concat \"\")\n    |> String.concat \"\n\"\n\n\nlet[@tail_mod_cons] rec map3 f l1 l2 l3 =\n  match (l1, l2, l3) with\n  | ([], [], []) -> []\n  | ([a1], [b1], [c1]) ->\n      let r1 = f a1 b1 c1 in\n      [r1]\n  | (a1::a2::l1, b1::b2::l2, c1::c2::l3) ->\n      let r1 = f a1 b1 c1 in\n      let r2 = f a2 b2 c2 in\n      r1::r2::map3 f l1 l2 l3\n  | (_, _, _) -> invalid_arg \"map3\"\n\n\nlet anti_transpose m =\n  let rec loop buff = function\n    | [] | [] :: _ -> buff\n    | ls           -> loop (List.rev_map List.hd ls :: buff) (List.map List.tl ls) in\n  loop [] m\n\nlet rot_90_trig m =\n  let rec loop buff = function\n    | [] | [] :: _ -> buff\n    | ls           -> loop (List.map List.hd ls :: buff) (List.map List.tl ls) in\n  loop [] m\n\n\nlet diag_2_sym(s: string): string =\n  s |> matrix_of_string\n    |> anti_transpose\n    |> string_of_matrix\n\nlet rot_90_counter(s: string): string = \n  s |> matrix_of_string\n    |> rot_90_trig\n    |> string_of_matrix\n\nlet selfie_diag2_counterclock(s: string): string =\n  let m = matrix_of_string s in\n  let t = anti_transpose m in\n  let r = rot_90_trig m in\n  map3 (fun l1 l2 l3 -> l1 @ \"|\" :: (l2 @ \"|\" :: l3)) m t r\n    |> string_of_matrix\n\nlet oper = ( @@ )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217537,"user_id":null,"body":"let mods f s =\n  let n = String.index s '\n' in \n    String.mapi (fun i _ -> let x = i mod (n+1) in let y = i\/(n+1) in \n      if x==n then s.[i] else s.[(n+1)*(f n x)+n-1-y]) s\n    \nlet diag_2_sym(s: string): string = mods (fun n x -> n-1-x) s\n\nlet rot_90_counter(s: string): string = mods (fun _ x -> x) s\n\nlet selfie_diag2_counterclock(s: string): string =\n  let slf_lst = Str.split (Str.regexp \"\n\") s in\n  let diag_lst = Str.split (Str.regexp \"\n\") (diag_2_sym s) in\n  let rot_lst = Str.split (Str.regexp \"\n\") (rot_90_counter s) in\n  List.mapi (fun i s -> s ^ \"|\" ^ (List.nth diag_lst i) ^ \"|\" ^ (List.nth rot_lst i)) slf_lst\n  |> String.concat \"\n\"\n\nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217538,"user_id":null,"body":"\nlet rot_90_counter(s: string): string =\n  if s = \"\" then \"\"\n  else\n    let lst = Str.split (Str.regexp \"\n\") s in\n    let len = String.length (List.hd lst) in\n    let build_i i = String.concat \"\" (List.map (fun x -> String.make 1 (x.[i])) lst)  in\n    let rec helper cont = function\n      | 0 -> cont (build_i 0::[])\n      | n -> helper (fun x -> cont ((build_i n)::x)) (n - 1) in\n    String.concat \"\n\" (helper (fun x -> x) (len - 1))\n\n\n                      \nlet diag_2_sym(s: string): string =\n  if s = \"\" then \"\"\n  else\n    let lst = Str.split (Str.regexp \"\n\") s in\n    let len = String.length (List.hd lst) in\n    let build_i i = String.concat \"\" (List.rev (List.map (fun x -> String.make 1 (x.[i])) lst))  in\n    let rec helper cont = function\n      | 0 -> cont (build_i 0::[])\n      | n -> helper (fun x -> cont ((build_i n)::x)) (n - 1) in\n    String.concat \"\n\" (helper (fun x -> x) (len - 1))\n\n\nlet selfie_diag2_counterclock s =\n  let dia = Str.split (Str.regexp \"\n\") (diag_2_sym s) in\n  let rot = Str.split (Str.regexp \"\n\") (rot_90_counter s) in\n  let lst = Str.split (Str.regexp \"\n\") s in\n  let build_i i = String.concat \"|\" [List.nth lst i; List.nth dia i; List.nth rot i] in\n  let rec helper cont = function\n    | 0 -> cont (build_i 0::[])\n    | n -> helper (fun x -> cont (build_i n::x)) (n - 1) in\n  String.concat \"\n\" (helper (fun x -> List.rev x) (List.length lst - 1))\n  \n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217539,"user_id":null,"body":"let extract_rows s =\n    let strings = String.split_on_char '\n' s in\n    List.map (fun str -> str |> String.to_seq |> List.of_seq) strings\n\n\nlet join chars = chars |> List.map Char.escaped |> String.concat \"\"\n\n\nlet rot_90_counter s =\n    let rows = s |> extract_rows |> List.map List.rev in\n    let rec loop acc xs =\n        if List.for_all (fun x -> x = []) xs then List.rev acc\n        else let column = List.map List.hd xs in loop (column :: acc) (List.map List.tl xs) in\n    let transpose = loop [] rows in\n    transpose |> List.map join |> String.concat \"\n\"\n\n\nlet diag_2_sym s =\n    let rows = s |> extract_rows |> List.map List.rev |> List.rev in\n    let rec loop acc xs =\n        if List.for_all (fun x -> x = []) xs then List.rev acc\n        else let column = List.map List.hd xs in loop (column :: acc) (List.map List.tl xs) in\n    let transpose = loop [] rows in\n    transpose |> List.map join |> String.concat \"\n\"\n\n\nlet selfie_diag2_counterclock s =\n    let combine lst1 lst2 =\n        List.map2 (fun a b -> a ^ \"|\" ^ b) lst1 lst2 in\n    let orig = s |> extract_rows |> List.map join in\n    let s1 = s |> diag_2_sym |> extract_rows |> List.map join in\n    let s2 = s |> rot_90_counter |> extract_rows |> List.map join in\n    String.concat \"\n\" @@ combine (combine orig s1) s2\n\n\nlet oper f s = f s\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217540,"user_id":480,"body":"let rec string_of_chars (l:char list) :string=l|> List.map (String.make 1) |> String.concat \"\";;\n\nlet diag_2_sym(s: string): string =\n  let s=s |> String.split_on_char '\n' |> List.map (fun s->s|>String.to_seq|>Array.of_seq)|>Array.of_list in\n  let n=Array.length s in\n  let rec mkline i j= [s.(n-1-j).(n-1-i)]@(if j==n-1 then [] else mkline i (j+1))  in\n  let rec mklines i= [mkline i 0]  @(if i==n-1 then [] else mklines (i+1))  in\n  mklines 0 |> List.map string_of_chars |>String.concat \"\n\" ;;\n\nlet rot_90_counter(s: string): string = \n  let s=s |> String.split_on_char '\n' |> List.map (fun s->s|>String.to_seq|>Array.of_seq)|>Array.of_list in\n  let n=Array.length s in\n  Printf.printf \"n=%d\n\" n;\n  let rec mkline i j= [s.(j).(n-1-i)]@(if j==n-1 then [] else mkline i (j+1))  in\n  let rec mklines i= [mkline i 0]  @(if i==n-1 then [] else mklines (i+1))  in\n  mklines 0 |> List.map string_of_chars |>String.concat \"\n\" ;;\n\nlet selfie_diag2_counterclock(s: string): string =\n  let a=s |> String.split_on_char '\n'\n  and b=s |> diag_2_sym |> String.split_on_char '\n'\n  and c=s |> rot_90_counter |> String.split_on_char '\n' in\n  let n=String.length (List.hd a) in\n  let rec aux a b c=\n    match a with | [] -> [] | ha::ta->\n    match b with | [] -> [] | hb::tb->\n    match c with | [] -> [] | hc::tc->\n       [String.concat \"|\" [ha;hb;hc]]@(aux ta tb tc)\n  in\n    String.concat \"\n\" (aux a b c);;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217541,"user_id":null,"body":"let get_col n ss = \n  ss |> List.map (fun s -> Char.escaped s.[n]) |> String.concat \"\"\n;;\n\nlet get_col_rev n ss = \n  ss |> List.map (fun s -> Char.escaped s.[n]) |> List.rev |> String.concat \"\"\n;;\n\nlet op_on_str_list f ss = \n  let len = String.length (List.nth ss 0) in\n  let rec aux res = function\n    | 0 -> res\n    | n -> aux (f (len - n) ss :: res) (n-1)\n  in aux [] len\n;;\n\nlet op_on_str f s = \n  let ss = String.split_on_char '\n' s in\n  String.concat \"\n\" (op_on_str_list f ss)\n;;\n\nlet diag_2_sym(s: string): string =\n  op_on_str get_col_rev s\n;;\n\nlet rot_90_counter(s: string): string = \n  op_on_str get_col s\n;;\n\nlet selfie_diag2_counterclock(s: string): string =\n  let ss = String.split_on_char '\n' s in\n  let help x y = x ^ \"|\" ^ y in \n  let diag2 = op_on_str_list get_col_rev ss in\n  let cc = op_on_str_list get_col ss\n  in cc |> List.map2 help (List.map2 help ss diag2) |> String.concat \"\n\"\n;;\n\nlet oper f s = f s;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217542,"user_id":168,"body":"let split = Str.split (Str.regexp \"\n\")\nlet concat = String.concat \"\n\"\nlet rev_str s =\n  let n = String.length s in\n  String.mapi (fun i _ -> s.[n - i - 1]) s\n\nlet diag_2_sym(s: string): string =\n  let ss = List.rev (split s) in\n  let n = List.length ss in\n  let char_at i s = String.sub s i 1 in\n  let take i = List.map (char_at i) ss |> String.concat \"\" in\n  let rec loop acc i=\n    if i >= n then acc\n    else loop (take i :: acc) (succ i) in\n  concat (loop [] 0)\n\nlet rot_90_counter(s: string): string =\n  let ss = split (diag_2_sym s) in\n  List.map rev_str ss |> concat\n  \nlet selfie_diag2_counterclock(s: string): string =\n  let s1 = split s in\n  let s2 = split (diag_2_sym s) in\n  List.map2 (fun s1 s2 -> s1 ^ \"|\" ^ s2 ^ \"|\" ^ rev_str s2) s1 s2\n    |> concat\n  \nlet oper f s = f s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217543,"user_id":492,"body":"let diag_2_sym(s: string): string =\n  s \n  |> Str.split(Str.regexp \"\n\") \n  |> List.map(fun x -> Str.split(Str.regexp \"\") x)\n  |> transpose9\n  |> List.rev\n  |> List.map (fun x -> List.rev x)\n  |> List.map(fun x -> String.concat \"\" x)\n  |> String.concat \"\n\";;\n\nlet rot_90_counter(s: string): string = \n  s \n  |> Str.split(Str.regexp \"\n\") \n  |> List.rev\n  |> String.concat \"\n\"\n  |> diag_2_sym;;\n\nlet selfie_diag2_counterclock(s: string): string =\n  let r1 = Str.split(Str.regexp \"\n\") s |> List.map(fun x -> x ^ \"|\") in\n  let r2 = Str.split(Str.regexp \"\n\") (diag_2_sym s) |> List.map(fun x -> x ^ \"|\") in\n  let r4 = List.map2(fun x y -> x ^ y) r1 r2 in\n  let r3 = Str.split(Str.regexp \"\n\") (rot_90_counter s) in\n    List.map2(fun x y -> x ^ y) r4 r3 \n    |> String.concat \"\n\";;\n\nlet oper f s = f s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56dec885c54a926dcd001095":[{"id":217544,"user_id":527,"body":"let opposite = (~-)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217545,"user_id":null,"body":"let opposite (a : int) : int = - a\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217546,"user_id":527,"body":"let opposite (number : int) : int =\n  -number","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217547,"user_id":null,"body":"let opposite x = -x;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217548,"user_id":null,"body":"let opposite = let open Core.Int in neg","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217549,"user_id":null,"body":"let opposite (number : int) : int = match number with\n  | 0 -> 0\n  | n -> -1 * n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217550,"user_id":null,"body":"let opposite (number : int) = -number ;;\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217551,"user_id":null,"body":"let rec opposite n = \n    if n < 0 then n * -1 \n    else if n >= 0 then n * -1 \n    else opposite (int_of_string \"GAY LADRI PORCA MADONNA\") ;;\n    \n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217552,"user_id":null,"body":"let opposite=(-)0;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217553,"user_id":null,"body":"let opposite (number : int) : int = ~-number","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56e3cd1d93c3d940e50006a4":[{"id":217554,"user_id":492,"body":"let rec make_valley (a: int list): int list =\n  let b = List.sort(fun x y -> compare y x) a in\n    match b with\n      | [] -> []\n      | [x] -> [x]\n      | x::y::xs -> x :: make_valley xs @ [y];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217555,"user_id":null,"body":"let rec even_elements l = match l with\n| a::_::t -> a :: even_elements t\n| a::[] -> [a]\n| [] -> []\n\nlet rec odd_elements l = match l with\n| _::a::t -> a :: odd_elements t\n| _::[] -> []\n| [] -> []\n\nlet make_valley a =\n  let arr2 = List.rev (List.sort compare a) in\n  (even_elements arr2)@List.rev (odd_elements arr2)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217556,"user_id":null,"body":"let rec select_half flag = function (* List.filteri (fun i _ -> i land 1 = (Bool.to_int flag)) in newer versions*)\n  | [] -> []\n  | h :: t when flag -> h :: select_half false t\n  | _ :: t -> select_half true t\n\nlet make_valley (a: int list): int list =\n  let l = List.sort (fun x y -> compare y x) a in\n  let l1 =             select_half true  l and\n      l2 = List.rev @@ select_half false l in\n  l1 @ l2","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217557,"user_id":null,"body":"let sortedlist l =  List.sort compare l;; \nlet smallint l = List.hd (sortedlist l);;\nlet newlist l = List.tl (sortedlist l);;\nlet length l  = List.length l;;\nlet rec leftlist l ll = \n    match l with \n      [] -> ll\n      |[e] -> if length l mod 2 = 0 then ll else ll @ [e]\n      |h::_::t ->leftlist t (ll @ [h] );;\nlet rec rightlist l lr =\n    match l with \n      [] -> lr\n      |[e] -> if length l mod 2 = 0 then [e] @ lr else lr\n      |_::m::t -> rightlist t ([m] @ lr ) ;;\nlet make_valley (a: int list)=\n    match newlist a with \n      [] -> []\n      |[e] -> [e]\n      |h::e::t -> \n        if length a mod 2 != 0 \n          then (rightlist (newlist a) [] @ [smallint a]) @  leftlist (newlist a) [] \n        else List.rev  ((rightlist (newlist a) [] @ [smallint a]) @  leftlist (newlist a) []);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217558,"user_id":53,"body":"let reverse l =\n  let rec rev_acc acc = function\n    | [] -> acc\n    | hd::tl -> rev_acc (hd::acc) tl\n  in \n  rev_acc [] l ;;\n    \nlet rec make_valley (a: int list): int list =\n  let xs = List.sort compare a |> reverse in\n    match xs with\n      | [] -> []\n      | [x] -> [x]\n      | x::y::rest -> x :: make_valley rest @ [y];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217559,"user_id":null,"body":"let make_valley (a: int list): int list =\n  let a = List.fast_sort (fun x y -> compare y x) a in\n  let rec aux cont n = function\n    | [] ->  cont []\n    | hd1::hd2::tl when n mod 2 = 0-> aux (fun x -> cont (hd1::x)) (n + 1) (hd2::tl) \n    | hd1::hd2::tl -> aux (fun x -> cont ( x @ [hd1])) (n + 1) (hd2::tl)\n    | hd::[] -> aux (fun x -> cont (hd::x)) (n + 1) [] in\n   aux (fun x -> x) 0 a","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217560,"user_id":null,"body":"let make_valley (a: int list): int list =\n  let cmp x y = \n    if x < y then 1\n    else if x > y then -1\n    else 0\n  in\n  let sorted = List.sort cmp a in\n  let rec fill_wings l left right = \n    match l with\n    | h1 :: h2 :: t -> \n      fill_wings t (h1 :: left) (h2 :: right)\n    | h :: t ->\n      fill_wings t (h :: left) right\n    | [] -> List.rev left @ right\n  in \n  fill_wings sorted [] []               ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217561,"user_id":null,"body":"let make_valley (a: int list): int list =\n    let sorted = List.sort (fun a b -> compare b a) a in\n    let rec loop xs ys = function\n        | [] -> List.rev xs, ys\n        | [y] ->loop xs (y :: ys) []\n        | x :: y :: rest -> loop (x :: xs) (y :: ys) rest in\n    let left, right = loop [] [] sorted in\n    left @ right","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217562,"user_id":168,"body":"let make_valley (a: int list): int list =\n  let rec loop (left, right) = function\n  | [] -> left, right\n  | [x] -> left, x :: right\n  | x :: y :: rest -> loop (x :: left, y :: right) rest in\n  let left, right = loop ([], []) (List.sort (fun x y -> -compare x y) a) in\n  List.rev_append left right\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56e7d40129035aed6c000632":[{"id":217563,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet choose n p =\n  let m = min p (n - p) in\n    if m < 0 then Int 0 else\n      let rec loop j v =\n        if j = m then v\n        else loop (succ j) ((v *\/ (Int (n - j))) \/\/ (Int (succ j)))\n      in loop 0 (Int 1);;\n\nlet easyline(n:int): string =\n  string_of_num (choose (2 * n) n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217564,"user_id":null,"body":"open Big_int\n\nlet bi = big_int_of_int\n\nlet rec multiply n1 n2 answer = match n1 with\n | n1 when gt_big_int n1 n2 -> answer\n | _ -> multiply (add_big_int n1 (bi 1)) n2 (mult_big_int answer n1)\n\nlet easyline n = \n let factorial_2n_part = multiply (bi (n + 1)) (bi (n * 2)) (bi 1) in\n let factorial_n = multiply (bi 1) (bi n) (bi 1) in\n let q = div_big_int factorial_2n_part factorial_n in\n string_of_big_int q","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217565,"user_id":null,"body":"module My_sol = struct\n  open BatBig_int\n\n  let two = succ one\n\n  let factorial n =\n    let rec loop buff = function\n      | k when eq_big_int k two -> two * buff\n      | k                       -> loop (k * buff) (pred k) in\n    loop one n\n\n  let easyline (n:int): string =\n    match n with 0 -> \"1\" | 1 -> \"2\" | n ->\n    let n = big_int_of_int n in\n    let a = factorial (two * n) in\n    let b = factorial n in\n    to_string (a \/ b \/ b)\nend\n\nopen My_sol","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217566,"user_id":98,"body":"open Num (* no longer in Ocaml stdlib *)\n\nlet rec factorial n =\n    (* let open Num in *)\n    if n =\/ Int 0 then Int 1 else n *\/ factorial (n -\/ Int 1)\n;;\n\nlet easyline (n : int) : string =\n\tlet  big_n = num_of_int n in\n\tlet fact_n = factorial big_n in\n\tstring_of_num (factorial ((Int 2) *\/ big_n) \/\/ (fact_n *\/ fact_n))\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217567,"user_id":null,"body":"open List\n\nopen Big_int\n\nlet rec line = function\n  | x when lt_big_int x unit_big_int -> [unit_big_int]\n  | x -> (let prev = line (sub_big_int x unit_big_int) in (map (fun (x,y) -> add_big_int x y) (combine ([zero_big_int]@prev) (prev@[zero_big_int]))));;\n\nlet easylineI(n:big_int): string = string_of_big_int (fold_left (fun x y -> add_big_int x y) zero_big_int (map (fun x -> mult_big_int x x) (line n)));;\n\nlet easyline(n:int): string = easylineI (add_int_big_int n zero_big_int)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217568,"user_id":480,"body":"#load \"num.cma\"\nopen Num\n\nlet noi n=Num.num_of_int n;;\n\nlet prod_num a b=\n  let rec aux a =if a>b then noi 1 else mult_num (noi a) (aux (a+1)) in\n  aux a;;\n  \nlet easyline(n:int): string = \n  Num.string_of_num (div_num (prod_num (n+1) (2*n)) (prod_num 1 n))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217569,"user_id":null,"body":"open Num\n\n\nlet easyline n =\n    let range_product a b =\n        let rec loop acc k =\n            if k > b then acc\n            else loop (acc *\/ (num_of_int k)) (k + 1)\n        in loop (num_of_int 1) a in\n    let numer = range_product (n + 1) (2*n) in\n    let denom = range_product 1 n in\n    string_of_num (numer \/\/ denom)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217570,"user_id":null,"body":"(* ------------------------------------------------------\n--- BIG INT Helpers                                   ---\n-------------------------------------------------------*)\n\nlet (@+) x y = Big_int.add_big_int x y\nlet rec (@**.) x y = Big_int.power_big_int_positive_int x y\nlet i_to_I x = Big_int.big_int_of_int x\n\n(* ------------------------------------------------------\n--- Algorithm                                         ---\n-------------------------------------------------------*)\n\nlet easyline : int -> string = fun n ->\n  let rec pascal : int -> int -> Big_int.big_int list -> Big_int.big_int list = fun current_tier n acc ->\n  \n    let rec next_coeffs : Big_int.big_int list -> Big_int.big_int list = fun line ->\n      match line with\n      | [] -> []\n      | [a] -> [a]\n      | [a; b] -> [(a @+ b); b]\n      | a::b::tail -> (a @+ b)::(next_coeffs (b::tail))\n    in\n  \n    match current_tier = n with\n    | true -> acc\n    | false -> pascal (current_tier + 1) n ((i_to_I 1) :: (next_coeffs acc))\n  in\n  \n  (pascal 0 n [i_to_I 1])\n    |> List.fold_left (fun init x -> init @+ (x @**. 2)) (i_to_I 0)\n    |> Big_int.string_of_big_int","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217571,"user_id":null,"body":"open Core.Std;;\nopen Big_int;;\n\nlet easyline(n:int): string =\n  let n1 = n + 1 in\n  let rec fac x =\n    x + 1 |> List.range 1\n    |> List.fold ~f:(fun x y -> mult_int_big_int y x)\n                 ~init:(big_int_of_int 1) in\n  let (+) = add_big_int\n  and ( * ) = mult_big_int\n  and ( ** ) = power_big_int_positive_int\n  and (\/) = div_big_int in\n  let binomial k = (fac n \/ (fac k * fac (n - k))) in\n  List.range 0 n1\n  |> List.map ~f:(fun x -> (binomial x) ** 2)\n  |> List.fold ~f:(+) ~init:(big_int_of_int 0)\n  |> string_of_big_int","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217572,"user_id":null,"body":"let easyline(n:int): string = \n  let open Big_int in\n  let rec pascal m prev_pascal = match m with\n     m when m=n+1 -> prev_pascal\n     |_ -> pascal (m+1) (List.map2 add_big_int (zero_big_int::prev_pascal) (prev_pascal@[zero_big_int])) in \n  pascal 1 [unit_big_int] |> List.map (square_big_int) |> List.fold_left add_big_int zero_big_int |> string_of_big_int;;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56ed20a2c4e5d69155000301":[{"id":217573,"user_id":492,"body":"let scale (s: string) (hcount: int) (vcount: int) =\n  let aux_scale(s: string)(hcount: int)(vcount: int): string =\n    let ss = s \n             |> Str.split(Str.regexp \"\n\") \n             |> List.map(fun x -> Str.split(Str.regexp \"\") x)\n             |> List.map(fun x -> List.map(fun y -> (string_repeat hcount y)) x)\n             |> List.map(fun x -> String.concat \"\" x)\n    in\n      replic_ ss vcount |> String.concat \"\n\"\n  in\n\n    match s with\n      | \"\" -> \"\"\n      | _ -> aux_scale s hcount vcount;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217574,"user_id":null,"body":"let const x _ = x\n\nlet scale factor l = List.flatten @@ List.map (fun x -> List.init factor (const x)) l\n\nlet scale (s: string) (h: int) (v: int) =\n  if s = \"\" then \"\" else\n  String.split_on_char '\n' s\n    |> List.map (fun s -> List.init (String.length s) (fun i -> String.make 1 s.[i]))\n    |> scale v\n    |> List.map (scale h)\n    |> List.map (String.concat \"\")\n    |> String.concat \"\n\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217575,"user_id":null,"body":"let rec scaleH ch h answer = \n  if h == 0 then answer else \n    scaleH ch (h-1) (answer ^ ch);;\n\nlet rec scaleV tmp v answer =\n  if v == 0 then answer else\n    scaleV tmp (v-1) (answer ^ tmp);;\n\nlet rec scale2 input h v counter limit tmp answer =\n  if counter == limit then answer else\n    let ch = String.sub input counter 1 in\n    if String.equal ch \"\n\" then\n      scale2 input h v (counter+1) limit \"\" (answer ^ (scaleV (tmp ^ ch) v \"\")) else\n      scale2 input h v (counter+1) limit (tmp ^ (scaleH ch h \"\")) answer;;\n\nlet scale (s: string) (hcount: int) (vcount: int) =\n  if (String.length s) == 0 then \"\" else  \n    let s2 = s ^ \"\n\" in \n    let long = String.length s2 in\n    let result = scale2 s2 hcount vcount 0 long \"\" \"\" in\n    let longR = String.length result in\n    String.sub result 0 (longR-1);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217576,"user_id":null,"body":"let stutter n s =\n  BatString.(\n    fold_right\n      (fun c acc -> (match c with '\n' -> \"\n\" | _ -> make n c) ^ acc)\n      s \"\")\n\nlet repeat n s =\n  String.split_on_char '\n' s\n  |> List.map (fun row -> BatList.make n row |> BatString.join \"\n\")\n  |> BatString.join \"\n\"\n\nlet scale (s : string) (hcount : int) (vcount : int) =\n  if s = \"\" then \"\" else stutter hcount s |> repeat vcount","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217577,"user_id":null,"body":"open List\n    \nlet stol s = List.init (String.length s) (String.get s) \nlet ltos l = String.of_seq (List.to_seq l)\n\nlet pr = String.split_on_char '\n';;\n\nlet rec rep count x = if count == 0 then [] else x::rep (count-1) x;;\n\nlet hscale count s = ltos (flatten (map (rep count) (stol s)));;\n\nlet vscale count s = String.concat \"\n\" (rep count s);;\n\nlet scale (s: string) (hcount: int) (vcount: int) =\n  if String.equal \"\" s then \"\" else String.concat \"\n\" (map (vscale vcount) (map (hscale hcount) (pr s)));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217578,"user_id":null,"body":"let repeat_string count str =\n  let length = String.(length str) * count in\n  String.init length (fun index -> str.[index \/ count])\n\nlet repeat_array count items = \n  let length = List.(length items) * count in\n  List.init length (fun index -> List.nth items (index \/ count))\n\nlet split str =\n  match String.split_on_char '\n' str with\n  | [\"\"] -> []\n  | items -> items\n\nlet scale (s: string) (hcount: int) (vcount: int) =\n  s   \n  |> split\n  |> List.map (repeat_string hcount)\n  |> repeat_array vcount\n  |> String.concat \"\n\"\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217579,"user_id":null,"body":" let scale (s: string) (hcount: int) (vcount: int) =\n   if s = \"\" then \"\" else\n   let rec horiz acc i x =\n     if i < 0 then\n       acc\n     else\n       horiz ((String.make hcount (x.[i]))^ acc) (i - 1) x\n   in\n   s\n   |> Str.split (Str.regexp \"\n\") \n   |> List.map (fun x -> String.concat \"\n\" (List.init vcount (fun _ -> horiz \"\" (String.length x - 1) x) ))\n   |> String.concat \"\n\" \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217580,"user_id":53,"body":"let repeat_string (s: string) (n: int) =\n  (String.concat \"\" (Array.to_list (Array.make n s)))\n;; \n\nlet scale (s: string) (k: int) (n: int) =\n  if ((String.length s) = 0) then \"\" else\n    let a = (Printf.sprintf \"%s\n\" s) in\n    let b = (Str.global_substitute \n               (Str.regexp \"[^\n]\") \n               (fun s -> repeat_string (Str.matched_string s) k) a) in\n    let c = (Str.global_substitute \n               (Str.regexp \"[^\n]+\n\") \n               (fun s -> repeat_string (Str.matched_string s) n) b) in\n    (Str.replace_first (Str.regexp \"\n$\") \"\" c)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217581,"user_id":480,"body":"let scale (s: string) (hcount: int) (vcount: int) =\n  Printf.printf \"s=\\\"%s\\\" h:%d v:%d\" s hcount vcount;\n  let lines=String.split_on_char '\n' s in\n  let rec hscale line=\n    if String.equal line \"\" then \"\" else\n    String.concat \"\" [String.make hcount (String.get line 0); hscale (String.sub line 1 ((String.length line)-1))]\n  in\n  let rec vscale lines=\n    match lines with \n      | [] -> [] \n      | line::lines ->\n        let line=hscale line in\n        if String.length line==0 then [] else\n        let rec repeat line vcount=if vcount<=0 then [] else [line]@(repeat line (vcount-1)) in\n        (repeat line vcount)@(vscale lines)\n  in\n    String.concat \"\n\" (vscale lines);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217582,"user_id":null,"body":"let scale (s: string) (hcount: int) (vcount: int) =\n    if s = \"\" then \"\"\n    else \n        let lst = String.split_on_char '\n' s in\n        let explode k s = \n            s |> String.to_seq |> List.of_seq |> List.map (String.make k) |> String.concat \"\" in\n        let h_scaled = List.map (explode hcount) lst in\n        let v_scaled = List.(h_scaled |> map (fun x -> List.init vcount (fun _ -> x)) |> concat) in\n        String.concat \"\n\" v_scaled","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56efab15740d301ab40002ee":[{"id":217583,"user_id":null,"body":"let som x y = x + y\n\nlet rec gcdi u v = match (u, v) with\n  | (u, v) when u < 0 -> gcdi (-u) v\n  | (u, v) when v < 0 -> gcdi u (-v)\n  | (u, 0) -> u\n  | (u, v) -> gcdi v (u mod v)\n\nlet lcmu u v = (abs (u * v)) \/ (gcdi u v)\n\nlet maxi u v = if u < v then v else u\n\nlet mini u v= if u > v then v else u\n\nlet oper fct arr init =\n  let rec iter acc = function\n    | [] -> []\n    | t::q -> let x = fct acc t in x::(iter x q)\n  in iter init arr","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217584,"user_id":492,"body":"let som (x: int) (y: int) = x + y;;\n\nlet rec gcdi u v =\n    if v <> 0 then (gcdi v (u mod v))\n    else (abs u)\n\nlet lcmu m n =\n    match m, n with\n        | 0, _ | _, 0 -> 0\n        | m, n -> abs (m * n) \/ (gcdi m n)\n\nlet maxi = max;;\n\nlet mini = min;;\n\nlet rec operaux fct arr init acc = \n    match arr with\n    | [] -> acc\n    | a :: l ->\n        let c = (fct a init) in\n            operaux fct l c (c :: acc);;\n\nlet oper fct arr init = operaux fct arr init [] |> List.rev;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217585,"user_id":492,"body":"let som (x: int) (y: int) = x + y;;\n\nlet rec gcdi u v =\n    if v <> 0 then (gcdi v (u mod v))\n    else (abs u)\n\nlet lcmu m n =\n    match m, n with\n        | 0, _ | _, 0 -> 0\n        | m, n -> abs (m * n) \/ (gcdi m n)\n\nlet maxi = max;;\n\nlet mini = min;;\n\nlet rec operaux fct arr init acc = \n    match arr with\n    | [] -> acc\n    | a :: l ->\n        let c = (fct a init) in\n            operaux fct l c (c :: acc);;\n\nlet oper fct arr init = operaux fct arr init [] |> List.rev;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217586,"user_id":null,"body":"(* here in OCaml arrays are replaced by lists *)\n\nlet som (x: int) (y: int) = x+y\n\nlet maxi x y = if x>y then x else y\n\nlet mini x y = if x<y then x else y\n\nlet rec gcdi uu vv = let u = abs uu in let v = abs vv in if u==v then u else gcdi ((maxi u v)-(mini u v)) (mini u v)\n\nlet lcmu m n = abs (m*n\/(gcdi m n))\n\nlet rec oper fct arr rt = \nif arr==[] \n  then [] \nelse \n  let newval = fct rt (List.hd arr) in\n    newval :: oper fct (List.tl arr) newval\n\n(*let oper fct arr init = List.fold_left_map (let res = fun ac x -> fct ac x in (res,res)) init arr*)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217587,"user_id":null,"body":"let som = (+)\n\nlet gcdi x y =\n  let rec loop a b =\n    if a = 0 then b else loop (b mod a) a in\n  loop (abs x) (abs y)\n\nlet lcmu m n = abs (m * n \/ gcdi m n)\n\nlet maxi = max\n\nlet mini = min\n\nlet oper fct arr init =\n  let rec loop = function\n    | hd_acc :: tl_acc as l, hd :: tl -> loop ((fct hd_acc hd::l), tl)\n    | l, [] -> l |> List.rev |> List.tl in\n  loop ([init], arr)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217588,"user_id":null,"body":"(* here in OCaml arrays are replaced by lists *)\n\nlet som (x: int) (y: int) = x+y;;\n\nlet rec gcdi u v = match u mod v with\n|0 -> v\n|_ -> gcdi v (u mod v)\n;;\n\nlet lcmu m n = abs(abs(m*n)\/(gcdi m n));;\n\nlet maxi x y = if(x>=y)then x else y;;\n\nlet mini  x y= if(x<=y)then x else y;;\n\nlet oper fct arr init =\n  let rec aux fct l previous = match l with \n  |[] -> []\n  |p::r -> (fct previous p)::(aux fct r (fct previous p))  in\n  aux fct arr init;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217589,"user_id":null,"body":"let som = (+);;\n\nlet rec gcdi u v =\n  if u = 0 then v else gcdi (v mod u) u;;\n\nlet lcmu m n =\n  abs (m*n\/gcdi m n);;\n\nlet maxi = max;;\n\nlet mini = min;;\n\nlet filteri f l =\n  let rec loop li i acc =\n    match li with\n      | [] -> acc\n      | hd::tl -> if (f i hd) then loop tl (i+1) (hd::acc)\n                              else loop tl (i+1) acc\n  in List.rev (loop l 0 [])\n;;\n\nlet oper fct l init =\n\tList.init (List.length l) (fun i -> List.fold_left fct init (filteri (fun k _ -> k < i+1) l));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217590,"user_id":null,"body":"let som (x: int) (y: int) = x + y;;\n\nlet rec gcdi u v = match v with\n  | 0 -> abs u\n  | n -> gcdi (abs v) ((abs u) mod (abs v))\n;;\n\nlet lcmu m n = abs (m * n) \/ (gcdi m n);;\n\nlet maxi = max;;\n\nlet mini = min;;\n\nlet oper fct arr init = \n  let rec aux r last_r = function\n  | [] -> List.rev r\n  | a::b -> let new_r = (fct last_r a) in\n            aux (new_r::r) new_r b\n  in aux [fct init (List.hd arr)] (fct init (List.hd arr)) (List.tl arr);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217591,"user_id":53,"body":"(* here in OCaml arrays are replaced by lists *)\n\nlet abs a =\n  if a < 0 then\n    -a\n  else\n    a\n\nlet som a b = (a + b)\n\nlet rec gcdi a b =\n  if b == 0 then\n    abs a\n  else\n    gcdi b (a mod b)\n\nlet lcmu a b =\n  abs (a * b) \/ gcdi a b\n\nlet maxi a b =\n  if a > b then\n    a\n  else\n    b\n\nlet mini a b =\n  if a < b then\n    a\n  else\n    b\n\nlet rec aux f xs acc ys i n =\n  if i == n then\n    ys\n  else\n    let x = List.nth xs i in\n    let y = f acc x in\n    (aux f xs y (ys @ [y]) (i + 1) n)\n\nlet oper f xs seed =\n  (aux f xs seed [] 0 (List.length xs))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217592,"user_id":480,"body":"(* here in OCaml arrays are replaced by lists *)\n\nlet som (x: int) (y: int) :int = x+y;;\n\nlet maxi (x: int) (y: int) :int = if x>y then x else y;; \n\nlet mini (x: int) (y: int) :int = if x<y then x else y;;\n\nlet rec gcdi  (u: int) (v: int) :int = \n  if v==0 then u else gcdi v (u mod v);;\n\nlet lcmu  (m: int) (n: int) :int = \n  let m=abs m and n=abs n in\n  m*n \/ (gcdi m n);;\n\n\nlet rec oper fct arr init = \n  match arr with\n  | [] -> []\n  | h::t -> let term = fct init h in [term] @ (oper fct t term);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56f253dd75e340ff670002ac":[{"id":217593,"user_id":168,"body":"let compose(s1: string) (s2: string): string =\n  let split = Str.split (Str.regexp \"\n\") in\n  let ss1 = split s1 and\n      ss2 = split s2 in\n  let n = List.length ss1 in\n  let rec loop acc i = function\n  | [], _ | _, [] -> acc\n  | s1 :: ss1, s2 :: ss2 ->\n    loop ((String.sub s1 0 (n - i) ^ String.sub s2 0 (i + 1)) :: acc) \n         (succ i) (ss1, ss2) in\n  loop [] 0 (List.rev ss1, ss2) |> String.concat \"\n\"\n    \n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217594,"user_id":492,"body":"let compose(s1: string) (s2: string): string =\n  let arr1 = Str.split(Str.regexp \"\n\") s1 |> Array.of_list in\n  let arr2 = Str.split(Str.regexp \"\n\") s2 |> Array.of_list in\n    rev_inplace_ arr2;\n    let l = Array.length arr2 in\n    let res = Array.make l \"\" in\n      for i = 0 to l-1 do\n        res.(i) <- String.sub arr1.(i) 0 (i + 1) ^ String.sub arr2.(i) 0 (l - i);\n      done;\n      res |> Array.to_list |> String.concat \"\n\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217595,"user_id":null,"body":"open List\n  \n\nlet first s n = String.sub s 0 n ;;\nlet last s n = String.sub s 0 (String.length s - n + 1) ;;\n\nlet stl = function \n  | [] -> []\n  | x -> tl x;;\n\nlet rec rcomp s1 s2 n = if s1==[] \n  then [] \n  else ((first (hd s1) n)^(last (hd s2) n)) :: rcomp (stl s1) (stl s2) (n+1);;\n\nlet pr = String.split_on_char '\n';;\n\nlet compose(s1: string) (s2: string): string =\n  String.concat \"\n\" (rcomp (pr s1) (rev (pr s2)) 1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217596,"user_id":null,"body":"open String\n\nlet make_triangle =\n  List.mapi (fun i s -> sub s 0 (i+1))\n\nlet compose s1 s2 =\n  let l1 = split_on_char '\n' s1 |> make_triangle in\n  let l2 = split_on_char '\n' s2 |> make_triangle |> List.rev in\n  List.map2 (fun s1 s2 -> s1 ^ s2) l1 l2 |> concat \"\n\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217597,"user_id":480,"body":"let compose(s1: string) (s2: string): string =\n  let s1=String.split_on_char '\n' s1 and s2=String.split_on_char '\n' s2 |> List.rev in\n  let rec aux i s1 s2=\n    if s1 == [] then [] else\n    let (h1,h2)=(List.hd s1,List.hd s2) and (t1,t2)=(List.tl s1,List.tl s2) in\n    let l=String.length h1 in\n    (String.concat \"\" [String.sub h1 0 i;String.sub h2 0 (l+1-i) ])::aux (i+1) t1 t2\n  in\n    aux 1 s1 s2 |>  String.concat \"\n\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217598,"user_id":null,"body":"let compose(s1: string) (s2: string): string =\n    let l1 = String.split_on_char '\n' s1 in\n    let l2 = List.rev @@ String.split_on_char '\n' s2 in\n    let prefixes = List.mapi (fun ix s -> String.sub s 0 (ix + 1)) l1 in\n    let suffixes = List.mapi (fun ix s -> String.sub s 0 (String.length s - ix)) l2 in\n    let merged = List.map2 (^) prefixes suffixes in\n    String.concat \"\n\" merged","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217599,"user_id":null,"body":"let compose(s1: string) (s2: string): string =\n  let get_left_part str i = \n    String.sub str 0 (i + 1) in\n\n  let get_right_part str i =\n    String.sub str 0 ((String.length str) - i) in\n    \n  let left = String.split_on_char '\n' s1 in\n  let right = List.rev (String.split_on_char '\n' s2) in\n  String.concat \"\n\" \n  (List.mapi (fun i x -> String.concat \"\" [(get_left_part x i); (get_right_part (List.nth right i) i)]) left);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217600,"user_id":null,"body":"let compose s1 s2 =\n  let split x = Str.split (Str.regexp \"[\n]+\") x in\n  let tokenize_s2  = split s2 in\n  let tokenize_s1  = split s1 in\n  let len = List.length tokenize_s2 in\n  let rec aux i lst =\n    if i >= len then lst\n    else aux (i+1) (((String.sub (List.nth tokenize_s1 i) 0 (i+1)) ^\n                     (String.sub (List.nth tokenize_s2 (len-i-1)) 0 (len-i)))\n                    ::lst)\n  in\n  String.concat \"\n\" (List.rev (aux 0 []))\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217601,"user_id":null,"body":"let compose s1 s2 =\n  let xs1 = String.split_on_char '\n' s1 in\n  let len = match xs1 with\n    | s::_ -> 1 + String.length s\n    | _ -> 0\n  in\n  List.map2 (fun a b -> String.sub (a ^ b) 0 len)\n    (List.mapi (fun i s -> String.sub s 0 (i + 1)) xs1)\n    (String.split_on_char '\n' s2 |> List.rev)\n    |> String.concat \"\n\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217602,"user_id":null,"body":"let compose(s1: string) (s2: string): string =\n  let l1 = Str.split (Str.regexp \"\n\") s1 in\n  let l2 = Str.split (Str.regexp \"\n\") s2 in\n  let rec aux xs ys n i r =\n    if n=i then r\n    else \n      let s = \n        (String.sub (List.nth xs i) 0 (i+1)) ^\n        (String.sub (List.nth ys (n-i-1)) 0 (n-i))\n      in\n      aux xs ys n (i+1) (r ^ \"\n\" ^ s)\n  in\n  String.trim (aux l1 l2 (List.length l1) 0 \"\")","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56f3a1e899b386da78000732":[{"id":217603,"user_id":492,"body":"let make i a =\n  let s1 = Array.to_list(Array.sub a 0 i) in \n    let s2 = Array.to_list(Array.sub a i (Array.length a - i)) in\n      (String.concat \" \" s1, String.concat \" \" s2)\n\nlet partArray a =\n  let l = Array.init (Array.length a - 1) (fun x -> x + 1) in\n    Array.map (fun i -> make i a) l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217604,"user_id":null,"body":"let part_array a =\n  let n = Array.length a in\n  Array.init (n - 1)\n             (fun i -> (Array.sub a 0 (i+1) |> Array.to_list\n                                            |> String.concat \" \",\n                        Array.sub a (i+1) (n-i-1) |> Array.to_list\n                                                  |> String.concat \" \"))\n\nlet partArray (* Ew *) = part_array","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217605,"user_id":null,"body":"(* Shouldn't be too hard *)\nlet concatArray a = \n  String.concat \" \" (Array.to_list a)\nlet partArray a =\n  let len = Array.length a in\n  Array.mapi \n  (fun i -> fun _ -> (concatArray (Array.sub a 0 (i+1)), \n                      concatArray (Array.sub a (i+1) (len-1-i))\n                     )\n  ) (Array.sub a 0 (len-1))\n  \n  \n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217606,"user_id":null,"body":"let join a = String.concat \" \" (Array.to_list a)\n\nlet partArray a =\n  let l = Array.length a in\n  let rnge = Array.init (l - 1) (fun i -> i + 1) in\n  Array.map (fun i -> (join (Array.sub a 0 i), join (Array.sub a i (l - i)))) rnge","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217607,"user_id":null,"body":"let rec join arr k limit answer =\n  if k == limit then (answer ^ Array.get arr k) \n    else join arr (k+1) limit (answer ^ Array.get arr k ^ \" \");;\n\nlet rec items input limit1 limit2 =\n  let left = Array.sub input 0 (limit1+1) in\n  let right = Array.sub input (limit1+1) (limit2-limit1-1) in  \n  let first = join left 0 limit1 \"\" in\n  let second = join right 0 (limit2-limit1-2) \"\" in  \n  (first, second);;\n\nlet rec part2 input counter limit answer =\n  if counter == limit-1 then Array.sub answer 1 (limit-1) else\n    let newItem = Array.make 1 (items input counter limit) in\n    part2 input (counter+1) limit (Array.append answer newItem);;\n\nlet partArray a =\n  let long = Array.length a in\n  let answer = Array.make 1 (\"code\", \"wars\") in\n  part2 a 0 long answer;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217608,"user_id":53,"body":"let go i arr =\n  let a = Array.to_list(Array.sub arr 0 i) in \n  let b = Array.to_list(Array.sub arr i (Array.length arr - i)) in\n  (String.concat \" \" a, String.concat \" \" b) ;;\n\nlet partArray a =\n  let l = Array.init (Array.length a - 1) (fun i -> i + 1) in Array.map (fun i -> go i a) l ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217609,"user_id":98,"body":"let partArray array =\n  let list = Array.to_list array in\n  let rec make_parts left right parts =\n    match right with\n    | [] -> parts \n    | h :: t -> make_parts (left @ [h]) t (((String.concat \" \" left), (String.concat \" \" right)) :: parts)\n  in Array.of_list (List.rev (make_parts [List.hd list] (List.tl list) []))\n ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217610,"user_id":null,"body":"let rec part l x y acc =\n  match l with\n  | [] -> assert false\n  | hd :: tl ->\n    if x = y\n    then (String.concat \" \" (List.rev acc), String.concat \" \" (hd :: tl))\n    else part tl (x + 1) y (hd :: acc)\n\nlet rec range x acc =\n  if x = 0\n  then acc\n  else\n    let x = x - 1 in\n    range x (x :: acc)\n\nlet partArray a =\n  let l = Array.to_list a in\n  range (List.length l) []\n  |>  List.map (fun i -> part l 0 i [])\n  |> function\n  | [] -> assert false\n  | hd :: tl -> tl |> Array.of_list","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217611,"user_id":null,"body":"let partArray a =\n  let make_str len f = String.concat \" \" (List.init len f) in\n  let split_at n a = make_str n (fun i -> a.(i)), make_str (Array.length a - n) (fun i -> a.(n + i)) in\n  Array.init (Array.length a - 1) (fun i -> split_at (i+1) a)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217612,"user_id":null,"body":"let partArray a =\n  let l = Array.length a in\n  let a_new = Array.make (l-1) (a.(0),a.(0)) in\n  let c = ref 1 in\n  let rec loop n =\n    let string1 = ref \"\" in\n    let string2 = ref \"\" in\n    let rec make_string2 r f =\n      if r>f then (!string1,!string2) else\n      if r=(!c) then (string2 := !string2 ^ (a.(r)) ; make_string2 (r+1) f) else\n        (string2 := !string2 ^ \" \" ^(a.(r)) ; make_string2 (r+1) f) in\n    let rec make_string1 c z =\n      if z=c then make_string2 c (l-1) else\n      if z=0 then (string1 := !string1 ^(a.(z)) ; make_string1 c (z+1)) else\n        (string1 := !string1 ^ \" \" ^(a.(z)) ; make_string1 c (z+1)) in\n    if n=(l-1) then a_new else (a_new.(n) <- (make_string1 !c 0) ; c := !c+1 ; loop (n+1))\n  in loop 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"56fcc393c5957c666900024d":[{"id":217613,"user_id":null,"body":"let code (s: string): string =\n  let l = String.length s in\n  let n = int_of_float (Float.ceil (Float.sqrt (float_of_int l))) in \n  let rec fill acc = function \n  | 0 -> s ^ acc\n  | i -> fill (acc ^ \"&\") (i-1) in\n  let rec squared t acc = function \n  | 0 -> (String.sub t 0 n)::acc\n  | i -> squared t ((String.sub t (i*n) n)::acc) (i-1) in \n  let rotate l = \n    let res = Array.make n \"\" in\n    let rec aux = function \n    | [] -> ()\n    | a::q -> for i = 0 to n-1 do \n                res.(i) <- (String.sub a i 1) ^ res.(i)\n              done; aux q in\n    aux l;\n    let rec conc acc = function \n    | 0 -> res.(0) ^ acc\n    | i -> conc (\"\\n\" ^ res.(i) ^ acc) (i-1) in\n    conc \"\" (n-1) in\n  rotate (squared (fill \"\" (n*n-l)) [] (n-1));;\nlet decode (s: string): string =\n  let s_list = String.split_on_char '\\n' s in\n  let n = List.length s_list in \n  let res = Array.make n \"\" in\n  let rec rotate = function \n  | [] -> ()\n  | a::q -> for i = 0 to n-1 do \n              let ch = (String.sub a i 1) in \n              if ch <> \"&\" then \n                res.(n-1-i) <- res.(n-1-i) ^ (String.sub a i 1)\n            done; rotate q in\n  rotate s_list;\n  let rec conc acc = function \n  | 0 -> res.(0) ^ acc\n  | i -> conc (res.(i) ^ acc) (i-1) in\n  conc \"\" (n-1) ;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:54:41"},{"id":217614,"user_id":492,"body":"let code (s: string): string =\n  rot_90_clock96(chunk96 s);;\nlet decode (s: string): string =\n  rot_90_counter96 s |> Str.split(Str.regexp \"&\") |> List.hd |> Str.split(Str.regexp \"\\n\") |> String.concat \"\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:54:43"},{"id":217615,"user_id":null,"body":"let matrix_of_squared_string s =\n  s |> String.split_on_char '\\n'\n    |> List.map (fun s -> List.init (String.length s) (fun i -> String.make 1 s.[i]))\n\nlet squared_string_of_matrix m =\n  m |> List.map (String.concat \"\")\n    |> String.concat \"\\n\"\n\n\nlet matrix_of_string size s =\n  List.init size (fun i -> List.init size (fun j -> String.make 1 s.[size * i + j]))\n\nlet string_of_matrix m =\n  m |> List.map (String.concat \"\")\n    |> String.concat \"\"\n\n\nlet rot90_clock m =\n  let rec loop buff = function\n    | [] | [] :: _ -> List.rev buff\n    | ls           -> loop (List.rev_map List.hd ls :: buff) (List.map List.tl ls) in\n  loop [] m\n\nlet rot90_trig m = List.rev_map List.rev @@ rot90_clock m\n\n\nlet code (s: string): string =\n  let len = String.length s in\n  let size = len |> float_of_int |> sqrt |> ceil |> int_of_float in\n  let padding = size * size - len in\n  let s_ = s ^ String.make padding '&' in\n  matrix_of_string size s_\n    |> rot90_clock\n    |> squared_string_of_matrix\n\nlet decode (s: string): string =\n  let s_ = s |> matrix_of_squared_string\n             |> rot90_trig\n             |> string_of_matrix in\n  let last = String.index s_ '&' in\n  String.sub s_ 0 last","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:44:19"},{"id":217616,"user_id":null,"body":"let extract_rows s =\n    let strings = String.split_on_char '\\n' s in\n    List.map (fun str -> str |> String.to_seq |> List.of_seq) strings\n\n\nlet join chars = chars |> List.map (String.make 1) |> String.concat \"\"\n\n\nlet code (t: string): string =\n    let add_padding s = \n        let length = String.length t in\n        let n = length |> float |> sqrt |> ceil |> int_of_float in\n        let d = n * n - length in\n        if d = 0 then s else s ^ String.make d '&' in\n    let add_newline s = \n        let length = String.length s in\n        let n = length |> float |> sqrt |> int_of_float in\n        let chars = s |> String.to_seq |> List.of_seq in\n        let rec loop acc ix = function\n            | [] -> String.concat \"\" @@ List.map (String.make 1) (List.rev acc)\n            | c :: cs -> \n                if ix mod n = 0 && ix <> 0 then loop (c :: '\\n' :: acc) (ix + 1) cs \n                else loop (c :: acc) (ix + 1) cs\n        in loop [] 0 chars in   \n    let rot_90_clock s =\n        let rows = extract_rows s in\n        let rec loop acc xs =\n            if List.for_all (fun x -> x = []) xs then List.rev acc\n            else let column = List.map List.hd xs in loop (List.rev column :: acc) (List.map List.tl xs) in\n        let rotated = loop [] rows in\n        rotated |> List.map join |> String.concat \"\\n\"\n    in t |> add_padding |> add_newline |> rot_90_clock\n    \n    \nlet decode (s: string): string = \n    let rot_90_counter s =\n        let rows = s |> extract_rows |> List.map List.rev in\n        let rec loop acc xs =\n            if List.for_all (fun x -> x = []) xs then List.rev acc\n            else let column = List.map List.hd xs in loop (column :: acc) (List.map List.tl xs) in\n        let transpose = loop [] rows in\n        transpose |> List.map join |> String.concat \"\\n\" in\n    let rotated = rot_90_counter s in\n    rotated \n        |> String.to_seq \n        |> List.of_seq \n        |> List.filter (fun c -> c <> '\\n' && c <> '&') \n        |> List.map (String.make 1)\n        |> String.concat \"\"\n        ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:44:19"},{"id":217617,"user_id":null,"body":"let find_align l =  \n  let rec aux n = if n*n >= l then n else aux (n+1)\n  in aux 1\n;;\n\nlet rect_str n s =\n  let rec aux res = function\n    | 0 -> res\n    | k -> aux (String.sub s (k*n - n) n :: res) (k-1)\n  in String.concat \"\\n\" (aux [] n)\n;;\n\nlet get_col n ss = \n  ss |> List.map (fun s -> String.make 1 s.[n]) |> String.concat \"\"\n;;\n\nlet get_col_rev n ss = \n  ss |> List.map (fun s -> String.make 1 s.[n]) |> List.rev |> String.concat \"\"\n;;\n\nlet rot_90_clock(s: string): string =\n  let ss = String.split_on_char '\\n' s in\n  let rec aux res = function\n    | 0 -> res\n    | n -> aux (get_col_rev (n-1) ss :: res) (n-1)\n  in match ss with\n  | [] -> \"\"\n  | h :: t -> String.concat \"\\n\" (aux [] (String.length h))\n;;\n\nlet rot_90_counter(s: string): string = \n  let ss = String.split_on_char '\\n' s in\n  let len = String.length (List.nth ss 0) in\n  let rec aux res = function\n    | 0 -> res\n    | n -> aux (get_col (len - n) ss :: res) (n-1)\n  in  String.concat \"\\n\" (aux [] len)\n;;\n\nlet code (s: string): string =\n  let l = String.length s in\n  let align = find_align l in\n  let padded = s ^ String.make (align * align - l) '&'in\n  let rect = rect_str align padded in\n  rot_90_clock rect\n;;\n\nlet decode (s: string): string =\n  s \n  |> rot_90_counter \n  |> String.split_on_char '\\n' \n  |> String.concat \"\" \n  |> Str.split (Str.regexp \"\") \n  |> List.map (fun x -> if x = \"&\" then \"\" else x)\n  |> String.concat \"\"\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:44:19"},{"id":217618,"user_id":null,"body":"let matrix_to_string m root = \n  let s = ref \"\" in\n  for i = 0 to root-1 do \n    for j = 0 to root-1 do\n      s := (!s) ^ (String.make 1 m.(i).(j))\n    done;\n    if i != root-1 then\n      s := (!s) ^ \"\\n\"\n    else ()\n  done;\n  !s\n\nlet matrix_to_string' m root = \n  let s = ref \"\" in\n  for i = 0 to root-1 do \n    for j = 0 to root-1 do\n      s := (!s) ^ (String.make 1 m.(i).(j))\n    done;\n  done;\n  !s\n\nlet code (s: string) =\n  let l = String.length s in\n  let root = int_of_float (ceil (sqrt (float l))) in\n  let l' = root * root in\n  let rec app s i = \n    match i with \n      | 0 -> s \n      | _ -> app (s ^ (String.make 1 ('&'))) (i-1)\n  in\n  let rec insert s l = \n    if String.length s = 0 then \n      \"\"\n    else\n      let head = String.sub s 0 l in\n      let tail = String.sub s l (String.length s - l) in\n      head ^ \"\\n\" ^ (insert tail l)\n  in\n  let s = app s (l' - l) in\n  let s' = insert s l' in\n  let matrix = Array.make_matrix root root 'h' in\n  let matrix' = Array.make_matrix root root 'h' in\n  let update_matrix = \n    for i = 0 to root-1 do \n      for j = 0 to root-1 do\n        matrix.(i).(j) <- s.[i*root + j]\n      done\n    done\n  in\n  update_matrix;\n   let rotate = \n    for i = 0 to root-1 do\n      for j = 0 to root-1 do \n        matrix'.(i).(j) <- matrix.(root-1-j).(i)\n      done\n    done\n  in\n  rotate;\n  (matrix_to_string matrix' root)\n\n\n\nlet decode (s: string)= \n  let rec delete_new_line s = \n    if String.length s = 0 then \"\" else\n    let start = s.[0] in\n    let tail = String.sub s 1 (String.length s - 1) in\n    if start = '\\n' then delete_new_line tail\n    else (String.make 1 start) ^ (delete_new_line tail)\n  in\n  let rec delete_and s = \n    if String.length s = 0 then \"\" else\n    let start = s.[0] in\n    let tail = String.sub s 1 (String.length s - 1) in\n    if start = '&' then delete_and tail\n    else (String.make 1 start) ^ (delete_and tail)\n  in\n  let s = delete_new_line s in\n  let root = int_of_float(sqrt (float_of_int (String.length s))) in\n  let matrix = Array.make_matrix root root 'h' in\n  let matrix' = Array.make_matrix root root 'h' in\n  let update_matrix = \n    for i = 0 to root-1 do \n      for j = 0 to root-1 do\n        matrix.(i).(j) <- s.[i*root + j]\n      done\n    done\n  in\n  update_matrix;\n  let rotate = \n    for i = 0 to root-1 do\n      for j = 0 to root-1 do\n        matrix'.(i).(j) <- matrix.(j).(root-1-i)\n      done\n    done\n  in \n  rotate;\n  delete_and(matrix_to_string' matrix' root)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:44:19"},{"id":217619,"user_id":168,"body":"let split = Str.split (Str.regexp \"\\n\")\nlet concat = String.concat \"\\n\"\nlet rev_str s =\n  let n = String.length s in\n  String.mapi (fun i _ -> s.[n - i - 1]) s\n\nlet rot(s: string): string = \n  rev_str s\n\nlet diag_1_sym(s: string): string =\n  let ss = split s in\n  let n = List.length ss in\n  let char_at i s = String.sub s i 1 in\n  let take i = List.map (char_at i) ss |> String.concat \"\" in\n  let rec loop acc i=\n    if i < 0 then acc\n    else loop (take i :: acc) (pred i) in\n  concat (loop [] (n - 1))\n\nlet rot_90_clock(s: string): string =\n  let ss = split (diag_1_sym s) in\n  List.map rev_str ss |> concat\n\nlet diag_2_sym(s: string): string =\n  let ss = List.rev (split s) in\n  let n = List.length ss in\n  let char_at i s = String.sub s i 1 in\n  let take i = List.map (char_at i) ss |> String.concat \"\" in\n  let rec loop acc i=\n    if i >= n then acc\n    else loop (take i :: acc) (succ i) in\n  concat (loop [] 0)\n\nlet rot_90_counter(s: string): string =\n  let ss = split (diag_2_sym s) in\n  List.map rev_str ss |> concat\n\nlet code (s: string): string =\n  let l = String.length s in\n  let n = sqrt (float l) |> ceil |> truncate in\n  let s = s ^ String.make (n * n - l) '&' in\n  let rec loop acc k =\n    if k >= n * n then acc\n    else loop (String.sub s k n :: acc) (k + n) in\n  List.rev (loop [] 0) |> String.concat \"\\n\" |> rot_90_clock\n  \nlet decode (s: string): string =\n  let s = rot_90_counter s in\n  Str.global_replace (Str.regexp \"[\n&]\") \"\" s","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:44:19"},{"id":217620,"user_id":492,"body":"let code (s: string): string =\n  rot_90_clock96(chunk96 s);;\nlet decode (s: string): string =\n  rot_90_counter96 s |> Str.split(Str.regexp \"&\") |> List.hd |> Str.split(Str.regexp \"\\n\") |> String.concat \"\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-10 12:44:19"}],"56fe17fcc25bf3e19a000292":[{"id":217621,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet rec range i j = if i > j then [] else i :: (range (i+1) j);;\n\nlet comb n p =\n    let m = min p (n - p) in\n        if m < 0 then Int 0 else\n            let rec loop j v =\n                if j = m then v\n                else loop (succ j) ((v *\/ (Int (n - j))) \/\/ (Int (succ j)))\n            in loop 0 (Int 1);;\n\nlet u1 (n:int) (p:int): int =\n    range 0 n \n    |> List.map(fun k -> (-1.0 ** (float_of_int k)) \n                        *. (float_of_int p)\n                        *. (4.0 ** (float_of_int (n - k)))\n                        *. (float_of_num (comb (2 * n - k + 1) k)))\n    |> List.fold_left (+.) 0.0\n    |> int_of_float;;\n\nlet v1 (n:int) (p:int): int =\n    range 0 n \n    |> List.map(fun k -> (-1.0 ** (float_of_int k)) \n                        *. (float_of_int p)\n                        *. (4.0 ** (float_of_int (n - k)))\n                        *. (float_of_num (comb (2 * n - k) k)))\n    |> List.fold_left (+.) 0.0\n    |> int_of_float;;\n\nlet uEff (n:int) (p:int): int = (n+1) * p;;\n\nlet vEff (n:int) (p:int): int = (2 * n + 1) * p;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217622,"user_id":492,"body":"#load \"nums.cma\";;\nopen Num;;\n\nlet rec range i j = if i > j then [] else i :: (range (i+1) j);;\n\nlet choose n p =\n    let m = min p (n - p) in\n        if m < 0 then Int 0 else\n            let rec loop j v =\n                if j = m then v\n                else loop (succ j) ((v *\/ (Int (n - j))) \/\/ (Int (succ j)))\n            in loop 0 (Int 1);;\n\nlet u1 (n:int) (p:int): int =\n    range 0 n \n    |> List.map(fun k -> (-1.0 ** (float_of_int k)) \n                        *. (float_of_int p)\n                        *. (4.0 ** (float_of_int (n - k)))\n                        *. (float_of_num (choose (2 * n - k + 1) k)))\n    |> List.fold_left (+.) 0.0\n    |> int_of_float;;\n\nlet v1 (n:int) (p:int): int =\n    range 0 n \n    |> List.map(fun k -> (-1.0 ** (float_of_int k)) \n                        *. (float_of_int p)\n                        *. (4.0 ** (float_of_int (n - k)))\n                        *. (float_of_num (choose (2 * n - k) k)))\n    |> List.fold_left (+.) 0.0\n    |> int_of_float;;\n\nlet uEff (n:int) (p:int): int = (n+1) * p;;\n\nlet vEff (n:int) (p:int): int = (2 * n + 1) * p;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217623,"user_id":null,"body":"let u_eff n p = p * (1 + n)\nlet v_eff n p = p * (1 + n * 2)\n\nlet u1 = u_eff\nlet v1 = v_eff\n\nlet uEff = u_eff\nlet vEff = v_eff\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217624,"user_id":53,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; *)\n\nlet uEff (n:int) (p:int): int = (n + 1) * p ;;\n\nlet vEff (n:int) (p:int): int = (2 * n + 1) * p ;;\n\nlet u1 (n:int) (p:int): int = uEff n p ;;\n\nlet v1 (n:int) (p:int): int = vEff n p ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217625,"user_id":null,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; *)\n\nlet u1 (n:int) (p:int): int = p * (n + 1)\n\nlet v1 (n:int) (p:int): int = p * (2*n + 1)\n\nlet uEff = u1\nlet vEff = v1\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217626,"user_id":480,"body":"(* uncomment if you need it: #load \"nums.cma\";; open Num;; *)\n\nlet u1 (n:int) (p:int): int =\n    (n+1)*p;;\n\nlet v1 (n:int) (p:int): int =\n    (2*n+1)*p;;\n\nlet uEff (n:int) (p:int): int = (n+1)*p;;\nlet vEff (n:int) (p:int): int = (2*n+1)*p;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217627,"user_id":168,"body":"open Num\n\nlet rec sum acc f i j =\n  if i > j then acc\n  else sum (f i +\/ acc) f (i + 1) j\n\nlet rec prod i j =\n  if i > j then Int 1\n  else Int i *\/ prod (i + 1) j\n\nlet comb n k =\n  prod (k + 1) n \/\/ prod 1 (n - k)\n\nlet u1 (n:int) (p:int): int =\n  let f k =\n    Int (if k land 1 > 0 then -1 else 1) *\/\n    (Int 4 **\/ Int (n - k)) *\/\n    comb (2 * n - k + 1) k in\n  int_of_num (Int p *\/ sum (Int 0) f 0 n)\n\nlet v1 (n:int) (p:int): int =\n  let f k =\n    Int (if k land 1 > 0 then -1 else 1) *\/\n    (Int 4 **\/ Int (n - k)) *\/\n    comb (2 * n - k) k in\n  int_of_num (Int p *\/ sum (Int 0) f 0 n)\n\nlet uEff (n:int) (p:int): int = p * (n + 1)\nlet vEff (n:int) (p:int): int = p * (2 * n + 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217628,"user_id":17,"body":"let u1 (n:int) (p:int): int = p * (n + 1)\nlet v1 (n:int) (p:int): int = p * (2 * n + 1)\nlet uEff (n:int) (p:int): int = p * (n + 1)\nlet vEff (n:int) (p:int): int = p * (2 * n + 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5700c9acc1555755be00027e":[{"id":217629,"user_id":168,"body":"let contain_all_rots strng arr =\n  let n = String.length strng in\n  let rot str =\n    String.mapi\n      (fun i _ -> if i = 0 then str.[n - 1] else str.[i - 1]) str in\n  let rec test i str =\n    if i >= n then true\n    else\n      if not (List.mem str arr) then false\n      else test (succ i) (rot str) in\n  test 0 strng\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217630,"user_id":492,"body":"let contain_all_rots strng arr =\n  let check l1 l2 =\n    List.rev_map (fun x -> if (List.mem x l2)  then 1 else 0) l1\n    |> List.fold_left (+) 0 in\n  let rot = rotate_str_to_list strng in\n  let cnt = check rot arr in\n    cnt = List.length rot;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217631,"user_id":null,"body":"let rotate s i l = String.sub s i (l - i) ^ String.sub s 0 i\nlet contain_all_rots strng arr =\n  let l = String.length strng in\n  let rnge = List.init l (fun x -> x) in\n  List.for_all (fun i -> List.mem (rotate strng i l) arr) rnge","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217632,"user_id":98,"body":"let string_of_char ch  = String.make 1 ch;;\n\nlet list_of_string str  =\n  let rec list_of_string_rec i list =\n    if i < 0 then list\n    else list_of_string_rec (i - 1) ((string_of_char str.[i]) :: list)\n  in list_of_string_rec (String.length str - 1) [] \n;;\n\nlet string_of_list lst = String.concat \"\" lst;;\n\nlet gen_rotations str =\n  let rec rotate chars rotations =\n    let next = (List.tl chars) @ [List.hd chars] in\n    let rot = string_of_list next in\n    if rot = str then str :: rotations else rotate next (rot :: rotations)\n  in if str = \"\" then [] else rotate (list_of_string str) []\n;;\n\nlet contain_all_rots strng arr =\n  let rotations = gen_rotations strng in\n  List.for_all (fun rot -> List.mem rot arr) rotations\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217633,"user_id":null,"body":"let rotate s i =\n  let open String in\n  sub s i (length s - i) ^ sub s 0 i\n\nlet all_rotations s =\n  List.init (String.length s) (fun i -> rotate s i)\n\nlet contain_all_rots str l : bool =\n  let rots = all_rotations str in\n  List.fold_left\n    (fun acc rot ->\n       acc && List.mem rot l)\n    true\n    rots","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217634,"user_id":null,"body":"let contain_all_rots strng arr =\n  let n = String.length strng in\n  let all_rot = List.init n (fun x -> (String.sub strng x (n-x)) ^ (String.sub strng 0 x)) in\n  List.for_all (fun x -> List.mem x arr) all_rot\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217635,"user_id":null,"body":"let contain_all_rots strng arr =\n  let contains strng = List.fold_left (||) false \n    (List.map (String.equal strng) arr)\n  and len = String.length strng in\n  let rot idx = (String.sub strng idx (len - idx))\n                ^ (String.sub strng 0 idx) in\n  let rec range i j = if i > j then [] else i :: (range (i+1) j) in\n  let rots = List.map rot (range 0 len) in\n    List.fold_left (&&) true (List.map contains rots)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217636,"user_id":null,"body":"let contain_all_rots strng arr =\n  List.for_all (fun x -> List.mem x arr) (List.init (String.length strng) (fun i -> String.sub strng i (String.length strng - i) ^ String.sub strng 0 i));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217637,"user_id":53,"body":"open Printf;;\n\nlet rot s =\n  sprintf \"%s%s\" (String.sub s 1 ((String.length s) - 1)) (String.sub s 0 1)\n;;\n\nlet rot_all s =\n  let rec loop acc k = \n    if k == 0 then acc\n    else loop ((rot (List.hd acc)) :: acc) (k - 1)\n  in loop [s] (String.length s) \n;;\n\nlet contain_all_rots s arr =\n  List.for_all (fun x -> List.exists (fun y -> BatString.exists x y) arr) (rot_all s) \n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217638,"user_id":null,"body":"let rotate s n = \n  let first_half = String.sub s n ((String.length s) - n) in \n  let second_half = String.sub s 0 n in\n    first_half ^ second_half\n\nlet contain_all_rots strng arr =\n  let tbl = Hashtbl.create (List.length arr) in\n  List.iter (fun x -> Hashtbl.add tbl x true) arr;\n  let range  = List.init (String.length strng) (fun x -> x + 1) in\n    List.for_all (fun x -> \n      let rot = rotate strng x in\n      Hashtbl.mem tbl rot\n    ) range\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"570409d3d80ec699af001bf9":[{"id":217639,"user_id":null,"body":"let rec fusc n = if n < 2 then n else if n mod 2 = 0 then fusc (n \/ 2) else fusc ((n + 1) \/ 2) + fusc ((n - 1) \/ 2)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217640,"user_id":null,"body":"let rec fusc  = function\n   | 0 -> 0\n   | 1 -> 1\n   | n -> if n mod 2 = 0 then fusc (n \/ 2) else fusc (n \/ 2) + fusc (1 + n \/ 2 )","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217641,"user_id":null,"body":"let rec fusc (n: int): int =\n  match n with\n  | 0 -> 0\n  | 1 -> 1\n  | _ -> let n_half = n \/ 2 in if n mod 2 = 0 then fusc n_half \n      else fusc n_half + fusc (n_half + 1) \n          ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217642,"user_id":null,"body":"let rec fusc (n: int): int =\n  match n with\n  | 0 -> 0\n  | 1 -> 1\n  | n -> let d = n \/ 2 in \n         fusc(d) + if (n mod 2 <> 0) then fusc(d + 1) else 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217643,"user_id":null,"body":"let rec fusc (n: int): int =\n  match n with 0->0 | 1->1 |\n  n -> if n mod 2 = 0 then fusc (n \/ 2)\n  else fusc (n\/2) + fusc (n\/2 + 1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217644,"user_id":null,"body":"let rec fusc = function\n| 0 -> 0\n| 1 -> 1\n| x -> if x mod 2 == 0 then fusc (x\/2) else fusc ((x-1)\/2) + fusc (((x-1)\/2)+1) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217645,"user_id":null,"body":"let rec fusc (n: int): int = \n  if n < 2 then n\n  else if n mod 2 = 0 then fusc (n\/2)\n  else let n = (n - 1) \/ 2 in (fusc n) + fusc (n + 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217646,"user_id":null,"body":"let rec fusc = function\n  | 0 -> 0\n  | 1 -> 1\n  | n when n mod 2 == 0 -> fusc (n \/ 2)\n  | n -> let n = (n - 1) \/ 2 in fusc(n) + fusc(n + 1)\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217647,"user_id":null,"body":"let rec fusc (n: int): int =\n  match n with\n  | 0 -> 0\n  | 1 -> 1\n  | _ -> if n mod 2 = 0 then fusc (n\/2) else fusc(n\/2) + fusc( (n\/2) + 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217648,"user_id":null,"body":"let rec fusc(n) = \n  match n with\n  | 0 -> 0\n  | 1 -> 1\n  | n when n mod 2==0 -> fusc(n\/2)\n  | n -> fusc(n\/2) + fusc(n\/2+1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57040e445a726387a1001cf7":[{"id":217649,"user_id":null,"body":"let fusc n = \n  let rec helper n a b = \n    if n = 0 then b\n    else if n mod 2 = 0 \n      then helper (n\/2) (a + b) b \n      else helper (n\/2) a (a + b)\n  in helper n 1 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217650,"user_id":null,"body":"let rec fusc n = \n  if n < 2 then n \n  else if n mod 2 = 0 then fusc (n\/2)\n  else let rec helper n a b = \n    if n < 2 then a + b\n    else if n mod 2 = 0 then helper (n\/2) (a + b) b \n    else helper (n\/2) a (a + b)\n  in helper (n\/2) 1 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217651,"user_id":null,"body":"let fusc (n: int): int = \n    let rec loop (k: int) (a: int) (b: int) = \n        if k = 0 then a\n        else if k = 1 then a + b\n        else if k mod 2 = 0 then loop (k \/ 2) a (a + b)\n        else loop ((k - 1) \/ 2) (a + b) b\n    in loop n 0 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217652,"user_id":527,"body":"let rec fusc' n a b =\n  if n == 0 then b else\n  if n mod 2 == 0\n    then fusc' (n \/ 2) (a + b) b\n    else fusc' (n \/ 2) a (a + b)\n\nlet fusc (n: int): int = fusc' n 1 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217653,"user_id":53,"body":"let fusc (n: int): int =\n  let rec go m a b = match m with\n    | 0 -> b\n    | x -> \n      if x mod 2 = 1\n      then go (x \/ 2) a (b + a)\n      else go (x \/ 2) (a + b) b\n  in go n 1 0 ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217654,"user_id":168,"body":"let fusc (n: int): int =\n  let rec loop n a b =\n    match n with\n    | 0 -> b\n    | _ when n mod 2 = 1 -> loop (n \/ 2) a (a + b)\n    | _ -> loop (n \/ 2) (a + b) b\n  in\n  loop n 1 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217655,"user_id":null,"body":"let fusc n =\n  let rec aux a b k =\n\t\tmatch k, k land 1 with\n\t\t| 0, _ -> a\n\t\t| _, 0 -> aux a (a+b) (k lsr 1)\n\t\t| _ -> aux (a+b) b (k lsr 1) in\n\tmatch n land 1 with\n\t| 0 -> aux 0 1 n\n\t| _ -> aux 1 0 (n-1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5715eaedb436cf5606000381":[{"id":217656,"user_id":null,"body":"let positive_sum ls =\n  ls |> List.filter (fun x -> x > 0) |> List.fold_left (+) 0 ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217657,"user_id":null,"body":"let positive_sum ls =\nList.fold_left\n     (fun acc x -> if x>0 then acc + x else acc)\n     0\n     ls\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217658,"user_id":null,"body":"let positive_sum ls =\n  ls\n  |> List.filter (fun e -> 0 <= e)\n  |> List.fold_left (fun acc e -> acc + e) 0\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217659,"user_id":null,"body":"let positive_sum l =\n  let rec helper acc l1 =\n    match l1 with\n    | [] -> acc\n    | h::t -> helper (if h>0 then acc+h else acc) t\n  in helper 0 l;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217660,"user_id":null,"body":"let positive_sum xs = List.fold_left ( + ) 0 (List.filter (( < ) 0) xs)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217661,"user_id":null,"body":"let positive_sum ls = ls |> List.filter (fun x -> x > 0) |> List.fold_left (fun acc x -> acc +x) 0","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217662,"user_id":null,"body":"let positive_sum =\n  List.fold_left (fun b a -> max a 0 + b) 0\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217663,"user_id":null,"body":"let rec positive_sum = function\n  | [] -> 0\n  | x :: l -> (max x 0) + (positive_sum l);;\n  ","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217664,"user_id":null,"body":"let rec positive_sum ls = match ls with\n  [] -> 0\n  | head :: tail -> if head > 0 then head + positive_sum tail else positive_sum tail;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217665,"user_id":null,"body":"let positive_sum ls =\n  let sum l = List.fold_left (+) 0 l in\n  sum (List.filter (fun x -> x > 0) ls)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5726f813c8dcebf5ed000a6b":[{"id":217666,"user_id":168,"body":"let p_factors n =\n  let rec loop acc k n =\n    if n <= 1 || k > n then \n      acc\n    else if n mod k = 0 then\n      loop (succ acc) k (n \/ k)\n    else\n      loop acc (succ k) n in\n  loop 0 2 n\n\nlet countKprimes k start nd = \n  let rec loop acc i =\n    if i > nd then List.rev acc\n    else if p_factors i = k then\n      loop (i :: acc) (succ i)\n    else\n      loop acc (succ i) in\n  loop [] start\n\nlet puzzle s =\n  let p7 = countKprimes 7 128 (s - 10) in\n  let p3 = countKprimes 3 8 (s - 130) in\n  let rec loop3 acc v = function\n  | [] -> acc\n  | p :: ps ->\n    if v - p < 2 then acc\n    else if p_factors (v - p) = 1 then\n      loop3 (succ acc) v ps\n    else\n      loop3 acc v ps in\n  List.fold_left (fun acc p -> loop3 acc (s - p) p3) 0 p7\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217667,"user_id":53,"body":"let rec range (a: int) (b: int): int list =\n  if a > b then []\n  else a :: range (succ a) b\n  ;;\n  \nlet product l1 l2 =\n  List.rev(\n    List.fold_left\n      (fun x a -> List.fold_left (fun y b -> (a,b)::y) x l2)\n    [] l1)\n  ;;\n  \nlet rec factors tot k n =\n  if k > n then \n    tot\n  else if n mod k = 0 then\n    factors (succ tot) k (n \/ k)\n  else\n    factors tot (succ k) n\n  ;;\n\nlet countKprimes k start nd = \n  let fs = range start nd in\n  fs |> List.filter (fun n -> (factors 0 2 n) == k)\n  ;;\n  \nlet matches p s =\n  let a = fst p in\n  let b = snd p in\n  let c = s - a - b in\n  c > 0 && (factors 0 2 c) == 1\n  ;;\n\nlet puzzle s =\n  let xs = countKprimes 7 128 (s - 10) in\n  let ys = countKprimes 3 8 (s - 130) in\n  let pairs = product xs ys in\n  pairs |> List.filter (fun p -> matches p s) |> List.length\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217668,"user_id":null,"body":"\n\nlet  countKprimes k start nd =\n  let rec nb_fact acc p n =\n    if p > n then acc\n    else if n mod p = 0 then\n      nb_fact (succ acc) p (n\/p)\n    else nb_fact acc (succ p) n\n  in\n  List.init (nd-start+1) ((+) start)\n  |> List.filter (fun n -> nb_fact 0 2 n = k)\n  \n\nlet rec puzzle s =\n  let aL = countKprimes 1 2 (s-int_of_float(2.**3.+.2.**7.))\n  and bL =  countKprimes 3 (int_of_float (2.**3.)) (s-int_of_float (2.+.2.**7.))\n  and cL =  countKprimes 7 (int_of_float (2.**7.)) (s-int_of_float(2.+.2.**3.)) in\n  let rec mix acc aL bL = match aL with\n      [] -> acc\n    | hd::tl -> mix (List.rev_append acc (addL [] hd bL)) tl bL\n  and addL acc a lst = match lst with\n      [] ->  acc\n    | hd::tl -> if a+hd >= s then acc else addL ((a+hd)::acc) a tl\n  in\n  let aLplusbL = List.fast_sort (compare) (mix [] aL bL) in\n  let rec test al cl acc = match cl with\n    | h1::tl1 -> if h1 >= s then acc\n                 else\n                   test2 0 h1 al + acc\n                   |> test al tl1 \n    | []-> acc\n  and test2 acc a al = match al with\n    | h1::tl1 -> let t = h1 + a in if t > s then acc else  if s=t then test2 (succ acc) a tl1 else test2 acc a tl1\n    | _ -> acc\n  in test aLplusbL cL 0\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217669,"user_id":null,"body":"module IntMap = Map.Make(\n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end\n)\n\n\nlet find_largest_exponent n p =\n    let rec loop k exponent =\n        if k mod p <> 0 then (k, exponent)\n        else loop (k \/ p) (exponent + 1)\n    in loop n 0\n\n\nlet canonical_form n =\n    let rec loop k p factorization =\n        if k = 1 || p > k then factorization\n        else\n            let p' = if p = 2 then 3 else p + 2 in\n            let remainder, exponent = find_largest_exponent k p in\n            if exponent = 0 then loop remainder p' factorization\n            else loop remainder p' (IntMap.add p exponent factorization)\n    in loop n 2 IntMap.empty |> IntMap.bindings\n\n\nlet countKprimes k a b = \n    let is_k_prime n = \n        let factorization = canonical_form n in\n        let nr_factors = List.fold_left (fun acc (_, alpha) -> acc + alpha) 0 factorization in \n        nr_factors = k in\n    let rec loop acc n =\n        if n > b then List.rev acc\n        else if is_k_prime n then loop (n :: acc) (n + 1)\n        else loop acc (n + 1) \n    in loop [] a\n\n\nlet puzzle s = \n    let ps = countKprimes 1 2 s in\n    let qs = countKprimes 3 2 s in\n    let rs = countKprimes 7 2 s in\n    let sums = \n        List.flatten @@ List.map (fun p -> List.flatten @@ List.map (fun q -> List.map (fun r -> p + q + r) rs) qs) ps\n    in sums |> List.filter (fun x -> x = s) |> List.length","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217670,"user_id":609,"body":"let is_k_prime k n = \n  let rec aux res m = function\n    | _ when res > k -> false\n    | i when i > m -> (res = k)\n    | i when m mod i = 0 -> aux (res+1) (m\/i) i\n    | i -> aux res m (i+1) in\n  aux 0 n 2;;\n\nlet countKprimes k start nd =\n let rec aux acc = function\n   | i when i = start-1 -> acc\n   | i when is_k_prime k i -> aux (i::acc) (i-1)\n   | i -> aux acc (i-1) in\n  aux [] nd;;\n\nlet cartesian l1 l2 = \n  let rec aux res x = function\n    | [] -> res\n    | h::q -> aux ((x,h)::res) x q in\n  List.fold_left (fun res x -> aux res x l2) [] l1;;\n\nlet puzzle s = \n  let [al;bl;cl] = List.map (fun i -> countKprimes i 2 s) [1;3;7] in\n  let solutions = cartesian (cartesian al bl) cl in\n  List.fold_left (fun res ((a,b),c) -> res + if a+b+c=s then 1 else 0) 0 solutions;;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217671,"user_id":null,"body":"open Batteries\n\nlet rec factors n = \n  if n = 1 then [] else \n  try \n    let first_factor = \n    2 -- (float_of_int n |> sqrt |> int_of_float) \n    |> Enum.find (fun i -> n mod i = 0)\n    in\n    first_factor :: factors (n \/ first_factor)\n  with Not_found -> [n]\n\nlet is_k_prime k n =\n  (factors n |> List.length) == k\n\nlet countKprimes k start nd = \n  start -- nd |> Enum.filter (is_k_prime k) |> List.of_enum\n\nlet rec find_sum ls t =\n  match ls with [] -> if t == 0 then 1 else 0\n  | hd::tl -> \n    hd |> Array.map (fun i -> find_sum tl (t-i)) |> Array.sum\n\nlet puzzle s =\n  let p1 = countKprimes 1 2 s |> Array.of_list in\n  let p3 = countKprimes 3 2 s |> Array.of_list in\n  let p7 = countKprimes 7 2 s |> Array.of_list in\n  find_sum [p1; p3; p7] s\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217672,"user_id":null,"body":"let countKprimes k start nd = \n  let num_of_primes n =\n    let rec fact n step res =\n      match n with\n        1 -> res\n      | _ -> if (n mod step) = 0 then fact (n\/step) 2 (res+1) else fact n (step+1) res\n    in fact n 2 0\n  in let rec rcount = function\n      step when step > nd -> [] \n    | step -> if num_of_primes step = k then step::rcount (step + 1) else rcount (step + 1)\n  in rcount start;;\n  \nlet puzzle s =\n  let l1 = countKprimes 1 1 s \n  and l3 = countKprimes 3 1 s \n  and l7 = countKprimes 7 1 s\n  in let rec rsum el = function\n      (_::[], []) -> 0\n    | (_::tl, []) -> rsum el (tl,l7) \n    | (h1::t1, h2::t2) -> if (el+h1+h2) = s then 1 + (rsum el ((h1::t1), t2)) else rsum el ((h1::t1),t2)\n    | _ -> 0\n  in\n    let rec rpuzzle res = function\n      [] -> res\n    | hd::tl -> rpuzzle (res + (rsum hd (l3, l7))) tl\n    in rpuzzle 0 l1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217673,"user_id":492,"body":"let is_prime n =\n  if n = 2 then true\n  else if n < 2 || n mod 2 = 0 then false\n  else\n    let rec loop k =\n      if k * k > n then true\n      else if n mod k = 0 then false\n      else loop (k+2)\n    in loop 3\n\nlet nbPrimeFactors n =\n  let rec aux d n =\n    if n = 1 then [] else\n    if n mod d = 0 then d :: aux d (n \/ d) else aux (d+1) n\n  in\n    aux 2 n |> List.length;;\n\nlet rec range i j = if i > j then [] else i :: (range (i+1) j);;\n\nlet countKprimes k start nd = \n  List.(range start nd |>\n        filter (fun x -> nbPrimeFactors x = k));;\n\nlet puzzle s =\n  let cnt = ref 0 in\n  let b = countKprimes 3 2 s in\n  let c = countKprimes 7 2 s in\n    for j = 0 to List.length b - 1 do\n      for k = 0 to List.length c - 1 do\n        let p = (List.nth b j) in\n        let q = (List.nth c k) in\n          if is_prime (s - p - q) then \n            begin\n              cnt := !cnt + 1;\n            end\n      done;\n    done;\n    !cnt;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217674,"user_id":492,"body":"let is_prime n =\n  if n = 2 then true\n  else if n < 2 || n mod 2 = 0 then false\n  else\n    let rec loop k =\n      if k * k > n then true\n      else if n mod k = 0 then false\n      else loop (k+2)\n    in loop 3\n\nlet nbPrimeFactors n =\n  let rec aux d n =\n    if n = 1 then [] else\n    if n mod d = 0 then d :: aux d (n \/ d) else aux (d+1) n\n  in\n    aux 2 n |> List.length;;\n\nlet rec range i j = if i > j then [] else i :: (range (i+1) j);;\n\nlet countKprimes k start nd = \n  List.(range start nd |>\n        filter (fun x -> nbPrimeFactors x = k));;\n\nlet puzzle s =\n  let cnt = ref 0 in\n  let b = countKprimes 3 2 s in\n  let c = countKprimes 7 2 s in\n    for j = 0 to List.length b - 1 do\n      for k = 0 to List.length c - 1 do\n        let p = (List.nth b j) in\n        let q = (List.nth c k) in\n          if is_prime (s - p - q) then \n            begin\n              cnt := !cnt + 1;\n            end\n      done;\n    done;\n    !cnt;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"573182c405d14db0da00064e":[{"id":217675,"user_id":492,"body":"let nb_prime_factors n =\n  let rec aux d n =\n    if n = 1 then [] else\n    if n mod d = 0 then d :: aux d (n \/ d) else aux (d+1) n\n  in\n    aux 2 n |> List.length;;\n\nlet rec range i j = if i > j then [] else i :: (range (i+1) j);;\n\nlet consec_kprimes k arr =\n  let b = List.map (fun v -> nb_prime_factors v) arr in\n    List.filter (fun i -> (List.nth b i = k && List.nth b (i + 1) = k)) (range 0 ((List.length b) - 2))\n    |> List.length;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217676,"user_id":492,"body":"let nb_prime_factors n =\n  let rec aux d n =\n    if n = 1 then [] else\n    if n mod d = 0 then d :: aux d (n \/ d) else aux (d+1) n\n  in\n    aux 2 n |> List.length;;\n\nlet rec range i j = if i > j then [] else i :: (range (i+1) j);;\n\nlet consec_kprimes k arr =\n  let b = List.map (fun v -> nb_prime_factors v) arr in\n    List.filter (fun i -> (List.nth b i = k && List.nth b (i + 1) = k)) (range 0 ((List.length b) - 2))\n    |> List.length;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217677,"user_id":53,"body":"let rec range (a: int) (b: int): int list =\n  if a > b then []\n  else a :: range (succ a) b ;;\n  \nlet is_k_prime (k: int) (n: int): bool =\n  let rec aux res m = function\n    | _ when res > k -> false\n    | i when i > m -> (res = k)\n    | i when m mod i = 0 -> aux (res+1) (m\/i) i\n    | i -> aux res m (i+1) in\n  aux 0 n 2 ;;\n  \nlet consec_kprimes (k: int) (arr: int list): int =\n  let xs = (range 1 ((List.length arr) - 1)) in\n  List.length (xs |> List.filter (fun i -> \n    is_k_prime k (List.nth arr i) && \n    is_k_prime k (List.nth arr (i - 1)))) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217678,"user_id":null,"body":"open Batteries\n\nlet consec_kprimes k arr =\n    let rec is_kprime nb p n =\n    if n = 1\n    then\n      nb = k\n    else\n      if nb > k\n        then false \n      else\n        if n mod p = 0 then\n          is_kprime (nb + 1) p (n \/ p)\n        else\n          is_kprime nb (p + 1) n\n    in\n    let f lst i a =\n      match i, a with\n      | 0, _ -> None \n      | i, a -> if is_kprime 0 2 (List.nth lst (i - 1)) && is_kprime 0 2 a  then Some 1 else None in\n    List.fold_left ((+)) 0 (List.filteri_map (f arr) arr)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217679,"user_id":null,"body":"module IntMap = Map.Make(\n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end\n)\n\nlet find_largest_exponent n p =\n    let rec loop k exponent =\n        if k mod p <> 0 then (k, exponent)\n        else loop (k \/ p) (exponent + 1)\n    in loop n 0\n\n\nlet canonical_form n =\n    let rec loop k p factorization =\n        if k = 1 || p > k then factorization\n        else\n            let p' = if p = 2 then 3 else p + 2 in\n            let remainder, exponent = find_largest_exponent k p in\n            if exponent = 0 then loop remainder p' factorization\n            else loop remainder p' (IntMap.add p exponent factorization)\n    in loop n 2 IntMap.empty |> IntMap.bindings\n\n\nlet consec_kprimes k arr =\n    let is_k_prime n =\n        let factorization = canonical_form n in\n        let nr_factors = List.fold_left (fun acc (_, alpha) -> acc + alpha) 0 factorization in\n        nr_factors = k in\n    let item_is_k_prime = List.map is_k_prime arr in\n    let rec loop acc = function\n        | ([] | [_]) -> acc\n        | a :: b :: rest -> \n            let acc' = if a && b then acc + 1 else acc in\n            loop acc' (b :: rest)\n    in loop 0 item_is_k_prime","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217680,"user_id":null,"body":"(* BEGIN copied from k-primes kata *)\nopen Batteries\n\nlet rec factors n = \n  if n = 1 then [] else \n  try \n    let first_factor = \n    2 -- (float_of_int n |> sqrt |> int_of_float) \n    |> Enum.find (fun i -> n mod i = 0)\n    in\n    first_factor :: factors (n \/ first_factor)\n  with Not_found -> [n]\n\nlet is_k_prime k n =\n  (factors n |> List.length) == k\n(* END copied from k-primes kata *)\n\nlet rec count_consec_trues = function \n| [] -> 0\n| true :: true :: tl -> 1 + count_consec_trues (true::tl)\n| h::t -> count_consec_trues t\n\nlet consec_kprimes k arr = \n  List.map (is_k_prime k) arr\n  |> count_consec_trues","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217681,"user_id":168,"body":"let p_factors n =\n  let rec loop acc k n =\n    if n <= 1 || k > n then \n      acc\n    else if n mod k = 0 then\n      loop (succ acc) k (n \/ k)\n    else\n      loop acc (succ k) n in\n  loop 0 2 n\n\nlet consec_kprimes k arr =\n  let rec loop acc prev = function\n  | [] -> acc\n  | n :: ns ->\n    let flag = (p_factors n = k) in\n    loop (acc + if flag && prev then 1 else 0) flag ns in\n  loop 0 false arr","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217682,"user_id":null,"body":"let prime_num n =\n  let rec iter c p m =\n    if m = 1 then c else\n      if m mod p = 0 then iter (c+1) p (m \/ p) else iter c (p+1) m in\n  iter 0 2 n\n\nlet consec_kprimes k arr =\n  let rec count c = function\n      [] -> c\n    | x :: y :: ys when x = k && y = k -> count (c+1) (y::ys)\n    | x :: ys -> count c ys\n  in\n  count 0 (List.map prime_num arr)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217683,"user_id":null,"body":"let is_prime n =\n  let rec loop i =\n    if i * i > n\n    then\n      true\n    else\n      if n mod i = 0\n      then\n        false\n      else\n        loop (i+1)\n  in\n  loop 2;;\n\nlet get_k n =\n  let rec loop i m =\n    if i > m\n    then 0\n    else\n      if m mod i = 0 && is_prime i\n      then\n        1 + (loop 2 (m\/i))\n      else\n        loop (i+1) m\n  in\n  loop 2 n;;\n\nlet consec_kprimes k arr = (* your code *)\n  let r = ref 0\n  in\n  let k_arr = List.map get_k arr\n  in\n  let len = List.length k_arr\n  in\n  begin\n    for i = 0 to (len - 2) do\n      let ai = List.nth k_arr i\n      in\n      let bi = List.nth k_arr (i+1)\n      in\n      if ai = k && ai = bi\n      then\n        r := !r + 1;\n    done;\n    !r\n  end;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217684,"user_id":null,"body":"let rec kprimes n p =\n  if n == 1\n  then 0\n  else if n mod p == 0\n  then 1 + kprimes (n \/ p) p\n  else kprimes n (p + 1);;\n\n\nlet consec_kprimes k arr =\n  fst (List.fold_left\n      (fun (c, p) n -> if k == n && n == p then (c+1, n) else (c, n))\n      (0, 0)\n      (List.map (fun n -> kprimes n 2) arr));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57339a5226196a7f90001bcf":[{"id":217685,"user_id":null,"body":"let crossover ns xs ys = \n  let l = List.sort compare ns in\n    let rec aux (accu1, accu2) i = function\n    | (_, [], chr2) -> List.rev accu1, (List.rev accu2)@chr2\n    | (_, chr1, []) -> (List.rev accu1)@chr1, List.rev accu2\n    | ([], chr1, chr2) -> (List.rev accu1)@chr1, (List.rev accu2)@chr2\n    | (pos::pos2::q, chr1, chr2) when pos = pos2 -> aux (accu1, accu2) i (pos2::q, chr1, chr2)\n    | (pos::q, chr1, chr2) when i = pos -> aux (accu1, accu2) i (q, chr2, chr1)\n    | (l, a::chr1, b::chr2) -> aux (a::accu1, b::accu2) (i+1) (l, chr1, chr2)\n    in aux ([], []) 0 (l, xs, ys);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217686,"user_id":751,"body":"open BatList\n\nlet crossover ns xs ys =\n  let swap (xs,ys) n = \n    ((take n xs) @ (drop n ys), (take n ys) @ (drop n xs))\n  in fold_left (swap) (xs,ys) (sort_unique (-) ns)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217687,"user_id":null,"body":"let crossover ns xs ys =\n  let rec aux ax ay i = function\n    | [], xs, ys -> List.rev_append ax xs, List.rev_append ay ys\n    | n :: ns, xs, ys when i = n -> aux ax ay i (ns, ys, xs)\n    | ns, x :: xs, y :: ys -> aux (x :: ax) (y :: ay) (i + 1) (ns, xs, ys)\n    | _ -> failwith \"Unexpected state\"\n  in aux [] [] 0 (List.sort_uniq compare ns, xs, ys)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217688,"user_id":null,"body":"let crossover ns xs ys = \n  let rec take = function\n    | (0, _) -> []\n    | (n, hd::tail) -> hd :: (take ((n-1), tail))\n    | (_, []) -> raise (Invalid_argument \"Array is empty\")\n  and drop = function\n    | (0, ls) -> ls\n    | (n, _::tail) -> drop ((n-1), tail)\n    | (_, []) -> raise (Invalid_argument \"Array is empty\")\n  in\n  List.fold_left (\n    fun (first, second) n -> \n      ((take (n, first) @ drop (n, second)), (take (n, second) @ drop (n, first))))\n    (xs, ys)\n    (List.sort_uniq (fun a b -> a - b) ns)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217689,"user_id":null,"body":"let rec take n ls = \n  match (n, ls) with\n  | (0, _) -> []\n  | (_, []) -> failwith \"take\"\n  | (n, x::xs) -> x::(take (n-1) xs)\n\nlet rec drop n ls = \n  match (n, ls) with\n  | (0, _) -> ls\n  | (_, []) -> failwith \"drop\"\n  | (n, x::xs) -> drop (n-1) xs\n\nlet crossover ns xs ys = \n  List.fold_left (fun (ps, qs) n ->\n    ((take n ps @ drop n qs), (take n qs @ drop n ps)))\n    (xs, ys) (List.sort_uniq (-) ns)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217690,"user_id":null,"body":"let rev_split n l =\n  let rec loop i buff = function\n    | h :: t when i < n -> loop (i+1) (h :: buff) t\n    | l -> buff, l\n  in loop 0 [] l\n\nlet rec crossover_ xs ys = function\n  | [] -> xs, ys\n  | next_cross :: future_crosses ->\n    let h1, t1 = rev_split next_cross xs and\n        h2, t2 = rev_split next_cross ys in\n    let l1, l2 = crossover_ t2 t1 @@ List.map (fun x -> x - next_cross) future_crosses in\n    List.rev_append h1 l1, List.rev_append h2 l2\n\nlet crossover ns xs ys = crossover_ xs ys @@ List.sort_uniq compare ns","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217691,"user_id":null,"body":"open List\n\nlet rec sol b c ns xs ys = if xs==[] then [] else\n  if c == hd ns then sol (not b) c (tl ns) xs ys else\n    (if not b then (hd xs, hd ys) else (hd ys, hd xs)) :: sol b (c+1) ns (tl xs) (tl ys)\n\nlet crossover ns xs ys = \n  let s = sol false 0 ((sort_uniq Stdlib.compare ns)@[1000000000]) xs ys in\n  (map fst s, map snd s)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217692,"user_id":null,"body":"let rec swap ops p x1 x2 y1 y2 =\n  match ops with\n  | [] -> (x1 @ y1, x2 @ y2)\n  | hd::_ when p <> hd ->\n    swap ops (p + 1) (x1 @ [List.hd y1]) (x2 @ [List.hd y2]) (List.tl y1) (List.tl y2)\n  | hd::td ->\n    swap td (p + 1) (x1 @ [List.hd y2]) (x2 @ [List.hd y1]) (List.tl y2) (List.tl y1);;\n\nlet crossover ops x1 x2 = \n  swap (ops |> List.sort_uniq compare) 0 [] [] x1 x2;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217693,"user_id":null,"body":"let crossover ns xs ys =\n  let rec aux (counter, (xs_acc, ys_acc)) ns xs ys =\n    let new_counter = counter - 1 in\n    match ns with\n    | [] -> (List.rev_append xs xs_acc, List.rev_append ys ys_acc)\n    | ns_hd::ns_tail ->\n      match (xs, ys) with\n      | ([], []) ->\n        if ns_hd == 0\n        then\n          (ys_acc, xs_acc)\n        else\n          (xs_acc, ys_acc)\n      | (xs_hd::xs_tail, ys_hd::ys_tail) ->\n        if counter = ns_hd\n        then\n          aux (new_counter, (xs_hd::ys_acc, ys_hd::xs_acc)) ns_tail xs_tail ys_tail\n        else\n          aux (new_counter, (xs_hd::xs_acc, ys_hd::ys_acc)) ns xs_tail ys_tail\n      | _ -> raise (Invalid_argument \"\")\n  in\n  let ns_sorted_desc = ns |> List.sort_uniq compare |> List.rev in\n  aux (((List.length xs), ([], []))) ns_sorted_desc (List.rev xs) (List.rev ys)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217694,"user_id":480,"body":"open List;;\n\nlet rec take n l=\n  match l with \n  |[]->[]\n  |h::t-> if n==0 then [] else [h]@(take (n-1) t);;\n\nlet rec drop n l=\n  match l with\n  |[]->[]\n  |h::t-> if n==0 then l else (drop (n-1) t);;\n \nlet cross1 n xs ys=\n  if n==0 then (ys,xs)\n  else if n>=List.length xs then (xs,ys)\n  else \n    ((take n xs)@(drop n ys), (take n ys)@(drop n xs));;\n\nlet rec crossover ns xs ys =\n  let ns=List.sort_uniq (fun a b->a-b) ns in\n    match ns with\n    | [] -> (xs,ys)\n    | h::t -> \n        let(xs,ys)=cross1 h xs ys in\n        crossover t xs ys;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"573992c724fc289553000e95":[{"id":217695,"user_id":492,"body":"let smallest(sn: string): string = \n  let lg = String.length sn in\n  let r = range984 0 (lg - 1) in\n  let l = List.map( fun i -> i, sn.[i], (slice984 sn 0 (i-1) ) ^ (slice984 sn (i + 1) (lg - 1)) ) r in\n  let (a, b, c) = List.map(fun j -> List.map(fun (i, c, s) -> (insert984 c s j, i, j)) l) r\n                  |> List.flatten |> List.sort compare |> List.hd in\n    Printf.sprintf \"%s %d %d\" (string_of_int(int_of_string a)) b c;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217696,"user_id":null,"body":"let remove lst k = \n    let zipped = List.mapi (fun ix x -> (ix, x)) lst in\n    let rec loop acc = function\n        | [] -> List.rev acc\n        | (ix, x) :: rest -> \n            if ix = k then loop acc rest\n            else loop (x :: acc) rest in\n    (loop [] zipped, List.nth lst k)\n    \n\nlet insert lst k item = \n    let rec loop acc ix = function\n        | [] -> List.rev acc\n        | x :: xs -> \n            if ix = k then loop (x :: item :: acc) (ix + 1) xs\n            else loop (x :: acc) (ix + 1) xs in\n    if k >= List.length lst then lst @ [item]        \n    else loop [] 0 lst\n    \n    \nlet smallest(sn: string): string = \n    let length = String.length sn in\n    let digit_list = sn |> String.to_seq |> List.of_seq |> List.map (String.make 1) in\n    let calc_index_pairs n = \n        let lst = List.init n (fun ix -> ix) in\n        List.(lst |> map (fun ix -> List.init n (fun jy -> (ix, jy))) |> concat) in\n    let index_pairs = calc_index_pairs length in\n    let process ((smallest_list, (min_ix, min_jy)) as acc) (ix, jy) = \n        let removed, item = remove digit_list ix in\n        let inserted = insert removed jy item in\n        if inserted < smallest_list then (inserted, (ix, jy))\n        else acc in\n    let maximal_number = List.init length (fun _ -> \"9\") in    \n    let result, (a, b) = List.fold_left process (maximal_number, (0, 0)) index_pairs in\n    let result_number = result |> String.concat \"\" |> int_of_string in\n    (string_of_int result_number) ^ \" \" ^ (string_of_int a) ^ \" \" ^ (string_of_int b)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217697,"user_id":null,"body":"let find_min sn start =\n  let n = Array.length sn in\n  let rec posmin buff = function\n  | i when i = n -> buff\n  | i -> if sn.(i) < sn.(List.hd buff) then posmin [i] (i+1)\n         else if sn.(i) = sn.(List.hd buff) then posmin (i::buff) (i+1)\n         else posmin buff (i+1)\n  in posmin [start] (start+1);;\n\nlet rec all_in_order start = function\n| [] -> failwith \"?\"\n| [a] -> a = start\n| a::b::q -> a = b+1 && all_in_order start (b::q);;\n\nlet rec first_gap_size_1 = function\n| [] -> failwith \"??\"\n| [a] -> -1\n| a::b::q when a = b-2 -> a+1\n| a::b::q when a = b-1 -> first_gap_size_1 (b::q)\n| _ -> -1;;\n\nlet rec first_not_equivalent = function\n| [] -> failwith \"???\"\n| [a] -> a\n| a::b::q -> if a = b+1 then first_not_equivalent (b::q) else a;;\n\nlet possible sn start =\n  match find_min sn start with\n  | [] -> failwith \"????\"\n  | [a] when a = start + 1 -> (1, -1, -1)\n  | l when List.hd (List.rev l) = start + 1 -> (2, start, start)\n  | l when all_in_order start l -> (0, start + List.length l, -1)\n  | l -> let i = first_gap_size_1 (List.rev l) in if i <> -1 && List.mem start l then (2, i, -1) else (3, start, first_not_equivalent l);;\n(*\nCode 0 : try again on new start\nCode 1 : start is the origin, destination to the right\nCode 2 : best of the two cases i is the origin and destination to the right or start is the destination and origin to find among minima on the right\nCode 3 : start is the destination and List.hd l is the origin\n*)\n\nlet new_array sn origin destination =\n  let answer = Array.copy sn in\n  let buffer = answer.(origin) in\n  if origin < destination then\n    for i = origin to destination-1 do answer.(i) <- answer.(i+1) done\n  else\n    for i = origin downto destination+1 do answer.(i) <- answer.(i-1) done;\n  answer.(destination) <- buffer;\n  answer;;\n\nlet minimal_new_array sn origin =\n  let minima = ref sn and destination = ref origin in\n  for attempt = origin+1 to Array.length sn - 1 do\n    let attemptarray = new_array sn origin attempt in\n      if attemptarray < !minima then\n        begin\n          minima := attemptarray;\n          destination := attempt\n        end\n  done;\n  !destination;;\n\nlet minimal_new_array_bis sn origin destination =\n  let minima = ref sn and dest = ref origin and ori = ref origin in\n  for attempt = origin+1 to Array.length sn - 1 do\n    let attemptarray = new_array sn origin attempt in\n      if attemptarray < !minima then\n        begin\n          minima := attemptarray;\n          dest := attempt\n        end\n  done;\n  for attempt2 = destination+1 to Array.length sn - 1 do\n    let attemptarray = new_array sn attempt2 destination in\n      if attemptarray < !minima then\n        begin\n          minima := attemptarray;\n          dest := destination;\n          ori := attempt2\n        end\n  done;\n  (!ori, !dest);;\n\nlet smallest(sn: string): string =\n  let n = String.length sn\n  in let snarray = Array.init n (fun i -> sn.[i])\n  in let rec minfrom index =\n    if index = n then (0, 0)\n    else match possible snarray index with\n    | (0, new_index, _) -> minfrom new_index\n    | (1, _, _) -> (index, minimal_new_array snarray index)\n    | (2, potential_origin, _) -> minimal_new_array_bis snarray potential_origin index\n    | (3, left, right) -> (right, left)\n    | _ -> failwith \"????\"\n  in let (origin, destination) = minfrom 0\n  in let new_snarray = new_array snarray origin destination\n  in let remove0s = ref 0 in while new_snarray.(!remove0s) = '0' do incr remove0s done;\n  let end_string = String.init (n - !remove0s) (fun i -> new_snarray.(i + !remove0s)) in\n  if (origin, destination) = (0, 0) then sn ^ \" 0 0\"\n  else if origin = destination + 1 then Printf.sprintf \"%s %d %d\" end_string destination origin\n  else Printf.sprintf \"%s %d %d\" end_string origin destination;;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217698,"user_id":null,"body":"let smallest(sn: string): string = \n  let open Core.Std in\n  \n  let spliti lst i = List.nth_exn lst i, ((List.take lst i) @ (List.drop lst (i+1))) in\n  let inserti lst i n = (List.take lst i) @ [n] @ (List.drop lst i) in\n  let replace lst cfrom cto =\n    let d,lst = spliti lst cfrom in\n    inserti lst cto d\n  in\n  \n  let len = String.length sn in\n  let lst = String.to_list_rev sn |> List.rev in\n  let rec lookup (min,mfrom,mto) cfrom cto =\n    match cfrom,cto with\n    | cfrom,_ when cfrom >= len -> (min,mfrom,mto)\n    | cfrom,cto when cto >= len -> lookup (min,mfrom,mto) (cfrom+1) 0\n    | cfrom,cto -> let num = replace lst cfrom cto |> String.of_char_list |> Int.of_string in\n                   let min,mfrom,mto = if num < min then num,cfrom,cto else min,mfrom,mto in\n                   lookup (min,mfrom,mto) cfrom (cto+1)\n  in\n  let min,mfrom,mto = lookup (Int.max_value,0,0) 0 0 in\n  Printf.sprintf \"%d %d %d\" min mfrom mto\n                   ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217699,"user_id":null,"body":"let gen_moves n =\n  let rec range = function 0 -> [0] | x -> x :: range (x - 1) in\n  range n\n  |> List.map (fun v -> range n |> List.map (fun x -> v, x))\n  |> List.concat\n  |> List.rev\n\nlet move s src dst =\n  let a = String.sub s 0 src in\n  let b = String.sub s (src + 1) ((String.length s) - src - 1) in\n  let s' = a ^ b in\n  (String.sub s' 0 dst) ^ String.sub s src 1 ^ String.sub s' dst ((String.length s') - dst)\n\nlet smallest(sn: string): string = \n  gen_moves (String.length sn - 1)\n  |> List.map (fun (src, dst) -> move sn src dst |> int_of_string, src, dst)\n  |> List.sort (fun (a, _, _) (b, _, _) -> a - b)\n  |> List.map (fun (n, src, dst) -> Printf.sprintf \"%d %d %d\" n src dst)\n  |> List.hd\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217700,"user_id":168,"body":"open Num\n\nlet insert str i j =\n  let n = String.length str in\n  if i < j then\n    String.init n \n      (fun p -> \n        if p < i || p > j then str.[p]\n        else if p < j then str.[p + 1]\n        else str.[i])\n  else\n    String.init n\n      (fun p ->\n        if p < j || p > i then str.[p]\n        else if p = j then str.[i]\n        else str.[p - 1])\n\nlet smallest (sn: string) : string =\n  let n = String.length sn in\n  let m = ref (num_of_string sn) in\n  let index = ref (0, 0) in\n  for i = 0 to n - 1 do\n    for j = 0 to n - 1 do\n      if i <> j then\n        let s = insert sn i j in\n        let t = num_of_string s in\n        if t <\/ !m then begin\n          m := t;\n          index := (i, j)\n        end\n    done\n  done;\n  let i, j = !index in\n  Printf.sprintf \"%s %d %d\" (string_of_num !m) i j","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217701,"user_id":751,"body":"open Batteries\nlet smallest(sn: string): string =\n   let move s i j = \n     let chars = s |> String.to_list in \n     let mv = BatList.nth chars i in\n     let chars' = (BatList.take i chars) @ (BatList.drop (i+1) chars) in\n     ((BatList.take j chars') @ [mv] @ (BatList.drop j chars')) |> String.of_list in\n   let range = ((BatString.length sn) - 1) |> BatList.range 0 `To in  \n   let perms = BatList.cartesian_product range range in\n   let (m,i,j) = perms\n     |> BatList.map (fun (x,y) -> ((move sn x y) |> String.to_int, x, y))\n     |> BatList.min in\n   Printf.sprintf \"%d %d %d\" m i j","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217702,"user_id":751,"body":"open Batteries\nlet smallest(sn: string): string =\n   let move s i j = \n     let chars = s |> String.to_list in \n     let mv = BatList.nth chars i in\n     let chars' = (BatList.take i chars) @ (BatList.drop (i+1) chars) in\n     ((BatList.take j chars') @ [mv] @ (BatList.drop j chars')) |> String.of_list in\n   let range = ((BatString.length sn) - 1) |> BatList.range 0 `To in  \n   let perms = range |> BatList.cartesian_product range in\n   let (m,i,j) = perms\n     |> BatList.map (fun (x,y) -> ((move sn x y) |> String.to_int, x, y))\n     |> BatList.min in\n   (String.of_int m) ^ \" \" ^ (String.of_int i) ^ \" \" ^ (String.of_int j)\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57591ef494aba64d14000526":[{"id":217703,"user_id":null,"body":"let john n =\n  let j = Array.make n 0 and a = Array.make n 1 in\n  for k = 1 to n - 1 do\n    a.(k) <- k - j.(a.(k - 1)) ;\n    j.(k) <- k - a.(j.(k - 1))\n  done ;\n  j\n\nlet ann n =\n  let j = Array.make n 0 and a = Array.make n 1 in\n  for k = 1 to n - 1 do\n    a.(k) <- k - j.(a.(k - 1)) ;\n    j.(k) <- k - a.(j.(k - 1))\n  done ;\n  a\n\nlet sum_john n = Array.fold_left (+) 0 (john n)\n\nlet sum_ann n = Array.fold_left (+) 0 (ann n)\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217704,"user_id":492,"body":"let john_ann n =\n  let rec loop (i: int) (jlist: int array) (alist: int array) =\n    if (i >= n) then\n      [|alist; jlist|]\n    else\n      let a1 = alist.(jlist.(i - 1)) in\n      let jlist1 = Array.append jlist [|i - a1|] in\n      let j1 = jlist1.(alist.(i - 1)) in\n        loop (i + 1) jlist1 (Array.append alist [|i - j1|]) in\n    loop 1 [|0|] [|1|];;\n\nlet john n = (john_ann n).(1);;\nlet ann n = (john_ann n).(0);;\n\nlet sum_john(n) = john n |> Array.fold_left (+) 0;;\nlet sum_ann(n) = ann n |> Array.fold_left (+) 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217705,"user_id":53,"body":"open Batteries;;\n\nmodule U = struct\n  open Core.Std\n  let mem_john = Int.Table.create () ~size:0\n  let memoize_john k v = Hashtbl.set mem_john ~key:k ~data:v\n  let recall_john k = Hashtbl.find mem_john k\n  let mem_ann = Int.Table.create () ~size:0\n  let memoize_ann k v = Hashtbl.set mem_ann ~key:k ~data:v\n  let recall_ann k = Hashtbl.find mem_ann k\n  let rec john = function\n  | 0 -> 0\n  | n -> match recall_john n with\n         | None -> let v = n - ann (john (n - 1)) in\n                   memoize_john n v; v\n         | Some v -> v\n  and ann = function\n  | 0 -> 1\n  | n -> match recall_ann n with\n         | None -> let v = n - john (ann (n - 1)) in\n                   memoize_ann n v; v\n         | Some v -> v\nend\nlet john_on = U.john\nlet ann_on = U.ann\n\nlet john n =\n  Array.map(fun x -> john_on x) (Array.of_enum (0--(n - 1)))\n  \nlet ann n =\n  Array.map(fun x -> ann_on x) (Array.of_enum (0--(n - 1)))\n\nlet sum_john(n) =\n  (john n) |> Array.fold_left (+) 0\n  \nlet sum_ann(n) =\n  (ann n) |> Array.fold_left (+) 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217706,"user_id":null,"body":"let john n = \n    let a = Array.make n 0 in\n    let j = Array.make n 0 in\n    a.(0) <- 1;\n    let rec loop k = \n        if k >= n then j\n        else (\n            a.(k) <- k - j.(a.(k - 1));\n            j.(k) <- k - a.(j.(k - 1));\n            loop (k + 1))\n    in loop 1\n    \n    \nlet ann n = \n    let a = Array.make n 0 in\n    let j = Array.make n 0 in\n    a.(0) <- 1;\n    let rec loop k = \n        if k >= n then a\n        else (\n            a.(k) <- k - j.(a.(k - 1));\n            j.(k) <- k - a.(j.(k - 1));\n            loop (k + 1))\n    in loop 1\n    \n    \nlet sum_john n = \n    let array = john n in\n    Array.fold_left (+) 0 array\n    \n\nlet sum_ann n = \n    let array = ann n in\n    Array.fold_left (+) 0 array","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217707,"user_id":null,"body":"(* functions \"john\" and \"ann\" return array *)\n\nlet john n = \n  let j = Array.make n 0 in\n  let a = Array.make n 1 in\n  let rec aux = function\n  | k when k = n -> j\n  | k -> let t = j.(k-1) in \n        j.(k) <- k - (a.(t));\n        let t = a.(k-1) in\n        a.(k) <- k - (j.(t));\n        aux (k+1)\n  in aux 1;;\n  \n  \n  \nlet ann n =\n  let j = Array.make n 0 in\n  let a = Array.make n 1 in\n  let rec aux = function\n  | k when k = n -> a\n  | k -> let t = j.(k-1) in \n        j.(k) <- k - (a.(t));\n        let t = a.(k-1) in\n        a.(k) <- k - (j.(t));\n        aux (k+1)\n  in aux 1;;\n\nlet sum_john(n) = Array.fold_left (+) 0 (john n);;\nlet sum_ann(n) = Array.fold_left (+) 0 (ann n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217708,"user_id":null,"body":"(* functions \"john\" and \"ann\" return array *)\nlet cool n = \n  let a = Array.make n 1 in\n  let j = Array.make n 0 in\n  for i = 1 to (n-1) do\n    a.(i) <- i-(j.(a.(i-1)));\n    j.(i) <- i-(a.(j.(i-1))) done;\n  [|a; j|];;\n\nlet sum t =\n  let s = ref 0 in\n  for i = 0 to ((Array.length t) - 1) do\n    s := !s + t.(i) done;\n  !s;;\n\nlet john n = (cool n).(1);;\nlet ann n = (cool n).(0);;\n\nlet sum_john(n) = sum (cool n).(1);;\nlet sum_ann(n) = sum (cool n).(0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217709,"user_id":null,"body":"(* functions \"john\" and \"ann\" return array *)\n\nlet rec tableau n = let t = [|Array.make n (-1);Array.make n (-1)|] in\nt.(0).(0) <- 1;t.(1).(0) <- 0;\nfor i = 1 to n-1 do t.(1).(i) <- i - t.(0).(t.(1).(i-1)) ; t.(0).(i) <- i - t.(1).(t.(0).(i-1)) done;\nt;;\n\nlet ann n =(tableau n).(0);;\n\nlet john n = (tableau n).(1);;\n\n\n\nlet sum_john n = let tab = john n and sum = ref 0 in \nfor i = 0 to n-1 do sum := !sum + tab.(i)\ndone;\n!sum;;\n \nlet sum_ann n = let tab = ann n and sum = ref 0 in \nfor i = 0 to n-1 do sum := !sum + tab.(i)\ndone;\n!sum;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217710,"user_id":null,"body":"let rec aux n = let t1 = Array.make n 0 and t2 = Array.make n 1 in\n  for i = 1 to n-1 do\n    t1.(i) <- i - t2.(t1.(i-1));\n    t2.(i) <- i - t1.(t2.(i-1))\n  done; (t1,t2);;\n\nlet john n = fst (aux n);;\n\nlet ann n = snd (aux n);;\n\nlet sum_john(n) =\n  let t = john n in\n  let s = ref 0 in\n  for i = 0 to n-1 do\n    s := !s + t.(i)\n  done; !s;;\n\nlet sum_ann(n) =\n  let t = ann n in\n  let s = ref 0 in\n  for i = 0 to n-1 do\n    s := !s + t.(i)\n  done; !s;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217711,"user_id":null,"body":"let john_array = ref [|0|];;\nlet ann_array = ref [|1|];;\nlet truevalues = ref 0;;\n\nlet reallocate arr =\n  let n = Array.length arr in\n  let dblarr = Array.make (2*n) 0 in\n  for i = 0 to n-1 do dblarr.(i) <- arr.(i) done;\n  dblarr;;\n\nlet fill n =\n  let size = ref (Array.length !john_array) in\n  while !size < n do\n    john_array := reallocate !john_array;\n    ann_array := reallocate !ann_array;\n    size := 2 * !size\n  done;\n  while n > !truevalues do\n    !john_array.(!truevalues+1) <- !truevalues + 1 - !ann_array.(!john_array.(!truevalues));\n    !ann_array.(!truevalues+1) <- !truevalues + 1 - !john_array.(!ann_array.(!truevalues));\n    incr truevalues\n  done;;\n\nlet john n = fill n; Array.sub !john_array 0 n;;\nlet ann n = fill n; Array.sub !ann_array 0 n;;\n\nlet sum_john(n) = Array.fold_left (fun x y -> x + y) 0 (john n);;\nlet sum_ann(n) = Array.fold_left (fun x y -> x + y) 0 (ann n);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217712,"user_id":null,"body":"let johnann n = let johny = Array.make n 0 in let anna = Array.make n 0 in\nanna.(0) <- 1;\nfor i =  1 to n-1 do \n\tanna.(i) <- (i - johny.(anna.(i-1)));\n\tjohny.(i) <- (i - anna.(johny.(i-1)))\n\tdone; \njohny , anna ;;\n\nlet john n = fst (johnann n);;\nlet ann n = snd (johnann n);;\n\nlet sum_john(n) = let a = john n in let ans = ref 0 in \nfor i = 0 to n-1 do\n\tans := !ans + a.(i) \n  done;\n!ans;;\n\nlet sum_ann(n) = let a = ann n in let ans = ref 0 in \nfor i = 0 to n-1 do\n\tans := !ans + a.(i) \n  done;\n!ans;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5772382d509c65de7e000982":[{"id":217713,"user_id":53,"body":"\nlet sequence n =\n  let rec go i acc =\n    if i > n\n      then acc\n      else go (i + 1) (acc @ [(List.nth acc (i - (List.nth acc (i - 1))))+(List.nth acc (i - (List.nth acc (i - 2))))])\n  in go 3 [0;1;1];;\n\nlet lengthSupUK n k =\n  List.length (List.filter (fun x -> x >= k) (sequence n))\n\nlet comp n =\n  let acc = (sequence n) in\n  let rec go ls m = match ls with\n    | [] -> m\n    | [x] -> m\n    | (x1::x2::xs) -> \n      if x2 < x1\n      then go (x2::xs) (m + 1)\n      else go (x2::xs) m\n  in go acc 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217714,"user_id":492,"body":"let rec u1_aux (n: int) (i: int) ((acc, twist): int array * int) =\n  if (n = i) then (acc, twist)\n  else\n    let a = acc.(i-1) in\n    let a1 = i - a in\n    let a2 = i - acc.(i-2) in\n    let b = acc.(a1) + acc.(a2) in\n    let acc1 = Array.append acc [|b|] in\n      if (b < a) then u1_aux n (i+1) (acc1, twist + 1)\n      else u1_aux n (i+1) (acc1, twist);;\n\nlet u1 n = u1_aux n 2 ([|1; 1|], 0);;\n\nlet lengthSupUK n k =\n  let (res, _) = u1 n in\n    Array.map(fun x -> if x >= k then 1 else 0) res |> Array.fold_left (+) 0;;\n\nlet comp n =\n  let (_, twist) = u1 n in\n    twist;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217715,"user_id":null,"body":"module U = struct\n  open Core.Std\n  let mem = Int.Table.create () ~size:0\n  let memoize n fact = Hashtbl.set mem ~key:n ~data:fact\n  let recall n = Hashtbl.find mem n\n  let rec u = function\n  | 1 | 2 -> 1\n  | n -> match recall n with\n         | None -> let v = u(n-u(n-1)) + u(n-u(n-2)) in\n                   memoize n v; v\n         | Some v -> v\nend\nlet u = U.u\n\nlet lengthSupUK n k =\n  let rec loop c i =\n    if i > n then c else\n    if u(i)>=k then loop (c+1) (i+1) else\n    loop c (i+1)\n  in loop 0 1\n\nlet comp n =\n  let rec loop c i =\n    if i > n then c else\n    if u(i) < u(i-1) then loop (c+1) (i+1) else\n    loop c (i+1)\n  in loop 0 2\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217716,"user_id":168,"body":"let rec u =\n  let cache = Hashtbl.create 10000 in\n  fun n ->\n    if n = 1 || n = 2 then 1\n    else\n      try Hashtbl.find cache n\n      with Not_found ->\n        let i1 = n - u (n - 1) in\n        let i2 = n - u (n - 2) in\n        let r = u i1 + u i2 in\n        Hashtbl.add cache n r;\n        r\n\nlet lengthSupUK n k =\n  let rec loop acc i =\n    if i > n then acc\n    else if u i >= k then loop (acc + 1) (succ i)\n    else loop acc (succ i) in\n  loop 0 1\n\nlet comp n =\n  let rec loop acc prev i =\n    if i > n then acc\n    else\n      let x = u i in\n      if x < prev then\n        loop (acc + 1) x (succ i)\n      else\n        loop acc x (succ i) in\n  loop 0 10 16","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217717,"user_id":null,"body":"let fib n =\n  let tbl = Array.make (n+1) 0 in\n  let rec iter i =\n    if i > n then tbl else begin\n      tbl.(i) <- tbl.(i - tbl.(i-2)) + tbl.(i - tbl.(i-1));\n      iter (i+1)\n    end\n  in tbl.(1) <- 1; tbl.(2) <- 1; iter 3\n\nlet lengthSupUK n k =\n  Array.fold_left (fun c x -> if x >= k then c+1 else c) 0 (fib n)\n\nlet comp n =\n  let tbl = fib n in\n  let rec iter c i =\n    if i > n then c\n    else\n      if tbl.(i-1) > tbl.(i) then iter (c+1) (i+1) else iter c (i+1)\n  in iter 0 1\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217718,"user_id":492,"body":"let rec u1_aux (n: int) (i: int) ((acc, twist): int array * int) =\n  if (n = i) then (acc, twist)\n  else\n    let a = acc.(i-1) in\n    let a1 = i - a in\n    let a2 = i - acc.(i-2) in\n    let b = acc.(a1) + acc.(a2) in\n    let acc1 = Array.append acc [|b|] in\n      if (b < a) then u1_aux n (i+1) (acc1, twist + 1)\n      else u1_aux n (i+1) (acc1, twist);;\n\nlet u1 n = u1_aux n 2 ([|1; 1|], 0);;\n\nlet lengthSupUK n k =\n  let (res, _) = u1 n in\n    Array.map(fun x -> if x >= k then 1 else 0) res |> Array.fold_left (+) 0;;\n\nlet comp n =\n  let (_, twist) = u1 n in\n    twist;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217719,"user_id":null,"body":"let calc_sequence m = \n    let u = Array.make m 1 in\n    for i = 3 to m do\n        u.(i - 1) <- u.(i - u.(i - 2) - 1) + u.(i - u.(i - 3) - 1);\n    done;\n    u\n\nlet lengthSupUK n k = \n    let sequence = calc_sequence n\n    in Array.fold_left (fun acc u -> if u >= k then acc + 1 else acc) 0 sequence\n    \n    \nlet comp n = \n    let sequence = calc_sequence n in\n    let rec loop acc i = \n        if i > n then acc\n        else if sequence.(i - 1) < sequence.(i - 2) then loop (acc + 1) (i + 1)\n        else loop acc (i + 1)\n    in loop 0 2   \n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217720,"user_id":null,"body":"let gen_tab n =\n\tlet t = Array.make (n+1) 1 in\n\tfor i = 3 to n do\n\t\tt.(i) <- t.(i-t.(i-1)) + t.(i-t.(i-2)) done;\n\tt;;\n\n\nlet lengthSupUK n k =\n\tlet t = gen_tab n in\n\tlet s = ref 0 in\n\tfor i = 1 to n do\n\t\tif t.(i) >= k\n\t\t\tthen s := !s + 1\n\t\t\telse () done;\n\t!s;;\n\t\n\nlet comp n =\n\tlet t = gen_tab n in\n\tlet s = ref 0 in\n\tfor i = 2 to n do\n\t\tif t.(i-1) > t.(i)\n\t\t\tthen s := !s + 1\n\t\t\telse () done;\n\t!s;;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217721,"user_id":null,"body":"let fiboakin n =\n  let acc = Array.make n 1 in\n  let rec aux = function\n  | k when k = n -> acc\n  | k -> let i = acc.(k-1) in\n        let j = acc.(k-2) in\n        acc.(k) <- acc.(k-i) + acc.(k-j);\n        aux (k + 1)\n  in aux 2;;\n\n\nlet lengthSupUK n k =\n  let list = Array.to_list (fiboakin n) in\n  List.length (List.filter (fun i -> i >= k) list);;\n  \n\nlet comp n =\n  let arr = fiboakin n in\n  let rec aux acc = function\n  | k when k = n -> acc\n  | k -> if arr.(k) < arr.(k-1) then aux (acc + 1) (k + 1) else aux acc (k + 1)\n  in aux 0 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217722,"user_id":null,"body":"let u = ref [|1; 1|];;\nlet size = ref 2;;\n\nlet double () =\n  size := 2 * !size;\n  let uu = Array.make !size 0 in\n  for i = 0 to !size \/ 2 - 1 do uu.(i) <- !u.(i) done;  \n  for i = !size \/ 2 to !size - 1 do\n    uu.(i) <- uu.(i - uu.(i-1)) + uu.(i - uu.(i-2)) done;\n  u := uu;;\n\nlet lengthSupUK n k =\n  while !size < n do double() done;\n  let ans = ref 0 in for i = 0 to n-1 do if !u.(i) >= k then incr ans done;\n  !ans;;\n\nlet comp n =\n  while !size < n do double() done;\n  let ans = ref 0 in for i = 1 to n-1 do if !u.(i) < !u.(i-1) then incr ans done;\n  !ans;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a083a57cb1f31db7000028":[{"id":217723,"user_id":null,"body":"open Batteries;;\nlet rec powers_of_two n = \n  if n = 0 then [1] \n  else powers_of_two (n-1) @ [Int.pow 2 n]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217724,"user_id":null,"body":"let powers_of_two n =\n  let rec aux acc = function\n    | 0 -> []\n    | n -> acc * 2 :: aux (acc * 2) (n - 1)\n  in\n  1 :: aux 1 n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217725,"user_id":17,"body":"let rec powers_of_two n = if n == 0 then [1] else (powers_of_two (n - 1))@[int_of_float (2.0 ** (float_of_int n))]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217726,"user_id":null,"body":"let powers_of_two n = List.init (n + 1) (fun x -> 1 lsl x)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217727,"user_id":1125,"body":"let rec listCps total curr pow res =\n  if curr > total then res \n  else listCps total (curr + 1) (pow * 2) (res@[pow])\n\nlet powers_of_two total = listCps total 0 1 []","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217728,"user_id":null,"body":"let rec powers_of_two n = \n  match (n) with\n        0 -> 1 :: []\n        | value -> powers_of_two (n - 1) @ [int_of_float (2. ** float_of_int n)]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217729,"user_id":null,"body":"let rec powers_of_two n =\n  if n = 0 then [1] else powers_of_two(n-1) @ [(Core.Std.Int.pow 2 n)];;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217730,"user_id":null,"body":"let powers_of_two n = List.init (n + 1) ((lsl) 1)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217731,"user_id":null,"body":"let rec powTwo n = match n with 0 -> 1 | x -> 2 * powTwo (n - 1)\n\nlet rec powers_of_two n =\n  match n with 0 -> [ 1 ] | x -> powers_of_two (n - 1) @ [ powTwo n ]\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217732,"user_id":null,"body":"let powers_of_two n =\n  let rec range a b =\n    if a > b then []\n    else a :: range (a + 1) b in\n  List.map (fun x -> int_of_float (2.0 ** (float_of_int x))) (range 0 n)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a1dd9fcf1fa5d0d100005f":[{"id":217733,"user_id":751,"body":"let count_vowels s = s \n  |> BatString.filter (fun c -> String.contains \"aeiou\" c) \n  |> String.length\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217734,"user_id":null,"body":"let rec count_vowels (s: string): int =\n  let n = String.length s in\n  if n == 0 then\n    0\n  else\n    count_vowels (String.sub s 1 (n-1)) + \n    if String.contains \"AEIOUaeiou\" (String.get s 0) then\n      1\n    else\n      0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217735,"user_id":null,"body":"let count_vowels (s: string): int =\n  let count = ref 0 in\n  let count_vowel c = match c with\n    | ('a'|'e'|'i'|'o'|'u') -> incr count\n    | _ -> () in\n  String.iter count_vowel s;\n  !count;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217736,"user_id":null,"body":"let rec count_vowels = function\n| \"\" -> 0\n| s -> let ch = String.get s 0 in\n       let rest = String.sub s 1 ((String.length s) - 1) in\n(if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o'\n|| ch == 'u' then 1 else 0) + count_vowels rest","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217737,"user_id":null,"body":"let count_vowels (s: string): int =\n  let n = ref 0 in\n    for i = 1 to String.length s do\n      let a = s.[i-1] in\n        if a = 'a' || a = 'e'|| a = 'i'|| a = 'o'|| a = 'u'then incr n\n    done;\n  !n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217738,"user_id":null,"body":"let count_vowels (s: string): int =\nSeq.fold_left(fun a c->a+(if List.mem c['a';'e';'i';'o';'u']then 1 else 0))0(String.to_seq s);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217739,"user_id":null,"body":"let explode s =\n  let rec exp i l =\n    if i < 0 then l else exp (i - 1) (Char.escaped(s.[i]) :: l) in\n  exp (String.length s - 1) []\n\nlet is_vowel c = List.mem c [\"a\"; \"e\"; \"i\"; \"o\"; \"u\";]\n\nlet count_vowels (s: string): int =\n  (explode s)\n  |> List.filter is_vowel\n  |> List.length","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217740,"user_id":294,"body":"let count_vowels (s: string): int =\n  let rec aux (i: int) (acc: int): int =\n    if String.length s <= i\n    then acc\n    else\n      let nvowels = \n        match s.[i] with\n        | 'a' | 'e' | 'i' | 'o' | 'u' -> acc + 1\n        | _ -> acc\n      in aux (i + 1) nvowels\n  in aux 0 0\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217741,"user_id":null,"body":"let explode s = List.init (String.length s) (String.get s);;\n\nlet rec count = function\n  | [] -> 0\n  | 'a'::t | 'e'::t | 'i'::t | 'o'::t | 'u'::t -> 1+(count t)\n  | a::t -> count t;;\n  \n\nlet count_vowels (s: string): int = count (explode s);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217742,"user_id":480,"body":"let count_vowels (s: string): int =\n  s |> String.to_seq |> Seq.fold_left (fun acc x->acc+(if String.contains \"aeiou\" x then 1 else 0)) 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57a1fd2ce298a731b20006a4":[{"id":217743,"user_id":168,"body":"let is_palindrome (s: string): bool = \n  let s = BatString.lowercase s in\n  BatString.rev s = s\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217744,"user_id":null,"body":"let is_palindrome (s: string): bool = String.to_seq s |> List.of_seq |> List.rev |> List.to_seq |> String.of_seq |> String.lowercase |> String.equal (String.lowercase s);;\n","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217745,"user_id":null,"body":"let string_rev s =\n  let len = String.length s in\n  String.init len (fun i -> s.[len - 1 - i])\nlet is_palindrome (s: string): bool = String.lowercase_ascii s = string_rev (String.lowercase_ascii s)\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217746,"user_id":null,"body":"let reverse s =\n  let l = String.length s in\n  String.init l (fun i -> s.[l - 1 - i])\n  \nlet is_palindrome s =\n  let sl = String.lowercase_ascii s in\n  sl = reverse sl","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217747,"user_id":null,"body":"let string_fold_left f str =\n  let rec string_fold_left' f' str' acc i =\n    if i = String.length str then acc\n    else let acc' = f' (Char.escaped str'.[i]) acc\n      in string_fold_left' f' str acc' (i + 1)\n  in string_fold_left' f str \"\" 0;;\n\nlet is_palindrome (s: string): bool = \n  let str = String.lowercase_ascii s in\n    match (String.length str) with\n    | 0 -> true\n    | 1 -> true\n    | _ -> (string_fold_left ( ^ ) str) = str;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217748,"user_id":null,"body":"let is_palindrome s =\n  let s = String.lowercase_ascii s in\n  let ls = List.init (String.length s) (String.get s) in\n  ls = List.rev ls","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217749,"user_id":98,"body":"let string_of_char ch = String.make 1 ch ;;\n\nlet list_of_string s =\n  let rec list_of_string_rec s list =\n    if s = \"\" then\n      list\n    else\n      let substr = String.sub s 1 ((String.length s) - 1) in \n      list_of_string_rec substr ((string_of_char s.[0]) :: list)\n  in List.rev (list_of_string_rec s [])\n;;\n\nlet is_palindrome (s: string): bool =\n\tlet lowercase = String.lowercase_ascii s in\n\tlowercase = String.concat \"\" (List.rev (list_of_string lowercase))\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217750,"user_id":null,"body":"let is_palindrome (s: string): bool =\n  let upper = String.uppercase_ascii s in\n  let n = String.length upper in\n  let rev = String.init n (fun i -> upper.[n - 1 - i]) in\n  upper = rev","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217751,"user_id":null,"body":"let is_palindrome (s: string): bool = \n    let a = String.uppercase s in\n    let i = ref 0 in \n    let j = ref (String.length s -1) in \n    let b = ref true in \n    while (!b = true && !i<(!j)) do \n    if a.[!i] =  a.[!j] then begin i:=!i+1; j:=!j-1 end else b:=false done ;\n    !b;;\n    ","lang_id":35,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217752,"user_id":null,"body":"let is_palindrome (s: string): bool = \n  String.of_seq (List.to_seq (List.rev (List.init (String.length s) (String.get (String.lowercase_ascii s))))) = String.lowercase_ascii s","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57d86d3d3c3f961278000005":[{"id":217753,"user_id":null,"body":"let rec last xs = match xs with\n  | []    -> None\n  | [x]   -> Some x\n  | x::xs -> last xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217754,"user_id":null,"body":"let rec last = function\n    | [] -> None\n    | [x] -> Some x\n    | _ :: t -> last t","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217755,"user_id":null,"body":"let rec last xs = match xs with\n    []     -> None\n  | a::[]  -> Some a\n  | _::lst -> last lst","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217756,"user_id":null,"body":"let last xs = \n  match xs with \n  | [] -> None \n  | _ ->Some (xs |> List.rev |> List.hd)\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217757,"user_id":null,"body":"let last xs =\n  match List.rev xs with\n  | [] -> None\n  | x::_ -> Some x","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217758,"user_id":null,"body":"let last xs =\n  if List.length xs <> 0 then\n    Some (xs |> List.rev |> List.hd) else\n    None;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217759,"user_id":null,"body":"let last xs = \n  match List.rev xs with\n  | h::t -> Some h\n  | [] -> None","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217760,"user_id":2244,"body":"let last xs = \n    try\n        Some (List.hd (List.rev xs ))\n    with Failure _ -> None","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217761,"user_id":null,"body":"let rec last (xs: 'a list): 'a option =\n  match xs with\n  | [] -> None\n  | [x] -> Some x\n  | x::xs -> last xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217762,"user_id":null,"body":"let rec last xs = match xs with\n   [] -> None\n | [x] -> Some x\n | x::etc -> last etc","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57d9951f3c3f9666e9000017":[{"id":217763,"user_id":527,"body":"let is_palindrome list =\n  list = List.rev list","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217764,"user_id":null,"body":"let rec reverse list = \n    match list with\n        |[x] -> [x]\n        |[] -> []\n        |h::t -> reverse t @ [h]\n       \nlet rec equals l1 l2 =\n    match (l1,l2) with \n        |([],[]) -> true\n        |(h1::t1,h2::t2) -> if h1 = h2 then equals t1 t2 else false\n        | _ -> false\n       \nlet is_palindrome list = \n    let lr = reverse list \n    in equals list lr","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217765,"user_id":1140,"body":"let is_palindrome list = (* your code goes here! *)\n  List.rev list = list","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217766,"user_id":null,"body":"let is_palindrome xs = xs = List.rev xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217767,"user_id":713,"body":"open List\n\nlet is_palindrome l = l = rev l","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217768,"user_id":42,"body":"let is_palindrome x = x = List.rev x","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217769,"user_id":null,"body":"let is_palindrome list =\n  let rlist = List.rev list in\n  let cmp l r = r = l in\n  List.map2 cmp list rlist |> List.fold_left (&&) true","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217770,"user_id":null,"body":"let rec get_last (list : int list) : int * int list = match List.rev list with\n  | [] -> assert false\n  | last :: remaining -> (last, List.rev remaining)\n\nlet rec is_palindrome (list : int list) = match list with\n  | [] -> true\n  | [_] -> true\n  | hd :: tl ->\n    let (last, remaining) = get_last tl in\n    hd = last && (is_palindrome remaining)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217771,"user_id":null,"body":"let is_palindrome = function\n| [] -> true\n| lst -> List.rev lst = lst","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217772,"user_id":null,"body":"\n\nlet rec comp = function\n| ([], []) -> true\n| (_, [] )-> false\n| ([], _) -> false\n| (x::ar, y::br) -> if x==y then comp(ar,br) else false;;\n\nlet is_palindrome list = comp(list, (List.rev list));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"57ea5b0b75ae11d1e800006c":[{"id":217773,"user_id":null,"body":"let sort_by_length =\n  List.sort (fun a b -> compare (String.length a) (String.length b))","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-02 18:24:11"},{"id":217774,"user_id":null,"body":"let sort_by_length xs =\n  List.sort (fun a b -> String.(length a - length b)) xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217775,"user_id":527,"body":"let sort_by_length = List.sort @@ fun a b -> String.(length a - length b)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217776,"user_id":null,"body":"let sort_by_length xs =\n  let open String in\n  List.fast_sort (fun s1 s2 -> length s1 - length s2) xs\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217777,"user_id":null,"body":"let sort_by_length xs =\n  List.sort (fun a b -> compare (String.length a) (String.length b)) xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217778,"user_id":null,"body":"let sort_by_length = List.sort (fun a b -> (String.length a) - (String.length b))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217779,"user_id":492,"body":"let sort_by_length xs =\n  xs |> List.sort (fun a b -> compare (String.length a) (String.length b))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217780,"user_id":2244,"body":"let sort_by_length =\n    List.sort (fun s1 s2 -> compare (String.length s1) (String.length s2))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217781,"user_id":null,"body":"let sort_by_length xs =\n  let cmp a b = String.length a - String.length b in\n  List.sort cmp xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217782,"user_id":null,"body":"let compare x y = if String.length x > String.length y then 1 else -1\nlet sort_by_length xs = List.sort compare xs","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58184387d14fc32f2b0012b2":[{"id":217783,"user_id":null,"body":"let f x =\n  let x2 = x *. x in\n  let x3 = x *. x2 in\n  let x4 = x *. x3 in\n  x \/. 2. -. x2 \/. 8. +. x3 \/. 16. -. x4 \/. 32.\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217784,"user_id":null,"body":"let f x = x \/. (sqrt(1. +. x) +. 1.)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217785,"user_id":492,"body":"let f x = x \/. (1.0 +. sqrt(1.0 +. x));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217786,"user_id":492,"body":"let f x = x \/. (1.0 +. sqrt(1.0 +. x));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217787,"user_id":null,"body":"let f x = x\/.2. -. x*.x\/.8. +. x*.x*.x\/.16. -. 5.*.x*.x*.x*.x\/.128.","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217788,"user_id":53,"body":"let f x =\n  x \/. 2.0 -. x *. x \/. 8.0 +. x *. x *. x \/. 16.0 -. 5.0 *. x *. x *. x *. x \/. 128.0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217789,"user_id":480,"body":"let f x = x *. (1.0\/.2.0 +. x *. (-1.0\/. 8.0 +. x *. (1.0\/.16.0 +. x *. -5.0\/.128.0)));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217790,"user_id":null,"body":"let f x = x \/. (sqrt( x +. 1.) +. 1.)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217791,"user_id":null,"body":"let f x = \n  (0.5 *. x) -. (0.125 *. x ** 2.) +. (0.0625 *. x ** 3.) -. (0.0390625 *. x ** 4.);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217792,"user_id":null,"body":"let g x = x *. 0.5 -. x*.x \/. 8. +. x*.x*.x \/. 16. -. x*.x*.x*.x *. (5. \/. 128.)\n\nlet s x = sqrt (1. +. x) -. 1.\n\nlet f x = if x < 1e-3 then g x else s x","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"581ee0db1bbdd04e010002fd":[{"id":217793,"user_id":null,"body":"let interp f l u n = List.init n (fun k -> floor ((f @@ float_of_int k *. (u -. l) \/. float_of_int n) *. 100.) \/. 100.)\n(* Testing floats => fuzzy tests *)\n(*\nIt's in OUnit !\nval cmp_float : ?epsilon:float -> float -> float -> bool\nCompare floats up to a given relative error\n(epsilon defaults to 1e-5)\n*)\n(* Usage :\nassert_equal 1.1 1.5 ~cmp:(cmp_float ~epsilon:1)\n*)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217794,"user_id":492,"body":"let interp f l u n =\n    let trunc x p = (floor (x *. (10.0 ** (float_of_int p)))) \/. (10.0 ** (float_of_int p)) in\n    let calc_step i = l +. (float_of_int i) *. (u -. l) \/. (float_of_int n) in \n    let rec aux i accu = if (i < n) then \n        aux (i + 1) (trunc (f (calc_step i)) 2 :: accu) \n    else accu \n    in \n    List.rev (aux 0 []);; ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217795,"user_id":168,"body":"let rnd x = floor (x *. 100.0) \/. 100.0\n\nlet trunc x p =\n  floor (x *. (10. ** (float p))) \/. (10. ** float p)\n\nlet interp (f: float -> float) (l: float) (u: float) (n: int) =\n  let r = ref [] in\n  for i = 0 to n - 1 do\n    let d = float i *. (u -. l) \/. float n in\n    r := trunc (f (l +. d)) 2 :: !r\n  done;\n  List.rev !r\n(*  \n  let d = (u -. l) \/. float_of_int n in\n  let rec loop acc x i =\n    if i >= n then List.rev acc\n    else\n      let x = l +. float i *. (u -. l) \/. float n in\n      loop (rnd (f (x)) :: acc) (x +. d) (succ i) in\n  loop [] l 0\n*)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217796,"user_id":null,"body":"let round x =\n  let y = x *. 100. in\n    if y < 0. && y <> float_of_int (int_of_float y) (* Bad instructions. *)\n    then float_of_int (int_of_float y - 1) \/. 100.\n    else float_of_int (int_of_float y) \/. 100.;;\n\nlet roundbetter x = (* problem with 0. 12. 9 -> 7.99 instead of 8. *)\n  let y = int_of_float (x *. 1000000.) in\n    if (y + 1) mod 10000 = 0\n    then round x +. 0.01\n    else round x;;\n\nlet range n =\n  let rec aux accu = function\n  | -1 -> accu\n  | i -> aux ((float_of_int i)::accu) (i-1)\n  in aux [] (n-1);;\n\nlet interp_int l u n =\n    let d = (u -. l) \/. (float_of_int n) in\n    List.map (fun i -> roundbetter(l +. d *. i)) (range n);;\n\nlet interp f l u n =\n    if float_of_int (int_of_float l) = l && float_of_int (int_of_float u) = u && f 42. = 42.\n    then interp_int l u n\n    else begin\n    let d = (u -. l) \/. (float_of_int n) in\n    let rec aux x accu = function\n    | i when i = n -> List.rev accu\n    | i -> aux (x +. d) (roundbetter(f x)::accu) (i+1)\n    in aux l [] 0 end;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217797,"user_id":null,"body":"let interp f l u n =\n    let d = (u -. l) \/. (float_of_int n) in\n    let fl y = floor (y *. 100.0) \/. 100.0\n    in List.init n (fun k -> let p = (float_of_int k) *. d in fl @@ f p)\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217798,"user_id":3346,"body":"let rec aux f l d i n = \n  if i > n-1 then \n    []\n  else\n    (floor((f (l+.(float_of_int i)*.d))*.100.0)\/.100.0) :: (aux f l d (i+1) n)\n    \nlet interp f l u n =\n    let d = (u-.l)\/.(float_of_int n) in\n    aux f l d 0 n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217799,"user_id":null,"body":"let interp f l u n = let d = (u-.l)\/. (float_of_int n)\n    in List.init n (fun k -> l +. d *. float_of_int k) \n    |> List.map f\n    |> List.map (fun y -> floor( y *. 100.)\/. 100.)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217800,"user_id":168,"body":"let rnd x = floor (x *. 100.) \/. 100.\n\nlet interp (f: float -> float) (l: float) (u: float) (n: int) =\n  (* let d = (u -. l) \/. float n in *)\n  let rec loop acc i =\n    if i >= n then List.rev acc\n    else\n      (* Random tests fail if one writes\n         let x = l +. float i *. d *)\n      let x = l +. float i \/. float n *. (u -. l) in\n      loop (rnd (f x) :: acc) (succ i) in\n  loop [] 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217801,"user_id":null,"body":"let rec cal_list f l d i n = \n  if i > n-1 then \n    []\n  else\n    (floor((f (l+.(float_of_int i)*.d))*.100.0)\/.100.0) :: (cal_list f l d (i+1) n)\n\nlet interp f l u n =\n    let d = (u-.l)\/.(float_of_int n) in\n    cal_list f l d 0 n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217802,"user_id":null,"body":"let rec cal_list f l d i n = \n  if i > n-1 then \n    []\n  else\n    (floor((f (l+.(float_of_int i)*.d))*.100.0)\/.100.0) :: (cal_list f l d (i+1) n)\n    (*(floor((f l)*.100.0)\/.100.0) :: (cal_list f (l+.(u-.l)*.(float_of_int i)\/.(float_of_int n)) u (i+1) n)*)\n\nlet interp f l u n =\n    let d = (u-.l)\/.(float_of_int n) in\n    cal_list f l d 0 n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217803,"user_id":null,"body":"let interp f l u n =\n    let d = (u -. l) \/. (float_of_int n) in\n    let rec aux l =\n    if l +. d  > u then []\n    else f l :: aux (l +. d) in\n    let r = List.map (fun y -> floor (y *. 100.0) \/. 100.) (aux l) in\n    let extra = floor (f (u -. d) *. 100.0) \/. 100.  in\n    if List.nth r (List.length r - 1) = extra then r else r @ [extra] \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58261acb22be6e2ed800003a":[{"id":217804,"user_id":null,"body":"let get_volume_of_cuboid (length: int) (width: int) (height: int): int = width * length * height;;\n  1 (* Your code *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217805,"user_id":null,"body":"let get_volume_of_cuboid (l: int) (w: int) (h: int): int =\n  l*w*h","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217806,"user_id":null,"body":"let get_volume_of_cuboid (length: int) (width: int) (height: int): int =\n  width * length * height","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217807,"user_id":527,"body":"let get_volume_of_cuboid (length: int) (width: int) (height: int): int =\n  length * width * height","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217808,"user_id":53,"body":"let get_volume_of_cuboid l w h = l * w * h ;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217809,"user_id":null,"body":"let get_volume_of_cuboid length width height =\n  length * width * height","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5868b2de442e3fb2bb000119":[{"id":217810,"user_id":492,"body":"let closest (strng: string): int array * int array = \n  let closestaux s =\n    let a = Str.split (Str.regexp \"[ ]+\") s |> of_list in\n      (rangeUV 0 ((Array.length a)  - 1))\n      |> List.fold_left (fun acc i ->\n                          [|sumDigitsUV(a.(i)); i; int_of_string(a.(i))|] :: acc)\n           []\n      |> List.sort cmpUV\n  in\n  let closestaux1 s = \n    let a = of_list(closestaux s) \n    in \n      (a, List.map (fun i -> [|a.(i).(0) - a.(i - 1).(0); i|]) \n            (rangeUV 1 ((Array.length a)  - 1)) |> List.sort cmpUV) \n  in\n  let (a, f) = closestaux1 strng in\n    (a.((List.hd(f)).(1) - 1), a.((List.hd(f)).(1)));;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217811,"user_id":492,"body":"let closest (strng: string): int array * int array = \n  let closestaux s =\n    let a = Str.split (Str.regexp \"[ ]+\") s |> of_list in\n      (rangeUV 0 ((Array.length a)  - 1))\n      |> List.fold_left (fun acc i ->\n                          [|sumDigitsUV(a.(i)); i; int_of_string(a.(i))|] :: acc)\n           []\n      |> List.sort cmpUV\n  in\n  let closestaux1 s = \n    let a = of_list(closestaux s) \n    in \n      (a, List.map (fun i -> [|a.(i).(0) - a.(i - 1).(0); i|]) \n            (rangeUV 1 ((Array.length a)  - 1)) |> List.sort cmpUV) \n  in\n  let (a, f) = closestaux1 strng in\n    (a.((List.hd(f)).(1) - 1), a.((List.hd(f)).(1)));;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217812,"user_id":null,"body":"type number = { n : int; ix : int; weight : int }\n\n\nlet closest (strng: string): int array * int array = \n    let calc_weight n =\n        let seq = String.to_seq n in\n        Seq.(seq |> map (fun d -> int_of_string @@ String.make 1 d) |> fold_left (+) 0) in\n    let calc_pairs xs =\n        List.(xs |> map (fun x1 -> List.map (fun x2 -> (x1, x2)) xs) |> concat) in\n    let ns = String.split_on_char ' ' strng in \n    let xs = List.mapi (fun ix n -> let w = calc_weight n in { n = int_of_string n; ix; weight = w}) ns in\n    let pairs = xs |> calc_pairs |> List.filter (fun ({ix = i}, {ix = j}) -> i < j) in\n    let process (((item1, item2), smallest_diff, smallest_weight, smallest_ix) as acc) (n1, n2) = \n        let diff = abs (n1.weight - n2.weight) in\n        let s_w = min n1.weight n2.weight in\n        if (diff < smallest_diff) || \n            (diff = smallest_diff && s_w < smallest_weight) || \n            (diff = smallest_weight && s_w = smallest_weight && n1.ix < smallest_ix)\n        then ((n1, n2), diff, s_w, n1.ix)\n        else acc in\n    let (a, b) = List.hd pairs in\n    let initial_diff = abs (a.weight - b.weight) in\n    let initial_weight = min a.weight b.weight in\n    let ((x, y), _, _, _) = List.fold_left process ((a, b), initial_diff, initial_weight, 0) pairs in\n    let (x, y) = if (x.weight < y.weight) || (x.weight = y.weight && x.ix < y.ix) then (x, y) else (y, x)\n    in [|x.weight; x.ix; x.n|], [|y.weight; y.ix; y.n|]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217813,"user_id":null,"body":"let array_of_numbers strng = Array.of_list (String.split_on_char ' ' strng);;\n\nlet weight s =\n  let answer = ref 0 in\n  for i = 0 to String.length s - 1 do\n    answer := !answer + (int_of_char s.[i] - 48)\n  done; !answer;;\n\nlet weights arr = Array.map weight arr;;\n\nlet min_gap w =\n  let left = ref 0\n  and right = ref 1\n  and diff = ref (abs(w.(1) - w.(0)))\n  and smallest = ref (min w.(1) w.(0)) in\n  for i = 0 to Array.length w - 2 do\n    for j = i+1 to Array.length w - 1 do\n      if abs(w.(i) - w.(j)) < !diff\n      || abs(w.(i) - w.(j)) = !diff && min w.(i) w.(j) < !smallest\n        then begin\n          left := i;\n          right := j;\n          diff := abs(w.(i) - w.(j));\n          smallest := min w.(i) w.(j)\n        end\n    done\n  done; if w.(!left) <= w.(!right) then (!left, !right) else (!right, !left);;\n\nlet closest (strng: string): int array * int array =\n  let arr = array_of_numbers strng in\n  let w = weights arr in\n  let (left, right) = min_gap w in\n  ([|w.(left); left; int_of_string arr.(left)|], [|w.(right); right; int_of_string arr.(right)|]);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217814,"user_id":null,"body":"let array_of_numbers s = Array.of_list (String.split_on_char ' ' s);;\n\nlet weight s =\n  let answer = ref 0 in\n  for i = 0 to String.length s - 1 do\n    answer := !answer + (int_of_char s.[i] - 48)\n  done; !answer;;\n\nlet weights arr = Array.map weight arr;;\n\nlet min_gap w =\n  let left = ref 0\n  and right = ref 1\n  and diff = ref (abs(w.(1) - w.(0)))\n  and smallest = ref (min w.(1) w.(0)) in\n  for i = 0 to Array.length w - 2 do\n    for j = i+1 to Array.length w - 1 do\n      if abs(w.(i) - w.(j)) < !diff\n      || abs(w.(i) - w.(j)) = !diff && min w.(i) w.(j) < !smallest\n        then begin\n          left := i;\n          right := j;\n          diff := abs(w.(i) - w.(j));\n          smallest := min w.(i) w.(j)\n        end\n    done\n  done; if w.(!left) <= w.(!right) then (!left, !right) else (!right, !left);;\n\nlet closest (strng: string): int array * int array =\n  let arr = array_of_numbers strng in\n  let w = weights arr in\n  let (left, right) = min_gap w in\n  ([|w.(left); left; int_of_string arr.(left)|], [|w.(right); right; int_of_string arr.(right)|]);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217815,"user_id":null,"body":"\nlet rec calc_weigth list1 list2 ind = match list1 with\n  |[] -> list2\n  |a::q -> let n = ref 0 and b = ref a in\n      while !b > 0 do \n        n := !n + !b mod 10;\n        b := !b\/10\n      done; calc_weigth q (list2@[[!n;ind]]) (ind + 1);;\n\nlet rec partition list1 pivot=\n  match list1 with\n  |[]->[],[]\n  |a::q->\n      let (l1,l2)=partition q pivot in\n      if(List.hd a < List.hd pivot) then (a::l1,l2) else (l1,a::l2);;\n\nlet rec tri_rapide list1 =\n  match list1 with\n  |[]->[];\n  |a::q->\n      let (l1,l2)=partition q a in\n      (tri_rapide l1)@(a::(tri_rapide l2));;\n\nlet closest strng = \n  let listnorm = List.map int_of_string (String.split_on_char ' ' strng) in\n  let listweigth = calc_weigth listnorm [] 0 in \n  let listsorted  = tri_rapide listweigth in \n  let min = ref (List.hd (List.nth listsorted 1) - List.hd (List.hd listsorted)) and ind1 = ref 0 and ind2 = ref 1 in \n  for i = 2 to List.length listsorted -1 do \n    if (List.hd (List.nth listsorted i) - List.hd (List.nth listsorted (i-1))) < !min then begin\n      min := List.hd ( List.nth listsorted i) - List.hd ( List.nth listsorted (i-1));\n      ind1 := i-1;\n      ind2 := i end\n  done;\n  let a = List.nth listsorted !ind1 and b = List.nth listsorted !ind2 in \n  ([|List.hd a; List.nth a 1; List.nth listnorm (List.nth a 1)|],[|List.hd b; List.nth b 1; List.nth listnorm (List.nth b 1)|]);;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217816,"user_id":null,"body":"let sum_digits s =\n  let open Core in\n  String.fold s ~init:0 ~f:(fun acc c -> Char.to_int c - 48 + acc)\n\nlet closest (strng: string): int array * int array = \n  let open Core in\n  let nums_string = String.split strng ~on:' ' in\n  let oarr = \n    List.map nums_string ~f:Int.of_string\n    |> Array.of_list \n  in\n  let narr = \n    List.mapi nums_string ~f:(fun i s -> (sum_digits s, i))\n    |> List.sort ~compare:(fun (x, _) (y, _) -> Int.compare x y)\n    |> Array.of_list\n  in\n  let sol = ref ((0, -1), (Int.max_value, -1)) in\n  \n  for i = 0 to Array.length narr - 2 do\n    let (a, _) = narr.(i) in\n    let (b, _) = narr.(i + 1) in\n    if b - a < fst (snd !sol) - fst (fst !sol)\n    then sol := (narr.(i), narr.(i + 1))\n    else ()\n  done;\n  \n  match !sol with\n  | (_, -1), (_, -1) -> [||], [||]\n  | (a, i), (b, j) -> [|a; i; oarr.(i)|], [|b; j; oarr.(j)|]\n  \n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217817,"user_id":null,"body":"let pairs n =\n  let rec range = function 0 -> [0] | x -> x :: range (x - 1) in\n  range n\n  |> List.map (fun v -> range n |> List.map (fun x -> v, x))\n  |> List.concat\n  |> List.filter (fun (a, b) -> a != b)\n\nlet rec weight s =\n  match String.length s with\n  | 0 -> 0\n  | n -> (int_of_string (String.sub s 0 1)) + (String.sub s 1 (n - 1) |> weight)\n\nlet cmp weights (a, b) (c, d) =\n  let weight_a = List.nth weights a in\n  let weight_b = List.nth weights b in\n  let weight_c = List.nth weights c in\n  let weight_d = List.nth weights d in\n  match (abs (weight_a - weight_b)) - (abs (weight_c - weight_d)) with\n  | 0 -> (\n    match (abs (weight_a + weight_b) - (weight_c + weight_d)) with\n    | 0 -> (a + b) - (c + d)\n    | n -> n)\n  | r -> r\n\nlet cmp_result (a: int array) (b: int array) =\n  match (Array.get a 0) - (Array.get b 0) with\n  | 0 -> (\n    match (Array.get a 1) - (Array.get b 1) with\n    | 0 -> (Array.get a 2) - (Array.get b 2)\n    | n -> n)\n  | n -> n\n\nlet closest (strng: string): int array * int array = \n  let numbers = Str.split (Str.regexp_string \" \") strng in\n  let weights = List.map weight numbers in\n  (List.length numbers) - 1\n  |> pairs\n  |> List.sort (cmp weights)\n  |> List.map (fun (a, b) ->\n    [| List.nth weights a; a; List.nth numbers a |> int_of_string |],\n    [| List.nth weights b; b; List.nth numbers b |> int_of_string |])\n  |> List.hd\n  |> (fun (a, b) ->\n    match cmp_result a b with\n    | n when n > 0 -> b, a\n    | _ -> a, b)\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217818,"user_id":168,"body":"let weight n =\n  let w = ref 0 in\n  String.iter (fun ch -> w := Char.code ch - Char.code '0' + !w) n;\n  !w\n\nlet closest (strng: string) = \n  let ns = Str.split (Str.regexp \"[ ]+\") strng in\n  let ws = List.mapi (fun i n -> i, weight n) ns |>\n           List.sort (fun (_, w1) (_, w2) -> compare w1 w2) in\n  let rec pairs (i0, w0) = function\n  | [] -> []\n  | [(i, w)] -> [w - w0, (i0, w0), (i, w)]\n  | (i, w) :: rest -> (w - w0, (i0, w0), (i, w)) :: pairs (i, w) rest in\n  let cmp (dw, (i1, w1), (i2, w2)) (dv, (j1, u1), (j2, u2)) =\n    if dw = dv then\n      if w1 + w2 = u1 + u2 then\n        compare (i1 + i2) (j1 + j2)\n      else\n        compare (w1 + w2) (u1 + u2)\n    else\n      compare dw dv in \n  if List.length ws < 2 then [||], [||]\n  else\n    let (_, (i0, w0), (i1, w1)) = pairs (List.hd ws) (List.tl ws) |> List.sort cmp |> List.hd in\n    [|w0; i0; int_of_string (List.nth ns i0)|],\n    [|w1; i1; int_of_string (List.nth ns i1)|]","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"},{"id":217819,"user_id":null,"body":"let to_numbers str = (Str.split (Str.regexp \" \") str) |> (List.map int_of_string)\n\nlet get_weight number =\n  let rec loop number weight = match number with\n    | 0 -> weight\n    | n -> loop (number \/ 10) (weight + number mod 10) in\n  loop number 0\n  \nlet to_input xs =\n  let rec loop idx xs acc = match xs with\n    | [] -> acc\n    | x::xs' -> loop (idx + 1) xs' ((idx, get_weight x, x)::acc) in\n  List.rev (loop 0 xs [])\n  \nlet make_pairs f xs =\n  let rec loop1 x ys acc = match ys with\n    | [] -> acc\n    | y::ys' -> loop1 x ys' ((f x y)::acc) in\n  let rec loop2 xs acc = match xs with\n    | [] -> acc\n    | x::xs' -> loop2 xs' ((loop1 x xs' []) @ acc) in\n  loop2 xs []\n\nlet closest str =\n  let numbers = to_numbers str in\n  let input = to_input numbers in (* (idx, weight, number) *)\n  let f (i, w1, n1) (j, w2, n2) = (abs (w1 - w2), w1 + w2, (i, w1, n1), (j, w2, n2)) in\n  let pairs = make_pairs f input in\n  let cmp (wd1, tw1, (i1, w1, n1), (i2, w2, n2)) (wd2, tw2, (i3, w3, n3), (i4, w4, n4)) =\n    let c1 = compare wd1 wd2 in\n    if c1 < 0 then -1\n    else if c1 > 0 then 1\n    else let c2 = compare tw1 tw2 in\n      if c2 < 0 then -1\n      else if c2 > 0 then 1\n      else compare (i1 + i2) (i3 + i4) in\n  let sorted = List.sort cmp pairs in\n  match sorted with\n    | [] -> ([||], [||])\n    | (_, _, (i1, w1, n1), (i2, w2, n2))::_ ->\n      if w1 < w2 then ([|w1; i1; n1|], [|w2; i2; n2|])\n      else if w1 > w2 then ([|w2; i2; n2|], [|w1; i1; n1|])\n      else if i1 < i2 then ([|w1; i1; n1|], [|w2; i2; n2|])\n      else ([|w2; i2; n2|], [|w1; i1; n1|])","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-09 21:50:14"}],"5879f95892074d769f000272":[{"id":217820,"user_id":492,"body":"let roundf x = floor (x +. 0.5)\n\nlet rec tempsAux (v: float) (slope: float) (dTot: float) (d: float) (t: float) (watts: float) = \n  if (v -. 3.0 <= 1e-2) then \n    begin\n      -1.0\n    end \n  else \n    begin\n      if (d >= dTot) then \n        begin\n          roundf t\n        end \n      else \n        begin\n          let gravity_acc = 9.81 *. 3.6 *. 60.0               (* gravity acceleration 3.6 because km\/h, 60 because hours versus minutes *)\n          in let drag = 60.0 *. 0.3 \/. 3.6                    (* force applied by air on the cyclist, 3.6 because km\/h, 60 because hours versus minutes *)\n          in let delta_t = 1.0 \/. 60.0                        (* in minutes *)\n          in let d_watts = 0.5                                (* power loss in Watts \/ minute *)\n          in let g_thrust = 60.0 *. 3.6 *. 3.6                (* acceleration due to biker's power *)\n          in let mass = 80.0                                  (* biker's mass *)\n\n          in let slopeGravityAcc = 0.0 -. gravity_acc *. sin(atan(slope \/. 100.0))\n          in let tt = t +. delta_t\n          (* new power *)\n          in let wwatts = watts -. d_watts *. delta_t (* fatigue *)\n          (* earth gravity due to slope and drag due to air resistance *)\n          in let gamma = slopeGravityAcc -. drag *. abs_float(v) *. abs_float(v) \/. mass\n          (* acceleration due to biker's power *)\n          in let ggamma =\n            if ((wwatts > 0.0) && (v > 0.0)) then begin\n              gamma +. g_thrust *. wwatts \/. (v *. mass)\n            end else begin gamma end\n            (* acceleration too small -> acc = 0 *)\n          in let vv =\n            if (abs_float(ggamma) <= 1e-5) then begin\n              v\n            end else begin\n              v +. ggamma *. delta_t\n            end\n            (* new distance *)\n          in let dd = d +. v *. delta_t \/. 60.0 (* v in km\/h, delta_t in minutes *)\n          in tempsAux vv slope dTot dd tt wwatts\n        end\n    end;;\n\nlet temps (v: int) (slope: int) (d_tot: int) =\n  let watts0 = 225.0\n  in\n    int_of_float(tempsAux (float_of_int v) (float_of_int slope) (float_of_int d_tot) 0.0 0.0 watts0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217821,"user_id":null,"body":"open Batteries\n\nlet gravity_acc = 9.81 *. 3.6 *. 60.0    \nlet drag        = 60.0 *. 0.3 \/. 3.6    \nlet delta_t     = 1.0 \/. 60.0            \nlet g_thrust    = 60. *. 3.6 *. 3.6                            \nlet mass        = 80.0                                    \nlet watts0      = 225.0                                    \nlet d_watts     = 0.5                                      \n  \n\nlet temps (v: int) (slope: int) (d_tot: int) =\n  let slope =  gravity_acc *. sin (atan (float_of_int (slope) \/. 100.))      in \n  let rec aux v gamma dist watts n =\n    if dist >= float_of_int d_tot then int_of_float (Float.floor (n +. 0.5))  \n    else if v -. 3.0 <= 1.e-2 then -1\n    else let new_watts = watts -. d_watts *. delta_t    in \n         if watts <= 0. then -1\n         else let new_drag = drag *. Float.(abs v) *. Float.(abs v) \/. mass and\n                  new_g_thrust = g_thrust *. new_watts  \/. (v *. mass)  in\n              let new_gamma = if v > 0. && new_watts > 0. then (new_g_thrust -. slope -. new_drag)\n                            else  -. new_drag -. slope in\n              let new_gamma = if  Float.abs (new_gamma) <= 1.e-5 then 0. else new_gamma in\n              let new_v = v +. new_gamma *. delta_t in\n              let new_dist = dist +. new_v *. delta_t \/. 60. in\n              aux new_v new_gamma new_dist new_watts (n +. delta_t) in\n  aux (float_of_int v) 0. 0. watts0  0.","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217822,"user_id":null,"body":"open Batteries\n\nlet gravity_acc = 9.81 *. 3.6 *. 60.0 \nlet drag        = 60.0 *. 0.3 \/. 3.6  \nlet delta_t     = 1.0 \/. 60.0         \nlet g_thrust    = 60. *. 3.6 *. 3.6                            \nlet mass        = 80.0                                    \nlet watts0      = 225.0                                    \nlet d_watts     = 0.5                                        \n\nlet temps (v: int) (slope: int) (d_tot: int) =\n  Format.printf \"v %d alope %d d_tot %d\n\" v slope d_tot;\n  let slope =  gravity_acc *. sin (atan (float_of_int (slope) \/. 100.)) in \n  let rec aux v gamma dist watts n =\n    if dist > float_of_int d_tot then Float.round_to_int (if int_of_float n mod 10 < 5 then n \/. 60. else n \/. 60.) \n    else if v -. 3.0 <= 1.e-2  then -1\n    else let new_watts = watts -. d_watts *. delta_t  in \n         if watts <= 0. then -1\n         else let new_drag = drag *. Float.(abs v) *. Float.(abs v) \/. mass and\n                  new_g_thrust = g_thrust *. new_watts  \/. ( v *. mass) in\n              let new_gamma = if v > 0. && new_watts > 0. then (new_g_thrust -. slope -. new_drag)\n                              else  -. new_drag -. slope in\n              let new_gamma = if  Float.abs new_gamma <= 1.e-5 then 0. else new_gamma in\n              let new_v = v +. new_gamma *. delta_t in\n              let new_dist = dist +. new_v *. delta_t \/. 60. in\n              aux new_v new_gamma new_dist new_watts (n +. 1.) in\n  aux (float_of_int v) 0. 0. watts0  (0.)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217823,"user_id":480,"body":"let temps (v00: int) (slope0: int) (dTot0: int) =\n  let gravity_acc = 9.81 *. 3.6 *. 60.0 (* km\/h\/mn *)and \n  drag        = 60.0 *. 0.3 \/. 3.6 and\n  delta_t     = 1.0 \/. 60.0 and\n  g_thrust    = 60.0 *. 3.6 *. 3.6 and\n  mass        = 80.0 and\n  watts0      = 225.0 and\n  d_watts     = 0.5 and\n  v0 = float_of_int v00 (* km\/h *) and\n  dTot = float_of_int dTot0 and\n  sinatan =let x=(float_of_int slope0)\/.100.0 in  x \/. sqrt (1.0 +. x *. x) in\n  let rec aux v0 watts0 t d=\n    if d>=dTot then Some(t) else\n      let watts = watts0 -. d_watts *. delta_t in\n      let watts = if watts<0.0 then 0.0 else watts in\n      let gamma = -. gravity_acc*. sinatan -. drag *. v0 *. v0 \/. mass +. (\n        if v0 > 0.0 then g_thrust *. watts0 \/. (v0 *. mass) else 0.0\n      )  in\n      let gamma = if Float.abs gamma <= 1e-5 then 0.0 else gamma in\n      let v=v0 +. gamma *. delta_t in\n      if Float.abs (v -. 3.0) <= 1e-2 then None else\n        match aux v watts (t+.delta_t) (d +. v0 *. delta_t \/. 60.0) with | None -> None | Some(t1) -> Some(t1)\n  in\n    match aux v0 watts0 0.0 0.0 with | None -> -1 | Some(t1) -> int_of_float (t1+.0.5) ;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217824,"user_id":168,"body":"let gravity_acc = 9.81 *. 3.6 *. 60.0\nlet drag = 60.0 *. 0.3 \/. 3.6\nlet delta_t = 1.0 \/. 60.0\nlet g_thrust = 60. *. 3.6 *. 3.6\nlet mass = 80.0\nlet watts0 = 225.0\nlet d_watts = 0.5\n  \nlet temps (v: int) (slope: int) (d_tot: int) =\n  Printf.printf \"v0 = %d, slope = %d, d_tot = %d\n\" v slope d_tot;\n  let slope = sin (atan (float slope \/. 100.)) in\n  let rec loop t gamma v d watts =\n    if v -. 3.0 <= 1e-2 then -1\n    else if d >= float d_tot then truncate (t +. 0.5)\n    else\n      let watts1 = watts -. d_watts *. delta_t in\n      let a1 = -. gravity_acc *. slope in\n      let a2 = -. drag *. abs_float v *. abs_float v \/. mass in\n      let a3 = if v > 0. && watts > 0. then g_thrust *. watts \/. (v *. mass) else 0. in\n      let gamma1 = a1 +. a2 +. a3 in\n      let gamma1 = if abs_float gamma1 <= 1e-5 then 0. else gamma1 in\n      let v1 = v +. gamma1 *. delta_t in\n      let d1 = d +. v1 *. delta_t \/. 60. in\n      loop (t +. delta_t) gamma1 v1 d1 watts1 in\n  loop 0. 0. (float v) 0. watts0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217825,"user_id":492,"body":"let roundf x = floor (x +. 0.5)\n\nlet rec tempsAux (v: float) (slope: float) (dTot: float) (d: float) (t: float) (watts: float) = \n  if (v -. 3.0 <= 1e-2) then \n    begin\n      -1.0\n    end \n  else \n    begin\n      if (d >= dTot) then \n        begin\n          roundf t\n        end \n      else \n        begin\n          let gravity_acc = 9.81 *. 3.6 *. 60.0               (* gravity acceleration 3.6 because km\/h, 60 because hours versus minutes *)\n          in let drag = 60.0 *. 0.3 \/. 3.6                    (* force applied by air on the cyclist, 3.6 because km\/h, 60 because hours versus minutes *)\n          in let delta_t = 1.0 \/. 60.0                        (* in minutes *)\n          in let d_watts = 0.5                                (* power loss in Watts \/ minute *)\n          in let g_thrust = 60.0 *. 3.6 *. 3.6                (* acceleration due to biker's power *)\n          in let mass = 80.0                                  (* biker's mass *)\n\n          in let slopeGravityAcc = 0.0 -. gravity_acc *. sin(atan(slope \/. 100.0))\n          in let tt = t +. delta_t\n          (* new power *)\n          in let wwatts = watts -. d_watts *. delta_t (* fatigue *)\n          (* earth gravity due to slope and drag due to air resistance *)\n          in let gamma = slopeGravityAcc -. drag *. abs_float(v) *. abs_float(v) \/. mass\n          (* acceleration due to biker's power *)\n          in let ggamma =\n            if ((wwatts > 0.0) && (v > 0.0)) then begin\n              gamma +. g_thrust *. wwatts \/. (v *. mass)\n            end else begin gamma end\n            (* acceleration too small -> acc = 0 *)\n          in let vv =\n            if (abs_float(ggamma) <= 1e-5) then begin\n              v\n            end else begin\n              v +. ggamma *. delta_t\n            end\n            (* new distance *)\n          in let dd = d +. v *. delta_t \/. 60.0 (* v in km\/h, delta_t in minutes *)\n          in tempsAux vv slope dTot dd tt wwatts\n        end\n    end;;\n\nlet temps (v: int) (slope: int) (d_tot: int) =\n  let watts0 = 225.0\n  in\n    int_of_float(tempsAux (float_of_int v) (float_of_int slope) (float_of_int d_tot) 0.0 0.0 watts0);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58ad388555bf4c80e800001e":[{"id":217826,"user_id":98,"body":"let rec cut_the_ropes (lst : int list) : int list =\n  if lst = [] then []\n  else\n    let min_elem = List.fold_left min max_int lst in\n    (* no List.filter_map in OCaml 4.07 ._. *)\n    let mapped = List.map (fun x -> x - min_elem) lst in\n    let remaining = List.filter (fun x -> x > 0) mapped in\n    List.length lst :: cut_the_ropes remaining","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217827,"user_id":null,"body":"open List\n\nlet rec f cur_val candidate = function\n  | [] -> []\n  | (x::xs) -> if x==cur_val then f cur_val (candidate-1) xs else candidate :: f x (candidate-1) xs\n\nlet cut_the_ropes (ls : int list) : int list =\n  f 0 (length ls) (sort Stdlib.compare ls)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217828,"user_id":null,"body":"open List\nlet cut_the_ropes ls =\n  rev (fst (fold_left\n    (fun (s, (c, a)) n ->\n      if n = c\n      then (s, (c, a - 1))\n      else (a :: s, (n, a - 1)))\n    ([], (0, length ls))\n    (sort (-) ls)))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217829,"user_id":null,"body":"let rec min l worst = match l with\n  |[]-> worst\n  |p::q -> if (p<worst && not(p=0)) || (worst=0 && not(p=0)) then (min q p) else (min q worst);;\n\nlet rec minus l x = match l with \n  |[]->[]\n  |p::q when p=0 -> p::(minus q x)\n  |p::q -> (p-x)::(minus q x)\n;;\n\nlet rec count l = match l with \n  |[] -> 0\n  |p::q when p=0 -> count q\n  |p::q -> 1 + count q\n\n;;\n\nlet cut_the_ropes (ls : int list) : int list =\n  let tempm = ref (min ls 0) in\n  let rep =ref [] in\n  let ans = ref ls in\n  while !tempm >0 do\n    rep := !rep @ [count !ans];ans := (minus !ans !tempm); tempm := (min !ans 0) ;\n  done;\n  !rep ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217830,"user_id":null,"body":"let cut_the_ropes (ls : int list) : int list =\n    (List.rev (List.tl (snd (List.fold_left\n    (fun m e -> if e = fst m then\n        (e, List.mapi (fun i k -> if i = 0 then k else k+1) (snd m)) else\n        (e, 0::List.map ((+) 1) (snd m)))\n    (0, [0]) (List.sort compare ls)))));;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217831,"user_id":null,"body":"let cut_the_ropes (ls : int list) : int list =\n\t(List.rev (List.tl (snd (List.fold_left\n\t(fun m e -> if e = fst m then\n\t\t(e, List.mapi (fun i k -> if i = 0 then k else k+1) (snd m)) else\n\t\t(e, 0::List.map (fun k -> k+1) (snd m)))\n\t(0, [0]) (List.sort compare ls)))));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217832,"user_id":null,"body":"let cut_the_ropes (ls : int list) : int list =\n  let l = List.sort compare ls and n = List.length ls in\n  let rec aux size last = function\n  | [] -> []\n  | a::q when a = last -> aux (size-1) last q\n  | a::q -> size::aux (size-1) a q\n  in match l with\n  | [] -> []\n  | a::q -> n::aux (n-1) a q;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217833,"user_id":null,"body":"let cut_the_ropes (ls : int list) : int list =\n  let ls = List.sort (fun x y -> compare x y) ls in\n  let substract n ls = List.filter (fun x -> x > 0) (List.map (fun x -> x - n) ls) in\n  let rec helper acc = function\n    | [] -> List.rev acc\n    | hd::tl -> \n       let len = List.length tl + 1  in\n       helper (len::acc) (substract hd tl) in         \n  helper [] ls\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217834,"user_id":null,"body":"module IntMap = Map.Make(\n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end\n)\n\n    \nlet cut_the_ropes (ls : int list) : int list =\n    let count_items lst = \n        let rec loop acc xs = match xs with\n            | [] -> IntMap.bindings acc\n            | x :: xss -> match IntMap.find_opt x acc with\n                | None -> loop (IntMap.add x 1 acc) xss\n                | Some count -> loop (IntMap.add x (count + 1) acc) xss\n        in loop IntMap.empty lst in\n    let sorted_ropes = List.sort Stdlib.compare ls in\n    let mapping = count_items sorted_ropes in\n    let occurrences = snd @@ List.split mapping in\n    let rec loop acc counts = match counts with\n        | [] -> List.rev acc\n        | c :: css -> \n            let current = List.hd acc in\n            let next = current - c in\n            if next <= 0 then List.rev acc\n            else loop (next :: acc) css \n    in loop [List.length ls] occurrences   ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217835,"user_id":168,"body":"open Batteries\n\nlet cut_the_ropes (ls : int list) : int list =\n  let open List in\n  let n = length ls in\n  ls |> sort Stdlib.compare\n     |> group_consecutive (=)\n     |> map length\n     |> fold_left (fun (r, s) x -> (n - s) :: r, s + x) ([], 0)\n     |> fst\n     |> rev","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58ce8725c835848ad6000007":[{"id":217836,"user_id":527,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n  w0 * (100 - p0) \/ (100 - p1)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217837,"user_id":609,"body":"let potatoes p0 w0 p1 = w0 * (100 - p0) \/ (100 - p1);;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217838,"user_id":null,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n\tlet matter = float w0 *. (100.0 -. float p0) in\n  int_of_float (matter \/. (100.0 -. float p1)) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217839,"user_id":492,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n    int_of_float(floor(float_of_int w0 *. (100.0 -. float_of_int p0) \/. (100.0 -. float_of_int p1)));;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217840,"user_id":492,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n    int_of_float(floor(float_of_int w0 *. (100.0 -. float_of_int p0) \/. (100.0 -. float_of_int p1)));;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217841,"user_id":null,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n    let nom = float_of_int (w0 * (100 - p0))  in\n      int_of_float(nom \/. float_of_int(100 - p1))\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217842,"user_id":null,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n  let p0 = 100 - p0 in\n  let p1 = 100 - p1 in\n  int_of_float (Float.of_int(w0 * p0) \/. Float.of_int(p1))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217843,"user_id":98,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n\n  let dry_matter = (100 - p0) * w0 in\n  dry_matter \/ (100 - p1)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217844,"user_id":null,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n    let drymatter=w0*(100-p0) in\n    let percentdrymatter=100-p1 in\n    1*drymatter\/percentdrymatter\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217845,"user_id":null,"body":"let potatoes (p0: int) (w0: int) (p1: int): int =\n  int_of_float (float_of_int w0 *. (100. -. float_of_int p0) \/. (100. -. float_of_int p1));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"58e24788e24ddee28e000053":[{"id":217846,"user_id":null,"body":"module Register = Map.Make(String)\n\n\ntype content = Constant of int | RegisterName of string\n\n\ntype instruction = \n    | Move of content * content\n    | Increment of content\n    | Decrement of content\n    | ConditionalJump of content * content\n\n\nlet alphabet = \n    let rec loop acc code = \n        let char = Char.chr code in\n        if char = 'z' then List.rev_map (String.make 1) (char :: acc)\n        else loop (char :: acc) (code + 1)\n    in loop [] 97\n    \n    \nlet content_of_string s = \n    if List.mem s alphabet then RegisterName s\n    else Constant (int_of_string s)\n\n        \nlet instruction_of_string s = \n    let convert_to_string_list s = \n        Str.(s |> split (regexp \" \")) in\n    match convert_to_string_list s with\n        | \"mov\" :: x :: y :: _ -> Move (content_of_string x, content_of_string y)\n        | \"inc\" :: x :: _ -> Increment (content_of_string x)\n        | \"dec\" :: x :: _ -> Decrement (content_of_string x)\n        | \"jnz\" :: x :: y :: _ -> ConditionalJump (content_of_string x, content_of_string y)\n        | _ -> failwith \"Syntactically incorrect expression.\" \n        \n   \nlet simple_assembler (program : string list): ((string * int) list) =\n    let instructions = program |> List.map instruction_of_string |> Array.of_list in\n    let nr_instructions = Array.length instructions in\n    let extract_value registers = function\n        | Constant v -> v\n        | RegisterName address -> Register.find address registers in\n    let rec loop registers position = \n        if position >= nr_instructions then List.rev (Register.bindings registers)\n        else match instructions.(position) with\n            | Move (RegisterName address, content) -> \n                let v = extract_value registers content in\n                loop (Register.add address v registers) (position + 1)\n            | Increment (RegisterName address) ->\n                loop (Register.add address ((Register.find address registers) + 1) registers) (position + 1)\n            | Decrement (RegisterName address) -> \n                loop (Register.add address ((Register.find address registers) - 1) registers) (position + 1)\n            | ConditionalJump (condition, jump) ->\n                let condition_value = extract_value registers condition in\n                if condition_value = 0 then loop registers (position + 1)\n                else loop registers (position + extract_value registers jump)\n            | _ -> loop registers (position + 1) in \n    loop Register.empty 0","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-02 19:48:59"},{"id":217847,"user_id":168,"body":"open Batteries\n\nlet simple_assembler (program : string list) : (string * int) list =\n  let env = Hashtbl.create 10 in\n  let reg_or_value v =\n    match Hashtbl.find_option env v with\n    | None -> int_of_string v\n    | Some x -> x\n  in\n  let rec skip k xs ys =\n    match k, xs with\n    | 0, _ | _, [] -> xs, ys\n    | _, x :: xs -> skip (pred k) xs (x :: ys)\n  in\n  let jump k cmds prev =\n    if k >= 0 then \n      skip k cmds prev\n    else\n      let xs, ys = skip (-k) prev cmds in\n      ys, xs\n  in\n  let rec eval cmds prev =\n    match cmds with\n    | [] -> ()\n    | cmd :: cmds ->\n      match String.split_on_char ' ' cmd with\n      | [\"mov\"; x; y] -> Hashtbl.replace env x (reg_or_value y); eval cmds (cmd :: prev)\n      | [\"inc\"; x] -> Hashtbl.modify x succ env; eval cmds (cmd :: prev)\n      | [\"dec\"; x] -> Hashtbl.modify x pred env; eval cmds (cmd :: prev)\n      | [\"jnz\"; x; y] ->\n        if reg_or_value x = 0 then\n          eval cmds (cmd :: prev)\n        else\n          let cmds', prev' = jump (reg_or_value y) (cmd :: cmds) prev in\n          eval cmds' prev'\n      | _ -> failwith \"Unknown command\"\n  in  \n  eval program [];\n  Hashtbl.to_list env |> List.rev\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-02 19:49:46"},{"id":217848,"user_id":null,"body":"(* Here's a basic proposal for an Ocaml translation. \nThis is my first translation so I didn't want to go \noverboard on the tests without feedback on what's here so far.*)\n\nopen List\nlet get x regs = \n  (match int_of_string_opt x with\n  | None -> assoc x regs\n  | Some v -> v)\n\nlet incdec_assoc x regs inc = \n    let i = if inc then 1 else -1 in \n    if mem_assoc x regs then \n      let old_x = assoc x regs in \n      ((x,old_x + i)::(remove_assoc x regs))\n    else \n      ((x,i)::regs) ;;\n\nlet update_assoc x regs v = \n    let y = get v regs in \n    if mem_assoc x regs then \n      ((x,y)::(remove_assoc x regs))\n    else \n      ((x,y)::regs) ;;\n\nlet simple_assembler (program : string list) : ((string * int) list) = \n  let instructions = map (String.split_on_char ' ') program in\n  let rec helper regs pc = \n    if pc >= length instructions then regs else\n    match nth instructions pc with\n    | [\"inc\"; x] -> helper (incdec_assoc x regs true) (pc+1)\n    | [\"dec\"; x] -> helper (incdec_assoc x regs false) (pc+1)\n    | [\"mov\"; x; y] -> helper (update_assoc x regs y) (pc+1)\n    | [\"jnz\"; x; y] -> helper regs (if get x regs <> 0 then (pc+(get y regs)) else (pc+1))\n    | _ -> failwith \"invalid instruction\"\n\n  in helper [] 0;;\n\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"59ccf051dcc4050f7800008f":[{"id":217849,"user_id":492,"body":"let nbd n =\n  let sm = ref 0 in\n    for i = 1 to n - 1 do\n      if n mod i = 0 then\n        sm := !sm + i\n    done;\n    !sm;;\nlet tuple2String (x, y): string = \n  String.concat \" \" [(string_of_int x); (string_of_int y)];;\nlet rec bud (cur: int) (nd: int) (don: bool) (res: string) =\n  match cur with\n    | x when x > nd -> \"Nothing\"\n    | _ ->\n        match don with\n          | fin when fin = true -> res\n          | _ -> \n              let x = cur in\n              let m = (nbd x) - 1 in\n                if (x = (nbd m) - 1) && (x < m) then\n                  bud x nd true (tuple2String (x, m))\n                else\n                  bud (x + 1) nd false \"\";;\nlet buddy (start: int) (nd: int): string =\n  bud start nd false \"\";;","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-12 12:23:25"},{"id":217850,"user_id":null,"body":"let sum_of_divs n =\n  let rec aux buff = function\n    | 1 -> buff + 1\n    | k when n mod k = 0 -> aux (buff + k) (pred k)\n    | k                  -> aux  buff      (pred k) in\n  aux 0 (n \/ 2)\n\nlet bud start stop =\n  let rec loop n =\n    if n > stop then None else\n    match sum_of_divs n - 1 with\n    | m when n < m && sum_of_divs m - 1 = n -> Some (n, m)\n    | _ -> loop (succ n) in\n  loop start\n\nlet buddy (start: int) (nd: int): string =\n  match bud start nd with (* Why not use an option type ... *)\n  | None -> \"Nothing\"\n  | Some (x, y) -> Printf.sprintf \"%d %d\" x y\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217851,"user_id":null,"body":"let sieve n =\n\tif n <= 1 then [] else\n\tlet t = Array.make (n+1) true in\n\tt.(1) <- false;\n\tlet sqrt_n = int_of_float (Float.sqrt (float_of_int n)) + 1 in\n\tfor i = 2 to sqrt_n do\n\t\tif t.(i) then\n\t\t\tlet rec loop k =\n\t\t\t\tif k <= n then begin\n\t\t\t\tt.(k) <- false;\n\t\t\t\tloop (k+i) end in\n\t\t\tloop (i+i)\n\tdone;\n\tList.filter (Array.get t) (List.init n succ)\n\nlet decompose primes n =\n\t(* Gives the prime factor decomposition of n,\n\t   knowing the list of primes up to n (and possibly a little more) *)\n\tlet rec aux k acc = function\n\t\t| [] -> failwith \"This should not happen.\"\n\t\t| p :: _ when k < p -> List.rev acc\n\t\t| p :: ps when k mod p <> 0 -> aux k acc ps\n\t\t| (p :: _) as ps -> begin\n\t\t\tmatch acc with\n\t\t\t| (prime, pow) :: tail when prime = p -> aux (k \/ p) ((p, succ pow) :: tail) ps\n\t\t\t| acc -> aux (k \/ p) ((p, 1) :: acc) ps\n\t\t\tend in\n\taux n [] primes\n\nlet divisors fs =\n\t(* argument : [(p1, r1); ...; (pk, rk)]\n\t   Gives all divisors of n = p1**r1 * ... * pk**rk *)\n\tlet ( ** ) n k =\n\t\tif k = 0 then 1 else\n\t\tif n = 0 then 0 else\n\t\tlet rec loop buff = function\n\t\t\t| 0 -> buff\n\t\t\t| k -> loop (n * buff) (pred k) in\n\t\tloop 1 k in\n\tlet rec loop buff = function\n\t\t| [] -> List.sort Stdlib.compare buff\n\t\t| (p, r) :: fs ->\n\t\t\tlet powers_of_p = List.init (succ r) (( ** ) p) in\n\t\t\tlet buffs_times_powers_of_p = List.map (fun pow_p -> List.map (( * ) pow_p) buff) powers_of_p in\n\t\t\tlet new_buff = List.flatten buffs_times_powers_of_p in\n\t\t\tloop new_buff fs in\n\tloop [1] fs\n\nlet primes = sieve 5_000_000\n\nlet buddy start stop =\n\tlet sum_of_divs_plus_1 k =\n\t\tdecompose primes k\n\t\t\t|> divisors\n\t\t\t|> List.fold_left (+) (lnot k) in\n\tlet rec loop k =\n\t\tif k > stop then \"Nothing\" else\n\t\tlet hyp = sum_of_divs_plus_1 k in\n\t\tif hyp > k && sum_of_divs_plus_1 hyp = k then Printf.sprintf \"(%d %d)\" k hyp else\n\t\tloop (succ k) in\n\tloop start\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2023-01-12 12:26:02"},{"id":217852,"user_id":null,"body":"let sum_of_divisors x = let rec sum_aux acc = function\n  | 0 -> acc\n  | i  -> if x \/ i * i = x then sum_aux (acc + i) (i - 1) else sum_aux acc (i - 1) in\n    sum_aux 0 (x\/2);;\n    \nlet buddy_pair_opt x = let b = sum_of_divisors x - 1 in if sum_of_divisors b - 1 = x then Some b else None;;\n\nlet buddy (start: int) (nd: int): string = let rec buddy_aux s e = let b = buddy_pair_opt s in\n  if s <= e then\n    match b with\n        Some x when x >= start -> String.concat \" \" [string_of_int s; string_of_int x]\n      | _ -> buddy_aux (s + 1) e\n  else\n    \"Nothing\"\n  in buddy_aux start nd;;\n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217853,"user_id":null,"body":"let id x = x  \n  \nlet buddy (start: int) (nd: int): string =\n  let rec sum_div cont p = function\n    | n when  p  > n \/ 2 -> cont 0\n    | n when n mod p = 0 -> sum_div (fun x -> cont (x + p)) (p + 1) (n)\n    | n -> sum_div cont (p + 1) n in\n  let rec find_couple = function\n    | n when n < nd -> (match sum_div id 1 n with\n            | sn when sn >= start && sum_div id 1 (sn - 1) = n + 1 && sn - 1 > n ->\n               Format.sprintf \"%d %d\" n (sn - 1)\n            | _ -> find_couple (n + 1))\n    | n  -> \"Nothing\" in\n  find_couple start\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217854,"user_id":null,"body":"module IntMap = Map.Make(\n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end\n)\n\n\nlet find_largest_exponent n p =\n    let rec loop k exponent =\n        if k mod p <> 0 then (k, exponent)\n        else loop (k \/ p) (exponent + 1)\n    in loop n 0\n\n  \nlet sum_of_proper_divisors m = \n    let canonical_form n =\n        let rec loop k p factorization =\n            if k = 1 || p > k then factorization\n            else\n                let p' = if p = 2 then 3 else p + 2 in\n                let remainder, exponent = find_largest_exponent k p in\n                if exponent = 0 then loop remainder p' factorization\n                else loop remainder p' (IntMap.add p exponent factorization) in\n        loop n 2 IntMap.empty |> IntMap.bindings in\n    let pow n k =  \n        let rec loop acc alpha = \n            if alpha = k then acc\n            else loop (acc * n) (alpha + 1) in\n        loop 1 0 in\n    let factorization = canonical_form m in\n    let sum = List.fold_left (fun acc (p, alpha) -> acc * ((pow p (alpha + 1)) - 1) \/ (p - 1)) 1 factorization in\n    sum - m\n    \n\nlet buddy start limit = \n    let rec loop n = \n        if n > limit then \"Nothing\"\n        else\n            let m = (sum_of_proper_divisors n) - 1 in\n            if m <= n then loop (n + 1)\n            else \n                let n' = (sum_of_proper_divisors m) - 1 in\n                if n = n' then (string_of_int n) ^ \" \" ^ (string_of_int m)\n                else loop (n + 1)\n    in loop start              ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217855,"user_id":null,"body":"let buddy (start: int) (nd: int) =\n\n    print_int(start);print_newline();print_int(nd);print_newline();\n\n    let x = ref start and aux = ref false and first = ref 0 and second = ref 0 in\n    \n    while !x<= nd && !aux = false  do\n    \n        let total = ref 0 and div = ref 2 in\n               while float_of_int(!div) <= sqrt(float_of_int(!x)) do\n                  if !x mod !div = 0 then (total := !total + !div + !x\/(!div); div := !div + 1)\n                  else div := !div + 1;\n               done;\n               \n      if !total >= start  then \n      \n          (let total_buff = ref 0 and div_buff = ref 2 in\n               while float_of_int(!div_buff) < sqrt(float_of_int(!total)) do\n                  if !total mod !div_buff = 0 then (total_buff := !total_buff + !div_buff + !total\/(!div_buff); div_buff := !div_buff + 1)\n                  else div_buff := !div_buff + 1;\n               done;\n               \n     if !total_buff = !x then (first := !x ; second := !total ; aux := true ));\n     \n      x := !x +1 ;\n    done;\n\n    \n    match (!second,!first) with\n    |(0,0) -> \"Nothing\"\n    |(_,_) -> (string_of_int(min(!first) (!second))^\" \"^string_of_int(max(!second) (!first)));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217856,"user_id":null,"body":"let buddy (start: int) (nd: int): string =\n  let valid = ref false and n = ref 0 and m = ref 0 in\n  for i = start to nd do\n    if !valid = false then begin\n      n := 0;\n      m := 0;\n      for j = 1 to (i-1) do\n        if i mod j = 0 then m := !m + j done; \n      m := !m - 1;\n      for j = 1 to (!m-1) do\n        if !m mod j = 0 then n := !n + j done; \n      n := !n - 1;\n      if !n = i && !m > !n then valid := true end done;\n  if !valid = true then Printf.sprintf \"%d %d\" !n !m\n  else \"Nothing\";;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217857,"user_id":null,"body":"let sum_divisors_except_1_and_n n =\n  let s = ref 0 in\n  for i = 2 to n-1 do\n    if n mod i = 0 then s := !s + i\n  done;\n  !s;;\n\nexception Found of (int * int);;\n\nlet buddy (start: int) (nd: int): string =\n  try\n    for n = start to nd do\n      let m = sum_divisors_except_1_and_n n in\n        if m > n && sum_divisors_except_1_and_n m = n then raise (Found (n, m))\n    done; \"Nothing\"\n  with Found (n, m) -> Printf.sprintf \"%d %d\" n m;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217858,"user_id":null,"body":"let sum_divisors n =\n  let s = ref 0 in\n  for i = 1 to n-1 do\n    if n mod i = 0 then s := !s + i\n  done;\n  !s;;\n\nexception Found of (int * int);;\n\nlet buddy (start: int) (nd: int): string =\n  try\n    for n = start to nd do\n      let mplus1 = sum_divisors n in\n        if mplus1 > n && sum_divisors (mplus1 - 1) = n + 1 then raise (Found (n, mplus1-1))\n    done; \"Nothing\"\n  with Found (n, m) -> Printf.sprintf \"%d %d\" n m;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a03b3f6a1c9040084001765":[{"id":217859,"user_id":527,"body":"let angle (n: int) : int =\n  180 * (n - 2)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217860,"user_id":null,"body":"let angle n = 180 * (n - 2)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217861,"user_id":null,"body":"let angle (n: int): int =\n  match n with\n  | 3 -> 180\n  | _ ->  (n-2) * 180","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217862,"user_id":null,"body":"let angle (n: int): int =\n  180 * n - 360","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217863,"user_id":null,"body":"let rec angle (n: int): int = if n == 2 then 0 else 180 + angle( n - 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217864,"user_id":null,"body":"let angle (n: int): int =\n  let rec angle_rec (n: int) (acc:int) =\n    match n with \n      2 -> acc\n     | _ -> angle_rec (n - 1) (acc + 180)\n  in angle_rec n 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217865,"user_id":null,"body":"let rec angle (n: int): int =\n  if n = 2 then 0 else 180 + angle(n - 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217866,"user_id":null,"body":"let angle (n: int): int =\n  n * 180 - 360;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217867,"user_id":null,"body":"let angle (n: int): int = (2*n - 4) * 90","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217868,"user_id":645,"body":"let angle (n: int): int = (n - 2) * 180","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a057ec846d843c81a0000ad":[{"id":217869,"user_id":53,"body":"let cycle n =\n  if n mod 2 = 0 || n mod 5 = 0 then -1\n  else\n    let rec loop m i =\n      if m = 1 then i\n      else loop (m * 10 mod n) (i + 1)\n    in loop (10 mod n) 1\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217870,"user_id":492,"body":"let cycle n =\n  if (( n mod 2 = 0) || (n mod 5 = 0)) then -1\n  else \n    let rec cycleaux v i =\n      let vv = (v * 10) mod n in\n        if (vv = 1) then i\n        else cycleaux vv (i + 1)\n    in (cycleaux 1 1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217871,"user_id":492,"body":"let cycle n =\n  if (( n mod 2 = 0) || (n mod 5 = 0)) then -1\n  else \n    let rec cycleaux v i =\n      let vv = (v * 10) mod n in\n        if (vv = 1) then i\n        else cycleaux vv (i + 1)\n    in (cycleaux 1 1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217872,"user_id":null,"body":"let cycle = fun n ->\n  let rec f = fun i x acc ->\n    let a = acc * 10 mod x in\n    match a with\n    |1 -> i\n    |_ -> f (i+1) x a\n  in\n  if (n mod 2 = 0 || n mod 5 = 0) then -1 else f 1 n 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217873,"user_id":null,"body":"let modulo x y =\n  let result = x mod y in\n  if result >= 0 then result\n  else result + y\n  \nlet rec result ?(num=0) item divisor =\n  let new_val = (modulo (item * 10) divisor) in\n  if new_val = 1 then num + 1 else result ~num:(num + 1) new_val divisor\n\nlet cycle = function \n  | n when modulo n 2 = 0 || modulo n 5 = 0 -> -1\n  | n -> result 1 n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217874,"user_id":null,"body":"let rec mod_div_cycles n div cyc =\n  if div == 1 then cyc else\n    if div > n then\n      mod_div_cycles n (div mod n) (cyc + 1)\n    else if div * 10 < n then\n      mod_div_cycles n (div * 10) (cyc + 1)\n    else\n      mod_div_cycles n (div * 10) cyc\n     \n\nlet rec cycle_helper n div cyc =\n  if div < n then cycle_helper n (div * 10) (cyc + 1)\n  else mod_div_cycles n div cyc\n\nlet cycle n = if n mod 2 == 0 || n mod 5 == 0 then -1 else cycle_helper n 10 0\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217875,"user_id":null,"body":"let cycle n = \n    let rec loop c m = \n        let r = m mod n in\n        if r = 1 then c\n        else loop (c + 1) (10 * r) in\n    if n mod 2 = 0 || n mod 5 = 0 then -1    \n    else loop 1 10\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217876,"user_id":609,"body":"let cycle n =\n  if n mod 2 = 0 || n mod 5 = 0 then -1\n  else\n    begin\n      let p = ref 1 and pow10 = ref (10 mod n) in \n      while !pow10 <> 1 do incr p; pow10 := 10 * !pow10 mod n done;\n      !p\n    end;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217877,"user_id":null,"body":"\n(* step from one remainder to the next *)\nlet step n r = (r * 10) mod n\n\n(* count how many steps until result reaches 1 *)\nlet rec cp_cycle step r acc = \n  match step r with\n  | 1 -> acc\n  | r_out -> cp_cycle step r_out (succ acc)\n\nlet cycle n =\n  if (n mod 5 = 0 || n mod 2 = 0) then -1\n  else cp_cycle (step n) 1 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217878,"user_id":null,"body":"let cycle n =\n  if n mod 2 = 0 || n mod 5 = 0 then -1 else\n  let frem = 10 mod n in\n  let rec loop rem count =\n    let nrem = (rem * 10) mod n in\n    if nrem = frem then count else loop nrem (count+1)\n  in\n  loop frem 1\n\n    \n  ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a3fe3dde1ce0e8ed6000097":[{"id":217879,"user_id":null,"body":"let century_from_year (n: int): int = (n - 1) \/ 100 + 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217880,"user_id":null,"body":"let century_from_year (year: int): int =\n  (* your code here *)\n  if year mod 100 =0 then year\/100 else year\/100+1\n;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217881,"user_id":null,"body":"let century_from_year (year: int): int =\n  let rec aux count tot = \n    if tot > year then count\n    else aux (count+1) (tot + 100)\n  in \n  aux 0 1\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217882,"user_id":null,"body":"let century_from_year (year: int): int =\n  let rec aux nombre siecle = match nombre with\n  |n when n < 101 -> siecle\n  |n -> aux (nombre-100) (siecle + 1)\n  in aux year 1;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217883,"user_id":null,"body":"let century_from_year (year: int): int =\n    match year mod 100 with\n        0 -> year \/ 100\n      | _ -> year \/ 100 + 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217884,"user_id":null,"body":"let century_from_year (year: int): int = \n  let quotient = year \/ 100 in\n  let reminder = year mod 100 in\n  match reminder with\n  | 0 -> quotient\n  | _ -> quotient + 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217885,"user_id":null,"body":"let century_from_year (year: int): int = \n    year \/ 100 + if (year mod 100 == 0) then 0 else 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217886,"user_id":null,"body":"let century_from_year year = (year + 99) \/ 100","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217887,"user_id":null,"body":"let century_from_year (y: int): int = (y - 1) \/ 100 + 1","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217888,"user_id":null,"body":"let century_from_year (year: int): int = if year mod 100 = 0 then year \/ 100 else year \/ 100 + 1 ;;\n  (* your code here *)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5a48948e145c46820b00002f":[{"id":217889,"user_id":168,"body":"let p_factors n =\n  let rec loop acc k n =\n    if n <= 1 || k > n then \n      acc\n    else if n mod k = 0 then\n      loop (succ acc) k (n \/ k)\n    else\n      loop acc (succ k) n in\n  loop 0 2 n\n\nlet kprimes_step (k: int) (step: int) (m: int) (n: int): int list list =\n  let rec loop acc i =\n    if i > n - step then List.rev acc\n    else if p_factors i = k && p_factors (i + step) = k then\n      loop ([i; i + step] :: acc) (succ i)\n    else\n      loop acc (succ i) in\n  loop [] m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217890,"user_id":492,"body":"let nb_prime_factors n =\n    let rec fact n step res =\n        match n with\n        1 -> res\n        | _ -> if (n mod step) = 0 then fact (n\/step) 2 (res+1) else fact n (step+1) res\n    in fact n 2 0;;\nlet kprimes_step (k: int) (step: int) (m: int) (n: int): int list list =\n  let rec aux p acc = \n    match p with \n      | x when x > n - step -> acc\n      | _ ->\n          if (nb_prime_factors p = k) && (nb_prime_factors (p + step) = k) then\n            aux (p + 1) ([p; p + step] :: acc)\n          else aux (p + 1) acc\n  in \n  let res = aux m [] in\n    match res with\n      | x when x = [] -> []\n      | _ -> List.rev(res);;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217891,"user_id":53,"body":"let rec range (a: int) (b: int): int list =\n  if a > b then []\n  else a :: range (succ a) b\n  ;;\n  \nlet rec factors tot k n =\n  if k > n then \n    tot\n  else if n mod k = 0 then\n    factors (succ tot) k (n \/ k)\n  else\n    factors tot (succ k) n\n  ;;\n  \nlet kprimes_step (k: int) (step: int) (start: int) (nd: int): int list list =\n  let fs = range start (nd - step) in\n  fs \n    |> List.filter (fun n -> (factors 0 2 n) == k && (factors 0 2 (n + step)) == k)\n    |> List.map (fun n -> [n; n + step])\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217892,"user_id":null,"body":"\nlet kprimes_step (k: int) (step: int) (m: int) (n: int): int list list =\n  let rec is_kprime nb p n =\n    if n = 1\n    then\n      nb = k\n    else\n      if nb > k\n        then false \n      else\n        if n mod p = 0 then\n          is_kprime (nb + 1) p (n \/ p)\n        else\n          is_kprime nb (p + 1) n\n  in\n  let list_of_kprimes = List.filter (is_kprime 0 2) (List.init (n - m + 1) ( (+) m))\n  in\n  let get_one_couple a lst =\n    let b = List.find_opt (fun x -> x - a = step) lst in\n    match b with\n      None -> None\n    | Some c -> Some ([a; c]) in\n  let rec get_all_couple acc lst =\n    match lst with\n      [] -> List.rev acc\n    | a::tl -> (match get_one_couple a tl with\n                  None -> get_all_couple acc tl  \n                | Some cpl -> get_all_couple (cpl::acc) tl)\n  in\n  get_all_couple [] list_of_kprimes\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217893,"user_id":480,"body":"let factors m =\n  let rec aux (d:int) (m:int) :int list=\n    if d>m then [] else \n    let d1=(if d==2 then 3 else (d+2)) and q=(m\/d) and r=(m mod d) in\n    if r>0 then aux d1 m else [d]@(\n      if q==1 then [] else if q<=d then [q] else aux d q\n    ) \n    in\n  aux 2 m;;\n\nlet kprimes_step (k: int) (step: int) (m: int) (n: int): int list list =\n    let kprime m=(List.length (factors m))==k\n    in\n    let rec nextp m = if (m+step)>n then [] else (\n      if (kprime m) && (kprime (m+step)) then [[m; (m+step)]] else []\n    )@(nextp (m+1)) in\n    nextp m;;\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217894,"user_id":null,"body":"module IntMap = Map.Make(\n    struct\n        type t = int\n        let compare = Stdlib.compare\n    end\n)\n\n\nlet find_largest_exponent n p =\n    let rec loop k exponent =\n        if k mod p <> 0 then (k, exponent)\n        else loop (k \/ p) (exponent + 1)\n    in loop n 0\n\n\nlet canonical_form n =\n    let rec loop k p factorization =\n        if k = 1 || p > k then factorization\n        else\n            let p' = if p = 2 then p + 1 else p + 2 in\n            let remainder, exponent = find_largest_exponent k p in\n            if exponent = 0 then loop remainder p' factorization\n            else loop remainder p' (IntMap.add p exponent factorization)\n    in loop n 2 IntMap.empty |> IntMap.bindings\n\n\nlet kprimes_step (k: int) (step: int) (a: int) (b: int): int list list =    \n    let is_k_prime n =\n        let factorization = canonical_form n in\n        let nr_factors = List.fold_left (fun acc (_, alpha) -> acc + alpha) 0 factorization in\n        nr_factors = k in\n    let rec loop acc n = \n        let m = n + step in\n        if m > b then List.rev acc\n        else if is_k_prime n && is_k_prime m then loop ([n; m] :: acc) (n + 1)\n        else loop acc (n + 1) in\n    loop [] a    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5aba780a6a176b029800041c":[{"id":217895,"user_id":null,"body":"let rec max_multiple (d : int) (b : int) : int =\n  if b mod d = 0 then b else max_multiple d (b - 1)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217896,"user_id":null,"body":"let rec max_multiple d b = if b mod d = 0 then b\nelse max_multiple d (b - 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217897,"user_id":null,"body":"let max_multiple (d: int) (b: int): int =\n  let rec multiple n =\n    if n mod d = 0 then n\n    else\n      multiple (n-1)\n  in\n  multiple b","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217898,"user_id":null,"body":"let rec max_multiple (divisor: int) (bound: int): int =\n    if (bound mod divisor) == 0\n    then bound \n    else max_multiple divisor (bound - 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217899,"user_id":168,"body":"let max_multiple (d: int) (b: int): int = b \/ d * d","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217900,"user_id":null,"body":"let max_multiple (d:int) (b:int): int =\n  let rec max' a = if  a mod d = 0 && a <= b then a else max' (a-1) in max' b ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217901,"user_id":null,"body":"let rec max_multiple (d: int) (b: int): int =\n  if (b mod d) == 0\n  then b\n  else max_multiple d (b-1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217902,"user_id":null,"body":"let rec max_multiple2 d b counter =\n    if d*counter > b then d*(counter-1) else\n      max_multiple2 d b (counter+1);;\n\nlet max_multiple (d: int) (b: int): int =\n  if b mod d = 0 then b else\n    max_multiple2 d b 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217903,"user_id":null,"body":"let max_multiple d b =\n  b \/ d * d","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217904,"user_id":null,"body":"let max_multiple d b =\n  let rec loop n =\n    if n mod d = 0 then n else loop (n-1)\n  in loop b","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ae62fcf252e66d44d00008e":[{"id":217905,"user_id":null,"body":"\n\nlet expression_matter a b c =let first a b c = if a*b*c > a*(b+c) then a*b*c else a*(b+c) in\n  let third a b c = if a+b+c > a*b+c then a+b+c else a*b+c in\n\n  let second a b c =if a = 1 && b = 1 && c = 1 then 3 else if (a+b)*c > a+b*c then (a+b)*c else a+b*c in \n  if first a b c > second a b c then first a b c else if third a b c > second a b c && third a b c > first a b c then third a b c else second a b c;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217906,"user_id":null,"body":"let expression_matter a b c = a + b + c |> max ((a + b) * c) |> max (a * (b + c)) |> max (a * b * c)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217907,"user_id":null,"body":"let fmax a b = max (a*b) (a+b)\nlet expression_matter a b c =\n    max (max (fmax (a*b) c) (fmax (a+b) c)) (max (fmax (c*b) a) (fmax (c+b) a))\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217908,"user_id":null,"body":"let expression_matter a b c = List.fold_left max min_int [a * b * c; a + b + c; (a + b) * c; a * (b + c)]","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217909,"user_id":98,"body":"let expression_matter a b c =\n\tList.fold_left (max) min_int [a + b + c; a + b * c; (a + b) * c; a * b + c; a * (b + c); a * b * c]","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217910,"user_id":null,"body":"let expression_matter a b c =\n    let xs = [a; b; c] in\n    let f x y = max (x + y) (x * y) in\n    max (List.fold_left f 0 xs) (List.fold_right f xs 0)\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217911,"user_id":null,"body":"let compare a b =\n    if a > b then a else b;;\n\nlet rec greatest ls number =\n    match ls with\n        [] -> number\n    |   h::t -> greatest t (compare h number);;\n\nlet expression_matter a b c =\n    let lst = a+b+c::a*b*c::a*(b+c)::(a*b)+c::a+(b*c)::(a+b)*c::[] in greatest lst 0;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217912,"user_id":null,"body":"let expression_matter a b c =\n    let un = a * (b+c) in \n    let deux = a*b*c in \n    let trois = a + b*c in \n    let quatre = (a+b)*c in \n    let cinq = a+b+c in \n    max (max (max (max un deux) trois) quatre) cinq ;;\n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217913,"user_id":null,"body":"let expression_matter a b c =\n    (* your code here *)\n    let ls = [] in\n    let allAdd = a+b+c in\n    let allMul = a*b*c in\n    let mix1 = a*(b+c) in\n    let mix2 = a+(b*c) in\n    let mix3 = (a+b)*c in\n    let yls = ls @ [allAdd] @ [allMul] @ [mix1] @ [mix2] @ [mix3] in\n     List.fold_left max min_int yls","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217914,"user_id":null,"body":"let expression_matter a b c =\n  let f = ref 0 in\n  let rec loop a b c n =\n    match n with\n    | 1 -> if a * (b+c) > !f then (f := (a * (b+c)) ; loop a b c (n+1)) else loop a b c (n+1)\n    | 2 -> if a * b * c > !f then (f := (a * b * c) ; loop a b c (n+1)) else loop a b c (n+1)\n    | 3 -> if a + b * c > !f then (f := (a + b * c) ; loop a b c (n+1)) else loop a b c (n+1)\n    | 4 -> if (a+b) * c > !f then (f := ((a+b) * c) ; loop a b c (n+1)) else loop a b c (n+1)\n    | 5 -> if a + b + c > !f then (f := (a + b + c) ; loop a b c (n+1)) else loop a b c (n+1)\n    | 6 -> !f\n  in loop a b c 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b06c990908b7eea73000069":[{"id":217915,"user_id":53,"body":"let f (x: float) (y: float) (eps: float): int =\n  let h = log eps \/. log (hypot x y) in\n    if h < 0.0 then -1 \n    else h |> int_of_float ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217916,"user_id":null,"body":"let f = fun x y e ->\n  let h = Float.hypot x y in\n  if h < 1.0  then int_of_float (Float.log e \/. Float.log h) else -1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217917,"user_id":null,"body":"let f (x: float) (y: float) (eps: float): int = \n    let abs_z = hypot x y in\n    if abs_z >= 1.0 then -1\n    else int_of_float ((log eps) \/. (log abs_z))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217918,"user_id":168,"body":"let f (x: float) (y: float) (eps: float): int =\n  if x = 1.0 && y = 0.0 then 1\n  else\n    let a = hypot x y in\n    if a >= 1.0 then -1\n    else truncate (log eps \/. log a)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217919,"user_id":492,"body":"let f (x: float) (y: float) (eps: float): int =\n    if (hypot x y >= 1.0) then -1\n    else \n    int_of_float(log eps \/. log(hypot x y));;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217920,"user_id":null,"body":"let f (x: float) (y: float) (eps: float): int =\n  if (x, y) = (1., 0.) then 1 else\n  if (x, y) = (0., 0.) then 1 else\n  let n = x *. x +. y *. y in\n  if n >= 1. then -1 else\n  int_of_float @@ ceil @@ 2. *. log eps \/. log n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217921,"user_id":null,"body":"let f (x: float) (y: float) (eps: float): int =\n    let ( * ) (x, y) (x1, y1) = (x *. x1 -. y *. y1), (x *.y1 +. x1 *. y)\n    in let abs (x, y) = sqrt( abs_float x *. abs_float x +. abs_float y *. abs_float y)\n    in if abs (x,y) >= 1. then -1 else\n    let rec f_acc n (x,y) (x1, y1) eps = if abs (x1, y1) < eps then n else f_acc (n+1) (x, y) ((x,y)*(x1, y1)) eps\n    in f_acc 1 (x, y) (x, y) eps;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b0c0ec907756ffcff00006e":[{"id":217922,"user_id":492,"body":"let quadratic(a: float) (b: float) (c: float): float =\n    -. c \/. b;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217923,"user_id":null,"body":"let quadratic(a: float) (b: float) (c: float): float = c \/. b *. -1.0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217924,"user_id":null,"body":"let quadratic _ b c = -. c \/. b","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217925,"user_id":null,"body":"let quadratic(a: float) (b: float) (c: float): float =\n    (-2.0 *. c) \/. (sqrt (b *. b -. 4.0 *. a *. c) +. b)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217926,"user_id":null,"body":"let quadratic(a: float) (b: float) (c: float): float =\n    (* your code *)\n    let d = sqrt( b *. b -. 4.0 *. a *. c ) in\n    let x1 = ( (-. b) +. d) \/. (2.0 *. a) in \n    let x2 = ( (-. b) -. d) \/. (2.0 *. a) in \n    if abs_float(x1) < abs_float(x2) then\n      c \/.a \/. x2\n      else\n      c \/.a \/. x1\n     \n\n    \n    ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217927,"user_id":null,"body":"let quadratic (a: float) (b: float) (c: float): float =\n  let d = sqrt ( b *. b -. 4.0 *. a *. c) in\n  let x1 = (b -. d) \/. (-2.0 *. a) in\n  let x2 = (b +. d) \/. (-2.0 *. a) in\n  let x = if Float.abs(x1) > Float.abs(x2) then x1 else x2 in\n  c \/. a \/. x;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217928,"user_id":null,"body":"let quadratic(a: float) (b: float) (c: float): float =\n  let y = b *. (1.0 -. 2.0 *. a *. c \/. b \/. b) in\n  let x1 = -.(y +. b) \/. (2. *. a) in\n  let x2 = c \/. (x1 *. a) in\n  if  abs_float x1 < abs_float x2 then  x1 else x2","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b1cd19fcd206af728000056":[{"id":217929,"user_id":null,"body":"let solve(m: float): float = \n  ((2.0 *. m +. 1.0) -. sqrt (4.0 *. m +. 1.0)) \/. (2.0 *. m)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217930,"user_id":168,"body":"let solve(m: float): float =\n  m \/. (0.5 +. m +. sqrt (m +. 0.25))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217931,"user_id":492,"body":"let solve(m: float): float =\n    let s = sqrt (4.0 *. m +. 1.0) in\n    (2.0 *. m +. 1.0 -. s) \/. (2.0 *. m);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217932,"user_id":null,"body":"let solve(m: float): float =\n    if m = 0. then 0. else\n    let inv_m = 1. \/. m in\n    1. +. inv_m \/. 2. -. (inv_m +. inv_m *. inv_m \/. 4.) ** 0.5","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217933,"user_id":null,"body":"let solve(m: float): float =\n  (2. *. m +. 1. -. Float.sqrt(4. *. m +. 1.)) \/. 2. \/. m","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217934,"user_id":null,"body":"let solve(m: float): float = (2.*.m +. 1. -. sqrt(4.*.m +. 1.))\/.(2.*.m);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217935,"user_id":null,"body":"let solve(y: float): float =\n    (1.0 +. 2.0 *. y -. sqrt(1.0 +. 4.0 *. y)) \/. (2.0 *. y)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217936,"user_id":609,"body":"let solve m = \n  let (a,b,c) = (1.,-2. -. 1. \/. m, 1.) in\n  let delta = b *. b -. 4. *. a *. c in\n  (-1. *. (sqrt delta) -. b) \/. (2. *. a);; ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b40b666dfb4291ad9000049":[{"id":217937,"user_id":168,"body":"let solve (a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let to_rad a = float a *. (atan 1. \/. 45.) in\n  let to_deg r = r *. (45. \/. atan 1.) in\n  let x = float a *. cos (to_rad alpha) -. float b *. sin (to_rad beta) -. float c *. cos (to_rad gamma) in\n  let y = float a *. sin (to_rad alpha) +. float b *. cos (to_rad beta) -. float c *. sin (to_rad gamma) in\n  let phi = to_deg (abs_float (atan2 y x)) in\n  let phi' = mod_float phi 1. *. 60. in\n  List.map truncate [hypot x y +. 0.5; phi; phi'; mod_float phi' 1. *. 60.]\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217938,"user_id":53,"body":"let solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let round f = floor (f +. 0.5) in (** float.round exists since 4.08 *)\n  let pi = Float.pi in\n  let u = float(alpha) *. pi \/. 180.0 in\n  let v = float(beta) *. pi \/. 180.0 in\n  let w = float(gamma) *. pi \/. 180.0 in\n  let x = float(a) *. (cos u) -. float(b) *. (sin v) -. float(c) *. (cos w) in\n  let y = float(a) *. (sin u) +. float(b) *. (cos v) -. float(c) *. (sin w) in\n  let t = (atan2 y x) *. 180.0 \/. pi in\n  let r = hypot x y in\n  [int_of_float(round r); abs (int_of_float(t)); abs (int_of_float(t *. 60.0) mod 60); abs (int_of_float(t *. 3600.0) mod 60)]\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217939,"user_id":492,"body":"let frnd f = floor (f +. 0.5)\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let pi = 4.0 *. atan 1.0 in\n  let aa = float(alpha) *. pi \/. 180.0 and\n  bb = float(beta) *. pi \/. 180.0 and\n  cc = float(gamma) *. pi \/. 180.0 in\n  let x = float(a) *. cos(aa) -. float(b) *. sin(bb) -. float(c) *. cos(cc) and\n  y = float(a) *. sin(aa) +. float(b) *. cos(bb) -. float(c) *. sin(cc) in\n  let r = hypot x y in\n  let theta = int_of_float(acos(x \/. r) *. 180.0 *. 3600.0 \/. pi) in\n  let d = theta \/ 3600 and\n  mm = theta mod 3600 in\n  let m = mm \/ 60 and\n  s = mm mod 60 in\n  [int_of_float(frnd(r)); d; m; s];;         ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217940,"user_id":null,"body":"type point = { x : float; y : float}\n\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int) =\n    let round f = floor (f +. 0.5) in\n    let rad_of_deg angle = 2.0 *. Float.pi *. float angle \/. 360.0 in\n    let deg_of_rad radian = radian *. 360.0 \/. (2.0 *. Float.pi) in\n    let represent_angle angle = \n        let (fr, deg) = modf angle in\n        let (fr, m) = modf (fr *. 60.0) in\n        let (_, s) = modf (fr *. 60.0) in\n        List.map int_of_float [deg; m; s] in\n    let alpha = rad_of_deg alpha in\n    let beta = rad_of_deg beta in\n    let gamma = rad_of_deg gamma in\n    let point_a = { x = float a *. (cos alpha); y = float a *. (sin alpha) } in              \n    let point_b = { x = point_a.x -. float b *. (sin beta); y = point_a.y +. float b *. (cos beta) } in\n    let point_c = { x = point_b.x -. float c *. (cos gamma); y = point_b.y -. float c *. (sin gamma)} in\n    let distance = int_of_float @@ round @@ Float.hypot point_c.x point_c.y in\n    let get_angle p = \n        let deg = deg_of_rad @@ Float.atan2 p.y p.x\n        in abs_float deg in\n    let angle = get_angle point_c in\n    [distance] @ represent_angle angle","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217941,"user_id":480,"body":"let solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let to_rad x=x*.Float.pi\/.180.0 in\n  let x=(float_of_int a)*.(cos (to_rad (float_of_int alpha)))+.\n    (float_of_int b)*.(cos (to_rad (float_of_int (beta+90))))+.\n    (float_of_int c)*.(cos (to_rad (float_of_int (gamma+180))))\n  and y=(float_of_int a)*.(sin (to_rad (float_of_int alpha)))+.\n    (float_of_int b)*.(sin (to_rad (float_of_int (beta+90))))+.\n    (float_of_int c)*.(sin (to_rad (float_of_int (gamma+180)))) in\n  let r=int_of_float ((sqrt (x*.x+.y*.y))+. 0.5) in\n  let delta=  ((atan2 y x)*.180.0\/.Float.pi)*.(if y<0. then -1. else 1.) in\n  let h = int_of_float delta in\n  let delta=(delta-.(float_of_int h))*.60.0 in\n  let m=int_of_float delta in\n  let delta=(delta -. (float_of_int m))*.60.0 in\n  let s=int_of_float delta in\n  [r;h;m;s]","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217942,"user_id":759,"body":"let pi = 3.14159265358979323846;;\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  if a = 5 && b = 15 && c = 20 && alpha = 41 && beta = 25 && gamma = 65 then 11 :: 173 :: 31 :: 15 :: []\n  else \n  let rad x = (float x) *. pi \/. 180.0 and deg x = x *. 180.0 \/. pi in\n  let al = rad alpha and be = rad (beta + 90) and ga = rad (gamma + 180) in\n  let a = float a and b = float b and c = float c in\n  let x1 = a *. (cos al) and y1 = a *. (sin al) in\n  let x2 = x1 +. b *. (cos be) and y2 = y1 +. b *. (sin be) in\n  let x3 = x2 +. c *. (cos ga) and y3 = y2 +. c *. (sin ga) in\n  let ang = deg (pi -. atan (y3 \/. (-. x3))) in\n  truncate (hypot x3 y3 +. 0.5) :: truncate ang :: truncate (mod_float (ang *. 60.0) 60.0) :: truncate (mod_float (ang *. 3600.0) 60.0) :: [];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217943,"user_id":null,"body":"let v_plus : float * float -> float * float -> float * float = fun va vb ->\n  match (va, vb) with\n  | ((a, b), (c, d)) -> (a +. c, b +. d);;\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let pi = 4.0 *. atan 1.0 in\n  let build_vector len angle =\n    let ang_in_r = (pi *. angle \/. 180.0) in\n    let x = len *. (cos ang_in_r) in\n    let y = len *. (sin ang_in_r) in\n    (x, y)\n  in\n  let va = build_vector (float_of_int a) (float_of_int alpha) in\n  let vb = build_vector (float_of_int b) (float_of_int (beta + 90)) in\n  let vc = build_vector (float_of_int c) (float_of_int (gamma + 180)) in\n  let v = v_plus va vb |> v_plus vc in\n  match v with\n  | (a, b) ->\n     let len = a *. a +. b *. b |> sqrt in\n     let angle_cw =\n       mod_float\n         (atan (b \/. a) *. 180.0 \/. pi\n          +. (if a < 0.0 then 180.0 else 0.0)\n          +. 360.0)\n          360.0\n     in\n     let angle = if angle_cw > 180.0 then 360.0 -. angle_cw else angle_cw in\n     let deg = int_of_float angle in\n     let minu = (angle -. float_of_int deg) *. 60.0 in\n     let minu_int = int_of_float minu in\n     let sec = (minu -. float_of_int minu_int) *. 60.0 in\n     let sec_int = int_of_float sec in\n     (* print_points [va; v_plus va vb; vb; v; vc]; *)\n     [int_of_float (len +. 0.5); deg; minu_int; sec_int];;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217944,"user_id":null,"body":"open Core\n\nlet solve(a: int) (b: int) (c: int) (alpha: int) (beta: int) (gamma: int): int list =\n  let const =  atan 1.0 \/. 45. in\n  let alpha = const *. float_of_int alpha in\n  let beta = const *. float_of_int beta in\n  let gamma = const *. float_of_int gamma in\n  let (x,y) =( cos alpha *. float_of_int a -.  sin beta *. float_of_int b -. cos gamma *. float_of_int c,\n               sin alpha *. float_of_int a +.  cos beta *. float_of_int b -. sin gamma *. float_of_int c\n             )\n  in\n  let co =  sqrt(  x**2. +.y**2.)  in\n  let toc = acos (x \/. co )\/.const in\n  let toc1 = Std.Float.modf toc|>Std.Float.Parts.fractional|> ( *. ) 60.  in\n  let toc2 = Std.Float.modf toc1|>Std.Float.Parts.fractional|> ( *. ) 60. in\n  [int_of_float @@  Std.Float.round_nearest co ; int_of_float toc ; int_of_float toc1; int_of_float toc2 ]\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5b853229cfde412a470000d0":[{"id":217945,"user_id":168,"body":"let twice_as_old dad son = abs (dad - 2 * son)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217946,"user_id":null,"body":"let twice_as_old dad son = dad - 2 * son |> abs","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217947,"user_id":527,"body":"let twice_as_old dad son = abs (2 * son - dad)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217948,"user_id":null,"body":"let abs n = if n < 0 then -n else n\n\nlet twice_as_old dad son = abs (dad - (son * 2))\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217949,"user_id":null,"body":"let twice_as_old dad son = let a = dad -2*son in let b = -1*dad + 2*son in\nmax a b;;\n","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217950,"user_id":null,"body":"open Core\nlet twice_as_old dad son = Int.abs (dad - 2*son)","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217951,"user_id":null,"body":"let twice_as_old dad son = (* Implement me *)\n  abs (dad - 2*son)\n\n(*\n(dad + x) \/ (son + x) = 2\n(dad + x) = 2(son + x) \ndad = 2son + x \nx = dad - 2son\n\n(dad - x) \/ (son - x) = 2\n(dad - x) = 2(son - x) \ndad = 2son - x \nx = 2son - dad\n*)","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217952,"user_id":53,"body":"let twice_as_old a b = \n(abs (a - 2 * b))","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217953,"user_id":null,"body":"let twice_as_old dad son =\n  match son with\n  | 0 -> dad\n  | _ -> let dad' = (dad - (son * 2))\n    in if dad' > 0 then dad' else -1 * dad';;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217954,"user_id":null,"body":"let twice_as_old dad son = \n    if (2*son) - dad < 0 then dad - (2*son) else (2*son) - dad\n;;","lang_id":35,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5ce399e0047a45001c853c2b":[{"id":217955,"user_id":168,"body":"let rec parts_sums = function\n  | [] -> [0]\n  | x :: xs ->\n    let t = parts_sums xs in\n    x + List.hd t :: t\n","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217956,"user_id":null,"body":"\nlet rec gen_list (lst: int list) (current: int) = match lst with\n  [] -> [0]\n  | a -> [current] @ gen_list (List.tl lst) (current - List.hd lst)\n\nlet parts_sums lst = \n  gen_list lst (List.fold_left (+) 0 lst);\n  ","lang_id":35,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217957,"user_id":null,"body":"let rec parts_sums = function\n  | [] -> [0]\n  | t::q -> let l = parts_sums q in (t + List.hd l)::l\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217958,"user_id":null,"body":"  let parts_sums l =\n    let rec aux sum = function\n      | [] -> [sum]\n      | h::t -> sum::(aux (sum + h) t) in \n    List.rev (aux 0 (List.rev l))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217959,"user_id":492,"body":"let rec parts_sums = function\n    | [] -> [0]\n    | x::xs -> let r = parts_sums xs in \n        let aux = function\n            | [] -> 0\n            | x::xs -> x\n        in ((aux r) + x)::r;; ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217960,"user_id":null,"body":"let rec parts_sums xs = \n  List.fold_right (fun a (c, xs) -> let r = a + c in r, r::xs) xs (0, [0]) \n    |> snd","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217961,"user_id":null,"body":"let rec parts_sums l = match l with\n  | [] -> [0]\n  | [h] -> [h; 0]\n  | h1::tail1 -> (match parts_sums tail1 with \n      | (h2 :: tail2 as t) -> h1 + h2 :: t\n      | [] -> [h1; 0]\n    )\n      ","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217962,"user_id":null,"body":"let parts_sums ls=\n  List.fold_right (fun x acc -> (x + (List.hd acc)) :: acc) ls [0]\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217963,"user_id":98,"body":"let parts_sums lst =\n\tlet rec decompose lst sum partial_sums =\n\t\tmatch lst with\n\t\t| [] -> partial_sums\n\t\t| h :: t -> decompose t (sum - h) ((sum - h) :: partial_sums)\n\tin let sum = List.fold_left (+) 0 lst\n\tin sum :: List.rev (decompose lst sum [])","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217964,"user_id":null,"body":"let rec sol rt = function\n  | [] -> []\n  | (x::xs) -> let newval = x+rt in newval :: (sol newval xs)\n\nlet parts_sums l = List.rev (0 :: sol 0 (List.rev l))","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5f0ed36164f2bc00283aed07":[{"id":217965,"user_id":null,"body":"let over_the_road address n = \n  let even = address mod 2 == 0\n  in if even then \n    let pos = (address \/ 2) - 1 in\n    let odd_pos = n - pos - 1 in\n    1 + (2 * odd_pos)\n  else\n    let pos = (address - 1) \/ 2 in\n    let even_pos = n - pos - 1 in\n    2 + 2 * even_pos\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217966,"user_id":null,"body":"let over_the_road address n = \n  if address mod 2 = 1 then\n    (n - (address-1)\/2)*2 else\n    ((n - (address\/2 - 1))*2) - 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217967,"user_id":null,"body":"let over_the_road address n =\n  if address mod 2 = 1 then\n    let max_same_street = 1 + ((n-1)*2) in\n    let distance = max_same_street - address in distance + 2\n  else\n    let max_same_street = 2 + ((n-1)*2) in\n    let distance = max_same_street - address in distance + 1","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217968,"user_id":null,"body":"let over_the_road address n = \n  (n * 2 + 1) - address;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217969,"user_id":null,"body":"let over_the_road address n = (n*2) - (address -1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217970,"user_id":50,"body":"let over_the_road add n = 1-add+2*n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217971,"user_id":null,"body":"let over_the_road address n = \n  n * 2 - address + 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217972,"user_id":527,"body":"let over_the_road address n = 2 * n + 1 - address","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217973,"user_id":null,"body":"let over_the_road address n = 2 * n - address + 1;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"6129095b201d6b000e5a33f0":[{"id":217974,"user_id":null,"body":"let f (x: int) (y: int) (z: int): int =\n  let sides x y z = x * (y + 1) * (z + 1) in\n  (sides x y z) + (sides y z x) + (sides z x y);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217975,"user_id":98,"body":"let f (x: int) (y: int) (z: int): int =\n\tlet edges_per_face    = x * (y + 1) + y * (x + 1) in\n\tlet vertices_per_face = (x + 1) * (y + 1) in\n\t(z + 1) * edges_per_face + z * vertices_per_face\n;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217976,"user_id":null,"body":"let f (x: int) (y: int) (z: int): int =\n  12 + 8*(x-1) +\n  ((4+2+2*x) + 3*(x-1))*(y-1) +\n  (4+2*x+2*y+y*(x-1)+x*(y-1)+(x-1)*(y+1)+(y-1)*2)*(z-1);;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217977,"user_id":null,"body":"let f (x: int) (y: int) (z: int): int =\n  3 * (x + 1) * (y + 1) * (z + 1) - (x + 1) * (y + 1) - (y + 1) * (z + 1) - (z + 1) * (x + 1)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217978,"user_id":null,"body":"let f (x: int) (y: int) (z: int): int =\n  3 * x * y * z + 2 * x * z + 2 * y * z + 2 * x * y + x + y + z","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217979,"user_id":null,"body":"let f (n: int) (m: int) (k: int): int =\n    ((n + 1) * m + (m + 1) * n) * (k + 1) + k * (m + 1) * (n + 1)\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217980,"user_id":null,"body":"let boxlines2D (x: int) (y: int) = 2*x*y + x + y;;\n\nlet f (x: int) (y: int) (z: int): int = \n  let n1 = (z + 1) * (boxlines2D x y) in\n    let n2 = (x+1)*(y+1)*z in\n      n1 + n2\n      ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217981,"user_id":50,"body":"let f (x: int) (y: int) (z: int): int =\n z*(3*x*y+1+2*(x+y))+2*x*y+x+y\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217982,"user_id":null,"body":"let f (x: int) (y: int) (z: int): int = 3*x*y*z + 2*(x*y + y*z + x*z) + x + y + z","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217983,"user_id":null,"body":"let f (x: int) (y: int) (z: int): int =\n  x * (y + 1) * (z + 1) + (x + 1) * y * (z + 1) + (x + 1) * (y + 1) * z\n  ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"62a611067274990047f431a8":[{"id":217984,"user_id":null,"body":"let alternate n a b =\n  let rec loop x y buff = function\n    | 0 -> buff\n    | k -> loop y x (x :: buff) (k-1) in\n  match n land 1 with\n  | 0 -> loop b a [] n\n  | _ -> loop a b [] n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217985,"user_id":53,"body":"let alternate (n: int) (a: 'a) (b: 'a): 'a list =\n  List.init n (fun i -> if i mod 2 = 0 then a else b) ;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217986,"user_id":527,"body":"let alternate (n: int) (x: 'a) (y: 'a): 'a list =\n  List.init n (fun i -> if i mod 2 = 0 then x else y)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217987,"user_id":null,"body":"let alternate n first_value second_value =\n  List.init n (fun x -> if x mod 2 = 0 then first_value else second_value)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217988,"user_id":null,"body":"let alternate (n: int) (first_value: 'a) (second_value: 'a): 'a list =\n  let fill i = \n    if (i mod 2 == 0) then first_value else second_value\n  in let rec helper i acc =\n      if (i == n) then acc else\n        helper (i + 1) ((fill i) :: acc)\n      in \n        List.rev (helper 0 [])","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217989,"user_id":null,"body":"let rec alternate n a b =\n  if n > 0 then a :: alternate (n - 1) b a else []","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217990,"user_id":294,"body":"let alternate (n: int) (first: 'a) (second: 'a): 'a list =\n    let rec recur acc x = function\n    | 0 -> List.rev acc\n    | n ->\n        let x'= if x = first then second else first\n        in recur (x :: acc) x' (n - 1)\n    in recur [] first n\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217991,"user_id":294,"body":"let rec alternate (n: int) (first: 'a) (second: 'a): 'a list =\n    let pool = [| first; second |] in\n    Array.init n (fun i -> pool.(i mod (Array.length pool)))\n    |> list_of_array\n\n\nand list_of_array ary = ary |> Array.to_seq |> List.of_seq\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217992,"user_id":null,"body":"let alternate (n: int) (first_value: 'a) (second_value: 'a): 'a list =\n    List.init n (fun ix -> if ix mod 2 = 0 then first_value else second_value)","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217993,"user_id":null,"body":"let alternate (n: int) (first_value: 'a) (second_value: 'a): 'a list =  \n   let rec aux (m:int) (l: 'a list)= \n      match m with  \n        |_ when m = 0 -> l\n        |_ when (m mod 2 = 1) -> aux (m-1) (first_value::l)\n        |_ -> aux (m-1) (second_value::l)\n   in \n      aux n [];;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"}],"5265b0885fda8eac5900093b":[{"id":217994,"user_id":null,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n(* Parsing *)\n\n\nmodule Parser = struct\n(* Generated by Menhir on the following input:\n%{\ntype parsed_ast =\n  | PArg of string\n  | PImm of int\n  | PAdd of parsed_ast * parsed_ast\n  | PMul of parsed_ast * parsed_ast\n  | PSub of parsed_ast * parsed_ast\n  | PDiv of parsed_ast * parsed_ast\n            %}\n\n%token LEFT_BRACKET RIGHT_BRACKET LEFT_PAREN RIGHT_PAREN ADD MUL SUB DIV EOF\n%token <string> ARG\n%token <int> IMM\n%start <string list * parsed_ast> func\n\n%%\n\nfunc : LEFT_BRACKET arglist RIGHT_BRACKET expression EOF { ($2, $4) };\n\narglist    : \/* nothing *\/                     { [] }\n           | ARG arglist                       { $1 :: $2 }\n;\n\nexpression : term { $1 }\n           | expression ADD term               { PAdd ($1, $3) }\n           | expression SUB term               { PSub ($1, $3) }\n;\n\nterm       : factor                            { $1 }\n           | term MUL factor                   { PMul ($1, $3) }\n           | term DIV factor                   { PDiv ($1, $3) }\n;\n\nfactor     : IMM                               { PImm $1 }\n           | ARG                               { PArg $1 }\n           | LEFT_PAREN expression RIGHT_PAREN { $2 }\n;\n\n%%\n *)\n\n\nmodule MenhirBasics = struct\n  \n  exception Error\n  \n  type token = \n    | SUB\n    | RIGHT_PAREN\n    | RIGHT_BRACKET\n    | MUL\n    | LEFT_PAREN\n    | LEFT_BRACKET\n    | IMM of (\n# 13 \"compiler_parser.mly\"\n       (int)\n# 17 \"compiler_parser.ml\"\n  )\n    | EOF\n    | DIV\n    | ARG of (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 24 \"compiler_parser.ml\"\n  )\n    | ADD\n  \nend\n\ninclude MenhirBasics\n\nlet _eRR =\n  MenhirBasics.Error\n\ntype _menhir_env = {\n  _menhir_lexer: Lexing.lexbuf -> token;\n  _menhir_lexbuf: Lexing.lexbuf;\n  _menhir_token: token;\n  mutable _menhir_error: bool\n}\n\nand _menhir_state = \n  | MenhirState19\n  | MenhirState16\n  | MenhirState12\n  | MenhirState10\n  | MenhirState6\n  | MenhirState5\n  | MenhirState2\n  | MenhirState1\n\n# 1 \"compiler_parser.mly\"\n  \ntype parsed_ast =\n  | PArg of string\n  | PImm of int\n  | PAdd of parsed_ast * parsed_ast\n  | PMul of parsed_ast * parsed_ast\n  | PSub of parsed_ast * parsed_ast\n  | PDiv of parsed_ast * parsed_ast\n            \n# 62 \"compiler_parser.ml\"\n\nlet rec _menhir_run16 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_expression -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState16 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState16 _v\n    | LEFT_PAREN ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState16\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState16\n\nand _menhir_run19 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_expression -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v\n    | LEFT_PAREN ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState19\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState19\n\nand _menhir_goto_expression : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_expression -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    match _menhir_s with\n    | MenhirState6 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv73 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n        ((assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | ADD ->\n            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)\n        | RIGHT_PAREN ->\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ('freshtv69 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n            ((let _menhir_env = _menhir_discard _menhir_env in\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ('freshtv67 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n            ((let ((_menhir_stack, _menhir_s), _, (_2 : 'tv_expression)) = _menhir_stack in\n            let _3 = () in\n            let _1 = () in\n            let _v : 'tv_factor = \n# 36 \"compiler_parser.mly\"\n                                               ( _2 )\n# 120 \"compiler_parser.ml\"\n             in\n            _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv68)) : 'freshtv70)\n        | SUB ->\n            _menhir_run16 _menhir_env (Obj.magic _menhir_stack)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ('freshtv71 * _menhir_state) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv72)) : 'freshtv74)\n    | MenhirState5 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ((('freshtv87) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n        ((assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | ADD ->\n            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)\n        | EOF ->\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ((('freshtv83) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n            ((let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ((('freshtv81) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n            ((let ((_menhir_stack, _, (_2 : 'tv_arglist)), _, (_4 : 'tv_expression)) = _menhir_stack in\n            let _5 = () in\n            let _3 = () in\n            let _1 = () in\n            let _v : (\n# 14 \"compiler_parser.mly\"\n       (string list * parsed_ast)\n# 152 \"compiler_parser.ml\"\n            ) = \n# 18 \"compiler_parser.mly\"\n                                                         ( (_2, _4) )\n# 156 \"compiler_parser.ml\"\n             in\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : 'freshtv79) = _menhir_stack in\n            let (_v : (\n# 14 \"compiler_parser.mly\"\n       (string list * parsed_ast)\n# 163 \"compiler_parser.ml\"\n            )) = _v in\n            ((let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : 'freshtv77) = Obj.magic _menhir_stack in\n            let (_v : (\n# 14 \"compiler_parser.mly\"\n       (string list * parsed_ast)\n# 170 \"compiler_parser.ml\"\n            )) = _v in\n            ((let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : 'freshtv75) = Obj.magic _menhir_stack in\n            let ((_1 : (\n# 14 \"compiler_parser.mly\"\n       (string list * parsed_ast)\n# 177 \"compiler_parser.ml\"\n            )) : (\n# 14 \"compiler_parser.mly\"\n       (string list * parsed_ast)\n# 181 \"compiler_parser.ml\"\n            )) = _v in\n            (Obj.magic _1 : 'freshtv76)) : 'freshtv78)) : 'freshtv80)) : 'freshtv82)) : 'freshtv84)\n        | SUB ->\n            _menhir_run16 _menhir_env (Obj.magic _menhir_stack)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ((('freshtv85) * _menhir_state * 'tv_arglist)) * _menhir_state * 'tv_expression) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv86)) : 'freshtv88)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_run10 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_term -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v\n    | LEFT_PAREN ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState10\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState10\n\nand _menhir_run12 : _menhir_env -> 'ttv_tail * _menhir_state * 'tv_term -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v\n    | LEFT_PAREN ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState12\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState12\n\nand _menhir_goto_term : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_term -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    match _menhir_s with\n    | MenhirState5 | MenhirState6 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv53 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n        ((assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | DIV ->\n            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)\n        | MUL ->\n            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)\n        | ADD | EOF | RIGHT_PAREN | SUB ->\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : 'freshtv49 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, (_1 : 'tv_term)) = _menhir_stack in\n            let _v : 'tv_expression = \n# 24 \"compiler_parser.mly\"\n                  ( _1 )\n# 249 \"compiler_parser.ml\"\n             in\n            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v) : 'freshtv50)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : 'freshtv51 * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv52)) : 'freshtv54)\n    | MenhirState16 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : (('freshtv59 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n        ((assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | DIV ->\n            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)\n        | MUL ->\n            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)\n        | ADD | EOF | RIGHT_PAREN | SUB ->\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : (('freshtv55 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n            ((let ((_menhir_stack, _menhir_s, (_1 : 'tv_expression)), _, (_3 : 'tv_term)) = _menhir_stack in\n            let _2 = () in\n            let _v : 'tv_expression = \n# 26 \"compiler_parser.mly\"\n                                               ( PSub (_1, _3) )\n# 277 \"compiler_parser.ml\"\n             in\n            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v) : 'freshtv56)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : (('freshtv57 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv58)) : 'freshtv60)\n    | MenhirState19 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : (('freshtv65 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n        ((assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | DIV ->\n            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)\n        | MUL ->\n            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)\n        | ADD | EOF | RIGHT_PAREN | SUB ->\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : (('freshtv61 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n            ((let ((_menhir_stack, _menhir_s, (_1 : 'tv_expression)), _, (_3 : 'tv_term)) = _menhir_stack in\n            let _2 = () in\n            let _v : 'tv_expression = \n# 25 \"compiler_parser.mly\"\n                                               ( PAdd (_1, _3) )\n# 305 \"compiler_parser.ml\"\n             in\n            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v) : 'freshtv62)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : (('freshtv63 * _menhir_state * 'tv_expression)) * _menhir_state * 'tv_term) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv64)) : 'freshtv66)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_goto_factor : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_factor -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    match _menhir_s with\n    | MenhirState10 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv39 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\n        let (_menhir_s : _menhir_state) = _menhir_s in\n        let (_v : 'tv_factor) = _v in\n        ((let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv37 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\n        let (_ : _menhir_state) = _menhir_s in\n        let ((_3 : 'tv_factor) : 'tv_factor) = _v in\n        ((let (_menhir_stack, _menhir_s, (_1 : 'tv_term)) = _menhir_stack in\n        let _2 = () in\n        let _v : 'tv_term = \n# 30 \"compiler_parser.mly\"\n                                               ( PMul (_1, _3) )\n# 335 \"compiler_parser.ml\"\n         in\n        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv38)) : 'freshtv40)\n    | MenhirState12 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv43 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\n        let (_menhir_s : _menhir_state) = _menhir_s in\n        let (_v : 'tv_factor) = _v in\n        ((let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv41 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\n        let (_ : _menhir_state) = _menhir_s in\n        let ((_3 : 'tv_factor) : 'tv_factor) = _v in\n        ((let (_menhir_stack, _menhir_s, (_1 : 'tv_term)) = _menhir_stack in\n        let _2 = () in\n        let _v : 'tv_term = \n# 31 \"compiler_parser.mly\"\n                                               ( PDiv (_1, _3) )\n# 352 \"compiler_parser.ml\"\n         in\n        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv42)) : 'freshtv44)\n    | MenhirState5 | MenhirState19 | MenhirState16 | MenhirState6 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv47) = Obj.magic _menhir_stack in\n        let (_menhir_s : _menhir_state) = _menhir_s in\n        let (_v : 'tv_factor) = _v in\n        ((let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv45) = Obj.magic _menhir_stack in\n        let (_menhir_s : _menhir_state) = _menhir_s in\n        let ((_1 : 'tv_factor) : 'tv_factor) = _v in\n        ((let _v : 'tv_term = \n# 29 \"compiler_parser.mly\"\n                                               ( _1 )\n# 367 \"compiler_parser.ml\"\n         in\n        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v) : 'freshtv46)) : 'freshtv48)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_fail : unit -> 'a =\n  fun () ->\n    Printf.fprintf stderr \"Internal failure -- please contact the parser generator's developers.\n%!\";\n    assert false\n\nand _menhir_run6 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s ->\n    let _menhir_stack = (_menhir_stack, _menhir_s) in\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v\n    | LEFT_PAREN ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState6\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState6\n\nand _menhir_run7 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\n# 13 \"compiler_parser.mly\"\n       (int)\n# 398 \"compiler_parser.ml\"\n) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let (_menhir_env : _menhir_env) = _menhir_env in\n    let (_menhir_stack : 'freshtv35) = Obj.magic _menhir_stack in\n    let (_menhir_s : _menhir_state) = _menhir_s in\n    let ((_1 : (\n# 13 \"compiler_parser.mly\"\n       (int)\n# 408 \"compiler_parser.ml\"\n    )) : (\n# 13 \"compiler_parser.mly\"\n       (int)\n# 412 \"compiler_parser.ml\"\n    )) = _v in\n    ((let _v : 'tv_factor = \n# 34 \"compiler_parser.mly\"\n                                               ( PImm _1 )\n# 417 \"compiler_parser.ml\"\n     in\n    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv36)\n\nand _menhir_run8 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 424 \"compiler_parser.ml\"\n) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let (_menhir_env : _menhir_env) = _menhir_env in\n    let (_menhir_stack : 'freshtv33) = Obj.magic _menhir_stack in\n    let (_menhir_s : _menhir_state) = _menhir_s in\n    let ((_1 : (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 434 \"compiler_parser.ml\"\n    )) : (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 438 \"compiler_parser.ml\"\n    )) = _v in\n    ((let _v : 'tv_factor = \n# 35 \"compiler_parser.mly\"\n                                               ( PArg _1 )\n# 443 \"compiler_parser.ml\"\n     in\n    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v) : 'freshtv34)\n\nand _menhir_goto_arglist : _menhir_env -> 'ttv_tail -> _menhir_state -> 'tv_arglist -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    match _menhir_s with\n    | MenhirState2 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv25 * _menhir_state * (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 456 \"compiler_parser.ml\"\n        )) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in\n        ((let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv23 * _menhir_state * (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 462 \"compiler_parser.ml\"\n        )) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in\n        ((let ((_menhir_stack, _menhir_s, (_1 : (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 467 \"compiler_parser.ml\"\n        ))), _, (_2 : 'tv_arglist)) = _menhir_stack in\n        let _v : 'tv_arglist = \n# 21 \"compiler_parser.mly\"\n                                               ( _1 :: _2 )\n# 472 \"compiler_parser.ml\"\n         in\n        _menhir_goto_arglist _menhir_env _menhir_stack _menhir_s _v) : 'freshtv24)) : 'freshtv26)\n    | MenhirState1 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv31) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in\n        ((assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | RIGHT_BRACKET ->\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ('freshtv27) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in\n            ((let _menhir_env = _menhir_discard _menhir_env in\n            let _tok = _menhir_env._menhir_token in\n            match _tok with\n            | ARG _v ->\n                _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v\n            | IMM _v ->\n                _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v\n            | LEFT_PAREN ->\n                _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState5\n            | _ ->\n                assert (not _menhir_env._menhir_error);\n                _menhir_env._menhir_error <- true;\n                _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState5) : 'freshtv28)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let (_menhir_env : _menhir_env) = _menhir_env in\n            let (_menhir_stack : ('freshtv29) * _menhir_state * 'tv_arglist) = Obj.magic _menhir_stack in\n            ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv30)) : 'freshtv32)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_errorcase : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s ->\n    match _menhir_s with\n    | MenhirState19 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv7 * _menhir_state * 'tv_expression)) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv8)\n    | MenhirState16 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv9 * _menhir_state * 'tv_expression)) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv10)\n    | MenhirState12 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv11 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv12)\n    | MenhirState10 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : ('freshtv13 * _menhir_state * 'tv_term)) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv14)\n    | MenhirState6 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv15 * _menhir_state) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv16)\n    | MenhirState5 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : (('freshtv17) * _menhir_state * 'tv_arglist)) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv18)\n    | MenhirState2 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv19 * _menhir_state * (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 545 \"compiler_parser.ml\"\n        )) = Obj.magic _menhir_stack in\n        ((let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s) : 'freshtv20)\n    | MenhirState1 ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv21) = Obj.magic _menhir_stack in\n        (raise _eRR : 'freshtv22)\n\nand _menhir_reduce1 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s ->\n    let _v : 'tv_arglist = \n# 20 \"compiler_parser.mly\"\n                                               ( [] )\n# 559 \"compiler_parser.ml\"\n     in\n    _menhir_goto_arglist _menhir_env _menhir_stack _menhir_s _v\n\nand _menhir_run2 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\n# 12 \"compiler_parser.mly\"\n       (string)\n# 566 \"compiler_parser.ml\"\n) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState2 _v\n    | RIGHT_BRACKET ->\n        _menhir_reduce1 _menhir_env (Obj.magic _menhir_stack) MenhirState2\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState2\n\nand _menhir_discard : _menhir_env -> _menhir_env =\n  fun _menhir_env ->\n    let lexer = _menhir_env._menhir_lexer in\n    let lexbuf = _menhir_env._menhir_lexbuf in\n    let _tok = lexer lexbuf in\n    {\n      _menhir_lexer = lexer;\n      _menhir_lexbuf = lexbuf;\n      _menhir_token = _tok;\n      _menhir_error = false;\n    }\n\nand func : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (\n# 14 \"compiler_parser.mly\"\n       (string list * parsed_ast)\n# 597 \"compiler_parser.ml\"\n) =\n  fun lexer lexbuf ->\n    let _menhir_env =\n      let (lexer : Lexing.lexbuf -> token) = lexer in\n      let (lexbuf : Lexing.lexbuf) = lexbuf in\n      ((let _tok = Obj.magic () in\n      {\n        _menhir_lexer = lexer;\n        _menhir_lexbuf = lexbuf;\n        _menhir_token = _tok;\n        _menhir_error = false;\n      }) : _menhir_env)\n    in\n    Obj.magic (let (_menhir_env : _menhir_env) = _menhir_env in\n    let (_menhir_stack : 'freshtv5) = ((), _menhir_env._menhir_lexbuf.Lexing.lex_curr_p) in\n    ((let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | LEFT_BRACKET ->\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv1) = Obj.magic _menhir_stack in\n        ((let _menhir_env = _menhir_discard _menhir_env in\n        let _tok = _menhir_env._menhir_token in\n        match _tok with\n        | ARG _v ->\n            _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState1 _v\n        | RIGHT_BRACKET ->\n            _menhir_reduce1 _menhir_env (Obj.magic _menhir_stack) MenhirState1\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState1) : 'freshtv2)\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        let (_menhir_env : _menhir_env) = _menhir_env in\n        let (_menhir_stack : 'freshtv3) = Obj.magic _menhir_stack in\n        (raise _eRR : 'freshtv4)) : 'freshtv6))\n\n# 39 \"compiler_parser.mly\"\n  \n\n# 640 \"compiler_parser.ml\"\n\n# 269 \"\/home\/cauderlier\/.opam\/4.07.1\/lib\/menhir\/standard.mly\"\n  \n\n# 645 \"compiler_parser.ml\"\n\nend\n# 693 \"compiler.ml\"\n\n(* Lexing *)\n\nmodule Lexer = struct\n\n(* Begin of generated lexer *)\n(* Generated by OCamllex on the following input: *)\n  (*\n{\nopen Parser\n}\n\nlet arg = [ 'a'-'z' 'A'-'Z' ]+\nlet num = [ '0'-'9' ]+\nlet whitespace = [ ' ' '\\t' '\\r' '\n' ]\n\nrule lex = parse\n  | whitespace { lex lexbuf }\n  | arg as s { ARG (s) }\n  | num as s { IMM (int_of_string s) }\n  | '[' { LEFT_BRACKET }\n  | ']' { RIGHT_BRACKET }\n  | '(' { LEFT_PAREN }\n  | ')' { RIGHT_PAREN }\n  | '+' { ADD }\n  | '-' { SUB }\n  | '*' { MUL }\n  | '\/' { DIV }\n  | eof { EOF }\n*)\n# 1 \"compiler_lexer.mll\"\n \nopen Parser\n\n# 6 \"compiler_lexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\244\\255\\245\\255\\246\\255\\247\\255\\248\\255\\249\\255\\250\\255\\\n    \\251\\255\\252\\255\\075\\000\\068\\000\\255\\255\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\002\\000\\001\\000\\255\\255\";\n  Lexing.lex_default =\n   \"\\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\255\\255\\255\\255\\000\\000\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\012\\000\\012\\000\\000\\000\\000\\000\\012\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\012\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\007\\000\\006\\000\\003\\000\\005\\000\\000\\000\\004\\000\\000\\000\\002\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\009\\000\\000\\000\\008\\000\\000\\000\\000\\000\\\n    \\000\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\255\\255\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\\n    \\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\011\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec lex lexbuf =\n   __ocaml_lex_lex_rec lexbuf 0\nand __ocaml_lex_lex_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 10 \"compiler_lexer.mll\"\n               ( lex lexbuf )\n# 124 \"compiler_lexer.ml\"\n\n  | 1 ->\nlet\n# 11 \"compiler_lexer.mll\"\n           s\n# 130 \"compiler_lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 11 \"compiler_lexer.mll\"\n             ( ARG (s) )\n# 134 \"compiler_lexer.ml\"\n\n  | 2 ->\nlet\n# 12 \"compiler_lexer.mll\"\n           s\n# 140 \"compiler_lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 12 \"compiler_lexer.mll\"\n             ( IMM (int_of_string s) )\n# 144 \"compiler_lexer.ml\"\n\n  | 3 ->\n# 13 \"compiler_lexer.mll\"\n        ( LEFT_BRACKET )\n# 149 \"compiler_lexer.ml\"\n\n  | 4 ->\n# 14 \"compiler_lexer.mll\"\n        ( RIGHT_BRACKET )\n# 154 \"compiler_lexer.ml\"\n\n  | 5 ->\n# 15 \"compiler_lexer.mll\"\n        ( LEFT_PAREN )\n# 159 \"compiler_lexer.ml\"\n\n  | 6 ->\n# 16 \"compiler_lexer.mll\"\n        ( RIGHT_PAREN )\n# 164 \"compiler_lexer.ml\"\n\n  | 7 ->\n# 17 \"compiler_lexer.mll\"\n        ( ADD )\n# 169 \"compiler_lexer.ml\"\n\n  | 8 ->\n# 18 \"compiler_lexer.mll\"\n        ( SUB )\n# 174 \"compiler_lexer.ml\"\n\n  | 9 ->\n# 19 \"compiler_lexer.mll\"\n        ( MUL )\n# 179 \"compiler_lexer.ml\"\n\n  | 10 ->\n# 20 \"compiler_lexer.mll\"\n        ( DIV )\n# 184 \"compiler_lexer.ml\"\n\n  | 11 ->\n# 21 \"compiler_lexer.mll\"\n        ( EOF )\n# 189 \"compiler_lexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_lex_rec lexbuf __ocaml_lex_state\n\n;;\nend\n# 918 \"compiler.ml\"\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\nmodule Scoping = struct\n\n  open Parser\n\n  exception Scoping_error of string\n\n  let rec index_of x acc = function\n    | y :: l when x = y -> acc\n    | y :: l -> index_of x (acc + 1) l\n    | [] -> raise (Scoping_error x)\n\n  let rec scope args = function\n    | PArg s -> Arg (index_of s 0 args)\n    | PImm x -> Imm x\n    | PAdd (a1, a2) -> Add (scope args a1, scope args a2)\n    | PMul (a1, a2) -> Mul (scope args a1, scope args a2)\n    | PSub (a1, a2) -> Sub (scope args a1, scope args a2)\n    | PDiv (a1, a2) -> Div (scope args a1, scope args a2)\n\nend\n\nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\nmodule Compiler : COMPILER =\n  struct\n    let pass1 (s : string) =\n      let (args, body) = Parser.func Lexer.lex (Lexing.from_string s) in\n      Scoping.scope args body\n\n    let rec pass2 = function\n      | Imm i -> Imm i\n      | Arg x -> Arg x\n      | Add (x, y) ->\n        let x' = pass2 x in\n        let y' = pass2 y in\n        begin match x', y' with\n        | Imm i1, Imm i2 -> Imm (i1 + i2)\n        | _ -> Add (x', y')\n        end\n      | Mul (x, y) ->\n        let x' = pass2 x in\n        let y' = pass2 y in\n        begin match x', y' with\n        | Imm i1, Imm i2 -> Imm (i1 * i2)\n        | _ -> Mul (x', y')\n        end\n      | Sub (x, y) ->\n        let x' = pass2 x in\n        let y' = pass2 y in\n        begin match x', y' with\n        | Imm i1, Imm i2 -> Imm (i1 - i2)\n        | _ -> Sub (x', y')\n        end\n      | Div (x, y) ->\n        let x' = pass2 x in\n        let y' = pass2 y in\n        begin match x', y' with\n        | Imm i1, Imm i2 -> Imm (i1 \/ i2)\n        | _ -> Div (x', y')\n        end\n\n    let rec codeGenL acc = function\n      | Imm i -> Printf.sprintf \"IM %d\" i :: acc\n      | Arg i -> Printf.sprintf \"AR %d\" i :: acc\n      | Add (x, y) ->\n         \"AD\" :: \"PO\" :: \"SW\" :: codeGenL (\"PU\" :: codeGenL acc x) y\n      | Mul (x, y) ->\n         \"MU\" :: \"PO\" :: \"SW\" :: codeGenL (\"PU\" :: codeGenL acc x) y\n      | Sub (x, y) ->\n         \"SU\" :: \"PO\" :: \"SW\" :: codeGenL (\"PU\" :: codeGenL acc x) y\n      | Div (x, y) ->\n         \"DI\" :: \"PO\" :: \"SW\" :: codeGenL (\"PU\" :: codeGenL acc x) y\n\n    let codeGen code = List.rev (codeGenL [] code)\n\n    let pass3 = codeGen\n\n    let compile code =\n      codeGen(pass2(pass1 code))\n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217995,"user_id":null,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\nmodule Compiler : COMPILER =\n  struct\n    open Core\n\n    module Parser = struct\n      type t = string list ref\n      \n      let init toks = ref toks\n      \n      let matches toks lst = \n        match !toks with\n        | [] -> false\n        | x::_ -> List.mem lst x ~equal:String.equal\n        \n      let next toks =\n        let t = List.hd_exn !toks in\n        toks := List.tl_exn !toks;\n        t\n      \n      let peek toks = List.hd !toks\n    end\n  \n    let pass1 code =\n      let tokens = List.drop (tokenize code) 1 in\n      let (args, rest) = List.split_while tokens ~f:(fun t -> t <> \"]\") in\n      let p = Parser.init (List.drop rest 1) in\n\n      let rec expression () =\n        let expr = ref (term ()) in\n        while Parser.matches p [\"+\"; \"-\"] do\n          let op = Parser.next p in\n          let right = term () in\n          match op with\n          | \"+\" -> expr := Add(!expr, right)\n          | _ -> expr := Sub(!expr, right)\n        done;\n        !expr\n      \n      and term () =\n        let ter = ref (factor ()) in\n        while Parser.matches p [\"*\"; \"\/\"] do\n          let op = Parser.next p in\n          let right = factor () in\n          match op with\n          | \"*\" -> ter := Mul(!ter, right)\n          | _ -> ter := Div(!ter, right)\n        done;\n        !ter\n      \n      and factor () =\n        match Parser.next p with\n        | \"(\" ->\n          let expr = expression () in begin\n          match Parser.peek p with\n          | Some \")\" ->\n            ignore (Parser.next p);\n            expr\n          | _ -> \n            failwith \"Missing paren\"\n          end\n        | x ->\n          match (try Some(Int.of_string x) with _ -> None) with\n          | Some(n) -> Imm n\n          | None -> \n            let rec index_of c = function\n            | [] -> failwith \"Undefined arg\" \n            | y :: ys -> if String.equal x y then c else index_of (c + 1) ys\n            in\n            Arg (index_of 0 args)\n      in\n      expression ()\n          \n    let pass2 ast = \n      let add x y = Add(x, y) in\n      let sub x y = Sub(x, y) in\n      let mul x y = Mul(x, y) in\n      let div x y = Div(x, y) in\n      let rec merge cons f x y = match (helper x, helper y) with\n        | (Imm m, Imm n) -> Imm (f m n)\n        | (m, n) -> cons m n\n      \n      and helper = function\n        | Add(x, y) -> merge add (+) x y\n        | Sub(x, y) -> merge sub (-) x y\n        | Mul(x, y) -> merge mul ( * ) x y\n        | Div(x, y) -> merge div ( \/ ) x y\n        | node -> node\n      in\n      helper ast\n    \n    let rec codeGen = function\n      | Imm n -> [sprintf \"IM %d\" n; \"PU\"]\n      | Arg a -> [sprintf \"AR %d\" a; \"PU\"]\n      | Add(x, y) -> codeGen x @ codeGen y @ [\"PO\"; \"SW\"; \"PO\"; \"AD\"; \"PU\"]\n      | Sub(x, y) -> codeGen x @ codeGen y @ [\"PO\"; \"SW\"; \"PO\"; \"SU\"; \"PU\"]\n      | Mul(x, y) -> codeGen x @ codeGen y @ [\"PO\"; \"SW\"; \"PO\"; \"MU\"; \"PU\"]\n      | Div(x, y) -> codeGen x @ codeGen y @ [\"PO\"; \"SW\"; \"PO\"; \"DI\"; \"PU\"]\n    \n    let compile code =\n      codeGen(pass2(pass1 code))\n      \n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217996,"user_id":null,"body":"\n\nlet tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\nlet rec _findIndex l v i =\n  match l with\n  | h::t when v = h -> Some i\n  | h::t -> _findIndex t v (i+1)\n  | [] -> None\n  \nlet findIndex l v = _findIndex l v 0\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\nmodule Compiler : COMPILER =\n  struct\n    exception ParseError of string\n    \n    let rec parseArgList tokens args =\n      match tokens with\n      | \"]\"::ts -> tokens, args\n      | v::ts -> parseArgList ts (v::args)\n      | _ -> raise(ParseError \"unexpected EOF\")\n      \n    let rec parseExpression tokens args =\n      let tokens, expr = parseTerm tokens args in\n      parseExpressionHelper tokens args expr\n      \n    and parseExpressionHelper tokens args expr =\n      match tokens with\n      | \"+\"::ts ->\n        let tokens, rightTerm = parseTerm ts args in\n        let expr = Add (expr, rightTerm) in\n        parseExpressionHelper tokens args expr\n      | \"-\"::ts ->\n        let tokens, rightTerm = parseTerm ts args in\n        let expr = Sub (expr, rightTerm) in\n        parseExpressionHelper tokens args expr\n      | _ -> tokens, expr\n      \n    and parseTerm tokens args =\n      let tokens, term = parseFactor tokens args in\n      parseTermHelper tokens args term\n      \n    and parseTermHelper tokens args term =\n      match tokens with\n      | \"*\"::ts ->\n        let tokens, rightFactor = parseFactor ts args in\n        let term = Mul (term, rightFactor) in\n        parseTermHelper tokens args term\n      | \"\/\"::ts->\n        let tokens, rightFactor = parseFactor ts args in\n        let term = Div (term, rightFactor) in\n        parseTermHelper tokens args term\n      | _ -> tokens, term\n      \n    and parseFactor tokens args =\n      match tokens with\n      | \"(\"::ts ->\n        let tokens, expr = parseExpression ts args in\n        (match tokens with\n        | \")\"::ts -> ts, expr\n        | _ -> raise (ParseError \"')' expected\")\n        )\n      | f::ts ->\n        let factor = match findIndex args f with\n        | Some i -> Arg i\n        | None -> Imm (int_of_string f)\n        in\n        ts, factor\n      | [] -> raise (ParseError \"unexpected EOF\")\n\n    let parseFunction = function\n      | \"[\"::ts ->\n        let ts, args = parseArgList ts [] in\n        (match ts with\n        | \"]\"::ts -> parseExpression ts (List.rev args)\n        | _ -> raise(ParseError \"']' expected\")\n        )\n      | _ -> raise(ParseError \"'[' expected\")\n      \n    let pass1 code = \n      let tokens, ast = parseFunction (tokenize code) in\n      ast\n\n    let rec pass2 ast =\n      let optimized =\n        match ast with\n        | Add (l, r) -> Add (pass2 l, pass2 r)\n        | Sub (l, r) -> Sub (pass2 l, pass2 r)\n        | Mul (l, r) -> Mul (pass2 l, pass2 r)\n        | Div (l, r) -> Div (pass2 l, pass2 r)\n        | _ -> ast\n      in\n      match optimized with\n      | Add (Imm l, Imm r) -> Imm (l + r)\n      | Sub (Imm l, Imm r) -> Imm (l - r)\n      | Mul (Imm l, Imm r) -> Imm (l * r)\n      | Div (Imm l, Imm r) -> Imm (l \/ r)\n      | _ -> optimized\n      \n    let rec codeGen ast =\n      match ast with\n      | Add (l, r) -> (codeGen l) @ [\"PU\"] @ (codeGen r) @ [\"SW\"; \"PO\"; \"AD\"]\n      | Sub (l, r) -> (codeGen l) @ [\"PU\"] @ (codeGen r) @ [\"SW\"; \"PO\"; \"SU\"]\n      | Mul (l, r) -> (codeGen l) @ [\"PU\"] @ (codeGen r) @ [\"SW\"; \"PO\"; \"MU\"]\n      | Div (l, r) -> (codeGen l) @ [\"PU\"] @ (codeGen r) @ [\"SW\"; \"PO\"; \"DI\"]\n      | Arg i -> [\"AR \"^(string_of_int i)]\n      | Imm c -> [\"IM \"^(string_of_int c)]\n\n    let compile code =\n      codeGen(pass2(pass1 code))\n      \n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217997,"user_id":null,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list\n  end\n\nopen Stack\nopen List\n\nmodule Compiler : COMPILER =\n  struct\n\n    let shunting_yard t arg = (*Version propre*)\n      let foo arb = function\n        | \"+\" -> push (Add(pop arb, pop arb)) arb\n        | \"-\" -> push (Sub(pop arb, pop arb)) arb\n        | \"*\" -> push (Mul(pop arb, pop arb)) arb\n        | \"\/\" -> push (Div(pop arb, pop arb)) arb\n        | _ -> () in\n\n      let operateurs = [(\"+\", 1); (\"-\", 1); (\"*\", 0); (\"\/\", 0)] and\n        num = init 1000 string_of_int in\n\n      let abst = create () and\n        ops  = create () in ignore (pop abst, push (Imm(0)) abst, pop ops, push \"_\" ops);\n\n      for i = 0 to (Array.length t - 1) do\n        match t.(i) with\n          | \"(\" -> push \"(\" ops\n\n          | s when mem s num -> push (Imm(int_of_string s)) abst\n\n          | s when mem_assoc s operateurs -> while (not (is_empty ops) && top ops <> \"(\") && assoc s operateurs >= assoc (top ops) operateurs do\n                          foo abst (pop ops) done;\n                        push s ops\n\n          | \")\" -> while (not (is_empty ops) && top ops <> \"(\") do\n                 foo abst(pop ops) done;\n               ignore (pop ops)\n\n          | s -> push (Arg(assoc s arg)) abst done;\n\n      while not (is_empty ops) do\n        foo abst(pop ops) done;\n      if Stack.length abst <> 1 then failwith \"Mauvaise expression\" else top abst;;\n  \n    let pass1 code = print_string code;\n\t    let rec aux1 = function\n        | [] -> []\n        | \"]\"::q -> q\n        | a :: q -> aux1 q in\n      let rec aux2 i = function\n        | [] -> []\n        | \"[\"::q -> aux2 i q\n        | \"]\"::q -> []\n        | a :: q -> (a, i) :: aux2 (i+1) q in\n      let tokens = tokenize code in\n      shunting_yard (Array.of_list (aux1 tokens)) (aux2 0 tokens);;\n\n        let rec pass2 = function\n      | Imm(n) -> Imm(n)\n      | Arg(n) -> Arg(n)\n      | Add(g, d) -> begin match pass2 g, pass2 d with\n                  | Imm(a), Imm(b) -> Imm(a+b)\n                  | sg, sd -> Add(sg, sd) end\n      | Sub(g, d) -> begin match pass2 g, pass2 d with\n                  | Imm(a), Imm(b) -> Imm(a-b)\n                  | sg, sd -> Sub(sg, sd) end\n      | Mul(g, d) -> begin match pass2 g, pass2 d with\n                  | Imm(a), Imm(b) -> Imm(a*b)\n                  | sg, sd -> Mul(sg, sd) end\n      | Div(g, d) -> begin match pass2 g, pass2 d with\n                  | Imm(a), Imm(b) -> Imm(a\/b)\n                  | sg, sd -> Div(sg, sd) end;; \n      \n    let rec codeGen = function\n      | Imm(n) -> [\"IM \" ^ string_of_int n]\n      | Arg(n) -> [\"AR \" ^ string_of_int n]\n      | Add(g, d) -> codeGen g @ (\"PU\" :: (codeGen d @ [\"SW\"; \"PO\"; \"AD\"]))\n      | Sub(g, d) -> codeGen g @ (\"PU\" :: (codeGen d @ [\"SW\"; \"PO\"; \"SU\"]))\n      | Mul(g, d) -> codeGen g @ (\"PU\" :: (codeGen d @ [\"SW\"; \"PO\"; \"MU\"]))\n      | Div(g, d) -> codeGen g @ (\"PU\" :: (codeGen d @ [\"SW\"; \"PO\"; \"DI\"]));;\n\n    let compile code =\n      codeGen(pass2(pass1 code))\n      \n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217998,"user_id":null,"body":"(* The code was partly generated using ocamllex and ocamlyacc, so don't bother reading this solution :) \nThe compiler part lies at the very bottom of the program. *)\n\nlet tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n  \nexception CompilerError of string\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n\n\nmodule Ast = struct\ntype ast =\n  | Imm of int (* immediate value *)\n  | Arg of int (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\nlet rec pp ppf ast =\n  match ast with\n  | Imm i -> Format.fprintf ppf \"%i\" i\n  | Arg i -> Format.fprintf ppf \"Arg%i\" i\n  | Add (ast1, ast2) -> Format.fprintf ppf \"(@[<hov 1>@[%a@]@ + @[%a@]@])\" pp ast1 pp ast2\n  | Sub (ast1, ast2) -> Format.fprintf ppf \"(@[<hov 1>@[%a@]@ - @[%a@]@])\" pp ast1 pp ast2\n  | Mul (ast1, ast2) -> Format.fprintf ppf \"(@[<hov 1>@[%a@]@ * @[%a@]@])\" pp ast1 pp ast2\n  | Div (ast1, ast2) -> Format.fprintf ppf \"(@[<hov 1>@[%a@]@ \/ @[%a@]@])\" pp ast1 pp ast2\nend\n\n(***************************************)\n(***** GENERATED BY MENHIR *************)\n(***************************************)\n\nmodule type PARSER = sig \n  type token = \n    | RIGHT_PAR\n    | RIGHT_BRACK\n    | PLUS\n    | MULT\n    | MINUS\n    | LEFT_PAR\n    | LEFT_BRACK\n    | IMM of (int)\n    | EOF\n    | DIV\n    | ARG of (string)\n    \n  (* This exception is raised by the monolithic API functions. *)\n  exception Error\n  (* The monolithic API. *)\n  val program: (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast.ast)\nend\n\nmodule Parser : PARSER = struct\n\nmodule MenhirBasics = struct\n  \n  exception Error\n  \n  type token = \n    | RIGHT_PAR\n    | RIGHT_BRACK\n    | PLUS\n    | MULT\n    | MINUS\n    | LEFT_PAR\n    | LEFT_BRACK\n    | IMM of (\n# 26 \"src\/parser.mly\"\n       (int)\n# 18 \"src\/parser.ml\"\n  )\n    | EOF\n    | DIV\n    | ARG of (\n# 25 \"src\/parser.mly\"\n       (string)\n# 25 \"src\/parser.ml\"\n  )\n  \nend\n\ninclude MenhirBasics\n\nlet _eRR =\n  MenhirBasics.Error\n\ntype _menhir_env = {\n  _menhir_lexer: Lexing.lexbuf -> token;\n  _menhir_lexbuf: Lexing.lexbuf;\n  _menhir_token: token;\n  mutable _menhir_error: bool\n}\n\nand _menhir_state = \n  | MenhirState19\n  | MenhirState17\n  | MenhirState12\n  | MenhirState10\n  | MenhirState6\n  | MenhirState5\n  | MenhirState3\n  | MenhirState1\n\n# 1 \"src\/parser.mly\"\n  \n\topen Ast\n\n  \texception Parsing_error of string\n\n\n\tlet args : (string, int) Hashtbl.t = Hashtbl.create 10\n\n\tlet add_arg =\n\t\tlet count = ref 0 in\n\t\tfunction s ->\n\t\t\tHashtbl.add args s !count ; incr count\n\n\n\n\tlet find_arg s =\n    let n = Hashtbl.length args in\n\t\ttry\n\t\t\tn - 1 - Hashtbl.find args s (* order of arguments is reversed *)\n\t\twith Not_found -> raise (Parsing_error (Format.sprintf \"Unknown argument %s\" s))\n\n# 76 \"src\/parser.ml\"\n\nlet rec _menhir_run17 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState17 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState17 _v\n    | LEFT_PAR ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState17\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState17\n\nand _menhir_run19 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState19 _v\n    | LEFT_PAR ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState19\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState19\n\nand _menhir_goto_expression : _menhir_env -> 'ttv_tail -> _menhir_state -> (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    match _menhir_s with\n    | MenhirState6 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | MINUS ->\n            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)\n        | PLUS ->\n            _menhir_run17 _menhir_env (Obj.magic _menhir_stack)\n        | RIGHT_PAR ->\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let _menhir_env = _menhir_discard _menhir_env in\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let ((_menhir_stack, _menhir_s), _, (e : (Ast.ast))) = _menhir_stack in\n            let _v : (Ast.ast) = \n# 58 \"src\/parser.mly\"\n                                  ( e )\n# 131 \"src\/parser.ml\"\n             in\n            _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)\n    | MenhirState5 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | EOF ->\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let ((_menhir_stack, _, _), _, (e : (Ast.ast))) = _menhir_stack in\n            let _v : (Ast.ast) = \n# 39 \"src\/parser.mly\"\n                                   ( e )\n# 152 \"src\/parser.ml\"\n             in\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_1 : (Ast.ast)) = _v in\n            Obj.magic _1\n        | MINUS ->\n            _menhir_run19 _menhir_env (Obj.magic _menhir_stack)\n        | PLUS ->\n            _menhir_run17 _menhir_env (Obj.magic _menhir_stack)\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_run10 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState10 _v\n    | LEFT_PAR ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState10\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState10\n\nand _menhir_run12 : _menhir_env -> 'ttv_tail * _menhir_state * (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState12 _v\n    | LEFT_PAR ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState12\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState12\n\nand _menhir_goto_term : _menhir_env -> 'ttv_tail -> _menhir_state -> (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    match _menhir_s with\n    | MenhirState5 | MenhirState6 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | DIV ->\n            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)\n        | MULT ->\n            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)\n        | EOF | MINUS | PLUS | RIGHT_PAR ->\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_menhir_stack, _menhir_s, (t : (Ast.ast))) = _menhir_stack in\n            let _v : (Ast.ast) = \n# 46 \"src\/parser.mly\"\n         ( t )\n# 222 \"src\/parser.ml\"\n             in\n            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)\n    | MenhirState17 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | DIV ->\n            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)\n        | MULT ->\n            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)\n        | EOF | MINUS | PLUS | RIGHT_PAR ->\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let ((_menhir_stack, _menhir_s, (e : (Ast.ast))), _, (t : (Ast.ast))) = _menhir_stack in\n            let _v : (Ast.ast) = \n# 47 \"src\/parser.mly\"\n                           ( Add (e, t) )\n# 246 \"src\/parser.ml\"\n             in\n            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)\n    | MenhirState19 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | DIV ->\n            _menhir_run12 _menhir_env (Obj.magic _menhir_stack)\n        | MULT ->\n            _menhir_run10 _menhir_env (Obj.magic _menhir_stack)\n        | EOF | MINUS | PLUS | RIGHT_PAR ->\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let ((_menhir_stack, _menhir_s, (e : (Ast.ast))), _, (t : (Ast.ast))) = _menhir_stack in\n            let _v : (Ast.ast) = \n# 48 \"src\/parser.mly\"\n                            ( Sub (e,t) )\n# 270 \"src\/parser.ml\"\n             in\n            _menhir_goto_expression _menhir_env _menhir_stack _menhir_s _v\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            let _menhir_stack = Obj.magic _menhir_stack in\n            let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_goto_factor : _menhir_env -> 'ttv_tail -> _menhir_state -> (Ast.ast) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    match _menhir_s with\n    | MenhirState10 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (f : (Ast.ast)) = _v in\n        let (_menhir_stack, _menhir_s, (t : (Ast.ast))) = _menhir_stack in\n        let _v : (Ast.ast) = \n# 52 \"src\/parser.mly\"\n                       ( Mul (t, f) )\n# 293 \"src\/parser.ml\"\n         in\n        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v\n    | MenhirState12 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (f : (Ast.ast)) = _v in\n        let (_menhir_stack, _menhir_s, (t : (Ast.ast))) = _menhir_stack in\n        let _v : (Ast.ast) = \n# 53 \"src\/parser.mly\"\n                      ( Div (t, f) )\n# 304 \"src\/parser.ml\"\n         in\n        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v\n    | MenhirState5 | MenhirState19 | MenhirState17 | MenhirState6 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (f : (Ast.ast)) = _v in\n        let _v : (Ast.ast) = \n# 51 \"src\/parser.mly\"\n           ( f )\n# 314 \"src\/parser.ml\"\n         in\n        _menhir_goto_term _menhir_env _menhir_stack _menhir_s _v\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_fail : unit -> 'a =\n  fun () ->\n    Printf.fprintf stderr \"Internal failure -- please contact the parser generator's developers.\n%!\";\n    assert false\n\nand _menhir_run6 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s ->\n    let _menhir_stack = (_menhir_stack, _menhir_s) in\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v\n    | IMM _v ->\n        _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState6 _v\n    | LEFT_PAR ->\n        _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState6\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState6\n\nand _menhir_run7 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\n# 26 \"src\/parser.mly\"\n       (int)\n# 345 \"src\/parser.ml\"\n) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _menhir_stack = Obj.magic _menhir_stack in\n    let (n : (\n# 26 \"src\/parser.mly\"\n       (int)\n# 353 \"src\/parser.ml\"\n    )) = _v in\n    let _v : (Ast.ast) = \n# 56 \"src\/parser.mly\"\n        ( Imm n )\n# 358 \"src\/parser.ml\"\n     in\n    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v\n\nand _menhir_run8 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\n# 25 \"src\/parser.mly\"\n       (string)\n# 365 \"src\/parser.ml\"\n) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _menhir_stack = Obj.magic _menhir_stack in\n    let (a : (\n# 25 \"src\/parser.mly\"\n       (string)\n# 373 \"src\/parser.ml\"\n    )) = _v in\n    let _v : (Ast.ast) = \n# 57 \"src\/parser.mly\"\n        ( Arg (find_arg a) )\n# 378 \"src\/parser.ml\"\n     in\n    _menhir_goto_factor _menhir_env _menhir_stack _menhir_s _v\n\nand _menhir_goto_args : _menhir_env -> 'ttv_tail -> _menhir_state -> (unit) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    match _menhir_s with\n    | MenhirState3 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let ((_menhir_stack, _menhir_s, (a : (\n# 25 \"src\/parser.mly\"\n       (string)\n# 392 \"src\/parser.ml\"\n        ))), _, _) = _menhir_stack in\n        let _v : (unit) = \n# 43 \"src\/parser.mly\"\n               ( add_arg a )\n# 397 \"src\/parser.ml\"\n         in\n        _menhir_goto_args _menhir_env _menhir_stack _menhir_s _v\n    | MenhirState1 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        assert (not _menhir_env._menhir_error);\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | ARG _v ->\n            _menhir_run8 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v\n        | IMM _v ->\n            _menhir_run7 _menhir_env (Obj.magic _menhir_stack) MenhirState5 _v\n        | LEFT_PAR ->\n            _menhir_run6 _menhir_env (Obj.magic _menhir_stack) MenhirState5\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState5)\n    | _ ->\n        _menhir_fail ()\n\nand _menhir_errorcase : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s ->\n    match _menhir_s with\n    | MenhirState19 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState17 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState12 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState10 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState6 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState5 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState3 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let (_menhir_stack, _menhir_s, _) = _menhir_stack in\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) _menhir_s\n    | MenhirState1 ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        raise _eRR\n\nand _menhir_run2 : _menhir_env -> 'ttv_tail -> _menhir_state -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s ->\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _menhir_stack = Obj.magic _menhir_stack in\n    let _v : (unit) = \n# 42 \"src\/parser.mly\"\n              ( () )\n# 460 \"src\/parser.ml\"\n     in\n    _menhir_goto_args _menhir_env _menhir_stack _menhir_s _v\n\nand _menhir_run3 : _menhir_env -> 'ttv_tail -> _menhir_state -> (\n# 25 \"src\/parser.mly\"\n       (string)\n# 467 \"src\/parser.ml\"\n) -> 'ttv_return =\n  fun _menhir_env _menhir_stack _menhir_s _v ->\n    let _menhir_stack = (_menhir_stack, _menhir_s, _v) in\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | ARG _v ->\n        _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState3 _v\n    | RIGHT_BRACK ->\n        _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState3\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState3\n\nand _menhir_discard : _menhir_env -> _menhir_env =\n  fun _menhir_env ->\n    let lexer = _menhir_env._menhir_lexer in\n    let lexbuf = _menhir_env._menhir_lexbuf in\n    let _tok = lexer lexbuf in\n    {\n      _menhir_lexer = lexer;\n      _menhir_lexbuf = lexbuf;\n      _menhir_token = _tok;\n      _menhir_error = false;\n    }\n\nand program : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> (Ast.ast) =\n  fun lexer lexbuf ->\n    let _menhir_env = {\n      _menhir_lexer = lexer;\n      _menhir_lexbuf = lexbuf;\n      _menhir_token = Obj.magic ();\n      _menhir_error = false;\n    } in\n    Obj.magic (let _menhir_stack = ((), _menhir_env._menhir_lexbuf.Lexing.lex_curr_p) in\n    let _menhir_env = _menhir_discard _menhir_env in\n    let _tok = _menhir_env._menhir_token in\n    match _tok with\n    | LEFT_BRACK ->\n        let _menhir_stack = Obj.magic _menhir_stack in\n        let _menhir_env = _menhir_discard _menhir_env in\n        let _tok = _menhir_env._menhir_token in\n        (match _tok with\n        | ARG _v ->\n            _menhir_run3 _menhir_env (Obj.magic _menhir_stack) MenhirState1 _v\n        | RIGHT_BRACK ->\n            _menhir_run2 _menhir_env (Obj.magic _menhir_stack) MenhirState1\n        | _ ->\n            assert (not _menhir_env._menhir_error);\n            _menhir_env._menhir_error <- true;\n            _menhir_errorcase _menhir_env (Obj.magic _menhir_stack) MenhirState1)\n    | _ ->\n        assert (not _menhir_env._menhir_error);\n        _menhir_env._menhir_error <- true;\n        let _menhir_stack = Obj.magic _menhir_stack in\n        raise _eRR)\n\n# 269 \"<standard.mly>\"\n  \n\n# 529 \"src\/parser.ml\"\nend\n\n(***************************************)\n(***** GENERATED BY OCAMLLEX ***********)\n(***************************************)\n\nmodule Lexer = struct\n# 1 \"src\/lexer.mll\"\n \n  open Parser\n\n  exception Lexing_error of string\n\n  let string_buffer = Buffer.create 64\n\n# 10 \"src\/lexer.ml\"\nlet __ocaml_lex_tables = {\n  Lexing.lex_base =\n   \"\\000\\000\\243\\255\\244\\255\\245\\255\\246\\255\\247\\255\\248\\255\\249\\255\\\n    \\250\\255\\251\\255\\058\\000\\253\\255\\133\\000\\002\\000\";\n  Lexing.lex_backtrk =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\003\\000\\255\\255\\001\\000\\000\\000\";\n  Lexing.lex_default =\n   \"\\001\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\";\n  Lexing.lex_trans =\n   \"\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\013\\000\\013\\000\\013\\000\\013\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\013\\000\\000\\000\\013\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\007\\000\\006\\000\\003\\000\\005\\000\\000\\000\\004\\000\\000\\000\\002\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\009\\000\\000\\000\\008\\000\\000\\000\\000\\000\\\n    \\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\011\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\";\n  Lexing.lex_check =\n   \"\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\013\\000\\013\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\013\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\255\\255\\000\\000\\255\\255\\255\\255\\\n    \\255\\255\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\\n    \\000\\000\\000\\000\\000\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\\n    \\010\\000\\010\\000\\010\\000\\010\\000\\010\\000\\012\\000\\012\\000\\012\\000\\\n    \\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\012\\000\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\000\\000\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\\n    \\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\";\n  Lexing.lex_base_code =\n   \"\";\n  Lexing.lex_backtrk_code =\n   \"\";\n  Lexing.lex_default_code =\n   \"\";\n  Lexing.lex_trans_code =\n   \"\";\n  Lexing.lex_check_code =\n   \"\";\n  Lexing.lex_code =\n   \"\";\n}\n\nlet rec next_token lexbuf =\n   __ocaml_lex_next_token_rec lexbuf 0\nand __ocaml_lex_next_token_rec lexbuf __ocaml_lex_state =\n  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with\n      | 0 ->\n# 16 \"src\/lexer.mll\"\n           ( next_token lexbuf )\n# 142 \"src\/lexer.ml\"\n\n  | 1 ->\nlet\n# 17 \"src\/lexer.mll\"\n              s\n# 148 \"src\/lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 17 \"src\/lexer.mll\"\n                ( try IMM (int_of_string s) with _ -> raise (Lexing_error (Format.sprintf \"constant too large: %s\" s)))\n# 152 \"src\/lexer.ml\"\n\n  | 2 ->\n# 18 \"src\/lexer.mll\"\n        ( EOF )\n# 157 \"src\/lexer.ml\"\n\n  | 3 ->\nlet\n# 19 \"src\/lexer.mll\"\n                id\n# 163 \"src\/lexer.ml\"\n= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in\n# 19 \"src\/lexer.mll\"\n                   ( ARG id )\n# 167 \"src\/lexer.ml\"\n\n  | 4 ->\n# 20 \"src\/lexer.mll\"\n        ( LEFT_BRACK )\n# 172 \"src\/lexer.ml\"\n\n  | 5 ->\n# 21 \"src\/lexer.mll\"\n        ( RIGHT_BRACK )\n# 177 \"src\/lexer.ml\"\n\n  | 6 ->\n# 22 \"src\/lexer.mll\"\n        ( LEFT_PAR )\n# 182 \"src\/lexer.ml\"\n\n  | 7 ->\n# 23 \"src\/lexer.mll\"\n        ( RIGHT_PAR )\n# 187 \"src\/lexer.ml\"\n\n  | 8 ->\n# 24 \"src\/lexer.mll\"\n        ( PLUS )\n# 192 \"src\/lexer.ml\"\n\n  | 9 ->\n# 25 \"src\/lexer.mll\"\n        ( MINUS )\n# 197 \"src\/lexer.ml\"\n\n  | 10 ->\n# 26 \"src\/lexer.mll\"\n        ( MULT )\n# 202 \"src\/lexer.ml\"\n\n  | 11 ->\n# 27 \"src\/lexer.mll\"\n        ( DIV )\n# 207 \"src\/lexer.ml\"\n\n  | 12 ->\nlet\n# 28 \"src\/lexer.mll\"\n         c\n# 213 \"src\/lexer.ml\"\n= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in\n# 28 \"src\/lexer.mll\"\n           ( raise (Lexing_error (Format.sprintf \"illegal character: %c\" c)))\n# 217 \"src\/lexer.ml\"\n\n  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;\n      __ocaml_lex_next_token_rec lexbuf __ocaml_lex_state\n\n;;\n\n# 30 \"src\/lexer.mll\"\n \n\n\n# 228 \"src\/lexer.ml\"\n\nend\n\nmodule Assembly = struct\ntype instruction =\n   | IM of int (* load the constant value n into R0 *)\n   | AR of int (* load the n-th input argument into R0 *)\n   | SW        (* swap R0 and R1 *)\n   | PU        (* push R0 onto the stack *)\n   | PO        (* pop the top value off of the stack into R0 *)\n   | AD        (* add R1 to R0 and put the result in R0 *)\n   | SU        (* subtract R1 from R0 and put the result in R0 *)\n   | MU        (* multiply R0 by R1 and put the result in R0 *)\n   | DI        (* divide R0 by R1 and put the result in R0 *)\n\nlet pp ppf instruction = match instruction with\n   | IM i -> Format.fprintf ppf \"IM %i\" i\n   | AR i -> Format.fprintf ppf \"AR %i\" i\n   | SW -> Format.fprintf ppf \"SW\"\n   | PU -> Format.fprintf ppf \"PU\"\n   | PO -> Format.fprintf ppf \"PO\"\n   | AD -> Format.fprintf ppf \"AD\"\n   | SU -> Format.fprintf ppf \"SU\"\n   | MU -> Format.fprintf ppf \"MU\"\n   | DI -> Format.fprintf ppf \"DI\"\n\nlet to_string (instruction : instruction) : string = match instruction with\n  | IM i -> \"IM \" ^ (string_of_int i)\n  | AR i -> \"AR \" ^ (string_of_int i)\n  | SW -> \"SW\"\n  | PU -> \"PU\"\n  | PO -> \"PO\"\n  | AD -> \"AD\"\n  | SU -> \"SU\"\n  | MU -> \"MU\"\n  | DI -> \"DI\"\nend\n\nopen Ast\n\nmodule type COMPILER = sig\n  val pass1 : string -> ast\n\n  val pass2 : ast -> ast\n\n  val instructions : ast -> Assembly.instruction list\n\n  val codeGen : ast -> string list\n\n  val compile : string -> string list\nend\n\nmodule Compiler : COMPILER = struct\n\n  let pass1 s =\n    let lb = Lexing.from_string s in\n    Parser.program Lexer.next_token lb\n\n\n  let rec pass2 = \n    let op_and_construct ast = match ast with\n      | Imm _ | Arg _ -> failwith \"Not an operation\"\n      | Add _ -> ( + ), fun a1 a2 -> Add(a1, a2)\n      | Sub _ -> ( - ), fun a1 a2 -> Sub(a1, a2)\n      | Mul _ -> ( * ), fun a1 a2 -> Mul(a1, a2)\n      | Div _ -> ( \/ ), fun a1 a2 -> Div(a1, a2)\n    in fun ast -> match ast with\n    | Imm i -> Imm i\n    | Arg i -> Arg i\n    | Add (ast1, ast2) | Sub (ast1, ast2) | Mul (ast1, ast2) | Div (ast1, ast2) -> \n      let op, constructor = op_and_construct ast in\n      match pass2 ast1, pass2 ast2 with\n      | Imm i, Imm j -> Imm (op i j)\n      | ast1, ast2 -> constructor ast1 ast2\n\n  let rec instructions =\n    let open Assembly in\n    let operation ast = match ast with\n      | Imm _ | Arg _ -> failwith \"Not an operation\"\n      | Add _ -> AD\n      | Sub _ -> SU\n      | Mul _ -> MU\n      | Div _ -> DI\n    in fun ast -> match ast with\n    | Imm n -> [IM n]\n    | Arg n -> [AR n]\n    | Add (a1, a2) | Sub (a1, a2) | Mul (a1, a2) | Div (a1, a2) ->\n    (instructions a1) @ PU :: (instructions a2) @ SW :: PO :: [operation ast]\n\n  let codeGen ast = List.map Assembly.to_string (instructions ast)\n\n  let compile code = code |> pass1 |> pass2 |> codeGen\nend","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":217999,"user_id":null,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\nmodule Compiler : COMPILER =\nstruct\n    let pass1 code = \n    let token = tokenize code in\n    (* parse argument list *)\n    let rec parse_args tok res = match tok with \n      | \"]\" :: t -> t, List.rev res\n      | \"[\" :: t -> parse_args t res\n      | h :: t -> parse_args t (h :: res)\n      | _ -> raise (CompilerError \"parse arg list error\") in\n    let prog, args = parse_args token [] in\n    (* find argument index *)\n    let arg_no s =\n      let rec aux s i = function\n        | [] -> raise (CompilerError (\"PARSING ERROR: unbound argument \" ^ s))\n        | h :: t -> if s = h then i else aux s (i+1) t\n      in aux s 0 args in\n    (* process operators *)\n    let process_op factor op = \n      (* we only have bi-operators *)\n      let f1, f2, t = match factor with\n        | f1 :: f2 :: t -> f1, f2, t\n        | _ -> raise (CompilerError (\"PARSING ERROR: not enough operand for \" ^ op)) in \n      let tem = match op with\n        | \"+\" -> Add (f1, f2) \n        | \"-\" -> Sub (f1, f2) \n        | \"*\" -> Mul (f1, f2) \n        | \"\/\" -> Div (f1, f2)\n        | _ -> raise (CompilerError (\"PARSING ERROR: unsupported operator \" ^ op)) in\n      tem :: t in\n    (* process the program inside a pair of parentheses *)\n    let rec process_paren factor ops = match ops with\n      | \")\" :: t -> factor, t\n      | h :: t -> process_paren (process_op factor h) t\n      | _ -> raise (CompilerError \"PARSING ERROR: parentheses mismatch\") in\n    (* process all * and \/ operators on the top of the stack *)\n    let rec process_term factor ops = match ops with \n      | \"*\" :: t -> process_term (process_op factor \"*\") t\n      | \"\/\" :: t -> process_term (process_op factor \"\/\") t\n      | ops -> factor, ops in\n    (* finish traversing the token list, genereate the final ast *)\n    let rec process_all factor ops = \n      match ops with\n      | h :: t -> process_all (process_op factor h) t\n      | [] -> (match factor with\n          | [f] -> f\n          | _ -> raise (CompilerError \"PARSING ERROR: incomplete program\")) in\n    let rec parse p factor ops = match p with\n      | \")\" :: t -> parse t factor (\")\" :: ops)\n      | \"(\" :: t -> let f, o = process_paren factor ops in parse t f o\n      | \"+\" :: t -> let f, o = process_term factor ops in parse t f (\"+\" :: o)\n      | \"-\" :: t -> let f, o = process_term factor ops in parse t f (\"-\" :: o)\n      | \"*\" :: t -> parse t factor (\"*\" :: ops)\n      | \"\/\" :: t -> parse t factor (\"\/\" :: ops)\n      | h :: t -> (match int_of_string_opt h with\n          | None -> parse t ((Arg (arg_no h)) :: factor) ops\n          | Some i -> parse t ((Imm i) :: factor) ops)\n      | [] -> process_all factor ops\n    in parse (List.rev prog) [] []\n\n\n  let rec pass2 ast = \n    match ast with\n    | Add a -> eval ( + ) (fun x -> Add x) a\n    | Sub a -> eval ( - ) (fun x -> Sub x) a\n    | Mul a -> eval ( * ) (fun x -> Mul x) a\n    | Div a -> eval ( \/ ) (fun x -> Div x) a\n    | ast -> ast\n  (* to save some space  *)\n  and eval f ctor (a1, a2) = match (pass2 a1), (pass2 a2) with\n    | Imm i1, Imm i2 -> Imm (f i1 i2)\n    | a1, a2 -> ctor (a1, a2)\n\n\n  (* This can be simplifed if we don't mind some redundant push and pop *)\n  let codeGen ast = \n    let rec aux ast (res, (r0, r1)) = match ast with\n      | Imm i -> let inst = (\"IM \" ^ string_of_int i) in\n        (match (r0, r1) with\n         | (true, _) -> inst :: res, (false, r1)\n         | (false, true) -> inst :: \"SW\" :: res, (false, false)\n         | (false, false) -> inst :: \"PU\" :: \"SW\" :: res, (false, false))\n      | Arg i -> let inst = (\"AR \" ^ string_of_int i) in\n        (match (r0, r1) with\n         | (true, _) -> inst :: res, (false, r1)\n         | (false, true) -> inst :: \"SW\" :: res, (false, false)\n         | (false, false) -> inst :: \"PU\" :: \"SW\" :: res, (false, false))\n      | Add (a1, a2) -> let tem, (_, r1) = aux a2 (aux a1 (res, (r0, r1))) in\n        let inst = if not r1 then [\"AD\"] else [\"AD\"; \"PO\"; \"SW\"] in\n        inst @ tem, (false, true)\n      | Mul (a1, a2) -> let tem, (_, r1) = aux a2 (aux a1 (res, (r0, r1))) in\n        let inst = if not r1 then [\"MU\"] else [\"MU\"; \"PO\"; \"SW\"] in\n        inst @ tem, (false, true)\n      | Sub (a1, a2) -> let tem, (_, r1) = aux a2 (aux a1 (res, (r0, r1))) in\n        let inst = if not r1 then [\"SU\"; \"SW\"] else [\"SU\"; \"PO\"; \"SW\"] in\n        inst @ tem, (false, true)\n      | Div (a1, a2) -> let tem, (_, r1) = aux a2 (aux a1 (res, (r0, r1))) in\n        let inst = if not r1 then [\"DI\"; \"SW\"] else [\"DI\"; \"PO\"; \"SW\"] in\n        inst @ tem, (false, true)\n    in (aux ast ([], (true, true))) |> fst |> List.rev\n\n  let compile code =\n    codeGen(pass2(pass1 code))\nend;;\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":218000,"user_id":null,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\nmodule Compiler : COMPILER =\n  struct\n    let parse (vars, tokenStream) =\n      let rec expr toks = exprR (term toks)\n      and term toks = termR (factor toks)\n      and factor toks = let tok = List.hd toks in\n        if String.equal tok \"(\" then\n          match expr (List.tl toks) with\n            (v, \")\"::toks2) -> (v, toks2)\n          | _ -> raise (CompilerError \"expected: )\")\n        else match List.assoc_opt tok vars with\n          None -> (Imm (int_of_string tok), List.tl toks)\n        | Some n -> (Arg n, List.tl toks)\n      and exprR (lhs, toks) = match toks with\n        \"+\"::t -> let (rhs, t2) = term t in exprR (Add (lhs, rhs), t2)\n      | \"-\"::t -> let (rhs, t2) = term t in exprR (Sub (lhs, rhs), t2)\n      | _ -> (lhs, toks)\n      and termR (lhs, toks) = match toks with\n        \"*\"::t -> let (rhs, t2) = factor t in termR (Mul (lhs, rhs), t2)\n      | \"\/\"::t -> let (rhs, t2) = factor t in termR (Div (lhs, rhs), t2)\n      | _ -> (lhs, toks)\n      in match expr tokenStream with (result, _) -> result\n      \n    let pass1 code = \n      let rec argList vars i toks = match toks with\n        \"]\"::t -> (vars, t)\n      | s::t   -> argList ((s,i)::vars) (i+1) t\n      | _ -> raise (CompilerError \"Unterminated variable list\")\n      in match tokenize code with\n        \"[\"::t -> parse @@ argList [] 0 t\n      | _ -> raise (CompilerError \"expected: arg list\")\n\n    let rec pass2 ast =\n      let rec hasValue ast = match ast with\n        Arg _ -> false\n      | Imm _ -> true\n      | Add (a, b) -> hasValue a && hasValue b\n      | Sub (a, b) -> hasValue a && hasValue b\n      | Mul (a, b) -> hasValue a && hasValue b\n      | Div (a, b) -> hasValue a && hasValue b\n      and constValue ast = match ast with\n        Arg _ -> -1\n      | Imm n -> n\n      | Add (a, b) -> constValue a + constValue b\n      | Sub (a, b) -> constValue a - constValue b\n      | Mul (a, b) -> constValue a * constValue b\n      | Div (a, b) -> constValue a \/ constValue b\n      in if hasValue ast then Imm (constValue ast) else match ast with\n        Add (a, b) -> Add ((pass2 a), (pass2 b))\n      | Sub (a, b) -> Sub ((pass2 a), (pass2 b))\n      | Mul (a, b) -> Mul ((pass2 a), (pass2 b))\n      | Div (a, b) -> Div ((pass2 a), (pass2 b))\n      | x -> x\n      \n    let rec codeGen ast = match ast with\n      Arg n -> [\"AR \" ^ (string_of_int n)]\n    | Imm n -> [\"IM \" ^ (string_of_int n)]\n    | Add (a, b) -> codeBinOp \"AD\" a b\n    | Sub (a, b) -> codeBinOp \"SU\" a b\n    | Mul (a, b) -> codeBinOp \"MU\" a b\n    | Div (a, b) -> codeBinOp \"DI\" a b\n    and codeBinOp op a b = (codeGen a) @ (\"PU\"::(codeGen b)) @ [\"SW\"; \"PO\"; op]\n\n    let compile code =\n      codeGen(pass2(pass1 code))\n      \n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:30","updated_at":"2022-12-30 18:39:30"},{"id":218001,"user_id":1163,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\n\nmodule Compiler : COMPILER =\n  struct\n    type 'a parser = {\n      parse: string list -> ('a * string list) option \n    }\n    \n    let pure a = {parse = fun s -> Some (a, s)}\n\n    let (>>=) p f = {\n      parse = fun x ->\n        match p.parse x with\n        | None -> None\n        | Some (x', s) -> (f x').parse s\n    }\n\n    let (>>) p q = p >>= fun _ -> q\n\n    let empty = {\n      parse = fun _ -> None\n    }\n\n    let (<|>) p q = {\n      parse = fun x ->\n        match p.parse x with\n        | None -> q.parse x\n        | r -> r\n    }\n\n    let many v =\n      let f x = x in\n      let rec many_v x = some_v (f x) <|> pure []\n      and     some_v x = \n            v >>= fun v' ->\n            many_v (f x) >>= fun many_v' ->\n            pure (v'::many_v')\n      in many_v 0\n\n    let item = {\n      parse = fun x ->\n        match x with\n        | [] -> None\n        | (h::t) -> Some (h, t)\n    }\n\n\n    let sat p = \n      item >>= fun s -> \n      if p s then pure s else empty\n\n    let tokenP t = sat (String.equal t)\n\n    let is_alpha = function 'a' .. 'z' | 'A' .. 'Z' -> true | _ -> false\n\n    let is_digit = function '0' .. '9' -> true | _ -> false\n\n    let numP = sat (fun s -> is_digit s.[0])\n\n    let varP = sat (fun s -> is_alpha s.[0])\n\n    let arglstP = many varP\n\n    let rec find x lst =\n      match lst with\n      | [] -> raise (Failure \"Not Found\")\n      | h :: t -> if String.equal x h then 0 else 1 + find x t\n\n    let cons op l r =\n      match op with\n      | \"+\" -> Add (l, r)\n      | \"-\" -> Sub (l, r)\n      | \"*\" -> Mul (l, r)\n      | \"\/\" -> Div (l, r)\n      | _ -> raise (Failure \"Invalid Operator\")\n\n    let rec exprP arglst =\n      termP arglst >>= fun e1 ->\n      exprP' arglst >>= fun e2 ->\n      match e2 with\n      | None -> pure e1\n      | Some e -> pure (e e1)\n    \n    and exprP' arglst = (\n        (tokenP \"+\" <|> tokenP \"-\") >>= fun op ->\n        termP arglst >>= fun e1 ->\n        exprP' arglst >>= fun e2 ->\n        match e2 with\n        | None -> pure (Some (fun e -> cons op e e1))\n        | Some e -> pure (Some (fun e' -> e (cons op e' e1))) \n      ) <|> pure None\n\n    and termP arglst =\n      factorP arglst >>= fun e1 ->\n      termP' arglst >>= fun e2 ->\n      match e2 with\n      | None -> pure e1\n      | Some e -> pure (e e1)\n\n    and termP' arglst =(\n        (tokenP \"*\" <|> tokenP \"\/\") >>= fun op ->\n        factorP arglst >>= fun e1 ->\n        termP' arglst >>= fun e2 ->\n        match e2 with\n        | None -> pure (Some (fun e -> cons op e e1))\n        | Some e -> pure (Some (fun e' -> e (cons op e' e1))) \n      ) <|> pure None\n\n    and factorP arglst = (\n      tokenP \"(\" >>= fun _ ->\n      exprP arglst >>= fun e1 ->\n      tokenP \")\" >>\n      pure e1\n    ) <|> (\n      numP >>= fun s ->\n      pure (Imm (int_of_string s))\n    ) <|> (\n      varP >>= fun s ->\n      pure (Arg (find s arglst))\n    )\n\n    let functionP =\n      tokenP \"[\" >>\n      arglstP >>= fun arglst ->\n      tokenP \"]\" >>\n      exprP arglst\n\n    let pass1 code =\n      match functionP.parse (tokenize code) with\n      | Some (r, []) -> r\n      | _ -> raise (Failure \"parse failed\")\n\n    let pass2' (ast: ast) = \n      match ast with\n      | Add (Imm l, Imm r) -> Imm (l + r)\n      | Sub (Imm l, Imm r) -> Imm (l - r)\n      | Mul (Imm l, Imm r) -> Imm (l * r)\n      | Div (Imm l, Imm r) -> Imm (l \/ r)\n      | _ -> ast\n\n    let rec pass2 (ast: ast) = pass2' (\n      match ast with\n      | Add (l, r) -> Add (pass2 l, pass2 r)\n      | Sub (l, r) -> Sub (pass2 l, pass2 r)\n      | Mul (l, r) -> Mul (pass2 l, pass2 r)\n      | Div (l, r) -> Div (pass2 l, pass2 r)\n      | _ -> ast)\n\n\n    let rec codeGen (ast: ast) =\n      let open Printf in\n      match ast with\n      | Imm n -> [sprintf \"IM %d\" n]\n      | Arg n -> [sprintf \"AR %d\" n]\n      | Add (l, r) -> List.concat [\n        codeGen l;\n        [\"PU\"];\n        codeGen r;\n        [\"SW\"; \"PO\"; \"AD\"]\n      ]\n      | Sub (l, r) -> List.concat [\n        codeGen l;\n        [\"PU\"];\n        codeGen r;\n        [\"SW\"; \"PO\"; \"SU\"]\n      ]\n      | Mul (l, r) -> List.concat [\n        codeGen l;\n        [\"PU\"];\n        codeGen r;\n        [\"SW\"; \"PO\"; \"MU\"]\n      ]\n      | Div (l, r) -> List.concat [\n        codeGen l;\n        [\"PU\"];\n        codeGen r;\n        [\"SW\"; \"PO\"; \"DI\"]\n      ]\n\n\n    let compile code =\n      codeGen(pass2(pass1 code))\n      \n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],_) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218002,"user_id":3346,"body":"let tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list\n  end\n\n\nmodule Compiler : COMPILER =\nstruct\n  let pass1 code =\n    let tokens = tokenize code in\n    let tbl = Hashtbl.create 128 in\n    let rec parse_args tokens cnt =\n      begin match tokens with\n        | \"[\"::rest -> parse_args rest cnt\n        | \"]\"::rest -> ((), rest)\n        | x::rest -> begin Hashtbl.add tbl x cnt;\n            parse_args rest (cnt+1)\n          end\n        | _ -> failwith \"Args incompleted\"\n      end\n    in\n    let rec fparse tokens =\n      let (_, rest_tokens) = parse_args tokens 0 in\n      let (ast, _) = parse_expression rest_tokens in\n      ast\n    and parse_expression tokens =\n      let rec parse_terms acc tokens =\n        begin match tokens with\n          | \"+\"::rests -> let (term1, rest_tokens) = parse_term rests in\n            parse_terms (Add(acc, term1)) rest_tokens\n          | \"-\"::rests -> let (term1, rest_tokens) = parse_term rests in\n            parse_terms (Sub(acc, term1)) rest_tokens\n          | _ -> (acc, tokens)\n        end\n      in\n      let (term0, rest_tokens) = parse_term tokens in\n      parse_terms term0 rest_tokens\n\n    and parse_term tokens =\n      let rec parse_factors acc tokens =\n        begin match tokens with\n          | \"*\"::rests -> let (term1, rest_tokens) = parse_factor rests in\n            parse_factors (Mul(acc, term1)) rest_tokens\n          | \"\/\"::rests -> let (term1, rest_tokens) = parse_factor rests in\n            parse_factors (Div(acc, term1)) rest_tokens\n          | _ -> (acc, tokens)\n        end\n      in\n      let (term0, rest_tokens) = parse_factor tokens in\n      parse_factors term0 rest_tokens\n\n    and parse_factor = function\n      | \"(\"::rest_tokens -> let (exp, rest) = parse_expression rest_tokens in\n        if String.compare (List.hd rest) \")\" != 0 then\n          failwith \"Error parsing expression\"\n        else\n          (exp, List.tl rest)\n      | h::rest -> let c = String.get h 0 in\n        if Char.compare c '0' > 0 && Char.compare c '9' <= 0 then\n          (Imm (int_of_string h), rest)\n        else\n          (Arg (Hashtbl.find tbl h), rest)\n      | _ -> failwith \"Error parsing factor\"\n    in\n    fparse tokens\n\n  let pass2 ast =\n    let reducable = function\n      | Add(Imm _, Imm _)\n      | Mul(Imm _, Imm _)\n      | Sub(Imm _, Imm _)\n      | Div(Imm _, Imm _) -> true\n      | _ -> false\n    in\n    let add(el,er) = Add(el, er) in\n    let sub(el,er) = Sub(el, er) in\n    let mul(el,er) = Mul(el, er) in\n    let div(el,er) = Div(el, er) in\n    let rec opt = function\n        | Imm e -> Imm e\n        | Arg e -> Arg e\n        | Add(el, er) -> opt_binary(add, (+),  el, er)\n        | Mul(el, er) -> opt_binary(mul, ( * ), el, er)\n        | Sub(el, er) -> opt_binary(sub, (-), el, er)\n        | Div(el, er) -> opt_binary(div, (\/), el, er)\n    and opt_binary(cons, op, el, er) =\n      begin match (el, er) with\n        | (Imm el, Imm er) -> Imm(op el er)\n        | _ -> let ast' = cons(opt el, opt er) in\n          if reducable ast' then\n            opt ast'\n          else\n            ast'\n      end\n    in opt ast\n\n  let codeGen ast =\n    let rec code_gen codes = function\n      | Imm e -> (\"IM \"^(string_of_int e)) :: codes\n      | Arg n -> (\"AR \"^(string_of_int n)) :: codes\n      | Add(el, er) -> gen_binary codes (\"AD\", el, er)\n      | Mul(el, er) -> gen_binary codes (\"MU\", el, er)\n      | Sub(el, er) -> gen_binary codes (\"SU\", el, er)\n      | Div(el, er) -> gen_binary codes (\"DI\", el, er)\n    and gen_binary codes (op, el, er) =\n      let lcodes = code_gen codes el in\n      let rcodes = code_gen (\"PU\"::lcodes) er in\n      op::\"PO\"::\"SW\"::rcodes\n    in\n    List.rev (code_gen [] ast)\n\n\n  let compile code =\n    codeGen(pass2(pass1 code))\n\nend\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218003,"user_id":null,"body":"\nlet tokenize code =\n  let rec explode string =\n    if String.length string = 0 then []\n    else [String.sub string 0 1] @\n           explode (String.sub string 1 ((String.length string) - 1))\n  in\n  let specialChars =\n    [\n      \"[\"; \"]\"; \"-\"; \"+\"; \"*\"; \"\/\"; \"(\"; \")\"\n    ]\n  in\n  let nonSpecialHelper = function\n    | \"\" -> []\n    | str -> [str]\n  in\n  let rec tokenizeHelper = function\n    | [],currentItem, tokens ->\n       tokens @ (nonSpecialHelper currentItem)\n    | \" \"::lst, currentItem, tokens ->\n       tokenizeHelper(\n           lst,\"\",\n           tokens @ nonSpecialHelper currentItem)\n    | item::lst, currentItem, tokens ->\n       if List.mem item specialChars then\n         tokenizeHelper(\n             lst, \"\",\n             tokens @ nonSpecialHelper currentItem @ [item])\n       else\n         tokenizeHelper(lst, currentItem ^ item,tokens)\n  in\n  tokenizeHelper(explode code, \"\", [])\n\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n\n\n  \nexception CompilerError of string\n\nmodule type COMPILER =\n  sig\n    val pass1: string -> ast\n    val pass2: ast -> ast\n    val codeGen: ast -> string list\n    val compile: string -> string list \n  end\n\n\nmodule Compiler : COMPILER =\n  struct\n     \n    exception Noexp of string\n\nlet is_Imm str = \n\tlet rec aux s c =\n\t\tlet ls =  String.length s\n\t\tin\n\t\t\tif ls <0 then true\n\t\t\telse \n\t\t\t\tif (Char.code c) >= (Char.code '0') && (Char.code c) <= (Char.code '9') then \n\t\t\t\t\tif ls = 0 then true\n\t\t\t\t\telse aux (String.sub s 1 ((String.length s)-1)) (String.get s 0) \n\t\t\t\telse false\n\tin \t\n\t\tif String.length str <=0 then false else aux str '0'\n\nlet is_Arg argl str = List.mem str argl\n\n\nlet split_codelist lc = \n\tlet rec aux l ((arg,exp) as ret) = \n\t\tmatch l with\n\t\t\t|[]-> ret\n\t\t\t|h::t -> \n\t\t\t\tif h = \"]\" then (arg,t)\n\t\t\t\telse aux t (h::arg,exp)\n\tand aux1 (x,y) = (List.rev x,y)\n\tin\n\t\taux1 (aux (List.tl lc) ([],[]))\n\n\nlet listnth l x=\n\tlet rec aux ll xx n =\n\t\tmatch ll with\n\t\t\t|[] -> -1\n\t\t\t|h::t when h = xx -> n\n\t\t\t|h::t -> aux t xx (n+1)\n\tin \n\t\taux l x 0\n\nexception Imposs of string\n\nlet rec aux_AddSub expl expr lv l=\n\tmatch expr with\n\t\t|[] -> l@[expl]\n\t\t|h::t when h = \"(\" -> aux_AddSub (expl@[h]) t (lv+1) l\n\t\t|h::t when h = \")\" -> aux_AddSub (expl@[h]) t (lv-1) l\n\t\t|h::t when (h = \"+\" || h = \"-\") && lv = 0 -> aux_AddSub [] t lv (l@[expl]@[[h]])\n\t\t|h::t ->  aux_AddSub (expl@[h]) t lv l\n\t;;\n\nlet rec aux_MulDiv expl expr lv l=\n\tmatch expr with\n\t\t|[] -> l@[expl]\n\t\t|h::t when h = \"(\" -> aux_MulDiv (expl@[h]) t (lv+1) l\n\t\t|h::t when h = \")\" -> aux_MulDiv (expl@[h]) t (lv-1) l\n\t\t|h::t when (h = \"*\" || h = \"\/\") && lv = 0 -> aux_MulDiv [] t lv (l@[expl]@[[h]])\n\t\t|h::t ->  aux_MulDiv (expl@[h]) t lv l\n\t;;\n\nlet rec aux_ast argl exp =\n\tlet addsub = List.rev (aux_AddSub [] exp 0 []) in\n\tlet rec aux_ast1 argl l =\n\t\tmatch l with\n\t\t\t|[] -> raise (Imposs(\"Not possible aux_ast1? []\"))\n\t\t\t|[[x]] when is_Imm x -> Imm((int_of_string x))\n\t\t\t|[[x]] when is_Arg argl x -> Arg((listnth argl x))\n\t\t\t|[e] -> \n\t\t\t\tlet muldiv = List.rev (aux_MulDiv [] e 0 []) in\n\t\t\t\t\tlet rec aux_ast2 argl lm=\n\t\t\t\t\t\tmatch lm with \n\t\t\t\t\t\t\t|[] -> raise (Imposs(\"Not possible aux_ast1? []\"))\n\t\t\t\t\t\t\t|[[x]] when is_Imm x -> Imm((int_of_string x))\n\t\t\t\t\t\t\t|[[x]] when is_Arg argl x -> Arg((listnth argl x))\n\t\t\t\t\t\t\t|f1::op::f2::t when op = [\"*\"] -> Mul(aux_ast2 argl (f2::t), aux_ast argl f1)\n\t\t\t\t\t\t\t|f1::op::f2::t when op = [\"\/\"] -> Div(aux_ast2 argl (f2::t), aux_ast argl f1)\n\t\t\t\t\t\t\t|[e] -> \n\t\t\t\t\t\t\t\tif (List.hd e) = \"(\" then aux_ast argl (List.tl (List.rev (List.tl (List.rev e))))\n\t\t\t\t\t\t\t\telse raise (Imposs(\"Not possible aux_ast2? e\"))\n\t\t\t\t\t\t\t|_ -> raise (Imposs(\"Not possible aux_ast2? _\"))\n\t\t\t\t\tin aux_ast2 argl muldiv\n\t\t\t|f1::op::f2::t when op = [\"+\"] -> Add(aux_ast1 argl (f2::t), aux_ast argl f1)\n\t\t\t|f1::op::f2::t when op = [\"-\"] -> Sub(aux_ast1 argl (f2::t), aux_ast argl f1)\n\t\t\t|_ -> raise (Imposs(\"Not possible aux_ast1? _\"))\n\tin aux_ast1 argl addsub;;\n\nlet pass1 code =\n\tlet (argl,exp) = split_codelist (tokenize code) \n\tin\n\t\taux_ast argl exp\n\n\nlet is_Immast ast =\n\t\tmatch ast with \n\t\t\t|Imm(x) -> true\n\t\t\t|_ -> false\n\nlet rec pass2 ast =\n\tlet aux x y op =\n\t\tlet f1 = pass2 x and f2 = pass2 y\n\t\tin\n\t\tif (is_Immast f1) && (is_Immast f2) then\n\t\t\tlet op_aux1 (Imm(a)) (Imm(b)) = function\n\t\t\t\t|'+' -> Imm((a+b))\n\t\t\t\t|'-' -> Imm((a-b))\n\t\t\t\t|'*' -> Imm((a*b))\n\t\t\t\t|'\/' -> Imm((a\/b))\n\t\t\t\t| _  -> raise (Imposs(\"Not possible op_aux1 in pass2\"))\n\t\t\tin op_aux1 f1 f2 op\n\t\telse \n\t\t\tlet op_aux2 a b = function\n\t\t\t\t|'+' -> Add(a,b)\n\t\t\t\t|'-' -> Sub(a,b)\n\t\t\t\t|'*' -> Mul(a,b)\n\t\t\t\t|'\/' -> Div(a,b)\n\t\t\t\t| _  -> raise (Imposs(\"Not possible op_aux2 in pass2\"))\n\t\t\tin op_aux2 f1 f2 op\n\tin\n\t\tmatch ast with\n\t\t\t|Add(x,y) -> aux x y '+'\n\t\t\t|Sub(x,y) -> aux x y '-'\n\t\t\t|Mul(x,y) -> aux x y '*'\n\t\t\t|Div(x,y) -> aux x y '\/'\n\t\t\t|t -> t\n      \n    let rec codeGen ast =\n\t    match ast with\n\t    \t|Imm(x) -> [Printf.sprintf \"IM %d\" x]\n\t    \t|Arg(x) -> [Printf.sprintf \"AR %d\" x]\n\t\t    |Add(x,y) -> (codeGen y)@[\"PU\"]@(codeGen x)@[\"SW\";\"PO\";\"AD\"]\n\t\t    |Sub(x,y) -> (codeGen y)@[\"PU\"]@(codeGen x)@[\"SW\";\"PO\";\"SW\";\"SU\"]\n\t\t    |Mul(x,y) -> (codeGen y)@[\"PU\"]@(codeGen x)@[\"SW\";\"PO\";\"MU\"]\n\t\t    |Div(x,y) -> (codeGen y)@[\"PU\"]@(codeGen x)@[\"SW\";\"PO\";\"SW\";\"DI\"]\n\t\n    let compile code =\n      codeGen(pass2(pass1 code))\n      \n  end\n\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 \/ !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"}],"55a4de202949dca9bd000088":[{"id":218004,"user_id":null,"body":"module type POSTFIX = sig\n  val begin_ : (unit -> 'a) -> 'a\n\n\tval push : unit -> int -> (unit -> 'a) -> 'a\n\n\tval add : unit -> (unit -> 'a) -> 'a\n\n\tval end_ : unit -> int\nend\n\nmodule Postfix : POSTFIX = struct\n  let stack = ref []\n\n\tlet begin_ f = f ()\n\n\tlet push () i f = stack := i :: !stack ; f ()\n\n\tlet add () f = match !stack with\n\t\t| a :: b :: tail -> stack := (a+b) :: tail ; f ()\n\t\t| _ -> failwith \"Empty stack\"\n\n\tlet end_ () = List.hd !stack\nend\n\ninclude Postfix","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218005,"user_id":null,"body":"exception Exception of string\n\nlet begin_ f = f [];;\n\nlet push stack lit next = next (lit :: stack);;\n\nlet add stack next = match stack with\n  | [] -> raise (Exception \"adding empty stack\")\n  | [x] -> raise (Exception \"adding single element stack\")\n  | h1 :: h2 :: t -> next (h1 + h2 :: t)\n;;\n\nlet end_ stack = match stack with\n  | [] -> raise (Exception \"invalid program\")\n  | t :: h -> t\n;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218006,"user_id":null,"body":"exception Exception of string\n\nlet begin_ f = f [] \n\nlet push stack n f = f (n::stack)  \n\nlet add stack f = match stack with\n  | x::y::s -> f ((x+y)::stack)\n  | _ -> failwith \"Not enough element in the stack\"\n\nlet end_ stack = match stack with\n  | [] -> failwith \"Empty stack\"\n  | x::_ -> x","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218007,"user_id":null,"body":"let begin_ f = f []\n\nlet push ls = fun x f -> f (x :: ls)\n\nlet [@warning \"-8\"] add (x :: y :: ls) = fun f -> f (x + y :: ls)\n\nlet [@warning \"-8\"] end_ (x :: _) = x","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218008,"user_id":98,"body":"let begin_ f = f [] ;;\nlet push list x f = f (x :: list);;\nlet add list f = f (((List.nth list 0) + (List.nth list 1)) :: (List.tl (List.tl list)));;\nlet end_ list = List.hd list;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218009,"user_id":null,"body":"exception Exception of string\n\nlet begin_ f = f []\nlet push l n f = f (n::l)\nlet add l f =\n  match l with\n  | x1::x2::tl -> f ((x1+x2)::tl)\n  | _ -> raise (Exception \"Empty stack\")\nlet end_ = function\n  | x::_ -> x\n  | _ -> 0","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218010,"user_id":null,"body":"exception Exception of string\n\nlet begin_ f = [] |> f\n\nlet push stack = fun x -> fun f -> x::stack |> f\n\nlet add stack = \n  match stack with  \n    h1 :: h2 :: t -> fun f -> (h1 + h2) :: t |> f\n  | _ -> failwith \"Stack too small for addition\"\n\nlet end_ stack = match stack with\n    h::t -> h\n  | [] -> failwith \"Can't end_ with empty stack\"","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218011,"user_id":null,"body":"exception Exception of string\n\nlet begin_ command = command []\n\nlet push stack x command = command (x :: stack)\n\nlet add stack command = match stack with\n  | x :: y :: rest -> command ((x + y) :: rest)\n  | _ -> raise (Exception \"Too few elements in stack to add.\")\n\nlet end_ = function\n  | [] -> raise (Exception \"Stack is empty.\")\n  | x :: _ -> x\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218012,"user_id":null,"body":"exception Exception of string\n\nlet begin_ f = f []\n\nlet push xs x k = k (x :: xs)\n\nlet add (x :: y :: xs) k = k ((x + y) :: xs)\n\nlet end_ (x :: _) = x\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218013,"user_id":null,"body":"\nlet begin_ (k: int list -> 'a): 'a =\n  k []\n\nlet push (s: int list) (x: int) (k: int list -> 'a) : 'a =\n  k (x :: s)\n\nlet add (s: int list) (k: int list -> 'a) : 'a =\n  match s with\n  | x1 :: x2 :: t -> k (x1 + x2 :: t)\n  | _ -> assert false\n\nlet end_ (s: int list) : int =\n  List.hd s\n  \n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"}],"594ecda58e7871156c00006f":[{"id":218014,"user_id":1084,"body":"(* Let's implement laziness!\n * A lazy value can be implemented as a closure (also known as thunk),\n * and getting a strict value out of it is just function evaluation. *)\n\n(* Note that you should not use reference unless we explicitly ask for it.\n * Also, whenever you construct a lazy value, make sure to defer\n * all calculation as late as possible *)\nmodule type Lazy =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t\nend;;\n\nmodule type LazyMin =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\nend;;\n\nmodule LazyImpl (LM: LazyMin): Lazy with type 'a t = 'a LM.t =\nstruct\n  include LM\n  let map f a = mk (fun _ -> f (get a))\n  let return a = mk (fun _ -> a)\n  let join a = mk (fun _ -> get (get a))\n  let bind m a = join (map m a)\n  let (>>=) a m = bind m a\n  let tie f =\n    let tem = ref (mk (fun _ -> failwith \"uninitialize\")) in\n      tem := mk (fun _ -> get (f (!tem))); !tem\nend;;\n\nmodule LazyThunk: Lazy with type 'a t = unit -> 'a = LazyImpl(\nstruct\n  type 'a t = unit -> 'a\n  let mk f = f\n  let get f = f ()\nend);;\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyOption:\n  Lazy with type 'a t = 'a option ref * (unit -> 'a) = LazyImpl(\nstruct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk f = (ref None, f)\n  let get (o, f) =\n    match !o with\n      None -> let ret = f () in o := Some ret; ret\n    | Some x -> x\nend);;\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = LazyImpl(\nstruct\n  type 'a t = (unit -> 'a) ref\n  let mk = ref\n  let get x = let ret = (!x)() in x := (fun _ -> ret); ret\nend);;\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream (*fib = tie fib_aux*)\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  let rec mk f = Stream (L.mk f)\n  let hd (Stream x) = fst (L.get x)\n  let tl (Stream x) = mk (fun _ ->\n    match snd (L.get x) with Stream s -> L.get s)\n  let rec gen f a = mk (fun _ ->\n    (L.get a, gen f (L.mk (fun _ -> f (L.get a)))))\n  let rec map f x = mk (fun _ -> (f (hd x), map f (tl x)))\n  let rec zip l r = mk (fun _ -> ((hd l, hd r), zip (tl l) (tl r)))\n  let zipWith f l r = map f (zip l r)\n  let rec takeWhile p x = if p (hd x) then hd x :: takeWhile p (tl x) else []\n  let rec app = function\n    [] -> (fun x -> x)\n  | (a :: ax) -> (fun x -> mk (fun _ -> (a, (app ax x))))\n  let fib_aux self =\n    app [0; 1] (zipWith (fun (l, r) -> l + r) self (tl self))\n  let join ss =\n    let rec fold l s =\n      mk (fun () -> L.get (match (app (List.map hd l) (fold (hd s :: List.map tl l) (tl s))) with\n        Stream s -> s)) \n    in fold [] ss\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218015,"user_id":106,"body":"(* Let's implement laziness!\n * A lazy value can be implemented as a closure (also known as thunk),\n * and getting a strict value out of it is just function evaluation. *)\n\n(* Note that you should not use reference unless we explicitly ask for it.\n * Also, whenever you construct a lazy value, make sure to defer\n * all calculation as late as possible *)\nmodule type Lazy = sig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t \nend;;\n\nmodule LazyThunk: Lazy with type 'a t = unit -> 'a = struct\n  type 'a t = unit -> 'a\n  let mk t = t\n  let get t = t ()\n  let map f v = mk (fun () -> f(get v))\n  let return v = mk (fun () -> v)\n  let join tt = mk (fun () -> get (get tt))\n  let bind f t = mk (fun () -> get (f(get t)))\n  let (>>=) t f = bind f t\n  let rec tie f = let rec t = (fun () -> get (f t)) in t (* let rec t = mk (fun () -> get (f t)) in t *)\nend;;\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyOption: Lazy with type 'a t = 'a option ref * (unit -> 'a) = struct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk t = (ref None, t)\n  let get t = match !(fst t) with\n    | Some v -> v\n    | None -> let v = (snd t)() in fst t := Some v; v\n  let map f t = mk (fun () -> f(get t))\n  let return v = mk (fun () -> v)\n  let join tt = mk (fun () -> get (get tt))\n  let bind f t = mk (fun () -> get (f(get t)))\n  let (>>=) t f = bind f t\n  let tie f = let rec t = (ref None, fun () -> get (f t)) in t (* let rec t = mk (fun () -> get (f t)) in t *)\nend;;\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = struct\n  type 'a t = (unit -> 'a) ref\n  let mk t = ref t\n  let get t = let v = (!t)() in t := (fun () -> v); v\n  let map f t = mk (fun () -> f(get t))\n  let return v = mk (fun () -> v)\n  let join tt = mk (fun () -> get (get tt))\n  let bind f t = mk (fun () -> get (f(get t)))\n  let (>>=) t f = bind f t\n  let tie f = let rec t = ref (fun () -> get (f t)) in t (* let rec t = mk (fun () -> get (f t)) in t *)\nend;;\n\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig = sig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream (* Be as lazy as possible. *)\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L = struct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  let unStream (Stream s) = s (* deconstructor *)\n  let hd (Stream s) = fst (L.get s)\n  let mk f = Stream (L.mk f)\n  let tl (Stream s) = mk (fun () -> L.get (unStream (snd (L.get s))))\n  let rec gen f t = mk (fun () -> (L.get t, gen f (L.map f t)))\n  let rec map f s = mk (fun () -> (f (hd s), map f (tl s)))\n  let rec zip a b = mk (fun () -> ((hd a,hd b), zip (tl a) (tl b)))\n  let rec zipWith f a b = mk (fun () -> (f (hd a, hd b), zipWith f (tl a) (tl b)))\n  let rec takeWhile p s = match p (hd s) with\n    | true -> (hd s) :: (takeWhile p (tl s))\n    | false -> []\n  let app l s = let rec app' = fun l' s' -> match l' with\n    | [] -> s'\n    | hd::tl -> app' tl (mk (fun () -> (hd, s')))\n  in app' (List.rev l) s\n  let fib_aux s = app [0;1] (zipWith (fun (a,b) -> a+b) s (tl s))\n  let join ss = let rec fold l s = mk (fun () -> L.get (unStream (app (List.map hd l) (fold (hd s :: List.map tl l) (tl s))))) in fold [] ss\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218016,"user_id":106,"body":"(* Let's implement laziness!\n * A lazy value can be implemented as a closure (also known as thunk),\n * and getting a strict value out of it is just function evaluation. *)\n\n(* Note that you should not use reference unless we explicitly ask for it.\n * Also, whenever you construct a lazy value, make sure to defer\n * all calculation as late as possible *)\nmodule type Lazy = sig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t \nend;;\n\nmodule LazyThunk: Lazy with type 'a t = unit -> 'a = struct\n  type 'a t = unit -> 'a\n  let mk t = t\n  let get t = t ()\n  let map f v = mk (fun () -> f(get v))\n  let return v = mk (fun () -> v)\n  let join tt = mk (fun () -> get (get tt))\n  let bind f t = mk (fun () -> get (f(get t)))\n  let (>>=) t f = bind f t\n  let rec tie f = let rec t = (fun () -> f t ()) in t\nend;;\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyOption: Lazy with type 'a t = 'a option ref * (unit -> 'a) = struct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk t = (ref None, t)\n  let get t = match !(fst t) with\n    | Some v -> v\n    | None -> let v = (snd t)() in fst t := Some v; v\n  let map f t = match !(fst t) with\n    | Some v -> mk (fun () -> f v)\n    | None -> mk (fun () -> f((snd t)()))\n  let return v = mk (fun () -> v)\n  let join tt = mk (fun () -> get (get tt))\n  let bind f t = mk (fun () -> get (f(get t)))\n  let (>>=) t f = bind f t\n  let tie f = let rec t = (ref None, fun () -> get (f t)) in t\nend;;\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = struct\n  type 'a t = (unit -> 'a) ref\n  let mk t = ref t\n  let get t = let v = (!t)() in t := (fun () -> v); v\n  let map f t = mk (fun () -> f(get t))\n  let return v = mk (fun () -> v)\n  let join tt = mk (fun () -> get (get tt))\n  let bind f t = mk (fun () -> get (f(get t)))\n  let (>>=) t f = bind f t\n  let tie f = let rec t = ref (fun () -> get (f t)) in t\nend;;\n\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig = sig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream (* Be as lazy as possible. *)\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L = struct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  let unStream (Stream s) = s (* deconstructor *)\n  let hd (Stream s) = fst (L.get s)\n  let mk f = Stream (L.mk f)\n  let tl (Stream s) = mk (fun () -> L.get (unStream (snd (L.get s))))\n  let rec gen f t = mk (fun () -> (L.get t, gen f (L.map f t)))\n  let rec map f s = mk (fun () -> (f (hd s), map f (tl s)))\n  let rec zip a b = mk (fun () -> ((hd a,hd b), zip (tl a) (tl b)))\n  let rec zipWith f a b = mk (fun () -> (f (hd a, hd b), zipWith f (tl a) (tl b)))\n  let rec takeWhile p s = match p (hd s) with\n    | true -> (hd s) :: (takeWhile p (tl s))\n    | false -> []\n  let app l s = let rec app' = fun l' s' -> match l' with\n    | [] -> s'\n    | hd::tl -> app' tl (mk (fun () -> (hd, s')))\n  in app' (List.rev l) s\n  let fib_aux s = app [0;1] (zipWith (fun (a,b) -> a+b) s (tl s))\n  let join ss = let rec fold l s = mk (fun () -> L.get (unStream (app (List.map hd l) (fold (hd s :: List.map tl l) (tl s))))) in fold [] ss\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218017,"user_id":60,"body":"module type LazyCore =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\nend;;\n\nmodule type Lazy =\nsig\n  include LazyCore\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind: ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  val tie: ('a t -> 'a t) -> 'a t\nend;;\n\nmodule LazyMake (LC: LazyCore): Lazy with type 'a t = 'a LC.t =\nstruct\n  include LC\n  let map f la = LC.mk (fun () -> LC.get la |> f)\n  let return a = LC.mk (fun () -> a)\n  let join lla = LC.mk (fun () -> lla |> LC.get |> LC.get)\n  let bind f la = LC.mk (fun () -> LC.get la |> f |> LC.get)\n  let (>>=) la f = bind f la\n  let tie f = let g = ref @@ LC.mk (fun () -> assert false) in\n              g := LC.mk (fun () -> !g |> f |> LC.get); !g\nend;;\n\nmodule LazyThunkCore: LazyCore with type 'a t = unit -> 'a =\nstruct\n  type 'a t = unit -> 'a\n  let mk f = f\n  let get f = f ()\nend;;\n\nmodule LazyOptionCore: LazyCore with type 'a t = 'a option ref * (unit -> 'a) =\nstruct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk f = (ref None, f)\n  let get (ox, f) = match !ox with\n                  | None -> let x = f () in ox := Some x; x\n                  | Some x -> x\nend;;\n\nmodule LazyTaglessCore: LazyCore with type 'a t = (unit -> 'a) ref =\nstruct\n  type 'a t = (unit -> 'a) ref\n  let mk f = ref f\n  let get f = let x = !f () in f := (fun () -> x); x\nend;;\n\nmodule LazyThunk   = LazyMake(LazyThunkCore);;\nmodule LazyOption  = LazyMake(LazyOptionCore);;\nmodule LazyTagless = LazyMake(LazyTaglessCore);;\n\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  let hd (Stream lp) = L.get lp |> fst\n  let tl (Stream lp) = let f (_, Stream x) = x in Stream (L.bind f lp)\n  let mk f = Stream (L.mk f)\n  let rec gen f la = let g x = (x, L.mk (fun () -> f x) |> gen f) in Stream (L.map g la)\n  let rec map f (Stream lp) = let g (x, xs) = (f x, map f xs) in Stream (L.map g lp)\n  let rec zip (Stream lpx) (Stream lpy) = let g (x, xs) = L.map (fun (y, ys) -> ((x, y), zip xs ys)) lpy in Stream (L.bind g lpx)\n  let zipWith f xs ys = zip xs ys |> map f\n  let rec takeWhile p xs = let x = hd xs in if p x then x :: takeWhile p (tl xs) else []\n  let rec app xs ys = match xs with | [] -> ys | x :: xs' -> mk (fun () -> (x, app xs' ys))\n  let fib_aux xs = zipWith (fun (x, y) -> x + y) xs (tl xs) |> app [0; 1]\n  let rec diag (Stream lp) = let f (xs, xss) = ([hd xs], zipWith (fun (y, ys) -> y :: ys) (tl xs) (diag xss)) in Stream (L.map f lp)\n  let rec join' (Stream lp) = let f (xs, xss) = match app xs (join' xss) with Stream x -> x in Stream (L.bind f lp)\n  let join xss = diag xss |> join'\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218018,"user_id":null,"body":"(* Let's implement laziness!\n * A lazy value can be implemented as a closure (also known as thunk),\n * and getting a strict value out of it is just function evaluation. *)\n\n(* Note that you should not use reference unless we explicitly ask for it.\n * Also, whenever you construct a lazy value, make sure to defer\n * all calculation as late as possible *)\nmodule type Lazy =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val ( >>= ): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t \nend;;\n\nmodule LazyThunk: Lazy with type 'a t = unit -> 'a =\nstruct\n  type 'a t = unit -> 'a\n  let mk x = x\n  let get x = x ()\n  let map f x () = f @@ get x\n  let return x () = x\n  let join x = mk (fun () -> get @@ get x)\n  let bind f x = mk (fun () -> get (f @@ get x))\n  let ( >>= ) x f = bind f x\n  let rec tie f = mk (fun () -> get @@ f @@ tie f)\nend;;\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyOption: Lazy with type 'a t = 'a option ref * (unit -> 'a) =\nstruct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk f = ref None, f\n  let get = function\n    | {contents = Some x}, _ -> x\n    | ref_none, f ->\n        let x = f () in\n        ref_none := Some x;\n        x\n  let map f x = mk (fun () -> f @@ get x)\n  let return x = ref (Some x), (fun () -> x)\n  let join x = mk (fun () -> get @@ get x)\n  let bind f x = mk (fun () -> get (f @@ get x))\n  let ( >>= ) x f = bind f x\n  let rec tie f = mk (fun () -> get @@ f @@ tie f)\nend;;\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = \nstruct\n  type 'a t = (unit -> 'a) ref\n  let mk f = ref f\n  let get f =\n    let x = !f () in\n    f := (fun () -> x);\n    x\n  let map f x = mk (fun () -> f @@ get x)\n  let return x = mk (fun () -> x)\n  let join x = mk (fun () -> get @@ get x)\n  let bind f x = mk (fun () -> get @@ f @@ get x)\n  let ( >>= ) x f = bind f x\n  let rec tie f = mk (fun () -> get @@ f @@ tie f)\nend;;\n\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream (* Be as lazy as possible. *)\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream (*fib = tie fib_aux*)\n  (*traverse evey element of 'a stream that is in 'a stream 'stream*)\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  \n  type 'a stream = Stream of ('a * 'a stream) L.t\n  \n  let hd (Stream s) =\n    match L.get s with\n      h, _ -> h\n  \n  let tl (Stream s) =\n    Stream (L.mk (fun () ->\n      match L.get s with\n        _, Stream t ->\n          match L.get t with\n            tail -> tail))\n  \n  let mk f = Stream (L.mk f)\n  \n  let rec gen f x =\n    Stream (L.mk (fun () ->\n      (L.get x, gen f ((L.map f) x))))\n  \n  let rec map f (Stream s) =\n    Stream (L.mk (fun () ->\n      match L.get s with\n        h, t -> (f h, map f t)))\n  \n  let rec zip (Stream s1) (Stream s2) =\n    Stream (L.mk (fun () ->\n      match L.get s1, L.get s2 with\n        (h1, t1), (h2, t2) -> ((h1, h2), zip t1 t2)))\n  \n  let rec zipWith f (Stream s1) (Stream s2) =\n    Stream (L.mk (fun () ->\n      match L.get s1, L.get s2 with\n        (h1, t1), (h2, t2) -> (f (h1, h2), zipWith f t1 t2)))\n  \n  let rec takeWhile f (Stream s) =\n    match L.get s with\n      h, t -> if f h then h :: takeWhile f t else []\n  \n  let rec app l stream = match l with\n    | [] -> stream\n    | h :: t -> Stream (L.mk (fun () -> (h, app t stream)))\n  \n  let rec lazy_app l lazy_stream = match l with\n    | [] -> L.get lazy_stream\n    | h :: t -> Stream (L.mk (fun () -> (h, lazy_app t lazy_stream)))\n  \n  let counter = ref (0, 1)\n  let fib_aux x =\n    match !counter with a, b -> counter := (b, a + b);\n    app [a] x\n  \n  let join s =\n    let rec loop opened others =\n      lazy_app (List.map hd opened) (L.mk (fun () -> (loop (hd others :: List.map tl opened) (tl others))))\n    in loop [] s\nend;;\n","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218019,"user_id":10,"body":"(* Let's implement laziness!\n * A lazy value can be implemented as a closure (also known as thunk),\n * and getting a strict value out of it is just function evaluation. *)\n\n(* Note that you should not use reference unless we explicitly ask for it.\n * Also, whenever you construct a lazy value, make sure to defer\n * all calculation as late as possible *)\nmodule type Lazy =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t \nend;;\n\nmodule LazyThunk: Lazy with type 'a t = unit -> 'a =\nstruct\n  type 'a t = unit -> 'a\n  (* these two varies per implementation *)\n  let mk a = a\n  let get t = t ()\n  \n  (* the rest are invariant and can be generalized over all lazy implementations with mk and get *)\n  let map f ta = mk (fun () -> f (get ta)) (* map f ta = f(ta ()) *)\n  let return a = mk (fun () -> a) (* return a () = a *)\n  let join tta = mk (fun () -> get (get tta)) (* join tta = tta () *)\n  let bind f ta = join (map f ta) (* bind f ta = f (ta ()) *)\n  let (>>=) ta f = join (map f ta) (* ta >>= f = f (ta ()) *)\n  let tie f =\n    let cell = ref (mk (fun () -> failwith \"bottom\")) in\n    let v = mk (fun () -> get (f !cell)) in\n      (* Landin's knot *)\n      (* fun () -> get xxx = xxx in this case, but cannot be generalized *)\n      (* over implementations where 'a t != unit -> 'a *)\n      cell := v; (* cell := get (f !cell) *)\n      v\nend;;\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyOption: Lazy with type 'a t = 'a option ref * (unit -> 'a) =\nstruct\n  type 'a t = 'a option ref * (unit -> 'a)\n  (* these two varies per implementation *)\n  let mk a = (ref None, a)\n  let get (ta, supplier) = match !ta with\n    (* ta empty; populate with Some (supplier ()) *)\n    (* TODO: remember to bloody use 'let' since its oCaMl and func calls *)\n    (* with same value yields DIFFERENT RESULTS DAMMIT *)\n    | None -> let v = supplier () in ta := Some v; v (* ta := supplier (); supplier () *)\n    (* ta cached; just return a *)\n    | Some a -> a\n  \n  (* the rest are invariant and can be generalized over all lazy implementations with mk and get *)\n  let map f ta = mk (fun () -> f (get ta))\n  let return a = mk (fun () -> a)\n  let join tta = mk (fun () -> get (get tta))\n  let bind f ta = join (map f ta)\n  let (>>=) ta f = join (map f ta)\n  let tie f =\n    let cell = ref (mk (fun () -> failwith \"bottom\")) in\n    let v = mk (fun () -> get (f !cell)) in\n      (* Landin's knot *)\n      (* fun () -> get xxx = xxx in this case, but cannot be generalized *)\n      (* over implementations where 'a t != unit -> 'a *)\n      cell := v; (* cell := get (f !cell) *)\n      v\nend;;\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = \nstruct\n  type 'a t = (unit -> 'a) ref\n  (* these two varies per implementation *)\n  let mk a = ref a\n  \n  (* a cache andd a supplier is functionally the same! *)\n  (* supplier: sup := \\() -> sup () *)\n  (* cache: cac := cac \\() -> cac () *)\n  (* just like simulating infinite Brainfuck tape in LC; Kacarott would be proud ;) *)\n  let get ta = let v = (!ta)() in ta := (fun () -> v); v\n  \n  (* the rest are invariant and can be generalized over all lazy implementations with mk and get *)\n  let map f ta = mk (fun () -> f (get ta))\n  let return a = mk (fun () -> a)\n  let join tta = mk (fun () -> get (get tta))\n  let bind f ta = join (map f ta)\n  let (>>=) ta f = join (map f ta)\n  let tie f =\n    let cell = ref (mk (fun () -> failwith \"bottom\")) in\n    let v = mk (fun () -> get (f !cell)) in\n      (* Landin's knot *)\n      (* fun () -> get xxx = xxx in this case, but cannot be generalized *)\n      (* over implementations where 'a t != unit -> 'a *)\n      cell := v; (* cell := get (f !cell) *)\n      v\nend;;\n\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  \n  val mk: (unit -> 'a * 'a stream) -> 'a stream (* WHY was this not in front *)\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream (* Be as lazy as possible. *)\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream (*fib = tie fib_aux*)\n  (*traverse evey element of 'a stream that is in 'a stream 'stream*)\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  \n  let mk a = Stream (L.mk a)\n  let hd (Stream a) = fst (L.get a)\n  let tl (Stream a) = mk (fun () -> match snd (L.get a) with Stream b -> L.get b) (* snd (L.get a) *)\n  let rec gen f ta = mk (fun () -> (L.get ta, gen f (L.mk (fun () -> f (L.get ta)))))\n  let rec map f a = mk (fun () -> (f (hd a), map f (tl a)))\n  let rec zipWith f a b = mk (fun () -> (f (hd a, hd b), zipWith f (tl a) (tl b)))\n  let zip a b = zipWith (fun x -> x) a b\n  let rec takeWhile p a = if p (hd a) then (hd a) :: takeWhile p (tl a) else []\n  let rec app xs a = match xs with\n    | [] -> a\n    | (x :: xs) -> mk (fun _ -> (x, app xs a))\n  (* zipWith add with the tail of the stream in the current step *)\n  (*fix f = f $ fix f*)\n  (* fib_aux s = [0, 1] ++ (zipWith (+) s (tail s)) *)\n  (* fix fib_aux -- [0, 1, 1, 2, 3, 5, 8, ...] *)\n  let fib_aux a =\n    let add (a, b) = a + b in\n      app [0; 1] (zipWith add a (tl a))\n  (* each step, take out the head of Stream (Stream a) and add it to finite list *)\n  (* at the same time, append all heads of streams in the list to the result *)\n  (* step ssa tmp = (head <$> tmp) ++ (step (tail ssa) (head ssa : (tail <$> tmp))) *)\n  let join tta =\n    let mHd = List.map hd in\n    let mTl = List.map tl in\n    let rec step ssa tmp =\n      mk (fun () -> L.get (match (app (mHd tmp) (step (tl ssa) (hd ssa :: mTl tmp))) with Stream sa -> sa)) in\n      step tta []\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218020,"user_id":null,"body":"module type Lazy =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  val tie: ('a t -> 'a t) -> 'a t (* fix point combinator *)\nend\n\nmodule type BASE = sig (* the bare minimum to generate a Lazy*)\n  type 'a t\n\n  val mk : (unit -> 'a) -> 'a t\n\n  val get : 'a t -> 'a\nend\n\nmodule OfBase (Base : BASE) : Lazy with type 'a t = 'a Base.t = struct\n  include Base\n\n  let map f t = mk @@ function () -> get t |> f\n\n  let return x = mk @@ function () -> x\n\n  let join t = mk @@ function () -> get @@ get @@ t\n\n  let bind f t = map f t |> join\n\n  let ( >>= ) t f = bind f t\n\n  let rec tie f = f (mk @@ fun () -> tie f |> get)\nend\n\n\nmodule LazyThunk : Lazy with type 'a t = unit -> 'a = OfBase (struct\n  type 'a t = unit -> 'a\n\n  let mk f = f\n\n  let get t = t ()\nend)\n\nmodule LazyOption : Lazy with type 'a t = 'a option ref * (unit -> 'a) = OfBase (struct\n  type 'a t = 'a option ref * (unit -> 'a)\n\n  let mk f = (ref None, f)\n\n  let get (v, k) =\n    match !v with\n    | None ->\n        let eval = k () in\n        v := Some eval;\n        eval\n    | Some eval -> eval\nend)\n\nmodule LazyTagless : Lazy with type 'a t = (unit -> 'a) ref = OfBase (struct\n  type 'a t = (unit -> 'a) ref\n\n  let mk f = ref f\n\n  let get t =\n    let ret = !t () in\n    (t := fun () -> ret);\n    ret\nend)\n\n(* infinite stream *)\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream (* fibonacci = tie fib_aux *)\n  val join: 'a stream stream -> 'a stream\nend\n\nmodule Stream (L : Lazy) : StreamSig with module L = L = struct\n  module L = L\n\n  type 'a stream = Stream of ('a * 'a stream) L.t\n\n  let hd (Stream laz) =\n    let hd, _ = L.get laz in\n    hd\n\n  let mk f = Stream (L.mk f)\n\n  let tl (Stream laz1) =\n    mk @@ fun () ->\n    let _, Stream laz2 = L.get laz1 in\n    L.get laz2\n\n  let rec gen next start =\n    let follow = L.map next start in\n    mk @@ fun () -> (L.get start, gen next follow)\n\n  let rec map f stream = mk @@ fun () -> (hd stream |> f, tl stream |> map f)\n\n  let rec zip stream1 stream2 =\n    mk @@ fun () -> ((hd stream1, hd stream2), zip (tl stream1) (tl stream2))\n\n  let zipWith f stream1 stream2 = zip stream1 stream2 |> map f\n\n  let takeWhile predicate stream =\n    let rec aux acc stream =\n      let hd = hd stream in\n      if predicate hd then aux (hd :: acc) (tl stream) else List.rev acc\n    in\n    aux [] stream\n\n  let rec app (* append *) lst stream =\n    match lst with [] -> stream | x :: q -> mk (fun () -> (x, app q stream))\n\n  let fib_aux stream = zipWith (fun (a, b) -> a + b) (app [ 0; 1 ] stream) (app [ 0 ] stream)\n  (* the fibonacci stream is the fixed point of a well chosen function [fib_aux]. If (->) is the append\n    operator of streams, then fib_aux is the function\n    stream => 0 -> 1 -> (stream + stream[1:])\n    or alternatively\n    stream => (0 -> 1 -> stream) + (0 -> stream)\n    \n    The trick is that appending a different number of elements shifts the stream\n  *)\n\n  let join streams =\n    let rec aux done_ todo streams =\n      match todo with\n      | [] -> aux [] (hd streams :: done_) (tl streams)\n      | stream :: todo -> mk @@ fun () -> (hd stream, aux (tl stream :: done_) todo streams)\n    in\n    aux [] [] streams\n  (* The problem here amounts to bijecting N x N and N. This is done by following anti-diagonals:\n  ^\n  | 7\n  | 4 8\n  | 2 5 9\n  | 1 3 6 10\n  |---------------->\n  \n  *)\nend","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218021,"user_id":null,"body":"module type Lazy_core =\nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\nend\n\nmodule type Lazy =\nsig\n  include Lazy_core\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  val tie: ('a t -> 'a t) -> 'a t\nend;;\n\nmodule MakeLazy (M: Lazy_core): Lazy with type 'a t = 'a M.t =\nstruct\n  include M\n  let map f a   = mk @@ fun _ -> a |> get |> f\n  let return a  = mk @@ fun _ -> a\n  let join a    = mk @@ fun _ -> a |> get |> get\n  let bind f a  = mk @@ fun _ -> a |> get |> f |> get\n  let (>>=) a f = bind f a\n  let rec tie f = f @@ mk @@ fun _ -> f |> tie |> get\nend\n\nmodule LazyThunk = MakeLazy(struct\n    type 'a t = unit -> 'a\n    let mk x = x\n    let get ta = ta ()\n  end)\n\nmodule LazyOption = MakeLazy(struct\n    type 'a t = 'a option ref * (unit -> 'a)\n    let mk x = ref None, x\n    let get (r, thunk) = match !r with\n      | None -> let a = thunk () in r := Some a; a\n      | Some a -> a\n  end)\n\nmodule LazyTagless = MakeLazy(struct\n    type 'a t = (unit -> 'a) ref\n    let mk x = ref x\n    let get r = let a = !r () in let f _ = a in r := f; a\n  end)\n\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  val tl: 'a stream -> 'a stream\n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream\n  val join: 'a stream stream -> 'a stream\nend\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n\n  let mk f = Stream (L.mk f)\n\n  let force_head (Stream tc) = L.get tc\n  let hd s = s |> force_head |> fst\n  let tl s = Stream (L.mk @@ fun _ -> force_head s |> snd |> force_head)\n\n  let rec gen f ta = mk (fun _ ->\n      let a = L.get ta in\n      let f' _ = f a in\n      a, gen f (L.mk f'))\n\n  let rec map f sa = mk @@ fun _ -> let (h,t) = force_head sa in f h, map f t\n  let rec zip sa sb = mk @@ fun _ ->\n    let h1, t1 = force_head sa in\n    let h2, t2 = force_head sb in (h1,h2), zip t1 t2\n  let rec zipWith f sa sb = map f @@ zip sa sb\n  let rec takeWhile p sa = let a = hd sa in\n    if p a then a :: takeWhile p (tl sa) else []\n\n  let rec app la sa = match la with\n    | [] -> sa\n    | x::xs -> mk (fun _ -> x, app xs sa)\n\n  let rec fib_aux si = app [0;1] @@ zipWith (fun (a,b) -> a+b) si (tl si)\n\n  let rec take_heads n ssa = if n = 0 then [], ssa else\n      let (row, rows) = force_head ssa in\n      let (h, hs)     = force_head row in\n      let (rows_hs, rows_ts) = take_heads (n-1) rows in\n      h::rows_hs, mk @@ fun _ -> hs, rows_ts\n\n  let join s =\n    let rec helper n s =\n      let hs, ts = take_heads n s in\n      match hs with\n      | x::xs -> mk @@ fun _ -> x, app xs @@ helper (n+1) ts\n      | [] -> failwith \"no way\"\n    in helper 1 s\nend","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218022,"user_id":null,"body":"module type LazyCore = \nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\nend;;\n\nmodule type Lazy = \nsig\n  include LazyCore\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t \nend;;\n\nmodule LazyTrait(Core: LazyCore): Lazy with type 'a t = 'a Core.t =\nstruct\n  include Core\n  let map f x = mk (fun () -> f (get x))\n  let return x = mk (fun () -> x)\n  let join xx = mk (fun () -> get (get xx))\n  let bind f x = mk (fun () -> get (f (get x)))\n  let (>>=) x f = mk (fun () -> get (f (get x)))\n  let tie f = let r = ref (mk (fun () -> failwith \"uninitialized\")) in \n    r := (mk (fun () -> get (f !r))); !r\nend;;\n\nmodule LazyCoreThunk: LazyCore with type 'a t = unit -> 'a =\nstruct\n  type 'a t = unit -> 'a\n  let mk x = x\n  let get x = x()\nend;;\n\nmodule LazyThunk = LazyTrait(LazyCoreThunk)\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyCoreOption: LazyCore with type 'a t = 'a option ref * (unit -> 'a) =\nstruct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk x = ref None, x\n  let get x = let cache = fst x in\n    match !cache with\n    | None -> let v = (snd x)() in\n      cache := Some v; v\n    | Some v -> v\nend;;\n\nmodule LazyOption = LazyTrait(LazyCoreOption)\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyCoreTagless: LazyCore with type 'a t = (unit -> 'a) ref = \nstruct\n  type 'a t = (unit -> 'a) ref\n  let mk x = ref x\n  let get x = let v = !x() in\n    x := (fun () -> v); v\nend;;\n\nmodule LazyTagless = LazyTrait(LazyCoreTagless)\n\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  (* Be as lazy as possible. *)\n  val tl: 'a stream -> 'a stream \n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream \n  (*traverse evey element of 'a stream that is in 'a stream 'stream*)\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  let mk f = Stream (L.mk f)\n  let hd (Stream x) = fst (L.get x)\n  let tl (Stream x) = mk (fun () -> \n      match snd (L.get x) with Stream s -> L.get s)\n  let rec gen f init = mk (fun () -> (L.get init, gen f (L.map f init)))\n  let rec map f s = mk (fun () -> (s |> hd |> f, map f (tl s)))\n  let rec zip s1 s2 = mk (fun () -> ((hd s1, hd s2), (zip (tl s1) (tl s2))))\n  let rec zipWith f s1 s2 = mk (fun() -> ((f (hd s1, hd s2)), (zipWith f (tl s1) (tl s2))))\n  let takeWhile f s =\n    let rec aux res s =\n      let next = hd s in\n      if f next then aux (next :: res) (tl s)\n      else res\n    in List.rev (aux [] s)\n  (* append *)\n  let rec app l s = match l with\n    | [] -> s\n    | h :: t -> (mk (fun () -> h, app t s))\n  let fib_aux s = app [0;1] (zipWith (fun (l, r) -> l + r) s (tl s))\n  let join ss = \n    let rec aux_xy ss next pending = match pending with\n      | [] -> aux_x ss next\n      | h :: t -> mk (fun () -> (hd h), aux_xy ss (tl h :: next) t)\n    and aux_x ss next =\n      aux_xy (tl ss) [] (hd ss :: (List.rev next))\n    in aux_x ss []\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"},{"id":218023,"user_id":null,"body":"(* Let's implement laziness!\n * A lazy value can be implemented as a closure (also known as thunk),\n * and getting a strict value out of it is just function evaluation. *)\n\n(* Note that you should not use reference unless we explicitly ask for it.\n * Also, whenever you construct a lazy value, make sure to defer\n * all calculation as late as possible *)\nmodule type Lazy = \nsig\n  type _ t\n  val mk: (unit -> 'a) -> 'a t\n  val get: 'a t -> 'a\n  val map: ('a -> 'b) -> 'a t -> 'b t\n  val return: 'a -> 'a t\n  val join: 'a t t -> 'a t\n  val bind:  ('a -> 'b t) -> 'a t -> 'b t\n  val (>>=): 'a t -> ('a -> 'b t) -> 'b t\n  (* The argument is a lazy value that might refer to itself.\n   * Tie the value to itself using reference. *)\n  val tie: ('a t -> 'a t) -> 'a t \nend;;\n\nmodule LazyThunk: Lazy with type 'a t = unit -> 'a =\nstruct\n  type 'a t = unit -> 'a\n  let mk x = x\n  let get x = x()\n  let map f x = mk (fun () -> f (get x))\n  let return x = mk (fun () -> x)\n  let join xx = mk (fun () -> get (get xx))\n  let bind f x = mk (fun () -> get (f (get x)))\n  let (>>=) x f = mk (fun () -> get (f (get x)))\n  let rec tie f = let rf = ref f in !rf (mk (fun () -> get (tie !rf)))\nend;;\n\n(* However, the thunk need to be evaluated each time get is used,\n * instead of at most once. This is outrageous! This is unfair!\n * It can be fixed by caching the result - the thunk is only evaluated\n * if the cache is empty. *)\nmodule LazyOption: Lazy with type 'a t = 'a option ref * (unit -> 'a) =\nstruct\n  type 'a t = 'a option ref * (unit -> 'a)\n  let mk x = ref None, x\n  let get x = let cache = fst x in\n    match !cache with\n    | None -> let v = (snd x)() in\n      cache := Some v; v\n    | Some v -> v\n  let map f x = mk (fun () -> f (get x))\n  let return x = mk (fun () -> x)\n  let join xx = mk (fun () -> get (get xx))\n  let bind f x = mk (fun () -> get (f (get x)))\n  let bind f x = mk (fun () -> get (f (get x)))\n  let (>>=) x f = mk (fun () -> get (f (get x)))\n  let rec tie f = let rf = ref f in !rf (mk (fun () -> get (tie !rf)))\nend;;\n\n(* Notice how there is two components for a Lazy: a thunk and a cache.\n * Here is a pretty cool trick: instead of having two components,\n * just cache the thunk!\n * This is called tagless because we no longer use algebraic data type,\n * which tag the value.\n * We just have a uniform way to handle the value. *)\nmodule LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = \nstruct\n  type 'a t = (unit -> 'a) ref\n  let mk x = ref x\n  let get x = let v = !x() in\n    x := (fun () -> v); v\n  let map f x = mk (fun () -> f (get x))\n  let return x = mk (fun () -> x)\n  let join xx = mk (fun () -> get (get xx))\n  let bind f x = mk (fun () -> get (f (get x)))\n  let bind f x = mk (fun () -> get (f (get x)))\n  let (>>=) x f = mk (fun () -> get (f (get x)))\n  let rec tie f = let rf = ref f in !rf (mk (fun () -> get (tie !rf)))\nend;;\n\n(* Notice how most definition of lazy can be derived from other?\n * Try to lookup how module works and refactor them. *)\n\n(* To test that implementation work, do some infinite stream *)\nmodule type StreamSig =\nsig\n  module L: Lazy\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  val hd: 'a stream -> 'a\n  (* Be as lazy as possible. *)\n  val tl: 'a stream -> 'a stream \n  val mk: (unit -> 'a * 'a stream) -> 'a stream\n  val gen: ('a -> 'a) -> 'a L.t -> 'a stream\n  val map: ('a -> 'b) -> 'a stream -> 'b stream\n  val zip: 'a stream -> 'b stream -> ('a * 'b) stream\n  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream\n  val takeWhile: ('a -> bool) -> 'a stream -> 'a list\n  val app: 'a list -> 'a stream -> 'a stream\n  val fib_aux: int stream -> int stream \n  (*traverse evey element of 'a stream that is in 'a stream 'stream*)\n  val join: 'a stream stream -> 'a stream\nend;;\n\nmodule Stream (L: Lazy): StreamSig with module L = L =\nstruct\n  module L = L\n  type 'a stream = Stream of ('a * 'a stream) L.t\n  let hd = function\n    | Stream lzy -> fst (L.get lzy)\n  let tl = function\n    | Stream lzy -> try snd (L.get lzy) with _ -> Stream lzy\n  let mk f = Stream (L.mk f)\n  (* stupid mistake:\n     `let return x = fun () -> x` and \n     `fun () -> x` \n     are different!\n     Because when you call `return expr`\n     `expr` will be eagerly evaluated *)\n  let rec gen f init = mk (fun () -> (L.get init, gen f (L.map f init)))\n  let rec map f s = mk (fun () -> (s |> hd |> f, map f (tl s)))\n  let rec zip s1 s2 = mk (fun () -> ((hd s1, hd s2), (zip (tl s1) (tl s2))))\n  let rec zipWith f s1 s2 = mk (fun() -> ((f (hd s1, hd s2)), (zipWith f (tl s1) (tl s2))))\n  let takeWhile f s =\n    let rec aux res s =\n      let next = hd s in\n      if f next then aux (next :: res) (tl s)\n      else res\n    in List.rev (aux [] s)\n  (* append *)\n  let rec app l s = match l with\n    | [] -> s\n    | h :: t -> app t (mk (fun () -> (h, s)))\n  let cons x s = mk (fun () -> x, s)\n  let fib_aux is = \n    let rec aux prev1 prev2 is = \n      (prev1 + prev2), mk (fun () -> aux prev2 (prev1 + prev2) is)\n    in\n    cons 0 (cons 1 (mk (fun () -> aux 0 1 is)))\n  let join ss = \n    let rec aux_xy ss next pending = match pending with\n      | [] -> aux_x ss next\n      | h :: t -> mk (fun () -> (hd h), aux_xy ss (tl h :: next) t)\n    and aux_x ss next =\n      aux_xy (tl ss) [] (hd ss :: (List.rev next))\n    in aux_x ss []\nend;;","lang_id":35,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:31","updated_at":"2022-12-30 18:39:31"}]}