{"50654ddff44f800200000004":[{"id":32366,"user_id":676,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:multiply))\n(in-package #:challenge\/solution)\n\n(defun multiply (a b)\n  (* a b))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32367,"user_id":null,"body":"(defpackage :challenge\/solution\n  (:use :cl)\n  (:export :multiply))\n(in-package :challenge\/solution)\n\n(defun multiply (a b) (* a b))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32368,"user_id":564,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:multiply))\n(in-package #:challenge\/solution)\n\n(defun multiply (&rest ns) (reduce #'* ns))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32369,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:multiply))\n(in-package #:challenge\/solution)\n\n(setf (fdefinition 'multiply) #'*)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32370,"user_id":232,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:multiply))\n(in-package #:challenge\/solution)\n\n(defun multiply (a b) (* a b))\n\n; a b needs to * not +","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32371,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:multiply))\n(in-package #:challenge\/solution)\n\n(defun multiply (a b)\n  (print(* a b)))","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32372,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:multiply))\n(in-package #:challenge\/solution)\n\n(defun multiply \n;  (a b) (* a b)\n  (&rest ns) (reduce #'* ns)\n\n)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"514b92a657cdc65150000006":[{"id":32373,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (loop for i from 2 below number\n        if (or (= (rem i 3) 0)\n               (= (rem i 5) 0))\n        sum i))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32374,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (let ((x (- number 1)))\n    (cond \n      ((< x 3) 0)\n      ((or (zerop (rem x 3)) (zerop (rem x 5))) (+ x (solution x)))\n      (t (solution x)))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32375,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (if (< number 0)\n      0\n      (loop :for i :from 1 :below number\n            :when (or (= 0 (mod i 3))\n                      (= 0 (mod i 5)))\n            :sum i)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32376,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (loop for x from 0 below number if (or (= 0 (mod x 3)) (= 0 (mod x 5))) sum x))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32377,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (apply #'+\n         (loop for x from 1 to (1- number)\n               if (three-or-five x)\n                 collect (first (list x)))))\n\n(defun three-or-five (number)\n  (or (= 0 (mod number 3)) (= 0 (mod number 5))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32378,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (n)\n  (let ((m 0))\n    (loop for i from 1\n          while (< i n)\n          do (if (or (= 0 (mod i 3)) (= 0 (mod i 5)))\n                 (setq m (+ m i))\n             )\n          )\n    m))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32379,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (loop for i from 1 to (1- number)\n\t      when (or (= (mod i 3) 0) (= (mod i 5) 0))\n\t      sum i))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32380,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun solution (number)\n  (loop :for i :from 3 :below number\n        :when (or (= (mod i 3) 0) (= (mod i 5) 0))\n        :sum i))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32381,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun multiples-of-x-below-n (n x)\n  (loop for i from 1 to (floor (\/ (1- n) x))\n\tcollect (* i x)))\n\n(defun multiples-of-3-and-5-below-n (n)\n  (reduce #'+\n\t  (delete-duplicates (append (multiples-of-x-below-n n 3)\n\t\t\t\t     (multiples-of-x-below-n n 5)))))\n\n(defun solution (number)\n  (multiples-of-3-and-5-below-n number))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32382,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solution))\n(in-package #:challenge\/solution)\n\n(defun mul-x<n (x n &optional (i 1) (lst nil))\n  (if (>= (* x i) n)\n      lst\n      (mul-x<n x n (+ i 1) (nconc lst (list (* x i))))))\n\n(defun solution (number)\n  (reduce '+ (union (mul-x<n 3 number) (mul-x<n 5 number))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"523b4ff7adca849afe000035":[{"id":32383,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n(defun greet ()\n  \"hello world!\")","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32384,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n(defun doit (acc n)\n  (typecase acc\n    (string (concatenate 'string acc (string (code-char n))))\n    (t (concatenate 'string (string (code-char acc)) (string (code-char n))))))\n\n(defun greet ()\n  (reduce #'doit '(104 101 108 108 111 32 119 111 114 108 100 33)))\n\n; Write a function `greet` that returns \"hello world!\"","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32385,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n#| \u202e |# (defun greet () \"hello world!\")","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32386,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n; Write a function `greet` that returns \"hello world!\"\n(defun greet ()\n  (concatenate 'string \"hello\" \" \" \"world\" \"!\")\n)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32387,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n(defun greet ()\n  (let ((greeting '(#\\h #\\e #\\l #\\l #\\o))\n\t(magic '(15 10 6 0 -11)))\n    (format nil \"~{~a~} ~{~a~}!\"\n\t    greeting\n\t    (mapcar #'code-char\n\t\t    (mapcar #'+ (mapcar #'char-code greeting) magic)))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32388,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n; Write a function `greet` that returns \"hello world!\"\n(defun greet ()\n  (string (intern \"hello world!\")))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32389,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n(defun greet ()\n  (format nil \n          (concatenate 'string \"hello\" \" world!\")))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32390,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n; Write a function `greet` that returns \"hello world!\"\n(defun greet()\n    (format nil \"hello world!\"))\n\n(greet)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32391,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n; Write a function `greet` that returns \"hello world!\"\n\n(defun  greet ()\n  (format nil \"~a\" \"hello world!\"))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32392,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:greet))\n(in-package #:challenge\/solution)\n\n; Write a function `greet` that returns \"hello world!\"\n(defun greet ()\n  (write-line \"hello world!\"))","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"53ee5429ba190077850011d4":[{"id":32393,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  (* n 2))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32394,"user_id":564,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  (+ n n))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32395,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  ; n will be an integer. Double it and return it.\n  (ash n 1))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32396,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  ; n will be an integer. Double it and return it.\n  (let ((n (* n 2))) n)\n  )\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32397,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  (setq n (* 2 n))\n  n)\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32398,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  (return-from double_integer (* 2 n))\n  n)\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32399,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  ; n will be an integer. Double it and return it.\n  (setq n (* n 2))\nn)\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32400,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)(* 2 n)\n  ; n will be an integer. Double it and return it.\n  )\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32401,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n)\n  (* 2 n); doubles the integer passed to it\n)\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32402,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:double_integer))\n(in-package #:challenge\/solution)\n\n(defun double_integer (n) (* n 2)\n  ; n will be an integer. Double it and return it.\n)\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"542f0c36d002f8cd8a0005e5":[{"id":32403,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) (1- n))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32404,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n)  \n  \"Due to the `maximize distance` rule, the first patient will always sit in chair 1.\n  The second patient will then sit in chair n.\n  Since chair n-1 is next to an occupied chair and is farthest away from the exit, it\n  is the least desirable by both metrics given any configuration of the free seats.\"\n  (1- n))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32405,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) \n  (let ((segments    (list (cons (1- n) 0)))\n        (patient     3))\n    (labels ((score (segment) (+ (cdr segment)\n                                 (floor (- (car segment) (cdr segment)) 2)\n                                 (* n (- (car segment) (cdr segment)))))\n             (rec ()\n               (let ((next (pop segments)))\n                 (incf patient)\n                 (if (and (null segments)\n                          (= patient (1+ n)))\n                     (+ (cdr next) (floor (- (car next) (cdr next))))\n                     (let* ((high    (car next))\n                            (low     (cdr next))\n                            (mid     (+ low (floor (- high low) 2)))\n                            (seg1    (cons mid low))\n                            (seg2    (cons high mid)))\n                       (when (and (> (- high low) 1) (\/= low high))\n                         (when (> (- mid low) 1)  (push seg1 segments))\n                         (when (> (- high mid) 1) (push seg2 segments))\n                         (setf segments\n                               (sort segments\n                                     #'<\n                                     :key #'score)))\n                       (rec))))))\n      (rec))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32406,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) \n    ; your code\n    (1- n)\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32407,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) \n  (let ((chairs (make-array (list n))))\n   (dotimes (i n)\n     (setf (elt chairs i) (list (+ i 1) i (- n 1 i))))\n   (setf (elt chairs 0) 1\n         (elt chairs (- n 1)) 2)\n   (flet ((propagate-left (cn)\n            (do* ((start (- cn 1) (- start 1))\n                  (chair (elt chairs start) (elt chairs start))               \n                  (d 1 (+ d 1)))\n                ((atom chair))\n              (setf (nth 2 chair) d)))\n          (propagate-right (cn)            \n            (do* ((start (+ cn 1) (+ start 1))\n                  (chair (elt chairs start) (elt chairs start))\n                  (d 1 (+ d 1)))\n                ((atom chair))\n              (setf (nth 1 chair) d)))\n          (distance (c)\n            (+ (cadr c) (caddr c))))\n      (do ((p 3 (+ p 1)))\n          ((> p n) (+ 1 (position n chairs)))\n        (do* ((free (- n p -1))\n              (i 1 (+ i 1))\n              (best nil))\n             ((zerop free) (propagate-left (- (car best) 1))\n                           (propagate-right (- (car best) 1))\n                           (setf (elt chairs (- (car best) 1)) p))\n          (let ((chair (elt chairs i)))\n            (cond ((consp chair)\n                   (decf free)\n                   (cond ((null best) (setf best chair))\n                         (t (cond ((> (distance chair)\n                                      (distance best))\n                                   (setf best chair)))))))))))))\n  ","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32408,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n\n(defun last-chair (size)\n  (- size 1))\n  \n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32409,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) \n    ; your code\n    (- n 1)\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32410,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) \n    (if (< n 3) n (- n 1))\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32411,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:last-chair))\n(in-package #:challenge\/solution)\n\n(defun last-chair (n) (- n 1))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"54c27a33fb7da0db0100040e":[{"id":32412,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (if (< n 0) nil\n      (= 0 (mod (sqrt n) 1))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32413,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (if (and (> n -1) (= (rem (sqrt n) 1) 0.0))\n      t\n  NIL))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32414,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (and (not (minusp n)) ;; keeping complex numbers out of this\n       (equalp (isqrt n) (sqrt n))) ;; are the greatest integer >= to n and the principle square root equal?\n ) ;the function body is a predicate and returns true or false without being explicitly told to do so.\n\n;;the more elaborate test is needed: sbcl's sqrt returns a single-float type, which will return false on integerp.","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32415,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  ( =\n     ( - \n        (sqrt n) \n        (isqrt (abs n))\n      )\n   \n     0\n  )\n  \n  )","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32416,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (let ((x (sqrt n)))\n    (and (> n -1)(equal x (float (round x))))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32417,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (if (>= n 0)\n      (zerop (mod (sqrt n) 1))\n      nil))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32418,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (and \n   (<= 0 n)\n   (= (sqrt n) (isqrt n))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32419,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (and (>= n 0) ;; keeping complex numbers out of this\n       (= (isqrt n)  (sqrt n))) \n ) ;the function body is a predicate and returns true or false without being explicitly told to do so.\n\n;;sbcl's sqrt returns a single-float type, which will return false on integerp.","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32420,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (if (> n -1)\n      (= n (* (isqrt n) (isqrt n)))\n      'NIL))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32421,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:is_square))\n(in-package #:challenge\/solution)\n\n(defun is_square (n)\n  (unless (< n 0)\n    (let ((a (sqrt n)))\n      (zerop (- a (floor a))))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"54d496788776e49e6b00052f":[{"id":32422,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun factors1 (n)\n  (remove-duplicates \n   (when (> n 1)\n    (loop with limit = (isqrt n)\n      for dv = 2 then (if (evenp dv) (1+ dv) (+ dv 2)) \n          do\n          (cond ((> dv limit) (return (list n)))\n                ((zerop (rem n dv)) (return (cons dv (factors1 (truncate n dv))))))))))\n(defun list-prime-factors (l)\n  (sort \n    (remove-duplicates\n      (let ((acc '()))\n        (dolist (x l)\n          (setf acc (append acc (factors1 (abs x)))))\n       acc)) #'<))\n (defun sum-for-one (n lst)\n    (apply '+ (mapcar (lambda (x) (if (= 0 (rem x n)) x 0)) lst)))\n(defun sum_of_divided (lst)\n  (mapcar (lambda (x) (list x (sum-for-one x lst))) (list-prime-factors lst)))","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32423,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun is-prime (n)\n  (loop for d from 2 to (isqrt n)\n        never (zerop (rem n d))))\n\n(defun filter (p lst)\n  (remove-if-not #'(lambda (x) (zerop (rem x p))) lst))\n\n(defun sum_of_divided (lst)\n  (loop for p from 2 to (apply #'max (cons 0 (mapcar #'abs lst)))\n        when (is-prime p)\n        when (filter p lst)\n        collect (list p (apply #'+ (filter p lst))))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32424,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun divide-out-factor (n f)\n  (if (integerp (\/ n f))\n      (divide-out-factor (\/ n f) f)\n      n))\n\n(defun primep (n)\n  \"Naive implementation\"\n  (when (> n 1)\n    (loop for fac from 2 to (isqrt n) never (zerop (rem nfac)))))\n\n(defun find-prime-factors (n)\n  \"Naive function.\"\n  (if (evenp n)\n      (cons 2 (find-prime-factors (divide-out-factor n 2)))\n      (loop for i from 3 to n by 2\n\t    when (and (zerop (rem n i)) (primep i))\n\t      collect i)))\n\n(defun sum_of_divided (lst)\n  (let ((p-fac-lst (sort (remove-duplicates (mapcan #'find-prime-factors lst)) #'<)))\n    (loop for p in p-fac-lst\n\t  collect (list p\n\t\t\t(reduce #'+ (remove-if-not\n\t\t\t\t     (lambda (x) (zerop (rem x p)))\n\t\t\t\t     lst))))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32425,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun sum_of_divided (lst)\n  (labels ((factors (x f fs)\n             (cond ((= 1 x) fs)\n                   ((zerop (mod x f)) (factors (\/ x f) f (unique-insert f fs)))\n                   (t (factors x (1+ f) fs))))\n           (unique-insert (x xs)\n             (cond ((null xs) (list x))\n                   ((= x (car xs)) xs)\n                   (t (cons x xs))))\n           (sum-multiples (p xs acc)\n             (cond ((null xs) acc)\n                   ((zerop (mod (car xs) p)) (sum-multiples p (cdr xs) (+ acc (car xs))))\n                   (t (sum-multiples p (cdr xs) acc)))))\n    (when lst\n      (let ((ps (sort (reduce #'nunion (mapcar (lambda (x) (factors (abs x) 2 nil)) lst)) #'<)))\n        (mapcar #'(lambda (p) (list p (sum-multiples p lst 0))) ps)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32426,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun sum_of_divided (lst)\n  (loop for i from 1 to (apply #'max (cons 0 (mapcar #'abs lst)))\n        when (primep i)\n        when (filter i lst)\n          collect (list i (apply #'+ (filter i lst)))))\n\n(defun filter (p lts)\n  (remove-if-not (lambda (x) (zerop (rem x p))) lts))\n\n(defun primep (n)\n  \"Is n prime?\"\n  (and (> n 1)\n       (or (= n 2) (oddp n))\n       (loop for i from 3 to (isqrt n) by 2\n             never (zerop (rem n i)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32427,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun sum_of_divided (lst)\n  (if (null lst) '()\n      (let*\n          ((pair-factors-value (reduce #'union (mapcar #'get-prime-factors lst)))\n           (factors (delete-duplicates (mapcar #'car pair-factors-value)))\n           (get-values (lambda (x y) (remove-if (lambda (z) (\/= x (car z))) y)))\n           (get-seconds (lambda (x y) (mapcar #'second (funcall get-values x y)))))\n       (sort\n        (loop for i in factors\n              collect (list\n                       i\n                       (apply #'+ (funcall get-seconds i pair-factors-value))))\n        (lambda (x y) (< (car x) (car y)))\n        ))))\n\n(defun primep (n)\n  \"Is n prime?\"\n  (and (> n 1)\n       (or (= n 2) (oddp n))\n       (loop for i from 3 to (isqrt n) by 2\n             never (zerop (rem n i)))))\n\n\n(defun get-prime-factors (n)\n(let\n      ((number (abs n)))\n    (loop for x from 2 to number\n          when (and (primep x)\n                    (zerop (mod number x)))\n            collect  (list x n))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32428,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun is-prime (n)\n  \"Checks if n>=2 is a prime.\"\n    (loop :with divisors := (loop :for i :from 3 :to (isqrt n) :by 2 :collect i)\n          :for d := 2 :then (pop divisors)\n          :if (zerop (mod n d))\n            :do (return nil)\n          :else\n            :do (setf divisors (delete-if (lambda (x) (zerop (mod x d)))\n                                          divisors))\n          :while divisors\n          :finally (return t)))\n\n(defun list-primes (n)\n  \"Lists primes up to n>=2.\"\n  (cons 2 (loop :for i :from 3 :to n :by 2\n                :when (is-prime i) :collect i)))\n\n(defun list-prime-factors (n)\n  (loop :for prime :in (list-primes n)\n        :when (zerop (mod n prime)) :collect prime))\n\n(defun common-prime-factors (list)\n  (reduce (lambda (a b) (sort (union a b) #'<))\n          (mapcar #'list-prime-factors list)))\n\n(defun sum_of_divided (list)\n  (cond ((null list) '())\n        (t (loop :for i :in (common-prime-factors list)\n                 :collect (list i (loop :for n :in list\n                                        :when (zerop (mod n i))\n                                          :sum n))))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32429,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun sieve (num lst)\n\t   (cond\n\t     ((null lst) ())\n\t     ((= (car lst) num) (cons num (sieve num (rest lst))))\n\t     ((= 0 (mod (car lst) num)) (sieve num (rest lst)))\n\t     (t (cons (car lst) (sieve num (rest lst))))))\n\n(defun get-primes (num)\n\t   (let ((a (loop for x from 2 to num\n\t\t\t  collect x)))\n\t     (dolist (i a)\n\t       (setf a (sieve i a)))\n\t     a))\n \n(defun sum_of_divided (lst)\n  (cond\n    ((null lst) ())\n    (t \n           (let ((a (remove-if-not (lambda (x) (some (lambda (y) (= 0 (mod y x))) lst))\n                                   (get-primes (apply #'max (mapcar #'abs lst)))))\n\t\t (result ()))\n                (dolist (i a)\n\t\t  (push (list i (apply #'+ (remove-if-not (lambda (x) (= 0 (mod x i))) lst))) result))\n\t     (reverse result)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32430,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n; memoize primes already found\n(defparameter *primes*\n      (make-array 10 \n        :fill-pointer 10\n        :adjustable t\n        :initial-contents '(2 3 5 7 11 13 17 19 23 29)))\n\n; add the next prime to the end of *primes*\n(defun find_next_prime ()\n  (vector-push-extend\n      (loop :for next_prime = (+ (elt *primes* (1- (length *primes*))) 2)\n            :then (+ next_prime 2)\n            :when (loop :for prime :across *primes*\n                        :always (\/= (rem next_prime prime) 0)\n                        :until (> (* prime prime) next_prime)\n                        :finally (return t))\n            :return next_prime)\n      *primes*))\n\n; gets the prime with index i\n(defun get_prime (i)\n  ; fill in gaps if we havent checked for this index yet\n  (loop :for j = (length *primes*) :then (1+ j)\n        :until (> j i)\n        :do (find_next_prime))\n  (elt *primes* i))\n\n  \n(defun sum_of_divided (lst)\n  (let ((sums (make-hash-table)) (res '()) )\n       (loop :for value :in lst :do \n          (loop :for j = 0 :then (1+ j)\n                :with prime :do (setq prime (get_prime j))\n                :until (> prime (abs value))\n                :when (= (rem value prime) 0)\n                :do (setf (gethash prime sums) (+ value (or (gethash prime sums) 0)))))\n       (setq res (loop :for k :being :the hash-keys :in sums :using (hash-value v) :collect `(,k ,v)))\n       (sort res #'(lambda (lhs rhs) (< (first lhs) (first rhs))))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32431,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:factors \n           #:sum_of_divided))\n(in-package #:challenge\/solution)\n\n(defun factors (n)\n  (setq kMax (floor (sqrt n)))\n  (setf (symbol-function 'f) #'(lambda (k n) (if (> k kMax) (if (eq n 1) nil (list n)) (if (eq (mod n k) 0) (cons k (f k (\/ n k))) (f (+ k 1) n)))))\n  (if (eq n 1) nil (f 2 n))\n  )\n\n(defun sum_of_divided (lst)\n  (setf (symbol-function 'primes) #'(lambda (l) (if l (append (factors (abs (car l))) (primes (cdr l))) nil)))\n  (setf (symbol-function 'sum) #'(lambda (p l) (if l (+ (if (eq (mod (car l) p) 0) (car l) 0) (sum p (cdr l))) 0)))\n  (map 'list #'(lambda (p) (list p (sum p lst))) (sort (remove-duplicates (primes lst)) #'<))\n  ) ","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5552101f47fc5178b1000050":[{"id":32432,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n\n(defun char->int (c) (parse-integer (format nil \"~A\" c)))\n\n(defun make-counter-closure (p)\n  \"The closure returned by this function will return p after its first call, then p+1, then p+2, etc.\"\n  (let ((count p))\n     (lambda () \n         (prog1 count\n           (incf count)))))\n\n(defun dig_pow (n p)\n    (let* ((digits (mapcar #'(lambda (x) (char->int x)) (coerce (format nil \"~A\" n) 'list))) ;get the digits of n.\n           (counter (make-counter-closure p))   ; This closure will output the powers p, p+1, p+2, ...\n           (power-sum (apply #'+ (mapcar #'(lambda (x) (expt x (funcall counter))) digits)))) ; exponentiate, then sum.\n       (if (integerp (\/ power-sum n))  ; if k exists,\n           (\/ power-sum n)             ; return k,\n           -1)))                       ; otherwise return -1.","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32433,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun digits (n &optional accu)\n  (if (zerop n)\n      accu\n      (digits (floor n 10)\n              (cons (mod n 10) accu))))\n\n(defun dig_pow (n p)\n  (loop :for d in (digits n)\n        :for i :from p\n        :sum (expt d i) :into sum\n        :finally (return (if (zerop (mod sum n))\n                             (\/ sum n)\n                             -1))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32434,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n\n(defun dig_pow (n p)\n  (let ((digits (map 'list #'digit-char-p (princ-to-string n)))\n        (sum 0))\n    (dolist (digit digits)\n      (incf sum (expt digit p))\n      (incf p))\n    (if (= (mod sum n) 0)\n        (\/ sum n)\n        -1)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32435,"user_id":565,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun dig_pow (n p)\n  (let ((ls nil)\n        (total 0))\n    (do ((v n (floor (\/ v 10))))\n        ((= v 0))\n      (push (mod v 10) ls))\n    (dolist (x ls)\n      (setq total (+ total (expt x p)))\n      (incf p))\n    (if (integerp (\/ total n)) (\/ total n) -1)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32436,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun pow (x n)\n  (let ((res 1))\n       (loop :while (> n 0)\n             :do (setq res (* res x)\n                       n (- n 1)))\n       res))\n\n(defun dig_pow (n p)\n  (let (digits res (_n n))\n             ;split the digits of n into the list digits\n       (setq digits (reverse (loop :while (> _n 0)\n                                   :collect (mod _n 10)\n                                   :do (setq _n (floor (\/ _n 10)))))\n             ;calculate the polynomial\n             res (loop :for x in digits\n                       :sum (pow x p)\n                       :do (incf p)))\n       ;check if multiple of n and return the result\n       (if (= (mod res n) 0)\n           (\/ res n)\n           -1)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32437,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun digit-to-list (n)\n  (map 'list #'digit-char-p (prin1-to-string n)))\n\n\n(defun pow-list (list p)\n  (loop for i from 0 to (- (length list) 1)\n        collect (+ i p)))\n\n\n(defun dig_pow (n p)\n  (let* ((list-n (digit-to-list n))\n        (list-p (pow-list list-n p))\n         (num-pow (reduce '+ (map 'list #'(lambda (x y) (expt x y)) list-n list-p))))\n    (if (= 0 (mod num-pow n))\n        (\/ num-pow n)\n        -1)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32438,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun dig_pow (number pow-from)\n  (let* ((numbers (mapcar (lambda (n) (digit-char-p n)) (coerce (write-to-string number) 'list)))\n\t (power (loop for num in numbers\n\t\t     for i from pow-from\n\t\t     sum (expt num i)))\n\t (div (\/ power number)))\n    (if (= (floor div) div)\n\tdiv\n\t-1)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32439,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun dig_pow (n p)\n  (labels ((num->list (n)\n             (loop for c across (format nil \"~S\" n)\n                   collect (digit-char-p c)))\n           (pow-sum (xs p acc)\n             (if (null xs)\n                 acc\n                 (pow-sum (cdr xs) (1+ p) (+ acc (expt (car xs) p))))))\n    (let ((x (\/ (pow-sum (num->list n) p 0) n)))\n      (or (and (integerp x) x) -1))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32440,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun dig_pow (n p)\n  (setq digits (reverse\n    (loop for x = n then (floor x 10)\n          until (= x 0)\n          collect (mod x 10))))\n  (setq s\n    (loop for d in digits\n          for i from p\n      sum (expt d i)))\n  (if (= 0 (mod s n))\n      (floor s n)\n      -1))","lang_id":8,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32441,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dig_pow))\n(in-package #:challenge\/solution)\n   \n(defun dig_pow (n p)\n  (let* ((a (map 'list #'digit-char-p (prin1-to-string n))) \n        (b (loop for i in a\n             for j from p\n             sum (expt i j))) )\n       (multiple-value-bind (k l) (floor b n)\n        (if (zerop l)\n            k\n            -1)))\n  )","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"55d24f55d7dd296eb9000030":[{"id":32442,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n)\n  (loop for i from 1 to n summing i))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32443,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (\/ (* n (1+ n)) 2))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32444,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) (reduce '+ (loop for x from 1 to n collect x)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32445,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (if (= n 1)\n      n\n      (+ n \n         (summation (1- n))\n         )\n))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32446,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n)\n  (loop for i\n        below (+ n 1)\n        sum i))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32447,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (setq total 0)\n  (dotimes (i (+ n 1))\n(setq total (+ total i)))\n  total)","lang_id":8,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32448,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (let ((x 0))\n    (loop for a from 1 to n\n          do (setf x (+ x a))) ;your code goes here\n  (return-from summation x)\n       )\n  \n)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32449,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (reduce #'+ (loop for i below n collect (+ i 1))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32450,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (if (= n 0)\n      0\n      (+ (summation (- n 1)) n)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32451,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:summation))\n(in-package #:challenge\/solution)\n\n(defun summation (n) \n  (floor (* n (+ n 1)) 2\n))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"55fd2d567d94ac3bc9000064":[{"id":32452,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n) \n  (expt n 3))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32453,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n) (* n n n))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32454,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n)\n  (let ((n (- n 1))\n        (first-number 1))\n    (loop for i from 1 to n do\n      (incf first-number (* i 2)))\n    (let ((last-number (+ first-number (* n 2))))\n      (loop for i from first-number to last-number by 2 sum i))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32455,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun iota (count &optional (start 0) (step 1))\n    (loop repeat count for i from start by step collect i))\n\n(defun row_sum_odd_numbers (n) \n (apply #'+ (iota n (+ (* n (- n 1)) 1)  2)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32456,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n\n(defun sum (n)\n  (\/ (* n (1+ n)) 2))\n\n(defun row_sum_odd_numbers (n)\n  (let ((m (sum (1- n))))\n    (- (+ (* m n 2) (* n (1+ n))) n)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32457,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n) \n  (* n n n) ;n^3\n  )","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32458,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun first-in-row (n)\n  (do ((row 1)\n       (i 1 (+ i 2))\n       (j 1 (if (>= j row)\n                (progn (incf row)\n                       (setf j 1))\n                (+ j 1))))\n      ((>= row n) i)))\n\n(defun make-row (n)\n  (loop with start = (first-in-row n)\n        for i from 1 to n\n        for num from start by 2\n        collecting num))\n\n(defun row_sum_odd_numbers (n) \n  (loop for num in (make-row n)\n        summing num))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32459,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n) \n    ; your code\n    (* n n n))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32460,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n) \n    (setq oddn (* (1- n) n))\n    (setq res 0)\n    (dotimes (x n (- res n))\n      (incf  res (incf  oddn 2))\n      )\n    \n  )","lang_id":8,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32461,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:row_sum_odd_numbers))\n(in-package #:challenge\/solution)\n\n(defun row_sum_odd_numbers (n) \n    (* (* n n) n)\n  )","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"566be96bb3174e155300001b":[{"id":32462,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v0)\n  (round v0 3.5316))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32463,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defvar *g* 9.81)\n\n(defun kmh_to_ms (v)\n    (\/ v 3.6))\n\n(defun t_max (v0)\n    (\/ v0 *g*))\n\n(defun max-ball (v0)\n    (let ((v (kmh_to_ms v0)))\n        (round\n         (\/ (t_max v) 0.1))))\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32464,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v0)\n  ; your code\n  (round (\/ (* v0 10) (* 3.6 9.81)))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32465,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v)\n  (setq v (\/ v 3.6))\n  (let ((_time 0))\n       (loop :while (> (+ (* v 0.1) (* -9.81 0.5 0.1 0.1)) 0)\n             :do (incf _time)\n             :do (setq v (- v (* 9.81 0.1))))\n       _time))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32466,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v0)\n  (let* ((v1 (\/ v0 3.6))\n         (tmax-tsec (\/ v1 .981))\n         (trec-max (round tmax-tsec)))\n    trec-max))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32467,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v0)\n  (labels ((height (r)\n             (- (* v0 10\/36 r) (* 0.5 9.81 r r)))\n           (rec (r acc)\n             (let ((h (height (* r 0.1))))\n               (if (< h acc)\n                   (1- r)\n                   (rec (1+ r) h)))))\n    (rec 0 0)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32468,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun height (v ti)\n  (- (* v ti) (* 0.5 35.316 ti ti)))\n  \n(defun max-ball (v0)\n  (let ((hmax 0) (hmaxt 0) (lasth 0))\n       (do ((ti 1 (+ 1 ti))) (nil hmax)\n            (let ((h (height v0 (\/ ti 10))))\n                 (when (> h hmax) (setf hmax h) (setf hmaxt ti))\n                 (when (< h lasth) (return hmaxt))\n                 (setf lasth h)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32469,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(defconstant g 9.81)\n\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v0)\n  (round (\/ (* 100 v0) g 36)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32470,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(defvar g 9.81)\n(setq *read-default-float-format* 'double-float)\n(defun max-ball (v0)\n  (round ( * 10 (\/ v0 g) (\/ 1000 (expt 60 2)))))\n  ; your code","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32471,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-ball))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n(defvar g 9.81)\n(defun h (v t*) (- (* v t*) (* 0.5 g t* t*)))\n(defun km\/h->m\/s (v-km\/h) (* v-km\/h (\/ 10 36)))\n(defun max-ball (v0)\n  (labels ((helper (res nt)\n             (let ((heigh (h (km\/h->m\/s v0) (* nt 0.1))))\n               (if (< heigh (cdr (car res)))\n                   res\n                   (helper (cons (cons nt heigh) res) (1+ nt))))))\n    (car (car (helper '((0 . 0.0)) 1)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5672682212c8ecf83e000050":[{"id":32472,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n(in-package #:challenge\/solution)\n\n(defun dbl_linear (n)\n  (let ((seq (make-array (1+ n) :initial-element 1)))\n       (loop for i from 1 to n\n             for i2 = 0 then (if (= k k2) (1+ i2) i2)\n             for i3 = 0 then (if (= k k3) (1+ i3) i3)\n             for k2 = (1+ (* (elt seq i2) 2))\n             for k3 = (1+ (* (elt seq i3) 3))\n             for k = (if (< k2 k3) k2 k3)\n             do (setf (elt seq i) k)\n             finally (return (elt seq n)))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32473,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n(in-package #:challenge\/solution)\n\n(defun walk (i x y n acc)\n  (if (> i n)\n    (gethash n *acc*)\n    (let* ((a (gethash x *acc*))\n           (b (gethash y *acc*))\n           (e (min (+ 1 (* 2 a)) (+ 1 (* 3 b))))\n           (x0 (if (= e (+ 1 (* 2 a))) (+ 1 x) x))\n           (y0 (if (= e (+ 1 (* 3 b))) (+ 1 y) y)))\n       (walk (+ i 1) x0 y0 n (setf (gethash i *acc*) e)))))\n\n(defun dbl_linear (n)\n  (defparameter *acc* (make-hash-table))\n  (walk 1 0 0 n (setf (gethash 0 *acc*) 1)))","lang_id":8,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32474,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n(in-package #:challenge\/solution)\n\n(defvar *i* 0) ;next element\n\n(defvar *u* (make-array 600000 :element-type 'integer))\n(setf (aref *u* 0) 1)\n(defvar *x* 0)\n(defvar *y* 0)\n\n(defun dbl_linear (n)\n  (dbl n))\n\n(defun dbl (n)\n  (let ((nx (1+ (* 2 (aref *u* *x*))))\n        (ny (1+ (* 3 (aref *u* *y*)))))\n    (cond\n      ((< n *i*) (aref *u* n))\n      ((= nx ny) (incf *i*) (incf *x*) (incf *y*) (setf (aref *u* *i*) nx) (dbl n))\n      ((< nx ny) (incf *i*) (incf *x*)            (setf (aref *u* *i*) nx) (dbl n))\n      (t         (incf *i*)            (incf *y*) (setf (aref *u* *i*) ny) (dbl n)))))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32475,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n\n(in-package #:challenge\/solution)\n\n(defun dbl_linear (n)\n  (let* ((rear '(4))\n        (seq (append '(1 3) rear))\n        (queue-for-*2+1 (cdr seq))\n        (queue-for-*3+1 (cdr seq))\n        (length 3))\n    (loop\n      (let* ((doubled (1+ (* 2 (car queue-for-*2+1))))\n             (tripled (1+ (* 3 (car queue-for-*3+1))))\n             (doubled<=tripled (<= doubled tripled))\n             (doubled>=tripled (>= doubled tripled))\n             (new-elem (if doubled<=tripled doubled tripled)))\n        (when doubled<=tripled (pop queue-for-*2+1))\n        (when doubled>=tripled (pop queue-for-*3+1))\n        (push new-elem (cdr rear))\n        (pop rear))\n      (incf length)\n      (when (> length n) (return)))\n    (nth n seq)))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32476,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n\n(in-package #:challenge\/solution)\n\n(defun dbl_linear (n)\n  (let* ((last-pair (list 4))\n        (seq (cons 1 (cons 3 last-pair)))\n        (queue-for-*2+1 (cdr seq))\n        (queue-for-*3+1 (cdr seq))\n        (len 3))\n    (loop\n      (let* ((for-*2+1 (car queue-for-*2+1))\n             (for-*3+1 (car queue-for-*3+1))\n             (doubled (1+ (* 2 for-*2+1)))\n             (tripled (when (< for-*3+1 for-*2+1) (1+ (* 3 for-*3+1)))))\n        (cond ((or (null tripled) (< doubled tripled))\n               (push doubled (cdr last-pair))\n               (pop last-pair)\n               (pop queue-for-*2+1))\n              ((= doubled tripled)\n               (push doubled (cdr last-pair))\n               (pop last-pair)\n               (pop queue-for-*2+1)\n               (pop queue-for-*3+1))\n              (t ; doubled > tripled\n               (push tripled (cdr last-pair))\n               (pop last-pair)\n               (pop queue-for-*3+1))))\n      (incf len)\n      (when (> len n) (return)))\n    (nth n seq)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32477,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n\n(in-package #:challenge\/solution)\n\n(defun dbl_linear (n)\n  (let ((seq (make-array 3 :initial-contents '(1 3 4) :adjustable t :fill-pointer 3))\n        (waiting-triple-start 1)\n        (waiting-double-start 1))\n    (loop\n      (let* ((to-double (elt seq waiting-double-start))\n             (to-triple (when (< waiting-triple-start waiting-double-start)\n                          (elt seq waiting-triple-start)))\n             (doubled (1+ (* 2 to-double)))\n             (tripled (when to-triple (1+ (* 3 to-triple)))))\n        (cond ((or (null tripled) (< doubled tripled))\n               (vector-push-extend doubled seq)\n               (incf waiting-double-start))\n              ((= doubled tripled)\n               (vector-push-extend doubled seq)\n               (incf waiting-double-start)\n               (incf waiting-triple-start))\n              ((> doubled tripled)\n               (vector-push-extend tripled seq)\n               (incf waiting-triple-start))))\n      (when (> (length seq) n) (return)))\n    (elt seq n)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32478,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n(in-package #:challenge\/solution)\n\n(defun dbl_linear (n)\n  (let ((arr (make-array (+ n 1) :initial-element 0 :element-type 'fixnum))\n        (seen (make-hash-table)))\n    (setf (aref arr 0) 1)\n    (labels ((find-nth (m i j)\n               (if (> m n)\n                   (aref arr (- m 1))\n                   (let ((one (+ (* 2 (aref arr i)) 1))\n                         (other (+ (* 3 (aref arr j)) 1)))\n                     (if (< one other)\n                         (progn (when (not (gethash one seen))\n                                  (setf (gethash one seen) t)                                  \n                                  (setf (aref arr m) one)\n                                  (incf m))\n                                (find-nth m (+ i 1) j))\n                         (progn (when (not (gethash other seen))\n                                  (setf (gethash other seen) t)                                  \n                                  (setf (aref arr m) other)\n                                  (incf m))\n                                (find-nth m i (+ j 1))))))))\n      (find-nth 1 0 0))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32479,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n(in-package #:challenge\/solution)\n\n(defun dbl_linear (n)\n  (let ((u (make-array (1+ n)))\n        (xi 0)\n        (yi 0))\n    (setf (aref u 0) 1)\n    (do ((i 1 (1+ i)))\n      ((> i n))\n      (let ((x (1+ (* 2 (aref u xi))))\n            (y (1+ (* 3 (aref u yi)))))\n        (setf (aref u i) (min x y))\n        (when (<= x y)\n          (incf xi))\n        (when (>= x y)\n          (incf yi))))\n    (aref u n)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32480,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dbl_linear))\n(in-package #:challenge\/solution)\n\n(defun aux (arr n &optional (yi 0) (zi 0) (cnt 0))\n  (if (>= cnt n)\n    (aref arr n)\n    (let* ((cnt (1+ cnt))\n           (y (1+ (* 2 (aref arr yi))))\n           (z (1+ (* 3 (aref arr zi))))\n          )\n        (cond ((> y z) (setf (aref arr cnt) z) (aux arr n yi (1+ zi) cnt))\n              ((> z y) (setf (aref arr cnt) y) (aux arr n (1+ yi) zi cnt))\n              (t (setf (aref arr cnt) y) (aux arr n (1+ yi) (1+ zi) cnt))))))\n(defun dbl_linear (n)\n    (let ((a (make-array (1+ n))))\n      (setf (aref a 0) 1)\n      (aux a n)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"56b2abae51646a143400001d":[{"id":32481,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun xor-shift (n p)\n  (logxor n (floor n (expt 2 p)))\n  )\n\n(defun mystery (n)\n  (xor-shift n 1)\n  )\n\n(defun mystery-inv (n)\n  (setq n (xor-shift n 64))\n  (setq n (xor-shift n 32))\n  (setq n (xor-shift n 16))\n  (setq n (xor-shift n  8))\n  (setq n (xor-shift n  4))\n  (setq n (xor-shift n  2))\n  (setq n (xor-shift n  1))\n  )\n\n(defun mystery-name () \"Gray code\")","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32482,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun mystery (n)\n  (logxor n (ash n -1)))\n\n\n(defun mystery-inv (n)\n  (labels ((rec (mask x)\n             (if (zerop mask)\n                 x\n                 (let ((new-mask (ash mask -1)))\n                   (rec new-mask  (logxor x new-mask))))))\n    (rec n n)))\n\n\n(defun mystery-name () \"Gray code\")","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32483,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun mystery-step (n p)\n  (logxor n (floor n (expt 2 p))))\n\n(defun mystery (n)\n  (mystery-step n 1))\n\n(defun mystery-inv (n)\n  (loop for p = 64 then (floor p 2)\n        for x = (mystery-step n p)\n          then (mystery-step x p)\n        do (when (<= p 1)\n             (return x))))\n\n(defun mystery-name ()\n  \"Gray code\")","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32484,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun mystery (n &optional (bit (or (and (not (zerop n))\n                                          (floor (log n 2)))\n                                     0)))\n  (if (zerop bit) n\n      (let* ((e (expt 2 bit))\n             (mask (1- e))\n             (l (mod n e))\n             (h (- n l)))\n        (if (zerop h) (mystery l (1- bit))\n            (+ h (mystery (- mask l) (1- bit)))))))\n\n(defun mystery-inv (n &optional (bit (or (and (not (zerop n))\n                                          (floor (log n 2)))\n                                     0)))\n  (if (zerop bit) n\n      (let* ((e (expt 2 bit))\n             (l (mod n e))\n             (h (- n l))\n             (m (mystery-inv l (1- bit))))\n        (if (zerop h) m (- (* 2 e) 1 m)))))\n\n(defun mystery-name ()\n  \"Gray code\")","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32485,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun mystery (n) (logxor (ash n -1) n))\n\n(defun mystery-inv (n)\n  (do ((m (ash n -1) (ash m -1))\n       (n n (logxor n m)))\n    ((= m 0) n)))\n\n(defun mystery-name () \"Gray code\")","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32486,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun mystery (n)\n  (logxor n (ash n -1)))\n\n(defun mystery-inv (n)\n  (if \n    (= 0 n) 0\n    (logxor n (mystery-inv (ash n -1)))))\n\n(defun mystery-name ()\n  \"gRaY CoDe\")","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32487,"user_id":163,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:mystery\n           #:mystery-inv\n           #:mystery-name))\n(in-package #:challenge\/solution)\n\n(defun mystery (n)\n  \"the mystery function aka Gray code\"\n  (logxor n (floor n 2)))\n\n(defun mystery-inv (n)\n  \"inverse of mystery function\"\n  (cond \n    ((= 0 n) 0)\n    (t (logxor n (mystery-inv (floor n 2))))\n    ))\n\n(defun mystery-name ()\n  \"the name of the mystery function\"\n  \"gRaY CoDe\"\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"581ee0db1bbdd04e010002fd":[{"id":32488,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n(defun interp (f l u n)\n       (loop :with d = (\/ (- u l) n)\n             :for i :from l :by d :below u\n             :collect (trunc (funcall f i))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32489,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n  (\/ (floor (* x 100)) 100.0))\n\n(defun interp (f l u n)\n  (loop with d = (\/ (- u l) n)\n        for k from 0 below n\n        for x = (+ l (* k d))\n        collect (trunc (funcall f x))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32490,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n\n(defun interp (f l u n)\n  (loop for i from 0 below n\n\t      collect (trunc (funcall f (+ l (* i (\/ (rationalize (- u l)) n)))))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32491,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n(defun interp (f l u n)\n  (let ((d (\/ (- u l) n)))\n       (loop :while (< l u)\n             :collect (trunc (funcall f l))\n             :do (setq l (+ l d)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32492,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n(defun interp (f l u n)\n  (let ((d (\/ (- u l) n))\n        (list nil))\n    (dotimes (i n list)\n      (push (trunc (funcall f (- u\n                                 (* d (+ i 1)))))\n            list))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32493,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n(defun interp (f l u n)\n  (setq inc (\/ (- u l) n))\n  (setq vec '())\n  (dotimes (x n) \n    (push (trunc (funcall f (+ l (* x inc)))) vec)\n    )\n  (reverse vec)\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32494,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n\n(defun interp (f l u n)\n  (let ((d (\/ (- u l) n)))\n    (loop for i from l to (- u (\/ d 2)) by d \n                         collect (trunc (apply f (list i)))\n                         )))  \n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32495,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n\n(defun interp (f l u n)\n  (cond\n   ((<= u l) ())\n   (t (cons (trunc (funcall f l))\n            (interp f (+ l (\/ (- u l) n)) u (- n 1))))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32496,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n  (\/ (floor (* x 100.0)) 100.0)\n)\n\n(defun range (n x d)\n  (if (eq n 0) nil (cons x (range (- n 1) (+ x d) d)))\n)\n\n(defun interp (f l u n)\n  (mapcar #'trunc (mapcar f (range n l (\/ (- u l) n))))\n)\n\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32497,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:interp))\n(in-package #:challenge\/solution)\n\n(defun trunc (x)\n    (\/ (floor (* x 100.0)) 100.0))\n\n(defun interp (f l u n)\n  (let ((d (\/ (- u l) n)))\n    (mapcar\n      #'(lambda (x) (trunc (funcall f x)))\n      (loop for x :from l :by d :while (< x u) collect x))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"58ce8725c835848ad6000007":[{"id":32498,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (floor (* w0 (- 100.0 p0)) (- 100.0 p1)))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32499,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (floor (\/ (* w0 (- 100 p0)) (- 100 p1)))\n)\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32500,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  ; your code\n  (let* ((matter_perc0 (- 100.0 p0))\n        (matter_weight (\/ (* w0 matter_perc0) 100.0))\n        (matter_p1 (- 100.0 p1)))\n        (truncate (* 100.0 matter_weight) matter_p1))\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32501,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  ;weight*old_percentage\/new_percentage\n  (floor (\/ (* w0 (- 100 p0)) (- 100 p1)))\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32502,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (let* ((initial-percent (\/ p0 100))\n         (final-percent (\/ p1 100))\n         (matter-weight (- w0 (* initial-percent w0))))\n  (floor matter-weight (- 1 final-percent))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32503,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (let* ((water-weight (\/ (* w0 p0) 100))\n         (dry-weight (- w0 water-weight))\n         (new-dry-percent (- 100 p1))\n         (one-percent-weight (\/ dry-weight new-dry-percent)))\n        (floor (* one-percent-weight 100))))\n  ","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32504,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (truncate (\/ (- w0 (* w0 (\/ p0 100))) (- 1 (\/ p1 100))))\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32505,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (truncate (\/ (* w0 (- 1 (\/ p0 100))) (- 1 (\/ p1 100))))\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32506,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (let* ((water-weight (* w0 (\/ p0 100)))\n         (dry-matter (- w0 water-weight)))\n    (truncate (* dry-matter (\/ 100 (- 100 p1))))))\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32507,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:potatoes))\n(in-package #:challenge\/solution)\n\n(defun potatoes (p0 w0 p1)\n  (- w0 (ceiling (* w0 (\/ (- p0 p1) (- 100 p1) ))))\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"59c68ea2aeb2843e18000109":[{"id":32508,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun balance (r p c n)\n  (- (* (expt (1+ r) n) p)\n     (* (\/ (1- (expt (1+ r) n)) r) c)))\n\n(defun amort (yearly-rate-percent principal term num-payment)\n  (let* ((rate (\/ yearly-rate-percent 100 12))\n         (payment (\/ (* rate principal) (- 1 (expt (1+ rate) (- term)))))\n         (last-balance (balance rate principal payment (1- num-payment)))\n         (part-interest (* rate last-balance))\n         (part-principal (- payment part-interest))\n         (new-balance (- last-balance part-principal)))\n    (mapcar #'round (list num-payment payment part-principal part-interest new-balance))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32509,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(defun aux (bal num-payments r payment &optional (i 0) (interest 0.0) (principal 0.0))\n    (if (>= i num-payments)\n        (list i (round payment) (round principal) (round interest) (round bal))\n        (let* ((ir (* bal r))\n               (p (- payment ir))\n               (b (- bal p)))\n          (aux b num-payments r payment (1+ i) ir p))))\n(defun amort (rate balance term num-payments)\n    (let* ((r (\/ rate 1200.0))\n           (payment (\/ (* r balance) (- 1.0 (expt (+ 1.0 r)(- term))))))\n        (aux balance num-payments r payment)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32510,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n; return a list with num-payment, c, princ, int, balance each rounded\n(defun amort (rate balance term num-payment)\n  (setq r (\/ rate 100 12))\n  (setq d (- 1 (expt (+ 1 r) (- term))))\n  (setq c (\/ (* r balance) d))\n  (setq b\n    (loop :for b = balance :then (- b (- c (* r b)))\n          :repeat (- num-payment 1)\n          :finally (return b)))\n  (setq int (* r b))\n  (setq princi (- c int))\n  (mapcar (lambda (x) (round x)) (list num-payment c princi int (- b princi))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32511,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun amort (rate balance term num-payments)\n  (setf rate (\/ rate 1200))\n  (setf n (* rate balance))\n  (setf d (- 1 (\/ 1 (expt (+ 1 rate) term))))\n  (setf c (\/ n d))\n  (setf N num-payments)\n  (loop while (> N 0)\n    do\n      (setf interest (* balance rate))\n      (setf principal (- c interest))\n      (setf balance (- balance principal))  \n      (decf N)\n  )\n  (list num-payments (round c) (round principal) (round interest) (round balance))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32512,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n; return a list with num-payment, c, princ, int, balance each rounded\n(defun amort (rate balance term num-payments)\n  (let* ((r (\/ rate (* 100 12)))\n         (b balance)\n         (d (- 1.0 (expt (1+ r) (- 0 term))))\n         (n (* r b))\n         (c (\/ n d)))\n    (dotimes (i num-payments)\n      (setf d (- 1.0 (expt (1+ r) (- 0 term)))\n            n (* r b))\n      (decf b (- c (* r b))))\n    (list num-payments (round c) (round (- c n)) (round n) (round b))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32513,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun amort (rate balance term num-payments)\n  (let* ((r (\/ rate 1200))\n         (n (* r balance))\n         (d (- 1 (expt (+ 1 r) (- term))))\n         (c (\/ n d)))\n    (loop for x from 1 to num-payments\n          for intere = (* balance r) then (* bala r)\n          for princi = (- c intere)\n          for bala = (- balance princi) then (- bala princi)\n          when (= x num-payments) \n          do (return (list x c princi intere bala)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32514,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun amort (rate balance term num-payments)\n  (let* ((r (\/ rate 1200))\n         (n (* r balance))\n         (d (- 1 (expt (+ 1 r) (- term))))\n         (c (\/ n d)))\n    (loop for x from 1 to num-payments\n          for intere = (* balance r) then (* bala r)\n          for princi = (- c intere)\n          for bala = (- balance princi) then (- bala princi)\n          ;do (format t \"Num ~A, c ~,2F, princ ~,2F, int ~,2f, Balance ~,2f~%\" x c princi intere bala)\n          when (= x num-payments) \n          do (return (list x (r100 c) (r100 princi) (r100 intere) \n                           (r100 bala))))))\n\n(defun r100 (i) (\/ (round (* 100.0 i)) 100.0))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32515,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n\n(defun power (x n)\n  (cond \n    ((> n 0) (* x (power x (- n 1))))\n    ((< n 0) (\/ 1 (power x (- 0 n))))\n    (t 1)\n  )\n)\n\n; return a list with num-payment, c, princ, int, balance each rounded\n(defun amort (rate balance term num-payments)   \n  (defun c (n d) (\/ n d))\n  (defun n (r balance) (* r balance))\n  (defun d (r term) (- 1 (power (+ 1 r) (- 0 term))))\n  (defun prnc (c int) (- c int))\n  \n  (setf curr-bal balance)\n  (setf rate (\/ rate 1200))\n  (loop for a from 1 to num-payments\n     do (setf c-val (c (n rate balance) (d rate term)))\n        (setf int-val (n curr-bal rate))\n        (setf prnc-val (prnc c-val int-val))\n        (setf curr-bal (- curr-bal prnc-val))\n  )\n\n  (return-from amort (list (round num-payments) (round c-val) (round prnc-val) (round int-val) (round curr-bal)))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32516,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n; return a list with num-payment, c, princ, int, balance each rounded\n(defun amort (rate balance term num-payments)\n  (defun inner (rate balance term num-payments)\n    (let* ((r (\/ rate 100 12))\n           (n (* r balance))\n           (d (- 1 (expt (+ 1 r) (- term))))\n           (c (float (\/ n d)))\n           (old-balance (if (= num-payments 1)\n                            balance\n                            (fifth (inner rate balance term (- num-payments 1)))))\n           (int (* old-balance r))\n           (princ (- c int))\n           (new-balance (- old-balance princ)))\n      (list num-payments c princ int new-balance)))\n  (mapcar #'round (inner rate balance term num-payments)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32517,"user_id":565,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:amort))\n(in-package #:challenge\/solution)\n\n(defun amort (rate balance term num-payments)\n  (let ((r (\/ rate (* 100 12))))\n    (let ((c (\/ (* r balance) (- 1 (expt (+ 1 r) (- term)))))\n          (interest nil)\n          (principal nil))\n      (dotimes (x num-payments)\n        (setq interest (* r balance))\n        (setq principal (- c interest))\n        (setq balance (- balance principal)))\n      (list num-payments (round c) (round principal) (round interest) (round balance)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"59ccf051dcc4050f7800008f":[{"id":32518,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(let ((ds-cache (make-hash-table))\n      (ps-cache (make-hash-table)))\n  (defun prime-sum (p n)\n    (let ((key (cons p n)))\n      (cond\n        ((\/= (mod n p) 0) 1)\n        ((gethash key ps-cache)\n         (gethash key ps-cache))\n        (t (setf (gethash key ps-cache) \n                 (+ 1 (* p (prime-sum p (floor n p)))))))))\n  (defun divisor-sum (n)\n    (cond ((<= n 0) 0)\n          ((= n 1) 1)\n          (t (loop for p from 2 until (= (mod n p) 0)\n                when (> (* p p) n)\n                return (setf (gethash n ds-cache) (+ n 1))\n                finally (return (let* ((ps (prime-sum p (floor n p)))\n                                       (ds (divisor-sum (floor n p))))\n                                  (setf (gethash n ds-cache)\n                                        (* (+ (* ps p) 1) (floor ds ps))))))))))\n\n(defun proper-divisor-sum (n)\n  (- (divisor-sum n) n))\n\n(defun other-buddy (n)\n  (- (proper-divisor-sum n) 1))\n\n(defun buddy-pair (n)\n  (let* ((n-buddy (other-buddy n))\n        (buddy-buddy (other-buddy n-buddy)))\n    (if (and (> n-buddy n) (= buddy-buddy n))\n        (list n n-buddy)\n        nil)))\n\n(defun buddy (start nd)\n  (loop for i from start to nd\n     for pair = (buddy-pair i)\n     when pair\n     return (format nil \"~a\" pair)\n     finally (return \"Nothing\")))\n","lang_id":8,"is_control":1,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32519,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun proper_divisor2 (n) \n  (loop for i from 2 to (isqrt n)\n        for (q r) = (multiple-value-list (floor n i)) \n        if (zerop r)\n        append (remove-duplicates `(,i ,q))\n        )   \n  )\n\n(defun num-to-s (n) \n  (reduce '+ (proper_divisor2 n)) )\n\n(defun buddy (start nd)\n  (loop for i from start to nd\n        for a = (num-to-s i)\n        for b = (num-to-s a)\n        if (and (eq i b) (<= i a))\n        return (format nil \"~F\" `(,i ,a))                                                                                                                                                                                                                                        \n        collect 0 \n        finally (return \"Nothing\")\n        )\n)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32520,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun get-divisors (num)\n  (let ((divs (list 1)))\n    (do ((x 2 (1+ x))) ((> x (1+ (sqrt num))))\n      (when (= 0 (mod num x))\n\t(push x divs)\n\t(push (\/ num x) divs)))\n    (when (= 0 (mod (sqrt num) 1))\n      (pop divs))\n    divs))\n\n(defun find-buddy-if-exists (num)\n  (let ((a (apply #'+ (get-divisors num))))\n    (if (and (= (apply #'+ (get-divisors (1- a))) (1+ num))\n\t     (> (1- a) num))\n\t(1- a)\n\t\"Nothing\")))\n  (defun buddy (start nd)\n  (let ((k (loop for x from start to nd\n\t\t do (let ((a (find-buddy-if-exists x)))\n\t\t      (when (numberp a)\n\t\t\t(return (concatenate 'string\n\t\t\t\t\t     \"(\" (write-to-string x) \" \"\n\t\t\t\t\t     (write-to-string a) \")\")))))))\n    (if k\n\tk\n\t\"Nothing\")))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32521,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:s\n           #:buddy))\n(in-package #:challenge\/solution)\n\n(defun s (n)\n  (setq kMax (floor (sqrt n)))\n  (setf (symbol-function 'f) #'(lambda (k) (if (> k kMax) 0 (if (eq (mod n k) 0) (if (eq (* k k) n) k (+ (\/ n k) k (f (+ k 1)))) (f (+ k 1))))))\n  (+ (f 2) 1)\n  )\n\n(defun buddy (start end)\n  (setf n (- start 1))\n  (setf m 0)\n  (loop while (and (<= n end) (eq m 0))\n      do (incf n)\n      do (let ((mm (- (s n) 1))) (if (and (> mm n) (eq (+ n 1) (s mm))) (setf m mm)))\n      )\n  (if (eq m 0) \"Nothing\" (concatenate 'string \"(\" (write-to-string n) \" \" (write-to-string m) \")\"))\n  )","lang_id":8,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32522,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (defun mkstr (&rest args)\n    (with-output-to-string (s)\n      (dolist (a args) (princ a s))))\n\n  (defun symb (&rest args)\n    (values (intern (apply #'mkstr args)))))\n\n(defmacro def-memoised (name args &body body)\n  (let ((table-name (symb name '-cache)))\n    `(progn\n       (defvar ,table-name (make-hash-table :test #'equal))\n       (defun ,name (,@args)\n         (or (gethash (list ,@args) ,table-name)\n             (setf (gethash (list ,@args) ,table-name) ,@body))))))\n\n(def-memoised sum-divisors (n)\n  (do ((sum 1)\n       (x   2 (incf x)))\n      ((> x (sqrt n)) sum)\n    (when (= (mod n x) 0)\n      (let ((upper (floor n x)))\n        (incf sum (+ x (if (\/= upper x) upper 0)))))))\n\n(defun buddy (low high)\n  (or (do ((x low (incf x)))\n          ((> x high))\n        (let* ((sum   (sum-divisors x))\n               (other (sum-divisors (1- sum))))\n          (when (and (= x (1- other))\n                     (> (1- sum) x))\n            (return (format nil \"~a\" (list x (1- sum)))))))\n      \"Nothing\"))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32523,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun summed-divisors (n)\n  (loop :with limit := (isqrt n)\n        :for div :from 1 :upto limit\n        :when (integerp (\/ n div))\n        :sum (cond\n               ((= div 1) 1)\n               ((= (* div div) n) div)\n               (t (+ div (\/ n div))))))\n\n(defun find-buddy (n)\n  (let ((buddy (1- (summed-divisors n))))\n    (and (> buddy n)\n         (= (summed-divisors buddy) (1+ n))\n         buddy)))\n\n(defun buddy (start nd)\n  (do ((n start (1+ n)))\n      ((> n nd) \"Nothing\")\n      (let ((maybe-buddy (find-buddy n)))\n        (if maybe-buddy\n            (return (format nil \"(~D ~D)\" n maybe-buddy))))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32524,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun summed-divisors (n)\n  (loop :with limit := (floor (sqrt n))\n        :for div :from 1 :upto limit\n        :when (integerp (\/ n div))\n        :sum (cond\n               ((= div 1) 1)\n               ((= (* div div) n) div)\n               (t (+ div (\/ n div))))))\n\n(defun find-buddy (n)\n  (let ((buddy (1- (summed-divisors n))))\n    (and (> buddy n)\n         (= (summed-divisors buddy) (1+ n))\n         buddy)))\n\n(defun buddy (start nd)\n  (do ((n start (1+ n)))\n      ((> n nd) \"Nothing\")\n      (let ((maybe-buddy (find-buddy n)))\n        (if maybe-buddy\n            (return (format nil \"(~D ~D)\" n maybe-buddy))))))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32525,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun buddy (start nd)\n  (buddy-helper start nd start))\n\n(defun divisors (n)\n  (let ((maxim (floor (sqrt n)))) \n    (declare (type fixnum maxim))\n        (labels ((divs (n next res)\n                   (declare (type fixnum n next))\n                   (if (> next maxim) res\n                       (multiple-value-bind (q r) (floor n next)\n                         (declare (type fixnum q r))\n                         (cond \n                           ((zerop r) \n                            (divs n (1+ next) (append res (list next q))))\n                           (t (divs n (1+ next) res)))))))\n          (divs n 2 (if (= n (* maxim maxim)) (list maxim) '())))))\n\n(defun sum (l)\n  (if (null l) 0\n      (reduce #'+ l)))\n\n(defun buddy-helper (start nd n)\n  (declare (type fixnum start nd n))\n  (let* ((m (sum (divisors n)))\n         (b2 (sum (divisors m))))\n    (cond \n      ((> n nd) \"Nothing\")\n      ((and (\/= n m) (= n b2) (> m n)) (format nil \"~A\" (list n m)))\n      (t (buddy-helper start nd (1+ n))))))\n\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32526,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun buddy (start nd)\n\t(loop for n from start to nd\n\t\t\t\tfor m = (find-possible-buddy n)\n\t\t\t\twhen (are-buddies-p n m)\n\t\t\t\t\treturn (format nil \"~a\" (list n m))\n\t\t\t\tfinally (return \"Nothing\")))\n\n(defun find-possible-buddy (n)\n\t(find-divisor-sum n))\n\n(defun are-buddies-p (n m)\n\t(let ((sm (find-divisor-sum m)))\n\t\t(and (= sm n) (< n m))))\n\n(defun find-divisor-sum (n)\n\t\"Find the sum of the divisors\"\n\t(let ((sqrtn (sqrt n)))\n\t\t(loop for d from 2 to sqrtn\n\t\t\t\t\twhen (zerop (mod n d))\n\t\t\t\t\t\tsum d\n\t\t\t\t\t\tand when (\/= d sqrtn)\n\t\t\t\t\t\t\t\t\tsum (\/ n d))))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32527,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:buddy))\n(in-package #:challenge\/solution)\n\n(defun buddy (start nd)\n\t(if (< start nd)\t\t\n\t\t\t(let ((pair \n\t\t\t\t\t\t\t(loop for n from start to nd\n\t\t\t\t\t\t\t\t\t\tfor sn = (find-divisor-sum n)\n\t\t\t\t\t\t\t\t\t\tfor m = (1- sn)\n\t\t\t\t\t\t\t\t\t\tfor sm = (find-divisor-sum m)\n\t\t\t\t\t\t\t\t\t\twhen (and (= sm (1+ n)) (= sn (1+ m)) (< n m))\n\t\t\t\t\t\t\t\t\t\t\treturn (list n m))))\n\t\t\t\t(if pair\n\t\t\t\t\t\t(format nil \"~a\" pair)\n\t\t\t\t\t\t\"Nothing\"))\n\t\t\t\"Nothing\"))\n\n\n(defun find-divisor-sum (n)\n\t\"Find the sum of the divisors\"\n  (1+ (loop for i from 2 to (sqrt n)\n\t\t\t\t\t\twhen (= 0 (mod n i))\n\t\t\t\t\t\t\tif (\/= i (\/ n i))\n\t\t\t\t\t\t\t\tsum (+ i (\/ n i))\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsum i)))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"59df2f8f08c6cec835000012":[{"id":32528,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun parse-input (str)\n  (loop for whole in (uiop:split-string str :separator '(#\\;))\n        for pair = (uiop:split-string whole :separator '(#\\:))\n        collect (nreverse pair)))\n\n(defun compare-name-pairs (n1 n2)\n  (destructuring-bind ((s1 g1) (s2 g2)) (list n1 n2)\n    (if (string-equal s1 s2)\n        (string-lessp g1 g2)\n        (string-lessp s1 s2))))\n\n(defun meeting (s)\n  (let ((name-pairs (parse-input (string-upcase s))))\n    (sort name-pairs #'compare-name-pairs)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32529,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun format-a-name (name-str)\n  (reverse (uiop:split-string (string-upcase name-str)\n                              :separator \":\")))\n\n(defun format-names (names-str)\n  (mapcar #'format-a-name (uiop:split-string names-str :separator \";\")))\n\n(defun meeting (s)\n  (sort (format-names s) (lambda (a b) (if (string= (car a) (car b))\n                            (string< (cadr a) (cadr b))\n                            (string< (car a) (car b))))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32530,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun read-to-delim (delim stream)\n  (with-output-to-string (out)\n    (loop :for ch := (read-char stream nil)\n          :until (or (null ch)\n                     (char= ch delim))\n          :do (write-char ch out))))\n\n(defun read-person (stream)\n  (let ((fname (read-to-delim #\\: stream))\n        (lname (read-to-delim #\\; stream)))\n    (list (string-upcase lname)\n          (string-upcase fname))))\n\n(defun read-people (stream)\n  (loop :while (peek-char nil stream nil)\n        :collect (read-person stream)))\n\n(declaim (inline fname lname))\n(defun fname (person)\n  (second person))\n(defun lname (person)\n  (first person))\n\n(defun person< (a b)\n  (if (not (string= (lname a)\n                    (lname b)))\n      (string< (lname a)\n               (lname b))\n      (string< (fname a)\n               (fname b))))\n\n(defun meeting (s)\n  (with-input-from-string (stream s)\n    (sort (read-people stream) #'person<)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32531,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n;; (defun split-string (string separators)\n;;   (loop with start = 0\n;;         for char across string\n;;         for end below (length string)\n;;         when (member char separators :test #'char=)\n;;           collect (subseq string (shiftf start (setf start (1+ end))) end)))\n\n(asdf:load-system :uiop)\n(defun list< (a b)\n  (cond\n    ((string< (first a) (first b)) t)\n    ((string= (first a) (first b)) (string< (second a) (second b)))\n    (t nil)))\n\n(defun meeting (s)\n  (let* ((names (uiop\/utility:split-string (string-upcase s) :separator '(#\\; #\\:)))\n         (pairs (loop for (first last) on names by #'cddr while last\n                      collect (list last first))))\n    (stable-sort pairs #'list<)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32532,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl :split-sequence)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun meeting (s)\n  (defun split-list-of-strings-over-period (list)\n    (loop :for i :in list :collect (split-sequence #\\. i)))\n  (defun sort-list-alphabetically (list)\n    (sort list #'string-lessp))\n  (defun concatenate-list-of-strings-with-dots (list)\n    (loop :for i :in list :collect\n                          (concatenate 'string (car i) \".\" (cadr i))))\n  (defun flip-every-two-in-list (list)\n    (loop :for i :in list :collect (list (cadr i) (car i))))\n  (defun split-list-of-strings-over-colon (list)\n    (loop :for i :in list :collect (split-sequence #\\: i)))\n  (defun split-string-over-semicolon (s)\n    (split-sequence #\\; s))\n  (defun an-upper-case-version-of-the-string (s)\n    (string-upcase s))\n  (split-list-of-strings-over-period\n   (sort-list-alphabetically\n    (concatenate-list-of-strings-with-dots\n     (flip-every-two-in-list\n      (split-list-of-strings-over-colon\n       (split-string-over-semicolon\n        (an-upper-case-version-of-the-string s))))))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32533,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun meeting (s)\n  (let* ((s (string-upcase s))\n         (split (split-string s #\\;)))\n    (mapcar #'(lambda (x) (list (second x) (first x))) \n            (sort \n             (mapcar #'(lambda (x) (split-string x #\\:)) split)\n             #'comparator))))\n\n(defun comparator (x y)\n  (if (string= (second x) (second y))\n      (string-lessp (first x) (first y))\n      (string-lessp (second x) (second y))))\n\n(defun split-string (string delimiter)\n    \"Returns a list of substrings of string\ndivided by ONE space each.\nNote: Two consecutive spaces will be seen as\nif there were an empty string between them.\"\n    (loop for i = 0 then (1+ j)\n          as j = (position delimiter string :start i)\n          collect (subseq string i j)\n          while j))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32534,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl :uiop)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun meeting (s)\n  (stable-sort\n    (sort\n      (mapcar (lambda (e) (reverse (uiop:split-string e :separator '(#\\:))))\n        (uiop:split-string (string-upcase s) :separator '(#\\;)))\n      #'string<= \n      :key #'cadr)\n    #'string<\n    :key #'car))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32535,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun split (string &key (delimiterp))\n  (loop :for beg = (position-if-not delimiterp string)\n    :then (position-if-not delimiterp string :start (1+ end))\n    :for end = (and beg (position-if delimiterp string :start beg))\n    :when beg :collect (subseq string beg end)\n    :while end))\n\n(defun separator (sep)\n  (lambda (c) (char= c sep)))\n\n(defun split-names (names)\n  (mapcar (lambda (pair)\n\t    (reverse (split (string-upcase pair) :delimiterp (separator #\\:))))\n\t  (split names :delimiterp (separator #\\;))))\n\n(defun sort-rule (a b)\n  (if (string< (first a) (first b))\n      t\n      (if (and (string= (first a) (first b)) (string< (second a) (second b)))\n\t  t\n\t  nil)))\n\n(defun meeting (s)\n    (sort (split-names s) #'sort-rule)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32536,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun split (c s)\n  (defun f (l acc)\n    (if (null l)\n      (cons acc NIL)\n      (if (char= c (car l))\n        (cons acc (f (cdr l) \"\"))\n        (f (cdr l) (concatenate 'string acc (string (car l)))))))\n  (f (coerce s 'list) \"\"))\n\n(defun meeting (s)\n  (setq l (sort\n    (mapcar (lambda (s) (split #\\: s)) (split #\\; (string-upcase s)))\n    (lambda (a b)\n      (if (string= (nth 1 a) (nth 1 b))\n        (string< (car a) (car b))\n        (string< (nth 1 a) (nth 1 b))))))\n  (loop :for (fn ln) :in l\n    :collect (list ln fn)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32537,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:meeting))\n(in-package #:challenge\/solution)\n\n(defun split(str delim) \n\t(let ((prev 0)) \n\t  (append \n\t     (loop \n\t    :for i \n\t    :from 0\n\t    :to (- (length str) 1) \n\t    :when (char= (char str i) delim) \n\t    :collect (let ((temp prev)) (setq prev (+ i 1)) (subseq str temp i))\t\n\t    )\n\n\t    (list (subseq str prev (length str) ) )\n\t  )\n\t)\n)\n\n(defun meeting (s)\n\t(sort \n\t\t(mapcar  \n\t\t\t(lambda (x) (reverse (split (string-upcase x) (char \":\" 0))) )\n\t\t\t(split s (char \";\" 0))\n\t\t)\n\t\t(lambda (x y) \n\t\t\t(if (string= (first x) (first y)) \n\t\t\t\t(funcall #'string-lessp (second x) (second y))\n\t\t\t\t(funcall #'string-lessp (first x) (first y))\n\t\t\t)\n\t\t)\n\t)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5a045fee46d843effa000070":[{"id":32538,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun sieve (n)\n  (let ((prime-array (make-array (1+ n) :element-type 'bit :initial-element 1)))\n    (loop\n      for p from 2 upto (isqrt n)\n      if (sbit prime-array p)\n      do (loop\n           for j from (* p p) upto n by p\n           do (setf (sbit prime-array j) 0)))\n    (loop\n      for i from 2 upto n\n      if (= 1 (sbit prime-array i))\n      collect i)))\n(defun get-power (n p &optional (i n) (s 0))\n  (if (>= i p)\n      (let ((s (+ s (floor i p))))\n        (get-power n p (floor i p) s))\n      s))\n(defun mk-string (n x)\n  (let ((p (get-power n x)))\n    (if (= p 1)\n        (format nil \"~a\" x)\n        (format nil \"~a^~a\" x p))))\n(defun decomp (n)\n    (if (< n 2)\n      1\n      (let* ((u (sieve n)) \n            (a (mapcar (lambda (x) (mk-string n x)) u)))\n        (string-right-trim \" \" (format nil \"~{~A ~^* ~}\" a)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32539,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun decomp* (num cur)\n  (cond\n    ((= 1 num) ())\n    ((= 0 (mod num cur)) (cons cur (decomp* (\/ num cur) cur)))\n    (t (decomp* num (1+ cur)))))\n\n(defun decomp** (n)\n  (let* ((a (loop for x from 2 to n\n\t\t collect x))\n\t(b (apply #'append (mapcar (lambda (x) (decomp* x 2)) a))))\n    \n    b))\n\n(defun klmnop (lst)\n  (cond\n    ((null lst) ())\n    (t (cons (list (car lst) (count (car lst) lst))\n\t     (klmnop (remove (car lst) lst))))))\n\n(defun style (lst)\n  (mapcar (lambda (x) (if (= 1 (second x))\n\t\t\t  (write-to-string (first x))\n\t\t\t  (concatenate 'string (write-to-string (first x))\n\t\t\t\t       \"^\"\n\t\t\t\t       (write-to-string (second x)))))\n\t  lst))\n\n(defun style-up (lst)\n  (cond\n    ((null (rest lst)) (car lst))\n    (t (concatenate 'string (car lst)\n\t\t    \" * \"\n\t\t    (style-up (rest lst))))))\n\n(defun decomp (n)\n  (style-up (style (klmnop (decomp** n)))))\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32540,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun prime-decomp (x)\n  (do* ((limit (isqrt x))\n        (seen  (make-array (list limit) :element-type 'boolean :initial-element nil))\n        (res   nil)\n        (n     2 (1+ n)))\n       ((> n x) res)\n    (loop while (= 0 (mod x n))\n          sum 1 into times\n          do (setf x (floor x n))\n          finally (when (> times 0)\n                    (push (cons n times) res)))))\n\n(defun merge-alists-into (xs ys)\n  (loop for (b . e) in ys\n        for cell = (assoc b xs)\n        if cell\n          do (incf (cdr cell) e)\n        else do (setf (cdr xs) (cons (cons b e) (cdr xs)))))\n\n(defun fact-decomp (x)\n  (loop with full-decomp = (prime-decomp x)\n        for i from (1- x) downto 2\n        do (merge-alists-into full-decomp (prime-decomp i))\n        finally (return full-decomp)))\n\n(defun decomp (n)\n  (with-output-to-string (s)\n    (format s\n            \"~{~a~^ * ~}\"\n            (mapcar (lambda (cell) (if (= 1 (cdr cell))\n                                  (format nil \"~a\" (car cell))\n                                  (format nil \"~a^~a\" (car cell) (cdr cell))))\n                    (sort (fact-decomp n) #'< :key #'car)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32541,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun primes-to (n)\n  (if (= n 2) '(2)\n      (let* ((n1 (floor (\/ n 2))) \n             (cache (make-array n1 :element-type 'boolean :initial-element t)))\n        (loop for x from 0 to (1- n1)\n              when (aref cache x)\n              do (loop for y from (+ x x x 3) to (1- n1) by (+ x x 3)\n                       do (setf (aref cache y) nil)))\n        (cons 2 (loop for i from 0 to (\/ (- n 3) 2) \n              when (aref cache i)\n              collect (+ i i 3))))))\n\n(defun decomp (n)\n  (let* ((primes (primes-to n))\n         (l (length primes))\n         (col (make-array l :element-type 'integer :initial-element 0)))\n    (loop for i from 2 to n do\n          (loop for j from 0 below l\n                with x = i\n                do\n                (when (= x 1) (return))\n                (loop \n                  with c = (elt primes j)\n                  do\n                  (if (zerop (mod x c))\n                      (progn (incf (aref col j))\n                             (setf x (\/ x c)))\n                      (return)))))\n    (format nil \"~{~{~a~[~;~:;^~:*~a~]~}~^ * ~}\" \n            (loop for i from 0 below l\n                  collect (list (elt primes i) (aref col i))))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32542,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun decomp (n)\n\t(print-factors (find-factors n)))\n\n(defun find-factors (n)\n\t(remove-if #'null\n\t\t\t\t\t\t (loop for p from 2 to n\n\t\t\t\t\t\t\t\t\t when (is-prime-p p)\n\t\t\t\t\t\t\t\t\t\t collect (list p (loop for m from p to n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sum (count-primes m p))))))\n\n(defun count-primes (n p)\n\t\"Gets the number of times the factor p appears in n\"\n\t(loop for c from 0 \n\t\t\t\tuntil (not (zerop (mod n p)))\n\t\t\t\tdo (setf n (\/ n p))\n\t\t\t\tfinally (return c)))\n\n(defun print-factors (factors)\n\t(format nil \"~{~{~d~[~;~:;~:*^~d~]~}~^ * ~}\" factors))\n\n(defun is-prime-p (n)\n\t;;test with 6k+1 check\n\t(when (or (= n 2) (= n 3))\n\t\t(return-from is-prime-p t))\n\t(when (or (zerop (mod n 2))\n\t\t\t\t\t\t(zerop (mod n 3)))\n\t\t(return-from is-prime-p nil))\n\t(loop for p from 5 by 6\n\t\t\t\twhile (<= (* p p) n)\n\t\t\t\twhen (or (zerop (mod n p))\n\t\t\t\t\t\t\t\t (zerop (mod n (+ 2 p))))\n\t\t\t\t\tdo (return-from is-prime-p nil))\n\tt)\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32543,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun primenum (n d)\n  (if (= (mod n d) 0)\n      (if (= n 2) t nil)\n      (if (> (sqrt n) d)\n          (primenum n (+ d 1))\n          t)))\n\n(defun factorshelper (i i2 n)\n  (if (= (mod n i) 0)\n      (+ 1 (factorshelper (* i i2) i2 n))\n      0))\n\n(defun factors (i n)\n  (loop for j from 1 to n\n        if (= (mod j i) 0)\n          sum (factorshelper i i j) into results\n        finally (return results)))\n\n(defun factorformat (i n)\n  (cond ((= n 0) nil)\n        ((= n 1) (write-to-string i))\n        (t (format nil \"~A^~A\" i n))))\n\n(defun decomp (n)\n  (format nil \"~{~A~^ * ~}\"\n    (loop for i from 2 to n\n          if (and (primenum i 2))\n            collect (factorformat i (factors i n)) into strs\n          finally (return strs))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32544,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun decomp (n)\n  (join\n     (mapcar #'stringify-expt\n             (loop with nums = (range 2 n)\n                  for i in (primes-upto n)\n                  collect (list i (loop for x in nums\n                                        sum (count-multiples x i)))))))\n\n(defun join (strs)\n  \"Given a list of strings, join with asterisks.\"\n  (format nil \"~{~a~^ * ~}\" strs))\n\n(defun stringify-expt (lst)\n  \"Given a list of (base, expt) return a string of 'base^expt'.\n  If the exponent is 1, just return the base\"\n  (if (= (second lst) 1)\n      (format nil \"~a\" (first lst))\n      (format nil \"~{~a~^^~}\" lst)))\n\n(defun count-multiples (n fac)\n  \"Return the number of times fac divides n evenly.\"\n  (loop for base = n then (\/ base fac)\n        while (zerop (rem base fac))\n        count 1))\n\n(defun primes-upto (n)\n  \"Return all prime numbers below n.\"\n  (loop for fac from 2 to n\n        when (notany (lambda (i) (zerop (mod fac i))) factors)\n        collect fac into factors\n        finally (return factors)))\n\n(defun range (start end)\n  (loop for i from start to end collect i))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32545,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n\n(defun small-primes-less-than (n)\n  (labels ((rec (known-primes candidate-primes)\n             (if (null candidate-primes)\n                 known-primes\n                 (let ((candidate-prime (car candidate-primes)))\n                   (if (notany #'(lambda (x) (zerop (mod candidate-prime x))) known-primes) ; The candidate isn't divisible by any known prime.\n                       (rec (append known-primes (list candidate-prime)) (cdr candidate-primes)) ; Add the largest prime to the end of the list of primes.\n                       (rec known-primes (cdr candidate-primes))))))) ; Or go on to the next candidate. \n    (rec '(2) (loop for i from 3 upto n collect i))))\n\n\n(defun factorial (n)\n  \"Doing an iteractive factorial feels ... wrong...\"\n  (if (= n 0)\n      1\n      (apply #'* (loop for i from 1 upto n collect i))))\n\n\n(defun decomp (n)\n  (labels ((factors-powers-alists ()   ; for each number less than or equal to n, produce an alist containing prime-power cons pairs\n             (let ((primes (small-primes-less-than n)))\n               (loop for k from 1 upto n collect (loop for p in primes collect (prime-dot-product k p)))))\n           (combine-factors-powers-alists (alists) ; \"add\" together all of the prime factors (multiply by summing the powers of the primes)\n             (let ((factors (make-array (1+ n) :initial-element 0)))\n               (loop for alist in alists do (loop for pare in alist do (incf (aref factors (car pare)) (cdr pare))))\n               (loop for i upto n unless (zerop (aref factors i)) collect (cons i (aref factors i)))))\n           (prime-dot-product (m p) ; If m is divisible by p^a, returns (p . a)\n             (cond ((not (zerop (mod m p))) (cons p 0))\n                   ((not (zerop (mod (\/ m p) p))) (cons p 1))\n                   (t (cons p (1+ (cdr  (prime-dot-product (\/ m p) p)))))))\n           (format-base-power (alist-element)  ; Turns (p . a) into \"p^a\" or \"p\" as appropriate.\n             (cond ((zerop (cdr alist-element)) nil)\n                   ((= 1 (cdr alist-element)) (format nil \"~A\" (car alist-element)))\n                   (t (format nil \"~A^~A\" (car alist-element) (cdr alist-element))))))\n    (let* ((prime-decomposition (combine-factors-powers-alists (factors-powers-alists))) ; Do the prime decomposition of the factorial.\n           (factor-strings (loop for pair in prime-decomposition collect (format-base-power pair)))) ; Express each prime factor-power pair as a string.\n      (format nil \"~{~A~^ ~^*~^ ~}\" factor-strings)))) ; Join the strings to create the final answer.\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32546,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun max-power.factor (exp n)\n  (cond ((= exp n) (cons 1 0))\n        ((= (rem n exp) 0) (let* ((mp.f (max-power.factor exp (\/ n exp)))\n                                  (mp (car mp.f))\n                                  (f (cdr mp.f)))\n                              (cons (+ mp 1) f)))\n        (T (cons 0 n))))\n\n(defun factorized (ns)\n  (if (null ns)\n      ns\n      (let* ((n (car ns))\n             (p.fs (mapcar #'(lambda (x) (max-power.factor n x)) ns))\n             (ps (mapcar #'car p.fs))\n             (p-sum (reduce #'+ ps))\n             (fs (remove-if-not #'(lambda (x) (> x 0)) (mapcar #'cdr p.fs))))\n            (cons (cons n p-sum) (factorized fs)))))\n  \n(defun f.p2str (f.p)\n  (let* ((f (car f.p)) (p (cdr f.p))\n         (f-str (format nil \"~A\" f))\n         (p-str (if (> p 1)\n                    (concatenate 'string \"^\" (format nil \"~A\" p))\n                    \"\")))\n        (concatenate 'string f-str p-str)))\n\n(defun range (s e) (loop for n from s to e collect n))\n\n(defun decomp (n)\n  (let* ((factors (range 2 n))\n         (fact.pows (factorized factors))\n         (fp-strs (mapcar #'f.p2str fact.pows)))\n        (format nil \"~{~A~^ * ~}\" fp-strs)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32547,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:decomp))\n(in-package #:challenge\/solution)\n\n(defun is-prime (n)\n  (or (= n 2)\n      (loop for i from 2 to (isqrt n)\n            never (zerop (rem n i)))))\n\n(defun find-exp (n p)\n  (if (zerop (rem n p)) \n      (1+ (find-exp (\/ n p) p))\n      0))\n\n(defun find-exp-fact (n p)\n  (loop for i from p to n\n        sum (find-exp i p) into e\n        finally (return e)))\n\n(defun decomp (n)\n  (let ((v\n    (loop for p from 2 to n\n          when (is-prime p)\n          collect (let ((e (find-exp-fact n p)))\n                       (if (> e 1)\n                           (format nil \"~d^~d\" p e)\n                           (format nil \"~d\" p))))))\n    (format nil \"~{~A~^ * ~}\" v))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5a057ec846d843c81a0000ad":[{"id":32548,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (setq res 1)\n  (setq shifted 1)\n  (defun shift () (setq shifted (mod (* shifted 10) n)))\n  (if (not (= 1 (gcd n 10))) \n      (setq res -1)\n      (loop until (= 1 (shift)) do (incf res))\n  )\n  res\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32549,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun coprime-10-p (n)\n  (or (= 0 (mod n 2))\n      (= 0 (mod n 5))))\n\n(defun cycli (n)\n  (if (coprime-10-p n)\n      -1\n      (loop :for i :from 1\n            :with initial-modulus := (mod 10 n)\n            :for current := initial-modulus :then (mod (* current initial-modulus) n)\n            :when (= 1 current)\n            :return i)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32550,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun check-coprime-with-10 (num)\n  (if (or (= 0 (mod num 2))\n\t  (= 0 (mod num 5))\n\t  (= 0 (mod num 10)))\n      nil\n      t))\n\n(defun get-digits-after-coma (num div flag cur)\n  (cond\n    ((and (= 1 div) flag) cur)\n    (t (get-digits-after-coma num (mod (* 10 div) num) t (1+ cur)))))\n\n\n\n(defun cycli (n)\n    (cond\n      ((= n 1) nil)\n      ((check-coprime-with-10 n) (get-digits-after-coma n 1 nil 0))\n      (t -1)))\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32551,"user_id":163,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n &optional (r (mod 10 n)) (i 1))\n\"period lenght for decimal representation of 1\/n\"  \n  (cond\n    ((= (mod n 2) 0) -1)\n    ((= (mod n 5) 0) -1)\n    ((= r 1) i)\n    (t (cycli n (mod (* r 10) n) (+ 1 i)))\n    )\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32552,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (setf (symbol-function 'f) #'(lambda (a b n) (if (and (eq a 10) (> n 0)) n (f (* (mod a b) 10) b (+ n 1)))))\n  (if (or (eq (mod n 2) 0) (eq (mod n 5) 0)) -1 (f 1 n -1))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32553,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (defun walk (m i)\n    (cond ((= 1 m) i)\n          (t (walk (mod (* m 10) n) (+ 1 i)))\n      ))\n  (if (or (= 0 (mod n 2)) (= 0 (mod n 5))) \n    -1\n    (walk (mod 10 n) 1)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32554,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (labels ((decimal-expansion (i)\n             (let ((carry 10))\n               (lambda () \n                 (multiple-value-bind (d r) (floor carry i)\n                   (setf carry (* 10 r))\n                   (values d carry))))))\n    (let ((de (decimal-expansion n)))\n      (if (or (= n 0) (\/= (gcd n 10) 1))\n          -1\n          (loop with (init-v init-carry) = (multiple-value-list (funcall de))\n             for (v carry) = (multiple-value-list (funcall de))\n             for len from 1\n             until (and (= v init-v) (= carry init-carry))\n             finally (return len))))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32555,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (if (or (zerop (mod n 2)) (zerop (mod n 5)))\n      -1\n        (loop for base = 10 then (* r 10)\n              for r = (rem base n)\n              if (= r 1) do (return (1+ c))\n              counting t into c)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32556,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (if (= (gcd n 10) 1)\n      (loop for m = (mod 10 n) then (mod (* 10 m) n)\n            for c upfrom 1\n            when (= m 1) return c)\n      -1))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32557,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:cycli))\n(in-package #:challenge\/solution)\n\n(defun cycli (n)\n  (if (= (gcd n 10) 1)\n      (loop with m = 1\n            with d integer\n            for c upfrom 1\n            do (setf (values d m) (floor (* 10 m) n))\n            when (= m 1) return c)\n      -1))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5aba780a6a176b029800041c":[{"id":32558,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (- bound (mod bound divisor)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32559,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (* divisor (floor bound divisor)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32560,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (d b)\n  (* d (floor b d))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32561,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound &optional (multiplier 1))\n  (if (> (* divisor multiplier) bound)\n      (* divisor (- multiplier 1))\n      (max-multiple divisor bound (+ multiplier 1))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32562,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (defun find-max-multiple (divisor bound best n)\n    (when (and (= 0 (mod n divisor)) (> n best))\n          (setq best n))\n    \n    (if (< n bound)\n        (find-max-multiple divisor bound best (+ n 1))\n        best))\n  \n  (find-max-multiple divisor bound 1 0))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32563,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (car (loop :for i :from 1 :to bound\n        :when (= (mod (- bound (- i 1)) divisor) 0)\n        :collect (- bound (- i 1)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32564,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (loop for i from divisor to bound\n\t      when (zerop (rem i divisor))\n\t      maximizing i))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32565,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (- bound (mod bound divisor)) ;biggest integer dividable by divisor below bound\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32566,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (loop :for x = divisor :then (+ x divisor)\n        :until (> (+ x divisor) bound)\n        :finally (return x)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32567,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:max-multiple))\n(in-package #:challenge\/solution)\n\n(defun max-multiple (divisor bound)\n  (setq mult (floor (\/ bound divisor)))\n  (* mult divisor)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ae62fcf252e66d44d00008e":[{"id":32568,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  \n(max (* (+ a b) c ) (* a (+ b c)) (* a b c) (+ a b c)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32569,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n   (max\n     (* a b c)\n     (+ a b c)\n     (* a (+ b c))\n     (* (+ a b) c)\n     (+ a (* b c))\n     (+ (* a b) c)\n  )\n)","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32570,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  \"Return the highest achievable result.\"\n  (let ((aa (* a (* b c)))\n        (bb (* a (+ b c)))\n        (cc (+ a (+ b c)))\n        (dd (+ a (* b c)))\n        (aaa (* c (* a b)))\n        (bbb (* c (+ a b)))\n        (ccc (+ c (+ a b)))\n        (ddd (+ c (* a b)))\n        )\n       (max aa bb cc dd aaa bbb ccc ddd))\n  )","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32571,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  (max \n   (* a (+ b c))\n   (* a b c) \n   (+ a (* b c)) \n   (* (+ a b) c)\n   (+ a b c)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32572,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  \"Return the highest achievable result.\"\n  (max (+ a b c)\n       (+ a (* b c))\n       (+ (* a b) c)\n       (* a b c)\n       (* a (+ b c))\n       (* (+ a b) c)))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32573,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  \"Return the highest achievable result.\"\n  (let ((var0 (* a (+ b c)))\n\t(var1 (* a b c))\n\t(var2 (+ a (* b c)))\n\t(var3 (* (+ a b) c))\n\t(var4 (+ a b c))\n\t(var5 (* a (+ b c))))\n    (max var0 var1 var2 var3 var4 var5)))\n\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32574,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defvar var0)\n(defvar var1)\n(defvar var2)\n(defvar var3)\n(defvar var4)\n(defvar var5)\n(defvar result)\n\n(defun expression_matter (a b c)\n  \"Return the highest achievable result.\"\n      (setq var0 (* a (+ b c)))\n    (setq var1 (* a (* b c)))\n    (setq var2 (+ a (* b c)))\n    (setq var3 (* c (+ a b)))\n    (setq var4 (+ c (* a b)))\n    (setq var5 (+ a (+ b c)))\n    (max var0 var1 var2 var3 var4 var5))\n","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32575,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  (max (+ a b c)\n       (* a b c)\n       (* (+ a b) c)\n       (* a (+ b c))))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32576,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  (let ((max 0))\n       (when (< max (* a b c)) (setq max (* a b c)))\n       (when (< max (+ (* a b) c)) (setq max (+ (* a b) c)))\n       (when (< max (+ a (* b c))) (setq max (+ a (* b c))))\n       (when (< max (+ a b c)) (setq max (+ a b c)))\n       (when (< max (* a (+ b c))) (setq max (* a (+ b c))))\n       (when (< max (* (+ a b) c)) (setq max (* (+ a b) c)))\n       max))","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32577,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:expression_matter))\n(in-package #:challenge\/solution)\n\n(defun expression_matter (a b c)\n  \"Return the highest achievable result.\"\n  (max (+ a (+ b c)) (+ a (* b c)) (* (+ a b) c) (+ (* a b) c) (* a (+ b c)) (* a (* b c)))\n  \n  )","lang_id":8,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5b1cd19fcd206af728000056":[{"id":32578,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (\/ (- (1+ (* 2 m)) (sqrt (1+ (* 4 m)))) (* 2 m))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32579,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (defun u (m x)\n    (do* ((i 1 (1+ i))\n          (p 0 s)\n          (pow-x x (* x pow-x))\n          (s x (+ s (* i pow-x))))\n         ((or (>= s m)\n              (<= (- s p) 1e-12)) s)))\n  (do* ((low 0.0d0)\n        (high 1.0d0)\n        (p 0 x)\n        (x 0.5d0 (\/ (+ low high) 2))\n        (s (u m x) (u m x))\n        (diff (abs (- p x)) (abs (- p x))))\n       ((<= diff 1e-12) x)\n    (if (> s m)\n        (setf high x)\n        (setf low x))))\n\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32580,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n;; This is an arithmetico-geometric series. The closed form value for it is:\n;; x \/ (1 - x)^2 = m\n;; So solving this problem is no harder than solving a quadratic equation.\n\n(defun quadratic-solver (a b c)\n  (let* ((discriminant (- (* b b) (* 4 a c)))\n         (vertex (- 0 (\/ b (* 2 a))))\n         (rhe (\/ (sqrt discriminant) (* 2 a))))\n     (values (- vertex rhe) (+ vertex rhe))))\n\n(defun solve (m)\n  (quadratic-solver m (- 0 (* 2 m) 1) m)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32581,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (\/ m (+ 0.5 m (sqrt (+ m 0.25))))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32582,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (- 1\n     (\/ (- (sqrt (+ m 0.25)) 0.5)\n        m)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32583,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (let ((s (sqrt (+ 1.0 (* 4.0 m)))))\n    (\/ (- (+ 1.0 (* 2.0 m)) s) (* 2.0 m))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32584,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (flet ((solve-quadratic (a b c)\n           (let ((u (coerce a 'double-float))\n                 (v (coerce b 'double-float))\n                 (w (coerce c 'double-float)))\n             (let ((d (sqrt (- (* v v) (* 4 u w))))\n                   (-b (- 0 v))\n                   (2a (* 2 u)))\n               (sort (list (\/ (+ -b d) 2a) (\/ (- -b d) 2a)) #'<)))))\n    (destructuring-bind (x y)  (solve-quadratic m (- 0 (1+ (* 2 m))) m)\n      (if (and (plusp x) (< x 1)) x y))))\n\n\n\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32585,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (let ((d (- (expt (\/ (1+ (* 2 m)) m) 2) 4)))\n    (\/ (- (\/ (1+ (* 2 m)) m) (sqrt d)) 2)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32586,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (\/ (- (+ (* 2 m) 1) (sqrt (+ (* 4 m) 1))) (* 2 m)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32587,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:solve))\n(in-package #:challenge\/solution)\n\n(setq *read-default-float-format* 'double-float)\n\n(defun solve (m)\n  (\/ (- (+ (* 2 m) 1) (sqrt (- (expt (+ (* 2 m) 1) 2) (* 4 (expt m 2))))) (* 2 m)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5ce399e0047a45001c853c2b":[{"id":32588,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (loop for num in (cons 0 ls)\n        for total = (reduce #'+ ls) then (- total num)\n        collect total))\n","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32589,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (let ((acc 0))\n    (append (nreverse (loop for item in (nreverse ls) collect (incf acc item))) '(0))))","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32590,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n\n(defun parts_sums (ls)\n  (reverse\n   (loop for x in (cons 0 (reverse ls))\n         sum x into summ\n         collect summ)))","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32591,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (let ((lst (reverse ls)) (res '(0)))\n       (loop :for elmt :in lst\n             :do (setq res (append (list (+ elmt (car res))) res)))\n       res))\n","lang_id":8,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32592,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (labels ((rec (xs acc)\n             (if (null xs)\n                 acc\n                 (rec (cdr xs) (cons (+ (car xs) (car acc)) acc)))))\n    (rec (reverse ls) (list 0))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32593,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n    (setq cumsums '(0))\n    (dolist (x (reverse ls) cumsums) (push (+ x (first cumsums)) cumsums))\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32594,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n; for i from o to lenght - 1 \n; collect sum(from_index(l i))\n\n\n\n(defun parts_sums (ls)\n\t(let( (sum (reduce #'+ ls)))\n\t\t(loop :for i :in (append '(0) ls) :collect (setq sum (- sum i)))\n\t)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32595,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (let* ((s (reduce #'+ ls))\n         (q s)) \n    (loop for i in ls\n          do (setq s (- s i)) \n          collect s into ns\n          finally (return (nconc (list q) ns))\n          ))) \n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32596,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (let ((a ())\n\t(b 0)\n\t(c (reduce #'+ ls)))\n    (loop for x in ls\n\t  do (push (- c b) a)\n\t     (incf b x))\n    (append (reverse a) '(0))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32597,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:parts_sums))\n(in-package #:challenge\/solution)\n\n(defun parts_sums (ls)\n  (loop with ls = (cons 0 (reverse ls))\n\t      for x in ls\n\t      summing x into sum\n\t      collecting sum into parts_sums\n        finally (return (reverse parts_sums))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5da1df6d8b0f6c0026e6d58d":[{"id":32598,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n(defun find-exp (k p)\n  (if (= (mod k p) 0)\n      (1+ (find-exp (\/ k p) p))\n      0)\n)\n\n(defun factor (k f p acc)\n  (if (> (* p p) k)\n      (if (> k 1) (funcall f acc p 1) acc)\n      (let ((e (find-exp k p)))\n           (if (= e 0)\n               (factor k f (1+ p) acc)\n               (factor (\/ k (expt p e)) f (1+ p)\n                       (funcall f acc p e)))))\n)\n      \n\n(defun c (k)\n  (factor k (lambda (acc p n)\n                    (if (= (mod n 2) 1) 0\n                        (* acc (1+ (* 3 (\/ n 2))))))\n          2 1)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32599,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n(defun count-factor-pairs (n)\n  (loop for i from 1 to (isqrt n) by 1\n        for (p q) = (multiple-value-list (floor n i)) \n        count (zerop q)\n        count (and (zerop q) (not (eq i p)))))\n\n(defun c (k)\n  (let ((x (isqrt (* k k k))))\n    (if (eql (truncate (* x x)) (truncate (* k k k)))\n        (count-factor-pairs (floor x))\n        0)))\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32600,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n(let ((known (make-hash-table)))\n  (setf (gethash 1 known) '()\n        (gethash 2 known) '(2)\n        (gethash 3 known) '(3)\n        (gethash 5 known) '(5))\n  (macrolet ((try (i &optional (from 5))\n               `(multiple-value-bind (q r) (floor n ,i)\n                  (when (= 0 r)\n                    (return (cons ,i (divs q ,from)))))))\n    (defun divs (n &optional (from 5))\n      (or (gethash n known)\n          (setf (gethash n known)\n                (loop :initially (try 2) (try 3)\n                      :for i :from from :by 6\n                      :while (<= (* i i) n)\n                      :do (try i i)\n                          (try (+ i 2) i)\n                      :finally (return (list n))))))))\n\n\n(defun c (k)\n  (flet ((divs-num (ls)\n           (let ((res 1))\n             (loop :for (i . pow) :in ls\n                   :do (setf res (* res (+ 1 pow))))\n             res)))\n    (let* ((divs (divs (* k k k)))\n           (std-divs (loop :for (i . rest) :on divs\n                           :for pow :from 1\n                           :when (or (endp rest) (\/= i (first rest)))\n                             :collect (cons i pow)\n                             :and :do (setf pow 0))))\n      (if (every (lambda (p) (evenp (cdr p))) std-divs)\n          (divs-num (mapcar (lambda (p) (cons (car p) (floor (cdr p) 2))) std-divs))\n          0))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32601,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:sigma\n           #:c))\n(in-package #:challenge\/solution)\n\n(defun sigma (n)\n  (setq kMax (floor (sqrt n)))\n  (setf (symbol-function 'f) #'(lambda (k) (if (> k kMax) 0 (if (eq (* k k) n) 1 (if (eq (mod n k) 0) (+ 2 (f (+ k 1))) (f (+ k 1)))))))\n  (f 1)\n  )\n\n(defun c (k)\n  (setq x (floor (sqrt k)))\n  (if (eq k (* x x)) (sigma (* x x x)) 0)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32602,"user_id":53,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n(defun walk (i n ans cnt m j)\n  (cond \n    ((= 1000 j) (* 4 ans))\n    ((and (<= n 1) (= 1 m)) ans)\n    ((\/= 0 (mod n i)) (walk (+ 1 i) n (* ans (+ 1 cnt)) 0 1 (+ 1 j)))\n    (t (walk i (floor n i) ans (+ 1 cnt) 0 (+ 1 j)))))\n\n(defun c (k)\n  (let ((sq (floor (sqrt k))))\n    (if (\/= k (* sq sq))\n      0\n      (walk 2 (* k sq) 1 0 1 0))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32603,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n;;; To solve the problem, find the prime factorization of k^3 , then find a way\n;;; to distribute those primes to x and y such that the powers of the primes add up correctly.\n\n(defun eratosieve-primes (n)\n  (let ((prime-vector (make-array (1+ n) :initial-element t)))\n    (setf (aref prime-vector 0) nil)\n    (setf (aref prime-vector 1) nil)\n    (let ((upper-limit-candidate-prime (1+ (isqrt n))))\n      (do ((current-candidate 2 (1+ current-candidate)))\n           ((< upper-limit-candidate-prime current-candidate)\n            (loop for i upto n when (aref prime-vector i) collect i))\n        (when (aref prime-vector current-candidate)\n          (loop for m from (* 2 current-candidate) upto n by current-candidate\n                do (setf (aref prime-vector m) nil)))))))\n\n\n\n(defvar +primes+ (eratosieve-primes 20000000))\n\n\n\n(defun factor-into-prime-power-alist (n)\n  (labels ((rec (remaining-prime-factors incomplete-alist remaining-primes)\n             (if (= 1 remaining-prime-factors)\n                 (nreverse incomplete-alist)\n                 (let ((p (car remaining-primes)))\n                   (if (zerop (mod remaining-prime-factors p))\n                       (let ((pair (cons p (do ((power 1 (1+ power))\n                                                (divisor p (* p divisor)))\n                                               ((not (zerop (mod remaining-prime-factors divisor))) (1- power))))))\n                         (rec (\/ remaining-prime-factors (expt (car pair) (cdr pair))) (cons pair incomplete-alist) (cdr remaining-primes)))\n                       (rec remaining-prime-factors incomplete-alist (cdr remaining-primes)))))))\n    (rec n nil +primes+)))\n\n\n\n\n(defun c (k)\n  (let ((prime-decomposition (factor-into-prime-power-alist k)))\n    (cond\n      ((not (integerp k)) 0)\n      ((<= k 0) 0) \n      ((= 1 k) 1)    ; 1 is a special number, it gets its own case.\n      ((some #'(lambda (pair) (oddp (cdr pair))) prime-decomposition) 0); If any prime factor in k has an odd power, then no pos int x or y will work.\n      (t (apply #'* (loop for pair in prime-decomposition collect (1+ (\/ (* 3 (cdr pair)) 2))))))))\n\n        ","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32604,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n(defun count-divisors (n)\n  (loop with upper = (isqrt (1- n))\n        with m = (if (= n (expt (1+ upper) 2)) 1 0)\n        for k from 1 upto upper\n        count (zerop (mod n k)) into divs\n        finally (return (+ (* 2 divs) m))))\n\n(defun c (k)\n  (let ((sqrt-k (isqrt k)))\n    (if (\/= k (expt sqrt-k 2))\n        0\n        (count-divisors (expt sqrt-k 3)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32605,"user_id":492,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:c))\n(in-package #:challenge\/solution)\n\n(defun aux (n cnt k)\n  (if (< (sqrt n) k)\n      (if (= n (* (- k 1)(- k 1)))\n          (- cnt 1)\n          cnt)\n      (if (= 0 (rem n k))\n          (aux n (+ 2 cnt) (+ 1 k))\n          (aux n cnt (+ 1 k)))))\n(defun c (k)\n  (let ((r (isqrt k)))\n    (if (= k (* r r))\n        (aux (* k r) 0 1)\n        0)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5f70c883e10f9e0001c89673":[{"id":32606,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (sort boxes (ecase dir (#\\R #'<) (#\\L #'>))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32607,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (if (string= dir \"R\")\n   (sort boxes #'<)\n   (sort boxes #'>)\n   )\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32608,"user_id":564,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (d ns)\n  (sort ns (if (char= #\\R d) #'< #'>)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32609,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (sort boxes (if (char= dir #\\R) #'< #'>)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32610,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (if (eql dir #\\R)\n      (sort boxes #'<)\n      (sort boxes #'>)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32611,"user_id":564,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (ecase dir\n    (#\\R (sort boxes #'<))\n    (#\\L (sort boxes #'>))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32612,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (let  ((tmp (sort boxes (lambda (a b) (<= a b)))))\n    (if (equalp dir #\\R)\n\ttmp\n\t(reverse tmp)\n     )\n    )\n  )\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32613,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (let ((comparator (if (char-equal dir #\\R) #'< #'>)))\n       (sort (copy-seq boxes) comparator)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32614,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (sort boxes (if (eq #\\R dir) '< '>)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32615,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:flip))\n(in-package #:challenge\/solution)\n\n(defun flip (dir boxes)\n  (if (string= dir `R)\n        (sort boxes #'<)\n        (sort boxes #'>)\n      )\n)\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5fc2a48cdb878a00267fd68b":[{"id":32616,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro with_syms ((&rest vars) &body body)\n  `(let ,(loop :for name :in vars :collect `(,name (gensym)))\n        ,@body))\n\n(defmacro dosteps ((var start end step) &body body)\n  (with_syms (start_name end_name step_name)\n    `(let ((,start_name ,start) (,end_name ,end) (,step_name ,step))\n          (cond \n            ((> ,step_name 0) (loop :for ,var :from ,start_name :below ,end_name :by ,step_name :do ,@body ))\n            ((< ,step_name 0) (loop :for ,var :from ,start_name :above ,end_name :by (- ,step_name) :do ,@body))\n            (t nil) ) ) ) )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32617,"user_id":106,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((var start end step) &body body)\n  `(let ((s ,start) (e ,end) (dd ,step))\n    (cond \n      ((< 0 dd) (loop for ,var from s below e by (abs dd) do ,@body))\n      ((> 0 dd) (loop for ,var from s above e by (abs dd) do ,@body))\n    )\n  )\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32618,"user_id":527,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((var start end step) &body body)\n  (let ((b (gensym)) (e (gensym)) (s (gensym)))\n    `(let ((,b ,start) (,e ,end) (,s ,step))\n      (cond\n        ((plusp ,s) (loop for ,var from ,b below ,e by ,s do ,@body))\n        ((minusp ,s) (loop for ,var from ,b above ,e by (- ,s) do ,@body))))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32619,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((var start end step) &body body)\n  (let ((start-sym (gensym))\n\t(end-sym (gensym))\n\t(step-sym (gensym)))\n    `(let* ((,start-sym ,start)\n\t    (,end-sym ,end)\n\t    (,step-sym ,step))\n       (when (\/= ,step-sym 0)\n\t (do ((,var ,start-sym (+ ,var ,step-sym)))\n\t     ((if (> ,step-sym 0)\n\t\t  (>= ,var ,end-sym)\n\t\t  (<= ,var ,end-sym)))\n\t   ,@body)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32620,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro once-only ((&rest names) &body body)\n  (let ((gensyms (loop for n in names collect (gensym))))\n    `(let (,@(loop for g in gensyms collect `(,g (gensym))))\n      `(let (,,@(loop for g in gensyms for n in names collect ``(,,g ,,n)))\n        ,(let (,@(loop for n in names for g in gensyms collect `(,n ,g)))\n           ,@body)))))\n\n(defmacro dosteps ((var start end step) &body body)\n  (once-only (start end step)\n    `\n     (if (< ,step 0)\n       (do ((,var ,start (+ ,var, step)))\n         ((<= ,var ,end))\n         ,@body)    \n                  \n       (when (> ,step 0) (do ((,var ,start (+ ,var ,step)))\n           ((>= ,var ,end))\n          ,@body)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32621,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((var start end step) &body body)\n  (let ((from (gensym))\n        (by (gensym))\n        (upto (gensym))\n        (test (gensym)))\n    `(let* ((,from ,start)\n            (,upto ,end)\n            (,by ,step)\n            (,test (if (> ,by 0) #'>= #'<=)))\n       (unless (zerop ,by)\n         (do ((,var ,from (+ ,var ,by)))\n             ((funcall ,test ,var ,upto))\n           ,@body)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32622,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((var start end step) &body body)\n  `(progn\n      (let ((start- ,start) (end- ,end) (step- ,step))\n      (let  ((,var start-) \n            (direction (if (> step- 0) '< '>)))\n            (defun step-test () (funcall direction ,var end-))\n            (if (or (not (step-test)) (zerop step-))\n              nil\n              (loop\n                while (step-test)\n                do (progn ,@body (incf ,var step-))\n              )\n            )\n      )\n      )\n    )\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32623,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((var start end step) &body body)\n  `(let ((s ,start)\n\t (e ,end)\n\t (st ,step))\n     (cond\n       ((and (< s e) (> st 0))\n\t(loop for ,var from s to (1- e) by st\n\t      do ,@body))\n       ((and (> s e) (< st 0))\n\t(loop for ,var downfrom s to (1+ e) by (- 0 st)\n\t      do ,@body)))))\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32624,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n(defmacro dosteps ((x begin end step) &body body)\n  (let ((start (gensym)) (stop (gensym)) (change (gensym)))\n    `(do* ((,start ,begin) (,stop ,end) (,change ,step)\n           (,x ,start (+ ,x ,change)))\n          ((or (= ,change 0)\n               (and (> ,change 0) (>= ,x ,stop))\n               (and (< ,change 0) (<= ,x ,stop)))\n           nil)\n       ,@body)))\n\n\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32625,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dosteps))\n(in-package #:challenge\/solution)\n\n\n(defmacro dosteps ((var start end step) &body body)\n  (let ((start_name (gensym)) (end_name (gensym)) (step_name (gensym)))\n   `(let ((,start_name ,start) (,end_name ,end) (,step_name ,step))\n    (if (\/= ,step_name 0)\n     (do ((,var ,start_name (+ ,var ,step_name)))\n       ((if (> ,step_name 0) (>= ,var ,end_name) (<= ,var ,end_name)))\n      ,@body\n      )\n     )\n    )\n   )\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"5fde1ea66ba4060008ea5bd9":[{"id":32626,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun burner (c h o)\n  (let ((water 0) (co2 0) (methane 0))\n       (setq water (min (floor h 2) o))\n       (setq h (- h (* water 2)))\n       (setq o (- o water))\n       \n       (setq co2 (min (floor o 2) c))\n       (setq c (- c co2))\n       \n       (setq methane (min (floor h 4) c))\n       (vector water co2 methane)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32627,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun list->vector (list)\n  (make-array (length list) :initial-contents list :adjustable nil))\n\n(defun molecules (amounts formula)\n  (loop for r in formula\n        for m across amounts\n        unless (zerop r)\n          minimize (floor m r)))\n\n(defun update-amounts (amounts formula mols)\n  (loop for r in formula\n        for j from 0 below (length amounts)\n        do (decf (aref amounts j) (* mols r))))\n\n(defun condense (amounts formulae)\n  (mapcar (let ((amounts (list->vector amounts)))\n            (lambda (formula)\n              (let ((mols (molecules amounts formula)))\n                (update-amounts amounts formula mols)\n                mols)))\n          formulae))\n\n(defun burner (c h o)\n  (list->vector (condense (list c h o)\n                          '((0 2 1)\n                            (1 0 2)\n                            (1 4 0)))))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32628,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun burner (c h o)\n  (setq h2o (min (floor h 2) o))\n  (setq o (- o h2o))\n  (setq h (- h (* 2 h2o)))\n  \n  (setq co2 (min (floor o 2) c))\n  (setq c (- c co2))\n  (setq o (- o (* 2 co2)))\n  \n  (setq ch4 (min (floor h 4) c))\n  (setq c (- c ch4))\n  (setq h (- h (* 4 ch4)))\n  \n  (vector h2o co2 ch4)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32629,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun burner (c h o)\n  (let ((water (min (floor h 2) o)))\n    (setf h (- h (* water 2)))\n    (setf o (- o water))\n    (let ((co2 (min (floor o 2) c)))\n      (setf c (- c co2))\n      (setf o (- o (* co2 2)))\n      (let ((methane (min c (floor h 4))))\n        (vector water co2 methane)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32630,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun burner (c h o)\n  (let (water co2 methane)\n       (setq water (min (floor (\/ h 2)) o)\n             h (- h (* water 2))\n             o (- o water)\n             co2 (min c (floor (\/ o 2)))\n             c (- c co2)\n             methane (min c (floor (\/ h 4))))\n       (vector water co2 methane)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32631,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun burner (c h o)\n  (let* ((h2 (floor h 2))\n         (h2o (min h2 o))\n         (h (- h (* 2 h2o)))\n         (o (- o h2o))\n         (o2 (floor o 2))\n         (co2 (min o2 c))\n         (o (- o (* 2 co2)))\n         (c (- c co2))\n         (h4 (floor h 4))\n         (ch4 (min h4 c)))\n        ;; no need to compute the rest of h and c\n   (vector h2o co2 ch4)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32632,"user_id":881,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun burner (c h o)\n  (let* ((water (min (floor h 2) o))\n         (co2 (min (floor (- o water) 2) c))\n         (methane (min (floor (- h (* 2 water)) 4) (- c co2))))\n        (vector water co2 methane)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32633,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun n-for-every (n x one)\n  \"Take n of x for every one of something\"\n  (abs (min one (floor x n))))\n\n(defun burner (c h o)\n  (let* ((water (n-for-every 2 h o))                            ;; 2 of h             for every o\n         (diox  (n-for-every 2 (- o water) c))                  ;; 2 of o             for every c after water\n         (meth  (n-for-every 4 (- h (* 2 water)) (- c diox))))  ;; 4 of h after water for every c after diox\n        (vector water diox meth)))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32634,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun n-for-every (n x one)\n  \"Take n of x for every one of something\"\n  (abs (min one (floor x n))))\n\n(defun burner (c h o)\n  (let* ((water (n-for-every 2 h o))                            ;; take 2 of h for every o\n         (diox  (n-for-every 2 (- o water) c))                  ;; take 2 of o for ever c after water\n         (meth  (n-for-every 4 (- h (* 2 water)) (- c diox))))  ;; take 4 of h after water for ever c after diox\n        (vector water diox meth)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32635,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:burner))\n(in-package #:challenge\/solution)\n\n(defun f (step many one &optional (tot 0))\n  \"step through many for every one of something\"\n  (if (or (= 0 one) (> step many)) \n      tot \n      (f step (- many step) (1- one) (1+ tot))))\n\n(defun burner (c h o)\n  (let* ((water (f 2 h o))                           ;; 2 h for every o\n         (diox  (f 2 (- o water) c))                 ;; 2 o for ever c after water\n         (meth  (f 4 (- h (* 2 water)) (- c diox)))) ;; 4 h for every c after water after diox\n     (vector water diox meth)))\n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"6129095b201d6b000e5a33f0":[{"id":32636,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z) \n  (+ (* x (1+ y) (1+ z))\n     (* (1+ x) y (1+ z))\n     (* (1+ x) (1+ y) z))\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32637,"user_id":163,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z) \n    \"Calculates number of edges in box x y z\"\n    (+ \n      (* 3 x y z)\n      (* 2 x y)\n      (* 2 x z)\n      (* 2 y z)\n      x y z)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32638,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z) \n  (+ (* x (+ y 1) (+ z 1))\n     (* (+ x 1) y (+ z 1))\n     (* (+ x 1) (+ y 1) z))\n  )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32639,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n\n(defun f (x y z) \n  (+ (* 3 x y z)\n     (* 2 x y)\n     (* 2 y z)\n     (* 2 x z)\n     x y z))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32640,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z) \n  (let ((x+1 (1+ x))\n        (y+1 (1+ y))\n        (z+1 (1+ z)))\n    (+ (* x y+1 z+1)\n       (* y z+1 x+1)\n       (* z x+1 y+1))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32641,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z)\n  (+ (* 3 x y z) (* 2 (+ (* x y) (* y z) (* x z))) x y z))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32642,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun count-x (x)\n  (- (* x 12) (sub-x x)))\n\n(defun sub-x (x)\n  (* (- x 1) 4))\n\n(defun count-y (x y)\n  (- (* y (count-x x)) (sub-y x y)))\n\n(defun sub-y (x y)\n  (* (- y 1) (+ (* (+ x 1) 1) (+ x x))))\n\n\n(defun sub-z (x y z)\n  (* (- z 1) (+ (* y (+ x 1)) (* (+ y 1) x))))\n\n(defun f (x y z)\n    (- (* z (count-y x y)) (sub-z x y z)))\n\n;; (defun f (x y z) \n;;     ; your code\n;;     0\n;;   )","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32643,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z) \n  (let* ((naive-lines (* x y z 12))\n         (xy-lines (+ (* (+ x 1) y) (* (+ y 1) x)))\n         (xz-lines (+ (* (+ x 1) z) (* (+ z 1) x)))\n         (yz-lines (+ (* (+ y 1) z) (* (+ z 1) y)))\n         (surface-lines-edges (* 4 (+ x y z)))\n         (surface-lines (- (* 2 (+ xy-lines xz-lines yz-lines)) surface-lines-edges))\n         (surface-lines-not-edges (- surface-lines surface-lines-edges))\n         (naive-surface-lines (+ surface-lines-edges (* 2 surface-lines-not-edges)))\n         (naive-inside-lines (- naive-lines naive-surface-lines))\n         (inside-lines (\/ naive-inside-lines 4))\n         (lines (+ surface-lines inside-lines)))\n    lines))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32644,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n;;; Solution: 3xyz + 2xy + 2yz + 2zx + x + y + z\n(defun f (x y z)\n    (+ (* 3 x y z)\n       (* 2 x y) (* 2 y z) (* 2 z x)\n       x y z))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32645,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:f))\n(in-package #:challenge\/solution)\n\n(defun f (x y z) \n  (cond\n    ((and (zerop x)\n\t  (zerop y)) z)\n    ((and (zerop x)\n\t  (zerop z)) y)\n    ((and (zerop y)\n\t  (zerop z)) x)\n    ((zerop x) (+ (* (1+ y) z)\n\t\t  (* (1+ z) y)))\n    ((zerop y) (+ (* (1+ x) z)\n\t\t  (* (1+ z) x)))\n    ((zerop z) (+ (* (1+ y) x)\n\t\t  (* (1+ x) y)))\n    (t (+ (* (1+ z)\n\t     (f x y 0))\n\t  (* z (1+ x) (1+ y))))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}],"621f89cc94d4e3001bb99ef4":[{"id":32646,"user_id":168,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dont-give-me-five))\n(in-package #:challenge\/solution)\n\n(defun aux (n p r)\n  (if (<= n 0) r\n    (let ((d (mod n 10)) (m (floor n 10)))\n      (if (= d 5) (aux m (* p 9) (+ (* p 4) p -1))\n                  (aux m (* p 9) (+ r (* p (if (> d 5) (- d 1) d))))\n       ))))\n\n(defun no-fives (n) (aux n 1 0))\n\n(defun dont-give-me-five (start end)\n  (cond ((> start 0) (- (no-fives end) (no-fives (- start 1))))\n        ((< end 0)   (- (no-fives (- start)) (no-fives (- -1 end))))\n        (t           (+ (no-fives end) (no-fives (- start)) 1))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32647,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dont-give-me-five))\n(in-package #:challenge\/solution)\n\n(defun leading-digit-factor (x)\n  (when (and (<= 0 x) (< x 10))\n    (cond ((zerop x) 0)\n\t        ((<= x 5) x)\n\t        (t (1- x)))))\n\n(defun digit-5-p (n)\n  (if (= n 5)\n      0\n      1))\n\n(defun number-to-list (n)\n  (map 'list #'digit-char-p (prin1-to-string (abs n))))\n\n(defun lst-has-no-5-p (lst)\n  (if (find 5 lst)\n      0\n      1))\n\n(defun no-range-no-five (lst)\n  (if lst\n      (+ (* (leading-digit-factor (car lst)) (expt 9 (length (cdr lst))))\n\t       (* (digit-5-p (car lst)) (no-range-no-five (cdr lst))))\n      0))\n\n(defun dont-give-me-five (start end)\n  (let ((start-lst (number-to-list start))\n\t      (end-lst (number-to-list end)))\n    (+ (-  (* (signum end) (no-range-no-five end-lst) )\n\t   (* (signum start) (no-range-no-five start-lst)))\n\t     (cond ((<= 0 start end) (lst-has-no-5-p end-lst))\n\t\t         ((<= start 0 end) (1- (+ (lst-has-no-5-p start-lst)\n\t\t\t\t\t                            (lst-has-no-5-p end-lst))))\n\t\t         ((<= start end 0) (lst-has-no-5-p start-lst))\n\t\t         (t 0)))))","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32648,"user_id":null,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dont-give-me-five))\n(in-package #:challenge\/solution)\n\n(defun dont-give-me-five (start end)\n  (let ((start-digits (map 'list (lambda (x) (parse-integer (string x)))\n\t\t\t   (write-to-string (abs start))))\n\t(end-digits (map 'list (lambda (x) (parse-integer (string x)))\n\t\t\t (write-to-string (abs end)))))\n    (cond\n      ((and (> start 0)\n\t    (> end 0))\n       (1+ (- (choices (get-close-normal end-digits 'd))\n\t      (choices (get-close-normal start-digits 'u)))))\n      ((and (< start 0)\n\t    (< end 0))\n       (dont-give-me-five (- end) (- start)))\n      (t (1- (+ (choices (get-close-normal start-digits 'd))\n\t\t(choices (get-close-normal end-digits 'd))))))))\n      \n\n(defun choices (digits)\n  (cond\n    ((and (null (rest digits))\n\t  (>= (car digits) 5)) (car digits))\n    ((and (null (rest digits))\n\t  (< (car digits) 5)) (1+ (car digits)))\n      ((= 5 (car digits)) (* 5 (expt 9 (1- (length digits)))))\n      ((> 5 (car digits)) (+ (* (car digits) (expt 9 (1- (length digits))))\n\t\t\t     (choices (rest digits))))\n      ((< 5 (car digits)) (+ (* (1- (car digits)) (expt 9 (1- (length digits))))\n\t\t\t     (choices (rest digits))))))\n\t     \n(defun get-close-normal (digits f)\n  (cond\n    ((null digits) ())\n    ((and (eq f 'd) (= 5 (car digits))) (cons 4 (loop for x from 1 to (1- (length digits))\n\t\t\t\t      collect 9)))\n    ((and (eq f 'u) (= 5 (car digits))) (cons 6 (loop for x from 1 to (1- (length digits))\n\t\t\t\t\t\t      collect 0)))\n    (t (cons (car digits)\n\t     (get-close-normal (rest digits) f)))))\n\n\n\n      \n      \n\t\t \n\n\t\t \n","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"},{"id":32649,"user_id":163,"body":"(defpackage #:challenge\/solution\n  (:use #:cl)\n  (:export #:dont-give-me-five))\n(in-package #:challenge\/solution)\n\n(defun contained-fives (n &optional (p 1) (fives-below-p 0) (rest-of-n 0) (fives 0))\n  (setq d (mod n 10))\n  (cond\n    ((= n 0) fives)\n    ((< n 0) (contained-fives (- n)))\n    ((< d 5) (contained-fives (floor n 10) (* p 10) (+ (* 9 fives-below-p) p) (+ rest-of-n (* d p)) (+ fives (* d fives-below-p))))\n    ((> d 5) (contained-fives (floor n 10) (* p 10) (+ (* 9 fives-below-p) p) (+ rest-of-n (* d p)) (+ fives (* (1- d) fives-below-p) p)))\n    ((= d 5) (contained-fives (floor n 10) (* p 10) (+ (* 9 fives-below-p) p) (+ rest-of-n (* d p)) (+ rest-of-n (* 5 fives-below-p) 1)))\n    )\n)\n\n(defun dont-give-me-five (start end)\n  (if (>= start 0)\n      (setq fstart (contained-fives (1- start)))\n      (setq fstart (- (contained-fives (- start)))))\n  (if (>= end 0)\n      (setq fend (contained-fives end))\n      (setq fend (- (contained-fives (- -1 end)))))\n  (+ end (- start) 1 (- fend) fstart)\n)","lang_id":8,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2023-01-14 13:23:29","updated_at":"2023-01-14 13:23:29"}]}