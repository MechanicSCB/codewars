{"50654ddff44f800200000004":[{"id":333217,"user_id":676,"body":"object Multiply {\n  def multiply(a: Long, b: Long) = a * b\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333218,"user_id":null,"body":"object Multiply {\n  def multiply(a: Long, b: Long): Long = a * b \n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333219,"user_id":527,"body":"object Multiply {\n  def multiply[T: Numeric](a: T, b: T) = implicitly[Numeric[T]].times(a, b)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333220,"user_id":527,"body":"object Multiply {\n  def multiply: (Int, Int) => Int = _ * _\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333221,"user_id":null,"body":"object Multiply {\n  def multiply(a:Int,b:Int) : Int = {\n    var c : Int = 0\n    c = (a * b)\n    return c;\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333222,"user_id":null,"body":"import scala.annotation.tailrec\nobject Multiply {\n  def multiply(a: Long, b: Long): Long = {\n    @tailrec\n    def _multiply(a: Int, b: Int, acc: Int): Int = {\n      if(b == 0) acc else _multiply(a, b - 1, a + acc)\n    }\n    return _multiply(a, b, 0);\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333223,"user_id":null,"body":"object Multiply {\n  def multiply(a: Long, b: Long): Long = a * b\n  println(multiply(2, 3))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333224,"user_id":null,"body":"object Multiply {\n  def multiply(a: Long, b: Long): Long = a * b\n  println(multiply(1, 2))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333225,"user_id":null,"body":"object Multiply {\n  def multiply(a: Long, b: Long): Long = {\n    var c = a * b\n    return c\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333226,"user_id":null,"body":"object Multiply {\n  def multiply(a: Long, b: Long): Long ={\n    val result = a * b\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"513e08acc600c94f01000001":[{"id":333227,"user_id":573,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int): String =\n    Seq(r, g, b).map(x => f\"${255 min (x max 0)}%02X\").mkString\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333228,"user_id":null,"body":"object Kata {\n  def rgb(r: Int, g: Int, b: Int): String = {\n    Seq(r, g, b).map {\n      case x if x <= 0   => \"00\"\n      case x if x >= 255 => \"FF\"\n      case x if x >= 16 =>\n        x.toHexString.toUpperCase\n      case x =>\n        \"0\" + x.toHexString.toUpperCase\n    }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333229,"user_id":751,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int) = {\n    def rnd(n: Int) = n max 0 min 255\n    \"%02X%02X%02X\" format (rnd(r), rnd(g), rnd(b))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333230,"user_id":573,"body":"object Kata {\n\n  def rgb(xs: Int*) = xs.map(x => f\"${255 min (x max 0)}%02X\").mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333231,"user_id":null,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int): String = \n    List(r,g,b)\n      .map(y => if (y < 0) 0 else if (y > 255) 255 else y)\n      .map(i => i.toHexString.toUpperCase)\n      .map(x => if (x.length < 2) \"0\" + x else x)\n      .mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333232,"user_id":null,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int): String = {\n    def clamp(x: Int): Int =\n      math.max(0, math.min(x, 255))\n    \"%02X%02X%02X\".format(clamp(r), clamp(g), clamp(b))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333233,"user_id":null,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int): String = \n    Seq(r, g, b).map {\n      case x if x >= 0 && x <= 255 => x.toHexString\n      case x => if (x < 0) 0.toHexString else 255.toHexString\n    }.map{\n      case x if x.length == 1 => s\"0$x\"\n      case x => x\n    }.mkString.toUpperCase\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333234,"user_id":null,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int): Any = {\n    val map = scala.collection.mutable.Map[Int, Char]()\n    for (x <- 0 to 16) if (x < 10) map(x) = (x + '0'.toInt).toChar else map(x) = ('A'.toInt + (x - 10)).toChar\n\n    var response = List[String]()\n    List(r, g, b).foreach(x => {\n      if (x > 255) {\n        response = response :+ \"FF\"\n      } else if (x < 0) {\n        response = response :+ \"00\"\n      } else {\n        var dec = x\n        var hex = \"\"\n        while (dec != 0) {\n          hex = map(dec % 16) + hex\n          dec = dec \/ 16\n        }\n        if (hex.size == 0) hex = \"00\" else if (hex.size == 1) hex = \"0\" + hex\n        response = response :+ hex\n      }\n    })\n\n    response.mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333235,"user_id":null,"body":"object Kata {\n  private def int2Hex(n: Int) = {\n    if(n < 0) \"00\"\n    else if(n > 255) \"FF\"\n    else {\n      val convertedString = n.toHexString.toUpperCase\n      convertedString.length match {\n        case 1 => \"0\" + convertedString\n        case _ => convertedString\n      }\n    }\n  }\n\n  def rgb(r: Int, g: Int, b: Int): String = {\n    int2Hex(r) + int2Hex(g) + int2Hex(b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333236,"user_id":null,"body":"object Kata {\n\n  def rgb(r: Int, g: Int, b: Int): String = {\n  var temp: String = \"0\"\n  var rslt0: BigInt = \n  if (BigInt(r) < 0) \n  {BigInt(0)} \n  else {\n    if (BigInt(r) > 255) \n      {BigInt(255)* 65536} \n    else {BigInt(r)* 65536}} \n  \n  var rslt1: BigInt = \n  if (BigInt(g) < 0) \n  {BigInt(0)} \n  else {\n    if (BigInt(g) > 255) \n      {BigInt(255)* 256} \n    else {BigInt(g)* 256}}\n  \n  var rslt2: BigInt = \n  if (BigInt(b) < 0) \n  {BigInt(0)} \n  else {\n    if (BigInt(b) > 255) \n      {BigInt(255)* 1} \n    else {BigInt(b)* 1}} \n  \n  var rslt: String = (rslt0 + rslt1 + rslt2).toString(16)\n  while (rslt.length() < \"000000\".length()) { \n  temp += rslt\n  rslt = temp\n  temp = \"0\"\n  }\n  rslt.toUpperCase()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"514b92a657cdc65150000006":[{"id":333237,"user_id":527,"body":"object MultiplesOf3Or5 {   \n  def solution(number: Int): Long =\n    (1 until number).view.filter(x => x % 3 == 0 || x % 5 == 0).foldLeft(0L)(_ + _)\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333238,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long = (1L until number).filter(x => x % 3 == 0 || x % 5 == 0).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333239,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long = {\n        def sumOf(k: Long): Long = {\n            val n = (number - 1) \/ k\n            k * n * (n + 1) \/ 2\n        }\n        \n        sumOf(3) + sumOf(5) - sumOf(15)\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333240,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long = Array.range(1,number).map(_.toLong).filter(x=>x%3==0||x%5==0).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333241,"user_id":573,"body":"object MultiplesOf3Or5 {\n\n  def solution(number: Int): Long =\n    (3L until number)\n      .filter(d => d % 3 == 0 || d % 5 == 0)\n      .sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333242,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long = \n      (1L until number).filter(n => n % 5 == 0 || n % 3 == 0 ).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333243,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long = (1l until number).filter(n => (n % 3) == 0 || (n % 5) == 0).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333244,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long = \n      ((3L until number) filter (x => x % 3 == 0 || x % 5 == 0)).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333245,"user_id":null,"body":"object MultiplesOf3Or5 {   \n    def solution(number: Int): Long =\n      Stream.from(3)\n            .map(_.toLong)\n            .takeWhile(_ < number)\n            .filter(n => n % 5 ==0 || n % 3 == 0)\n            .sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333246,"user_id":527,"body":"import scala.annotation.tailrec\n\nobject MultiplesOf3Or5 {   \n  def solution(number: Int): Long = {\n    @tailrec\n    def sumFrom(i: Int, sum: Long = 0): Long =\n      if (i >= number) sum\n      else if (i % 3 == 0 || i % 5 == 0) sumFrom(i + 1, sum + i)\n      else sumFrom(i + 1, sum)\n    sumFrom(1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"515de9ae9dcfc28eb6000001":[{"id":333247,"user_id":null,"body":"object Kata {\n\n  def solution(s: String): List[String] = {\n    s.grouped(2).map(_.padTo(2, '_')).toList\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333248,"user_id":573,"body":"object Kata {\n\n  def solution(s: String): List[String] =\n    s.padTo(s.size + s.size%2, '_').grouped(2).toList\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333249,"user_id":null,"body":"object Kata {\n  def solution(s: String): List[String] = s.length match {\n    case 0 => List()\n    case 1 => List(s ++ \"_\")\n    case _ => List(s.take(2)) ++ solution(s.drop(2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333250,"user_id":573,"body":"object Kata {\n\n  def solution(s: String): List[String] =\n    (s + \"_\" * (s.size%2)).grouped(2).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333251,"user_id":null,"body":"object Kata {\n  def solution(s: String): List[String] = {\n    val newStr = if (s.length % 2 != 0) s + \"_\" else s\n    \n    newStr.grouped(2).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333252,"user_id":null,"body":"object Kata {\n\n  def solution(s: String): List[String] = {\n    if(s.length % 2 == 0) s.grouped(2).toList else s.concat(\"_\").grouped(2).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333253,"user_id":573,"body":"object Kata {\n\n  def solution(s: String): List[String] =\n    s.grouped(2).toList.map(_.padTo(2, '_'))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333254,"user_id":null,"body":"object Kata {\n  def solution(x: String): List[String] = \n    if (x.length == 0) List()\n    else helper(x, List.empty)\n\n  def helper(x: String, l: List[String]): List[String] =\n      if (x.length == 2) List.concat(l, List(x))\n      else if (x.length == 1) List.concat(l, List(x:+'_'))\n      else helper(x.substring(2, x.length), l:+x.take(2))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333255,"user_id":null,"body":"object Kata {\n\n  def solution(s: String): List[String] = {\n    if(s.isEmpty) Nil\n    else if(s.size == 1) List(s  +'_') \n    else s.take(2) :: solution(s.drop(2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333256,"user_id":null,"body":"object Kata {\n\n  def solution(str: String): List[String] = {\n      var string: String = str\n      if(string.length % 2 != 0) string += \"_\"\n      string.zip(string.drop(1)).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).map(x => s\"${x._1}${x._2}\" ).toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"515e188a311df01cba000003":[{"id":333257,"user_id":null,"body":"object GetPlanetName {\n\n  def get_planet_name(i: Int): String = {\n    i match {\n      case 1 => \"Mercury\"\n      case 2 => \"Venus\"\n      case 3 => \"Earth\"\n      case 4 => \"Mars\"\n      case 5 => \"Jupiter\"\n      case 6 => \"Saturn\"\n      case 7 => \"Uranus\"\n      case 8 => \"Neptune\"\n      case _ => throw new IllegalArgumentException()\n    }\n  }\n  \n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333258,"user_id":573,"body":"object GetPlanetName {\n\n  val get_planet_name = Map(\n    1 -> \"Mercury\",\n    2 -> \"Venus\",\n    3 -> \"Earth\",\n    4 -> \"Mars\",\n    5 -> \"Jupiter\",\n    6 -> \"Saturn\",\n    7 -> \"Uranus\",\n    8 -> \"Neptune\"\n  )\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333259,"user_id":573,"body":"object GetPlanetName {\n\n  val get_planet_name = List(\"\", \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333260,"user_id":null,"body":"\/\/The function is not returning the correct values. Can you figure out why?\n\n\/\/GetPlanetName.get_planet_name(3); \/\/should return \"Earth\"\nobject GetPlanetName{\ndef get_planet_name(i:Int):String={\ni match {\ncase 1=>\"Mercury\"\ncase 2=>\"Venus\"\ncase 3=>\"Earth\"\ncase 4=>\"Mars\"\ncase 5=>\"Jupiter\"\ncase 6=>\"Saturn\"\ncase 7=>\"Uranus\"\ncase 8=>\"Neptune\"\ncase 9=>\"Pluto\"}\n\n\n}\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333261,"user_id":null,"body":"\ncase class Planet(id:Int,name:String)\nobject  GetPlanetName{\n    def get_planet_name(id:Int)={\n      val planets = Seq(Planet(1,\"Mercury\"),Planet(2,\"Venus\"),Planet(3,\"Earth\"),Planet(4,\"Mars\"),Planet(5,\"Jupiter\"),Planet(6,\"Saturn\"),Planet(7,\"Uranus\"),Planet(8,\"Neptune\"),Planet(9,\"Pluto\"))\n\n      planets.find{planet=>planet.id==id} match {\n        case Some(planet) => planet.name\n        case None => Nil\n      }\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333262,"user_id":null,"body":"object GetPlanetName {\n  def get_planet_name(n: Int): String = {\n    n match {\n      case 1 => \"Mercury\"\n      case 2 => \"Venus\"\n      case 3 => \"Earth\"\n      case 4 => \"Mars\"\n      case 5 => \"Jupiter\"\n      case 6 => \"Saturn\"\n      case 7 => \"Uranus\"\n      case 8 => \"Neptune\"\n      case _ => throw new IllegalArgumentException()\n    }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333263,"user_id":null,"body":"object GetPlanetName {\n  def get_planet_name(name: Int): String = name match {\n    case 1 => \"Mercury\"\n    case 2 => \"Venus\"\n    case 3 => \"Earth\"\n    case 4 => \"Mars\"\n    case 5 => \"Jupiter\"\n    case 6 => \"Saturn\"\n    case 7 => \"Uranus\"    \n    case 8 => \"Neptune\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333264,"user_id":null,"body":"\/\/The function is not returning the correct values. Can you figure out why?\nobject GetPlanetName{\n  def get_planet_name(s:Int): String = {\n    s match {\n      case 1 => \"Mercury\"\n      case 2 => \"Venus\"\n      case 3 => \"Earth\"\n      case 4 => \"Mars\"\n      case 5 => \"Jupiter\"\n      case 6 => \"Saturn\"\n      case 7 => \"Uranus\"\n      case 8 => \"Neptune\"\n      case _ => \"The Sun\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333265,"user_id":null,"body":"object GetPlanetName {\n  def get_planet_name(n: Int) : String = {\n    n match {\n      case 1 => \"Mercury\"\n      case 2 => \"Venus\"\n      case 3 => \"Earth\"\n      case 4 => \"Mars\"\n      case 5 => \"Jupiter\"\n      case 6 => \"Saturn\"\n      case 7 => \"Uranus\"\n      case 8 => \"Neptune\"\n      case _ => \"\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333266,"user_id":null,"body":"object GetPlanetName {\n  def get_planet_name(planetNum: Int): String = {\n    planetNum match {\n      case 1 => \"Mercury\"\n      case 2 => \"Venus\"\n      case 3 => \"Earth\"\n      case 4 => \"Mars\"\n      case 5 => \"Jupiter\"\n      case 6 => \"Saturn\"\n      case 7 => \"Uranus\"\n      case 8 => \"Neptune\"\n      case _ => \"Not a planet\"\n    } \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"515e271a311df0350d00000f":[{"id":333267,"user_id":573,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int =\n    xs.map(x => x*x).sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333268,"user_id":null,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = xs.fold(0)((a,b) => a+b*b)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333269,"user_id":null,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = {\n    var sum = 0;\n  \n    for (i <- xs)\n      sum = sum + i * i;\n    \n    return sum;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333270,"user_id":null,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = xs match {\n    case Nil => 0\n    case _ => xs map (x => x * x) reduce (_ + _)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333271,"user_id":53,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = {\n    return xs.foldLeft(0) { (acc, n) => acc + n * n }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333272,"user_id":null,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = xs.map(scala.math.pow(_, 2).toInt).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333273,"user_id":null,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = {\n    xs.foldLeft(0)((sum, x) => sum + x*x)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333274,"user_id":null,"body":"object Kata {\n\n  def square_sum(xs: Seq[Int]): Int = {\n    xs.foldLeft(0)((p,n) => p + (n * n))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333275,"user_id":null,"body":"object Kata {\n  def square_sum(xs: Seq[Int]): Int = xs.fold(0)((a,i) => a+(i*i))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333276,"user_id":null,"body":"import scala.math.pow\nobject Kata {\n  def square_sum(xs: Seq[Int]): Int =  if(xs.length > 0) xs.map(x => x * x).reduce((x,y) => x + y) else 0;\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"515f51d438015969f7000013":[{"id":333277,"user_id":573,"body":"object Kata {\n\n  def pyramid(n: Int): List[List[Int]] =\n    List.tabulate(n)(i => List.fill(i+1)(1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333278,"user_id":575,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = {\n    (1 to n).map(List.fill(_)(1)).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333279,"user_id":751,"body":"object Kata {\n  def pyramid(n: Int) = (1 to n).map(List.fill(_)(1)).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333280,"user_id":null,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = {\n    n match {\n      case 0 => List()\n      case _ => pyramid(n - 1) ::: List(List.fill(n)(1))\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333281,"user_id":null,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = {\n    List.tabulate(n)(el => List.tabulate(el+1)(_=>1))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333282,"user_id":null,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = n match {\n    case 0 => Nil\n    case _ => (1 to n).map(List.fill(_)(1)).toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333283,"user_id":null,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = {\n    (1 to n).toList.map(x => List.fill(x)(1))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333284,"user_id":527,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] =\n    List.fill(n)(1).tails.toList.reverse.tail\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333285,"user_id":null,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = {\n    (0 to n).foldLeft(List[List[Int]]())((list , q) => if (q == 0) list else List.fill(q)(1) :: list).reverse\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333286,"user_id":null,"body":"object Kata {\n  def pyramid(n: Int): List[List[Int]] = {\n    val result = for (i <- 1 to n) yield List.fill(i)(1)\n    result.toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5168bb5dfe9a00b126000018":[{"id":333287,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n    word.reverse  \n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333288,"user_id":null,"body":"object Kata {\n  def solution: (String) => String = _.reverse\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333289,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n    word.foldRight(\"\")((c, s) => s + c)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333290,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n     word.foldLeft(\"\")((accumulator, nextChar) => nextChar + accumulator)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333291,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n    var a= word.length()-1\n     var res=\"\"\n      while( a >= 0 ){\n         res+= word(a)\n         a = a - 1;\n      }\n     res\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333292,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n     word.toArray.reverse.mkString(\"\");\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333293,"user_id":null,"body":"object Kata {\n\n  implicit class Revy(val sc: StringContext) extends AnyVal {\n    def revy(args: Any*): String = {\n      args.mkString.reverse\n\n    }\n  }\n\n  def solution(word: String): String = {\n    revy\"$word\"\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333294,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n  return (\"\" \/: word)(_.+:(_))\n     \n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333295,"user_id":null,"body":"object Kata:\n  def solution(word: String): String =\n    word.reverse","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333296,"user_id":null,"body":"object Kata {\n\n  def solution(word: String): String = {\n    \n    (word.length-1 to 0 by -1).map( num => word.charAt(num)).mkString\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"517abf86da9663f1d2000003":[{"id":333297,"user_id":null,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String = str.split(\"[_-]\").reduce((a, b) => a + b.capitalize)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333298,"user_id":null,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String = {\n    val splitted = str.split(\"-|_\")  \n    (splitted.head ++ splitted.tail.map(word => word.capitalize)).mkString(\"\") \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333299,"user_id":527,"body":"object CamelCase {\n  val to_camel_case = \"[_-](.)\".r.replaceAllIn(_: String, _.group(1).toUpperCase)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333300,"user_id":573,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String =\n    s\"\"\"${str.take(1)}${str.split(\"[-_]\").map(_.capitalize).mkString.drop(1)}\"\"\" \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333301,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject CamelCase {\n\n  def to_camel_case(s: String): String =\n    to_camel_case(s.toList, Nil).reverse.mkString\n\n  @tailrec\n  def to_camel_case(input: List[Char], output: List[Char]): List[Char] = {\n    input match {\n      case Nil                    => output\n      case ('_' | '-') :: Nil     => output\n      case ('_' | '-') :: s :: xs => to_camel_case(xs, s.toUpper :: output)\n      case s :: xs                => to_camel_case(xs, s :: output)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333302,"user_id":null,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String = {\n    val entries = str.split(\"[-_]\")\n    if (entries.isEmpty) \n      \"\"\n    else \n      entries.head + entries.tail.map(_.capitalize).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333303,"user_id":null,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String = {\n   val new_str = str.split(\"[_-]\")\n   val head = new_str.head\n   val tail = new_str.drop(1).map(a =>   a.capitalize).mkString(\"\")\n   head + tail\n  }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333304,"user_id":null,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String = str.split(\"_|-\").reduce((a,b) => a.concat(b.capitalize))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333305,"user_id":573,"body":"object CamelCase {\n\n  def to_camel_case(str: String): String =\n    str.split(\"[-_]\").toList match { case head :: tail => s\"$head${tail.map(_.capitalize).mkString}\" }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333306,"user_id":null,"body":"object CamelCase {\n\n      def to_camel_case(str: String): String = {\n        val delimiter = \"\"\"[_|-]\"\"\";\n        str.split(delimiter).reduce((a,b) => a + b.capitalize)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"51b6249c4612257ac0000005":[{"id":333307,"user_id":573,"body":"object Roman {\n\n  def solution(roman: String): Int =\n    Map(\"M\" -> 1000, \"CM\" -> -200, \"D\" -> 500, \"CD\" -> -200, \"C\" -> 100, \"XC\" -> -20, \"L\" -> 50, \"XL\" -> -20, \"X\" -> 10, \"IX\" -> -2, \"V\" -> 5, \"IV\" -> -2, \"I\" -> 1)\n      .map { case (s, d) => s.r.findAllMatchIn(roman).size * d }\n      .sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333308,"user_id":null,"body":"object Roman {\n  val SYMBOL_TO_VALUE_MAP = Map('I' -> 1, 'V' -> 5, 'X' -> 10, 'L' -> 50, 'C' -> 100, 'D' -> 500, 'M' -> 1000)\n\n  case class Acc(last: Int, overall: Int)\n\n  def solution(roman: String): Int = {\n    roman\n      .toArray\n      .map(SYMBOL_TO_VALUE_MAP(_))\n      .foldRight(Acc(0,0))((curr, acc) => if (curr < acc.last) Acc(curr, acc.overall - curr) else Acc(curr, acc.overall + curr))\n      .overall\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333309,"user_id":573,"body":"object Roman {\n\n  def solution(roman: String): Int =\n    Map(\"M\" -> 1000, \"CM\" -> -200, \"D\" -> 500, \"CD\" -> -200, \"C\" -> 100, \"XC\" -> -20, \"L\" -> 50, \"XL\" -> -20, \"X\" -> 10, \"IX\" -> -2, \"V\" -> 5, \"IV\" -> -2, \"I\" -> 1)\n      .map { case (s, v) => roman.sliding(s.size).count(_ == s) * v }\n      .sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333310,"user_id":null,"body":"object Roman {\n\n  val symbolDecoder = Map('I' -> 1, 'V' -> 5, 'X' -> 10, 'L' -> 50, 'C' -> 100, 'D' -> 500, 'M' -> 1_000)\n\n  def solution(roman: String): Int = {\n    \n    @scala.annotation.tailrec\n    def f(numbers: List[Int])(total: Int = 0): Int = numbers match {\n      case x1 :: x2 :: xs if x1 < x2 => f(xs)(total + x2 - x1)\n      case x :: xs => f(xs)(total + x)\n      case Nil => total\n    }\n    \n    f(roman.map(symbolDecoder).toList)()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333311,"user_id":null,"body":"object Roman {\n val romanNumbers = Map(\n    \"I\"-> 1,\n    \"V\" -> 5,\n    \"X\" -> 10,\n    \"L\" -> 50,\n    \"C\" -> 100,\n    \"D\" -> 500,\n    \"M\" -> 1000)\n\n  def digit(number:Int):Int = {\n    var n = 1\n    var buffer = number\n    while(buffer >= 10) {\n      buffer \/= 10\n      n+=1\n    }\n    n\n  }\n\n\n  def solution(roman: String): Int = {\n    var buffer: Seq[Int] = Seq.empty\n    var previousNumber : Option[Int] = None\n    roman.split(\"\").foreach(romanNb => {\n      val decimalNb = romanNumbers.getOrElse(romanNb, 0)\n      val nextValue = previousNumber.fold(decimalNb) {\n        case previousNb if previousNb < decimalNb => decimalNb - 2 * previousNb\n        case _ => decimalNb\n      }\n      buffer = buffer :+ nextValue\n      previousNumber = Some(decimalNb)\n    })\n\n    buffer.sum\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333312,"user_id":573,"body":"object Roman {\n\n  def solution(roman: String): Int =\n    List((\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400), (\"C\", 100), (\"XC\", 90), (\"L\", 50), (\"XL\", 40), (\"X\", 10), (\"IX\", 9), (\"V\", 5), (\"IV\", 4), (\"I\", 1))\n      .collectFirst { case (s, v) if roman.startsWith(s) => v + decode(roman.drop(s.size)) }\n      .getOrElse(0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333313,"user_id":null,"body":"object Roman {\n\n   def asDigit(c: Char): Int = c match {\n      case 'I' => 1\n      case 'V' => 5\n      case 'X' => 10\n      case 'L' => 50\n      case 'C' => 100\n      case 'D' => 500\n      case 'M' => 1000\n      case _ => throw new RuntimeException(\"unknown character\")\n    }\n\n    def solution(roman: String): Int = {\n      roman.foldRight((0, 0)) {\n        case (nextChar, (lastDigit, result)) =>\n          val nextDigit = Roman.asDigit(nextChar)\n          if (nextDigit >= lastDigit)\n            (nextDigit, result + nextDigit)\n          else\n            (nextDigit, result - nextDigit)\n      }._2\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333314,"user_id":null,"body":"object Roman {\n\n  def solution(roman: String): Int = {\n    def go(s: String): Int = {\n      s match {\n        case s if s.startsWith(\"L\") => 50 + go(s.drop(1))\n        case s if s.startsWith(\"XL\") => 40 + go(s.drop(2))\n        case s if s.startsWith(\"CM\") => 900 + go(s.drop(2))\n        case s if s.startsWith(\"CD\") => 400 + go(s.drop(2))\n        case s if s.startsWith(\"XC\") => 90 + go(s.drop(2))\n        case s if s.startsWith(\"C\") => 100 + go(s.drop(1))\n        case s if s.startsWith(\"D\") => 500 + go(s.drop(1))\n        case s if s.startsWith(\"M\") => 1000 + go(s.drop(1))\n        case s if s.startsWith(\"X\") => 10 + go(s.drop(1))\n        case s if s.startsWith(\"IX\") => 9 + go(s.drop(2))\n        case s if s.startsWith(\"V\") => 5 + go(s.drop(1))\n        case s if s.startsWith(\"IV\") => 4 + go(s.drop(2))\n        case s if s.startsWith(\"I\") => 1 + go(s.drop(1))\n        case _ => 0\n      }\n    }\n    go(roman)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333315,"user_id":null,"body":"object Roman {\n  import scala.annotation.tailrec\n  \n  def solution(roman: String): Int = {\n    def decodeV(romanVal: Char): Int = romanVal match {\n      case 'I' => 1\n      case 'V' => 5\n      case 'X' => 10\n      case 'L' => 50\n      case 'C' => 100\n      case 'D' => 500\n      case 'M' => 1000\n    }\n\n    @tailrec\n    def countRes(listV: List[Int], currentVal: Int): Int =\n      listV.length match {\n        case 1 => currentVal + listV.head\n        case 0 => currentVal\n        case _ => if (listV.head < listV(1)) {\n          countRes(listV.drop(2), currentVal + (listV(1) - listV.head))\n        } else countRes(listV.drop(1), currentVal + listV.head)\n      }\n\n    countRes(roman.toList.map(decodeV), 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333316,"user_id":null,"body":"object Roman {\n\n  def solution(roman: String): Int = {\n    val list = roman.split(\"\").toList\n    result(list, 0, 0)\n    \n  }\n  def result(list: List[String],lastSeen: Int, accumulator: Int): Int = {\n    list match {\n      case Nil => accumulator\n      case h :: tail => {\n        h match {\n          case \"I\" => result(tail, 1, accumulator + 1)\n          case \"V\" => if (lastSeen >= 5) result(tail, 5, accumulator + 5) \n                      else result(tail, 5, accumulator - lastSeen + (5-lastSeen))\n          case \"X\" => if (lastSeen >= 10) result(tail, 10, accumulator + 10)\n                      else result(tail, 10, accumulator -lastSeen + (10 - lastSeen))\n          case \"L\" => if (lastSeen >= 50) result(tail, 50, accumulator + 50)\n                      else result(tail, 50, accumulator - lastSeen + (50 - lastSeen))\n          case \"C\" => if (lastSeen >= 100) result(tail, 100, accumulator + 100)\n                      else result(tail, 100, accumulator -lastSeen + (100 - lastSeen))\n          case \"D\" => if (lastSeen >= 500) result(tail, 500, accumulator + 500)\n                      else result(tail, 500, accumulator - lastSeen + (500 - lastSeen))\n          case \"M\" => if (lastSeen >= 1000) result(tail, 1000, accumulator + 1000)\n                      else result(tail, 1000, accumulator - lastSeen + (1000 - lastSeen))\n        }\n      }\n    }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"51b62bf6a9c58071c600001b":[{"id":333317,"user_id":573,"body":"object Roman {\n\n  def encode(arabic: Int): String =\n    List((\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400), (\"C\", 100), (\"XC\", 90), (\"L\", 50), (\"XL\", 40), (\"X\", 10), (\"IX\", 9), (\"V\", 5), (\"IV\", 4), (\"I\", 1))\n      .collectFirst { case (s, v) if v <= arabic => s\"$s${encode(arabic-v)}\" }\n      .getOrElse(\"\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333318,"user_id":null,"body":"import scala.collection.mutable.LinkedHashMap\n\nobject Roman {\n\n  def encode(arabic: Int): String = {\n    var code : String = \"\"\n    var remainder : Int = arabic\n    \n    val romanMapping = LinkedHashMap(\n      1000 -> \"M\",\n      900 -> \"CM\",\n      500 -> \"D\",\n      400 -> \"CD\",\n      100 -> \"C\",\n      90 -> \"XC\",\n      50 -> \"L\",\n      40 -> \"XL\",\n      10 -> \"X\",\n      9 -> \"IX\",\n      5 -> \"V\",\n      4 -> \"IV\",\n      1 -> \"I\"\n    )\n    \n    for ((key, value) <- romanMapping) {\n      while (remainder >= key) {\n        remainder -= key\n        code += value\n      }\n    }\n    \n    return code\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333319,"user_id":null,"body":"object Roman {\n\n  def encode(arabic: Int): String = {\n    def charsString(count: Int, c: Char) = (1 to count).map(_ => c).mkString(\"\")\n  \n    def fixRomans(raw: String, base: Char, medium: Char, full: Char) = {\n      raw.length match {\n        case r if r <= 3 => raw\n        case 4 => s\"$base$medium\"\n        case 5|6|7|8 => s\"$medium${charsString(raw.length - 5, base)}\"\n        case 9 => s\"$base$full\"\n      }\n    }\n  \n    val digitString = arabic.toString.map(_.asDigit)\n  \n    val units = digitString.takeRight(1)\n    val tens = digitString.dropRight(1).takeRight(1)\n    val hundreds = digitString.dropRight(2).takeRight(1)\n    val thousands = digitString.dropRight(3)\n  \n  \n    \/\/Fill all with base roman numbers(I,X,C,M => 1, 10, 100, 1000)\n    val unitsRomanRaw = units.flatMap(u => charsString(u, 'I')).mkString(\"\")\n    val tensRomanRaw = tens.flatMap(u => charsString(u, 'X')).mkString(\"\")\n    val hundredsRomanRaw = hundreds.flatMap(u => charsString(u, 'C')).mkString(\"\")\n    val thousandsRoman = thousands.flatMap(u => charsString(u, 'M')).mkString(\"\")\n  \n    \/\/Fix the repeated characters > 3\n    val unitsRoman = fixRomans(unitsRomanRaw, 'I', 'V', 'X')\n    val tensRoman = fixRomans(tensRomanRaw, 'X', 'L', 'C')\n    val hundredsRoman = fixRomans(hundredsRomanRaw, 'C', 'D', 'M')\n  \n    s\"$thousandsRoman$hundredsRoman$tensRoman$unitsRoman\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333320,"user_id":null,"body":"object Roman {\n\n  def encode(arabic: Int): String = {\n  \/**\n     * a\u4e3a\u5bf9\u5e94\u76841*\u5b57\u6bcd,b\u4e3a\u5bf9\u5e94\u76845*\u5b57\u6bcd,c\u4e3a\u524d\u4e00\u4f4d\u76841*\u5b57\u6bcd\n     *\n     * @param d\n     * @return\n     *\/\n    def transform(d: Int): String = {\n      if (d == 0) {\n        \"\"\n      } else if (d <= 3) {\n        (0 until d).map(_ =>\"a\").mkString(\"\")\n      } else if (d == 4) {\n        \"ab\"\n      } else if (d == 5) {\n        \"b\"\n      } else if (d <= 8) {\n        val t = (0 until (d - 5)).map(_ =>\"a\").mkString(\"\")\n        s\"b$t\"\n      } else {\n        \"ac\"\n      }\n    }\n\n    assert(arabic > 0)\n    val thousand = arabic \/ 1000\n    val hundred = (arabic - thousand * 1000) \/ 100\n    val decade = (arabic - thousand * 1000 - hundred * 100) \/ 10\n    val singles = arabic - thousand * 1000 - hundred * 100 - decade * 10\n    val thousandRoman = (0 until thousand).map(_ =>\"M\").mkString(\"\")\n\n    val hundredRoman = transform(hundred).replace(\"a\", \"C\").replace(\"b\", \"D\").replace(\"c\", \"M\")\n    val decadeRoman = transform(decade).replace(\"a\", \"X\").replace(\"b\", \"L\").replace(\"c\", \"C\")\n    val singlesRoman = transform(singles).replace(\"a\", \"I\").replace(\"b\", \"V\").replace(\"c\", \"X\")\n    s\"$thousandRoman$hundredRoman$decadeRoman$singlesRoman\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333321,"user_id":null,"body":"object Roman {\n  \n  \/\/ Extended notation to encode everything up to Int.MaxValue\n  val numerals = Vector(\n    (\"I\", \"V\"),    \/\/ 1 ; 5\n    (\"X\", \"L\"),    \/\/ 10 ; 50\n    (\"C\", \"D\"),    \/\/ 100 ; 500\n    (\"M\", \"V.\"),   \/\/ 1,000 ; 5,000\n    (\"X.\", \"L.\"),  \/\/ 10,000 ; 50,000\n    (\"C.\", \"D.\"),  \/\/ 100,000 ; 500,000\n    (\"M.\", \"V..\"), \/\/ 1,000,000 ; 5,000,000\n    (\"X..\", \"L..\"),\/\/ 10,000,000 ; 50,000,000\n    (\"C..\", \"D..\"),\/\/ 100,000,000 ; 500,000,000\n    (\"M..\", \"\")    \/\/ 1,000,000,000\n  )\n  def `1-ishNumeral`(decimalPower: Int) = numerals(decimalPower)._1\n  def `5-ishNumeral`(decimalPower: Int) = numerals(decimalPower)._2\n  \n  def encode(decimalNumber: Int): String = {\n    require(decimalNumber.sign == 1, \"Encoding supports only naturals.\") ; import Decimal._\n    \n    decimalNumber.digits.map { case Digit(value, index) =>\n      value match {\n        \/\/ additivePattern, e.g. \"III\" (3) [{'I'} * 3], or \"LXX\" (70) [{'L'} + ({'X'} * 2)]:\n        case `0` | `1` | `2` | `3` => `1-ishNumeral`(index) * value\n        case `5` | `6` | `7` | `8` => `5-ishNumeral`(index) + (`1-ishNumeral`(index) * (value - 5))\n        \/\/ subtractivePattern, e.g. \"IV\" (4) [- {'I'} + {'V'}], or \"CM\" (900) [- {'C'} + {'M'}]:\n        case `4` => `1-ishNumeral`(index) + `5-ishNumeral`(index)\n        case `9` => `1-ishNumeral`(index) + `1-ishNumeral`(index + 1)\n    }}.mkString\n  }\n  \n}\n\nobject Decimal {\n  \n  sealed abstract class Numeral(val value: Int)\n  \/\/ Let's have exhaustivity checks on numerals\n  final case object `0` extends Numeral(0)\n  final case object `1` extends Numeral(1)\n  final case object `2` extends Numeral(2)\n  final case object `3` extends Numeral(3)\n  final case object `4` extends Numeral(4)\n  final case object `5` extends Numeral(5)\n  final case object `6` extends Numeral(6)\n  final case object `7` extends Numeral(7)\n  final case object `8` extends Numeral(8)\n  final case object `9` extends Numeral(9)\n  \n  val numerals = List(`0`,`1`,`2`,`3`,`4`,`5`,`6`,`7`,`8`,`9`)\n  \n  import scala.language.implicitConversions\n  implicit def valueOf($: Numeral): Int = $.value\n  \n  final case class Digit(value: Numeral, index: Int)\n  \/\/ index is Int for convenience; even 4-bit would do!\n  \n  implicit class IntExtension(self: Int) { def digits =\n    self.toString.reverse.zipWithIndex.map { case (symbol, index) =>\n      Digit(numerals.filter(_.value == symbol.asDigit).head, index)\n    }.reverse\n  }\n  \n} \/\/ Should come from a lib, really! A lot of boilerplate for a small \u2013 yet nice \u2013 gain\u2026","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333322,"user_id":null,"body":"object Roman {\n\n  def encode(x: Int): String = {\n\n    def getM(x: Int): (String, Int) = {\n      val rs = \"M\" * (x \/ 1000)\n      (rs, x % 1000)\n    }\n\n    def getDC(init: String, x: Int): (String, Int) = {\n      val r = x \/ 100\n      val rt = r match {\n        case 9 => \"CM\"\n        case x if x > 4 => \"D\" + \"C\" * (r - 5)\n        case 4 => \"CD\"\n        case y => \"C\" * y\n      }\n      (init + rt, x % 100)\n    }\n\n    def getLX(init: String, x: Int): (String, Int) = {\n      val r = x \/ 10\n      val rt = r match {\n        case 9 => \"XC\"\n        case x if x > 4 => \"L\" + \"X\" * (r - 5)\n        case 4 => \"XL\"\n        case y => \"X\" * y\n      }\n      (init + rt, x % 10)\n    }\n\n    def getVI(init: String, x: Int): String = {\n      val rt = x match {\n        case 9 => \"IX\"\n        case x if x > 4 => \"V\" + \"I\" * (x - 5)\n        case 4 => \"IV\"\n        case y => \"I\" * y\n      }\n      init + rt\n    }\n\n    val (init1, x1) = getM(x)\n    val (init2, x2) = getDC(init1, x1)\n    val (init3, x3) = getLX(init2, x2)\n    getVI(init3, x3)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333323,"user_id":null,"body":"object Roman {\n  \n  val rules = Map(\n    1 -> \"I\",\n    5 -> \"V\",\n    10 -> \"X\",\n    50 -> \"L\",\n    100 -> \"C\",\n    500 -> \"D\",\n    1000 -> \"M\"\n  )\n  println(encode(6))\n\n\n  def encode(arabic: Int): String = {\n    def helper(number: Int, powerOfTen: Int, result: String): String = {\n      if(number == 0) {\n        return result\n      }\n\n      val lastDigit: Int = number % 10\n      lastDigit match {\n        case 0 => helper(number \/ 10, powerOfTen + 1, result)\n        case 4 => helper(number \/ 10, powerOfTen + 1, rules(math.pow(10,powerOfTen).toInt) ++\n          rules( 5 * math.pow(10,powerOfTen).toInt) ++ result)\n        case 9 => helper(number \/ 10, powerOfTen + 1, rules(math.pow(10,powerOfTen).toInt) ++\n          rules( 10 * math.pow(10,powerOfTen).toInt) ++ result)\n        case num => if (num < 4)\n          helper(number \/ 10, powerOfTen + 1, rules(math.pow(10,powerOfTen).toInt)*num ++ result)\n        else\n          helper(number \/ 10, powerOfTen + 1, rules(5 * math.pow(10,powerOfTen).toInt) ++ rules(math.pow(10,powerOfTen).toInt)*(num - 5) ++ result)\n      }\n    }\n\n    helper(arabic, 0, \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333324,"user_id":null,"body":"object Roman {\n\n  val arabicToRomanNumerals: List[(Int, String)] = List(\n    (1000, \"M\"),\n    (900, \"CM\"),\n    (500, \"D\"),\n    (400, \"CD\"),\n    (100, \"C\"),\n    (90, \"XC\"),\n    (50, \"L\"),\n    (40, \"XL\"),\n    (10, \"X\"),\n    (9, \"IX\"),\n    (6, \"VI\"),\n    (5, \"V\"),\n    (4, \"IV\"),\n    (1, \"I\")\n  )\n\n  def encode(arabic: Int): String = toRomanNumerals(arabic, arabicToRomanNumerals)\n\n  private def toRomanNumerals(number: Int, digits: List[(Int, String)]): String = digits match {\n    case Nil => \"\"\n    case head :: tail => head._2 * (number \/ head._1) + toRomanNumerals(number % head._1, tail)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333325,"user_id":null,"body":"import scala.collection.mutable.HashMap\nimport scala.math.{pow, log10}\n\nobject Roman {\n  def numOfDigs(num: Int) = log10(num).asInstanceOf[Int] + 1\n  def nthDig(num: Int, n: Int): Int = num \/ pow(10, n).asInstanceOf[Int] % 10\n  def lastDig(num: Int) = nthDig(num, numOfDigs(num) - 1)\n  def popLastDig(num: Int): Int = num % (lastDig(num) * pow(10, numOfDigs(num) - 1).asInstanceOf[Int])\n\n  \/\/ easy to add new digits (_V = 5000, _X = 10000 etc.)\n  val symbols = Array('I', 'V', 'X', 'L', 'C', 'D', 'M')\n  \n  def romanOne(pwr: Int): String = symbols.apply(pwr * 2).toString\n  def romanFive(pwr: Int): String = symbols.apply(pwr * 2 + 1).toString\n  def digToRomanOne(dig: Int, pwr: Int): String =\n    if (dig <= 0) \"\"\n    else if (dig < 4) romanOne(pwr) + digToRomanOne(dig - 1, pwr)\n    else romanOne(pwr) + romanFive(pwr)\n  def digToRomanFive(dig: Int, pwr: Int): String =\n    if (dig <= 0) \"\"\n    else if (dig < 5) romanFive(pwr) + digToRomanOne(dig - 1, pwr)\n    else romanOne(pwr) + romanOne(pwr + 1)\n  def digToRoman(dig: Int, pwr: Int): String =\n    if (dig < 5) digToRomanOne(dig, pwr)\n    else digToRomanFive(dig - 4, pwr)\n  def encode(arabic: Int): String =\n    if (arabic > 0) digToRoman(lastDig(arabic), numOfDigs(arabic) - 1) + encode(popLastDig(arabic))\n    else \"\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333326,"user_id":null,"body":"object Roman {\n  val numerals = Vector((\"I\", \"V\"), (\"X\", \"L\"), (\"C\", \"D\"), (\"M\", \"\"))\n  \n  def _1_ishNumeral(rank: Int) = numerals(rank)._1\n  def _5_ishNumeral(rank: Int) = numerals(rank)._2\n  \n  def encode(decimal: Int): String = {\n    decimal.toString.map(_.asDigit).reverse.zipWithIndex.map { case (digit, rank) =>\n      digit match {\n        case 0 | 1 | 2 | 3 => _1_ishNumeral(rank) * digit\n        case 5 | 6 | 7 | 8 => _5_ishNumeral(rank) + (_1_ishNumeral(rank) * (digit - 5))\n        case 4 => _1_ishNumeral(rank) + _5_ishNumeral(rank)\n        case 9 => _1_ishNumeral(rank) + _1_ishNumeral(rank + 1)\n    }}.reverse.mkString\n  }\n} \/\/ That's the short version of my previous solution.\n\/\/ Now also ignoring possible failures, like other solutions. ;-)","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"51ba717bb08c1cd60f00002f":[{"id":333327,"user_id":null,"body":"object Kata {\n  def solution(nums: Seq[Int]): String = {\n    nums.foldLeft(List.empty[List[Int]]) {\n      case (Nil, x) => List(x)::Nil\n      case (xs::xxs, x) =>\n        if (xs.head == x-1) (x::xs)::xxs\n        else List(x)::xs::xxs\n    }.map {\n      case x::Nil => s\"$x\"\n      case x::y::Nil => s\"$y,$x\"\n      case x => s\"${x.last}-${x.head}\"\n    }.reverse.mkString(\",\")\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333328,"user_id":null,"body":"object Kata {\n\n    def solution(xs: Seq[Int]): String = split(xs).map(x=> if(x.length==1) x.head.toString else if(x.length==2) s\"${x.head},${x.reverse.head}\" else s\"${x.head}-${x.reverse.head}\").mkString(\",\")\n  def split(list: Seq[Int]) : List[List[Int]] = list match {\n    case Nil => Nil\n    case h::t => val segment = list.zipWithIndex.takeWhile{x=>x._1-h==x._2}.map(_._1)\n      segment :: split(list.drop(segment.length))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333329,"user_id":null,"body":"object Kata {\n\n  def solution(xs: Seq[Int]): String = {\n    xs.foldLeft(List[List[Int]]())((acc, element) => {\n      if (acc.isEmpty || element - acc.last.last != 1)\n        acc:+ List(element)\n      else {\n        acc.dropRight(1) :+ (acc.last :+ element)\n      }\n    }).map(l => if(l.size < 3) l.mkString(\",\") else l.head +\"-\"+l.last).mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333330,"user_id":null,"body":"object Kata {\n    def solution(xs: Seq[Int]): String = {\n        if(xs.length == 0) \"\"\n        else xs.tail.foldLeft(IndexedSeq(Range(xs.head, xs.head)))((rs, i) => rs.init ++ (rs.last + i)).mkString(\",\")\n    }\n\n    case class Range(left : Int, right : Int) {\n        override def toString = \n            if(left == right) left.toString\n            else if(right - left == 1) s\"$left,$right\"\n            else s\"$left-$right\"\n        def +(i : Int) = if(i - right == 1) IndexedSeq(Range(left, i)) else IndexedSeq(this, Range(i, i))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333331,"user_id":null,"body":"object Kata {\n  def solution(xs: Seq[Int]): String = {\n    if (xs.size <= 1) xs.mkString\n    else {   \n      val offsets = 0 +: xs.zip(xs.tail).map(n => n._2 - n._1)\n      \n      val pods = xs.zip(offsets)\n        .foldLeft(List[(Int, Int)]()) {\n          case (acc, elem) => acc.lastOption match {\n            case Some(v) if v._2 == 1 && elem._2 != 1 => {\n              val last = acc.last\n              acc.dropRight(1) :+ (last._1, last._2 + 1) :+ elem\n            }\n            case _ => acc :+ elem\n        }\n      }\n\n      val last = pods.last\n      (pods.dropRight(1) :+ (last._1, last._2 + 1))\n        .map(\n          n => {\n            n._2 match {\n              case 1 => \"*\"\n              case _ => s\"${n._1},\"\n            }\n          }\n        ).mkString\n        .dropRight(1)\n        .replace(\",*\", \"-\")\n        .filter(_ != '*')\n    }\n  } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333332,"user_id":null,"body":"object Kata {\n  import scala.collection.mutable.ArrayBuffer\n  \n  def solution(xs: Seq[Int]): String = {\n    def getStringRange(firstInt: Int, secondInt: Int): String =\n      if (firstInt == secondInt) firstInt.toString else if (firstInt + 1 == secondInt) s\"$firstInt,$secondInt\" else s\"$firstInt-$secondInt\"\n\n\n    def rec(acc: ArrayBuffer[String], currentList: Seq[Int], intBeginOfRange: Int): ArrayBuffer[String] = {\n      currentList match {\n        case Nil => acc\n        case l if l.tail.isEmpty =>\n          acc += getStringRange(intBeginOfRange, l.head)\n          acc\n        case l =>\n          if (l.head + 1 == l.tail.head) rec(acc, l.tail, intBeginOfRange)\n          else {\n            acc += getStringRange(intBeginOfRange, l.head)\n            rec(acc, l.tail, l.tail.head)\n          }\n      }\n    }\n\n    if (xs.isEmpty) \"\"\n    else rec(ArrayBuffer[String](), xs, xs.head).mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333333,"user_id":null,"body":"object Kata {\n\n  def solution(xs: Seq[Int]): String = {\n      def getRange(list: Seq[Int]): (String, List[Int]) = {\n    if (list.isEmpty) {\n      return (\"\", List[Int]())\n    }\n    if (list.length < 3) {\n      return (list.head.toString, list.tail)\n    }\n    val first = list.head\n    var second = list.tail.head\n    var third = list.tail.tail.head\n\n    if (!((second == (first + 1)) && (third == (second + 1)))) {\n      return (first.toString, list.tail)\n    }\n\n    var retString = first.toString + \"-\" + third\n    second = third\n    var remList = list.tail.tail.tail\n    var done = false\n    while (!done) {\n      if (remList.isEmpty) {\n        done = true\n      } else {\n        third = remList.head\n        if (third != (second + 1)) {\n          done = true\n        } else {\n          remList = remList.tail\n          retString = first.toString + \"-\" + third\n          second = third\n        }\n      }\n    }\n    (retString, remList)\n  }\n\n  var result = getRange(xs)\n  var retList = List(result._1)\n  while (result._2.nonEmpty) {\n    result = getRange(result._2)\n    retList = retList :+ result._1\n  }\n  retList.mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333334,"user_id":null,"body":"import scala.collection.mutable.ArrayBuffer\n\nobject Kata {\n\n  def solution(xs: Seq[Int]): String = {\n    if (xs.length == 0) {\n      \"\"\n    } else {\n      var current = xs.head\n      var tempList = ArrayBuffer[String]()\n      val list = ArrayBuffer[String]()\n\n      for (x <- xs) {\n        if (x == current) {\n          tempList.addOne(x.toString)\n          current += 1\n        } else {\n          if (tempList.length < 3) {\n            list.addAll(tempList)\n          } else {\n            list.addOne(s\"${tempList.head}-${tempList.last}\")\n          }\n          tempList = tempList.empty\n          tempList.addOne(x.toString)\n          current = x + 1\n        }\n      }\n\n      if (tempList.length < 3) {\n        list.addAll(tempList)\n      } else {\n        list.addOne(s\"${tempList.head}-${tempList.last}\")\n      }\n      list.mkString(\",\")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333335,"user_id":null,"body":"object Kata {\n  \n  def solution(xs: Seq[Int]): String = {\n    def solutionRec(xs: Seq[Int]): List[List[Int]] = xs match {\n      case Nil => List()\n      case _ => \n        var next = xs.head\n        xs.span { x => \n          val b = x == next\n          next = x + 1\n          b\n        } match {\n          case (range, Nil) => List(range)\n          case (range, rest) => range :: solutionRec(rest)\n        }\n    }\n    solutionRec(xs).map(range => {\n      if (range.size < 3) range.mkString(\",\")\n      else s\"${range.head}-${range.last}\"\n    }).mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333336,"user_id":null,"body":"object Kata {\n\n  def toRanges(xs: Seq[Int]): List[Range] =\n    xs.foldLeft[List[Range]](Nil) {\n      case (r :: tail, i) if i == r.end + 1 => Range.inclusive(r.start, i) :: tail\n      case (acc, i)                         => Range.inclusive(i, i) :: acc\n    }.reverse\n\n  def solution(xs: Seq[Int]): String =\n    toRanges(xs).foldLeft(\"\") {\n      case (acc, r) if r.length > 2  => acc + s\"${r.start}-${r.end},\"\n      case (acc, r) if r.length == 2 => acc + s\"${r.start},${r.end},\"\n      case (acc, r) if r.length == 1 => acc + s\"${r.start},\"\n    }.dropRight(1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"51c8991dee245d7ddf00000e":[{"id":333337,"user_id":573,"body":"object Kata {\n\n  def reverseWords(str: String): String =\n    str.split(' ').reverse.mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333338,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = {\n    val reversed = str.split(\" \");\n    var result = \"\";\n    for (i <- reversed.length -1 to 0 by -1) result+= reversed(i) + \" \";\n    result.replaceAll(\"\"\"(?m)\\s+$\"\"\",\"\");\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333339,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = {\n    def recur(words: List[String]): String =\n      words match {\n        case Nil => \"\"\n        case head :: Nil => head\n        case head :: tail => recur(tail) + \" \" + head\n      }\n      recur(str.split(\" \").toList)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333340,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = {\n    val arr = str.split(\" \")\n    var newString = \"\"\n    \/\/  println(arr.toList)\n    for (x <- (0 to arr.length - 1).reverse) {\n      newString += arr(x) + \" \"\n    }\n    newString.substring(0, newString.length - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333341,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = str.split(\" \").reverse.reduce((x, y) => x + \" \" + y)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333342,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = {\n      val words = str.split(\" \")\n    if(words.length>1)\n    words.tail.reverse.mkString(\" \").concat(s\" ${words.head}\")\n    else words.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333343,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = {\n    \n  \n    val strSplit = str.split(\" \")\n    val reversedString = strSplit.reverse\n    val newString = reversedString.mkString(\" \")\n    newString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333344,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String =\n  {\n    var t =\"\"\n    val temp = str.split(' ')\n    for(i<-temp)\n      {\n        t=i+\" \"+t\n      }\n    t.trim\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333345,"user_id":null,"body":"object Kata {\n\n  def reverseWords(s: String): String = {\n    \n    def loop (acc:List[String] = s.split(\" \").toList, st:String=\"\", k:Int= s.split(\" \").toList.length - 1):String =\n    {\n      if (k<0) st else loop(acc, s\"$st ${acc(k)}\", k-1)\n\n    }\n      loop().trim.replaceAll(\" +\", \" \")\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333346,"user_id":null,"body":"object Kata {\n\n  def reverseWords(str: String): String = {\n    val strSplit = str.split(\" \")\n    val reversedString = strSplit.reverse\n    val newString = reversedString.mkString(\" \")\n    \/\/println(newString)\n    newString\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"51e0007c1f9378fa810002a9":[{"id":333347,"user_id":573,"body":"object DeadFish {\n\n  def parse(data: String): List[Int] =\n    data.foldLeft(0, List[Int]()) {\n      case ((v, out), 'i') => (v+1, out)\n      case ((v, out), 'd') => (v-1, out)\n      case ((v, out), 's') => (v*v, out)\n      case ((v, out), 'o') => (v,   out :+ v)\n    }._2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333348,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject DeadFish {\n  def parse(data: String): List[Int] = {\n    \/\/ Implement me! :)\n    data.foldLeft((0, List[Int]())) {\n      case ((value, output), 'i') => (value + 1, output)\n      case ((value, output), 'd') => (value - 1, output)\n      case ((value, output), 's') => (value * value, output)\n      case ((value, output), 'o') => (value, output :+ value)\n      case ((value, output), _) => (value, output)\n    }._2\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333349,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject DeadFish {\n  def parse(data: String): List[Int] = {\n    var result: List[Int] = List()\n    var i : Int = 0\n    for (c <- data) {\n      c match {\n        case 'i' => i += 1\n        case 'd' => i -= 1\n        case 's' => i *= i\n        case 'o' => result = result :+ i\n        }\n    }\n    result\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333350,"user_id":null,"body":"object DeadFish {\n  val parse = (_ : String).scanLeft((0, Option.empty[Int])) {\n    case ((n, _), 'i') => (n + 1, None)\n    case ((n, _), 'd') => (n - 1, None)\n    case ((n, _), 's') => (n * n, None)\n    case ((n, _), 'o') => (n, Some(n))\n    case ((n, _), _)   => (n, None)\n  }.flatMap(_._2).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333351,"user_id":null,"body":"object DeadFish {\n\n  def parse(data: String): List[Int] =\n    data.foldLeft((List.empty[Int], 0)) {\n      case ((results, currentValue), command) =>\n        command match {\n          case 'i' => (results, currentValue + 1)\n          case 'd' => (results, currentValue - 1)\n          case 's' => (results, currentValue * currentValue)\n          case 'o' => (results :+ currentValue, currentValue)\n        }\n    }._1\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333352,"user_id":null,"body":"object DeadFish {\n  def parse(data: String): List[Int] = {\n    def accu(data: List[Char], value: Int, result: List[Int]): List[Int] = data match {\n    case Nil => result.reverse\n    case head::tail => head match {\n      case 'i' => accu(tail, value+1, result)\n      case 'd' => accu(tail, value-1, result)\n      case 's' => accu(tail, value*value, result)\n      case 'o' => accu(tail, value, value::result)\n    }\n  }\n  accu(data.toCharArray.toList,0,Nil)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333353,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject DeadFish {\n\n  def parse(data: String): List[Int] = {\n    var x  = 0\n    val ns = new ListBuffer[Int]()\n\n    data.foreach({\n      case 'i' => x += 1\n      case 'd' => x -= 1\n      case 's' => x *= x\n      case 'o' => ns += x\n    })\n\n    ns.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333354,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject DeadFish {\n  def parse(data: String): List[Int] =\n    data.foldLeft((List.empty[Int], 0)) {\n      case ((xs, v), 'i') => (xs, v+1)\n      case ((xs, v), 'd') => (xs, v-1)\n      case ((xs, v), 's') => (xs, v*v)\n      case ((xs, v), 'o') => (v::xs, v)\n    }._1.reverse\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333355,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject DeadFish {\n   def parse(data: String): List[Int] = {\n    var result: List[Int] = List()\n    var tmpValue = 0;\n    data.map(_ match {\n      case 'i' => tmpValue += 1\n      case 'd' => tmpValue -= 1\n      case 's' => tmpValue *= tmpValue\n      case 'o' => result = result :+ tmpValue\n      case _ =>\n    })\n    result\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333356,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject DeadFish {\n  def parse(data: String): List[Int] = {\n  var result = new ListBuffer[Int]\n  var value = 0\n  data.foreach(_ match {\n    case 'i' => value += 1\n    case 'd' => value -= 1\n    case 's' => value = value * value\n    case 'o' => result.append(value)\n  })\n  result.toList\n }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"51edd51599a189fe7f000015":[{"id":333357,"user_id":573,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double =\n    a.zip(b).map { case (x, y) => math.pow(x-y, 2) }.sum \/ a.size\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:33"},{"id":333358,"user_id":null,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    \/\/\n    a.zip(b).map(e => math.pow(e._2-e._1,2)).sum\/a.length\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:42"},{"id":333359,"user_id":53,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    (a zip b).map({case (x, y) => scala.math.pow(x - y, 2) }).sum \/ a.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333360,"user_id":527,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    (a, b).zipped.map{ case (x, y) => math.pow(x - y, 2) }.sum \/ a.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333361,"user_id":null,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    a.zip(b).map(pair => math.pow(pair._1 - pair._2, 2)).sum \/ a.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333362,"user_id":null,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    (a lazyZip b).map((a,b) => Math.pow(Math.abs(a-b), 2)).sum \/ a.size\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333363,"user_id":null,"body":"object Sol {\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    a.indices.map(i => scala.math.pow(Math.abs(a(i) - b(i)), 2)).sum \/ a.size.toDouble\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333364,"user_id":null,"body":"object Sol {\n  def solution(a: Seq[Int], b: Seq[Int]): Double =\n    a.zip(b).map{ tup => scala.math.pow((tup._1 - tup._2), 2) }.sum \/ a.length\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333365,"user_id":null,"body":"import scala.math.pow\n\nobject Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    val items = a.zip(b)\n      .map(x => (x._1 - x._2).abs)\n      .map(pow(_, 2))\n    \n    items.sum \/ items.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"},{"id":333366,"user_id":null,"body":"object Sol {\n\n  def solution(a: Seq[Int], b: Seq[Int]): Double = {\n    a.zip(b).map{ case (a1, b1) => math.pow((a1 - b1).abs, 2) }.sum \/ a.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-11 14:14:23"}],"521c2db8ddc89b9b7a0000c1":[{"id":333367,"user_id":751,"body":"object Snail {\n  \n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = xs match {\n    case Nil => Nil\n    case x :: xs => x ++ snail(xs.transpose.reverse)\n  }    \n  \n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333368,"user_id":null,"body":"object Snail {\n  \n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = xs match {\n    case Nil => Nil\n    case x :: rest => x ++ snail(rest.transpose.reverse)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333369,"user_id":null,"body":"object Snail {\n  \n  def getLastCol(ls: Seq[Seq[Int]], acc: Seq[Int]=List()): Seq[Int] ={\n  if(ls.tail.isEmpty) acc:+ ls.head.last\n  else getLastCol(ls.tail,acc:+ls.head.last)\n}\ndef getFirstCol(ls: Seq[Seq[Int]], acc: Seq[Int]=List()): Seq[Int] ={\n  if(ls.tail.isEmpty) acc:+ ls.head.head\n  else getFirstCol(ls.tail,acc:+ls.head.head)\n}\ndef deleteLastCol(ls:Seq[Seq[Int]], acc:Seq[Seq[Int]] = List()): Seq[Seq[Int]] =\n{\n  if(ls.tail.isEmpty) acc:+ ls.head.dropRight(1)\n  else deleteLastCol(ls.tail, acc:+ls.head.dropRight(1))\n}\ndef deleteFirstCol(ls:Seq[Seq[Int]], acc:Seq[Seq[Int]] = List()): Seq[Seq[Int]] =\n{\n  if(ls.tail.isEmpty) acc:+ ls.head.drop(1)\n  else deleteFirstCol(ls.tail, acc:+ls.head.drop(1))\n}\n\n\ndef snail(ls: Seq[Seq[Int]], acc: Seq[Seq[Int]] = List(), iter:Int=1): Seq[Int] = {\n  if(ls.head.isEmpty)List()\n    \n else if(iter%2==1)\n  {\n    if(ls.length ==1 && ls.head.length ==1) (acc:+ls.head).flatten\n  else snail(deleteLastCol(ls.drop(1)), acc:+ls(0):+getLastCol(ls.drop(1)),iter+1)\n  }\n  else{\n   if(ls.length ==1 && ls.head.length ==1) (acc:+ls.head).flatten\n   else snail(deleteFirstCol(ls.dropRight(1)), acc:+ls.takeRight(1)(0).reverse:+getFirstCol(ls.dropRight(1)).reverse, iter+1)\n }\n}\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333370,"user_id":null,"body":"object Snail {\n  \n  def snail(xs: Seq[Seq[Int]]): Seq[Any] = {\n  def last_(b:Seq[Seq[Int]],l:Seq[Int]):Seq[Int]=b match{\n   case Nil => throw new Exception(\"Empty list or wrong demension.\")\n   case x::Nil => (x.last::l).init.reverse\n   case x::xt => last_(xt, x.last::l)\n }\ndef smaller_sq(a:Seq[Seq[Int]],l:Seq[Seq[Int]]):Seq[Seq[Int]]=a match{\n  case Nil => throw new Exception(\"Empty list.\")\n  case x::Nil => l:+x.init.tail\n  case x::xs => smaller_sq(xs,l:+x.init.tail)\n}\ndef firth(a:Seq[Seq[Int]],l:Seq[Int]):Seq[Int]=a match{\n  case Nil => throw new Exception(\"Empty list.\")\n  case x::Nil => (x.head::l).init.tail\n  case x::xs => firth(xs,x.head::l)\n}\n  \n  def re(x:Seq[Seq[Int]],xl:Seq[Int],l:Seq[Int],sw:Int\n       ,acc:Int,stop:Int,acc_final:Int,final_stop:Int):Seq[Int]={\n     \n     if(acc_final==final_stop) l.reverse\n     \n     else if(sw==0 && acc!=stop){\n        re(x,xl.tail,xl.head::l,sw,acc+1,stop,acc_final+1,final_stop)\n      }\n     else if(sw==0&& acc==stop){\n       re(x,x.last.init.reverse++firth(x,List()),l,1,0,\n           (x.last.init.reverse++firth(x,List())).length,acc_final,final_stop)\n     }\n      else if(sw==1 && acc!=stop){\n        re(x,xl.tail,xl.head::l,sw,acc+1,stop,acc_final+1,final_stop)\n      }\n      else if(sw==1&& acc==stop){\n        re(smaller_sq(x.init.tail,List()),\n            smaller_sq(x.init.tail,List()).head++last_(smaller_sq(x.init.tail,List()),List()),l,\n            0,0,smaller_sq(x.init.tail,List()).head.length+smaller_sq(x.init.tail,List()).length-1,\n            acc_final,final_stop)\n      }\n      else throw new Exception(\"Error\")\n   }\n   if(xs.isEmpty)List()\n   else if(xs.last.isEmpty)List()\n   else re(xs,xs.head++last_(xs,List()),List(),0,0,xs.head.length+xs.length-1,0,xs.length*xs.head.length)\n   \n  }\n}\n\/\/Sorry for unreadable code, but i tried my best:)","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333371,"user_id":null,"body":"object Snail {\n  \n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = {\n    \n    def snailRec(xs: Seq[Seq[Int]], snailRes: Seq[Int]): Seq[Int] = {\n  \n      if(xs.isEmpty) return snailRes\n  \n      snailRec(xs.tail.transpose.reverse, snailRes++xs.head)\n    }\n    snailRec(xs, List())\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333372,"user_id":null,"body":"object Snail {\n  def snail: Seq[Seq[Int]] => Seq[Int] = _ match {\n      case Nil    => Nil\n      case h :: t => h ++ snail(t.transpose.reverse)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333373,"user_id":null,"body":"import cats.data.NonEmptyList\n\nobject Snail {\n\n  case class Coordinate(i: Int, j: Int)\n  case class Navigation(visitedSofar: NonEmptySeq[Coordinate])\n\n  sealed trait Direction\n  object Direction {\n    case object Up    extends Direction\n    case object Right extends Direction\n    case object Down  extends Direction\n    case object Left  extends Direction\n\n    def rightHandedRotate(currentDir: Direction): Direction = currentDir match {\n        case Direction.Right =>\n          Direction.Down\n        case Direction.Left =>\n          Direction.Up\n        case Direction.Up =>\n          Direction.Right\n        case Direction.Down =>\n          Direction.Left\n      }\n  }\n\n  def coordinateAhead(coordinate: Coordinate, currentDirection: Direction): Coordinate = {\n    val iValue = coordinate.i\n    val jValue = coordinate.j\n\n    currentDirection match {\n      case Direction.Up =>\n        coordinate.copy(j = jValue - 1)\n      case Direction.Right =>\n        coordinate.copy(i = iValue + 1)\n      case Direction.Down =>\n        coordinate.copy(j = jValue + 1)\n      case Direction.Left =>\n        coordinate.copy(i = iValue - 1)\n    }\n  }\n\n  def maybeCoordinateAhead(navigation: Navigation, currentDirection: Direction, squareSide: Int): Option[Coordinate] = {\n    val ahead = coordinateAhead(navigation.visitedSofar.head, currentDirection)\n    Option.when(\n      !navigation.visitedSofar.toList.contains(ahead) &&\n        ahead.i <= squareSide &&\n        ahead.j <= squareSide &&\n        0 < ahead.i &&\n        0 < ahead.j\n    )(ahead)\n  }\n\n  def getNumberAt(xs: Seq[Seq[Int]])(coordinate: Coordinate): Int = xs(coordinate.j - 1)(coordinate.i - 1)\n\n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = {\n\n    def update(currentDirection: Direction, navigation: Navigation): Navigation =\n      if (navigation.visitedSofar.size == xs.size * xs.size)\n        navigation\n      else\n        maybeCoordinateAhead(navigation, currentDirection, xs.size) match {\n          case Some(nextCoordinate) =>\n            update(currentDirection, Navigation(nextCoordinate :: navigation.visitedSofar))\n          case None =>\n            update(Direction.rightHandedRotate(currentDirection), navigation)\n        }\n\n    xs match {\n      case _ if xs.flatten.isEmpty =>\n        Nil\n      case _ =>\n        val start = Coordinate(1, 1)\n        update(Direction.Right, Navigation(NonEmptyList.one(start)))\n          .visitedSofar\n          .reverse\n          .map(getNumberAt(xs))\n          .toList\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333374,"user_id":null,"body":"object Snail {\n  \n  case class Coordinate(i: Int, j: Int)\n  case class Navigation(visitedSofar: Seq[Coordinate], coordinate: Coordinate)\n\n  sealed trait Direction\n  object Direction {\n    case object Up    extends Direction\n    case object Right extends Direction\n    case object Down  extends Direction\n    case object Left  extends Direction\n\n    def rightHandedRotate(currentDir: Direction): Direction =\n      currentDir match {\n        case Direction.Right =>\n          Direction.Down\n        case Direction.Left =>\n          Direction.Up\n        case Direction.Up =>\n          Direction.Right\n        case Direction.Down =>\n          Direction.Left\n      }\n  }\n\n  def coordinateAhead(coordinate: Coordinate, currentDirection: Direction): Coordinate = {\n    val iValue = coordinate.i\n    val jValue = coordinate.j\n\n    currentDirection match {\n      case Direction.Up =>\n        coordinate.copy(j = jValue - 1)\n      case Direction.Right =>\n        coordinate.copy(i = iValue + 1)\n      case Direction.Down =>\n        coordinate.copy(j = jValue + 1)\n      case Direction.Left =>\n        coordinate.copy(i = iValue - 1)\n    }\n  }\n\n  def maybeCoordinateAhead(navigation: Navigation, currentDirection: Direction, squareSide: Int): Option[Coordinate] = {\n    val ahead = coordinateAhead(navigation.coordinate, currentDirection)\n    Option.when(\n      !navigation.visitedSofar.contains(ahead) &&\n        ahead.i <= squareSide &&\n        ahead.j <= squareSide &&\n        0 < ahead.i &&\n        0 < ahead.j\n    )(ahead)\n  }\n\n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = {\n    def getNumberAt(coordinate: Coordinate): Int = xs(coordinate.j - 1)(coordinate.i - 1)\n\n    def update(currentDirection: Direction, navigation: Navigation): Navigation =\n      if (navigation.visitedSofar.size == xs.size * xs.size)\n        navigation\n      else\n        maybeCoordinateAhead(navigation, currentDirection, xs.size) match {\n          case Some(nextCoordinate) =>\n            update(currentDirection, Navigation(nextCoordinate :: navigation.visitedSofar, nextCoordinate))\n          case None =>\n            update(Direction.rightHandedRotate(currentDirection), navigation)\n        }\n\n    xs match {\n      case _ if xs.flatten.isEmpty =>\n        Nil\n      case ::(_, _) =>\n        val start = Coordinate(1, 1)\n        update(Direction.Right, Navigation(visitedSofar = List(start), coordinate = start)).visitedSofar.reverse\n          .map(getNumberAt)\n\n    }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333375,"user_id":null,"body":"object Snail {\n\n\n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = {\n    if (xs.isEmpty) return List()\n\n\n    import scala.collection.mutable.ArrayBuffer\n    val row = xs.length\n    val column = xs.head.length\n    val num = row * column\n\n    def valid(x: Int, y: Int): Boolean =\n      x >= 0 && x < row && y >= 0 && y < column\n\n    val visit = Array.fill(row, column)(false)\n    val turn = Array((0,1), (1,0), (0,-1), (-1,0))\n    var res =   ArrayBuffer.empty[Int]\n\n    @scala.annotation.tailrec\n    def travel(x: Int, y: Int, curNum: Int, step: Int): Unit = {\n      if (curNum < num) {\n        visit(x)(y) = true\n        res += xs(x)(y)\n        val xn = x + turn(step%4)._1\n        val yn = y + turn(step%4)._2\n        if (valid(xn,yn) && !visit(xn)(yn))\n          travel(xn, yn, curNum+1, step)\n        else {\n          val xn = x + turn((step+1)%4)._1\n          val yn = y + turn((step+1)%4)._2\n          travel(xn, yn, curNum+1, step +1)\n        }\n      }\n    }\n\n    travel(0, 0, 0, 0)\n\n    res.toList\n  }\n  \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333376,"user_id":null,"body":"object Snail {\n  \n  def leftTurn[T](xs:Seq[Seq[T]]):Seq[Seq[T]] = xs.transpose.reverse\n  \n  def snail(xs: Seq[Seq[Int]]): Seq[Int] = xs match {\n    case List() => List()\n    case row::rest => row ++ snail(leftTurn(rest))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"523f5d21c841566fde000009":[{"id":333377,"user_id":573,"body":"object Kata {\n\n  def array_difference(a: Seq[Int], b: Seq[Int]) =\n    a.filterNot(b.contains)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333378,"user_id":null,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]) = {\n    val quickRefSet = b.toSet\n    a.filterNot(quickRefSet.contains)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333379,"user_id":527,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]) = a.filterNot(b.toSet.contains)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333380,"user_id":53,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]) = {\n    a.filterNot(x => b.exists(_ == x))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333381,"user_id":null,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]) = {\n    \/\/ Your code here\n    a.filter(s => !b.contains(s))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333382,"user_id":636,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]) = \n    b.foldLeft(a)((t,c) => t.filterNot(_==c))\n \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333383,"user_id":null,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]): Seq[Int] = {\n    a.filterNot(b.contains(_))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333384,"user_id":null,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]): Seq[Int] = {\n    val s = b.toSet\n    a.filter(x => !(b contains x))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333385,"user_id":null,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]): Seq[Int] = {\n    a.filter(x => !b.contains(x))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333386,"user_id":null,"body":"object Kata {\n  def array_difference(a: Seq[Int], b: Seq[Int]): Seq[Int] = {\n    \/\/ Your code here\n    a.filter(i => !b.exists(i == _))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"524c74f855025e2495000262":[{"id":333387,"user_id":573,"body":"object Poker {\n  \n  case class Card(rank: String, colour: String)\n  val ranks = List(\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\")\n  implicit def ordering: Ordering[String] = Ordering.by(ranks.indexOf)\n\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n\n    val cards = (holeCards ::: communityCards).map(x => Card(x.init, x.takeRight(1)))\n\n    def group(occurences: Int, excluded: List[String] = Nil): Option[String] =\n      cards.groupBy(_.rank).collect { case (rank, cards) if cards.size >= occurences && !excluded.contains(rank) => rank }.maxOption\n\n    def highests(excluded: List[String] = Nil, cards: List[Card]=cards): List[String] =\n      cards.map(_.rank).filterNot(excluded.contains).sorted.reverse\n\n    def flush(cards: List[Card]): Option[List[Card]] =\n      cards.groupBy(_.colour).collectFirst { case (_, cards) if cards.size >= 5 => cards }\n\n    def straight(cards: List[Card]): Option[List[String]] =\n      highests(cards=cards).sliding(5).find(ranks.reverse.containsSlice)\n\n    (for { flush <- flush(cards); straight <- straight(flush) } yield (\"straight-flush\", straight))\n      .orElse { group(occurences=4).map { four => (\"four-of-a-kind\", four :: highests(excluded=List(four)).take(1)) } }\n      .orElse { for { triple <- group(occurences=3); pair <- group(occurences=2, excluded=List(triple)) } yield (\"full house\", List(triple, pair)) }\n      .orElse { flush(cards).map { cards => (\"flush\", highests(cards=cards).take(5)) } }\n      .orElse { straight(cards.distinctBy(_.rank)).map((\"straight\", _)) }\n      .orElse { group(occurences=3).map { triple => (\"three-of-a-kind\", triple :: highests(excluded=List(triple)).take(2)) } }\n      .orElse { for { pair1 <- group(occurences=2); pair2 <- group(occurences=2, excluded=List(pair1)) } yield (\"two pair\", List(pair1, pair2, highests(excluded=List(pair1, pair2)).head)) }\n      .orElse { group(occurences=2).map { pair => (\"pair\", pair :: highests(excluded=List(pair)).take(3)) } }\n      .getOrElse { (\"nothing\", highests().take(5)) }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333388,"user_id":null,"body":"import scala.util.matching.Regex\nobject Poker {\n\n  type Result = (String, List[String])\n\n  sealed trait Suit\n  case object Diamonds extends Suit \/\/ \u2666\n  case object Hearts extends Suit \/\/ \u2665\n  case object Spades extends Suit \/\/ \u2660\n  case object Clubs extends Suit \/\/ \u2663\n\n  object Suit {\n\n    def apply(ch: Char): Suit = ch match {\n      case '\u2666' => Diamonds\n      case '\u2665' => Hearts\n      case '\u2660' => Spades\n      case '\u2663' => Clubs\n    }\n  }\n\n  case class Card(mark: String, rank: Int, suit: Suit) {\n\n    override def equals(that: Any): Boolean = that match {\n      case that: Card => this.hashCode == that.hashCode\n      case _ => false\n    }\n\n    override def hashCode(): Int = this.rank + this.mark.hashCode\n  }\n\n  object Card {\n    val cardR: Regex = \"\"\"(\\S{1,2})(\\S)\"\"\".r\n    val numberR: Regex = \"\"\"\\d{1,2}\"\"\".r\n\n    def calcRank(mark: String): Int = mark match {\n      case \"A\" => 14\n      case \"K\" => 13\n      case \"Q\" => 12\n      case \"J\" => 11\n      case numberR(_*) => mark.toInt\n      case _ => -1\n    }\n\n    def apply(s: String): Card = s match {\n      case cardR(mark, s) => Card(mark, calcRank(mark), Suit(s.head))\n    }\n  }\n\n  def hand(hole: List[String], community: List[String]): Result =\n    findCombination((hole ++ community).map(Card.apply).sortByRank)\n\n  object Detector {\n\n    def checkPair(cards: List[Card]): Option[Result] = {\n      val pair = cards.groupRankAmount.removeGroupsLess(2)\n\n      if (pair.isEmpty) return None\n\n      val pairMark = pair.getCards.sortByRank.firstMark\n      val others = cards.filterNot(_.mark == pairMark).sortByRank.take(3).marks\n\n      Some(\"pair\", List(pairMark) ++ others)\n    }\n\n    def checkTwoPair(cards: List[Card]): Option[Result] = {\n      val pairCards = cards.groupRankAmount.removeGroupsLess(2)\n\n      if (pairCards.isEmpty || pairCards.size < 2) return None\n\n      val twoPairs = pairCards.getCards.sortByRank.take(2).marks\n      val others = cards.filterNot(card => twoPairs.contains(card.mark)).sortByRank.firstMark\n\n      Some(\"two pair\", twoPairs ++ List(others))\n    }\n\n    def checkFourOfKind(cards: List[Card]): Option[Result] = {\n      val result = cards.groupRankAmount\n      val four = result.removeGroupsLess(4).getCards\n\n      if (four.isEmpty) return None\n\n      val fourMark = four.firstMark\n      val otherMark = cards.filterNot(_.mark == fourMark).sortByRank.firstMark\n\n      Some((\"four-of-a-kind\", List(fourMark, otherMark)))\n    }\n\n    def checkThreeOfKind(cards: List[Card]): Option[Result] = {\n      val three = cards.groupRankAmount.removeGroupsLess(3).getCards\n\n      if (three.isEmpty) return None\n\n      val threeMark = three.firstMark\n      val otherMarks = cards.filterNot(_.mark == threeMark).sortByRank.take(2).marks\n\n      Some(\"three-of-a-kind\", List(threeMark) ++ otherMarks)\n\n    }\n\n    def checkFullHouse(cards: List[Card]): Option[Result] = {\n      val result = cards.groupRankAmount\n\n      if (result.size < 3) return None\n\n      val three = result.removeGroupsLess(3).sortByRank\n\n      if (three.isEmpty) return None\n\n      val threeMark = three.getCards.firstMark\n      val other = result\n        .filterNot(threeMark == _._1.mark)\n        .sortByRank\n        .removeGroupsLess(2)\n\n      if (other.isEmpty) return None\n\n      Some((\"full house\", List(threeMark, other.getCards.firstMark)))\n    }\n\n    def checkFlush(cards: List[Card]): Option[Result] = {\n      val result = cards.groupSuite.filter { case (_, cards) => cards.size >= 5}.values\n\n      if (result.isEmpty) return None\n\n      Some(\"flush\", result.head.take(5).marks)\n    }\n\n    def checkStraight(cards: List[Card]): Option[Result] = isStraight(cards).map(cards => (\"straight\", cards.marks))\n\n    def checkStraightFlush(cards: List[Card]): Option[Result] = {\n      val result = cards.groupSuite\n        .map { case (suit, cards) => (suit, isStraight(cards)) }\n        .filter { case (_, cards) => cards.isDefined }\n        .values\n\n      if (result.isEmpty) return None\n\n      Some((\"straight-flush\", result.head.get.marks))\n    }\n\n    def isStraight(cards: List[Card]): Option[List[Card]] = {\n      def check(control: Int, select: List[Int]): Boolean =\n        select.zipWithIndex\n          .map { case (element, index) => element + index }\n          .count(_ == control) == select.size\n\n      val sorted = cards.sortByRank.distinct\n      val ranks = sorted.map(_.rank)\n\n      if (ranks.length >= 5 && check(ranks.head, ranks.slice(0, 5))) Some(sorted.slice(0, 5))\n      else if (ranks.length >= 6 && check(ranks(1), ranks.slice(1, 6))) Some(sorted.slice(1, 6))\n      else if (ranks.length >= 7 && check(ranks(2), ranks.slice(2, 7))) Some(sorted.slice(2, 7))\n      else None\n    }\n\n  }\n\n  def findCombination(cards: List[Card]): (String, List[String]) = {\n    import Detector._\n\n    checkStraightFlush(cards)\n      .orElse(checkFourOfKind(cards))\n      .orElse(checkFullHouse(cards))\n      .orElse(checkFlush(cards))\n      .orElse(checkStraight(cards))\n      .orElse(checkThreeOfKind(cards))\n      .orElse(checkTwoPair(cards))\n      .orElse(checkPair(cards))\n      .getOrElse((\"nothing\", cards.sortByRank.marks.take(5)))\n\n  }\n\n  implicit class PokerExtension(cards: List[Card]) {\n    def marks: List[String] = cards.map(_.mark)\n    def firstMark: String = cards.head.mark\n    def groupSuite: Map[Suit, List[Card]] = cards.groupBy(_.suit)\n    def groupRank: Map[Int, List[Card]] = cards.groupBy(_.rank)\n    def groupRankAmount: List[(Card, Int)] = cards.groupRank.map { case (_, cards) => (cards.head, cards.size) }.toList\n    def sortByRank: List[Card] = cards.sortWith(_.rank > _.rank)\n  }\n\n  implicit class PokerExtensionMap(cards: List[(Card, Int)]) {\n    def getCards: List[Card] = cards.map{ case (card, _) => card }\n    def removeGroupsLess(size: Int): List[(Card, Int)] = cards.filter { case (_, amount) => amount >= size }\n    def sortByRank: List[(Card, Int)] = cards.sortWith(_._1.rank >= _._1.rank)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333389,"user_id":null,"body":"import scala.util.matching.Regex\nobject Poker {\n  type Result = (String, List[String])\n\n  def hand(hole: List[String], community: List[String]): Result = {\n    println(\"\n___ START ___\")\n    val all = hole ++ community\n    val cards = all.map(Card.apply).sortByRank\n    findCombination(cards)\n  }\n\n  object Detector {\n\n\n    def checkPair(cards: List[Card]): Option[Result] = {\n      val group = cards.groupRank.map { case (rank, cards) => (cards.head, cards.size) }.toList\n      val pair = group.filter {\n        case (card, amount) => amount >= 2\n      }\n\n      if (pair.isEmpty) return None\n      val pairMark = pair.map(_._1).sortByRank.head.mark\n      val others = cards.filterNot(card => pairMark == card.mark).sortByRank.take(3).marks\n\n      Some(\"pair\", List(pairMark) ++ others)\n\n    }\n\n    def checkTwoPair(cards: List[Card]): Option[Result] = {\n\n      val group = cards.groupRank.map { case (rank, cards) => (cards.head, cards.size)}.toList\n      val pairCards = group.filter {\n        case (card, amount) => amount >= 2\n      }\n      if (pairCards.isEmpty || pairCards.size < 2) return None\n\n      val twoPairs = pairCards.map(_._1).sortByRank.take(2).marks\n      val others = cards\n        .filterNot(card => twoPairs.contains(card.mark))\n        .sortByRank\n        .head\n        .mark\n      println(s\"-- First Card Pair: $pairCards\")\n      println(s\"-- twoPairs       : $twoPairs\")\n      println(s\"-- others       : $others\")\n      Some(\"two pair\", twoPairs ++ List(others))\n    }\n\n    def checkFourOfKind(cards: List[Card]): Option[Result] = {\n      println(s\"Checking Four of Kind of $cards\n----------------------- \")\n      val group = cards.groupRank\n      println(s\"Grouped $group\")\n      val result = group.map { case (rank, cards) => (cards.head, cards.size)}.toList\n      println(s\"Is Four of kind? - ${result}\")\n      val four = result.filter(_._2 >= 4).map(_._1)\n\n      if (four.isEmpty) return None\n\n      val fourMark = four.head.mark\n      val otherMark = cards.filterNot(card => card.mark == fourMark).sortByRank.head.mark\n\n      Some((\"four-of-a-kind\", List(fourMark, otherMark)))\n    }\n\n    def checkThreeOfKind(cards: List[Card]): Option[Result] = {\n      println(s\"Checking Three of Kind of $cards\n----------------------- \")\n      val three = cards.groupRank.find { case (_, cards) => cards.size >= 3}\n      if (three.isEmpty) return None\n      val other = cards.filter(three.get._2.head.mark != _.mark).sortByRank\n      if (other.isEmpty) return None\n\n      println(s\"Summary \n-Three: $three \n-Other: $other\")\n      Some(\"three-of-a-kind\", List(three.get._2.head.mark) ++ other.take(2).marks)\n\n    }\n\n    def checkFullHouse(cards: List[Card]): Option[Result] = {\n      println(s\"Checking Full House of $cards\n----------------------- \")\n      val group = cards.groupRank\n      println(s\"Grouped $group\")\n      val result = group.map { case (rank, cards) => (cards.head, cards.size) }.toList\n      if(result.size < 3) return None\n      println(s\"Is Full House - ${result}\")\n      val three = result.filter(_._2 >= 3).sortWith(_._1.rank >= _._1.rank)\n      println(s\"Three: $three\")\n\n\n      if (three.nonEmpty) {\n        val other = result\n          .filter(three.head._1.mark != _._1.mark)\n          .sortWith(_._1.rank >= _._1.rank)\n          .find{ case (card, amount) => amount >= 2}\n\n        if (other.isEmpty) return None\n\n\n        println(s\"Other: $other\")\n        val r = List(three.head._1.mark, other.get._1.mark)\n\n        println(s\"result: true, ${result}\")\n        println(s\"result: true, ${r}\")\n        Some((\"full house\", r))\n      }\n      else {\n        println(s\"result: false\")\n        None\n      }\n    }\n\n    def checkFlush(cards: List[Card]): Option[Result] = {\n      println(s\"Checking Flush of $cards\n----------------------- \")\n      val group = cards.groupSuite\n      println(s\"Grouped $group\")\n      val result = group.filter {\n        case (suit, cards) => cards.size >= 5\n      }.values\n      println(s\"Is Full House - ${result}\")\n      if (result.nonEmpty) {\n        println(s\"result: true, ${result.head.take(5)}\")\n        Some(\"flush\", result.head.take(5).marks)\n      }\n      else {\n        println(s\"result: false\")\n        None\n      }\n\n    }\n\n    def checkStraight(cards: List[Card]): Option[Result] = {\n      println(s\"Checking Straight of $cards\n----------------------- \")\n      isStraight(cards).map(cards => (\"straight\", cards.marks))\n    }\n\n    def checkStraightFlush(cards: List[Card]): Option[Result] = {\n      println(s\"\nChecking Straight flush of $cards\n----------------------- \")\n      val group = cards.groupSuite\n      println(s\"Grouped $group\")\n      val result = group.map { case (suit, cards) => (suit, Detector.isStraight(cards)) }\n      println(s\"Is Straight flush? - ${result}\")\n      val c = result.filter { case (_, cards) => cards.isDefined }.values\n\n      if (c.nonEmpty) {\n        println(s\"result: true, ${c.head.get.marks}\")\n        Some((\"straight-flush\", c.head.get.marks))\n      }\n      else {\n        println(s\"result: false\")\n        None\n      }\n    }\n\n    def isStraight(cards: List[Card]): Option[List[Card]] = {\n      def check(control: Int, select: List[Int]): Boolean = {\n        select\n          .zipWithIndex.map { case (element, index) => element + index }\n          .count(_ == control) == select.size\n      }\n\n      val sorted = cards.sortByRank.distinct\n      println(s\"s: $sorted, \n d: ${sorted.distinct}\")\n      val ranks = sorted.map(_.rank)\n      print(s\"Check Straight ${ranks} -> \")\n      if (ranks.length >= 5 && check(ranks.head, ranks.slice(0,5))) {\n        println(s\"Found Straight first 5 ${sorted.slice(0,5)}\")\n        Some(sorted.slice(0,5))\n      }\n      else if (ranks.length >= 6 && check(ranks(1), ranks.slice(1,6))) {\n        println(s\" Found Straight second 5 ${sorted.slice(1,6)}\")\n        Some(sorted.slice(1,6))\n      }\n      else if (ranks.length >= 7 && check(ranks(2), ranks.slice(2,7))) {\n        println(s\" Found Straight third 5 ${sorted.slice(2,7)}\")\n        Some(sorted.slice(2,7))\n      } else {\n        println(\"Not Found\")\n        None\n      }\n    }\n  }\n\n  def findCombination(cards: List[Card]): (String, List[String]) = {\n    import Detector._\n\n    checkStraightFlush(cards)\n      .orElse(checkFourOfKind(cards))\n      .orElse(checkFullHouse(cards))\n      .orElse(checkFlush(cards))\n      .orElse(checkStraight(cards))\n      .orElse(checkThreeOfKind(cards))\n      .orElse(checkTwoPair(cards))\n      .orElse(checkPair(cards))\n      .getOrElse((\"nothing\", cards.sortByRank.marks.take(5)))\n\n  }\n\n  implicit class PokerExtension(cards: List[Card]) {\n    def marks: List[String] = cards.map(_.mark)\n    def groupSuite: Map[Suit, List[Card]] = cards.groupBy(_.suit)\n    def groupRank: Map[Int, List[Card]] = cards.groupBy(_.rank)\n    def sortByRank: List[Card] = cards.sortWith(_.rank > _.rank)\n  }\n\n  sealed trait Suit\n  case object Diamonds extends Suit \/\/ \u2666\n  case object Hearts extends Suit \/\/ \u2665\n  case object Spades extends Suit \/\/ \u2660\n  case object Clubs extends Suit \/\/ \u2663\n\n  object Suit {\n\n    def apply(ch: Char): Suit = ch match {\n      case '\u2666' => Diamonds\n      case '\u2665' => Hearts\n      case '\u2660' => Spades\n      case '\u2663' => Clubs\n    }\n  }\n\n  case class Card(mark: String, rank: Int, suit: Suit) {\n\n    override def equals(that: Any): Boolean = that match {\n      case that: Card => this.hashCode == that.hashCode\n      case _ => false\n    }\n\n    override def hashCode(): Int =  this.rank + this.mark.hashCode\n  }\n\n  object Card {\n    val cardR: Regex = \"\"\"(\\S{1,2})(\\S)\"\"\".r\n    val numberR: Regex = \"\"\"\\d{1,2}\"\"\".r\n\n    def calcRank(mark: String): Int = mark match {\n      case \"A\" => 14\n      case \"K\" => 13\n      case \"Q\" => 12\n      case \"J\" => 11\n      case numberR(_*) => mark.toInt\n      case _ => -1\n    }\n\n    def apply(s: String): Card = s match {\n      case cardR(mark, s) => Card(mark, calcRank(mark), Suit(s.head))\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333390,"user_id":null,"body":"\nobject Poker {\n\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n    val cards = sort(holeCards ++ communityCards)\n    findStraightFlush(cards)\n      .orElse(findFourOfAKind(cards))\n      .orElse(findFullHouse(cards))\n      .orElse(findFlush(cards))\n      .orElse(findStraight(cards))\n      .orElse(findThreeOfAKind(cards))\n      .orElse(fidTwoPairs(cards))\n      .orElse(findPair(cards))\n      .getOrElse(nothing(cards))\n  }\n  def nothing(cards: List[String]) = {\n    (\"nothing\", ranks(cards))\n  }\n   def findPair(cards: List[String]) = {\n    kinds(cards)\n      .find(_.length == 2)\n      .map(pair => (\"pair\", ranks((pair ++ cards).distinct)))\n  }\n  def fidTwoPairs(cards: List[String]) = {\n    val pairs = kinds(cards).filter(_.length == 2)\n    for{\n      pair1 <- pairs.headOption\n      pair2 <- pairs.lift(1)\n    } yield (\"two pair\", ranks((pair1 ++ pair2 ++ cards).distinct))\n  }\n\n  def findThreeOfAKind(cards: List[String]) = {\n    kinds(cards)\n      .find(_.length == 3)\n      .map(four => (\"three-of-a-kind\", ranks((four ++ cards).distinct)))\n  }\n  def findStraight(cards: List[String]) = {\n    sequences(cards)\n      .find(_.length >= 5)\n      .map(_.take(5))\n      .map(cards => (\"straight\", ranks(cards)))\n  }\n  def findFlush(cards: List[String]) = {\n    colors(cards)\n      .find(_.length >= 5)\n      .map(_.take(5))\n      .map(cards => (\"flush\", ranks(cards)))\n  }\n\n  def findFullHouse(cards: List[String]) = {\n    val cardsByKind = kinds(cards)\n    for{\n      three <- cardsByKind.find(_.length == 3)\n      two <- cardsByKind.find(c => c.length >= 2 && c != three)\n    } yield (\"full house\", ranks(three ++ two))\n  }\n\n  def findFourOfAKind(cards: List[String]) = {\n    kinds(cards)\n      .find(_.length == 4)\n      .map(four => (\"four-of-a-kind\", ranks((four ++ cards).distinct)))\n  }\n\n  def kinds(cards: List[String]) =\n    cards.groupBy(_.head)\n      .values\n      .toList\n      .sortBy(k => rank(k.head)).reverse\n\n  def findStraightFlush(cards: List[String]) = {\n    coloredSequences(cards)\n      .find(_.length >= 5)\n      .map(_.take(5))\n      .map(cards => (\"straight-flush\", ranks(cards)))\n  }\n\n  private def ranks(cards: List[String]) = cards.take(5).map(_.init).distinct\n\n  private def coloredSequences(cards: List[String]) =\n    colors(cards).flatMap(sequences)\n\n  def colors(cards: List[String]) = {\n    cards.groupBy(_.last).values.toList\n  }\n\n  def sequences(cards: List[String]) = {\n    cards.foldRight(List[List[String]]()) {\n      case (card, (highest :: lowers) :: sequences) if rank(card) == rank(highest) + 1 =>\n        (card :: highest :: lowers) :: sequences\n      case (card, (highest :: lowers) :: sequences) if rank(card) == rank(highest) =>\n        (highest :: lowers) :: sequences\n      case (card, sequences) => (card :: Nil) :: sequences\n    }\n  }\n\n  def sort(cards: List[String]) = cards.sortBy(c => (rank(c), c.last)).reverse\n\n  def rank(card: String) = (card.head) match {\n    case 'A' => 14\n    case 'K' => 13\n    case 'Q' => 12\n    case 'J' => 11\n    case '1' => 10\n    case n => n.asDigit\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333391,"user_id":null,"body":"import Card.{CardListOps, CardListOptOps, CardMapOps, DisplayValue}\n\nobject Poker {\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n    val cards = (holeCards ++: communityCards).map(Card.fromString).orderByValue\n    val colorSets = cards.groupByColor\n    val valueSets = cards.groupByValue\n\n    def anotherSetOf2(other: List[Card]): Option[List[Card]] =\n      valueSets.exceptKey(other.head.value).ofSizeGt(2).map(other ++: _.slice(0, 2))\n\n    def finish(start: List[Card]): List[Card] = start :++ cards.filterNot(start contains _).slice(0, 5 - start.size)\n\n    \/\/ Test-driven development pushed to the next level. I had to find all the bloody strings in test cases.\n    colorSets.ofSizeGt(5).getStraightOpt.isA(\"straight-flush\")\n      .orElse(valueSets.of(4).map(finish).isA(\"four-of-a-kind\"))\n      .orElse(valueSets.of(3).flatMap(anotherSetOf2).isA(\"full house\"))\n      .orElse(colorSets.ofSizeGt(5).map(_.orderByValue.slice(0,5)).isA(\"flush\"))\n      .orElse(Some(cards).getStraightOpt.isA(\"straight\"))\n      .orElse(valueSets.of(3).map(finish).isA(\"three-of-a-kind\"))\n      .orElse(valueSets.of(2).flatMap(anotherSetOf2).map(finish).isA(\"two pair\"))\n      .orElse(valueSets.of(2).map(finish).isA(\"pair\"))\n      .getOrElse(Result(\"nothing\", cards.slice(0, 5)))\n      .toOutputFormat\n  }\n}\n\ncase class Card (value: Int, color: Char) {\n  def displayValue: String = DisplayValue(value - 2)\n  override def toString: String = \"$displayValue$color\"\n}\n\nobject Card {\n  val DisplayValue: List[String] = ('2' to '9').map(_.toString) ++: List(\"10\", \"J\", \"Q\", \"K\", \"A\")\n  val Ordinal: Map[String, Int] = DisplayValue.zip(2 to 14).toMap\n\n  def ordinal(card: String): Int = Ordinal(card.slice(0, card.length -1))\n\n  def color(card: String): Char = card(card.length - 1)\n\n  def fromString(str: String): Card = Card(ordinal(str), color(str))\n\n  implicit class CardListOps(list: List[Card]) {\n    def groupByColor: List[(Char, List[Card])] = list.groupBy(_.color).toList.sortBy(_._1).reverse\n    def groupByValue: List[(Int, List[Card])] = list.groupBy(_.value).toList.sortBy(_._1).reverse\n    def orderByValue: List[Card] = list.sortBy(_.value).reverse\n  }\n\n  implicit class CardListOptOps(list: Option[List[Card]]) {\n    def getStraightOpt: Option[List[Card]] = list.flatMap((l:List[Card]) =>\n      l.orderByValue.distinctBy(_.value).sliding(5).find(x => x.maxBy(_.value).value - x.minBy(_.value).value == 4))\n    def isA(text: String): Option[Result] = list.map(l => Result(text, l))\n  }\n\n  implicit class CardMapOps(map: List[(Any, List[Card])]) {\n    def values: Seq[List[Card]] = map.map(_._2)\n    def exceptKey(key: Any): List[(Any, List[Card])] = map.filterNot(_._1 == key)\n    def of(size: Int): Option[List[Card]] = values.find(_.size == size)\n    def ofSizeGt(size: Int): Option[List[Card]] = values.find(_.size >= size)\n\n  }\n}\n\ncase class Result(handValue: String, cards: List[Card]) {\n  def toOutputFormat: (String, List[String]) = (handValue, cards.map(_.displayValue).distinct)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333392,"user_id":null,"body":"\nobject Poker {\n  val suits = Array(\"\u2663\", \"\u2666\", \"\u2660\", \"\u2665\")\n  val ranks = Array(\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\")\n  def toRank(c: String): String = c.substring(0, c.length - 1)\n  def toRankValue(c: String): Int = ranks.indexOf(c.substring(0, c.length - 1))\n  def toSuit(c: String): String = c.substring(c.length - 1)\n  def toRanks(cs: List[String]): List[String] = cs.map(toRank)\n  def toSuits(cs: List[String]): List[String] = cs.map(toSuit)\n  def filterSuit(s: String, cs: List[String]): List[String] = cs.filter(toSuit(_) == s)\n  def filterRank(r: String, cs: List[String]): List[String] = cs.filter(toRank(_) == r)\n  def partRank(r: String, cs: List[String]): (List[String], List[String]) = cs.partition(toRank(_) == r)\n  def sortRank(cs: List[String]): List[String] = {\n    cs.sortWith((c1, c2) => {\n      val r1 = toRankValue(c1)\n      val r2 = toRankValue(c2)\n      r1 < r2\n    })\n  }\n  def sortRankHighToLow(cs: List[String]): List[String] = {\n    cs.sortWith((c1, c2) => {\n      val r1 = toRankValue(c1)\n      val r2 = toRankValue(c2)\n      r1 > r2\n    })\n  }\n\n  def isFlushStraight(cs: List[String]): Option[List[String]] = {\n    sortRankHighToLow(cs) match {\n      case s if s.length < 5 => None\n      case s if toRankValue(s(0)) - 4 == toRankValue(s(4)) => Some(s.take(5))\n      case s => isStraight(s.tail)\n    }\n  }\n\n  def isStraight(cs: List[String]): Option[List[String]] = {    \n    val sorted = sortRankHighToLow(cs)\n    sorted.distinctBy(toRank(_)) match {\n      case s if s.length < 5 => None\n      case s if toRankValue(s(0)) - 4 == toRankValue(s(4)) => Some(s.take(5))\n      case s => isStraight(s.tail)\n    }\n  }\n\n  def isStraightOrFlush(cs: List[String]): Option[(String, List[String])] = {\n    val sortedSuits: List[(String, List[String])] = cs.groupBy(toSuit).toList.sortBy(-_._2.length)\n    sortedSuits match {\n      case (_, flushLs) :: _ if flushLs.length >= 5 => \n        isFlushStraight(flushLs)\n          .map(cs => (\"straight-flush\", toRanks(cs)))\n          .orElse(Some(\"flush\", toRanks(sortRankHighToLow(flushLs).take(5))))\n      case _ => isStraight(cs).map(cs => (\"straight\", toRanks(cs)))\n    }\n  }\n\n  def isSameRanks(cs: List[String]): Option[(String, List[String])] = {\n    val sortedRanks: List[(String, List[String])] = cs.groupBy(toRank).toList.sortBy(-_._2.length)\n    sortedRanks match {\n      case (r1, ls1) :: _ if ls1.length >= 4 =>\n        val extraSameRank = if (ls1.length > 4) List(ls1.head) else Nil\n        val otherRank = toRank(sortRank(cs.filter(toRank(_) != r1) ++ extraSameRank).last)\n        Some((\"four-of-a-kind\", List(r1, otherRank)))\n\n      case (r1, ls1) :: (r2, ls2) :: (r3, ls3) :: _ if ls1.length >= 3 && ls2.length >= 2 && ls3.length >= 2 => \n        val threeRank = if (ls2.length == 2) r1 else if (toRankValue(r1) > toRankValue(r2)) r1 else r2\n        val twoRank = \n          if (ls2.length == 3) {\n            if (threeRank == r1) r2 else r1\n          } else {\n            if (toRankValue(r2) > toRankValue(r3)) r2 else r3\n          }\n        println((456, sortedRanks, toRankValue(r2), toRankValue(r3), toRankValue(r2) > toRankValue(r3), List(threeRank, twoRank)))\n        Some((\"full house\", List(threeRank, twoRank)))\n\n      case (r1, ls1) :: (r2, ls2) :: _ if ls1.length >= 3 && ls2.length >= 2 => \n        println((123, sortedRanks))\n        if (ls2.length == 2) {\n          Some((\"full house\", List(r1, r2)))\n        } else {\n          Some((\"full house\", toRanks(sortRankHighToLow(List(ls1.head, ls2.head)))))\n        }\n\n      case (r1, ls1) :: (r2, ls2) :: _ if ls1.length >= 3 && ls2.length < 2 => \n        val otherRanks = toRanks(sortRankHighToLow(cs.filter(!ls1.contains(_)))).take(2)\n        Some((\"three-of-a-kind\", r1 +: otherRanks))\n\n      case (r1, ls1) :: (r2, ls2) :: (r3, ls3) :: _ if ls1.length >= 2 && ls2.length >= 2 && ls3.length >= 2 => \n        val twoPairCards = sortRankHighToLow(List(ls1.head, ls2.head, ls3.head)).take(2)\n        val pairRanks = toRanks(twoPairCards)\n        var handWithoutPairs = cs.patch(cs.indexWhere(pairRanks(0) == toRank(_)), Nil, 1)\n        handWithoutPairs = handWithoutPairs.patch(handWithoutPairs.indexWhere(pairRanks(0) == toRank(_)), Nil, 1)\n        handWithoutPairs = handWithoutPairs.patch(handWithoutPairs.indexWhere(pairRanks(1) == toRank(_)), Nil, 1)\n        handWithoutPairs = handWithoutPairs.patch(handWithoutPairs.indexWhere(pairRanks(1) == toRank(_)), Nil, 1)\n        val otherRank = toRank(sortRankHighToLow(handWithoutPairs).head)\n        Some((\"two pair\", pairRanks :+ otherRank))\n\n      case (r1, ls1) :: (r2, ls2) :: _ if ls1.length >= 2 && ls2.length >= 2 => \n        val twoPairCards = sortRankHighToLow(List(ls1.head, ls2.head))\n        val pairRanks = toRanks(twoPairCards)\n        var handWithoutPairs = cs.patch(cs.indexWhere(pairRanks(0) == toRank(_)), Nil, 1)\n        handWithoutPairs = handWithoutPairs.patch(handWithoutPairs.indexWhere(pairRanks(0) == toRank(_)), Nil, 1)\n        handWithoutPairs = handWithoutPairs.patch(handWithoutPairs.indexWhere(pairRanks(1) == toRank(_)), Nil, 1)\n        handWithoutPairs = handWithoutPairs.patch(handWithoutPairs.indexWhere(pairRanks(1) == toRank(_)), Nil, 1)\n        val otherRank = toRank(sortRankHighToLow(handWithoutPairs).head)\n        Some((\"two pair\", pairRanks :+ otherRank))\n\n      case (r1, ls1) :: (r2, ls2) :: _ if ls1.length >= 2 && ls2.length < 2 => \n        val otherRanks = toRanks(sortRankHighToLow(cs.filter(c => !ls1.contains(c))).take(3))\n        Some((\"pair\", r1 +: otherRanks))\n\n      case _ => None\n    }\n  }\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n    val allCards = holeCards ++ communityCards\n    isStraightOrFlush(allCards).orElse(isSameRanks(allCards))\n      .getOrElse((\"nothing\", toRanks(sortRank(allCards)).reverse.take(5)))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333393,"user_id":null,"body":"object Poker {\n  private val pic2Num = Map(\"J\" -> 11, \"Q\" -> 12, \"K\" -> 13, \"A\" -> 14)\n  private val num2Pic = Map(11 -> \"J\", 12 -> \"Q\", 13 -> \"K\", 14 -> \"A\")\n  private val signEncode = Map(\"\u2660\" -> 0, \"\u2666\" -> 1, \"\u2665\" -> 2, \"\u2663\" -> 3)\n\n  private def parseInput(in: String): (Int, Int) = (pic2Num.getOrElse(in.dropRight(1), in.dropRight(1).toInt), signEncode(in.takeRight(1)))\n  private def decode(in: Int): String = num2Pic.getOrElse(in, in.toString)\n\n  private def findStraightFlush(in: List[(Int, Int)]): (Boolean, Option[(String, List[String])]) = {\n    val flash = findFlush(in)\n    if (flash._1){\n      val straight = findStraight(flash._2.get._2)\n      if (straight._1) (true, Some(\"straight-flush\", straight._2.get._2)) else (false, None)\n    } else (false, None)\n  }\n\n  private def findStraight(in: List[Int]): (Boolean, Option[(String, List[String])]) = {\n    def checkSlice(slice: List[Int]): (Boolean, Option[(String, List[String])]) = {\n      if(slice.head - slice(4) == 4 && slice.toSet.size == 5) (true, Some(\"straight\", slice.map(decode))) else (false, None)\n    }\n    val candidate = in.toSet.toList.sorted.reverse.padTo(7, -1)\n    lazy val slice1 = checkSlice(candidate.slice(0, 5))\n    lazy val slice2 = checkSlice(candidate.slice(1, 6))\n    lazy val slice3 = checkSlice(candidate.slice(2, 7))\n    if(slice1._1) return slice1\n    if(slice2._1) return slice2\n    if(slice3._1) return slice3\n    (false, None)\n  }\n\n  private def findFlush(in: List[(Int, Int)]): (Boolean, Option[(String, List[Int])]) = {\n    in.groupBy(_._2).values.find(_.length >= 5).getOrElse(List()) match {\n      case Nil => (false, None)\n      case list => (true, Some(\"flush\", list.map(_._1)))\n    }\n  }\n  private def reduceFlush(in: List[Int]): (String, List[String]) = {\n    (\"flush\", in.sorted.reverse.slice(0, 5).map(decode))\n  }\n\n  private def findCountCombo(in: List[Int]): (Boolean, Option[(String, List[String])]) = {\n    def takeTopNotEqual(not: Set[Int], n: Int): List[Int] = {\n      in.toSet.diff(not).toList.sorted.reverse.take(n)\n    }\n    val cnt2Card = in.groupBy(identity).mapValues(elem => elem.size).groupMap(_._2)(_._1)\n    if (cnt2Card.keys.toSet.contains(4)) {\n      val f = cnt2Card(4).head\n      return (true, Some(\"four-of-a-kind\", (List(f) ++ takeTopNotEqual(Set(f), 1)).map(decode)))\n    }\n    if (cnt2Card.keys.toSet.contains(3) && cnt2Card.keys.toSet.contains(2)) {\n      val t = cnt2Card(2).max\n      val th = cnt2Card(3).head\n      return (true, Some(\"full house\", List(th, t).map(decode)))\n    }\n    if (cnt2Card.keys.toSet.contains(3)) {\n      val th = cnt2Card(3)\n      if (th.toSeq.length == 1) {\n        val v = th.head\n        return (true, Some(\"three-of-a-kind\", (List(v) ++ takeTopNotEqual(Set(v), 2)).map(decode)))\n      } else {\n        return (true, Some(\"full house\", th.toList.sorted.reverse.slice(0, 5).map(decode)))\n      }\n    }\n    if (cnt2Card.keys.toSet.contains(2)) {\n      val t = cnt2Card(2)\n      if (t.toSeq.length == 1) {\n        val v = t.head\n        return (true, Some(\"pair\", (List(v) ++ takeTopNotEqual(Set(v), 3)).map(decode)))\n      } else {\n        val leaders = t.toList.sorted.reverse.slice(0, 2)\n        return (true, Some(\"two pair\", (leaders ++ takeTopNotEqual(leaders.toSet, 1)).map(decode)))\n      }\n    }\n    (false, None)\n  }\n\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n    val parsedInput = (holeCards ++ communityCards).map(parseInput)\n    lazy val sf = findStraightFlush(parsedInput)\n    lazy val f = findFlush(parsedInput)\n    lazy val s = findStraight(parsedInput.map(_._1))\n    lazy val cc = findCountCombo(parsedInput.map(_._1))\n    if (sf._1) return sf._2.get\n    if (cc._1 && Set(\"full house\", \"four-of-a-kind\").contains(cc._2.get._1)) return cc._2.get\n    if (f._1) return reduceFlush(f._2.get._2)\n    if (s._1) return s._2.get\n    if (cc._1) return cc._2.get\n    (\"nothing\", parsedInput.map(_._1).sorted.reverse.slice(0, 5).map(decode))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333394,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject Poker {\n  private var cards : ListBuffer[(Integer,String)] = ListBuffer()\n  private var cardValues : ListBuffer[Integer] = ListBuffer()\n  private var cardTypes : ListBuffer[String] = ListBuffer()\n\n  private var hasStreak = false\n  private var streakValues : ListBuffer[Integer] = ListBuffer()\n\n  def clean(): Unit = {\n    cards.clear()\n    cardValues.clear()\n    cardTypes.clear()\n    streakValues.clear()\n    hasStreak = false\n  }\n\n  def parseCards(allCards: List[String]): Unit = {\n    for (card <- allCards) {\n      val index = card.length - 1\n      val valueOfCard = card.substring(0,index)\n      val value = valueOfCard match {\n        case \"J\" => 11\n        case \"Q\" => 12\n        case \"K\" => 13\n        case \"A\" => 14\n        case _ => Integer.parseInt(valueOfCard)\n      }\n      val typeOfCard = card.substring(index)\n      cards = cards:+((value,typeOfCard))\n      cardValues = cardValues:+value\n      cardTypes = cardTypes:+typeOfCard\n    }\n\n    cards = cards.sortBy((x: (Integer,String)) => x._1).reverse\n  }\n\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n    clean()\n\n    parseCards(holeCards.appendedAll(communityCards))\n\n    val isSF = isStraightFlush\n    if (isSF._1) return (\"straight-flush\", isSF._2)\n\n    val isFour = isFourOfAKind\n    if (isFour._1) return (\"four-of-a-kind\", isFour._2)\n\n    val isFH = isFullHouse\n    if (isFH._1) return (\"full house\", isFH._2)\n\n    val isF = isFlush\n    if (isF._1) return (\"flush\", isF._2)\n\n    val isS = isStraight\n    if (isS._1) return (\"straight\", isS._2)\n\n    val isT = isThree\n    if (isT._1) return (\"three-of-a-kind\", isT._2)\n\n    val isTP = isTwoPair\n    if (isTP._1) return (\"two pair\", isTP._2)\n\n    val isP = isPair\n    if (isP._1) return (\"pair\", isP._2)\n\n    (\"nothing\", formatEmpty())\n  }\n\n  def isStraight: (Boolean, List[String]) = {\n    var previous: Integer = 0\n    var counter: Integer = 1\n    for (value <- cardValues.sortBy((x: Integer) => x).reverse.distinct) {\n      if (previous != 0 && previous - 1 == value) {\n        counter = counter + 1\n      } else {\n        counter = 1\n        streakValues.clear()\n      }\n\n      streakValues = streakValues:+value\n      if (counter == 5) {\n        return (true, formatStraight(streakValues))\n      }\n      previous = value\n    }\n\n    (false, formatStraight(streakValues))\n  }\n\n  def formatStraight(cards: ListBuffer[Integer]): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n    for (card <- cards) {\n      formattedCards.addOne(formatValue(card))\n    }\n    formattedCards.toList\n  }\n\n  def isStraightFlush: (Boolean, List[String]) = {\n    val streakCards : ListBuffer[(Integer,String)] = ListBuffer()\n\n    val sortedCards = cards.sortBy((x: (Integer,String)) => x._1).reverse\n    for (card <- sortedCards) {\n      streakCards.clear()\n      streakCards.addOne(card._1, card._2)\n      if (hasNext(card._1, card._2, 1, streakCards)) {\n        return (true, formatStraightFlush(streakCards))\n      }\n    }\n\n    (false, formatStraightFlush(streakCards))\n  }\n\n  def hasNext(cardVal: Integer, cardType: String, count: Integer, streakCards: ListBuffer[(Integer,String)]): Boolean = {\n    var counter = count\n    if (count == 5)\n      return true\n    for (card <- cards) {\n      if (card._1 == cardVal - 1 && card._2.equals(cardType)) {\n        counter = counter + 1\n        streakCards.addOne(card._1, card._2)\n        if (hasNext(card._1, cardType, counter, streakCards)) {\n          return true\n        }\n      }\n    }\n    streakCards.clear()\n    false\n  }\n\n  def formatStraightFlush(cards: ListBuffer[(Integer,String)]): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n    for (card <- cards) {\n      formattedCards.addOne(formatValue(card._1))\n    }\n    formattedCards.toList\n  }\n\n  def formatStreat(values: ListBuffer[Integer]): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n    for (value <- values) {\n      formattedCards.addOne(formatValue(value))\n    }\n    formattedCards.toList\n  }\n\n\n  def isFourOfAKind: (Boolean, List[String]) = {\n    var counter = 0\n    for (index <- cards.indices) {\n      val value = cards(index)._1\n      counter = 1\n      for (i <- cards.indices) {\n        if (i != index && value == cards(i)._1) {\n          counter = counter + 1\n          if (counter == 4) {\n            return (true, formatFourOfAKind(value))\n          }\n        }\n      }\n    }\n\n    (false, List())\n  }\n\n  def formatFourOfAKind(four: Integer): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n    \n    formattedCards.addOne(formatValue(four))\n    for (card <- cards) {\n      if (card._1 != four) {\n        formattedCards.addOne(formatValue(card._1))\n        return formattedCards.toList\n      }\n    }\n    formattedCards.toList\n  }\n\n\n    def isFullHouse: (Boolean, List[String]) = {\n    var threeValue: Integer = 0\n    var twoValue: Integer = 0\n\n    var counter = 0\n    for (index <- cards.indices) {\n      val value = cards(index)._1\n      counter = 1\n      for (i <- cards.indices) {\n        if (i != index && value == cards(i)._1) {\n          counter = counter + 1\n          if (counter == 3) {\n            threeValue = value\n            if (twoValue == value) {\n              twoValue = 0\n            }\n          }\n          if (counter == 2 && threeValue != value && twoValue == 0) {\n            twoValue = value\n          }\n          if (twoValue != 0 && threeValue !=0) {\n            return (true, formatFullHouse(threeValue, twoValue))\n          }\n        }\n      }\n    }\n    (false, List())\n  }\n\n  def formatFullHouse(three: Integer, two: Integer): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n\n    formattedCards.addOne(formatValue(three))\n    formattedCards.addOne(formatValue(two))\n\n    formattedCards.toList\n  }\n\n\n  def isFlush: (Boolean, List[String]) = {\n    val streakCards : ListBuffer[(Integer,String)] = ListBuffer()\n\n    val sortedCards = cards.sortBy((x: (Integer,String)) => x._1).reverse\n    for (index <- sortedCards.indices) {\n      val card = sortedCards(index)\n      streakCards.clear()\n      streakCards.addOne(card._1, card._2)\n      for (id <- (index + 1) until sortedCards.length) {\n        if (sortedCards(id)._2.equals(card._2)) {\n          streakCards.addOne(sortedCards(id)._1, card._2)\n        }\n        if (streakCards.length == 5) {\n          return (true, formatStraightFlush(streakCards))\n        }\n      }\n    }\n\n    (false, formatStraightFlush(streakCards))\n  }\n\n\n  def isThree: (Boolean, List[String]) = {\n    var threeValue: Integer = 0\n\n    var counter: Integer = 0\n    for (index <- cards.indices) {\n      val value = cards(index)._1\n      counter = 1\n      for (i <- cards.indices) {\n        if (i != index && value == cards(i)._1) {\n          counter = counter + 1\n          if (counter == 3) {\n            threeValue = value\n            return (true, formatThree(threeValue))\n          }\n        }\n      }\n    }\n    (false, List())\n  }\n\n  def formatThree(three: Integer): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n\n    formattedCards.addOne(formatValue(three))\n\n    var counter: Integer = 0\n    for (card <- cards) {\n      if (card._1 != three) {\n        formattedCards.addOne(formatValue(card._1))\n        counter = counter + 1\n      }\n      if (counter == 2) {\n        return formattedCards.toList\n      }\n    }\n\n    formattedCards.toList\n  }\n\n\n  def isTwoPair: (Boolean, List[String]) = {\n    var firstValue: Integer = 0\n    var secondValue: Integer = 0\n\n    var counter = 0\n    for (index <- cards.indices) {\n      val value = cards(index)._1\n      counter = 1\n      for (i <- cards.indices) {\n        if (i != index && value == cards(i)._1) {\n          counter = counter + 1\n          if (counter == 2 && firstValue == 0) {\n            firstValue = value\n            counter = 0\n          }\n          if (counter == 2 && firstValue != value) {\n            secondValue = value\n          }\n          if (secondValue != 0 && firstValue !=0) {\n            return (true, formatTwoPair(firstValue, secondValue))\n          }\n        }\n      }\n    }\n    (false, List())\n  }\n\n  def formatTwoPair(first: Integer,second: Integer): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n\n    formattedCards.addOne(formatValue(first))\n    formattedCards.addOne(formatValue(second))\n\n    var counter: Integer = 0\n    for (card <- cards) {\n      if (card._1 != first && card._1 != second) {\n        formattedCards.addOne(formatValue(card._1))\n        counter = counter + 1\n      }\n      if (counter == 1) {\n        return formattedCards.toList\n      }\n    }\n\n    formattedCards.toList\n  }\n\n  def isPair: (Boolean, List[String]) = {\n    var firstValue: Integer = 0\n\n    var counter = 0\n    for (index <- cards.indices) {\n      val value = cards(index)._1\n      counter = 1\n      for (i <- cards.indices) {\n        if (i != index && value == cards(i)._1) {\n          counter = counter + 1\n          if (counter == 2) {\n            firstValue = value\n          }\n          if (firstValue != 0) {\n            return (true, formatPair(firstValue))\n          }\n        }\n      }\n    }\n    (false, List())\n  }\n\n  def formatPair(first: Integer): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n\n    formattedCards.addOne(formatValue(first))\n\n    var counter: Integer = 0\n    for (card <- cards) {\n      if (card._1 != first) {\n        formattedCards.addOne(formatValue(card._1))\n        counter = counter + 1\n      }\n      if (counter == 3) {\n        return formattedCards.toList\n      }\n    }\n\n    formattedCards.toList\n  }\n\n  def formatEmpty(): List[String] = {\n    val formattedCards : ListBuffer[String] = ListBuffer()\n\n    var counter: Integer = 0\n    for (card <- cards) {\n      formattedCards.addOne(formatValue(card._1))\n      counter = counter + 1\n\n      if (counter == 5) {\n        return formattedCards.toList\n      }\n    }\n\n    formattedCards.toList\n  }\n\n\n  def formatValue(value: Integer): String = {\n    var result = \"\"\n    if (value == 11) result = \"J\"\n    else if (value == 12) result = \"Q\"\n    else if (value == 13) result = \"K\"\n    else if (value == 14) result = \"A\"\n    else result = value.toString\n    result\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333395,"user_id":null,"body":"import scala.math.Ordering.Implicits.seqOrdering\n\nobject Poker {\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n    def isStraight(h: List[(Int, Char)]): Boolean = (h.maxBy(_._1)._1 - h.minBy(_._1)._1 == h.length - 1) && h.map(_._1).distinct.length == 5\n\n    def isFlush(h: List[(Int, Char)]): Boolean = h.groupBy(_._2).size == 1\n\n    def isGroupSizes(h: List[(Int, Char)], s: Seq[Int]): Boolean = h.groupBy(_._1).values.map(_.length).toList.sorted == s\n\n    def distinctByCount(h: List[(Int, Char)]): List[Int] =\n      h.groupBy(_._1).toList.sortBy(g => (g._2.length, g._1))(Ordering.Tuple2(Ordering.Int.reverse, Ordering.Int.reverse)).map(_._1)\n\n    val stringToValue = Map(\"J\" -> 11, \"Q\" -> 12, \"K\" -> 13, \"A\" -> 14).withDefault(_.toInt)\n    val valueToString = stringToValue.map(_.swap).withDefault(_.toString)\n    val types: Seq[(String, List[(Int, Char)] => Boolean)] = Seq(\n      (\"straight-flush\", h => isStraight(h) && isFlush(h)),\n      (\"four-of-a-kind\", h => isGroupSizes(h, Seq(1, 4))),\n      (\"full house\", h => isGroupSizes(h, Seq(2, 3))),\n      (\"flush\", h => isFlush(h)),\n      (\"straight\", h => isStraight(h)),\n      (\"three-of-a-kind\", h => isGroupSizes(h, Seq(1, 1, 3))),\n      (\"two pair\", h => isGroupSizes(h, Seq(1, 2, 2))),\n      (\"pair\", h => isGroupSizes(h, Seq(1, 1, 1, 2))),\n      (\"nothing\", _ => true)\n    )\n    val combos: List[List[(Int, Char)]] = (holeCards ++ communityCards).map(c => (stringToValue(c.dropRight(1)), c.last)).combinations(5).toList\n    val (name, hands) = types.map { case (handTypeName, isHandType) => (handTypeName, combos.filter(isHandType)) }.filter(_._2.nonEmpty).head\n    (name, hands.map(distinctByCount).max.map(valueToString(_)))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333396,"user_id":468,"body":"object Poker {\n\n  private lazy val order = List(\"A\", \"K\", \"Q\", \"J\") ::: (10 to 2 by -1).map(_.toString).toList \/\/ Ace-Hogh order\n\n  def hand(holeCards: List[String], communityCards: List[String]): (String, List[String]) = {\n\n    lazy val split = (holeCards ::: communityCards).map(s => (s.dropRight(1), s.last)) \/\/ Splits the string into face and suit\n    lazy val faces = split.map(_._1)\n    lazy val byFace = faces.groupBy(identity).map {\n      case (suit, cards) => (suit, cards.length) \/\/ count occurences by face\n    }\n\n    \/**\n     * Helper function. Picks the best kicker cards from faces, excluding specific cards\n     *\n     * @param exclude List of Faces to exclude\n     * @param count   The number of kicker cards required\n     * @return List of best kicker cards\n     *\/\n    def pickKicker(exclude: List[String], count: Int): List[String] = {\n      if (count == 1) List(faces.filterNot(exclude.contains).minBy(order.indexOf))\n      else faces.filterNot(exclude.contains).sortBy(order.indexOf).take(count)\n    }\n\n    lazy val flush =\n      split.groupBy(_._2) \/\/ group by suit\n        .find(_._2.length > 4)\n        .map(_._2.map(_._1).sortBy(order.indexOf)) \/\/ sort by face value\n\n    lazy val quads = byFace.find(_._2 == 4).map {\n      case (face, _) => face :: pickKicker(face :: Nil, 1) \/\/ pick highest kicker\n    }\n\n    lazy val trips = byFace.filter(_._2 == 3).keys.toList.sortBy(order.indexOf) \/\/ atmost 2 trips\n\n    lazy val pairs = byFace.filter(_._2 == 2).keys.toList.sortBy(order.indexOf) \/\/ atmost 3 pairs\n\n    lazy val fullHouse = (trips, pairs) match {\n      case (trip :: Nil, pair :: _) => Some(trip :: pair :: Nil) \/\/ one three-of-a-kind + atleast one pair\n      case (_ :: _ :: Nil, Nil) => Some(trips) \/\/ two trips: smaller of the two trips is considered a pair\n      case _ => None\n    }\n\n    lazy val straight = containsStraight(faces)\n\n    lazy val straightFlush = flush flatMap containsStraight\n\n\n    straightFlush.map((\"straight-flush\", _))\n      .orElse(quads.map((\"four-of-a-kind\", _)))\n      .orElse(fullHouse.map((\"full house\", _)))\n      .orElse(flush.map(x => (\"flush\", x.take(5))))\n      .orElse(straight.map((\"straight\", _)))\n      .getOrElse {\n        (trips, pairs) match {\n          case (trip :: Nil, _) => (\"three-of-a-kind\", trip :: pickKicker(trip :: Nil, 2))\n          case (Nil, first :: second :: _) => (\"two pair\", first :: second :: pickKicker(pairs.take(2), 1)) \/\/ 1 kicker\n          case (Nil, pair :: Nil) => (\"pair\", pair :: pickKicker(pair :: Nil, 3)) \/\/ three kickers\n          case _ => (\"nothing\", faces.sortBy(order.indexOf).take(5)) \/\/ best 5\n        }\n      }\n  }\n\n  \/**\n   * Checks if a straight exists in the given list of faces\n   *\n   * @param faces The list of face values\n   * @return An Optional List of the highest possible 5-card straight\n   *\/\n  private def containsStraight(faces: List[String]): Option[List[String]] = {\n    \/**\n     * Tail recursive helper function.\n     * The input list is sorted and does not have repeats\n     * At every iteration, checks if the first two face values are in sequence\n     * If so, adds the first card to a running accumulator, and return it with the next card when it reaches length 4\n     *\n     * @param faces List of sorted unique faces\n     * @param acc   accumulator list\n     * @return Optional List of highest possible straigh\n     *\/\n    @scala.annotation.tailrec\n    def check(faces: List[String], acc: List[String]): Option[List[String]] =\n      if (acc.length == 4) Some(acc appended faces.head) \/\/ 4 cards have next card in sequence. i.e, we have a straight\n      else if (faces.size == 1) None \/\/ if we have only one card left, and running sequence < 4, we can't form a straight\n      else if (order.indexOf(faces(1)) - order.indexOf(faces.head) == 1) check(faces.tail, acc appended faces.head)\n      else check(faces.tail, Nil) \/\/ reset the accumulator, if the sequence breaks\n\n\n    check(faces.sortBy(order.indexOf).distinct, Nil)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"525f50e3b73515a6db000b83":[{"id":333397,"user_id":527,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = {\n    \"(%d%d%d) %d%d%d-%d%d%d%d\".format(numbers:_*)\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333398,"user_id":null,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = {\n    s\"(${numbers.take(3).mkString}) ${numbers.slice(3,6).mkString}-${numbers.drop(6).mkString}\"\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333399,"user_id":null,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = {\n    \"(\" + numbers.slice(0,3).mkString+ \") \"+ numbers.slice(3,6).mkString+ \"-\" + numbers.slice(6,10).mkString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333400,"user_id":573,"body":"object Kata {\n\n  def create_phone_number(numbers: Seq[Int]) = {\n    val ns = numbers.mkString\n    s\"(${ns.take(3)}) ${ns.slice(3, 6)}-${ns.drop(6)}\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333401,"user_id":null,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = numbers match {\n    case a::b::c::d::e::f::rest => s\"($a$b$c) $d$e$f-${rest.mkString}\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333402,"user_id":null,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = {\n    numbers.mkString(\"\").replaceFirst(\"(\\\\d{3})(\\\\d{3})(\\\\d+)\", \"($1) $2-$3\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333403,"user_id":null,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = {\n    numbers.take(3).mkString(\"(\",\"\",\")\").concat(numbers.slice(3, 6).mkString(\" \",\"\",\"-\")).concat(numbers.slice(6,numbers.size).mkString(\"\"))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333404,"user_id":null,"body":"object Kata {\n  def create_phone_number(numbers: Seq[Int]) = {\n    val (left, right) = numbers.mkString(\"\").splitAt(3)\n    \"(\" + left + \") \" + right.patch(3, \"-\", 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333405,"user_id":null,"body":"object Kata \n  def create_phone_number: Seq[Int] => String = n => \"(%d%d%d) %d%d%d-%d%d%d%d\".format(n:_*)\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333406,"user_id":53,"body":"object Kata {\n  def create_phone_number(n: Seq[Int]): String = {\n    return s\"(${n(0)}${n(1)}${n(2)}) ${n(3)}${n(4)}${n(5)}-${n(6)}${n(7)}${n(8)}${n(9)}\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5264d2b162488dc400000001":[{"id":333407,"user_id":null,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n    sentence.split(\" \").map(x => if ( x.size >= 5 ) x.reverse else x).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333408,"user_id":573,"body":"object Codewars {\n\n  def spin_words(sentence: String): String =\n    sentence\n      .split(\" \")\n      .collect {\n        case word if word.size >= 5 => word.reverse\n        case word                   => word\n      }\n      .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333409,"user_id":527,"body":"object Codewars {\n  val spin_words = raw\"\\w{5,}\".r.replaceAllIn(_: String, _.matched.reverse)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333410,"user_id":null,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n    sentence.split(\" \").map {\n      case w if w.length < 5 => w\n      case w => w.reverse\n    }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333411,"user_id":null,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n    sentence.split(' ').map(a => if(a.length >4) a.reverse else a).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333412,"user_id":null,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n   val a = sentence.split(\" \").map(x=>if(x.length>=5) x.reverse else x)\n    a.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333413,"user_id":null,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n    sentence.split(\" \").map(w => if(w.size < 5) w else w.reverse).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333414,"user_id":null,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n  val a = new StringBuilder\n  sentence.split(\" \").foreach(\n    word=>\n      if(word.length>4) a.append(word.reverse+\" \")\n      else a.append(word+\" \"))\n  \n  a.toString.trim\n}\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333415,"user_id":468,"body":"object Codewars {\n  def spin_words(sentence: String): String = {\n  sentence.split(\" \").map(f => {\n        if (f.length > 4) f.reverse else f\n      }).reduce(_ + \" \" + _).trim\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333416,"user_id":null,"body":"object Codewars {\n  def spin_words(s: String): String = s.split(' ').map(x =>  if (x.length > 4) x.reverse else x).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5265326f5fda8eb1160004c8":[{"id":333417,"user_id":573,"body":"object Kata {\n\n  def number_to_string(n: Int): String =\n    n.toString\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333418,"user_id":527,"body":"object Kata {\n  def number_to_string(n: Int): String = s\"$n\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333419,"user_id":527,"body":"object Kata {\n  def number_to_string = String.valueOf(_: Int)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333420,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject Kata {\n\n  def number_to_string(n: Int): String = {\n    val offset = '0'.toInt\n    val isneg = n < 0\n    var nn = n.abs\n    val tmp0 = ListBuffer[Int]()\n    if (nn == 0) {tmp0.insert(0,0)}\n    while(0 < nn ) {\n      val tmp = nn % 10\n      tmp0.insert(0,tmp)\n      nn = nn \/ 10\n    }\n\n    (if (isneg) {('-' +  (_ : String))} else {identity(_ : String )})  (tmp0.map(x => (x + offset).toChar).mkString)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333421,"user_id":null,"body":"object Kata {\n\n  def number_to_string(n: Int): String = { \n   \n    val result = n.toString()\n\n    return result\n   \n  }\n\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333422,"user_id":null,"body":"object Kata {\n\n  def number_to_string(n: Int): String= {\n    return n.toString(); \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333423,"user_id":null,"body":"object Kata {\n\n  def number_to_string(n: Int): String = String.valueOf(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333424,"user_id":null,"body":"object Kata {\n\n  def number_to_string(n: Int): String = n.toString\n  \n  print(number_to_string(5))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333425,"user_id":null,"body":"object Kata {\n\n  def number_to_string(n: Int): String = \"%d\".format(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333426,"user_id":null,"body":"object Kata {\n\n  def number_to_string(n: Int): String = Integer.toString(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"526571aae218b8ee490006f4":[{"id":333427,"user_id":527,"body":"object Kata {\n  def count_bits(n: Int): Int = Integer.bitCount(n)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333428,"user_id":573,"body":"object Kata {\n\n  def count_bits(n: Int): Int = n.toBinaryString.count(_ == '1')\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333429,"user_id":null,"body":"object Kata {\n\n  def count_bits(n: Int): Int = {\n    if (n == 0) 0\n    else (n & 1) + count_bits(n >> 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333430,"user_id":null,"body":"object Kata {\n  def count_bits(n: Int): Int = n.toBinaryString.filter(_ != '0').size\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333431,"user_id":null,"body":"object Kata {\n  def count_bits(n: Int): Int = {\n    def loop(count: Int, num: Int): Int = num match {\n      case 0 => count\n      case _ => loop(count + (num & 1), num >>> 1)\n    }\n    \n    loop(0, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333432,"user_id":null,"body":"object Kata {\n\n  def count_bits(n: Int): Int = {\n    if (n == 0) 0\n    else {\n      count_bits(n\/2) + (if (n % 2 == 1) 1 else 0)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333433,"user_id":null,"body":"object Kata {\n\n  def count_bits(n: Int) = n.toBinaryString.count(_ == '1')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333434,"user_id":null,"body":"object Kata {\n\n  def count_bits(n: Int): Int = n.toBinaryString.toList.map(e => e.toString.toInt).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333435,"user_id":null,"body":"object Kata {\n\n  \n  def count_bits(n: Int): Int = n match {\n    case 0 => 0\n    case n1 => n1 % 2 + count_bits(n \/ 2)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333436,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n\n  @tailrec\n  def count_bits(n: Int, numOfOnes: Int = 0): Int = {\n    n match {\n      case it if it <= 0      => numOfOnes\n      case it if it % 2 == 1  => count_bits(n >> 1, numOfOnes + 1)\n      case _                  => count_bits(n >> 1, numOfOnes )\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"526c7363236867513f0005ca":[{"id":333437,"user_id":573,"body":"object Solution {\n\n  def isLeap(year: Int): Boolean =\n    java.time.Year.parse(year.toString).isLeap\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333438,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = if (year % 400 == 0) true else (if (year % 100 == 0) false else (if (year % 4 == 0) true else false))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333439,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = (year % 4, year % 100, year % 400) match {\n    case (_, _, 0) => true\n    case (_, 0, _) => false\n    case (0, y, _) if y != 0 => true\n    case (_, _, _) => false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333440,"user_id":null,"body":"object Solution{\n  def isLeap(n: Int): Boolean = (((n%4==0) && (n%100!=0)) || (n%400==0))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333441,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = if( (year % 4 == 0 && year % 100 != 0) || year % 400 == 0) true else false\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333442,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = \n    if ( year % 100 == 0 && (year \/ 100) % 4 != 0)\n      false\n    else \n      if ( year % 4 == 0 && year % 400 == 0)\n        true\n      else\n        if ( year % 4 == 0 )\n          true\n        else false\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333443,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = java.time.Year.isLeap(year)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333444,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = year match {\n    case _ if year % 400 == 0 => true\n    case _ if year % 100 == 0  => false\n    case _ if year % 4 == 0 => true\n    case _ => false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333445,"user_id":null,"body":"object Solution{\n  def isLeap(y: Int): Boolean = (y % 400, y % 100, y % 4) match {\n    case (0, _, _) => true\n    case (_, 0, _) => false\n    case (_, _, 0) => true\n    case _ => false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333446,"user_id":null,"body":"object Solution{\n  def isLeap(year: Int): Boolean = \n       if(year % 400 == 0) true\n  else if(year % 100 == 0) false\n  else    year % 4   == 0\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"52742f58faf5485cae000b9a":[{"id":333447,"user_id":573,"body":"object HumanTime {\n\n  def format_duration(seconds: Int): String =\n    (List((\"year\", 31536000, 100000), (\"day\", 86400, 365), (\"hour\", 3600, 24), (\"minute\", 60, 60), (\"second\", 1, 60))\n      .map {\n        case (unit, duration, modulo) => (seconds \/ duration % modulo, unit)\n      }\n      .collect {\n        case (duration, unit) if duration == 1 => s\"$duration $unit\"\n        case (duration, unit) if duration != 0 => s\"$duration ${unit}s\"\n      })\n      match {\n        case Nil => \"now\"\n        case List(single) => single\n        case list => s\"${list.init.mkString(\", \")} and ${list.last}\"\n      }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333448,"user_id":null,"body":"object HumanTime {\n\n  def format_duration(seconds: Int): String = {\n\n    def formatUnit(num: Int, unit: String) = {\n      if (num == 0) \"\" else if (num == 1) s\"1 $unit\" else  s\"$num ${unit}s\"\n    }\n\n    val years = formatUnit(seconds \/ 31536000, \"year\")\n    val days = formatUnit((seconds % 31536000) \/ 86400, \"day\")\n    val hours = formatUnit(((seconds % 31536000) % 86400) \/ 3600, \"hour\")\n    val mins = formatUnit((((seconds % 31536000) % 86400) % 3600) \/ 60, \"minute\")\n    val secs = formatUnit((((seconds % 31536000) % 86400) % 3600) % 60, \"second\")\n\n    List(years, days, hours, mins, secs).filter(s => s != \"\") match {\n      case Nil => \"now\"\n      case List(single) => single\n      case list => s\"${list.init.mkString(\", \")} and ${list.last}\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333449,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\n\nobject HumanTime {\n\n  def format_duration(seconds: Int): String = {\n    val minuteUnit = 60\n    val hourUnit = minuteUnit * 60\n    val dayUnit = hourUnit * 24\n    val yearUnit = dayUnit * 365\n\n    var sec = seconds\n\n    val ans = List(yearUnit, dayUnit, hourUnit, minuteUnit, 1)\n      .foldLeft(ListBuffer.empty[Int])((s, e) => {\n        s += sec \/ e\n        sec -= s.last * e\n        s\n      })\n      .zip(List(\"year\", \"day\", \"hour\", \"minute\", \"second\"))\n      .filter(_._1 != 0)\n      .map {\n        case (1, u) => s\"1 $u\"\n        case (t, u) => s\"$t $u\" + \"s\"\n      }\n    if (ans.nonEmpty) ans.init.mkString(\", \") + (if (ans.init.nonEmpty) \" and \" else \"\") + ans.last\n    else \"now\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333450,"user_id":null,"body":"object HumanTime {\n\n  case class Component(value: Int, rest: List[String])\n  \n  def pluralStr(value: Int, str: String): String = value match {\n    case 1 => s\"$value $str\"\n    case _ => s\"$value ${str}s\"\n  }\n  \n  def makeUnitComponent(size: Int, unitName: String) =\n    (input: Component) => input.value match {\n      case x if x % size != 0 => new Component(\n          input.value \/ size,\n          pluralStr(x % size, unitName) :: input.rest\n        )\n      case _ => new Component(input.value \/ size, input.rest)\n    }\n  \n  def format_duration(seconds: Int): String = {\n    val componentFns = List(\n      makeUnitComponent(60, \"second\"),\n      makeUnitComponent(60, \"minute\"),\n      makeUnitComponent(24, \"hour\"),\n      makeUnitComponent(365, \"day\"),\n      makeUnitComponent(Int.MaxValue, \"year\")\n    )\n    \n    val result = componentFns.foldLeft(new Component(seconds, Nil)) {\n      case (acc, fn) => fn(acc)\n    }.rest\n    \n    result.length match {\n      case 0 => \"now\"\n      case 1 => result.head\n      case _ => {\n        val left = result.dropRight(1).mkString(\", \")\n        val right = result.takeRight(1).head\n        s\"$left and $right\"\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333451,"user_id":null,"body":"object HumanTime {\n\n  def format_duration(seconds: Int): String = {\n    if(seconds == 0) return \"now\"\n    val years = (seconds \/ 31536000, \"year\")\n    val days = ((seconds % 31536000) \/ 86400, \"day\")\n    val hours = (((seconds % 31536000) % 86400) \/ 3600, \"hour\")\n    val minutes = ((((seconds % 31536000) % 86400) % 3600) \/ 60, \"minute\")\n    val seconds1 = ((((seconds % 31536000) % 86400) % 3600) % 60, \"second\")\n    val s = List(years, days, hours, minutes, seconds1).filter(_._1 != 0)\n      .map(e => s\"${e._1} ${e._2}${if(e._1 > 1) \"s\" else \"\"}\").mkString(\", \")\n    if(s.contains(\",\")) s.patch(s.lastIndexOf(\",\"), \" and\", 1) else s\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333452,"user_id":null,"body":"object HumanTime {\n\n  def format_duration(seconds: Int): String = if (seconds == 0) \"now\" else get_format(seconds);\n  \n  def get_format(seconds: Int): String = {\n    var s: Int = seconds;\n    var y: String = get_years(s);\n    s = s % (60 * 60 * 24 * 365);\n    var d: String = get_days(s);\n    s = s % (60 * 60 * 24);\n    var h: String = get_hours(s);\n    s = s % (60 * 60);\n    var m: String = get_minutes(s);\n    s = s % 60;\n    var sec: String = get_seconds(s);\n    print(y, d, h, m, sec)\n    var result: String = Array(y, d, h, m, sec).filter(_ != \"\").mkString(\", \");\n    if (result.contains(\", \")) {\n      result = result.reverse.replaceFirst(\" ,\", \" dna \").reverse;\n    }\n    return result;\n  }\n  \n  def get_years(s: Int): String = {\n    var k: Int = (60 * 60 * 24 * 365);\n    if (s \/ k == 0) return \"\"\n    else if (s \/ k == 1) return \"1 year\"\n    else return s\"${s\/k} years\";\n  }\n  \n  def get_days(s: Int): String = {\n    var k: Int = (60 * 60 * 24);\n    if (s \/ k == 0) return \"\"\n    else if (s \/ k == 1) return \"1 day\"\n    else return s\"${s\/k} days\";\n  }\n  \n  def get_hours(s: Int): String = {\n    var k: Int = (60 * 60);\n    if (s \/ k == 0) return \"\"\n    else if (s \/ k == 1) return \"1 hour\"\n    else return s\"${s\/k} hours\";\n  }\n  \n  def get_minutes(s: Int): String = {\n    var k: Int = 60;\n    if (s \/ k == 0) return \"\"\n    else if (s \/ k == 1) return \"1 minute\"\n    else return s\"${s\/k} minutes\";\n  }\n  \n  def get_seconds(s: Int): String = {\n    if (s == 0) return \"\"\n    else if (s == 1) return \"1 second\"\n    else return s\"${s} seconds\";\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333453,"user_id":null,"body":"object HumanTime {\n\n  def format_duration(seconds: Int): String = seconds match {\n    case 0 => \"now\"\n    case n: Int => covertTime(n).toString\n  }\n\n  case class covertTime(n: Int) {\n    val (year, day, hour, minute, second) = (\n      n \/ (365 * 24 * 60 * 60) ,\n      n % (365 * 24 * 60 * 60) \/ (24 * 60 * 60),\n      n % (24 * 60 * 60) \/ (60 * 60),\n      n % (60 * 60) \/ 60,\n      n % 60)\n\n    override def toString: String = {\n      def wrapper(name: String, n: Int): String = {\n        if (n == 0) \"\"\n        else if (n == 1) n + \" \" + name\n        else n + \" \" + name + \"s\"\n      }\n\n      val namesAndInt =\n        List(\"year\", \"day\", \"hour\", \"minute\", \"second\") zip List(year, day, hour, minute, second)\n\n      val res = namesAndInt.map(x => wrapper(x._1, x._2)).filter(_.length > 0)\n      res.length match {\n        case 1 => res.mkString\n        case n: Int => res.dropRight(1).mkString(\", \") + \" and \" + res.last\n      }\n\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333454,"user_id":null,"body":"object HumanTime {\n  val timeDivs: List[Int] = List(60, 60, 24, 365)\n  val timeUnits = List(\"second\", \"minute\", \"hour\", \"day\", \"year\")\n  \n  def format_duration(seconds: Int): String = {\n    def plural(t: Long, s: String): String = { if(t > 1) s + \"s\" else s }\n\n    if(seconds == 0) \"now\"\n    else {\n      val firstPass = timeDivs.scanLeft(seconds)( (x, y) => x \/ y)\n      val moddedPass = firstPass.zip(timeDivs).map{ case (x, timeDiv) => x % timeDiv } :+ firstPass.last \n      val phrases = moddedPass.zip(timeUnits).filter(_._1 != 0).map{ case(x, tu) => x.toString + \" \" + plural(x, tu) }.reverse\n      if(phrases.length > 1) { phrases.take(phrases.length - 1).mkString(\", \") + \" and \" + phrases.last} else phrases.head\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333455,"user_id":null,"body":"object HumanTime {\n\tdef format_duration(seconds: Int): String = {\n\t\tval n = Seq(\"second\" -> 1, \"minute\" -> 60, \"hour\" -> 60, \"day\" -> 24, \"year\" -> 365, \"inf\" -> Int.MaxValue)\n\n\t\tdef unitStr(unit: String, i: Int): Option[String] = i match {\n\t\t\tcase 0 => None\n\t\t\tcase 1 => Some(s\"1 $unit\")\n\t\t\tcase _ => Some(s\"$i ${unit}s\")\n\t\t}\n\n\t\tn.indices.dropRight(1).foldLeft(seconds -> Seq.empty[Option[String]]) { case ((t, s), i) =>\n\t\t\t(t \/ n(i + 1)._2) -> (unitStr(n(i)._1, t % n(i + 1)._2) +: s)\n\t\t}._2.flatten match {\n\t\t\tcase Nil => \"now\"\n\t\t\tcase List(single) => single\n\t\t\tcase multi @ _ => multi.dropRight(1).mkString(\", \") + \" and \" + multi.last\n\t\t}\n\t}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333456,"user_id":null,"body":"object HumanTime {\n  val minute = 60\n  val hour = 60 * minute\n  val day = 24 * hour\n  val year = 365 * day\n  \n  def formats(n: Int, s: String): String =\n   if (n > 1) s\"$n ${s}s\" else s\"$n $s\"\n  \n  def format_duration(seconds: Int): String =\n    if (seconds == 0) \"now\"\n    else\n      List((\"year\", year), (\"day\", day), (\"hour\", hour), (\"minute\", minute), (\"second\", 1))\n        .foldLeft((seconds, List.empty[String])) {\n          case ((remaining, l), (s, d)) if remaining \/ d > 0 =>\n            (remaining % d, formats(remaining \/ d, s) :: l)\n          case (acc, _) => acc\n        }._2 match {\n          case h :: n :: tail => (tail.reverse :+ s\"$n and $h\").mkString(\", \")\n          case l => l.mkString\n        }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5274e122fc75c0943d000148":[{"id":333457,"user_id":573,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = f\"$n%,d\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333458,"user_id":null,"body":"object Kata {\n  def groupByCommas(n: Int): String = {\n    n.toString.reverse.grouped(3).mkString(\",\").reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333459,"user_id":null,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = java.text.NumberFormat.getInstance.format(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333460,"user_id":null,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = n.formatted(\"%,d\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333461,"user_id":573,"body":"object Kata {\n\n  def groupByCommas(n: Int): String =\n    \"%,d\".formatLocal(java.util.Locale.US, n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333462,"user_id":null,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = {\n  def helper (n : String, lst: Seq[Any]): Seq[Any] = {\n    if (n.length > 3) {\n      helper (n.slice(0, n.length-3), lst.+:(n.takeRight(3)))\n    } else {\n      lst.+: (n)\n    }\n  }\n  helper(n.toString, Seq()).mkString(\",\")\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333463,"user_id":636,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = n.toString.reverse.foldLeft((0, \"\")) {\n        case ((cnt, out), digit) =>\n          (cnt + 1, out + {if (cnt != 0 && cnt % 3 == 0) s\",$digit\" else s\"$digit\"})}._2.reverse\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333464,"user_id":null,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = {\n    n.toString.reverse.zipWithIndex.map { case (c, i) => {\n      if ((i + 1) % 3 == 0 && i != (n.toString.length - 1)) \",\" + c.toString else c.toString\n    }}.reverse.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333465,"user_id":null,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = {\n  var result = n.toString \n  var str = result \n      var len = str.length\n      if(len > 3)\n      {\n        str = \"\"\n        var comma = \",\"\n        while(len>=0)\n        {\n          str = result.takeRight(3)+comma+str\n          result = result.take(len-3)\n          len = len-3\n        }\n        str = str.take(str.length-1)\n        if(str.take(1) == \",\")\n          str = str.takeRight(str.length-1)\n      }\n      str\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333466,"user_id":null,"body":"object Kata {\n\n  def groupByCommas(n: Int): String = {\n    def rewrite(in: String, out: String = \"\"): String=\n      if (in.nonEmpty) {\n        println(in,out)\n        rewrite(in.tail, s\"$out${\n          if(in.length % 3 != 1) in.head\n          else if (in.length > 1) s\"${in.head},\"\n          else in.head\n        }\")\n      } else\n        out\n\n    rewrite(n.toString)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5277c8a221e209d3f6000b56":[{"id":333467,"user_id":573,"body":"object Kata {\n\n  def valid_braces(s: String): Boolean =\n    s.replace(\"()\", \"\").replace(\"[]\", \"\").replace(\"{}\", \"\") match { case \"\" => true; case `s` => false; case x => valid_braces(x) }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333468,"user_id":null,"body":"object Kata {\n\n  def valid_braces(s: String): Any = {\n    val stack = scala.collection.mutable.Stack[Char]()\n    val map = Map[Char, Char](')' -> '(', '}' -> '{', ']' -> '[')\n    s.takeWhile(x => { x match {\n        case _ if (map.filter(_._2 == x).size == 1) => stack.push(x); true\n        case _ if (stack.isEmpty || map(x) != stack.pop) => false\n        case _ => true\n      }\n    }).size == s.size && stack.isEmpty\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333469,"user_id":527,"body":"object Kata extends scala.util.parsing.combinator.RegexParsers {\n\n  def valid_braces(s: String): Boolean = parseAll(p, s).successful\n\n  lazy val p: Parser[Any] = ('('~p~')' | '['~p~']' | '{'~p~'}').*\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333470,"user_id":null,"body":"object Kata {\n\n  def valid_braces(s: String): Boolean = {\n    val pairs = Map('('->')', '['->']', '{'->'}')\n    def loop(xs:List[Char], ys: List[Char]): Boolean = (xs, ys) match {\n      case (Nil, Nil) => true\n      case (Nil, _::Nil) => false\n      case (x::xs, ys) if \"([{\".contains(x) => loop(xs, pairs(x)::ys)\n      case (x::xs, y::ys) if x==y =>loop(xs, ys)\n      case _ => false\n    }\n    \n    loop(s.toList, List())\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333471,"user_id":null,"body":"object Kata {\n  \n  def valid_braces(s: String): Boolean = {\n    if (s.length == 0) true\n    else if (s.contains(\"()\")) valid_braces(s.replace(\"()\", \"\"))\n    else if (s.contains(\"{}\")) valid_braces(s.replace(\"{}\", \"\"))\n    else if (s.contains(\"[]\")) valid_braces(s.replace(\"[]\", \"\"))\n    else false\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333472,"user_id":null,"body":"object Kata {\n\n  val matching = Map(\n    ')' -> '(',\n    ']' -> '[',\n    '}' -> '{'\n  )\n             \n  val openers = matching.values.toSet\n  \n  def valid_braces(s: String): Boolean =\n    s.foldLeft(Some(List.empty): Option[List[Character]]){\n      case (Some(stack), c) if openers.contains(c) =>\n        Some(c :: stack)\n      case (Some(last :: stack), c) if matching.get(c).contains(last) =>\n        Some(stack)\n      case _ =>\n        None\n    }.contains(Nil)\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333473,"user_id":null,"body":"object Kata {\n\n  def valid_braces(s: String): Boolean = {\n    checkBraces(s, \"\")\n  }\n    \n  def checkBraces(s: String, inverse: String): Boolean = {\n    if (s.isEmpty) {\n      inverse.isEmpty\n    } else {\n      s.head match {\n        case '(' => checkBraces(s.tail, \")\" + inverse)\n        case '[' => checkBraces(s.tail, \"]\" + inverse)\n        case '{' => checkBraces(s.tail, \"}\" + inverse)\n        case close if (inverse.nonEmpty) && (inverse.head == close) => checkBraces(s.tail, inverse.tail)\n        case _ => false\n      }      \n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333474,"user_id":null,"body":"object Kata {\n\n  def valid_braces(s: String): Boolean = {\n    def filterBrackets(c:Int, n:String): Boolean ={\n      val newString = n.replace(\"()\", \"\")\n        .replace(\"[]\", \"\")\n        .replace(\"{}\", \"\")\n  \n      if (newString.length == 0) true\n      else if (newString.length == c) false\n      else filterBrackets(newString.length, newString)\n    }\n  \n    filterBrackets(s.length, s)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333475,"user_id":null,"body":"object Kata {\n  import scala.collection.mutable._\n  val q = Array('(', '{', '[')\n  def valid_braces(s: String): Boolean = {\n    val a = ArrayBuffer[String]()\n    var b = List[Char]()\n    for (c <- s) {\n      if (q contains c) b = c :: b\n      else {\n        if (b.length == 0) return false\n        val lastValue = b.head\n        if ( ( c == ']' & lastValue == '[' ) | ( c == '}' & lastValue == '{' ) | ( c == ')' & lastValue == '(' )) {\n          b = b.tail\n          }\n        }\n        \n      }\n                                                return b.isEmpty\n                                                \n    }\n    \n  }","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333476,"user_id":null,"body":"import scala.collection.mutable\n\nobject Kata {\n\n  def valid_braces(s: String): Boolean = {\n    val stack = new mutable.Stack[Char]()\n    val pairs = Map('(' -> ')', '[' -> ']', '{' -> '}')\n    val rest = s dropWhile { c =>\n      if (pairs.keySet.contains(c)) {\n        stack.push(c)\n        true\n      } else if (stack.isEmpty || pairs(stack.pop()) != c) {\n        false\n      }\n      else true\n    }\n    rest.isEmpty && stack.isEmpty\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5287e858c6b5a9678200083c":[{"id":333477,"user_id":573,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean =\n    n == n.toString.map(i => math.pow(i.asDigit, n.toString.size)).sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333478,"user_id":null,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean = n.toString.map(x => scala.math.pow(x.asDigit, n.toString.length)).sum == n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333479,"user_id":null,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean = {\n    val digits = n.toString.map(_.asDigit)\n    val power = digits.length\n\n    digits.map { digit =>\n      scala.math.pow(digit, power)\n    }.sum.toInt == n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333480,"user_id":573,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean =\n    n == s\"$n\".map(i => math.pow(i.asDigit, s\"$n\".size)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333481,"user_id":null,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean = {\n    val nStr = n.toString\n    val power = nStr.length\n    nStr.map(x => Math.pow(x - '0', power)).reduce(_ + _) == n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333482,"user_id":null,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean = {\n    n.toString.split(\"\").map(a=> math.pow(a.toInt,n.toString.length)).sum == n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333483,"user_id":null,"body":"import scala.math.pow\n\nobject Kata {\n\n  def narcissistic(n: Int): Boolean = {\n    val stringNumber = n.toString\n    stringNumber.foldLeft(0)((t, n) => {\n      t + pow(n.toString.toInt, stringNumber.length).intValue\n    }) == n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333484,"user_id":null,"body":"object Kata {\n\n  def narcissistic(n: Int): Boolean = {\n   val digitsOfInt = n.toString.map(_.asDigit).toList\n   \n    digitsOfInt.map(scala.math.pow(_,digitsOfInt.length).toInt).sum == n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333485,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject Kata {\n\n  def narcissistic(n: Int): Boolean = {\n    val charList = n.toString.toList\n    val numDigits = charList.size\n    var strList = new ListBuffer[String]()\n    \n    for (c <- charList) {\n      strList += c.toString\n    }\n    \n    var res = 0.0\n    \n    for (s <- strList) {\n      res += scala.math.pow(s.toDouble, numDigits)\n    }\n    \n    if (res == n) {\n      true\n    } else {\n      false\n    }\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333486,"user_id":53,"body":"import scala.math._\n\nobject Kata {\n  def narcissistic(num: Int): Boolean = {\n    var k = log10(num).toInt + 1\n    var m = 0\n    var n = num\n    while (n > 0) {\n      var d = n % 10;\n      m += pow(d, k).toInt\n      n \/= 10;\n    }\n    return m == num\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"528d36d7cc451cd7e4000339":[{"id":333487,"user_id":573,"body":"object StudentsRank {\n\n  def mostMoney(students: List[Student]): String = {\n    def money(s: Student): Int = s.fives * 5 + s.tens * 10 + s.twenties * 20\n    if (students.groupBy(money).size == 1 && students.size != 1) \"all\" else students.maxBy(money).name\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333488,"user_id":636,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String = \n    students.foldLeft(\"\",0){\n      case ((nam, mon), c) => {\n        val money = c.fives*5 +c.tens*10 +c.twenties*20\n        if (money > mon) (c.name, money) \n        else if (money < mon) (nam, mon) \n        else (\"all\", money)\n    }}._1\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333489,"user_id":759,"body":"object StudentsRank {\n  case class Simpler(name: String, money: Int)\n  def mostMoney(students: List[Student]): String = {\n    val simple = students.map(a => Simpler(a.name, 5 * a.fives + 10 * a.tens + 20 * a.twenties))\n    if (simple.length == 1) simple(0).name\n    else {\n      val sorted = simple.sortBy(-_.money)\n      if (sorted(0).money == sorted(1).money) \"all\"\n      else sorted(0).name\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333490,"user_id":null,"body":"object StudentsRank {\n  def mostMoney(students: List[Student]): String = {\n    var result = \"\"\n    var temp = 0\n    students.map(x => {( x.name -> (x.fives*5+x.tens*10+x.twenties*20)) })\n            .foreach(x=>\n                if(x._2 > temp){\n                    temp = x._2\n                    result = x._1\n                } else if (x._2 == temp) {\n                    temp = x._2\n                    result = \"all\"\n                } else {}\n            )\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333491,"user_id":null,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String = {\n    val ss = students.map(x => (x.name, x.twenties * 20 + x.tens * 10 + x.fives * 5)).sortBy(_._2)\n    ss match {\n      case Nil => \"\"\n      case x :: Nil => x._1\n      case x :: xs if xs.forall(e => e._2 == x._2) => \"all\"\n      case xs => xs.last._1\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333492,"user_id":null,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String = {\n    \n    students match {\n      case List(student) => student.name\n      case _ => { \n        val sortedStudents = students.sortWith((one, another) => calcSum(one) > calcSum(another) )\n        \n        val richestStudent = sortedStudents(0)\n        val anotherStudent = sortedStudents(1)\n        \n        if (calcSum(richestStudent) > calcSum(anotherStudent)) richestStudent.name else \"all\"\n      }\n    }\n    \n  }\n  \n  private def calcSum(student: Student): Int = {\n    student.fives * 5 + student.tens * 10 + student.twenties * 20\n  }\n  \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333493,"user_id":null,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String ={\n    val sortStud = students.map(s => (s.name, s.fives * 5 + s.tens * 10 + s.twenties * 20)).sortWith((s1, s2) => s1._2 > s2._2)\n    val maxStud = sortStud(0)\n    if (sortStud.count(s => s._2 == maxStud._2) > 1) \"all\" else maxStud._1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333494,"user_id":null,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String = {\n    val total = students.map(f => (f.name, f.fives*5+f.tens*10+f.twenties*20))\n    if(total.map(_._2).distinct.length == 1 && total.length != 1) return \"all\"\n    total.maxBy(_._2)._1\n    \n  }\n    \n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333495,"user_id":null,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String = {\n    students.foreach(println(_))\n    val pairs = students.map(x => Tuple2(x.name, List(x.fives * 5, x.tens * 10, x.twenties * 20).sum))\n    students.length match {\n      case 1 => students.head.name\n      case _ => if (pairs.forall(_._2 == pairs.head._2)) \"all\" else pairs.maxBy(_._2)._1\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333496,"user_id":null,"body":"object StudentsRank {\n\n  \/\/ NOTE: the student case class is preloaded\n  def mostMoney(students: List[Student]): String = {\n    val stuSum = students.map(x => (x.name, x.fives*5+x.tens*10+x.twenties*20))\n    val max = stuSum.sortBy(_._2).last._2\n    val finalList = stuSum.filter(_._2 == max) \n    if (finalList.size == 1) finalList.last._1\n    else \"all\"\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"52945ce49bb38560fe0001d9":[{"id":333497,"user_id":527,"body":"object Kata {\n\n  def pascal(p: Int): List[List[BigInt]] = {\n    List.iterate(List(BigInt(1)), p) { xs =>\n      1 :: (xs, xs.tail.view :+ BigInt(0)).zipped.map(_ + _)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333498,"user_id":573,"body":"object Kata {\n\n  def pascal(p: Int): List[List[BigInt]] =\n    List.range(1, p).scanLeft(List(BigInt(1))) {\n      (prev, _) => (BigInt(0) +: prev :+ BigInt(0)).sliding(2).map(_.sum).toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333499,"user_id":null,"body":"object Kata {\n\n  def pascal(p: Int): List[List[BigInt]] = {\n    if(p == 1) {\n      List(List(BigInt(1)))\n    } else {\n      val previous = pascal(p - 1)\n      val next: List[BigInt] = previous.last.zipWithIndex.map { tuple =>\n        val (i, idx) = tuple\n        if (idx == 0) BigInt(1) else i + previous.last(idx - 1)\n      } :+ 1\n      previous :+ next\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333500,"user_id":468,"body":"object Kata {\n\n  private final val ONE = BigInt(1)\n\n  @scala.annotation.tailrec\n  def pascal(p: Int, acc: List[List[BigInt]] = List(List(ONE))): List[List[BigInt]] = if (p == 1) acc else {\n    val last = acc.last\n    pascal(p - 1, acc.appended(ONE :: last.zip(last.tail).map { case (a, b) => a + b } ::: List(ONE)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333501,"user_id":null,"body":"object Kata {\n  import scala.annotation.tailrec\n  def pascal(p: Int): List[List[BigInt]] = {\n    @tailrec\n    def f(i: Int, l: List[BigInt], ll: List[List[BigInt]]): List[List[BigInt]] = i match {\n      case i if i == p => ll ++ List(l)\n      case _ => f(i + 1, rec(l), ll++ List(l))\n    }\n    f(1, List(BigInt.apply(1)), List())\n    }\n\n  def rec(l: List[BigInt]): List[BigInt] = {\n    val ll = BigInt.apply(0) :: l\n    (for {\n      i <- ll.indices\n    } yield (ll.slice(i, i + 2).sum)).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333502,"user_id":null,"body":"object Kata {\n  def pascal(p: Int): List[List[BigInt]] = {\n    var L0: List[List[BigInt]] = List(List(1))\n    var LB: List[BigInt] = List(1)\n    if (p==1)\n      L0\n    else\n      (2 to p).foreach(x=>\n        L0 = L0.appended(LB:::(for (i<- 1 to x-2)  yield( L0(x-2).apply(i-1)+L0(x-2).apply(i) )).toList:::LB)\n      )\n    L0  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333503,"user_id":null,"body":"object Kata {\n  def pascal(p: Int) =\n    Seq.iterate(Seq(BigInt(1)), p)(s =>\n      BigInt(0) +: s lazyZip s :+ BigInt(0) map (_ + _))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333504,"user_id":null,"body":"object Kata {\n\n  def factorial(n: Int, acc: Int = 0, xs: List[BigInt] = List(BigInt(1))): List[BigInt] = {\n    if (acc == n) xs\n    else factorial(n, acc + 1, xs :+ xs.last * (acc + 1))\n  }\n  \n  def pascal(p: Int): List[List[BigInt]] = {\n    val factorials = factorial(p)\n    def pascalAux(acc: Int = 0, result: List[List[BigInt]] = List()): List[List[BigInt]] = {\n      if (acc == p) result\n      else pascalAux(acc + 1, result :+ (0 to acc).map(x => factorials(acc)\/factorials(x)\/factorials(acc - x)).toList)\n    }\n    pascalAux()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333505,"user_id":null,"body":"object Kata {\n\n def pascal(p: Int): List[List[BigInt]] = {\n  def loop(step: Int,\n           last: List[BigInt],\n           res: List[List[BigInt]] = Nil): List[List[BigInt]] = {\n    if (step > p) res\n    else {\n      val next: List[BigInt] = BigInt(1) :: last.sliding(2,1).map(_.sum).toList.appended(BigInt(1))\n      loop(step + 1, next, next :: res)\n    }\n  }\n\n  lazy val l1 = List(BigInt(1))\n  lazy val l2 = List(BigInt(1),BigInt(1))\n  if (p == 1) List(l1)\n  else if (p == 2) List(l1, l2)\n  else loop(3, l2, List(l2, l1)).reverse\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333506,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n\n  def nextSeq(x: List[BigInt]): List[BigInt] = (BigInt(0) +: x :+ BigInt(0)).sliding(2).map(_.sum).toList\n\n  @tailrec\n  def recursion(p: Int, res: List[List[BigInt]] = List(List(BigInt(1)))): List[List[BigInt]] = res match {\n    case _ if p == 1 => res\n    case head +: tail => recursion(p - 1, nextSeq(head) +: res)\n  }\n\n  def pascal(p: Int): List[List[BigInt]] = recursion(p).reverse\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"529adbf7533b761c560004e5":[{"id":333507,"user_id":null,"body":"object Sol {\n\n  def fibonacci(n: Int, x: BigInt = 1, y: BigInt = 1): BigInt = {\n    n match {\n      case 0 | 1 => x\n      case _ => fibonacci(n - 1, y, x + y)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:18:21"},{"id":333508,"user_id":null,"body":"import scala.collection.mutable.Map\n\nobject Sol {\n\n  val cached: Map[Int, BigInt] = Map(0 -> 0, 1 -> 1)\n\n  def fibonacci(n: Int): BigInt =\n    cached.getOrElseUpdate(n, fibonacci(n-1) + fibonacci(n-2))\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:18:29"},{"id":333509,"user_id":null,"body":"object Sol {\n\n  def fibonacci(n: Int): BigInt = {\n    lazy val fibs: LazyList[BigInt] = BigInt(0) #:: fibs.scanLeft(BigInt(1))(_ + _)\n    fibs(n)\n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:18:33"},{"id":333510,"user_id":null,"body":"import scala.collection.mutable\n\nobject Sol {\n\n  private val map = mutable.Map[Int, BigInt](\n    0 -> 0,\n    1 -> 1,\n  )\n\n  def fibonacci(n: Int): BigInt = {\n    map.getOrElseUpdate(n, fibonacci(n-2) + fibonacci(n-1))\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:18:13"},{"id":333511,"user_id":527,"body":"object Sol {\n  val fib: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: fib.zip(fib.tail).map{ case (x, y) => x + y }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333512,"user_id":null,"body":"object Sol {\n\n  def fibonacci(n: Int): BigInt = {\n    \/\/ your code here\n    def counter(n: BigInt, a: BigInt, b: BigInt): BigInt =\n      if (n <= 0 ) b\n      else counter(n-1, a = a+b, b=a)\n\n    counter(n, 1, 0)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:17:22"},{"id":333513,"user_id":null,"body":"import scala.collection.mutable\n\nobject Sol {\n  val cache = mutable.Map[Int, BigInt]()\n  def fibonacci(n: Int): BigInt = n match {\n    case 0 | 1 => BigInt(n)\n    case _ =>\n      cache.getOrElseUpdate(n - 1, fibonacci(n - 1)) + cache.getOrElseUpdate(n - 2, fibonacci(n - 2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:18:13"},{"id":333514,"user_id":null,"body":"object Sol {\n\n   lazy val comp = {\n      def f(a: BigInt, b: BigInt): Stream[BigInt] = a #:: f(b, a + b)\n      f(0, 1)\n    }\n    \n  def fibonacci(n: Int): BigInt = comp.take(n + 1).last\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:17:22"},{"id":333515,"user_id":636,"body":"object Sol {\n\n  val fibs: LazyList[BigInt] =\n  BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map{ n => n._1 + n._2 }\n\n  def fibonacci(n: Int): BigInt = {\n    fibs.drop(n).head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:17:22"},{"id":333516,"user_id":null,"body":"object Sol {\n\n  def fibonacci(n: Int): BigInt = {\n    def innfibonacci(n0: BigInt, n1: BigInt, nn: Int):BigInt = if (nn == 0) n1 else innfibonacci(n1, n1 + n0, nn - 1) \n    innfibonacci(0, 1, n - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 19:18:13"}],"529bf0e9bdf7657179000008":[{"id":333517,"user_id":null,"body":"object Sudoku {\n\n  val xs: Set[Int] = (1 to 9).toSet\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n    board.forall(_.toSet == xs) &&\n    board.transpose.forall(_.toSet == xs) &&\n    board.grouped(3).forall {\n      _.transpose.grouped(3).forall(_.flatten.toSet == xs)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333518,"user_id":573,"body":"object Sudoku {\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean =\n    Seq(\n      board,\n      board.transpose,\n      (for { i <- Seq(0, 3, 6); j <- Seq(0, 3, 6) } yield board.slice(i, i+3).flatMap(_.slice(j, j+3))).toArray\n    )\n    .flatten\n    .forall(_.toList.sorted == (1 to 9).toList)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333519,"user_id":null,"body":"object Sudoku {\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n    val height =List[Array[Int]](board.map(x=>x(0)),\n                                 board.map(x=>x(1)),\n                                 board.map(x=>x(2)),\n                                 board.map(x=>x(3)),\n                                 board.map(x=>x(4)),\n                                 board.map(x=>x(5)),\n                                 board.map(x=>x(6)),\n                                 board.map(x=>x(7)),\n                                 board.map(x=>x(8))\n                                 )\n    val mini = List[Array[Int]](\n      Array[Int](board(0)(0),board(0)(1),board(0)(2),board(1)(0),board(1)(1),board(1)(2),board(2)(0),board(2)(1),board(2)(2)),\n      Array[Int](board(3)(0),board(3)(1),board(3)(2),board(4)(0),board(4)(1),board(4)(2),board(5)(0),board(5)(1),board(5)(2)),\n      Array[Int](board(6)(0),board(6)(1),board(6)(2),board(7)(0),board(7)(1),board(7)(2),board(8)(0),board(8)(1),board(8)(2)),\n      Array[Int](board(0)(3),board(0)(4),board(0)(5),board(1)(3),board(1)(4),board(1)(5),board(2)(3),board(2)(4),board(2)(5)),\n      Array[Int](board(3)(3),board(3)(4),board(3)(5),board(4)(3),board(4)(4),board(4)(5),board(5)(3),board(5)(4),board(5)(5)),\n      Array[Int](board(6)(3),board(6)(4),board(6)(5),board(7)(3),board(7)(4),board(7)(5),board(8)(3),board(8)(4),board(8)(5)),\n      Array[Int](board(0)(6),board(0)(7),board(0)(8),board(1)(6),board(1)(7),board(1)(8),board(2)(6),board(2)(7),board(2)(8)),\n      Array[Int](board(3)(6),board(3)(7),board(3)(8),board(4)(6),board(4)(7),board(4)(8),board(5)(6),board(5)(7),board(5)(8)),\n      Array[Int](board(6)(6),board(6)(7),board(6)(8),board(7)(6),board(7)(7),board(7)(8),board(8)(6),board(8)(7),board(8)(8))\n    )\n    board.filter(x=>x.filter(xx=>xx==0).size>0).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==0).size>0).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==0).size>0).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==1).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==1).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==1).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==2).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==2).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==2).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==3).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==3).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==3).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==4).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==4).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==4).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==5).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==5).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==5).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==6).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==6).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==6).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==7).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==7).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==7).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==8).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==8).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==8).size>1).size==0 &&\n    board.filter(x=>x.filter(xx=>xx==9).size>1).size==0 &&\n    height.filter(x=>x.filter(xx=>xx==9).size>1).size==0 &&\n    mini.filter(x=>x.filter(xx=>xx==9).size>1).size==0 \n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333520,"user_id":null,"body":"object Sudoku {\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n    isPartValid(board) && isPartValid(board.transpose) && isPartValid(get3x3(board))\n  }\n  \n  def isPartValid(board: Seq[Seq[Int]]): Boolean = {\n    board.map(_.distinct.length==9).forall(_ == true) && board.map(_.forall(_!=0)).forall(_ == true) && board.length==9\n  }\n  \n  def get3x3(board: Seq[Seq[Int]]): Seq[Seq[Int]] ={\n    board.map(_.grouped(3).toArray).grouped(3).map(_.transpose).reduce(_ ++ _).map(_.flatten)\n  }\n  \n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333521,"user_id":null,"body":"object Sudoku {\n\ndef isListValid(list: List[Int]): Boolean = {\n  !list.groupBy(identity).exists(_._2.length != 1) &&\n  !list.exists(a => a > 9 || a < 1)\n}\n\ndef areSquaresValid(board: Seq[Seq[Int]]): Boolean = {\n  !Array(0, 1, 2).flatMap(n => board.flatMap(_.slice(n * 3, (n + 1) * 3)).toList.grouped(9).toList.map(isListValid)).contains(false)\n}\n\ndef valid_solution(board: Seq[Seq[Int]]): Boolean = {\n  if (board.transpose.map(row => isListValid(row.toList)).contains(false))\n    return false\n  if (board.map(row => isListValid(row.toList)).contains(false))\n    return false\n  areSquaresValid(board)\n}\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333522,"user_id":null,"body":"object Sudoku {\n  val quad = Array(\n    Array(0, 0, 0, 1, 1, 1, 2, 2, 2),\n    Array(0, 0, 0, 1, 1, 1, 2, 2, 2),\n    Array(0, 0, 0, 1, 1, 1, 2, 2, 2),\n    Array(3, 3, 3, 4, 4, 4, 5, 5, 5),\n    Array(3, 3, 3, 4, 4, 4, 5, 5, 5),\n    Array(3, 3, 3, 4, 4, 4, 5, 5, 5),\n    Array(6, 6, 6, 7, 7, 7, 9, 9, 9),\n    Array(6, 6, 6, 7, 7, 7, 9, 9, 9),\n    Array(6, 6, 6, 7, 7, 7, 9, 9, 9)\n  )\n  \n  def valid_solution(board: Seq[Seq[Int]]): Boolean =\n    board.forall(_.forall(_ != 0)) &&\n    board.forall(_.toSet.size == 9) &&\n    board.transpose.forall(_.toSet.size == 9) && \n      (((quad zip board) flatMap {case (x,y) => x zip y} ).toList groupBy(_._1) map (_._2)).forall(_.toSet.size == 9)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333523,"user_id":636,"body":"object Sudoku {\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n    val boards = board.concat(board.transpose)\n    val blocks = for (i <- 0 until 9 by 3; j <- 0 until 9 by 3) yield {board.slice(0+i,3+i).map(x => x.slice(0+j,3+j))}\n    if (board.flatten.contains(0) ||\n        boards.exists(f => f.sorted.toList != (1 to 9).toList) ||\n        blocks.map(x => x.flatten.sum) != Vector.fill(9)(45)) false\n      else true\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333524,"user_id":null,"body":"object Sudoku {\n\n    def getRows(board: Seq[Seq[Int]]): List[List[Int]] = board.map(_.toList).toList\n\n    def getColumns(board: Seq[Seq[Int]]): List[List[Int]] = board.transpose.map(_.toList).toList\n\n    def getCubes(board: Seq[Seq[Int]]): List[List[Int]] = {\n      def boardTailRec(all: Seq[Seq[Int]], cubes: List[List[Int]]): List[List[Int]] = all match {\n        case Array() => cubes\n        case array => boardTailRec(array.tail, rowTailRec(array.head, cubes, (9 - array.length) \/ 3 * 3, (9 - array.length) \/ 3 * 3))\n      }\n\n      def rowTailRec(numbers: Array[Int], cubes: List[List[Int]], index1: Int, index2: Int): List[List[Int]] = numbers match {\n        case Array() => cubes\n        case array => rowTailRec(array.tail, cubes.updated(index1, cubes(index1) :+ array.head), (2 - (array.length - 2) \/ 3) + index2, index2)\n      }\n\n      boardTailRec(board, (1 to 9).map(_ => List()).toList)\n    }\n\n    def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n      val value = for {\n        rows <- getRows(board)\n        columns <- getColumns(board)\n        cubes <- getCubes(board)\n        result = rows.distinct.sum + columns.distinct.sum + cubes.distinct.sum == 135\n      } yield result\n      value.forall(identity)\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333525,"user_id":null,"body":"object Sudoku {\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n    val allowed: Set[Int] = (1 to 9).toSet\n    board.forall(_.toSet == allowed) && board.transpose.forall(_.toSet == allowed) && board.grouped(3).forall {\n      _.transpose.grouped(3).forall(_.flatten.toSet == allowed)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333526,"user_id":null,"body":"object Sudoku {\n  val fullSet = Set(1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n  def valid_solution(board: Seq[Seq[Int]]): Boolean = {\n    (0 to 8).map(x => containsFullSet(board(x))).concat(\n      (0 to 8).map(x => {\n        val a = (0 to 8).map(y => board(y)(x)).toArray\n        containsFullSet(a)\n      })\n    ).concat(\n      List(\n        (0 to 2),\n        (3 to 5),\n        (6 to 8),\n      ).map(range => {\n        range.flatMap(x => {\n          (0 to 2).map(y => board(x)(y))\n        }).toArray\n      }).map(x => containsFullSet(x))\n    ).concat(\n      List(\n        (0 to 2),\n        (3 to 5),\n        (6 to 8),\n      ).map(range => {\n        range.flatMap(x => {\n          (3 to 5).map(y => board(x)(y))\n        }).toArray\n      }).map(x => containsFullSet(x))\n    ).concat(\n      List(\n        (0 to 2),\n        (3 to 5),\n        (6 to 8),\n      ).map(range => {\n        range.flatMap(x => {\n          (6 to 8).map(y => board(x)(y))\n        }).toArray\n      }).map(x => containsFullSet(x))\n    )\n    .forall(x => x)\n  }\n  \n  def containsFullSet(a: Array[Int]): Boolean = {\n    val diff = fullSet diff a.toSet\n    \n    if (diff.size == 0) true else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"52a382ee44408cea2500074c":[{"id":333527,"user_id":null,"body":"object Matrix {\n  \n  def det2x2(matrix: Seq[Seq[Int]]): Int = {\n    matrix(0)(0) * matrix(1)(1) - matrix(0)(1) * matrix(1)(0)\n  }\n  \n  def getMinor(column: Int, matrix: Seq[Seq[Int]]): Seq[Seq[Int]] = {\n    val rows = matrix.drop(1) \/\/ eliminate first row\n    rows.map(x => x.zipWithIndex.filter(_._2 != column).map(_._1))\n  }\n  \n  def sig(n: Int): Int = {\n    if (n % 2 == 0) 1 else -1\n  }\n  \n  def determinant(matrix: Seq[Seq[Int]]): Int = {\n    \n    matrix.size match {\n      case 0 => throw new Exception(\"Empty matrix\")\n      case 1 => matrix(0)(0)\n      case 2 => det2x2(matrix)\n      case _ => (0 until matrix.size).map(\n        c => sig(c) * matrix(0)(c) * determinant(getMinor(c, matrix))).sum\n    }\n    \n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333528,"user_id":573,"body":"object Matrix {\n\n  def determinant(matrix: Seq[Seq[Int]]): Int =\n    matrix match {\n      case Seq(Seq(a)) => a\n      case _ =>\n        matrix\n          .head.zipWithIndex\n          .map { case (x, i) => math.pow(-1, i).toInt * x * determinant(matrix.drop(1).map(_.patch(i, Nil, 1))) }\n          .sum\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333529,"user_id":null,"body":"object Matrix {\n\n  def dropRowColumn(row: Int, col: Int, array: Seq[Seq[Int]]): Seq[Seq[Int]] =\n    (array.take(row) ++ array.drop(row + 1))\n      .map(row => row.take(col) ++ row.drop(col + 1))\n\n  def determinant(matrix: Seq[Seq[Int]]): Int = matrix.length match {\n    case 1 => matrix(0)(0)\n    case 2 => matrix(0)(0) * matrix(1)(1) - matrix(0)(1) * matrix(1)(0)\n    case _ =>\n      matrix.indices.map(\n        i => (if (i % 2 == 0) 1 else -1) * matrix(0)(i) * determinant(dropRowColumn(0, i, matrix))\n      ).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333530,"user_id":null,"body":"object Matrix {\n\n  type Matrix = List[List[Int]]\n\n  def getMinor(m: Matrix)(i: Int, j: Int) : Matrix = {\n    def without[A](xs: List[A], n: Int) : List[A] =\n      xs.zipWithIndex.filterNot { case (_, i) => i + 1 == n }.map(_._1)\n\n    without(m, i).map(r => without(r, j))\n  }\n\n  def getFirstRowPairs(m: Matrix) : List[(Int, Int)] =\n    (1 to (m.length)).toList.map(y => (1, y))\n\n  def getCell(m: Matrix)(i: Int, j: Int) : Int =\n    m(i - 1)(j - 1)\n\n  def evensNegative(xs: List[Int]) : List[Int] =\n    xs.zipWithIndex\n      .map { case (x, n) => (x, n % 2 != 0) }\n      .map { case (x, isEven) => if (isEven) -x else x }\n\n  def getDeterminant(m: Matrix) : Int =\n    if (m.length == 1) getCell(m)(1, 1)\n    else {\n      val list = getFirstRowPairs(m).map(p =>\n        (getCell(m) _).tupled(p) * getDeterminant((getMinor(m) _).tupled(p)))\n      evensNegative(list).sum\n    }\n\n  def determinant(matrix: Seq[Seq[Int]]): Int =\n    getDeterminant(matrix.map(_.toList).toList)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333531,"user_id":null,"body":"object Matrix {\n\n  def determinant(matrix: Seq[Seq[Int]]): Int = new Mat(matrix).det\n  \n  class Mat(data: Seq[Seq[Int]], rowIdx: Seq[Int], colIdx: Seq[Int]) {\n    def this(data: Seq[Seq[Int]]) = this(data, Seq.range(0, data.size), Seq.range(0, data.size))\n    def apply(row: Int, col: Int): Int = data(rowIdx(row))(colIdx(col))\n    def size: Int = rowIdx.size\n    def minor(row: Int, col: Int): Mat = new Mat(data, rowIdx.take(row) ++ rowIdx.drop(row+1), colIdx.take(col) ++ colIdx.drop(col+1))\n    def det: Int = size match {\n      case 1 => this(0, 0)\n      case n => (0 until n).map(col => (if(col%2 == 0) 1 else -1) * this(0, col) * minor(0, col).det).sum\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333532,"user_id":null,"body":"import scala.reflect.ClassTag\n\nobject Matrix {\n\n    def determinant(matrix: Seq[Seq[Int]]): Int = {\n      val row = matrix.head\n      if (row.length == 1) row.head\n      else row.zipWithIndex.foldLeft((0, 1)) {\n        case ((acc, sign), (value, col)) => \n          val minorDet = determinant(filter(matrix, 0, col))\n          (acc + (sign * value * minorDet), sign * -1)\n      }._1\n    }\n\n    def filter(matrix: Seq[Seq[Int]], row: Int, col: Int): Seq[Seq[Int]] =\n      filterOutIdx(matrix.map(filterOutIdx(_, col)), row)\n\n    def filterOutIdx[A : ClassTag](arr: Seq[A], idx: Int): Seq[A] =\n      arr.zipWithIndex.filter {\n        case (_, index) => idx != index\n      }.map(_._1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333533,"user_id":null,"body":"object Matrix {\n  def getSubMatrix(matrix: Seq[Seq[Int]], id: Int): Seq[Seq[Int]] = {\n    val size = matrix(0).length\n    (for (i <- 1 until size) yield {\n      (for (j <- 0 until size if j != id) yield {\n        matrix(i)(j)\n      }).toSeq\n    }).toSeq\n  } \n\n  def determinant(matrix: Seq[Seq[Int]]): Int = {\n    matrix.size  match {\n      case 1 => matrix(0)(0)\n      case 2 => matrix(0)(0)*matrix(1)(1) - matrix(0)(1)*matrix(1)(0) \n      case _ => matrix(0).zipWithIndex.foldLeft(0) {\n        case (ans, (elem, id)) => ans + math.pow(-1,id).toInt*elem*determinant(getSubMatrix(matrix, id)) \n      }\n    }\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333534,"user_id":null,"body":"object Matrix {\n\n  def determinant(matrix: Seq[Seq[Int]]): Int = {\n    var index = 0\n\n    if (matrix.isEmpty || matrix.length == index) 0\n    else if (matrix(0).length == 1) matrix(0)(0)\n    else matrix(0).foldLeft(0) { (acc, x) =>\n      val newAcc = acc + x * determinant(matrix.drop(1).map(matr => matr.slice(0, index) ++ matr.slice(index + 1, matr.length))) * (if (index % 2 == 0) 1 else -1)\n\n      index += 1\n      newAcc\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333535,"user_id":null,"body":"object Matrix {\n\n  def determinant(matrixBad: Seq[Seq[Int]]): Int = {\n    def detList(goodMatrix: List[List[Int]]): Int = {\n      goodMatrix match {\n        case x :: Nil => x.head\n        case matrix => {\n          def subMatrix(pos: Int): List[List[Int]] = {\n            matrix.tail map { arr => {\n              def getNewArr(curPos: Int, curArr: List[Int]): List[Int] = {\n                if (curPos == 0) curArr.tail\n                else curArr.head +: getNewArr(curPos - 1, curArr.tail)\n              }\n\n              getNewArr(pos, arr)\n            }\n            }\n          }\n          (1 to matrix.length).zip(matrix.head).map {\n            case (i, v) => (if (i % 2 == 1) 1 else -1) * v * detList(subMatrix(i - 1))\n          }.sum\n        }\n      }\n    }\n\n    detList(matrixBad.map(_.toList).toList)\n  }\n\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333536,"user_id":null,"body":"object Matrix {\n\n  def removeElementAtIndex(array: Seq[Int], index: Int) = {\n    array.zipWithIndex.filter(_._2 != index).map(_._1)\n  }\n  \n  def determinant(matrix: Seq[Seq[Int]]): Int = {\n    matrix.toList match {\n      case x :: Nil => x(0)\n      case x :: y :: Nil => x(0) * y(1) - x(1) * y(0)\n      case firstRow :: rest => {\n        firstRow.zipWithIndex.map{\n          case (elem, i) => \n          Math.pow(-1, i).toInt * elem * determinant(matrix.tail.map(row => {\n            removeElementAtIndex(row, i)\n          }))\n        }.sum\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"52efefcbcdf57161d4000091":[{"id":333537,"user_id":527,"body":"object Kata {\n  def count_characters(string: String): Map[Char, Int] = {\n    string.groupBy(identity).mapValues(_.size)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333538,"user_id":573,"body":"object Kata {\n\n  def count_characters(string: String): Map[Char,Int] =\n    string.groupMapReduce(identity)(_ => 1)(_ + _)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333539,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = {\n    var result = Map[Char, Int]()\n    string.foreach(char => {\n      result = result + (char -> (result.getOrElse(char, 0) + 1))\n    })\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333540,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = string.map(x=>(x,string.count(_==x))).toMap\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333541,"user_id":2178,"body":"object Kata {\n  def count_characters(string: String): Map[Char, Int] = {\n    string.foldLeft(Map.empty[Char, Int]) {\n      _.updatedWith(_) { \n        case None => Some(1)\n        case Some(x) => Some(x + 1)\n      }\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333542,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = {\n    string.groupBy(a => a).map(x => x._1 -> x._2.length)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333543,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = {\n    var m : Map[Char,Int] = Map[Char,Int]()\n    for( c <- string.toList.distinct){ m += (c -> string.count(_ == c)) }\n    m\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333544,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = {\n        string.toCharArray.map(x => (x, string.count(_ == x))).toMap\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333545,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = {\n    \/\/ Implement me! :)\n    \n    val mmsii = string.toCharArray.flatMap(x => x.toString.split(\",\"))\n                .map(x => (x, 1)).groupBy(_._1).mapValues(_.map(_._2)\n                .reduce(_ + _)).toMap\n    mmsii.flatMap{case (m,v) => m.map(_ -> v)}\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333546,"user_id":null,"body":"object Kata {\n  def count_characters(string: String): Map[Char,Int] = {\n    string.groupBy(identity).map[Char,Int]{case (k,v) => (k,v.length)}\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"52f787eb172a8b4ae1000a34":[{"id":333547,"user_id":573,"body":"object Solution {\n\n  def zeros(n: Int): Int =\n    n \/ 5 match {\n      case 0 => 0\n      case x => x + zeros(x)\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333548,"user_id":null,"body":"import scala.math.pow\nobject Solution {\n  def zeros(n: Int): Int = LazyList.from(1).map(pow(5,_)).takeWhile(n\/_ >= 1).map(x => (n\/x).toInt).sum\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333549,"user_id":null,"body":"object Solution {\n  def zeros(n: Int): Int = {\n    def z(i: Int, count: Int): Int = \n        i\/5 match {\n          case 0 => count\n          case x => z(x, count + x)\n        }\n    z(n, 0)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333550,"user_id":null,"body":"object Solution {\n  def zeros(n: Int): Int = {\n    if (n >= 5) {\n        return (n \/ 5) + zeros(n \/ 5)\n    }\n    0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333551,"user_id":null,"body":"object Solution {\n  def zeros(n: Int): Int = Stream.from(1).map(f => (n\/Math.pow(5,f)).toInt).takeWhile(_ >= 1).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333552,"user_id":null,"body":"object Solution {\n  def sumOfDividers(by: Int)(num: Int): Int =\n    if (num < by) 0\n    else (num \/ by) + sumOfDividers(by)(num \/ by)\n\n  def zeros(num: Int): Int = sumOfDividers(5)(num)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333553,"user_id":527,"body":"object Solution {\n  def zeros(n: Int): Int = {\n    Stream.iterate(n \/ 5)(_ \/ 5).takeWhile(_ != 0).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333554,"user_id":null,"body":"object Solution {\n  def zeros(n: Int): Int = {\n    var numOfFives = 0\n    var k: Int = 5\n    while (n >= k) {\n      numOfFives += n\/k\n      k *= 5\n    }\n    numOfFives\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333555,"user_id":null,"body":"object Solution {\n  def zeros(n: Int): Int = c(n, 5, n\/5)\n \n  def c(n: Int, d: Int, e: Int): Int = e match {\n    case 0 => 0\n    case _ => n\/d + c(n, d*5, n\/(d*5))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333556,"user_id":null,"body":"object Solution {\n  def zeros(n: Int): Int = {\n    val powersOf5 = Iterator.continually(5).scanLeft(5L)(_ * _).takeWhile(_ <= n).map(_.toInt).toSeq\n    powersOf5.map(n \/ _).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5300901726d12b80e8000498":[{"id":333557,"user_id":null,"body":"object FizzBuzz {\n  def fizzbuzz(n: Int): List[String] ={\n    (1 to n).map(k => k match{\n      case k if k % 15 == 0 => \"FizzBuzz\"\n      case k if k % 3 == 0 => \"Fizz\"\n      case k if k % 5 == 0 => \"Buzz\"\n      case k => k.toString\n    }).toList\n    }\n  }","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333558,"user_id":220,"body":"object FizzBuzz {\n  \n  def fizzbuzz(n: Int): String = n match {\n    case n if n % 15 == 0 => \"FizzBuzz\"\n    case n if n % 5  == 0 => \"Buzz\"\n    case n if n % 3  == 0 => \"Fizz\"\n    case _                => n.toString\n  }\n  \n  def fizzbuzz(n: Int): List[String] = (1 to n).map(fizzbuzz).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333559,"user_id":null,"body":"object FizzBuzz {\n  \n  def fizzBuzz(x: Int) = (x % 3, x % 5) match {\n    \n      case (0, 0) => \"FizzBuzz\"\n      case (0, _) => \"Fizz\"\n      case (_, 0) => \"Buzz\"\n      case _ => x.toString\n    \n    }\n  \n  def fizzbuzz(n: Int): List[String] = (1 to n).map(fizzBuzz).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333560,"user_id":null,"body":"object FizzBuzz {\n  def fizzbuzz(n: Int): List[String] = {\n    (1 to n).map(listEntry => listEntry match  {\n      case listEntry if listEntry % 15 == 0 => \"FizzBuzz\"\n      case listEntry if listEntry % 3 == 0 => \"Fizz\"\n      case listEntry if listEntry % 5 == 0 => \"Buzz\"\n      case _ => listEntry.toString\n    }).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333561,"user_id":null,"body":"object FizzBuzz {\n  def fizzbuzz(n: Int): List[String] = n match {\n    case n if n < 1 => throw new Exception(\"Parameter has to be greater than 1\")\n    case n if n == 1 => List(\"1\")\n    case n if isMultipleOf3(n) && !isMultipleOf5(n) => fizzbuzz(n - 1):::List(\"Fizz\")\n    case n if isMultipleOf5(n) && !isMultipleOf3(n) => fizzbuzz(n - 1):::List(\"Buzz\")\n    case n if isMultipleOf3(n) && isMultipleOf5(n) => fizzbuzz(n - 1):::List(\"FizzBuzz\")\n    case _ => fizzbuzz(n - 1):::List(n.toString)\n  }\n  def isMultipleOf3(n: Int): Boolean = (n % 3 == 0)\n  def isMultipleOf5(n: Int): Boolean = (n % 5 == 0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333562,"user_id":325,"body":"object FizzBuzz {\n  def fizzbuzz(n: Int): List[String] = (1 to n).map(_ match { \n    case divBy15 if divBy15 % 15 == 0 => \"FizzBuzz\"\n    case divBy5  if divBy5 % 5 == 0 => \"Buzz\"\n    case divBy3  if divBy3 % 3 == 0 => \"Fizz\"\n    case other => other.toString\n  }).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333563,"user_id":null,"body":"object FizzBuzz {\n  \n  def getStr(x: Int) = x match {\n      case x if x % 3 == 0 & x % 5 == 0 => \"FizzBuzz\"\n      case x if x % 3 == 0 => \"Fizz\"\n      case x if x % 5 == 0 => \"Buzz\"\n      case x => x.toString\n    }\n  \n  def fizzbuzz(n: Int): List[String] = (1 to n).map(getStr(_)).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333564,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject FizzBuzz {\n  def fizzbuzz(n: Int): List[String] = {\n    val l = ListBuffer[String]();\n    var i = 0;\n    for(i <- 1 to n)\n    {\n      if ((i % 3 == 0) && (i % 5 == 0)){\n        l += \"FizzBuzz\"\n      }\n      else if (i % 3 == 0){\n        l += \"Fizz\"\n      }\n      else if (i % 5 == 0){\n        l += \"Buzz\"\n      }\n      else{\n        l += i.toString();\n      }\n    }\n    l.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333565,"user_id":null,"body":"object FizzBuzz {\n  def fizzbuzz(n: Int): List[String] = {\n    (1 to n).toList.map(i => (i % 3, i % 5) match {\n      case (0, 0) => \"FizzBuzz\"\n      case (0, _) => \"Fizz\"\n      case (_, 0) => \"Buzz\"\n      case _ => i+\"\"\n    })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333566,"user_id":null,"body":"object FizzBuzz {\n  def fizzbuzz(n: Int): List[String] = {\n    var retVal:List[String] = List()\n    for(i <- 1 to n){\n      val in:String = (i%3, i%5) match {\n        case(0,0) => \"FizzBuzz\"\n        case(0,_) => \"Fizz\"\n        case(_,0) => \"Buzz\"\n        case _ => i.toString\n      }\n      retVal = retVal :+ in\n    }\n    retVal\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"53369039d7ab3ac506000467":[{"id":333567,"user_id":573,"body":"object Kata {\n\n  def bool_to_word(boolean: Boolean): String =\n    if (boolean) \"Yes\" else \"No\"\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333568,"user_id":null,"body":"object Kata {\n\n  def bool_to_word(b: Boolean): String = b match {\n    case true => \"Yes\"\n    case    _ => \"No\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333569,"user_id":null,"body":"object Kata {\n\n  def bool_to_word(bool: Boolean): String = if (bool) \"Yes\" else \"No\"\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333570,"user_id":null,"body":"object Kata {\n\n  def bool_to_word(boolean: Boolean) = if (boolean) \"Yes\" else \"No\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333571,"user_id":null,"body":"object Kata {\n\n  def bool_to_word(boolean: Boolean): String = {\n    val t1: PartialFunction[Boolean, String] = {case true => \"Yes\"}\n    val t2: PartialFunction[Boolean, String] = {case false => \"No\"}\n    val t = t1 orElse t2\n    t(boolean)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333572,"user_id":null,"body":"object Kata {\n\n  def bool_to_word(x: Boolean): String =\n    if (x == true) \"Yes\"\n    else \"No\"\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333573,"user_id":null,"body":"object Kata:\n  def bool_to_word(boolean: Boolean): String =\n    boolean match\n      case true => \"Yes\"\n      case false => \"No\"","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333574,"user_id":527,"body":"object Kata:\n  def bool_to_word(boolean: Boolean): String =\n    if boolean then \"Yes\" else \"No\"","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333575,"user_id":527,"body":"object Kata:\n  def bool_to_word(boolean: Boolean): String =\n    if (boolean) \"Yes\" else \"No\"","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333576,"user_id":null,"body":"object Kata {\n\n  def bool_to_word(boolean: Boolean): String = \n    if boolean then \"Yes\" else \"No\"\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"534d2f5b5371ecf8d2000a08":[{"id":333577,"user_id":527,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    List.tabulate(size, size)((x, y) => (x + 1) * (y + 1))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333578,"user_id":null,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] =\n    (1 to size).map(\n      x => (1 to size).map(y => y * x).toList\n    ).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333579,"user_id":null,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    (1 to size).grouped(1).map { row =>\n      (1 to size).map(x => x * row.head).toList\n    }.toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333580,"user_id":null,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    \/\/ Implement me!\n    val x = 1 to size\n    x.map{i => x.map {j => i * j}.toList}.toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333581,"user_id":null,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] =\n    List.tabulate(size, size)((i, j) => (i+1)*(j+1))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333582,"user_id":636,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    (for (i <- 1 to size) yield \n      (for (j <- 1 to size; k = i * j) yield k).toList).toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333583,"user_id":null,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    val mainList = (1 to size).toList\n    mainList.map(el => mainList.map(_ * el))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333584,"user_id":null,"body":"object Kata {\n\n  def multiplicationTable(size: Int): List[List[Int]] =\n    (1 to size).toList.sliding(1).toList.map { v =>\n      val head = v.head\n      val filled = List.fill(size)(head)\n      filled.foldLeft(List(head)) { (acc, next) => acc ++ List(acc.last + next) }.take(size)\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333585,"user_id":null,"body":"import scala.Array.ofDim\nobject Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    var miMatriz = ofDim[Int](size,size)\n\n    for(fila <- 0 to size-1){\n      for(columna <- 0 to size-1){\n        miMatriz(fila)(columna) = (columna + 1)  * (fila + 1)\n      }\n    }\n    miMatriz.map(list => list.toList).toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333586,"user_id":null,"body":"object Kata {\n  def multiplicationTable(size: Int): List[List[Int]] = {\n    List.tabulate(size)(n => List.range(n + 1, size * (n + 1) + 1, n + 1))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"534ea96ebb17181947000ada":[{"id":333587,"user_id":573,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int) = 0 max n * m - 1\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333588,"user_id":1228,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int) = {\n    (n * m - 1).max(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333589,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int) = {\n    if (n == 0 || m == 0) 0\n    else n - 1 + (m - 1) * n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333590,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int) = {\n    \/\/ your code here\n    \n    if(n == 0) 0\n    else n * m - 1\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333591,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int) = if((n*m-1)>0) n*m-1 else 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333592,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int) = {\n    ((n-1) + n * (m-1)).min((m-1) + m * (n-1)).max(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333593,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int): Int = {\n    val nBreaks = break(n)\n    val mBreaks = break(m)\n    if (mBreaks > 0) return (nBreaks + mBreaks) * 3\n    (nBreaks + mBreaks)\n  }\n  \n  def break(n: Int): Int = {\n    if (n < 2) return 0\n    (n \/ 2) + break((n \/ 2) + n % 2)\n    \/\/ 2 + break(2 + 1 = 3) = 4\n    \/\/ 1 + break(1 + 1 = 2) = 2\n    \/\/ 1 + break(1 + 0 = 1) = 1\n    \/\/ 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333594,"user_id":null,"body":"object Sol {\n\n  def breakCount(x: Int): Int = {\n    if(x<=1){\n       0\n    } else {\n       x - 1\n    }\n  }\n  \n  def breakSquare(large: Int, small: Int): Int = {\n    breakCount(large) + (large * breakCount(small))\n  }\n  \n  def break_chocolate(n: Int, m: Int) = {\n    if(n<=0 || m<=0){\n     0\n    }else{\n      if( n < m ){\n        breakSquare(n,m)\n      }else{\n        breakSquare(m,n)\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333595,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int): Int = (n, m) match {\n    case (1, m) => m - 1\n    case (n, 1) => n - 1\n    case (n, m) if (n > 0 && m > 0) => m + break_chocolate(n - 1, m)\n    case _ => 0\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333596,"user_id":null,"body":"object Sol {\n\n  def break_chocolate(n: Int, m: Int): Int = {\n    return if (n*m == 0) { 0 } else{ n*m - 1 }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"53d40c1e2f13e331fc000c26":[{"id":333597,"user_id":53,"body":"object Fib {\n  def fib(n: Int): BigInt = {\n    if (n >= 0) {\n      return aux(n)._1;\n    }\n    if (n%2 == 0) {\n      return -aux(-n)._1;\n    }\n    return aux(-n)._1;\n  }\n  def aux(n: Int): (BigInt, BigInt) = {\n    if (n == 0) {\n      return (BigInt(0), BigInt(1));\n    }\n    if (n == 1) {\n      return (BigInt(1), BigInt(1));\n    }\n    val xs = aux(n \/ 2);\n    val a = xs._1\n    val b = xs._2;\n    val x = a * (2 * b - a);\n    val y = b * b + a * a;\n    if (n%2 == 0) {\n      return (x, y);\n    }\n    return (y, x+y);\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333598,"user_id":null,"body":"object Fib {\n  final def foo(n: BigInt): (BigInt, BigInt) = {\n    if (n == 0) {\n      (BigInt(0), BigInt(1)) \/\/ (fib(0), fib(-1))\n    } else if (n == 1) {\n      (BigInt(1), BigInt(0)) \/\/ (fib(1), fib(0))\n    } else {\n      val (x, y) = foo(n \/ 2) \/\/ (fib(n \/ 2), fib(n \/ 2 - 1))\n      val a = (2 * y + x) * x\n      val b = x * x + y * y\n      if (n % 2 == 0) {\n        (a, b)\n      } else {\n        (a + b, a)\n      }\n    }\n  }\n\n  def fib(n: Int): BigInt = {\n    if (n >= 0) {\n      foo(n)._1\n    } else {\n      if (n % 2 == 0) {\n        -foo(-n)._1\n      } else {\n        foo(-n)._1\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333599,"user_id":null,"body":"object Fib {\n  def fibs(n: Int): (BigInt, BigInt) = n match {\n    case 0 => (0, 1)\n    case 1 => (1, 0)\n    case _ =>\n      val (a, b) = fibs(n \/ 2)\n      val p = (2 * b + a) * a\n      val q = a * a + b * b\n      if (n % 2 == 0) (p, q) else (p + q, p)\n  }\n\n  def fib(n: Int) =\n    fibs(n.abs)._1 * (if (n < 0 && n % 2 == 0) -1 else 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333600,"user_id":null,"body":"object Fib {\n\n  import scala.math.{signum => s}\n  \n  def fib(n: Int): BigInt = n match {\n    case 0 => BigInt(0)\n    case 1 | -1 => BigInt(1)\n    case _ if n % 2 == 0 => (n \/ 2).abs match { case k =>\n      fib(k) match { case fk => s(n) * fk * (2 * fib(k - 1) + fk) }\n    }\n    case _ => (n + 1) \/ 2 match { case k =>\n      fib(k).pow(2) + fib(k - 1).pow(2)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333601,"user_id":null,"body":"\nimport java.math.BigInteger\nobject Fib {\n\n  def fib(n: Int): BigInt = {\n    val result = fibonacci(Math.abs(n))\n\n    \/\/ negative numbers support\n    if (n < 0 && n % 2 == 0) result.bigInteger.negate\n    else result\n  }\n\n  \/\/ mutable fast double algorithm\n  def fibonacci(n: Int): BigInt = {\n    var a: BigInteger = BigInteger.ZERO\n    var b: BigInteger = BigInteger.ONE\n\n    var m = 0\n    var bit = Integer.highestOneBit(n)\n    while ( bit != 0) {\n      \/\/ Double it\n      val d = multiply(a, b.shiftLeft(1).subtract(a))\n      val e = multiply(a, a).add(multiply(b, b))\n      a = d\n      b = e\n      m *= 2\n      \/\/ Advance by one conditionally\n      if ((n & bit) != 0) {\n        val c = a.add(b)\n        a = b\n        b = c\n        m += 1\n      }\n\n      bit >>>= 1\n    }\n    a\n  }\n\n  def multiply(x: BigInteger, y: BigInteger): BigInteger = x.multiply(y)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333602,"user_id":null,"body":"object Fib {\n    \n  def matMult(m1:Array[Array[BigInt]], m2:Array[Array[BigInt]]): Array[Array[BigInt]] = {\n    val retArray = Array.ofDim[BigInt](2,2)\n    val i = 0\n    val j = 0\n    for (i <- 0 until m1.length) {\n      for (j <- 0 until m1.length) {\n        var sum = BigInt(0)\n        for (k <- 0 until m1.length) {\n          sum += m1(i)(k) * m2(k)(j)\n        }\n        retArray(i)(j) = sum\n      }\n    }\n    retArray\n  }\n\n\n  def fib(n: Int): BigInt = {\n    \/\/ your code here\n        if (n == 0) {\n      return 0\n    }\n    if (n == 1) {\n      return 1\n    }\n        \n    if (n < 0) {\n      var fibNPlus1 = BigInt(0)\n      var fibNPlus2 = BigInt(1)\n      if (n == -1) {\n        return fibNPlus2 - fibNPlus1\n      }\n      var fib = fibNPlus2 - fibNPlus1\n      for (i <- -1 to n by -1) {\n        fib = fibNPlus2 - fibNPlus1\n        \/\/println(s\"fib[${i}] $fib, fib[${i + 2}] $fibNPlus2, fib[${i+1}] $fibNPlus1\")\n        fibNPlus2 = fibNPlus1\n        fibNPlus1 = fib\n      }\n\n      return fib\n    }\n    \n\n    var stack = List[(Int, Int)]()\n    var startVal = n\n    while (startVal > 1) {\n      if (startVal % 2 != 0) {\n        startVal = startVal - 1\n        stack = (1, startVal) :: stack\n      } else {\n        stack = (0, startVal) :: stack\n      }\n      startVal = startVal \/ 2\n    }\n\n    val initMat = Array(Array(BigInt(1), BigInt(1)), Array(BigInt(1), BigInt(0)))\n    var resultMat = initMat\n\n    while (!stack.isEmpty) {\n      val tuple = stack.head\n      stack = stack.tail\n\n      if (tuple._1 == 1) {\n        resultMat = matMult(initMat, matMult(resultMat, resultMat))\n      } else {\n        resultMat = matMult(resultMat, resultMat)\n      }\n    }\n\n    resultMat(0)(1)\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333603,"user_id":null,"body":"object Fib {\n  type SquareMatrix = ((BigInt, BigInt), (BigInt, BigInt))\n  type Vector = (BigInt, BigInt)\n\n  def fib(n: Int): BigInt = {\n    n match {\n      case _ if n < 0 => fib(-n)*math.pow(-1, n-1).toInt\n      case 0 => 0\n      case 1 => 1\n      case _ => multiplyVec(power(((0, 1), (1, 1)), n - 1), (0, 1))._2\n    }\n  }\n\n  def power(a: SquareMatrix, n: Int): SquareMatrix = {\n    if (n == 1) {\n      a\n    } else if (n % 2 == 0) {\n      val m = power(a, n \/ 2)\n      multiply(m, m)\n    } else {\n      multiply(a, power(a, n - 1))\n    }\n  }\n\n  def multiply(a: SquareMatrix, b: SquareMatrix): SquareMatrix = {\n    val ((a11, a12),\n    (a21, a22)) = a\n    val ((b11, b12),\n    (b21, b22)) = b\n    ((a11 * b11 + a12 * b21, a11 * b12 + a12 * b22),\n      (a21 * b11 + a22 * b21, a21 * b12 + a22 * b22))\n  }\n\n  def multiplyVec(a: SquareMatrix, b: Vector): Vector = {\n    val ((a11, a12),\n    (a21, a22)) = a\n    val (b1, b2) = b\n    (a11 * b1 + a12 * b2,\n      a21 * b1 + a22 * b2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333604,"user_id":null,"body":"object Fib {\n  def fib(n: Int): BigInt = {\n    val absN = n.abs\n    val sign = if (n < 0 && absN % 2 == 0) -1 else 1\n    fibAbs(absN) * sign\n  }\n\n  def fibAbs(n: Int): BigInt = {\n    def fibs(n: Int): (BigInt, BigInt) =\n      if (n == 0) (0, 0)\n      else if (n == 1) (1, 0)\n      else {\n        val (a, b) = fibs(n \/ 2)\n        val p = (2 * b + a) * a\n        val q = a * a + b * b\n        if (n % 2 == 0) (p, q) else (p + q, p)\n      }\n\n    fibs(n)._1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333605,"user_id":null,"body":"object Fib {\n  def fib2(n : Int): (BigInt, BigInt) = {\n    if (n == 0) (BigInt(-1), BigInt(0))\n    else if (n == 1) (BigInt(0), BigInt(1))\n    else if (n % 2 == 0) {\n      val (f1, f2) = fib2(n \/ 2)\n      (f1 * f1 + f2 * f2, f2 * (f2 + f1 + f1))\n    } else {\n      val (f1, f2) = fib2((n + 1) \/ 2)\n      (f1 * (f2 + f2 - f1), f1 * f1 + f2 * f2)\n    }\n  }  \n  def fib(n: Int): BigInt = {\n    if (n >= 0) fib2(n)._2 \n    else if (n % 2 == 0) -fib2(-n)._2 \n    else fib2(-n)._2 \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333606,"user_id":null,"body":"object Fib {\n\ndef fib(n: BigInt) = {\n  var nn = if (n > 0) n else -n\n  var (a, b, c, d): (BigInt, BigInt, BigInt, BigInt) = (1,1,1,0)\n  var (rc, rd): (BigInt, BigInt) = (0,1)\n  var (ta, tb, tc): (BigInt, BigInt, BigInt) = (0, 0, 0)\n  while (nn>0) {\n       if ((nn & 1) > 0) {\n         tc = rc\n         rc = rc*a + rd*c\n         rd = tc*b + rd*d\n       }\n    ta = a\n    tb = b\n    tc = c\n    a = a*a + b*c\n    b = ta*b +b*d\n    c = c*ta + d*c\n    d = tc*tb + d*d\n\n    nn = nn >> 1\n  }\n  if (n>0)\n    rc\n  else if ((n & 1) > 0)\n    rc\n  else\n    rc*(-1)\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"53da3dbb4a5168369a0000fe":[{"id":333607,"user_id":1228,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = {\n    if (number % 2 == 0) \"Even\" else \"Odd\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333608,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = number % 2 match {\n    case 0 => \"Even\"\n    case _ => \"Odd\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333609,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = {\n    \/\/ your code here\n    number%2 match {\n      case 0 => \"Even\"\n      case _ => \"Odd\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333610,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = {\n    val x = number%2;\n    x match {\n      case 0 => \"Even\"\n      case _  => \"Odd\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333611,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = {\n    val arr = List(\"Even\", \"Odd\")\n    arr(number.abs % 2)\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333612,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = List(\"Even\", \"Odd\")(Math.abs(number) % 2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333613,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = {\n    if ((number & 1) == 1) \"Odd\" else \"Even\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333614,"user_id":null,"body":"object Sol {\n\n  def even_or_odd(number: Int): String = number match{    \n    case i => if(i % 2 == 0) \"Even\" else \"Odd\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333615,"user_id":527,"body":"object Sol:\n  def even_or_odd(number: Int): String =\n    if number % 2 == 0 then \"Even\" else \"Odd\"","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333616,"user_id":527,"body":"object Sol:\n  def even_or_odd(number: Int): String =\n    if (number % 2 == 0) \"Even\" else \"Odd\"","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"53f0f358b9cb376eca001079":[{"id":333617,"user_id":null,"body":"class Ball(val ballType: String = \"regular\")\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333618,"user_id":527,"body":"case class Ball(ballType: String = \"regular\")","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333619,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\nclass Ball(var  argument:String = \"regular\"){\n  \n   def ballType :String = {\n     \n     argument\n     \n   } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333620,"user_id":null,"body":"class Ball{\n  private var tipo : String =\"regular\"\n\n  def this(a : String) ={\n    this()\n    this.tipo=a\n  }\n\n  def ballType: String = {\n    this.tipo\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333621,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\nclass Ball(t: String){\n  val ballType = t\n  def this() = this(\"regular\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333622,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\nclass Ball(desiredType:String = \"regular\"){\n  val ballType = desiredType\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333623,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\nclass Ball (ball: String = \"regular\"){\n  val ballType = ball\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333624,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\nclass Ball(_ballType : String) {\n  var ballType : String = _ballType\n  def this() {\n    this(\"regular\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333625,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\n case class Ball(ballType: String = \"regular\")","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333626,"user_id":null,"body":"\/\/ Create class \"Ball\" with argument \"ballType\"\n class Ball(bla: String = \"regular\"){\n    val ballType = bla\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"540d0fdd3b6532e5c3000b5b":[{"id":333627,"user_id":null,"body":"\nimport scala.collection.mutable\nobject BinomialExpansion {\n\ndef expand(expr: String): String = {\n  var cache = mutable.Map(BigInt(0L)-> BigInt(1L), BigInt(1L) -> BigInt(1L), BigInt(2L) -> BigInt(2L))\n  def factorial(n: BigInt): BigInt = {\n    val cachedFact = cache.get(n)\n    if (cachedFact.isDefined) {\n      return cachedFact.get\n    }\n\n    val value = n * factorial(n - 1)\n    cache.put(n, value)\n    value\n  }\n\n  \/\/println(factorial(203) \/ factorial(0) \/ factorial(203))\n\n  def nChooseK(n: Long, k:Long): Long = {\n    if (k == 0) {\n      return 1\n    }\n    if (k == n) {\n      return 1\n    }\n    \/\/println(s\"factorial($n) ${factorial(n)} \/ factorial($k) ${factorial(k)}\/ factorial${(n - k)} ${factorial(n - k)}\")\n    val factN = factorial(n)\n    val factK = factorial(k)\n    val factNK = factorial(n - k)\n    if (factK > factNK) {\n      (factorial(n) \/ factorial(k) \/ factorial(n - k)).toLong\n    } else {\n      (factorial(n) \/ factorial(k) \/ factorial(n - k)).toLong\n    }\n  }\n\n  \/\/println(s\"${nChooseK(15, 14)} -----------------\")\n\n  def getPartsFromExpr(expr: String): Array[String] = {\n    var retList = Array[String]()\n    val splitExpr = expr.split(\"\\\\^\")\n\n    \/\/println(\"1 .....................\")\n    val n = splitExpr(1)\n    retList = retList :+ n\n    val hasPlus = if (splitExpr(0).indexOf(\"+\") != -1) true else false\n\n\n    \/\/println(\"2 .....................\")\n    var expressionStripped = splitExpr(0).replaceAll(\"[()]\", \"\")\n    \/\/println(s\"expressionStripped $expressionStripped\")\n    val aSignIsNegative = if (expressionStripped.head == '-') true else false\n    if (aSignIsNegative) expressionStripped = expressionStripped.tail\n    \/\/println(s\"expressionStripped $expressionStripped\")\n    val parts = expressionStripped.split(\"[+-]\")\n    \/\/println(\"2a .....................\")\n    val variablePart = parts(0)\n    \/\/println(s\"2b variablePart $variablePart .....................\")\n    val numberPattern = \"([0-9]+)\".r\n    \/\/println(\"2c .....................\")\n    var a = numberPattern.findFirstIn(variablePart) match {\n      case Some(d) => d\n      case None => \"1\"\n    }\n    if (aSignIsNegative) a = s\"-$a\"\n    \/\/println(s\"2d variablePart $variablePart .....................\")\n    val x = variablePart.substring(variablePart.length - 1)\n    \/\/println(\"2e .....................\")\n    val b = if (hasPlus) parts(1) else s\"-${parts(1)}\"\n\n    \/\/println(\"3 .....................\")\n\n    retList = retList :+ b\n    retList = retList :+ x\n    retList = retList :+ a\n\n\n    retList\n  }\n\n  val parts = getPartsFromExpr(expr).reverse\n  val a = parts(0).toInt\n  val x = parts(1)\n  val b = parts(2).toInt\n  val n = parts(3).toInt\n\n  \/\/println(s\"a=$a, x=$x, b=$b\")\n  if (n == 0) {\n    \/\/println(\"1\")\n    return \"1\"\n  }\n\n  if (n == 1) {\n    return expr.split(\"\\\\^\")(0).replaceAll(\"[()]\", \"\")\n  }\n\n  if (b == 0) {\n    if (math.abs(a) > 1) {\n      val aPower = s\"${math.pow(a, n).toLong}\"\n      return s\"$aPower$x^$n\"\n    } else {\n      return s\"$x^$n\"\n    }\n  }\n\n  var retList = List[String]()\n  for (k <- 0 to n) {\n    \/\/println(s\"0: k $k *****************************\")\n    val coeffVal = nChooseK(n, k)\n    \/\/println(s\"0a: $k -> $coeffVal *****************************\")\n    val nMinusK = n - k\n    val firstPow = if (a == 1) 1 else math.pow(a, nMinusK).toLong\n    val secondPow = if (b == 1) 1 else math.pow(b, k).toLong\n    \/\/println(s\"0a1: b $b, k $k -> $secondPow *****************************\")\n    val coeffsProd = coeffVal * firstPow * secondPow\n    val coeffsProdStr = f\"$coeffsProd%d\"\n    val xWithPow = if (nMinusK == 1) x else if (nMinusK == 0) \"1\" else s\"$x^$nMinusK\"\n    \/\/println(\"1 *****************************\")\n    var term = \"\"\n    if (coeffsProdStr == \"1\") {\n      term = s\"$xWithPow\"\n      \/\/println(s\"$xWithPow .........\")\n    } else if (coeffsProdStr == \"-1\") {\n      term = s\"-$xWithPow\"\n      \/\/println(s\"-$xWithPow ============\")\n    } else {\n      if (xWithPow == \"1\") {\n        term = f\"$coeffsProd%d\"\n      } else {\n        term = f\"$coeffsProd%d$xWithPow\"\n        \/\/println(f\"$coeffsProd%d$xWithPow *************\")\n      }\n    }\n    if (k == 0) {\n      retList = term :: retList\n    } else {\n      if (term.head != '-') {\n        retList = (\"+\" + term) :: retList\n      } else {\n        retList = term :: retList\n      }\n    }\n  }\n  \/\/println\n  retList.reverse.mkString(\"\")\n}\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333628,"user_id":null,"body":"import java.util.regex.Pattern\nobject BinomialExpansion {\n  private val binExpPattern = Pattern.compile(\"\\\\((-?\\\\d*)(\\\\w)([+-]\\\\d+)\\\\)\\\\^(\\\\d+)\")\n  private val p0 = BigInt(0)\n  private val p1 = BigInt(1)\n  private val n1 = BigInt(-1)\n  \n    def expand(expr: String): String = {\n    val split = expr.replace(\" \", \"\").split('^')\n    val term = split(0).substring(1, split(0).length - 1) \/\/ substring removes brackets\n\n    \/\/ split(1) is the power\n    split(1).toLong match {\n      case 0L => \"1\"\n      case 1L => term\n      case n =>\n        \/\/ split variable and constant terms, along with signs\n        val eq = term.replace(\"+\", \" +\")\n          .replace(\"-\", \" -\").split(\" \").filter(_.nonEmpty)\n        \/\/eq = ax + b\n        val ax = eq(0)\n        val (a, x) = ax.splitAt(ax.length - 1)\n        \/\/ If a is empty, or just the + or - operator, append a 1 at the end\n        val A = (if (a.exists(_.isDigit)) a else a + \"1\").toLong\n        val B = eq(1).toLong\n        if (B == 0) {\n          \/\/ if B was 0, input expr was (Ax)^n, which is simply A^n*x^n\n          val cf = Math.pow(A, n).toLong\n          \/\/ if coefficient is 1 or -1, \"hide\" the 1\n          if (cf == 1) s\"$x^$n\"\n          else if (cf == -1) s\"-$x^$n\"\n          else s\"$cf$x^$n\"\n        } else {\n\n          var r = 0L\n          var nCr = 1L\n\n          var res = \"\"\n          while (r <= n) {\n            \/\/ Math.pow returns a double. .toLong drops the pesky .0\n            val coefficient = nCr * Math.pow(A, n - r).toLong * Math.pow(B, r).toLong\n            \/\/ \"hide\" 1 in coefficient, and add in an artificial + is needed\n            val cf =\n              if (coefficient == 1) \"+\"\n              else if (coefficient == -1) \"-\"\n              else if (coefficient < 0) coefficient.toString\n              else \/*if (coefficient > 0)*\/ s\"+$coefficient\" \/\/ Note that neither a nor b is 0 here. Thus coefficient is never 0\n\n\n            res += (n - r match {\n              case 0 =>\n                \/\/ when power is 0, x term vanishes, leaving only constant.\n                \/\/ If the constant is empty or is only + or -, append a 1\n                if (cf.exists(_.isDigit)) cf else s\"${cf}1\"\n              case 1 =>\n                \/\/ \"hide\" something^1\n                s\"$cf$x\"\n              case p => s\"$cf$x^$p\"\n            })\n\n            r += 1\n            \/\/ Note that nCr = nC(r-1) * (n - r + 1) \/ r\n            \/\/ Doing multiplication and division separately ensure precision\n            nCr *= n - r + 1\n            nCr \/= r\n          }\n\n          \/\/ Remove artificially added +, if it's at the begining of the result\n          if (res.startsWith(\"+\")) res.replaceFirst(\"\\\\+\", \"\") else res\n        }\n    }\n  }\n\n  \/**\n    * \u4e8c\u9879\u5f0f\u516c\u5f0f\n    * (a+b)\u207f=C(n,0)a\u207f+C(n,1)a\u207f\u05bf\u00b9b+C(n,2)a\u207f\u05bf\u00b2b\u00b2+.+C(n,(n-k))[a^(n-k)]b^k+......+C(n,n)b\u207f\n    * \u5219\n    * (ax+b)^n=C(n,0)*a^n*x^n + C(n,1)*a^(n-1)*x^(n-1)*b +.....+ C(n,n)*b^n\n    *\/\n  def expand2(expr: String): String = {\n    val matcher = binExpPattern.matcher(expr)\n    if (!matcher.find()) \"\" else {\n      val g1 = matcher.group(1)\n      val a = if (g1 == null || g1.isEmpty) 1 else if (g1 == \"-\") -1 else g1.toInt\n      val x = matcher.group(2)\n      val b = matcher.group(3).toInt\n      val n = matcher.group(4).toInt\n      (n to 0 by -1).map(i => { \/\/\u5012\u5e8f\uff0c\u7b80\u5316\u4e0b\u9762\u4ee3\u7801\n        val c = combine(n, i) * BigInt(math.pow(a, i).toLong) * BigInt(math.pow(b, n - i).toLong) \/\/\u7cfb\u6570\n        val xStr = i match { \/\/x\u9879\uff0c i\u6b21\u5e42\n          case 0 => \"\"\n          case 1 => x\n          case _ => s\"$x^$i\"\n        }\n        c match {\n          case `p0` => null\n          case `p1` => if (xStr.isEmpty) \"1\" else xStr\n          case `n1` => if (xStr.isEmpty) \"-1\" else s\"-$xStr\"\n          case _ => s\"$c$xStr\"\n        }\n      }).filter(_ != null).mkString(\"+\").replace(\"+-\", \"-\")\n    }\n  }\n\n  \/**\n    * \u7ec4\u5408 C(n,m)\n    * =(n*(n-1)*....*(n-m+1))\/(m*(m-1)*...*1)\n    *\/\n  def combine(n: Int, m: Int): BigInt =\n    (0 until m).foldLeft(BigInt(1))((r, i) => r * (n - i) \/ (i + 1))\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333629,"user_id":null,"body":"object BinomialExpansion {\n  case class Expression(a: Long, x: String, b: Long, n: Long)\n\n  def parseCoefficient(s: String): Long = s match {\n    case \"-\" => -1\n    case \"\"  => 1\n    case _   => s.toLong\n  }\n\n  def simplifyCoefficient(s: Long): String =\n    if (s == 1) \"\"\n    else if (s == -1) \"-\"\n    else s.toString\n\n  def parseExpression(expr: String): Option[Expression] = {\n    val r = \"\"\"\\((-?\\d*)(\\w)((?:\\+|-)\\d+)\\)\\^(-?\\d+)\"\"\".r\n    expr match {\n      case r(a, x, b, n) =>\n        Some(Expression(parseCoefficient(a), x, parseCoefficient(b), n.toLong))\n      case _ => None\n    }\n  }\n\n  def coefficients(n: Long): List[Long] = {\n    val m = collection.mutable.Map[(Long, Long), Long]((0L, 0L) -> 1L)\n\n    def helper(row: Long, col: Long): Long = {\n      if (col == 0 || col == row) 1\n      else\n        m.getOrElseUpdate(\n          (row, col),\n          helper(row - 1, col) +\n            (if (col == 0) 0 else helper(row - 1, col - 1))\n        )\n    }\n\n    (0L to n).map(col => helper(n, col)).toList\n  }\n\n  def buildPart(e: Expression, c: List[Long], n: Long, p: Long): String = {\n    val m = n - p\n\n    val partCoeff = simplifyCoefficient(\n      c(p.toInt) * math.pow(e.a, m).toLong * math.pow(e.b, p).toLong\n    )\n    if (partCoeff == \"0\") return \"\"\n    val partCoeffStr = if (partCoeff == \"\" && p != 0) \"1\" else partCoeff\n    val xStr =\n      if (m == 0) \"\"\n      else s\"${e.x}\" + (if (m == 1) \"\" else s\"^$m\")\n\n    val s = s\"$partCoeffStr$xStr\"\n    if (s == \"-\") \"-1\" else s\n  }\n\n  def expand(expr: String): String = {\n    val e = parseExpression(expr).get\n    if (e.n == 0) return \"1\"\n\n    (0L to e.n)\n      .map(p => buildPart(e, coefficients(e.n), e.n, p))\n      .filterNot(_.isEmpty)\n      .toList\n      .map { s => if (s.startsWith(\"-\")) s else s\"+$s\" }\n      .mkString\n      .dropWhile(_ == '+')\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333630,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject BinomialExpansion {\n\n  @tailrec\n  def factorial(n: Int, acc: Int = 1, factorials: List[Long] = List(1)): List[Long] = {\n    val newFactorials = factorials :+ factorials.last * acc\n    if (acc >= n) newFactorials\n    else factorial(n, acc + 1, newFactorials)\n  }\n  \n  def parseA(s: String): Int = {\n    s match {\n      case \"\" => 1\n      case \"-\" => -1\n      case other => s.toInt\n    }\n  }\n  \n  def parseB(s: String): Int = {\n    val sign = if (s(0) == '-') -1 else 1\n    sign * s.drop(1).toInt\n  }\n  \n  def expand(expr: String): String = {\n    val pIndex = expr.indexOf(\"^\")\n    val n = expr.drop(pIndex + 1).toInt\n    val base = expr.take(pIndex).drop(1).dropRight(1)\n    val x = base.replaceAll(\"[^a-zA-Z]\", \"\")\n    val xIndex = base.indexOf(x)\n    val a = parseA(base.take(xIndex))\n    val b = parseB(base.drop(xIndex + 1))\n    \n    val factorials = factorial(n)\n    \n    def parseAnswer(l: List[Long]): String = {\n      @tailrec\n      def parseAux(l: List[Long], s: String = \"\"): String = {\n        if (l.length == 0) s\n        else {\n          val sign = if (l(0) >= 0) \"+\" else \"\"\n          val coef = l(0).toString match {\n            case \"1\" => if(l.length == 1) \"1\" else \"\"\n            case \"-1\" => if(l.length == 1) \"-1\" else \"-\"\n            case x => x\n          }\n          val suffix = l.length match {\n            case 1 => \"\"\n            case 2 => x\n            case other => x + \"^\" + (l.length - 1)\n          }\n          val term = if (coef == \"0\") \"\" else (sign.concat(coef).concat(suffix))\n          parseAux(l.tail, s + term)\n        }\n      }\n      val answer = parseAux(l)\n      if(answer(0) == '+') answer.drop(1)\n      else answer\n    }\n    \n    def asPowersList(p: Int, acc: List[Long] = List()): List[Long] = {\n      if (p == -1) acc\n      else {\n        val k = n - p\n        val bin = factorials(n)\/(factorials(k) * factorials(p))\n        val c = bin * math.pow(a, p).toLong * math.pow(b, k).toLong\n        asPowersList(p-1, acc :+ c)\n      }\n    }\n    \n    parseAnswer(asPowersList(n))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333631,"user_id":null,"body":"object BinomialExpansion {\n\n  type Member = (Long, Option[String])\n\n  def expand(expr: String): String = {\n    val p = \"\\\\(([+-]?\\\\d*[a-zA-Z]*)([+-]?\\\\d*[a-zA-Z]*)\\\\)\\\\^(\\\\d+)\".r\n    val p(x, y, z) = expr\n    val (m1, m2) = (parse(x), parse(y))\n    coef(z.toInt).map({\n      case (f, e1, e2) => product(pow(m1, e1), pow(m2, e2), f)\n    })\n      .filter(e => e._1 != 0)\n      .map(mkString)\n      .foldLeft(\"\")(join)\n  }\n\n  def join(s1: String, s2: String): String = (s1, s2) match {\n    case (\"\", a) => a\n    case (a, b) if b.startsWith(\"-\") => a + b\n    case (a, b) => a + \"+\" + b\n  }\n\n  def product(m1: Member, m2: Member, f: Long): Member = product(m1, product(m2, f))\n\n  def product(m1: Member, m2: Member): Member = (\n    m1._1 * m2._1,\n    Some(m1._2.filterNot(_ => m1._1 == 0).getOrElse(\"\") + m2._2.filterNot(_ => m2._1 == 0).getOrElse(\"\")).filterNot(_.isEmpty)\n  )\n\n  def product(m: Member, i: Long): Member = (m._1 * i, m._2)\n\n  def pow(m: Member, e: Int): Member = (\n    scala.math.pow(m._1, e).toLong,\n    e match {\n      case 0 => None\n      case 1 => m._2\n      case _ => m._2 map (_ + s\"^$e\")\n    }\n  )\n\n  def mkString(m: Member): String = (m._1.toString, m._2) match {\n    case (\"0\", _) => \"\"\n    case (\"1\", x) => x.getOrElse(\"1\")\n    case (\"-1\", x) => \"-\" + x.getOrElse(\"1\")\n    case (i, o) => i + o.getOrElse(\"\")\n  }\n\n  def parse(x: String): Member = {\n    val p = \"([+-]?\\\\d*)([a-zA-Z]*)\".r\n    val p(n, l) = x\n    val f = n match {\n      case \"-\" => -1\n      case \"\" => 1\n      case _ => n.toInt\n    }\n    (f, Option(l).filter(_ != \"\"))\n  }\n\n  def coef(pow: Int): IndexedSeq[(Long, Int, Int)] = (0 to pow).map(i => (choose(pow, i), pow - i, i))\n\n  def choose(n: Int, k: Int): Long =\n    if (k == 0 || k == n) 1\n    else choose(n - 1, k - 1) + choose(n - 1, k)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333632,"user_id":468,"body":"object BinomialExpansion {\n\n  def expand(expr: String): String = {\n    val split = expr.replace(\" \", \"\").split('^')\n    val term = split(0).substring(1, split(0).length - 1) \/\/ substring removes brackets\n\n    \/\/ split(1) is the power\n    split(1).toLong match {\n      case 0L => \"1\"\n      case 1L => term\n      case n =>\n        \/\/ split variable and constant terms, along with signs\n        val eq = term.replace(\"+\", \" +\")\n          .replace(\"-\", \" -\").split(\" \").filter(_.nonEmpty)\n        \/\/eq = ax + b\n        val ax = eq(0)\n        val (a, x) = ax.splitAt(ax.length - 1)\n        \/\/ If a is empty, or just the + or - operator, append a 1 at the end\n        val A = (if (a.exists(_.isDigit)) a else a + \"1\").toLong\n        val B = eq(1).toLong\n        if (B == 0) {\n          \/\/ if B was 0, input expr was (Ax)^n, which is simply A^n*x^n\n          val cf = Math.pow(A, n).toLong\n          \/\/ if coefficient is 1 or -1, \"hide\" the 1\n          if (cf == 1) s\"$x^$n\"\n          else if (cf == -1) s\"-$x^$n\"\n          else s\"$cf$x^$n\"\n        } else {\n\n          var r = 0L\n          var nCr = 1L\n\n          var res = \"\"\n          while (r <= n) {\n            \/\/ Math.pow returns a double. .toLong drops the pesky .0\n            val coefficient = nCr * Math.pow(A, n - r).toLong * Math.pow(B, r).toLong\n            \/\/ \"hide\" 1 in coefficient, and add in an artificial + is needed\n            val cf =\n              if (coefficient == 1) \"+\"\n              else if (coefficient == -1) \"-\"\n              else if (coefficient < 0) coefficient.toString\n              else \/*if (coefficient > 0)*\/ s\"+$coefficient\" \/\/ Note that neither a nor b is 0 here. Thus coefficient is never 0\n\n\n            res += (n - r match {\n              case 0 =>\n                \/\/ when power is 0, x term vanishes, leaving only constant.\n                \/\/ If the constant is empty or is only + or -, append a 1\n                if (cf.exists(_.isDigit)) cf else s\"${cf}1\"\n              case 1 =>\n                \/\/ \"hide\" something^1\n                s\"$cf$x\"\n              case p => s\"$cf$x^$p\"\n            })\n\n            r += 1\n            \/\/ Note that nCr = nC(r-1) * (n - r + 1) \/ r\n            \/\/ Doing multiplication and division separately ensure precision\n            nCr *= n - r + 1\n            nCr \/= r\n          }\n\n          \/\/ Remove artificially added +, if it's at the begining of the result\n          if (res.startsWith(\"+\")) res.replaceFirst(\"\\\\+\", \"\") else res\n        }\n    }\n  }\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"541c8630095125aba6000c00":[{"id":333633,"user_id":573,"body":"object SumOfDigits {\n\n  def digital_root(n: Int): Int =\n    if (n < 10) n else digital_root(n.toString.map(_.asDigit).sum)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333634,"user_id":null,"body":"object SumOfDigits {\n\n  def digital_root(n: Int): Int = return (n - 1) % 9 + 1;\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333635,"user_id":null,"body":"object SumOfDigits {\n\n  \n  def digital_root(n: Int): Int = LazyList.iterate(n)(n => n.toString.map(d => d.toString.toInt).sum).find(n => n<10).get\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333636,"user_id":1228,"body":"object SumOfDigits {\n\n  def digital_root(n: Int): Int = {\n    (n - 1) % 9 + 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333637,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject SumOfDigits {\n\n  @tailrec\n  def digital_root(n: Int): Int = n match {\n    case d if d < 10 => d\n    case d => digital_root(sum(d, 0))\n  }\n  \n  @tailrec\n  def sum(n: Int, acc: Int): Int = {\n    if (n < 10) acc + n else sum(n \/ 10, acc + n % 10)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333638,"user_id":null,"body":"object SumOfDigits {\n\n    @scala.annotation.tailrec\n    def digital_root(n: Int): Int = {\n      val digits = n.toString.map(_.asDigit).toList\n\n      if(digits.length == 1) digits.head else digital_root(digits.sum)\n    }\n \n \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333639,"user_id":573,"body":"object SumOfDigits {\n\n  def digital_root(n: Int): Int =\n    if (n < 10) n else digital_root(s\"$n\".map(_.asDigit).sum)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333640,"user_id":null,"body":"object SumOfDigits {\n\n  \/**\n   * This method returns the digital root of the given non-negative integer\n   *\n   * @param n the non-negative integer whose digital root is desired\n   * @return the digital root\n   *\/\n  def digital_root(n: Int): Int = \n    if (n > 0) {\n      \/\/ this uses the fact that the digital root is in [1, 9], \n      \/\/ and that a number is congruent to its digital sum modulo 9\n      \/\/ This works as long as we represent th 0 congruency class with 9\n      val mod = n % 9\n      if (mod != 0) {\n        mod\n      } else {\n        9\n      }\n    } else {\n      0\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333641,"user_id":null,"body":"object SumOfDigits {\n\n  def digital_root(n: Int): Int = {\n    if (n.toString.length > 1)\n      digital_root(n.toString.map(_.toString.toInt).foldLeft(0)(_ + _))\n    else\n      n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333642,"user_id":null,"body":"object SumOfDigits {\n\n  def digital_root(n: Int): Int = if ((\"\"+n).map(_-48).sum > 9) digital_root((\"\"+n).map(_-48).sum) else (\"\"+n).map(_-48).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"542c0f198e077084c0000c2e":[{"id":333643,"user_id":527,"body":"object Sol {\n  def divisors(n: Int): Int = (1 to n).count(n % _ == 0)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333644,"user_id":null,"body":"object Sol {\n\n  def divisors(n: Int): Int = {\n    1.to(n).count(n % _ == 0)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333645,"user_id":null,"body":"object Sol {\n\ndef divisors(n: Int): Int = (1 to n\/2).count(d=>n%d==0)+1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333646,"user_id":null,"body":"object Sol {\n\n  def divisors(n: Int): Int = {\n    (1 to n).filter(n % _ == 0).length\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333647,"user_id":null,"body":"object Sol {\n\n  def divisors(n: Int): Int = {\n    var sum = 0\n    \n    for (w <- 1 to n) if (n%w == 0)  sum += 1\n    \n    sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333648,"user_id":null,"body":"object Sol {\n  def divisors(n: Int): Int = (1 to n).toList.filter(n%_ == 0).length\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333649,"user_id":null,"body":"import scala.collection.mutable.ArrayBuffer\n\nobject Sol {\n\n  def divisors(n : Int) : Int = {\n    if (n == 0) return 0\n    if (n == 1) return 1\n    val array = ArrayBuffer.range(1,n+1)\n    array.count(i => n%i == 0)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333650,"user_id":null,"body":"object Sol {\n  def divisors(n: Int): Int = (1 to n \/ 2)\n    .filter(n % _ == 0)\n    .appended(n)\n    .toSet\n    .size\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333651,"user_id":null,"body":"object Sol {\n\n  def divisors(n: Int): Int = {\n    \/\/ your code here\n    \n    def rec (acc: Int, m: Int, divisors: Set[Int]): Int = {\n      m match {\n        case 1 => acc\n        case k if !divisors.contains(k) && n % k == 0 => \n          val accNew = if (n \/ k == k) acc + 1 else acc + 2\n          rec(accNew, m - 1, divisors ++ Set(n \/ k, k))\n        case k => rec(acc, m - 1, divisors)\n      }\n    }\n    \n    if (n == 1) 1 \n    else rec(2, n \/ 2, Set.empty)\n  }\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333652,"user_id":null,"body":"object Sol {\n\n  def divisors(n: Int): Int = {\n    \/\/ your code here\n    recFindDiv(n).size\n  }\n  \n  def recFindDiv(n: Int, divider: Int = 1): List[Int] =\n    (n % divider) match {\n      case x if (x != 0) => recFindDiv(n, divider + 1)\n      case x if (x == 0 & n == divider) => n :: Nil\n      case x if (x == 0 & n != divider) => divider :: recFindDiv(n, divider + 1)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5467e4d82edf8bbf40000155":[{"id":333653,"user_id":573,"body":"object Order {\n  \n  def descending_order(n: Int): Int =\n    n.toString.sorted.reverse.toInt\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333654,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int = num.toString.sortBy(-_).toInt\n  \/\/longer, but more readable: num.toString.sorted.reverse.toInt\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333655,"user_id":573,"body":"object Order {\n  \n  def descending_order(n: Int): Int =\n    n.toString.sortBy(-_).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333656,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int = num.toString.toList.sorted(Ordering.Char.reverse).mkString(\"\").toInt\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333657,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int = {\n    num.toString.toList.sorted.reverse.mkString.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333658,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int =\n    num.toString.toList.map(x => x.asDigit).sorted.reverse.mkString(\"\").toInt\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333659,"user_id":null,"body":"object Order {\n  \n  \/\/ sorts digits of num in descending order\n  def descending_order(num: Int): Int = {\n    (\"\"+num).map(_-48).sortWith(_>_).mkString(\"\").toInt\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333660,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int = {\n  @scala.annotation.tailrec\n  def splitToList(number : Int, list : List[Int] = List()) : List[Int] = number match {\n    case x if x <= 0 => list\n    case _ => splitToList(number\/10, number%10 :: list)\n  }\n  splitToList(num).sorted.reverse.fold(0){(a,b) => 10*a + b}\n}\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333661,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int = {\n    num.toString.sortWith((a: Char, b: Char) => a > b)\n  }.toInt\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333662,"user_id":null,"body":"object Order {\n  \n  def descending_order(num: Int): Int = num.toString.map(_.asDigit).sortBy(- _).mkString.toInt \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"546f922b54af40e1e90001da":[{"id":333663,"user_id":573,"body":"object Kata {\n\n  def alphabet_position(text: String): String =\n    text.filter(_.isLetter).map(_.toLower - 96).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333664,"user_id":527,"body":"object Kata {\n  def alphabet_position(text: String): String =\n    text.filter(_.isLetter).map(_.toLower - 'a' + 1).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333665,"user_id":573,"body":"object Kata {\n\n  def alphabet_position(text: String): String =\n    text.collect { case c if c.isLetter => c.toLower - 96 }.mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333666,"user_id":null,"body":"object Kata {\n\n  def alphabet_position(text: String): String = \n    text.filter(_.isLetter).map(c => c.asDigit - 9).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333667,"user_id":null,"body":"object Kata {\n\n    def alphabet_position(text: String): String = {\n      val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n      val textList: List[String] = text.toLowerCase.toList.map(_.toString)\n      val result: String = textList.map{ x=>alphabet.contains(x) match {\n        case true => alphabet.indexOf(x)+1\n        case _ => \"-\"\n        }\n      }.filter(_ != \"-\").mkString(\" \")\n      result\n    }\n\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333668,"user_id":null,"body":"object Kata {\n\n  val LetterOffset = 96;\n\n  def alphabet_position(text: String): String = {\n    text.foldLeft(Seq.empty[Int])((res, curr) => {\n      if (curr.isLetter) res :+ (curr.toLower.toInt - LetterOffset) else res\n    }).mkString(\" \");\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333669,"user_id":null,"body":"object Kata {\n\n  val alphabet = \" abcdefghijklmnopqrstuvwxyz\"\n\n  def alphabet_position(text: String): String = \n    text\n      .toLowerCase\n      .map(c => alphabet.indexOf(c))\n      .filter(_ > 0)\n      .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333670,"user_id":null,"body":"object Kata {\n\n  def alphabet_position(text: String): String = \n   text.toUpperCase().replaceAll(\"[^A-Z]\",\"\").flatMap(x => s\"${x.toInt - 64} \").trim\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333671,"user_id":null,"body":"object Kata {\n\n  def alphabet_position(text: String): String = {\n    text.toLowerCase().map(x => if(x.toInt > 96 && x.toInt < 123) x.toInt - 96 else 0).filter(_ > 0).mkString(\" \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333672,"user_id":null,"body":"object Kata {\n\n  def alphabet_position(text: String): String = text.toLowerCase.map(alpha.get).flatten.mkString(\" \")\n  \n  val alpha = ('a' :: ('a'.to('z').toList)).zipWithIndex.toMap\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"547202bdf7587835d9000c46":[{"id":333673,"user_id":1802,"body":"object Monads {\n\n  import scala.language.higherKinds\n\n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n\n  trait Monoid[A] {\n    def mempty: A\n\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] =\n        Identity(a)\n\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] =\n        amb(ma.a)\n    }\n  }\n\n  sealed trait Maybe[+A]\n\n  case class Just[A](a: A) extends Maybe[A]\n\n  case object None extends Maybe[Nothing]\n\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] =\n        Just(a)\n\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] =\n        ma match {\n          case Just(a) => amb(a)\n          case None => None\n        }\n    }\n  }\n\n  case class State[S, A](run: S => (S, A))\n\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a] = State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] =\n        State(s => (s, a))\n\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] =\n        State(s1 => {\n          val (s2, a) = ma.run(s1)\n          val (s3, b) = amb(a).run(s2)\n          (s3, b)\n        })\n    }\n  }\n\n  case class Reader[R, A](run: R => A)\n\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a] = Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] =\n        Reader(_ => a)\n\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] =\n        Reader(r => {\n          val a = ma.run(r)\n          val b = amb(a).run(r)\n          b\n        })\n    }\n  }\n\n  case class Writer[W, A](run: (W, A))\n\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a] = Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] =\n        Writer(m.mempty, a)\n\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n        val (w1, a) = ma.run\n        val (w2, b) = amb(a).run\n        Writer(m.mappend(w1)(w2) -> b)\n      }\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333674,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n  \n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n  \n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = Identity(amb(ma.a).a)\n    }\n  }\n\n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] =  ma match {\n        case None => None\n        case Just(a) => amb(a)\n      }\n    }\n  }\n\n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State(x => (x, a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = State(s1 => ma.run(s1) match {\n        case (s, a) => amb(a).run(s)\n      })\n    }\n  }\n\n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader(r => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = Reader(r => ma.run(r) match {\n        case a => amb(a).run(r)\n      })\n    }\n  }\n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer((m.mempty, a))\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = ma.run  match {\n        case (w,a) if w == m.mempty => Writer(amb(a).run)\n        case (w,a) => Writer(w, amb(a).run._2)\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333675,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n  \n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n  \n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n    }\n  }\n  \n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] = ma match {\n      case None => None\n      case Just(a) => amb(a)\n      }\n    }\n  }\n  \n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State( s => (s,a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = {\n        State(\n          ma.run.andThen{case (s,a) => amb(a).run(s)}\n        )\n      }\n    }\n  }\n  \n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader( _ => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = \n        Reader( r => amb(ma.run(r)).run(r))\n    }\n  }\n  \n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer(m.mempty -> a)\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n        val (wa, a) = ma.run\n        val (wb, b) = amb(a).run\n        val w = m.mappend(wa)(wb)\n        Writer((w, b))\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333676,"user_id":null,"body":"object Monads {\n\n    trait Monad[M[_]] {\n      def unit[A](a: A): M[A]\n      def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n    }\n\n    trait Monoid[A] {\n      def mempty: A\n      def mappend(x: A)(y: A): A\n    }\n\n\n    case class Identity[A](a: A)\n    object Identity {\n      implicit val identityMonad = new Monad[Identity] {\n        def unit[A](a: A): Identity[A] = new Identity[A](a)\n        def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n      }\n    }\n\n    sealed trait Maybe[+A]\n    case class Just[A](a: A) extends Maybe[A]\n    case object None extends Maybe[Nothing]\n    object Maybe {\n      implicit val maybeMonad = new Monad[Maybe] {\n        def unit[A](a: A): Maybe[A] = new Just[A](a)\n        def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] = ma match {\n          case Just(a) => amb(a)\n          case None => None\n        }\n      }\n    }\n\n    case class State[S, A](run: S => (S, A))\n    object State {\n      \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n      implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n        def unit[A](a: A): State[S, A] = State(env => (env, a))\n        def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = {\n         State(env => {\n           val run1 = ma.run(env)\n           amb(run1._2).run(run1._1)\n         })\n        }\n      }\n    }\n\n    case class Reader[R, A](run: R => A)\n    object Reader {\n      implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n        def unit[A](a: A): Reader[R, A] = Reader(_ => a)\n        def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = {\n          Reader[R,B](env => amb(ma.run(env)).run(env))\n        }\n      }\n    }\n\n    case class Writer[W, A](run: (W, A))\n    object Writer {\n      implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n        def unit[A](a: A): Writer[W, A] = Writer(m.mempty, a)\n        def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n          val runA: (W, A) = ma.run\n          val runB: (W, B) = amb(runA._2).run\n          Writer(m.mappend(runA._1)(runB._1),runB._2)\n        }\n      }\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333677,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n\n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n\n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n    }\n  }\n\n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] =\n        ma match {\n        case Just(a) => amb(a)\n        case None => None\n      }\n    }\n  }\n\n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State(s => (s,a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = {\n        State(s1 => {\n          val (s2, a) = ma.run(s1)\n          amb(a).run(s2)\n        })\n      }\n    }\n  }\n\n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader(_ => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = {\n        Reader(r =>{\n          val a = ma.run(r)\n          amb(a).run(r)\n        })\n      }\n    }\n  }\n\n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer(m.mempty, a)\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n        val (w1, a) = ma.run\n        val (w2, b) = amb(a).run\n        Writer((m.mappend(w1)(w2), b))\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333678,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n  \n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n  \n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = {\n        ma match {\n         case Identity(x) => amb(x)\n        }\n      }\n    }\n  }\n  \n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] =  {\n        ma match {\n          case Just(x) => amb(x)\n          case None => None\n        }\n      }\n    }\n  }\n  \n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State(x => (x, a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = {\n        ma match {\n          case State(run) => State(s => {\n            val (ss, a) = run(s)\n            val State(run2) = amb(a)\n            run2(ss)\n          })\n        }\n      }\n    }\n  }\n  \n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader((x) => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = {\n        ma match {\n          case Reader(run) => Reader(r => {\n            val a = run(r)\n            val Reader(run2) = amb(a)\n            run2(r)\n          })\n        }\n      }\n    }\n  }\n  \n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer((m.mempty, a))\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n        ma match {\n          case Writer(run) => {\n            val (w, a) = run\n            val Writer(run2) = amb(a)\n            val (ww, b) = run2\n            Writer(m.mappend(w)(ww), b)\n          }\n        }\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333679,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n  \n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n  \n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n    }\n  }\n  \n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] = ma match {\n        case None    => None\n        case Just(a) => amb(a)\n      }\n    }\n  }\n  \n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State(s => (s, a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] =\n        State(s0 => {\n          val (s1, a) = ma.run(s0)\n          amb(a).run(s1)\n        })\n    }\n  }\n  \n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader(r => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = \n        Reader(r0 => amb(ma.run(r0)).run(r0))\n    }\n  }\n  \n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer(m.mempty, a)\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n        val (w, a)  = ma.run\n        val (w1, b) = amb(a).run\n        Writer((m.mappend(w)(w1), b))\n      }\n    }\n  }\n}\n\nobject Main extends App {\n    import Monads._\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333680,"user_id":null,"body":"object Monads {\n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n\n  trait Monoid[A] {\n    def mempty: A\n\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n    }\n  }\n\n  sealed trait Maybe[+A]\n\n  case class Just[A](a: A) extends Maybe[A]\n\n  case object None extends Maybe[Nothing]\n\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] =\n        ma match {\n          case Just(a) => amb(a)\n          case None => None\n        }\n    }\n  }\n\n  case class State[S, A](run: S => (S, A))\n\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a] = State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State(S => (S, a))\n      \n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = State(s => amb(ma.run(s)._2).run(ma.run(s)._1))\n    }\n  }\n\n  case class Reader[R, A](run: R => A)\n\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a] = Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader(_ => a)\n\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = Reader(r => amb(ma.run(r)).run(r))\n    }\n  }\n\n  case class Writer[W, A](run: (W, A))\n\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a] = Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer((m.mempty, a))\n\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = Writer((m.mappend(amb(ma.run._2).run._1)(ma.run._1), amb(ma.run._2).run._2))\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333681,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n\n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n\n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n    }\n  }\n\n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] =  ma match {\n        case None => None\n        case Just(a) => amb(a)\n      }\n    }\n  }\n\n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State(s => (s, a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] =\n                State{s => val st = ma.run(s)\n          amb(st._2).run(st._1)\n        }\n    }\n  }\n\n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader(_ => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = \n        Reader(r => amb(ma.run(r)).run(r))\n    }\n  }\n\n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer(m.mempty,a)\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = {\n        val mb: Writer[W, B] = amb(ma.run._2)\n        new Writer((m.mappend(ma.run._1)(mb.run._1), mb.run._2))\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333682,"user_id":null,"body":"object Monads {\n  import scala.language.higherKinds\n  \n  trait Monad[M[_]] {\n    def unit[A](a: A): M[A]\n    def bind[A, B](ma: M[A])(amb: A => M[B]): M[B]\n  }\n  \n  trait Monoid[A] {\n    def mempty: A\n    def mappend(x: A)(y: A): A\n  }\n\n\n  case class Identity[A](a: A)\n  object Identity {\n    implicit val identityMonad = new Monad[Identity] {\n      def unit[A](a: A): Identity[A] = Identity(a)\n      def bind[A, B](ma: Identity[A])(amb: A => Identity[B]): Identity[B] = amb(ma.a)\n    }\n  }\n  \n  sealed trait Maybe[+A]\n  case class Just[A](a: A) extends Maybe[A]\n  case object None extends Maybe[Nothing]\n  object Maybe {\n    implicit val maybeMonad = new Monad[Maybe] {\n      def unit[A](a: A): Maybe[A] = Just(a)\n      def bind[A, B](ma: Maybe[A])(amb: A => Maybe[B]): Maybe[B] = ma match {\n        case Just(a) => amb(a)\n        case None => None\n      }\n    }\n  }\n  \n  case class State[S, A](run: S => (S, A))\n  object State {\n    \/\/ inspired by https:\/\/stackoverflow.com\/a\/6248296\n    implicit def stateMonad[S] = new Monad[({type x[a]=State[S, a]})#x] {\n      def unit[A](a: A): State[S, A] = State( s => (s, a))\n      def bind[A, B](ma: State[S, A])(amb: A => State[S, B]): State[S, B] = State({s =>\n        val (s2, a) = ma.run(s)\n        amb(a).run(s2)\n      })\n    }\n  }\n  \n  case class Reader[R, A](run: R => A)\n  object Reader {\n    implicit def readerMonad[R] = new Monad[({type x[a]=Reader[R, a]})#x] {\n      def unit[A](a: A): Reader[R, A] = Reader(_ => a)\n      def bind[A, B](ma: Reader[R, A])(amb: A => Reader[R, B]): Reader[R, B] = Reader { r =>\n        amb(ma.run(r)).run(r)\n      }\n    }\n  }\n  \n  case class Writer[W, A](run: (W, A))\n  object Writer {\n    implicit def readerMonad[W](implicit m: Monoid[W]) = new Monad[({type x[a]=Writer[W, a]})#x] {\n      def unit[A](a: A): Writer[W, A] = Writer((m.mempty, a))\n      def bind[A, B](ma: Writer[W, A])(amb: A => Writer[W, B]): Writer[W, B] = ma match {\n        case Writer ((w, a)) => {\n          val Writer((ww, b)) = amb(a)\n          Writer((m.mappend(w)(ww), b))\n        }\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54b42f9314d9229fd6000d9c":[{"id":333683,"user_id":527,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val wordLower = word.toLowerCase\n    val charCounts = wordLower.groupBy(identity).mapValues(_.size)\n    wordLower.map(c => if (charCounts(c) > 1) ')' else '(')\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333684,"user_id":null,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    word.toLowerCase.map(c => if (word.toLowerCase.count(_ == c) <= 1) \"(\" else \")\").mkString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333685,"user_id":573,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val wordLower = word.toLowerCase\n    val charCounts = wordLower.groupMapReduce(identity)(_ => 1)(_ + _)\n    wordLower.map(c => if (charCounts(c) > 1) ')' else '(')\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333686,"user_id":null,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val w = word.toLowerCase\n    w.map {\n      case l if w.indexOf(l) == w.lastIndexOf(l) => \"(\"\n      case _ => \")\"\n    }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333687,"user_id":516,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val lowerCase = word.toLowerCase\n    val distinct = lowerCase.groupBy(identity).mapValues(_.size)\n    lowerCase.map(ch => if(distinct(ch) == 1) '(' else ')')\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333688,"user_id":null,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val map = scala.collection.mutable.Map[Char, Int]()\n    \n    word.foreach(x => {\n      val xLowerCase = x.toLower\n      if (map.contains(xLowerCase)) map(xLowerCase) = map(xLowerCase) + 1\n      else map(xLowerCase) = 1\n    })\n\n    word.map(x => if (map(x.toLower) > 1) ')' else '(')\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333689,"user_id":null,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val counts = word.toLowerCase.groupBy(identity).mapValues(x => if (x.size>1) ')' else '(' )\n    word.toLowerCase.map(counts).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333690,"user_id":751,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val encoder = word.toLowerCase.groupBy(identity).mapValues(cs => if(cs.size >1) ')' else '(')\n    word.toLowerCase.map(encoder)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333691,"user_id":null,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    val lowerCase = word.toLowerCase\n    lowerCase.map(c => if (lowerCase.indexOf(c) == lowerCase.lastIndexOf(c)) '(' else ')' )\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333692,"user_id":null,"body":"object Solution {\n\n  def duplicate_encode(word: String) = {\n    word.toLowerCase().map(x => if (word.toLowerCase().count(_ == x) > 1) \")\" else \"(\").mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54b724efac3d5402db00065e":[{"id":333693,"user_id":573,"body":"import MorseCodes.morseCodes\n\nobject MorseDecoder {\n\n  def decode(msg: String) =\n    msg.trim.split(\"   \").map(_.split(' ').map(morseCodes).mkString).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333694,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode(msg: String) =\n    msg.trim.split(\" {3}\").map(_.split(\" \").map(morseCodes).mkString).mkString(\" \")\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333695,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  private val morseWordsSeparator: String = \"\\\\s{3}\"\n  private val morseCharactersSeparator: String = \"\\\\s{1}\"\n  private val redundantWhitespaces: String = \"\"\"^\\s+|\\s+$\"\"\"\n\n  def decode(msg: String): String = msg\n    .replaceAll(redundantWhitespaces, \"\")\n    .split(morseWordsSeparator)\n    .map(word => word\n      .split(morseCharactersSeparator)\n      .map(char => MorseCodes.morseCodes(char))\n      .mkString(\"\"))\n    .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333696,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode(msg: String) = \n    msg.trim.split(\"   \")\n    .map(s => s.split(\" \").map(morseCodes).mkString)\n    .mkString(\" \")\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333697,"user_id":574,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode(msg: String) = msg.split(\"   \")\n          .map(_.split(\" \").filterNot(_.isEmpty).map(morseCodes).mkString)\n          .filterNot(_.isEmpty).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333698,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode(msg: String) = msg.trim.split(\"\\\\s{1,2}\").map(x => morseCodes.getOrElse(x, \" \")).mkString(\"\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333699,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decodeWord(word: String) = word.split(\" \").map(morseCodes(_)).mkString\n  \n  def cleanMsg(msg: String) = msg.replaceAll(\"(^ +)|( +$)\", \"\")\n  \n  def decode(msg: String) = cleanMsg(msg).split(\"   \").map(decodeWord(_)).mkString(\" \")\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333700,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode(msg: String): String = {\n    msg.trim.split(\"\\\\s\\\\s+\").map(_.split(\"\\\\s+\").map((c) => morseCodes(c)).mkString(\"\")).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333701,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode(msg: String) = {\n    val list = msg.trim.replaceAll(\"\\\\s{2,}?\", \" \").split(\" \").map{\n      code =>\n        if (code != \"\") morseCodes(code) else \" \"\n    }\n    list.mkString    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333702,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n   def decode(msg: String): String = {\n      msg.split(\"   \").map(word => word.split(\" \").map(letter => morseCodes.get(letter).getOrElse(\"\"))).map(word => word.mkString(\"\")).mkString(\" \").trim\n     }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54b72c16cd7f5154e9000457":[{"id":333703,"user_id":636,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode_bits(bitsRaw:String):String = {\n    \n    val bits = bitsRaw.dropWhile(_=='0').reverse.dropWhile(_=='0').reverse\n      \n    val timeUnit = Array(bits.split(\"0\").filterNot(_ == \"\").distinct,\n      bits.split(\"1\").filterNot(_ == \"\").distinct).flatten.map(_.length).min\n    \n    val signal = bits.grouped(timeUnit).map(_.take(1)).toArray :+ \"X\"\n        \n    signal\n      .sliding(2)\n      .foldLeft(\"\")((t,c) =>\n        if (c(0) == c(1)) t+c(0)\n        else t+c(0)+\" \").trim.split(\" \")\n      .map(code =>\n        (code(0), code.size) match {\n          case ('0',7) => \"   \" \/\/ new word\n          case ('0',3) => \" \" \/\/ new character\n          case ('0',1) => \"\" \/\/ pause between elements\n          case ('1',1) => \".\" \/\/ dot\n          case ('1',3) => \"-\" \/\/ dash\n          case _ => throw new RuntimeException(\"Decoding Error\")\n        }\n      ).mkString(\"\")\n  }\n  \n  \n  def decode_morse(morseCode:String):String = {\n    morseCode.trim.split(\"   \") \/\/words\n      .map(_.split(\" \")) \/\/letters\n      .map(_.map(morseCodes).mkString)\n      .mkString(\" \")\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333704,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode_morse(morseCode: String): String = morseCode.trim.split(\"  \").map(_.trim.split(\" \").map(morseCodes).mkString(\"\")).mkString(\" \")\n\n  def decode_bits(bits: String): String = {\n    val trimmedBits = bits.dropWhile(_ == '0').reverse.dropWhile(_ == '0').reverse\n\n    val timeUnit = (trimmedBits.split(\"0+\").filterNot(_.isEmpty).map(_.length) ++ trimmedBits.split(\"1+\").filterNot(_.isEmpty).map(_.length)).minOption.getOrElse(0)\n\n    trimmedBits\n      .replace(\"1\" * timeUnit * 3, \"-\")\n      .replace(\"1\" * timeUnit, \".\")\n      .replace(\"0\" * timeUnit * 7, \"   \")\n      .replace(\"0\" * timeUnit * 3, \" \")\n      .replace(\"0\", \"\")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333705,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode_bits(bits:String):String = {\n    val trimmed = bits.replaceAll(\"^0*|0*$\", \"\")\n    val maybeDot = trimmed.split(\"0+\").map(_.length).min\n    val len = trimmed.replaceAll(\"^1+|1+$\",\"\").split(\"1+\").map(_.length).filter(_ > 0).minOption.map(math.min(_, maybeDot)).getOrElse(maybeDot)\n    trimmed.replaceAll(\"^0*|0*$\", \"\").replaceAll(s\"0{${7*len}}\", \"   \").replaceAll(s\"0{${3*len}}\", \" \")\n      .replaceAll(s\"1{${3*len}}0{0,${len}}\", \"-\").replaceAll(s\"1{${len}}0{0,${len}}\", \".\")\n  }\n \n  def decode_morse(msg:String):String = msg.trim.split(\"   \").map(\n    _.trim.split(\" \").map(morseCodes(_)).mkString\n  ).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333706,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  \/**\n    * 1.\u53bb\u5934\u5c3e\u76840\n    * 2.\u6839\u636e\u6700\u77ed\u7684\u8fde\u7eed\u6570\u5b57\u63a8\u65ad\u901f\u7387\n    * 3.\u6309\u901f\u7387\u89e3\u7801\n    *\/\n  def decode_bits(bits: String): String = {\n    val cutHeadTail = bits.replaceAll(\"^0*\", \"\").replaceAll(\"0*$\", \"\")\n    \/\/\u5982\u679c\u5168\u662f1\uff0c\u90a3\u4e48\u5c31\u662f\u4e00\u4e2a.\u4fe1\u53f7\n    if (cutHeadTail.matches(\"1*\")) \".\" else {\n      val unit = math.min(\n        cutHeadTail.split(\"0\").map(_.length).filter(_ > 0).min,\n        cutHeadTail.split(\"1\").map(_.length).filter(_ > 0).min\n      )\n      val (dot, dash, charSep, wordSep) = (\"1\" * unit, \"1\" * 3 * unit, \"0\" * 3 * unit, \"0\" * 7 * unit)\n      cutHeadTail.split(wordSep).map(_.replace(dash, \"-\").replace(dot, \".\")\n        .replace(charSep, \" \").replace(\"0\", \"\")).mkString(\"   \")\n    }\n  }\n\n  def decode_morse(morseCode: String): String = morseCode.trim.split(\" {3}\")\n    .map(w => w.trim.split(\" \").map(morseCodes).mkString)\n    .mkString(\" \")\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333707,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def trim(bits: String): String =\n    bits.replaceAll(\"^0+1\", \"1\").replaceAll(\"10+$\", \"1\")\n\n  def repeat(s: String, n: Int, rs: String = \"\"): String =\n    if (n > 0) repeat(s, n - 1, rs + s)  else rs\n\n  def findShortestRange(bits: String, s: Int = Int.MaxValue): Int =\n    if (bits.nonEmpty) {\n      val l = bits.takeWhile(_ == bits.head).length\n      findShortestRange(bits.drop(l), Math.min(s, l))\n    } else s\n\n  def decode_bits(bits: String): String = {\n    val trimmed = trim(bits)\n    val base = findShortestRange(trimmed)\n\n    val dot = repeat(\"1\", base)\n    val dash = dot + \"1+\"\n\n    val dotBreak = repeat(\"0\", base)\n    val letterBreak = repeat(dotBreak, 3)\n    val wordBreak = letterBreak + \"0+\"\n\n    trimmed\n      .split(wordBreak)\n      .map(\n        _\n          .split(letterBreak + \"+\")\n          .map(\n            _\n              .replaceAll(dash, \"-\")\n              .replaceAll(dot, \".\")\n              .replaceAll(\"0\", \"\")\n          )\n          .mkString(\" \")\n      )\n      .mkString(\"   \")\n  }\n  \n  def decode_morse(morseCode:String):String = {\n    morseCode\n      .split(\"   \")\n      .map(_.split(\" \").map(morseCodes).mkString(\"\"))\n      .mkString(\" \")\n  } \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333708,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  \/\/ More or less optimized for resource usage\n  def decode_bits(bits: String): String = {\n    if (bits.isEmpty)\n      return \"\"\n\n    val firstRealIdx = bits.indexOf('1')\n    val lastRealIdx  = bits.lastIndexOf('1')\n\n    \/\/ Loop through (real) characters and do the action for each consecutive same-bit sequence\n    def loopThroughChars(processSequence: (Char, Int) => Unit) = {\n      var currChar: Char = bits(firstRealIdx)\n      var currSeqLen = 1\n\n      for (i <- (firstRealIdx + 1) to lastRealIdx) {\n        val c = bits(i)\n        c match {\n          case c if c == currChar =>\n            currSeqLen += 1\n          case _ =>\n            processSequence(currChar, currSeqLen)\n            currChar = c\n            currSeqLen = 1\n        }\n      }\n      processSequence(currChar, currSeqLen)\n    }\n\n    val timeUnit: Int = {\n      var minLen = Int.MaxValue\n      loopThroughChars((bit, len) => minLen = minLen min len)\n      minLen\n    }\n\n    val timeUnit3 = timeUnit * 3\n    val timeUnit7 = timeUnit * 7\n\n    val sb = new StringBuilder\n\n    loopThroughChars((bit, len) => {\n      (bit, len) match {\n        case ('1', `timeUnit3`) => sb.append(\"-\")\n        case ('1', `timeUnit`)  => sb.append(\".\")\n        case ('0', `timeUnit7`) => sb.append(\"   \")\n        case ('0', `timeUnit3`) => sb.append(\" \")\n        case ('0', `timeUnit`)  => \/\/ NOOP\n        case _ =>\n          throw new MatchError(s\"${(bit, len)}, timeUnit=$timeUnit, sb=$sb, bits=$bits\")\n      }\n    })\n\n    sb.toString()\n  }\n  \n  def decode_morse(morseCode: String): String = {\n    morseCode.split(\"   \").map(_.split(' ').map(morseCodes).mkString).mkString(\" \")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333709,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject MorseDecoder {\n  import MorseCodes.morseCodes\n\n  private def findShortestConsecutiveOnes(bits: String): Int = {\n    var minLen = Int.MaxValue\n\n    val firstRealIdx = bits.indexOf('1')\n    val lastRealIdx  = bits.lastIndexOf('1')\n\n    var currChar: Char = bits(firstRealIdx)\n    var currSeqLen = 1\n\n    for (i <- (firstRealIdx + 1) to lastRealIdx) {\n      val c = bits(i)\n      c match {\n        case c if c == currChar =>\n          currSeqLen += 1\n        case _ =>\n          minLen = minLen min currSeqLen\n          currChar = c\n          currSeqLen = 1\n      }\n    }\n    minLen = minLen min currSeqLen\n    if (minLen == Int.MaxValue) {\n      throw new IllegalStateException(\"Failed to process \" + bits)\n    }\n    minLen\n  }\n\n  def decode_bits(bits: String): String = {\n    if (bits.isEmpty)\n      return \"\"\n\n    val timeUnit: Int = findShortestConsecutiveOnes(bits)\n    val timeUnit3 = timeUnit * 3\n    val timeUnit7 = timeUnit * 7\n\n    val sb = new StringBuilder\n\n    var currChar: Char = bits(0)\n    var currSeqLen = 1\n\n    def append(isEnd: Boolean): Unit = {\n      val startOrEnd = sb.isEmpty || isEnd\n      (currChar, currSeqLen) match {\n        case ('1', `timeUnit3`)                => sb.append(\"-\")\n        case ('1', `timeUnit`)                 => sb.append(\".\")\n        case ('0', `timeUnit7`) if !startOrEnd => sb.append(\"   \")\n        case ('0', `timeUnit3`) if !startOrEnd => sb.append(\" \")\n        case ('0', `timeUnit`) if !startOrEnd  => \/\/ NOOP\n        case ('0', _) if startOrEnd            => \/\/ NOOP\n        case _ =>\n          throw new MatchError(s\"${(currChar, currSeqLen)}, timeUnit=$timeUnit, isEnd=$isEnd, sb=$sb, bits=$bits\")\n      }\n    }\n\n    for (i <- 1 until bits.length) {\n      val c = bits(i)\n      if (c == currChar) {\n        currSeqLen += 1\n      } else {\n        append(false)\n        currChar = c\n        currSeqLen = 1\n      }\n    }\n    append(true)\n    sb.toString()\n  }\n\n  def decode_morse(morseCode: String): String = {\n    morseCode.split(\"   \").map(_.split(' ').map(morseCodes).mkString).mkString(\" \")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333710,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode_morse(msg: String) : String = {\n    if(msg.isEmpty) return \"\"\n    val morseLetters = msg.trim.split(\"   \").map(_.split(\" \"))\n    val writtenLetters = morseLetters.map(_.map(l => morseCodes(l)))\n    writtenLetters.map(_.mkString).mkString(\" \")\n  }\n\n\n  def findTimeUnit(onesLengths : Array[Int], zerosLengths: Array[Int]) : Int = {\n    if(zerosLengths.isEmpty || onesLengths.min < zerosLengths.min) onesLengths.min\n    else zerosLengths.min\n  }\n\n\n  def convertBitsToDotsOrLinesOrSpaces(bits : String, timeUnit : Int) : String = {\n    val dot = \"1\" * timeUnit\n    val line = \"1\" * timeUnit * 3\n    val charSpace = \"0\" * timeUnit\n    val letterSpace = \"0\" * timeUnit * 3\n    if(bits == dot) \".\"\n    else if(bits == line) \"-\"\n    else if(bits == charSpace) \"\"\n    else if(bits == letterSpace) \" \"\n    else \"   \"\n  }\n\n  def checkIfMessageIsEmpty(bits: String) : Boolean = !bits.exists(_ == '1')\n\n  def decode_bits(bits : String) : String = {\n    if(checkIfMessageIsEmpty(bits)) return \"\"\n    val trimmedBits = bits.substring(bits.indexOf(\"1\"), bits.lastIndexOf(\"1\")+1)\n    val zeros = trimmedBits.split(\"1\").filter(_.nonEmpty)\n    val ones = trimmedBits.split(\"0\").filter(_.nonEmpty)\n    val timeUnit = findTimeUnit(ones.map(_.length), zeros.map(_.length))\n    var morseString = \"\"\n    for(i <- ones.indices) {\n      if(i == ones.length-1) morseString += convertBitsToDotsOrLinesOrSpaces(ones(i), timeUnit)\n      else {\n        morseString += convertBitsToDotsOrLinesOrSpaces(ones(i), timeUnit)\n        morseString += convertBitsToDotsOrLinesOrSpaces(zeros(i), timeUnit)\n      }\n    }\n    morseString\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333711,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode_morse(msg: String) : String = {\n    val morseLetters = msg.trim.split(\"   \").map(_.split(\" \"))\n    val writtenLetters = morseLetters.map(_.map(l => morseCodes(l)))\n    val words = writtenLetters.map(_.mkString)\n    words.mkString(\" \")\n  }\n\n\n  def findTimeUnit(bits : String) : Int = {\n    val zeros = bits.split(\"1\").map(_.length).filter(_ > 0)\n    val ones = bits.split(\"0\").map(_.length).filter(_ > 0)\n    if(ones.isEmpty) zeros.min\n    else if(zeros.isEmpty) ones.min\n    else if(zeros.min < ones.min) zeros.min\n    else ones.min\n  }\n\n  def convertBitsToDotsAndLines(bits : String, timeUnit : Int) : String = {\n    val dot = \"1\" * timeUnit\n    val line = \"1\" * timeUnit * 3\n    val charSpace = \"0\" * timeUnit\n    val letterSpace = \"0\" * timeUnit * 3\n    if(bits == dot) \".\"\n    else if(bits == line) \"-\"\n    else if(bits == charSpace) \"\"\n    else if(bits == letterSpace) \" \"\n    else \"   \"\n  }\n\n  def decode_bits(bits : String) : String = {\n    val trimmedBits = bits.substring(bits.indexOf(\"1\"), bits.lastIndexOf(\"1\")+1)\n    val zeros = trimmedBits.split(\"1\").filter(_.length > 0)\n    val ones = trimmedBits.split(\"0\").filter(_.length > 0)\n    val timeUnit = findTimeUnit(trimmedBits)\n    var morseString = \"\"\n    for(i <- ones.indices) {\n      if(i == ones.length-1) morseString += convertBitsToDotsAndLines(ones(i), timeUnit)\n      else {\n        morseString += convertBitsToDotsAndLines(ones(i), timeUnit)\n        morseString += convertBitsToDotsAndLines(zeros(i), timeUnit)\n      }\n    }\n    morseString\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333712,"user_id":null,"body":"object MorseDecoder {\n  import MorseCodes.morseCodes\n\n  def decode_bits(bits:String):String = {\n   val in = bits.dropWhile(_ == '0')\n      .reverse\n      .dropWhile(_ == '0')\n      .reverse\n    val timeunit = (in.takeWhile(_ == in.head).length to 1 by -1)\n      .find(t => in.sliding(t, t).forall(s => s.length == t && s.forall(_ == s.head)))\n      .get\n    val cleanIn = in.sliding(timeunit, timeunit).map(_.head).mkString\n\n    def decode_bitsHelper(bits: String): String = {\n      if (bits.isEmpty) \"\"\n      else if (bits.startsWith(\"0000000\")) \"   \" + decode_bitsHelper(bits.drop(7))\n      else if (bits.startsWith(\"000\")) \" \" + decode_bitsHelper(bits.drop(3))\n      else if (bits.startsWith(\"111\")) \"-\" + decode_bitsHelper(bits.drop(3))\n      else if (bits.startsWith(\"0\")) \"\" + decode_bitsHelper(bits.drop(1))\n      else \".\" + decode_bitsHelper(bits.drop(1))\n    }\n    \n    decode_bitsHelper(cleanIn)\n  }\n  \n  def decode_morse(morseCode:String):String = \n    morseCode.trim\n    .replace(\"   \", \" | \")\n    .split(\" \")\n    .map(m => if (m == \"|\") \" \" else morseCodes(m))\n    .mkString\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54bd6b4c956834c9870001a1":[{"id":333713,"user_id":null,"body":"import java.lang.Boolean\n\nobject BagelSolver {\n  def getBagel: Bagel = {\n   val field = classOf[Boolean].getDeclaredField(\"value\")\n    field.setAccessible(true)\n    field.set(java.lang.Boolean.TRUE, java.lang.Boolean.FALSE)\n    new Bagel\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333714,"user_id":null,"body":"object BagelSolver {\n\n  def getBagel: Bagel = {\n    new Bagel\n  }\n}\n\ntrait Matchers extends org.scalatest.Matchers {\n  \n  implicit class BooleanMatcher(b: Boolean) {\n    def shouldBe(v: Boolean): Unit = ()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333715,"user_id":null,"body":"import org.scalatest.Bagel\nobject BagelSolver {\n  def getBagel: Bagel = {\n    new Bagel \/\/ fix it!\n  }\n}\n\npackage org.scalatest {\n  class Bagel {\n      def getValue = 4\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333716,"user_id":null,"body":"object BagelSolver {\n   def getBagel: Bagel = {\n    import java.lang.reflect.{Field, Modifier}\n    val f = classOf[java.lang.Boolean].getField(\"TRUE\")\n    val modifers = classOf[Field].getDeclaredField(\"modifiers\")\n    modifers.setAccessible(true)\n    modifers.setInt(f, f.getModifiers & ~Modifier.FINAL)\n    f.set(null, false)\n    new Bagel \/\/ fix it!\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333717,"user_id":null,"body":"import java.lang.reflect._\n\nobject BagelSolver {\n  def getBagel: Bagel = {\n    val field = classOf[java.lang.Boolean].getField(\"TRUE\")\n    field.setAccessible(true)\n    \/\/ Make it not final\n    val modifiersField = classOf[Field].getDeclaredField(\"modifiers\");\n    modifiersField.setAccessible(true);\n    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n    \/\/ Make true false !!\n    field.set(null, java.lang.Boolean.FALSE)\n    println(field)\n    new Bagel \/\/ fix it!\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333718,"user_id":null,"body":"import java.lang.reflect.Field\nimport java.lang.reflect.Modifier\n\nobject BagelSolver {\n  def getBagel = new Bagel\n  \n  \/\/ set true to false\n  val fTrue = classOf[java.lang.Boolean].getField(\"TRUE\")\n  val modifiers = classOf[Field].getDeclaredField(\"modifiers\")\n  modifiers.setAccessible(true)\n  modifiers.setInt(fTrue, fTrue.getModifiers & ~Modifier.FINAL)\n  fTrue.set(null, false)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333719,"user_id":53,"body":"object BagelSolver {\n  def getBagel: Bagel = {\n    try {\n      val field = classOf[java.lang.Boolean].getDeclaredField(\"value\")\n      field.setAccessible(true)\n      field.set(java.lang.Boolean.TRUE, java.lang.Boolean.FALSE)\n    } catch {\n      case e: Throwable => return null\n    }\n    new Bagel\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333720,"user_id":null,"body":"import java.lang.reflect._\n\nobject BagelSolver {\n  def setFinalStatic(field: Field, modifiersField: Field, newValue: Object): Unit = {\n    field.setAccessible(true)\n\n    modifiersField.setAccessible(true)\n    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL)\n\n    field.set(null, newValue)\n  }\n  \n  def getBagel: Bagel = {\n    setFinalStatic(Class.forName(\"java.lang.Boolean\").getField(\"TRUE\"), Class.forName(\"java.lang.reflect.Field\").getDeclaredField(\"modifiers\"), java.lang.Boolean.FALSE.asInstanceOf[Object])\n    new Bagel\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333721,"user_id":null,"body":"import java.lang.reflect.{Field, Modifier};\n\nobject BagelSolver {\n  \n  def getBagel: Bagel = {\n        \n    val f = classOf[java.lang.Boolean].getField(\"TRUE\")\n    val modifiers = classOf[Field].getDeclaredField(\"modifiers\")\n    modifiers.setAccessible(true)\n    modifiers.setInt(f, f.getModifiers & ~Modifier.FINAL)\n    f.set(null, false)\n    \n    new Bagel \/\/ fix it!\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333722,"user_id":null,"body":"import java.lang.reflect.{Field, Modifier}\n\nobject BagelSolver {\n  def getBagel: Bagel = {\n    \n    val f = classOf[java.lang.Boolean].getField(\"TRUE\")\n    f.setAccessible(true)\n    val m = classOf[Field].getDeclaredField(\"modifiers\")\n    m.setAccessible(true)\n    m.setInt(f, f.getModifiers & ~Modifier.FINAL);\n    f.set(null, false) \n    \n    new Bagel\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54bd79a7956834e767001357":[{"id":333723,"user_id":null,"body":"import java.util.Random\nobject Psychic {\n  \n  val rndField = classOf[Math].getDeclaredClasses.toList(0).getDeclaredFields.toList(0)\n  rndField.setAccessible(true)\n  rndField.get(null).asInstanceOf[Random].setSeed(0L)\n  \n  val rnd = new Random(0L)\n  \n  def guess(): Double = {\n    rnd.nextDouble()\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333724,"user_id":573,"body":"import java.util.Random\n\nobject Psychic {\n\n  def guess(): Double = {\n    val seed = getSeed(java.lang.Math.random())\n    new Random(seed).nextDouble()\n  }\n\n  \/\/ Reverse Random.nextDouble() computation to find back the seed:\n  def getSeed(nextDouble: Double): Long = {\n\n    val multiplier = 0x5DEECE66DL\n    val addend = 0xBL\n    val mask = (1L << 48) - 1\n\n    val coef = (nextDouble * (1L << 53)).toLong\n    val next26 = coef >>> 27\n    val next27 = coef & ((1L << 27) - 1)\n\n    val upper26 = (next26 << (48 - 26)) & mask\n    val upper27 = (next27 << (48 - 27)) & mask\n    val upper27Of48Mask = ((1L << 27) - 1) << (48 - 27)\n\n    val seed =\n      (upper26 to (upper26 | ((1L << (48 - 26)) - 1)))\n        .collectFirst {\n          case oldSeed if (((oldSeed * multiplier + addend) & mask) & upper27Of48Mask) == upper27 =>\n            (oldSeed * multiplier + addend) & mask\n        }\n\n    seed.get ^ multiplier\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333725,"user_id":null,"body":"object Psychic {\n  def guess(): Double = {\n    val seed = new java.util.Random().nextLong\n    val value = new java.util.Random(seed).nextDouble\n\n    val field = ClassLoader.getSystemClassLoader\n      .loadClass(\"java.lang.Math$RandomNumberGeneratorHolder\")\n      .getDeclaredField(\"randomNumberGenerator\")\n    field.setAccessible(true)\n    field.get(null).asInstanceOf[java.util.Random].setSeed(seed)\n\n    value\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333726,"user_id":null,"body":"object Psychic {\n  def guess(): AlwaysEqual = {\n    new AlwaysEqual\n  }\n\n  class AlwaysEqual {\n    override def equals(obj: Any): Boolean = {\n      obj match {\n        case (x: AlwaysEqual) => false\n        case _ => true\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333727,"user_id":null,"body":"object Psychic {\n  class ReplicatedRandom extends java.util.Random {\n      val  numerator: Long = (Math.random() * (1L << 53)).toLong\n      val first26: Int = (numerator >>> 27).toInt\n      val last27: Int = (numerator & ((1L << 27) - 1)).toInt\n      replicateState(first26, 26, last27, 27)\n\n\n    def replicateState(nextN: Int, n: Int, nextM: Int, m: Int) = {\n      val multiplier = 0x5DEECE66DL\n      val addend = 0xBL\n      val mask = (1L << 48) - 1\n      val upperMOf48Mask = ((1L << m) - 1) << (48 - m)\n\n      val oldSeedUpperN = (nextN.toLong << (48 - n)) & mask\n      val newSeedUpperM = (nextM.toLong << (48 - m)) & mask\n\n      val possibleSeeds =\n      (oldSeedUpperN to (oldSeedUpperN | ((1L << (48 - n)) - 1))).flatMap(os=>{\n        val newSeed = (os * multiplier + addend) & mask\n        if ((newSeed & upperMOf48Mask) == newSeedUpperM) List[Long](newSeed)\n        else List[Long]()\n      })\n\n      if (possibleSeeds.length == 1) setSeed(possibleSeeds.head ^ multiplier)\n    }\n  }\n\n  def guess(): Double = {\n    new ReplicatedRandom().nextDouble()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333728,"user_id":null,"body":"\/\/just hack it! based on: https:\/\/franklinta.com\/2014\/08\/31\/predicting-the-next-math-random-in-java\/\n\nclass ReplicatedRandom extends java.util.Random { \/\/ Replicate the state of a Random using a single value from its nextDouble\n  def replicateState(nextDouble: Double): Boolean = { \/\/ nextDouble() is generated from ((next(26) << 27) + next(27)) \/ (1L << 53)\n    \/\/ Inverting those operations will get us the values of next(26) and next(27)\n    val numerator = (nextDouble * (1L << 53)).toLong\n    val first26 = (numerator >>> 27).toInt\n    val last27 = (numerator & ((1L << 27) - 1)).toInt\n    replicateState(first26, 26, last27, 27)\n  }\n\n  import java.util\n\n  def replicateState(nextN: Int, n: Int, nextM: Int, m: Int): Boolean = { \/\/ Constants copied from java.util.Random\n    val multiplier = 0x5DEECE66DL\n    val addend = 0xBL\n    val mask = (1L << 48) - 1\n    val upperMOf48Mask = ((1L << m) - 1) << (48 - m)\n    \/\/ next(x) is generated by taking the upper x bits of 48 bits of (oldSeed * multiplier + addend) mod (mask + 1)\n    \/\/ So now we have the upper n and m bits of two consecutive calls of next(n) and next(m)\n    val oldSeedUpperN = (nextN.toLong << (48 - n)) & mask\n    val newSeedUpperM = (nextM.toLong << (48 - m)) & mask\n    \/\/ Bruteforce the lower (48 - n) bits of the oldSeed that was truncated.\n    \/\/ Calculate the next seed for each guess of oldSeed and check if it has the same top m bits as our newSeed.\n    \/\/ If it does then the guess is right and we can add that to our candidate seeds.\n    val possibleSeeds = new util.ArrayList[Long]\n    for (oldSeed <- oldSeedUpperN to (oldSeedUpperN | ((1L << (48 - n)) - 1))) {\n      val newSeed = (oldSeed * multiplier + addend) & mask\n      if ((newSeed & upperMOf48Mask) == newSeedUpperM) possibleSeeds.add(newSeed)\n    }\n    if (possibleSeeds.size == 1) { \/\/ If there's only one candidate seed, then we found it!\n      setSeed(possibleSeeds.get(0) ^ multiplier) \/\/ setSeed(x) sets seed to `(x ^ multiplier) & mask`, so we need another `^ multiplier` to cancel it out\n\n      return true\n    }\n    if (possibleSeeds.size >= 1) System.out.println(\"Didn't find a unique seed. Possible seeds were: \" + possibleSeeds)\n    else System.out.println(\"Failed to find seed!\")\n    false\n  }\n}\n\nobject Psychic {\n  val justOneValue = java.lang.Math.random()\n  val rep = new ReplicatedRandom()\n  rep.replicateState(justOneValue)\n    \n  def guess(): Double = rep.nextDouble()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333729,"user_id":null,"body":"class It {\n   override def equals(x: Any) = x match {\n     case _: It => false\n     case _ => true\n   }\n}\n\nobject Psychic {\n  def guess(): It = {\n    return new It\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333730,"user_id":null,"body":"object Psychic {\n  def guess(): Double = {\n    val start = java.lang.Math.random()\n\n    val numerator = (start * (1L << 53)).asInstanceOf[Long]\n    val first26 = (numerator >>> 27).toInt\n    val last27 = (numerator & ((1L << 27) - 1)).toInt\n    \n    val multiplier = 0x5DEECE66DL\n    val addend = 0xBL\n    val mask = (1L << 48) - 1\n    \n    val upperMOf48Mask = ((1L << 27) - 1) << (48 - 27)\n    \n    val oldSeedUpperN = (first26.asInstanceOf[Long] << (48 - 26)) & mask\n    val newSeedUpperM = (last27.asInstanceOf[Long] << (48 - 27)) & mask\n    \n    val possibleSeeds = new java.util.ArrayList[Long]\n    \n    var oldSeed = oldSeedUpperN\n    while ( {\n      oldSeed <= (oldSeedUpperN | ((1L << (48 - 26)) - 1))\n    }) {\n      val newSeed = (oldSeed * multiplier + addend) & mask\n      if ((newSeed & upperMOf48Mask) == newSeedUpperM)\n        possibleSeeds.add(newSeed)\n    \n      oldSeed += 1\n    }\n    \n    val rn = new java.util.Random(possibleSeeds.get(0) ^ multiplier)\n    rn.nextDouble()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333731,"user_id":null,"body":"\nimport java.util.Random\nimport java.util.concurrent.atomic.AtomicLong\n\nobject Psychic {\n  def guess(): Double = {\n    \/\/ Hack into the system RNG\n    val klass = Class.forName(\"java.lang.Math$RandomNumberGeneratorHolder\")\n    val field = klass.getDeclaredField(\"randomNumberGenerator\")\n    field.setAccessible(true)\n    val sysRandom = field.get(null) \/\/ The system RNG\n    \/\/ Seed accessor\n    val randomSeedField = sysRandom.getClass.getDeclaredField(\"seed\")\n    randomSeedField.setAccessible(true)\n    \/\/ The system RNG seed object\n    val sysSeed = randomSeedField.get(sysRandom).asInstanceOf[AtomicLong]\n    \n    \/\/ This will be our seed value\n    val seed = System.nanoTime()\n    \/\/ Set the seed\n    sysSeed.set(seed)\n    \/\/ Guess\n    val ourGuess = java.lang.Math.random();\n    \/\/ Set the seed again\n    sysSeed.set(seed)\n    \n    ourGuess\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333732,"user_id":null,"body":"import java.lang.reflect.Field\nimport java.util.Random\nimport java.util.concurrent.atomic.AtomicLong\nobject Psychic {\n  val holderClass: Class[_] = Class.forName(\"java.lang.Math$RandomNumberGeneratorHolder\")\n  val generatorField: Field = holderClass.getDeclaredField(\"randomNumberGenerator\")\n  generatorField.setAccessible(true)\n  val generator: AnyRef = generatorField.get(null)\n  val seedField: Field = generator.getClass.getDeclaredField(\"seed\")\n  seedField.setAccessible(true)\n  val seed:AtomicLong = seedField.get(generator).asInstanceOf[AtomicLong]\n  val random = new Random()\n  seedField.set(random, new AtomicLong(seed.get())) \/\/\u8981\u65b0\u7684AtomicLong,\u5426\u5219\u548c\u539f\u6765\u7684\u4e00\u8d77\u7528\u4e24\u8fb9\u4fee\u6539\n\n  def guess(): Double = {\n    random.nextDouble()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54bf1c2cd5b56cc47f0007a1":[{"id":333733,"user_id":573,"body":"object Dups {\n\n  def duplicate_count(str: String): Int =\n    str.groupBy(_.toLower).count(_._2.size > 1)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333734,"user_id":527,"body":"object Dups {\n\n  def duplicate_count(str: String): Int =\n    str.groupBy(_.toLower).count{ case (_, cs) => cs.size > 1 }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333735,"user_id":null,"body":"object Dups {\n\n  def duplicate_count(str: String): Int = {\n    str.toLowerCase.groupBy(identity).filter(_._2.size > 1).size\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333736,"user_id":null,"body":"object Dups {\n\n    def duplicate_count(str: String) : Int = str match {\n      case null => 0\n      case \"\" => 0\n      case _ => {\n        val strNoCase = str.toLowerCase()\n        if ( strNoCase.tail.length <= 0 ) 0\n        else {\n            (if (!strNoCase.tail.contains(strNoCase.head)) 0 else 1 ) + duplicate_count(strNoCase.tail.replaceAll(strNoCase.head.toString,\"\"))\n        }\n      }\n    }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333737,"user_id":null,"body":"object Dups {\n\n  def duplicate_count(str: String): Int = str.toLowerCase.groupBy(e => e).count(map => map._2.length > 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333738,"user_id":null,"body":"import scala.collection.mutable\n\nobject Dups {\n  \n def duplicate_count(str: String): Int = {\n    val indexCountArray = Array.fill(256)(0)\n     for( i <- 0 until str.length) {\n       indexCountArray(str(i).toLower) = indexCountArray(str(i).toLower) + 1\n     }\n    indexCountArray.count(_ > 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333739,"user_id":null,"body":"object Dups {\n\n  def duplicate_count(str: String): Int = {\n    str.split(\"\").map(_.toLowerCase).groupBy(identity).count(x => x._2.length > 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333740,"user_id":null,"body":"object Dups {\n  def duplicate_count(str: String): Int = {\n    str\n      .toLowerCase\n      .groupBy(x => x)\n      .map(e => (e._1, e._2.length))\n      .filter(_._2>1)\n      .size\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333741,"user_id":null,"body":"object Dups {\n\n  def duplicate_count(str: String): Int = {\n    str.map(_.toLower).groupBy(identity).mapValues(_.size).filter(_._2 > 1).size\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333742,"user_id":null,"body":"object Dups {\n\n  def duplicate_count(str: String): Int = {\n    val strToLower = str.toLowerCase()\n    val strToList = strToLower.toList\n    val eleMapping = strToList.groupBy(identity).mapValues(_.size)\n    val dupCount = eleMapping.count(c => c._2 > 1)\n    dupCount\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54c27a33fb7da0db0100040e":[{"id":333743,"user_id":527,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = {\n    math.sqrt(x).isWhole\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333744,"user_id":null,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = {\n    math.sqrt(x).isValidInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333745,"user_id":null,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = {\n    LazyList.from(0)\n      .map(math.pow(_, 2))\n      .takeWhile(_ <= x)\n      .contains(x)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333746,"user_id":null,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = {\n    if (x >= 0 && Math.sqrt(x) % 1 == 0) true else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333747,"user_id":null,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = {\n    \n    def _is_square(d: Int): Boolean = \n      if(d < 0) false\n      else if(d * d == x) true\n      else _is_square(d - 1)\n   \n    _is_square(x)\n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333748,"user_id":null,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = math.pow(x, 0.5) % 1 == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333749,"user_id":null,"body":"import scala.math.sqrt\nimport scala.math.floor\n\nobject Sol {\n\n  \/**\n   * Checks if x is a perfect square.\n   *\n   * @param x Number to check\n   * @return True if x is a perfect square, false otherwise\n   *\/\n  def is_square(x: Int): Boolean = {\n    val root = sqrt(x)\n    (root == floor(root))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333750,"user_id":null,"body":"object Sol {\n\n  def is_square(x: Int): Boolean = {\n   math.sqrt(x)==math.sqrt(x).round\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333751,"user_id":null,"body":"object Sol {\n  def is_square(x: Int): Boolean = {\n    def sqt(n:BigInt):BigInt = {\n      var a = BigInt(1)\n      var b = (n>>5)+BigInt(8)\n      while((b-a) >= 0) {\n        var mid:BigInt = (a+b)>>1\n        if(mid*mid-n> 0) b = mid-1\n        else a = mid+1\n      }\n      a-1\n    }\n    var y = sqt(x)\n    if(y*y == x) true\n    else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333752,"user_id":null,"body":"object Sol {\n  import scala.math._\n  \n  def is_square(x: Int): Boolean = {\n    floor(sqrt(x.toDouble)) == sqrt(x.toDouble)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54cb771c9b30e8b5250011d4":[{"id":333753,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n    def height(n: BigInteger, m: BigInteger): BigInteger = {\n    var i = BigInt(1)\n    (BigInt(1) to BigInt(n)).foldLeft(BigInt(0)){ (acc,e) =>\n      i=i*(BigInt(m)-e+1)\/e\n      acc+i\n    }.bigInteger\n  }\n}\n\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333754,"user_id":571,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n  def height(n: BigInteger, t: BigInteger): BigInteger = {\n  var res = new BigInteger(\"0\")\n  var fac = new BigInteger(\"1\")\n  var rounds = new BigInteger(\"0\")\n  var one = new BigInteger(\"1\")\n  while (rounds.compareTo(n)<0){\n    fac = (fac.multiply(t.subtract(rounds)).divide(rounds.add(one)))\n    res = res.add(fac)\n    rounds = rounds.add(one)\n  }\n  return res\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333755,"user_id":168,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.ONE\n\nobject Faberge {\n  def height(n: BigInteger, m: BigInteger): BigInteger = {\n    var c = ONE\n    var s = ZERO\n    var i = ZERO\n    while (i.compareTo(n) < 0) {\n      c = c.multiply(m.subtract(i))\n      i = i.add(ONE)\n      c = c.divide(i)\n      s = s.add(c)      \n    }\n    s\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333756,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n  def height(n: BigInteger, m: BigInteger): BigInteger = if (m == ZERO || n == ZERO) ZERO else (1 to n.intValue())\n    .foldLeft((ZERO, ONE))((res, i) => {\n      val (curSum, prevCombine) = res\n      val curCombine = prevCombine.multiply(m.subtract(valueOf(i - 1))).divide(valueOf(i))\n      (curSum.add(curCombine), curCombine)\n    })._1\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333757,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.valueOf\nimport scala.math.BigInt.javaBigInteger2bigInt\n\nobject Faberge {\n  def height(n: BigInteger, m: BigInteger): BigInteger = {\n    var mCoef: BigInteger = m\n    var h: BigInteger = BigInteger.ZERO\n    var k: BigInteger = BigInteger.ONE\n    for (i <- 1 to n.toInt) {\n      k = k.multiply(mCoef).divide(valueOf(i))\n      h = h.add(k)\n      mCoef = mCoef.subtract(valueOf(1))\n    }\n    h\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333758,"user_id":null,"body":"import java.math.BigInteger\nimport scala.collection.mutable.ArrayBuffer\nimport scala.math.BigInt.javaBigInteger2bigInt\n\n\nobject Faberge {\n \n  def height(n1: BigInteger, m1: BigInteger): BigInteger = {\n    val n: BigInt = n1\n    val m: BigInt = m1\n\n    var height: BigInt = BigInteger.ZERO\n    var f: BigInt = BigInteger.ONE\n    for (i <- 1 to n.intValue) {\n      f = f * (m - i + 1) \/ i\n      height = height + f\n    }\n    height.bigInteger\n  }\n\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333759,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n    def height(n: BigInteger, m: BigInteger): BigInteger = {\n    val N = BigInt(n.intValue())\n    val M = BigInt(m.intValue())\n    val M2 = M + 1\n    val K = N.min(M)\n    val Half = M2\/2\n     \n    def partialSum(K: BigInt): BigInt = {\n      var i = BigInt(1)\n      (BigInt(1) to K).foldLeft(BigInt(0)){ (acc,e) =>\n        i=i*(M2 - e)\/e\n        acc+i\n      }\n    }\n    \n    val answer = K match {\n      case x if x <= Half => partialSum(x)\n      case x if (K == M) => BigInt(2).pow(M.toInt) - partialSum(M - x - 1) - 1\n      case x => BigInt(2).pow(M.toInt) - partialSum(M - x - 1) - 2\n    }\n    \n    new BigInteger(answer.toString)\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333760,"user_id":null,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.valueOf\nimport scala.collection.mutable.ArrayBuffer\n\nobject Faberge {\n  def height(n: BigInteger, m: BigInteger): BigInteger = {\n    val N = BigInt(n.intValue())\n    val M = BigInt(m.intValue())\n    val M2 = M + 1\n    val K = N.min(M)\n    val Half = M2\/2\n     \n    def partialSum(K: BigInt): BigInt = {\n      var a = BigInt(1)\n      var b = BigInt(1)\n      var answer = BigInt(0)\n      var i = BigInt(1)\n      \n      while (i <= K)\n      {\n        a *= (M2 - i)\n        b *= i\n        answer += (a \/ b)\n        i += 1\n      }\n      \n      answer\n    }\n    \n    val answer = K match {\n      case x if x <= Half => partialSum(x)\n      case x if (K == M) => BigInt(2).pow(M.toInt) - partialSum(M - x - 1) - 1\n      case x => BigInt(2).pow(M.toInt) - partialSum(M - x - 1) - 2\n    }\n    \n    new BigInteger(answer.toString)\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333761,"user_id":492,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n  def height(n: BigInteger, m: BigInteger): BigInteger = {\n    var h = BigInteger.ZERO;\n    var u = BigInteger.ONE;\n    for (i <- 1 to n.intValue()) {\n        u = u.multiply(m.add(BigInteger.valueOf(1 - i))).divide(BigInteger.valueOf(i));\n        h = h.add(u);\n    }\n    return h;\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333762,"user_id":53,"body":"import java.math.BigInteger\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.valueOf\n\nobject Faberge {\n  def height(n: BigInteger, m: BigInteger): BigInteger = {\n    var x = n;\n    var t = BigInteger.ONE;\n    var h = BigInteger.ZERO;\n    while (x.compareTo(BigInteger.ZERO) != 0) {\n      var e = t.multiply(m.subtract(n).add(x)).divide(n.add(BigInteger.ONE).subtract(x));\n      x = x.subtract(BigInteger.ONE);\n      t = e;\n      h = h.add(e);\n    }\n    return h;\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54d496788776e49e6b00052f":[{"id":333763,"user_id":573,"body":"object sum_of_divided {\n\n  def sum_of_divided(lst: Array[Int]): String =\n    (2 to lst.map(_.abs).max)\n      .collect {\n        case i if BigInt(i).isProbablePrime(i) && lst.count(_ % i == 0) > 0 =>\n          s\"($i ${lst.filter(_ % i == 0).sum})\"\n      }\n      .mkString\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333764,"user_id":null,"body":"object sum_of_divided {\n  def sum_of_divided(lst: Array[Int]): String = {\n    LazyList\n      .from(2)\n      .filter(p => BigInt(p).isProbablePrime(10))\n      .takeWhile(p => p <= lst.map(Math.abs(_)).max)\n      .map(p => (p, lst.filter(e => e % p == 0)))\n      .filter { case (_, lst) => lst.length > 0 }\n      .map { case (p, lst) => s\"(${p} ${lst.sum})\" }\n      .mkString\n  }\n}\n\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333765,"user_id":null,"body":"object sum_of_divided {\n  def sum_of_divided(lst: Array[Int]): String = {\n    import scala.collection.mutable.ArrayBuffer\n    def factors(x: Int): ArrayBuffer[Int] = {\n      def travel(x: Int, a: Int): ArrayBuffer[Int] =\n        if (a * a > x) ArrayBuffer(x) else\n          x % a match {\n            case 0 => travel(x \/ a, a) += a\n            case _ => travel(x, a + 1)\n          }\n      travel(x.abs, 2).reverse\n    }\n    val primes = lst.flatMap(factors(_).distinct).distinct.sorted\n    primes.map(x => Array(x, lst.filter(_ % x == 0).sum)).map(_.mkString(\"(\", \" \" , \")\")).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333766,"user_id":492,"body":"object sum_of_divided {\n\n  def sum_of_divided(lst: Array[Int]): String = {\n    val rem: Array[Int] = Array.ofDim[Int](lst.length)\n    var max: Int = 0\n    var result: String = \"\"\n    for (i <- 0 until lst.length) {\n      rem(i) = Math.abs(lst(i))\n      max = Math.max(max, Math.abs(lst(i)))\n    }\n    var fac: Int = 2\n    while (fac <= max) {\n      var isFactor: Boolean = false\n      var tot: Int = 0\n      for (i <- 0 until lst.length if rem(i) % fac == 0) {\n        isFactor = true\n        tot += lst(i)\n        while (rem(i) % fac == 0) rem(i) \/= fac\n      }\n      if (isFactor) {\n        result += \"(\" + fac + \" \" + tot + \")\"\n      }\n      fac += 1\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333767,"user_id":492,"body":"object sum_of_divided {\n\n  def sum_of_divided(lst: Array[Int]): String = {\n    val rem: Array[Int] = Array.ofDim[Int](lst.length)\n    var max: Int = 0\n    var result: String = \"\"\n    for (i <- 0 until lst.length) {\n      rem(i) = Math.abs(lst(i))\n      max = Math.max(max, Math.abs(lst(i)))\n    }\n    var fac: Int = 2\n    while (fac <= max) {\n      var isFactor: Boolean = false\n      var tot: Int = 0\n      for (i <- 0 until lst.length if rem(i) % fac == 0) {\n        isFactor = true\n        tot += lst(i)\n        while (rem(i) % fac == 0) rem(i) \/= fac\n      }\n      if (isFactor) {\n        result += \"(\" + fac + \" \" + tot + \")\"\n      }\n      fac += 1\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333768,"user_id":null,"body":"object sum_of_divided {\n  import scala.annotation.tailrec\n  \n    def getPrimes(upperBorder: Int, lowerBorder: Int = 2): Seq[Int] = {\n      @tailrec\n      def loop(acc: Seq[Int], initSeq: Seq[Int]): Seq[Int] = {\n        val k = initSeq.head\n        if (k * k > upperBorder)\n          acc ++ initSeq\n        else\n          loop(acc :+ k, initSeq.filterNot(_ % k == 0))\n      }\n\n      if (upperBorder < lowerBorder)\n        Seq()\n      else\n        loop(Seq(), lowerBorder to upperBorder)\n    }\n\n  def sum_of_divided(lst: Array[Int]): String = {\n    val max = lst.map(x => Math.abs(x)).max\n    val r = for {\n      prime <- getPrimes(max)\n      if lst.exists(_ % prime == 0)\n      sum = lst.filter(_ % prime == 0).sum\n    } yield s\"($prime $sum)\"\n    r.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333769,"user_id":null,"body":"\nimport scala.collection.mutable\n\nobject sum_of_divided {\n\ndef sum_of_divided(lst: Array[Int]): String = {\n  val primes = Array(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10111,10133,10139,10141,10151,10159,10163,10169,10177,10181,10193,10211,10223,10243,10247,10253,10259,10267,10271,10273,10289,10301,10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,10429,10433,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559,10567,10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663,10667,10687,10691,10709,10711,10723,10729,10733,10739,10753,10771,10781,10789,10799,10831,10837,10847,10853,10859,10861,10867,10883,10889,10891,10903,10909,10937,10939,10949,10957,10973,10979,10987,10993,11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,11119,11131,11149,11159,11161,11171,11173,11177,11197,11213,11239,11243,11251,11257,11261,11273,11279,11287,11299,11311,11317,11321,11329,11351,11353,11369,11383,11393,11399,11411,11423,11437,11443,11447,11467,11471,11483,11489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,11731,11743,11777,11779,11783,11789,11801,11807,11813,11821,11827,11831,11833,11839,11863,11867,11887,11897,11903,11909,11923,11927,11933,11939,11941,11953,11959,11969,11971,11981,11987,12007,12011,12037,12041,12043,12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,12161,12163,12197,12203,12211,12227,12239,12241,12251,12253,12263,12269,12277,12281,12289,12301,12323,12329,12343,12347,12373,12377,12379,12391,12401,12409,12413,12421,12433,12437,12451,12457,12473,12479,12487,12491,12497,12503,12511,12517,12527,12539,12541,12547,12553,12569,12577,12583,12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,12697,12703,12713,12721,12739,12743,12757,12763,12781,12791,12799,12809,12821,12823,12829,12841,12853,12889,12893,12899,12907,12911,12917,12919,12923,12941,12953,12959,12967,12973,12979,12983,13001,13003,13007,13009,13033,13037,13043,13049,13063,13093,13099,13103,13109,13121,13127,13147,13151,13159,13163,13171,13177,13183,13187,13217,13219,13229,13241,13249,13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,13397,13399,13411,13417,13421,13441,13451,13457,13463,13469,13477,13487,13499,13513,13523,13537,13553,13567,13577,13591,13597,13613,13619,13627,13633,13649,13669,13679,13681,13687,13691,13693,13697,13709,13711,13721,13723,13729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,13933,13963,13967,13997,13999,14009,14011,14029,14033,14051,14057,14071,14081,14083,14087,14107,14143,14149,14153,14159,14173,14177,14197,14207,14221,14243,14249,14251,14281,14293,14303,14321,14323,14327,14341,14347,14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,14461,14479,14489,14503,14519,14533,14537,14543,14549,14551,14557,14561,14563,14591,14593,14621,14627,14629,14633,14639,14653,14657,14669,14683,14699,14713,14717,14723,14731,14737,14741,14747,14753,14759,14767,14771,14779,14783,14797,14813,14821,14827,14831,14843,14851,14867,14869,14879,14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,15017,15031,15053,15061,15073,15077,15083,15091,15101,15107,15121,15131,15137,15139,15149,15161,15173,15187,15193,15199,15217,15227,15233,15241,15259,15263,15269,15271,15277,15287,15289,15299,15307,15313,15319,15329,15331,15349,15359,15361,15373,15377,15383,15391,15401,15413,15427,15439,15443,15451,15461,15467,15473,15493,15497,15511,15527,15541,15551,15559,15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,15667,15671,15679,15683,15727,15731,15733,15737,15739,15749,15761,15767,15773,15787,15791,15797,15803,15809,15817,15823,15859,15877,15881,15887,15889,15901,15907,15913,15919,15923,15937,15959,15971,15973,15991,16001,16007,16033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,16249,16253,16267,16273,16301,16319,16333,16339,16349,16361,16363,16369,16381,16411,16417,16421,16427,16433,16447,16451,16453,16477,16481,16487,16493,16519,16529,16547,16553,16561,16567,16573,16603,16607,16619,16631,16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,16747,16759,16763,16787,16811,16823,16829,16831,16843,16871,16879,16883,16889,16901,16903,16921,16927,16931,16937,16943,16963,16979,16981,16987,16993,17011,17021,17027,17029,17033,17041,17047,17053,17077,17093,17099,17107,17117,17123,17137,17159,17167,17183,17189,17191,17203,17207,17209,17231,17239,17257,17291,17293,17299,17317,17321,17327,17333,17341,17351,17359,17377,17383,17387,17389,17393,17401,17417,17419,17431,17443,17449,17467,17471,17477,17483,17489,17491,17497,17509,17519,17539,17551,17569,17573,17579,17581,17597,17599,17609,17623,17627,17657,17659,17669,17681,17683,17707,17713,17729,17737,17747,17749,17761,17783,17789,17791,17807,17827,17837,17839,17851,17863,17881,17891,17903,17909,17911,17921,17923,17929,17939,17957,17959,17971,17977,17981,17987,17989,18013,18041,18043,18047,18049,18059,18061,18077,18089,18097,18119,18121,18127,18131,18133,18143,18149,18169,18181,18191,18199,18211,18217,18223,18229,18233,18251,18253,18257,18269,18287,18289,18301,18307,18311,18313,18329,18341,18353,18367,18371,18379,18397,18401,18413,18427,18433,18439,18443,18451,18457,18461,18481,18493,18503,18517,18521,18523,18539,18541,18553,18583,18587,18593,18617,18637,18661,18671,18679,18691,18701,18713,18719,18731,18743,18749,18757,18773,18787,18793,18797,18803,18839,18859,18869,18899,18911,18913,18917,18919,18947,18959,18973,18979,19001,19009,19013,19031,19037,19051,19069,19073,19079,19081,19087,19121,19139,19141,19157,19163,19181,19183,19207,19211,19213,19219,19231,19237,19249,19259,19267,19273,19289,19301,19309,19319,19333,19373,19379,19381,19387,19391,19403,19417,19421,19423,19427,19429,19433,19441,19447,19457,19463,19469,19471,19477,19483,19489,19501,19507,19531,19541,19543,19553,19559,19571,19577,19583,19597,19603,19609,19661,19681,19687,19697,19699,19709,19717,19727,19739,19751,19753,19759,19763,19777,19793,19801,19813,19819,19841,19843,19853,19861,19867,19889,19891,19913,19919,19927,19937,19949,19961,19963,19973,19979,19991,19993,19997,20011,20021,20023,20029,20047,20051,20063,20071,20089,20101,20107,20113,20117,20123,20129,20143,20147,20149,20161,20173,20177,20183,20201,20219,20231,20233,20249,20261,20269,20287,20297,20323,20327,20333,20341,20347,20353,20357,20359,20369,20389,20393,20399,20407,20411,20431,20441,20443,20477,20479,20483,20507,20509,20521,20533,20543,20549,20551,20563,20593,20599,20611,20627,20639,20641,20663,20681,20693,20707,20717,20719,20731,20743,20747,20749,20753,20759,20771,20773,20789,20807,20809,20849,20857,20873,20879,20887,20897,20899,20903,20921,20929,20939,20947,20959,20963,20981,20983,21001,21011,21013,21017,21019,21023,21031,21059,21061,21067,21089,21101,21107,21121,21139,21143,21149,21157,21163,21169,21179,21187,21191,21193,21211,21221,21227,21247,21269,21277,21283,21313,21317,21319,21323,21341,21347,21377,21379,21383,21391,21397,21401,21407,21419,21433,21467,21481,21487,21491,21493,21499,21503,21517,21521,21523,21529,21557,21559,21563,21569,21577,21587,21589,21599,21601,21611,21613,21617,21647,21649,21661,21673,21683,21701,21713,21727,21737,21739,21751,21757,21767,21773,21787,21799,21803,21817,21821,21839,21841,21851,21859,21863,21871,21881,21893,21911,21929,21937,21943,21961,21977,21991,21997,22003,22013,22027,22031,22037,22039,22051,22063,22067,22073,22079,22091,22093,22109,22111,22123,22129,22133,22147,22153,22157,22159,22171,22189,22193,22229,22247,22259,22271,22273,22277,22279,22283,22291,22303,22307,22343,22349,22367,22369,22381,22391,22397,22409,22433,22441,22447,22453,22469,22481,22483,22501,22511,22531,22541,22543,22549,22567,22571,22573,22613,22619,22621,22637,22639,22643,22651,22669,22679,22691,22697,22699,22709,22717,22721,22727,22739,22741,22751,22769,22777,22783,22787,22807,22811,22817,22853,22859,22861,22871,22877,22901,22907,22921,22937,22943,22961,22963,22973,22993,23003,23011,23017,23021,23027,23029,23039,23041,23053,23057,23059,23063,23071,23081,23087,23099,23117,23131,23143,23159,23167,23173,23189,23197,23201,23203,23209,23227,23251,23269,23279,23291,23293,23297,23311,23321,23327,23333,23339,23357,23369,23371,23399,23417,23431,23447,23459,23473,23497,23509,23531,23537,23539,23549,23557,23561,23563,23567,23581,23593,23599,23603,23609,23623,23627,23629,23633,23663,23669,23671,23677,23687,23689,23719,23741,23743,23747,23753,23761,23767,23773,23789,23801,23813,23819,23827,23831,23833,23857,23869,23873,23879,23887,23893,23899,23909,23911,23917,23929,23957,23971,23977,23981,23993,24001,24007,24019,24023,24029,24043,24049,24061,24071,24077,24083,24091,24097,24103,24107,24109,24113,24121,24133,24137,24151,24169,24179,24181,24197,24203,24223,24229,24239,24247,24251,24281,24317,24329,24337,24359,24371,24373,24379,24391,24407,24413,24419,24421,24439,24443,24469,24473,24481,24499,24509,24517,24527,24533,24547,24551,24571,24593,24611,24623,24631,24659,24671,24677,24683,24691,24697,24709,24733,24749,24763,24767,24781,24793,24799,24809,24821,24841,24847,24851,24859,24877,24889,24907,24917,24919,24923,24943,24953,24967,24971,24977,24979,24989,25013,25031,25033,25037,25057,25073,25087,25097,25111,25117,25121,25127,25147,25153,25163,25169,25171,25183,25189,25219,25229,25237,25243,25247,25253,25261,25301,25303,25307,25309,25321,25339,25343,25349,25357,25367,25373,25391,25409,25411,25423,25439,25447,25453,25457,25463,25469,25471,25523,25537,25541,25561,25577,25579,25583,25589,25601,25603,25609,25621,25633,25639,25643,25657,25667,25673,25679,25693,25703,25717,25733,25741,25747,25759,25763,25771,25793,25799,25801,25819,25841,25847,25849,25867,25873,25889,25903,25913,25919,25931,25933,25939,25943,25951,25969,25981,25997,25999,26003,26017,26021,26029,26041,26053,26083,26099,26107,26111,26113,26119,26141,26153,26161,26171,26177,26183,26189,26203,26209,26227,26237,26249,26251,26261,26263,26267,26293,26297,26309,26317,26321,26339,26347,26357,26371,26387,26393,26399,26407,26417,26423,26431,26437,26449,26459,26479,26489,26497,26501,26513,26539,26557,26561,26573,26591,26597,26627,26633,26641,26647,26669,26681,26683,26687,26693,26699,26701,26711,26713,26717,26723,26729,26731,26737,26759,26777,26783,26801,26813,26821,26833,26839,26849,26861,26863,26879,26881,26891,26893,26903,26921,26927,26947,26951,26953,26959,26981,26987,26993,27011,27017,27031,27043,27059,27061,27067,27073,27077,27091,27103,27107,27109,27127,27143,27179,27191,27197,27211,27239,27241,27253,27259,27271,27277,27281,27283,27299,27329,27337,27361,27367,27397,27407,27409,27427,27431,27437,27449,27457,27479,27481,27487,27509,27527,27529,27539,27541,27551,27581,27583,27611,27617,27631,27647,27653,27673,27689,27691,27697,27701,27733,27737,27739,27743,27749,27751,27763,27767,27773,27779,27791,27793,27799,27803,27809,27817,27823,27827,27847,27851,27883,27893,27901,27917,27919,27941,27943,27947,27953,27961,27967,27983,27997,28001,28019,28027,28031,28051,28057,28069,28081,28087,28097,28099,28109,28111,28123,28151,28163,28181,28183,28201,28211,28219,28229,28277,28279,28283,28289,28297,28307,28309,28319,28349,28351,28387,28393,28403,28409,28411,28429,28433,28439,28447,28463,28477,28493,28499,28513,28517,28537,28541,28547,28549,28559,28571,28573,28579,28591,28597,28603,28607,28619,28621,28627,28631,28643,28649,28657,28661,28663,28669,28687,28697,28703,28711,28723,28729,28751,28753,28759,28771,28789,28793,28807,28813,28817,28837,28843,28859,28867,28871,28879,28901,28909,28921,28927,28933,28949,28961,28979,29009,29017,29021,29023,29027,29033,29059,29063,29077,29101,29123,29129,29131,29137,29147,29153,29167,29173,29179,29191,29201,29207,29209,29221,29231,29243,29251,29269,29287,29297,29303,29311,29327,29333,29339,29347,29363,29383,29387,29389,29399,29401,29411,29423,29429,29437,29443,29453,29473,29483,29501,29527,29531,29537,29567,29569,29573,29581,29587,29599,29611,29629,29633,29641,29663,29669,29671,29683,29717,29723,29741,29753,29759,29761,29789,29803,29819,29833,29837,29851,29863,29867,29873,29879,29881,29917,29921,29927,29947,29959,29983,29989,30011,30013,30029,30047,30059,30071,30089,30091,30097,30103,30109,30113,30119,30133,30137,30139,30161,30169,30181,30187,30197,30203,30211,30223,30241,30253,30259,30269,30271,30293,30307,30313,30319,30323,30341,30347,30367,30389,30391,30403,30427,30431,30449,30467,30469,30491,30493,30497,30509,30517,30529,30539,30553,30557,30559,30577,30593,30631,30637,30643,30649,30661,30671,30677,30689,30697,30703,30707,30713,30727,30757,30763,30773,30781,30803,30809,30817,30829,30839,30841,30851,30853,30859,30869,30871,30881,30893,30911,30931,30937,30941,30949,30971,30977,30983,31013,31019,31033,31039,31051,31063,31069,31079,31081,31091,31121,31123,31139,31147,31151,31153,31159,31177,31181,31183,31189,31193,31219,31223,31231,31237,31247,31249,31253,31259,31267,31271,31277,31307,31319,31321,31327,31333,31337,31357,31379,31387,31391,31393,31397,31469,31477,31481,31489,31511,31513,31517,31531,31541,31543,31547,31567,31573,31583,31601,31607,31627,31643,31649,31657,31663,31667,31687,31699,31721,31723,31727,31729,31741,31751,31769,31771,31793,31799,31817,31847,31849,31859,31873,31883,31891,31907,31957,31963,31973,31981,31991,32003,32009,32027,32029,32051,32057,32059,32063,32069,32077,32083,32089,32099,32117,32119,32141,32143,32159,32173,32183,32189,32191,32203,32213,32233,32237,32251,32257,32261,32297,32299,32303,32309,32321,32323,32327,32341,32353,32359,32363,32369,32371,32377,32381,32401,32411,32413,32423,32429,32441,32443,32467,32479,32491,32497,32503,32507,32531,32533,32537,32561,32563,32569,32573,32579,32587,32603,32609,32611,32621,32633,32647,32653,32687,32693,32707,32713,32717,32719,32749,32771,32779,32783,32789,32797,32801,32803,32831,32833,32839,32843,32869,32887,32909,32911,32917,32933,32939,32941,32957,32969,32971,32983,32987,32993,32999,33013,33023,33029,33037,33049,33053,33071,33073,33083,33091,33107,33113,33119,33149,33151,33161,33179,33181,33191,33199,33203,33211,33223,33247,33287,33289,33301,33311,33317,33329,33331,33343,33347,33349,33353,33359,33377,33391,33403,33409,33413,33427,33457,33461,33469,33479,33487,33493,33503,33521,33529,33533,33547,33563,33569,33577,33581,33587,33589,33599,33601,33613,33617,33619,33623,33629,33637,33641,33647,33679,33703,33713,33721,33739,33749,33751,33757,33767,33769,33773,33791,33797,33809,33811,33827,33829,33851,33857,33863,33871,33889,33893,33911,33923,33931,33937,33941,33961,33967,33997,34019,34031,34033,34039,34057,34061,34123,34127,34129,34141,34147,34157,34159,34171,34183,34211,34213,34217,34231,34253,34259,34261,34267,34273,34283,34297,34301,34303,34313,34319,34327,34337,34351,34361,34367,34369,34381,34403,34421,34429,34439,34457,34469,34471,34483,34487,34499,34501,34511,34513,34519,34537,34543,34549,34583,34589,34591,34603,34607,34613,34631,34649,34651,34667,34673,34679,34687,34693,34703,34721,34729,34739,34747,34757,34759,34763,34781,34807,34819,34841,34843,34847,34849,34871,34877,34883,34897,34913,34919,34939,34949,34961,34963,34981,35023,35027,35051,35053,35059,35069,35081,35083,35089,35099,35107,35111,35117,35129,35141,35149,35153,35159,35171,35201,35221,35227,35251,35257,35267,35279,35281,35291,35311,35317,35323,35327,35339,35353,35363,35381,35393,35401,35407,35419,35423,35437,35447,35449,35461,35491,35507,35509,35521,35527,35531,35533,35537,35543,35569,35573,35591,35593,35597,35603,35617,35671,35677,35729,35731,35747,35753,35759,35771,35797,35801,35803,35809,35831,35837,35839,35851,35863,35869,35879,35897,35899,35911,35923,35933,35951,35963,35969,35977,35983,35993,35999,36007,36011,36013,36017,36037,36061,36067,36073,36083,36097,36107,36109,36131,36137,36151,36161,36187,36191,36209,36217,36229,36241,36251,36263,36269,36277,36293,36299,36307,36313,36319,36341,36343,36353,36373,36383,36389,36433,36451,36457,36467,36469,36473,36479,36493,36497,36523,36527,36529,36541,36551,36559,36563,36571,36583,36587,36599,36607,36629,36637,36643,36653,36671,36677,36683,36691,36697,36709,36713,36721,36739,36749,36761,36767,36779,36781,36787,36791,36793,36809,36821,36833,36847,36857,36871,36877,36887,36899,36901,36913,36919,36923,36929,36931,36943,36947,36973,36979,36997,37003,37013,37019,37021,37039,37049,37057,37061,37087,37097,37117,37123,37139,37159,37171,37181,37189,37199,37201,37217,37223,37243,37253,37273,37277,37307,37309,37313,37321,37337,37339,37357,37361,37363,37369,37379,37397,37409,37423,37441,37447,37463,37483,37489,37493,37501,37507,37511,37517,37529,37537,37547,37549,37561,37567,37571,37573,37579,37589,37591,37607,37619,37633,37643,37649,37657,37663,37691,37693,37699,37717,37747,37781,37783,37799,37811,37813,37831,37847,37853,37861,37871,37879,37889,37897,37907,37951,37957,37963,37967,37987,37991,37993,37997,38011,38039,38047,38053,38069,38083,38113,38119,38149,38153,38167,38177,38183,38189,38197,38201,38219,38231,38237,38239,38261,38273,38281,38287,38299,38303,38317,38321,38327,38329,38333,38351,38371,38377,38393,38431,38447,38449,38453,38459,38461,38501,38543,38557,38561,38567,38569,38593,38603,38609,38611,38629,38639,38651,38653,38669,38671,38677,38693,38699,38707,38711,38713,38723,38729,38737,38747,38749,38767,38783,38791,38803,38821,38833,38839,38851,38861,38867,38873,38891,38903,38917,38921,38923,38933,38953,38959,38971,38977,38993,39019,39023,39041,39043,39047,39079,39089,39097,39103,39107,39113,39119,39133,39139,39157,39161,39163,39181,39191,39199,39209,39217,39227,39229,39233,39239,39241,39251,39293,39301,39313,39317,39323,39341,39343,39359,39367,39371,39373,39383,39397,39409,39419,39439,39443,39451,39461,39499,39503,39509,39511,39521,39541,39551,39563,39569,39581,39607,39619,39623,39631,39659,39667,39671,39679,39703,39709,39719,39727,39733,39749,39761,39769,39779,39791,39799,39821,39827,39829,39839,39841,39847,39857,39863,39869,39877,39883,39887,39901,39929,39937,39953,39971,39979,39983,39989,40009,40013,40031,40037,40039,40063,40087,40093,40099,40111,40123,40127,40129,40151,40153,40163,40169,40177,40189,40193,40213,40231,40237,40241,40253,40277,40283,40289,40343,40351,40357,40361,40387,40423,40427,40429,40433,40459,40471,40483,40487,40493,40499,40507,40519,40529,40531,40543,40559,40577,40583,40591,40597,40609,40627,40637,40639,40693,40697,40699,40709,40739,40751,40759,40763,40771,40787,40801,40813,40819,40823,40829,40841,40847,40849,40853,40867,40879,40883,40897,40903,40927,40933,40939,40949,40961,40973,40993,41011,41017,41023,41039,41047,41051,41057,41077,41081,41113,41117,41131,41141,41143,41149,41161,41177,41179,41183,41189,41201,41203,41213,41221,41227,41231,41233,41243,41257,41263,41269,41281,41299,41333,41341,41351,41357,41381,41387,41389,41399,41411,41413,41443,41453,41467,41479,41491,41507,41513,41519,41521,41539,41543,41549,41579,41593,41597,41603,41609,41611,41617,41621,41627,41641,41647,41651,41659,41669,41681,41687,41719,41729,41737,41759,41761,41771,41777,41801,41809,41813,41843,41849,41851,41863,41879,41887,41893,41897,41903,41911,41927,41941,41947,41953,41957,41959,41969,41981,41983,41999,42013,42017,42019,42023,42043,42061,42071,42073,42083,42089,42101,42131,42139,42157,42169,42179,42181,42187,42193,42197,42209,42221,42223,42227,42239,42257,42281,42283,42293,42299,42307,42323,42331,42337,42349,42359,42373,42379,42391,42397,42403,42407,42409,42433,42437,42443,42451,42457,42461,42463,42467,42473,42487,42491,42499,42509,42533,42557,42569,42571,42577,42589,42611,42641,42643,42649,42667,42677,42683,42689,42697,42701,42703,42709,42719,42727,42737,42743,42751,42767,42773,42787,42793,42797,42821,42829,42839,42841,42853,42859,42863,42899,42901,42923,42929,42937,42943,42953,42961,42967,42979,42989,43003,43013,43019,43037,43049,43051,43063,43067,43093,43103,43117,43133,43151,43159,43177,43189,43201,43207,43223,43237,43261,43271,43283,43291,43313,43319,43321,43331,43391,43397,43399,43403,43411,43427,43441,43451,43457,43481,43487,43499,43517,43541,43543,43573,43577,43579,43591,43597,43607,43609,43613,43627,43633,43649,43651,43661,43669,43691,43711,43717,43721,43753,43759,43777,43781,43783,43787,43789,43793,43801,43853,43867,43889,43891,43913,43933,43943,43951,43961,43963,43969,43973,43987,43991,43997,44017,44021,44027,44029,44041,44053,44059,44071,44087,44089,44101,44111,44119,44123,44129,44131,44159,44171,44179,44189,44201,44203,44207,44221,44249,44257,44263,44267,44269,44273,44279,44281,44293,44351,44357,44371,44381,44383,44389,44417,44449,44453,44483,44491,44497,44501,44507,44519,44531,44533,44537,44543,44549,44563,44579,44587,44617,44621,44623,44633,44641,44647,44651,44657,44683,44687,44699,44701,44711,44729,44741,44753,44771,44773,44777,44789,44797,44809,44819,44839,44843,44851,44867,44879,44887,44893,44909,44917,44927,44939,44953,44959,44963,44971,44983,44987,45007,45013,45053,45061,45077,45083,45119,45121,45127,45131,45137,45139,45161,45179,45181,45191,45197,45233,45247,45259,45263,45281,45289,45293,45307,45317,45319,45329,45337,45341,45343,45361,45377,45389,45403,45413,45427,45433,45439,45481,45491,45497,45503,45523,45533,45541,45553,45557,45569,45587,45589,45599,45613,45631,45641,45659,45667,45673,45677,45691,45697,45707,45737,45751,45757,45763,45767,45779,45817,45821,45823,45827,45833,45841,45853,45863,45869,45887,45893,45943,45949,45953,45959,45971,45979,45989,46021,46027,46049,46051,46061,46073,46091,46093,46099,46103,46133,46141,46147,46153,46171,46181,46183,46187,46199,46219,46229,46237,46261,46271,46273,46279,46301,46307,46309,46327,46337,46349,46351,46381,46399,46411,46439,46441,46447,46451,46457,46471,46477,46489,46499,46507,46511,46523,46549,46559,46567,46573,46589,46591,46601,46619,46633,46639,46643,46649,46663,46679,46681,46687,46691,46703,46723,46727,46747,46751,46757,46769,46771,46807,46811,46817,46819,46829,46831,46853,46861,46867,46877,46889,46901,46919,46933,46957,46993,46997,47017,47041,47051,47057,47059,47087,47093,47111,47119,47123,47129,47137,47143,47147,47149,47161,47189,47207,47221,47237,47251,47269,47279,47287,47293,47297,47303,47309,47317,47339,47351,47353,47363,47381,47387,47389,47407,47417,47419,47431,47441,47459,47491,47497,47501,47507,47513,47521,47527,47533,47543,47563,47569,47581,47591,47599,47609,47623,47629,47639,47653,47657,47659,47681,47699,47701,47711,47713,47717,47737,47741,47743,47777,47779,47791,47797,47807,47809,47819,47837,47843,47857,47869,47881,47903,47911,47917,47933,47939,47947,47951,47963,47969,47977,47981,48017,48023,48029,48049,48073,48079,48091,48109,48119,48121,48131,48157,48163,48179,48187,48193,48197,48221,48239,48247,48259,48271,48281,48299,48311,48313,48337,48341,48353,48371,48383,48397,48407,48409,48413,48437,48449,48463,48473,48479,48481,48487,48491,48497,48523,48527,48533,48539,48541,48563,48571,48589,48593,48611,48619,48623,48647,48649,48661,48673,48677,48679,48731,48733,48751,48757,48761,48767,48779,48781,48787,48799,48809,48817,48821,48823,48847,48857,48859,48869,48871,48883,48889,48907,48947,48953,48973,48989,48991,49003,49009,49019,49031,49033,49037,49043,49057,49069,49081,49103,49109,49117,49121,49123,49139,49157,49169,49171,49177,49193,49199,49201,49207,49211,49223,49253,49261,49277,49279,49297,49307,49331,49333,49339,49363,49367,49369,49391,49393,49409,49411,49417,49429,49433,49451,49459,49463,49477,49481,49499,49523,49529,49531,49537,49547,49549,49559,49597,49603,49613,49627,49633,49639,49663,49667,49669,49681,49697,49711,49727,49739,49741,49747,49757,49783,49787,49789,49801,49807,49811,49823,49831,49843,49853,49871,49877,49891,49919,49921,49927,49937,49939,49943,49957,49991,49993,49999,50021)\n\n    def primeFactors(n: Int, primesMap: mutable.Map[Int, Int], treeSet: mutable.TreeSet[Int]): Unit = {\n      for (p <- primes) {\n        if (p > math.abs(n)) {\n          return\n        }\n        if (n % p == 0) {\n          val numbersSum = primesMap.getOrElse(p, 0)\n          primesMap.put(p, numbersSum + n)\n          treeSet.add(p)\n        }\n      }\n    }\n\n  \/\/ your code\n    var hashMap = mutable.HashMap[Int, Int]()\n    var treeSet = mutable.TreeSet[Int]()\n    for (i <- lst) {\n      primeFactors(i, hashMap, treeSet)\n    }\n  \n    var result = \"\"\n    for (k <- treeSet) {\n      result = result + s\"($k ${hashMap(k)})\"\n    }\n    result\n\n}\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333770,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject sum_of_divided {\n\n  val primes: LazyList[Int] =\n    2 #:: 3 #:: LazyList.iterate(5)(_ + 1).filter(isPrime)\n\n  def isPrime(n: Int): Boolean = {\n    primes.takeWhile(i => i * i <= n).forall(n % _ != 0)\n  }\n\n\n\n  def sum_of_divided(lst: Array[Int]): String = {\n\n    def getPrimes(n: Int): Set[Int] = {\n      @tailrec\n      def getPrimesHelper(currentN: Int, remainingPrimes: LazyList[Int], currentPrimes: Set[Int]): Set[Int] = {\n        currentN match {\n          case 1 | -1 => currentPrimes\n          case n1 => {\n            val curPrime: Int = remainingPrimes.head\n            if (n1 % curPrime == 0)\n              getPrimesHelper(n1 \/ curPrime, remainingPrimes, currentPrimes + curPrime)\n            else\n              getPrimesHelper(n1, remainingPrimes.tail, currentPrimes)\n          }\n        }\n      }\n      getPrimesHelper(n, primes, Set.empty)\n    }\n\n    lst.flatMap(getPrimes).toSet.toList.sorted\n      .map(\n        (p: Int) => (p,\n          lst.filter(i => i % p == 0).sum))\n      .map {\n        case (p, s) => s\"($p $s)\"\n      }.mkString\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333771,"user_id":null,"body":"object sum_of_divided {\n\n  def sum_of_divided(list: Array[Int]): String = {\n\n    def getPrimeFactors(number: Int): Seq[Int] =\n      (2 +: (3 to number.abs by 2).filter(isPrime)).filter(number % _ == 0)\n\n    def isPrime(number: Int): Boolean =\n      (2 +: (3 to Math.sqrt(number.abs).floor.toInt by 2).toList).forall(number % _ != 0)\n\n    list\n      .flatMap(getPrimeFactors).toSet[Int].toList.sorted\n      .map { factor => s\"($factor ${list.filter(_ % factor == 0).sum})\" }\n      .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333772,"user_id":null,"body":"object sum_of_divided {\n  \n  \n  def sum_of_divided(lst: Array[Int]): String = {\n    def factors(k: Int): Set[Int] = {\n      var (factors, d, n) = (new scala.collection.mutable.HashSet[Int](), 2, math.abs(k))\n      while (d * d <= n) {\n        while (n % d == 0) { \/\/\u540c\u4e2a\u8d28\u56e0\u6570\u51fa\u73b0\u591a\u6b21\n          factors += d\n          n \/= d\n        }\n        d += 1\n      }\n      if (n > 1) factors += n\n      factors.toSet\n    }\n\n    lst.flatMap(n => factors(n).map(f => (f, n))).groupBy(_._1).toList.sortBy(_._1)\n      .map(kv => s\"(${kv._1} ${kv._2.map(_._2).sum})\").mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54d512e62a5e54c96200019e":[{"id":333773,"user_id":573,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String =\n    Iterator\n      .iterate((List[Int](), m, 2)) {\n        case (acc, x, a) if x % a == 0 => (a :: acc, x\/a, a)\n        case (acc, x, a) if a*a <= x   => (acc, x, a+1)\n        case (acc, x, a)               => (x :: acc, x, a)\n      }\n      .dropWhile { case (_, x, a) => a*a <= x }.drop(1).next._1\n      .groupMapReduce(identity)(_ => 1)(_ + _)\n      .toSeq.sorted\n      .map {\n        case (factor, 1)     => s\"($factor)\"\n        case (factor, count) => s\"($factor**$count)\"\n      }\n      .mkString\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333774,"user_id":null,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n    \ndef str(tup:(Int,Int)):String = tup match {\n  case (_,1) => \"(\" +tup._1.toString + \")\"\n  case _ => \"(\" + tup._1.toString + \"**\" + tup._2.toString + \")\"\n}\ndef verySlow(n:Int,d:Int): List[Int] = n match{\n  case n if n < 2 => Nil\n  case _ => if (n%d  == 0) d::verySlow(n\/d,d) else verySlow(n,d+1) \n}\ndef dup(xs:List[Int]): List[(Int,Int)] = xs match{\n  case Nil => Nil\n  case x::xs1 =>List((x,xs.takeWhile(_ == xs.head).length)):::dup(xs.dropWhile(_ == xs.head))\n}\nval k = verySlow(m,2)\ndup(k).map(str(_)).mkString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333775,"user_id":null,"body":"import java.lang.Math.{pow, sqrt}\n\nobject PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n    if (m == 1) return \"\"\n\n    var exp = 0\n    val div = (List(2) ++ (3 to sqrt(m).ceil.toInt by 2).toList ++ List(m)).find(m % _ == 0).get\n    while (m % pow(div, exp + 1).toInt == 0) exp += 1\n    if (exp > 1) s\"($div**$exp)\" + factors(m \/ pow(div, exp).toInt)\n    else s\"($div)\" + factors(m \/ pow(div, exp).toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333776,"user_id":null,"body":"object PrimeDecomp {\n  import scala.collection.mutable.ArrayBuffer\n  def prime_factors(m: Int): String = {\n    def factorize(x: Int): ArrayBuffer[Int] = {\n      def travel(x: Int, a: Int): ArrayBuffer[Int] =\n        if (a * a > x) ArrayBuffer(x) else\n        x % a match {\n          case 0 => travel(x \/ a, a) += a\n          case _ => travel(x, a + 1)\n        }\n      travel(x, 2)\n    }\n\n    factorize(m).groupBy(identity).toList.sortBy(_._1)\n      .map(x => if (x._2.length > 1) s\"(${x._1}**${x._2.length})\" else s\"(${x._1})\").mkString\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333777,"user_id":573,"body":"import scala.annotation.tailrec\n\nobject PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n\n    @tailrec\n    def primeFactors(x: Int, a: Int = 2, list: List[Int] = Nil): List[Int] =\n      a*a > x match {\n        case false if x % a == 0 => primeFactors(x\/a, a, a :: list)\n        case false               => primeFactors(x, a+1, list)\n        case true                => x :: list\n      }\n\n    primeFactors(m)\n      .filter(_ != 1)\n      .groupBy(identity)\n      .toList\n      .sortBy(_._1)\n      .map {\n        case (factor, List(_)) => s\"($factor)\"\n        case (factor, occurences) => s\"($factor**${occurences.size})\"\n      }\n      .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333778,"user_id":492,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n    var n = m\n    var result: String = \"\"\n    var fac: Int = 2\n    while (fac <= n) {\n      var count: Int = 0\n      count = 0\n      while (n % fac == 0) {\n        n \/= fac\n        count += 1\n      }\n      if (count > 0) {\n        result += \"(\" + fac + (if (count > 1) \"**\" + count else \"\") + \")\"\n      }\n      fac += 1\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333779,"user_id":null,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n    def factor(num : Int) : List[Int]  = {\n      val exists = (2 to math.sqrt(num).toInt).find(num% _ == 0)\n      exists match{\n        case Some(d) => d :: factor(num\/d)\n        case None => List(num)\n      }\n    } \n    def encode(xs:List[Int]) : List[List[Int]] = xs match{\n      case Nil => Nil\n      case y :: ys =>\n      val (f,r) = xs.span(x => x == y)\n      f :: encode(r)      \n    }\n    def makepair(xs : List[List[Int]]) : List[(Int,Int)] = {\n      xs.map(ys => (ys.head ,ys.length))\n    }\n    def show(xs : List[(Int,Int)]) : String = xs match{\n      case Nil => \"\"\n      case (x,y) :: rest => \n      if(y == 1) s\"($x)${show(rest)}\"\n      else s\"($x**$y)${show(rest)}\"\n    }\n    show(makepair(encode(factor(m))))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333780,"user_id":null,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n      Iterator\n      .iterate((List[Int](), m, 2)) {\n        case (acc, x, a) if x % a == 0 => (a :: acc, x \/ a, a)\n        case (acc, x, a) if a * a <= x => (acc, x, a + 1)\n        case (acc, x, a) => (x :: acc, x, a)\n      }\n      .dropWhile { case (_, x, a) => a * a <= x }.drop(1).next()._1\n      .groupBy(identity).mapValues(_.length).toList.sortBy(_._1)\n      .map {\n        case (factor, 1) => s\"($factor)\"\n        case (factor, count) => s\"($factor**$count)\"\n      }\n      .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333781,"user_id":null,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n    \n    {\n      var n:Int = m\n      def loop(v: Int): LazyList[Tuple2[Int, Int]] = {\n        if (n==1) return LazyList()\n        \n        val p = (2 to n).view.filter(n%_==0).head\n        if (p==n) return (p,1) #:: LazyList()\n        \n        var counted = 0\n        while (n%p==0){\n          n = n\/p\n          counted += 1\n        }\n        return (p,counted) #:: loop(v+1)\n      }\n      loop(0)\n    }\n    .collect{case(p,c) if c==1 => s\"($p)\" case (p,c) => s\"($p**$c)\"}\n    .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333782,"user_id":null,"body":"object PrimeDecomp {\n\n  def prime_factors(m: Int): String = {\n    var res   = \"\"\n    var d     = 2\n    var num   = m\n    val ub    = Math.sqrt(m).floor\n    var count = 0\n    while (d <= ub) {\n      if (num % d == 0) {\n        num \/= d\n        count += 1\n      } else {\n        val a = count match {\n          case 0 => \"\"\n          case 1 => s\"($d)\"\n          case _ => s\"(${d}**$count)\"\n        }\n        res += a\n        d += 1\n        count = 0\n        if (num == 1)\n          d = ub.toInt + 1\n      }\n    }\n    if (num != 1)\n      res + s\"($num)\"\n    else\n      res\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54d7660d2daf68c619000d95":[{"id":333783,"user_id":1228,"body":"object Fracts {\n\n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    def reduceFraction(f: (Long, Long)): (Long, Long) =\n      f match { case (n, d) => val div = gcd(n, d); (n\/div, d\/div) }\n    \n    def gcd(a: Long, b: Long):Long=if (b==0) a.abs else gcd(b, a%b)\n    def lcm(a: Long, b: Long)=(a*b).abs\/gcd(a,b)\n    \n    val reducedFractions = lst.map(reduceFraction)\n    val commonDenominator = reducedFractions.map(_._2).reduceLeft(lcm)\n    reducedFractions.map { case (n, d) => (n * (commonDenominator\/d), commonDenominator) }.mkString\n  }\n}\n\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333784,"user_id":53,"body":"object Fracts {\n\n  def gcd(a: Long, b: Long): Long = {\n    if (b == 0) a\n    else gcd(b, a % b)\n  }\n  \n  def lcm(a: Long, b: Long): Long = (a * b) \/ gcd(a, b)\n  \n  def reduce(t: (Long, Long)): (Long, Long) = {\n    val (a, b) = t\n    val i = gcd(a, b)\n    (a \/ i, b \/ i)\n  }\n  \n  def norm(t: (Long, Long), cd: Long): (Long, Long) = {\n    val (a, b) = t\n    (a * cd \/ b, cd)\n  }\n  \n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    val xss = lst.map((xs) => reduce(xs))\n    val cd = xss.foldLeft(1L)((acc, xs) => lcm(xs._2, acc))\n    val yss = xss.map((xs) => norm(xs, cd))\n    yss.mkString(\" \").replaceAll(\"\\\\s\", \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333785,"user_id":null,"body":"object Fracts {\n\n   def convert_frac(lst: Array[(Long, Long)]): String = {    \n    def greatestCommDenom(a: Long, b: Long):Long=if (b==0) a.abs else greatestCommDenom(b, a%b)\n    \n    val simpleFracts = lst.map(x => x match { case (n, d) => val div = greatestCommDenom(n, d); (n\/div, d\/div) })\n    val commDenom = simpleFracts.map(_._2).reduceLeft((a,b) => (a*b).abs\/greatestCommDenom(a,b))\n    simpleFracts.map { case (n, d) => (n * (commDenom\/d), commDenom) }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333786,"user_id":492,"body":"object Fracts {\n\n  private def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n  private def lcm(a: Long, b: Long): Long = a * b \/ gcd(a, b)\n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    var lcmall: Long = 1\n    var newlst = List.newBuilder[(Long, Long)]\n    for (i <- 0 until lst.length) {\n      val g: Long = gcd(lst(i)._1, lst(i)._2)\n      val t = (lst(i)._1 \/ g, lst(i)._2 \/ g)\n      newlst += t\n    }\n    val newlist = newlst.result()\n    for (item <- newlist) {\n      lcmall = lcm(lcmall, item._2)\n    }\n    var result: String = \"\"\n    for (item <- newlist) {\n      result += \"(\" + (item._1 * lcmall \/ item._2) + \",\" + lcmall + \")\"\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333787,"user_id":null,"body":"object Fracts {\n  \n  def gcd(a: Long, b: Long): Long = if(b == 0) a else gcd(b, a % b)\n  def lcm(a: Long, b: Long): Long = a * b \/ gcd(a, b)\n  \n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    var reduced = lst.map { case (a, b) => (a \/ gcd(a, b), b \/ gcd(a, b)) }\n    val denom = reduced.map(_._2).reduce(lcm)\n    reduced.map { case (a, b) => (a * denom \/ b, denom) }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333788,"user_id":492,"body":"object Fracts {\n\n  private def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n  private def lcm(a: Long, b: Long): Long = a * b \/ gcd(a, b)\n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    var lcmall: Long = 1\n    var newlst = List.newBuilder[(Long, Long)]\n    for (i <- 0 until lst.length) {\n      val g: Long = gcd(lst(i)._1, lst(i)._2)\n      val t = (lst(i)._1 \/ g, lst(i)._2 \/ g)\n      newlst += t\n    }\n    val newlist = newlst.result()\n    for (item <- newlist) {\n      lcmall = lcm(lcmall, item._2)\n    }\n    var result: String = \"\"\n    for (item <- newlist) {\n      result += \"(\" + (item._1 * lcmall \/ item._2) + \",\" + lcmall + \")\"\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333789,"user_id":null,"body":"object Fracts {\n  def mcd(a:Long, b:Long): Long = if (a == 0) b else mcd( b%a, a );\n  def lcd(a:Long, b:Long): Long = a \/ mcd(a,b) * b;\n  def convert_frac(lst: Array[(Long, Long)]): String = {\n     val simpl = lst.map(pair => {val(a,b) = pair; val d = mcd(a,b); (a\/d, b\/d)})\n     val common = simpl.map(_._2).reduce(lcd)\n     return simpl.map(pair => { val(a,b) = pair; val d = common\/b; \"(\"+a*d+\",\"+ b*d+\")\"}).mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333790,"user_id":null,"body":"object Fracts {\n\n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    val converted = lst.map { case (first, second) => (BigInt(first), BigInt(second)) }\n    val (_, down) = converted.unzip\n    val downList = down.toList.sorted\n    def lcd = (a: BigInt, b: BigInt) =>\n      (a * b).abs \/ a.gcd(b)\n    @annotation.tailrec\n    def compute(innerList: List[BigInt]): BigInt = {\n      innerList match {\n        case head::Nil => head\n        case first::second::tail =>\n          compute(lcd(first, second) :: tail)\n      }\n    }\n    @annotation.tailrec\n    def compute1(innerList: List[BigInt]): BigInt = {\n      innerList match {\n        case head::Nil => head\n        case first::second::tail =>\n          compute1(first.gcd(second) :: tail)\n      }\n    }\n    val res = compute(downList)\n    val result = converted.map { case (up, down) => (up * res \/ down, res) }\n    val (up, _) = result.unzip\n    val upList = up.toList.reverse\n    val gcdResult = compute1(upList :+ res)\n    val totalResult = result.map { case (up, down) => (up \/ gcdResult, res \/ gcdResult) }\n    totalResult.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333791,"user_id":null,"body":"object Fracts {\n  \n  def gcd(x: List[Long]): Long = {\n      if (x.length>2) return gcd(List(x(0), gcd(x.slice(1,x.length))))\n      val a = x.max\n      val b = x.min\n      if(b==0) return a\n      val q = a\/b\n      val r = a%b\n      return gcd(List(b,r))    \n  }\n  \n  def lcm(x: List[Long]): Long = {\n    if (x.length>2) return lcm(List(x(0), lcm(x.slice(1,x.length))))\n    return x(0)*x(1)\/gcd(x)\n  }\n  \n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    if (lst.length==0) return \"\"\n    \n    val reduced = lst.map(x => {\n        val g = gcd(List(x._1,x._2)); (x._1\/g, x._2\/g)})\n    \n    if (reduced.length==1) return reduced.mkString(\"\")\n    \n    val cd = lcm(reduced.map(x => x._2).toList)\n    reduced.map(x => (x._1 * (cd\/x._2), cd)).mkString(\"\") \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333792,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Fracts {\n\n  def convert_frac(lst: Array[(Long, Long)]): String = {\n    @tailrec\n    def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n    def lcm(a: Long, b: Long): Long = a * b \/ gcd(a, b)\n    def lcmArray(lst: Array[(Long, Long)]): Long = lst.foldLeft(1.toLong)((a, b) => lcm(a, b._2 \/ (gcd(b._1, b._2))))\n    def convert_fracIter(lst: Array[(Long, Long)], lcm: Long): String = lst.map(i => f\"(${i._1 * lcm \/ i._2},$lcm)\").mkString\n    convert_fracIter(lst, lcmArray(lst))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54da539698b8a2ad76000228":[{"id":333793,"user_id":527,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    walk.size == 10 &&\n      walk.count(_ == \"n\") == walk.count(_ == \"s\") &&\n      walk.count(_ == \"e\") == walk.count(_ == \"w\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333794,"user_id":null,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    val List(n, s, e, w) = \"nsew\".toList.map(x => walk.count(_ == x))\n    walk.size == 10 && n == s && e == w\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333795,"user_id":null,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    walk.size == 10 && {\n      val mapped = walk.groupBy(identity).mapValues(_.size)\n      mapped.getOrElse(\"n\", 0) == mapped.getOrElse(\"s\", 0) &&\n        mapped.getOrElse(\"e\", 0) == mapped.getOrElse(\"w\", 0)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333796,"user_id":null,"body":"object Solution {\n def is_valid_walk(walk: Seq[String]): Boolean = {\n  var x = 0\n  var y = 0\n  if (walk.length == 10) {\n    for (coord <- walk) {\n      coord match {\n        case \"w\" => x -= 1\n        case \"e\" => x += 1\n        case \"s\" => y -= 1\n        case \"n\" => y += 1\n      }\n    }\n    if (x==0&&y==0)true\n    else false\n  }\n  else false\n}\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333797,"user_id":null,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    \/\/ your code here\n    \/\/val path = walk.map(letter => if (\"sw\" contains letter) 1 else -1 :Int)\n    val result = walk map {\n      case \"s\" => (0, 1)\n      case \"n\" => (0, -1)\n      case \"w\" => (1, 0)\n      case \"e\" => (-1, 0)\n    } reduce \n      ((a, b) => (a._1 + b._1, a._2 + b._2))\n    if (walk.length == 10 & result == (0, 0)) true else false\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333798,"user_id":null,"body":"object Solution {\n  def is_valid_walk(w: Seq[Char]): Boolean = {\n    w.size == 10 && w.count(_ == \"n\") == w.count(_ == \"s\") && w.count(_ == \"e\") == w.count(_ == \"w\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333799,"user_id":null,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    walk.size == 10 && walking(walk,0,0,0,0)\n  }\n  \n  def walking(walk: Seq[String],n:Int,s:Int,e:Int,w:Int):Boolean = {\n      \n       if(walk.isEmpty){\n         if(n == s && e == w) true else false       \n       }else{\n         walk.head match {\n           case\"n\" => walking(walk.tail,n+1,s,e,w)\n           case \"s\" => walking(walk.tail,n,s+1,e,w)\n            case \"e\" => walking(walk.tail,n,s,e+1,w)\n          case \"w\" => walking(walk.tail,n,s,e,w+1)\n          case _ => false\n         }\n       }\n    \n    }}\n   \n  \n\n\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333800,"user_id":null,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    walk.count(x => {x == \"w\"}) == walk.count(x => {x == \"e\"}) && walk.count(x => {x == \"n\"}) == walk.count(x => {x == \"s\"}) && walk.length == 10\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333801,"user_id":53,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    walk.length == 10 && \n    walk.count(n => n == \"n\") == walk.count(n => n == \"s\") &&\n    walk.count(n => n == \"e\") == walk.count(n => n == \"w\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333802,"user_id":null,"body":"object Solution {\n  def is_valid_walk(walk: Seq[String]): Boolean = {\n    if (walk.length != 10) false\n    else {\n      val wg = walk.groupBy(identity).map { case (k, v) => (k, v.length) }\n      wg.getOrElse(\"n\", 0) == wg.getOrElse(\"s\", 0) && wg.getOrElse(\"w\", 0) == wg.getOrElse(\"e\", 0)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54da5a58ea159efa38000836":[{"id":333803,"user_id":573,"body":"object FindTheOddInt {\n\n  def find_it(xs: Seq[Int]): Int =\n    xs.find(x => xs.count(_ == x) % 2 == 1).get\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333804,"user_id":527,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int = xs.reduce(_ ^ _)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333805,"user_id":573,"body":"object FindTheOddInt {\n\n  def find_it(xs: Seq[Int]): Int =\n    xs.groupBy(identity).collect { case (x, vs) if vs.size%2 == 1 => x }.head\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333806,"user_id":53,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int = {\n    xs.foldLeft(0)((acc, x) => acc ^ x)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333807,"user_id":null,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int = {\n    \n   val x = xs.groupBy(identity).mapValues(_.size).toSeq      \n   val y = x.filter( t => t._2 %2!=0 )\n   \n   y(0)._1\n  \n\n    \n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333808,"user_id":null,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int = \n    xs(xs.map(x => xs.count(_ == x)).indexWhere(_ % 2 != 0))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333809,"user_id":null,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int = \n    xs.groupBy(x =>x).filter(x =>x._2.length %2 !=0).head._1\n   \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333810,"user_id":null,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int = {\n    xs.groupBy(identity).filter(_._2.size % 2 != 0).head._1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333811,"user_id":null,"body":"object FindTheOddInt {\n  \/\/ As we're told there will only ever be one odd number\n  \/\/ we can use a logical XOR so all the even values will cancel out\n  def find_it(xs: Seq[Int]) = xs.foldLeft(0)(_^_)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333812,"user_id":null,"body":"object FindTheOddInt {\n  def find_it(xs: Seq[Int]): Int =\n    xs.groupBy(identity).collectFirst { case (key, values) if values.length % 2 == 1 => key }.get\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54db15b003e88a6a480000b9":[{"id":333813,"user_id":53,"body":"object ModSystem {\n  def gcd(a: Int, b: Int): Int=if (b == 0) a else gcd(b, a % b)\n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    val p = bases.foldLeft(1)((acc, e) => acc * e)\n    val q = bases.foldLeft(1)((acc, e) => (acc * e) \/ gcd(acc, e))\n    if (p < n || p != q) \"Not applicable\"\n    else bases.map((e) => s\"-${n % e}-\").mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333814,"user_id":573,"body":"object ModSystem {\n\n  def fromNb2Str(n: Int, bases: Array[Int]): String =\n    if (bases.product >= n && areCoprimes(bases)) s\"-${bases.map(n % _).mkString(\"--\")}-\" else \"Not applicable\"\n\n  def areCoprimes(bases: Array[Int]): Boolean = bases.combinations(2).forall(gcd(_) == 1)\n  def gcd(t: Array[Int]): Int = if (t(1) == 0) t(0) else gcd(Array(t(1), t(0) % t(1)))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333815,"user_id":492,"body":"import java.util.Arrays\nimport java.util.stream.Collectors\nobject ModSystem {\n\n  private def gcd(a: Int, b: Int): Int = if ((a == 0)) b else gcd(b % a, a)\n  private def lcm(a: Int, b: Int): Int = a * b \/ gcd(a, b)\n\n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    val product: Int = Arrays.stream(bases).reduce(1, (a, b) => a * b)\n    val baseLcm: Int = Arrays.stream(bases).reduce(1, ModSystem.lcm)\n    if (baseLcm != product || product <= n) return \"Not applicable\"\n    Arrays\n      .stream(bases)\n      .map((base) => n % base)\n      .mapToObj(java.lang.Integer.toString)\n      .collect(Collectors.joining(\"--\", \"-\", \"-\"))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333816,"user_id":null,"body":"object ModSystem {\n  \n  def gcd(x: Int, y: Int): Int = {\n    if (x == 0) y\n    else if (y == 0) x\n    else if (x < y) gcd(x, y - x)\n    else gcd(x - y, y)\n  }\n  \n  def isPrime(i: Int): Boolean = {\n    if (i <= 1) false\n    else if (i == 2) true\n    else !(2 to (i-1)).exists(x => i % x == 0)\n  }\n    \n  def isCoprimeTo(x: Int, i: Int) = gcd(i, x) == 1\n  \n  def fromNb2Str(n: Int, bases: Array[Int]): String = {    \n    val pairs = for(x <- bases; y <- bases if x != y) yield(x,y)\n    val moduli = bases.map(x => s\"-${n%x}-\").mkString\n    val coprimes = for (pair <- pairs) yield !isCoprimeTo(pair._1, pair._2)\n    \n    if((coprimes contains true) || (bases.product < n)) \"Not applicable\" else moduli\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333817,"user_id":null,"body":"object ModSystem {\n\n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    for (x <- bases) {\n      for (y <- bases) {\n        if (x != y && gcd(x, y) != 1) {\n          return \"Not applicable\"\n        }\n      }\n    }\n\n    if (bases.product < n) {\n      return \"Not applicable\"\n    }\n\n    var result: String = \"\"\n\n    for (base <- bases) {\n      result += \"-\" + (n % base).toString + \"-\"\n    }\n\n    result\n  }\n\n  private def gcd(a: Int, b: Int): Int = {\n    if (b == 0) {\n      a\n    } else {\n      gcd(b, a % b)\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333818,"user_id":null,"body":"object ModSystem {\n  def gcd(x: Int, y: Int): Int = {\n    if (y == 0) math.abs(x) else gcd(y, x % y)\n  }\n  \n  def lcm(x: Int, y: Int): Int = math.abs(x * y) \/ gcd(x, y)\n  \n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    val product = bases.reduce((x, y) => x*y)\n    val coprimeCheck = bases.reduce((x, y) => lcm(x, y)) == product\n    val productCheck = (product > n)\n    if (coprimeCheck && productCheck) {\n      val moduli = bases.map(x => n % x).mkString(\"--\")\n      s\"-$moduli-\"\n    }\n    else {\n      \"Not applicable\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333819,"user_id":null,"body":"object ModSystem {\n\n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    if (bases.product <= n) \"Not applicable\"\n    else if ((for (x <- bases; y <- bases if x != y) yield (x, y)).exists(p => gcd(p._1, p._2) != 1)) \"Not applicable\"\n    else bases.map(n % _).map(\"-\" + _ + \"-\").mkString\n  }\n\n  def gcd(a: Int, b: Int): Int = {\n    if (b == 0) a else gcd(b, a % b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333820,"user_id":null,"body":"object ModSystem {\n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    def gcd(x: Int, y: Int): Int = if (y == 0) x else gcd(y, x % y)\n\n    if (bases.product <= n || bases.combinations(2).exists(x => gcd(x.head, x.tail.head) != 1)) \"Not applicable\"\n    else bases.map(n % _).mkString(\"-\", \"--\", \"-\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333821,"user_id":null,"body":"object ModSystem {\n\n  def fromNb2Str(n: Int, bases: Array[Int]): String =\n    if (\n      bases.product <= n ||\n      (0 to bases.length - 2).exists(i => (i + 1).until(bases.length).exists(j => gcd(bases(i), bases(j)) > 1))\n    ) {\n      \"Not applicable\"\n    } else {\n      bases.map(n % _).mkString(\"-\", \"--\", \"-\")\n    }\n\n  @scala.annotation.tailrec\n  private def gcd(a: Long, b: Long): Long =\n    if (b == 0) math.abs(a) else gcd(b, a % b)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333822,"user_id":null,"body":"object ModSystem {\n\n  def fromNb2Str(n: Int, bases: Array[Int]): String = {\n    \/\/ your code\n    val prod = bases reduce(_*_)\n    val vect = bases.sliding(2).toVector\n    val ite = vect map(x => gcd(x(0),x(1)))\n    var result = \"\"\n    \n \n    if(prod < n || ite.contains(2)) {\n      result = \"Not applicable\"\n    } else {\n      result = \"-\"+(bases map (x => n % x) mkString(\"--\")) + \"-\" \n    }\n    result\n  }\n  \n  def gcd(a: Int, b: Int): Int = {\n\n  if (b == 0) a\n\n  else gcd(b, a % b)\n\n}                                                 \/\/> gcd: (a: Int, b: Int)Int\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54dc6f5a224c26032800005c":[{"id":333823,"user_id":573,"body":"object StockList {\n\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = {\n    val counts = lstOfArt.map(_.split(\" \")).groupMapReduce(_(0).take(1))(_(1).toInt)(_ + _)\n    if (lstOfArt.isEmpty) \"\" else lstOfCat.map(cat => s\"($cat : ${counts.getOrElse(cat, 0)})\").mkString(\" - \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333824,"user_id":573,"body":"object StockList {\n\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String =\n    lstOfArt.size match {\n      case 0 => \"\"\n      case _ =>\n        val counts = lstOfArt.map(_.split(\" \")).groupBy(_(0).head.toString).mapValues(_.map(_(1).toInt).sum)\n        lstOfCat.map(category => s\"($category : ${counts.getOrElse(category, 0)})\").mkString(\" - \")\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333825,"user_id":null,"body":"object StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = {\n    if (lstOfArt.isEmpty) return \"\"\n    lstOfCat\n      .map(c => c -> lstOfArt.filter(s => s.startsWith(c)).foldLeft(0)((acc, s) => acc + s.split(\" \").last.toInt))\n      .map { case (cat, num) => s\"($cat : $num)\"}\n      .mkString(\" - \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333826,"user_id":492,"body":"import java.util.Collections\nimport java.util.Arrays\n\nobject StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = {\n    if (lstOfArt.length == 0 || lstOfCat.length == 0) return \"\"\n    var output: String = \"\"\n    for (letter <- lstOfCat) {\n      var s: Int = 0\n      for (stock <- lstOfArt if stock.charAt(0) == letter.charAt(0)) {\n        val parts: Seq[String] = stock.split(\" \")\n        s += java.lang.Integer.parseInt(parts(1))\n      }\n      output += \"(\" + letter.charAt(0) + \" : \" + s + \") - \"\n    }\n    output.replaceAll(\" - $\", \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333827,"user_id":null,"body":"object StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = {\n    if (lstOfArt.isEmpty || lstOfCat.isEmpty) return \"\"\n    \n    val tableOfArt = lstOfArt.map(_.split(\" \")) \/\/ split each element in the array\n      .map(list => list(0)(0).toString -> list(1).toInt) \/\/create a tuple of the label and quantity\n      .groupMapReduce(lst => lst._1)(_._2)(_ + _) \/\/ create a map of the label and its quantity sum\n      .withDefaultValue(0)\n  \n    val summary = lstOfCat.map(cat => s\"($cat : ${tableOfArt(cat)})\")\n    summary.mkString(\" - \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333828,"user_id":null,"body":"object StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = {\n    if(lstOfCat.isEmpty || lstOfArt.isEmpty) return \"\"\n    val totals=lstOfArt.groupBy(x=> x(0).toString).map(t=> if(lstOfCat.contains(t._1)) (t._1,t._2.map(_.split(\" \")(1).toInt).sum) else (\"\",\"\"))\n    lstOfCat.map(x=> s\"($x : ${totals.getOrElse(x,0)})\").mkString(\" - \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333829,"user_id":null,"body":"object StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = {\n    \/\/ your code\n    if (lstOfArt.isEmpty || lstOfCat.isEmpty) \"\"\n    else lstOfCat.map {code =>\n      val amount = lstOfArt\n        .filter{ str => str(0) == code(0)}\n        .map(_.split(\" \"))\n        .map(arr => arr(1).toInt)\n        .sum\n      s\"($code : $amount)\"\n    }.mkString(\" - \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333830,"user_id":null,"body":"object StockList {\n  def stock_list(a: Seq[String], b: Seq[String]): String = {\n    println(b)\n    if (a.length == 0 || b.length == 0) {\n      \"\"\n    } else {\n      val reg = \"(\\\\w)\\\\w+ (\\\\d+)\".r\n      var data: Map[String, Int] = b.map((_, 0)).toMap\n\n      a.foreach((x) => {\n        val res = reg.findFirstMatchIn(x).get\n        val code = res.group(1)\n        val count = res.group(2)\n\n        if (data.contains(code)) {\n          data = data.updated(code, data(code) + count.toInt)\n        }\n      })\n      var orderedList: List[Tuple2[String, Int]] = List()\n      \n      b.foreach(x => orderedList = orderedList :+ (x, data(x)))\n\n      orderedList.toList.map(x => s\"(${x._1} : ${x._2})\").mkString(\" - \") \n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333831,"user_id":null,"body":"object StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String =\n    if (lstOfArt.isEmpty || lstOfCat.isEmpty) \"\"\n    else lstOfCat.map { c =>\n      val count = lstOfArt.withFilter(_.headOption.exists(_ == c.head)).map(_.split(' ').last.toInt).sum\n\n      s\"($c : $count)\"\n    }.mkString(\" - \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333832,"user_id":468,"body":"object StockList {\n  def stock_list(lstOfArt: Seq[String], lstOfCat: Seq[String]): String = if (lstOfArt.isEmpty || lstOfCat.isEmpty) \"\" else {\n    val sum = lstOfArt\n      .filter(title => lstOfCat.contains(title.head.toString))\n      .groupBy(_.head)\n      .map { case (group, title) =>\n        group.toString -> title.map(_.split(\" \").last.toInt).sum\n      }\n\n    lstOfCat.map { group =>\n      s\"($group : ${sum.getOrElse(group, 0)})\"\n    }.mkString(\" - \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54de3257f565801d96001200":[{"id":333833,"user_id":636,"body":"object OrdersSummary {\n\n  case class Order(tick: String, amt: Int, value: Double, buysell: Char){\n    assert (buysell=='B' || buysell=='S')\n  }\n\n  def processOrder (orderCandidate: String) : Either[String, (Double,Double)] =\n    if (orderCandidate.isEmpty) Right(0, 0) else {\n      try {\n        val parts = orderCandidate.split(\" \")\n        val Order(tick, amt, value, buysell) =\n          Order(parts(0), parts(1).toInt, if (parts(2).contains(\".\")) parts(2).toDouble else \"fail\".toDouble, parts(3)(0))\n        val total = scala.math.round(amt * value)\n        Right(if (buysell == 'B') (total, 0) else (0, total))\n      } catch {\n        case e: Throwable => Left(s\"$orderCandidate\")\n      }\n    }\n  def balanceStatements(lst: String): String = {\n    val orders = lst.split(\", \")\n    val processed = orders.toList map (x => processOrder(x))\n    val buySellTotals = (processed filter (_.isRight) map (x => x.getOrElse(0.0,0.0))).foldLeft((0.0,0.0))((t,a) => (t._1+a._1, t._2+a._2))\n    val badOrders = processed filter (_.isLeft) map (x => x.left.getOrElse(\"\"))\n    val totals = s\"Buy: ${buySellTotals._1.round} Sell: ${buySellTotals._2.round}\"\n    val s = new StringBuffer()\n    println(s\"${badOrders.length}  $badOrders\")\n    if (badOrders.length > 0 ) {\n      s.append(s\"; Badly formed ${badOrders.length}: \")\n      for (i<- 1 to badOrders.length) s.append(s\"${badOrders(i-1)} ;\")\n    }\n    totals ++ s.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333834,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\nobject OrdersSummary {\n\n  def balanceStatements(lst: String): String = {\n    val orders: Array[String] = lst.split(\", \")\n    var toBuy: Double = 0\n    var toSell: Double = 0\n    var badlyFormed: ListBuffer[String] = ListBuffer()\n    val pattern = \"[^\\\\s]+ ([0-9]+) ([0-9]+\\\\.[0-9]+) (B|S)\"\n    val regex = pattern.r\n    for (order <- orders) {\n      if(order.matches(pattern)) {\n        val regex(quantity, price, status) = order\n        if(status.equals(\"B\")) toBuy += quantity.toInt * price.toDouble\n        else toSell += quantity.toInt * price.toDouble\n      }\n      else {\n        if(!order.trim.isEmpty) badlyFormed += (order + \" ;\")\n      }\n    }\n    var response = \"Buy: \"+Math.round(toBuy)+\" Sell: \"+Math.round(toSell)\n    if(badlyFormed.length > 0) {\n      response += \"; Badly formed \"+badlyFormed.length+\": \"\n      for (badString <- badlyFormed) {\n        response += badString\n      }\n    }\n    return response\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333835,"user_id":492,"body":"import java.util.ArrayList\nimport java.util.regex._\n\nobject OrdersSummary {\n\n  def balanceStatements(lst: String): String = {\n    val orders: Array[String] = lst.split(\", \")\n    val badlyformed: ArrayList[String] = new ArrayList[String]()\n    var buytotal: Double = 0\n    var selltotal: Double = 0\n    val orderpat: Pattern = Pattern.compile(\"^\\\\S+ (\\\\d+) (\\\\d*\\\\.\\\\d+) ([BS])$\")\n    for (order <- orders) {\n      if (!order.isEmpty) {        \n        val mtch: Matcher = orderpat.matcher(order)\n        if (mtch.matches()) {\n          val price: Double = java.lang.Integer.parseInt(mtch.group(1)) * java.lang.Double.parseDouble(mtch.group(2))\n          if (\"B\" == mtch.group(3)) {\n            buytotal += price\n          } else {\n            selltotal += price\n          }\n        } else {\n          badlyformed.add(order)\n        }\n      }\n    }\n    \"Buy: \" + Math.round(buytotal) + \" Sell: \" + Math.round(selltotal) +\n      (if (badlyformed.size > 0)\n         \"; Badly formed \" + badlyformed.size + \": \" + String.join(\n           \" ;\",\n           badlyformed) +\n           \" ;\"\n       else \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333836,"user_id":573,"body":"import scala.util.Try\n\nobject OrdersSummary {\n\n  def balanceStatements(input: String): String = {\n\n    val orders = input\n        .split(\", \")\n        .map(_.split(\" \"))\n        .map {\n          case order @ Array(stock, quantity, price, \"B\") if price.contains(\".\") =>\n            Try(Buy((quantity.toInt * price.toDouble))).getOrElse(Error(order.mkString(\" \")))\n          case order @ Array(stock, quantity, price, \"S\") if price.contains(\".\") =>\n            Try(Sell((quantity.toInt * price.toDouble))).getOrElse(Error(order.mkString(\" \")))\n          case error =>\n            Error(error.mkString(\" \"))\n        }\n\n    val totalBought = orders.collect { case o: Buy => o.amount }.sum.round.toInt\n    val totalSold = orders.collect { case o: Sell => o.amount }.sum.round.toInt\n    val errors = orders.collect { case o: Error if o.order != \"\" => o.order }\n\n    val orderSummary = s\"Buy: $totalBought Sell: $totalSold\"\n    val errorSummary = if (errors.nonEmpty) s\"; Badly formed ${errors.size}: ${errors.mkString(\" ;\")} ;\" else \"\"\n\n    s\"$orderSummary$errorSummary\"\n  }\n\n  sealed trait Action\n  case class Sell(amount: Double) extends Action\n  case class Buy(amount: Double) extends Action\n  case class Error(order: String) extends Action\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333837,"user_id":null,"body":"object OrdersSummary {\n\ndef balanceStatements(lst: String): String = {\n    val orders = lst.split(',').map(_.trim().split(' ')).filter(_.length > 1)\n\n    val priceList = orders.map {\n      case Array(_, q, p, \"B\") if !q.contains(\".\") && p.contains(\".\") => (p.toDouble * q.toDouble)\n      case Array(_, q, p, \"S\") if !q.contains(\".\") && p.contains(\".\") => -(p.toDouble * q.toDouble)\n      case _ => 0\n    }\n\n    val buy = priceList.filter(_ > 0).sum.round\n    val sell = priceList.filter(_ < 0).sum.round.abs\n    val errNo = priceList.count(_ == 0)\n    val errMsg = priceList.zipWithIndex.filter(_._1 == 0).map(errIdx => orders(errIdx._2).mkString(\" \"))\n\n    \"Buy: \" + buy + \" Sell: \" + sell + {if (errNo > 0) s\"; Badly formed $errNo: ${errMsg.mkString(\" ;\")} ;\"  else \"\"}\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333838,"user_id":492,"body":"import java.util.ArrayList\nimport java.util.regex._\n\nobject OrdersSummary {\n\n  def balanceStatements(lst: String): String = {\n    val orders: Array[String] = lst.split(\", \")\n    val badlyformed: ArrayList[String] = new ArrayList[String]()\n    var buytotal: Double = 0\n    var selltotal: Double = 0\n    val orderpat: Pattern = Pattern.compile(\"^\\\\S+ (\\\\d+) (\\\\d*\\\\.\\\\d+) ([BS])$\")\n    for (order <- orders) {\n      if (!order.isEmpty) {        \n        val mtch: Matcher = orderpat.matcher(order)\n        if (mtch.matches()) {\n          val price: Double = java.lang.Integer.parseInt(mtch.group(1)) * java.lang.Double.parseDouble(mtch.group(2))\n          if (\"B\" == mtch.group(3)) {\n            buytotal += price\n          } else {\n            selltotal += price\n          }\n        } else {\n          badlyformed.add(order)\n        }\n      }\n    }\n    \"Buy: \" + Math.round(buytotal) + \" Sell: \" + Math.round(selltotal) +\n      (if (badlyformed.size > 0)\n         \"; Badly formed \" + badlyformed.size + \": \" + String.join(\n           \" ;\",\n           badlyformed) +\n           \" ;\"\n       else \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333839,"user_id":1285,"body":"object OrdersSummary {\n\n  def balanceStatements(lst: String): String = {\n    if (lst == \"\") return \"Buy: 0 Sell: 0\"\n    val regex = \"\\\\S+\\\\s\\\\d+\\\\s\\\\d+\\\\.\\\\d+\\\\s[BS]\".r\n    val reduced = lst.split(\", \")\n      .map(s => if (regex matches s) {\n        val split = s.split(\" \")\n        if (split(3) == \"B\") {\n          (split(1).toInt * split(2).toDouble, \"B\")\n        } else {\n          (split(1).toInt * split(2).toDouble, \"S\")\n        }\n      } else {\n        (-1.0, s)\n      })\n      .foldLeft((0.0, 0.0, 0, \"\"))((acc, cur) => {\n        cur._2 match {\n          case \"B\" => (acc._1 + cur._1, acc._2, acc._3, acc._4)\n          case \"S\" => (acc._1, acc._2 + cur._1, acc._3, acc._4)\n          case _ => (acc._1, acc._2, acc._3 + 1, s\"${acc._4}${cur._2} ;\")\n        }\n      })\n\n    val buy = Math.round(reduced._1).toInt\n    val sell = Math.round(reduced._2).toInt\n    if (reduced._3 == 0) s\"Buy: $buy Sell: $sell\"\n    else s\"Buy: $buy Sell: $sell; Badly formed ${reduced._3}: ${reduced._4}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333840,"user_id":null,"body":"import scala.util.Try\n\nobject OrdersSummary {\n  def parseDouble(s: String): Option[Double] = Try { s.toDouble }.toOption\n  \n  def check1(s: String): Boolean = parseDouble(s) != None && !s.contains('.')\n  \n  def check2(s: String): Boolean = parseDouble(s) != None && s.contains('.')\n  \n  def check3(s: String): Boolean = s == \"B\" || s == \"S\"\n  \n  def simplify(quote: String): String = {\n    val parts = quote.split(\" \")\n    if(parts.length != 4 || !check1(parts(1)) || !check2(parts(2)) || !check3(parts(3)))\n    {\n      println(quote)\n      quote.concat(\" ;\")\n    }\n    else \n    {\n      val price = parts(1).toDouble * parts(2).toDouble\n      if (parts(3) == \"B\") {\n        (price * -1).toString\n      }\n      else {\n        price.toString\n      }\n    }\n  }\n  \n  def balanceStatements(lst: String): String = {\n    if (lst == \"\")\n    {\n      \"Buy: 0 Sell: 0\"\n    }\n    val list = lst.split(\", \")\n    val simplified = list.map(x => simplify(x)).filter(_ != \" ;\")\n    val buy = simplified.filter(x => x(0) == '-').map(x => x.drop(1).toDouble).sum\n    val sell = simplified.filter(x => x(0).isDigit).map(x => x.toDouble).sum\n    val bad = simplified.filter(x => x(0) != '-' && !x(0).isDigit)\n    val beginning = s\"Buy: ${math.round(buy).toInt} Sell: ${math.round(sell).toInt}\"\n    if (bad.length == 0){\n      beginning\n    }\n    else {\n      beginning.concat(s\"; Badly formed ${bad.length}: ${bad.mkString(\"\")}\")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333841,"user_id":null,"body":"object OrdersSummary {\n\n  import scala.util._\n  import scala.collection.mutable.ArrayBuffer\n  \n  def balanceStatements(lst: String): String = {\n    val errors = ArrayBuffer[String]()\n    case class Summary(buy: Double, sell: Double, errorCount: Int) {\n      override def toString(): String = f\"Buy: ${buy}%1.0f Sell: ${sell}%1.0f\"\n    }\n    \n    def extract(s: String): Try[Summary] = Try {\n      if (s.isEmpty) return Try(Summary(0, 0, 0))\n      val patt = \"(\\\\S*) (\\\\d*) (\\\\d*\\\\.\\\\d*) ([BS])\".r\n      val patt(stock, quantity, price, buyOrSell) = s\n      if (buyOrSell == \"B\") Summary(price.toDouble * quantity.toDouble, 0, 0) else Summary(0, price.toDouble * quantity.toDouble, 0)\n    }\n    \n    def process(txn: String): Summary = {\n      val summary = extract(txn) match {\n        case Failure(_) => {\n          errors += txn\n          Summary(0, 0, 1)\n        }\n        case Success(s) => s\n      }\n      summary\n    }\n    \n    val toks = lst.split(\",\")\n    val summarys = for {\n      tok <- toks\n    } yield process(tok.trim)\n    \n    val finalSummary = summarys.foldLeft(Summary(0, 0, 0))((acc, x) => {\n      Summary(acc.buy + x.buy, \n              acc.sell + x.sell,\n              acc.errorCount + x.errorCount\n             )})\n    if (errors.size > 0) s\"${finalSummary}; Badly formed ${finalSummary.errorCount}: ${errors.mkString(\" ;\")} ;\"\n    else s\"${finalSummary}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333842,"user_id":null,"body":"object OrdersSummary {\n\n  val intR = \"[0-9]+\"\n  val doubleR = \"[0-9]+\\\\.[0-9]+\"\n\n  def balanceStatements(lst: String): String = {\n    val (finalBuy, finalSell, finalBad) =\n      lst.split(\",\").foldLeft((0.0, 0.0, List.empty[String])) {\n        case ((buy, sell, bad), elem) =>\n          scala.util\n            .Try {\n              elem.trim.split(\" \") match {\n                case Array(_, s, p, \"B\")\n                  if s.matches(intR) && p.matches(doubleR) =>\n                  (buy + (s.toInt * p.toDouble), sell, bad)\n                case Array(_, s, p, \"S\")\n                  if s.matches(intR) && p.matches(doubleR) =>\n                  (buy, sell + (s.toInt * p.toDouble), bad)\n              }\n            }\n            .fold(\n              _ => (buy, sell, elem.trim :: bad),\n              e => e\n            )\n      }\n\n    val b = String.format(\"%.0f\", finalBuy)\n    val s = String.format(\"%.0f\", finalSell)\n    s\"Buy: $b Sell: $s\" + Option\n      .when(finalBad.nonEmpty && lst.nonEmpty)(finalBad)\n      .map(list =>\n        s\"; Badly formed ${list.size}: ${list.reverse.map(s => s + \" ;\").mkString}\"\n      )\n      .getOrElse(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54e320dcebe1e583250008fd":[{"id":333843,"user_id":null,"body":"object Dec2Fact {\n  val base36 = ('0' to '9') ++ ('A' to 'Z')\n  def factorial: Stream[Long] = 1 #:: factorial.zip(Stream.from(1)).map(x => x._1 * x._2)\n  def dec_2_fact_string(nb: Long): String = {\n  \tval facts = factorial.takeWhile(_ <= nb).toList.reverse\n  \tfacts.foldLeft((\"\", nb)){ case ((result, remaining), fact) =>\n  \t\t(result + base36((remaining \/ fact).toInt)) -> (remaining % fact)\n  \t}._1\n  }\n  def fact_string_2_dec(str: String): Long = {\n  \tval facts = factorial.take(str.length).toList\n  \tstr.indices.foldLeft(0L){ (t, i) =>\n  \t\tt + (base36.indexOf(str(str.length-i-1)) * facts(i))\n  \t}\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 21:25:57"},{"id":333844,"user_id":468,"body":"import scala.annotation.tailrec\n\nobject Dec2Fact {\n\n  \/**\n   * Coverts the input from base 10 to a factorial based number\n   *\n   * Consider the example 463.\n   * This can be transformed into a factorial representation by these successive divisions:\n   *\n   * 463 \u00f7 1 = 463, remainder 0\n   * 463 \u00f7 2 = 231, remainder 1\n   * 231 \u00f7 3 = 77 , remainder 0\n   *  77 \u00f7 4 = 19 , remainder 1\n   *  19 \u00f7 5 = 3  , remainder 4\n   *   3 \u00f7 6 = 0  , remainder 3\n   *\n   * The process terminates when the quotient reaches zero.\n   * Reversing the reminders gives the desired number: '341010'.\n   *\n   * @param nb The number in base 10 to convert\n   * @param acc The accumulated list of reminders. Optional, starts with Nil\n   * @param divisor The divisor for each step. Optional, starts at 1\n   * @return The input in Factorial base\n   *\/\n  @tailrec\n  def dec_2_fact_string(nb: Long, acc: List[Long] = Nil, divisor: Int = 1): String =\n    if (nb != 0) dec_2_fact_string(nb \/ divisor, (nb % divisor) :: acc, divisor + 1)\n    else acc.map { digit =>\n      if (digit < 10) (digit + '0').toChar\n      else (digit + '7').toChar \/\/ '7' is 10 less than 'A', this is == digit - 10 + 'A'\n    }.mkString\n\n  def fact_string_2_dec(str: String): Long = fact_string_2_dec(str.toList, str.length, 0)\n\n  \/**\n   * Coverts input from factorial based number to decimal.\n   *\n   * Consider the example: 341010\n   * -> 3\u00d75! + 4\u00d74! + 1\u00d73! + 0\u00d72! + 1\u00d71! + 0\u00d70!\n   * -> ((((3\u00d75 + 4)\u00d74 + 1)\u00d73 + 0)\u00d72 + 1)\u00d71 + 0\n   * -> 463\n   *\n   * This implementation assumes a '0' at the start of the number, like so:\n   * 0341010\n   * -> 0\u00d76! + 3\u00d75! + 4\u00d74! + 1\u00d73! + 0\u00d72! + 1\u00d71! + 0\u00d70!\n   * -> (((((0\u00d76 + 3)\u00d75 + 4)\u00d74 + 1)\u00d73 + 0)\u00d72 + 1)\u00d71 + 0\n   * -> 463\n   *\n   * Note that this makes iteration simpler:\n   *   0\u00d76 + 3 = 3\n   *   3\u00d75 + 4 = 19\n   *  19\u00d74 + 1 = 77\n   *  77\u00d73 + 0 = 231\n   * 231\u00d72 + 1 = 463\n   * 463\u00d71 + 0 = 463\n   *\n   * @param list       the input String, as a list of characters\n   * @param multiplier the multiplier to apply at each step\n   * @param acc        the accumulated number\n   * @return The input in base 10\n   *\/\n  @tailrec\n  def fact_string_2_dec(list: List[Char], multiplier: Int, acc: Long): Long = list match {\n    case head :: tail => fact_string_2_dec(tail, multiplier - 1, acc * multiplier + head.asDigit)\n    case Nil => acc\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 21:26:02"},{"id":333845,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Dec2Fact {\n   def dec_2_fact_string(nb: Long): String = {\n    val factorials = constructFactorialReference(nb, sizeBased = false)\n    decodeFactToString(nb, factorials)\n  }\n\n  @tailrec\n  def decodeFactToString(nb: Long, factorials: Array[Long], result: String = \"\"): String = {\n    if (factorials.isEmpty) result\n    else {\n      val factorial = factorials.head\n      val mul = nb \/ factorial\n      val res = if (mul > 9) result + (mul + 55).toChar else result + mul\n      decodeFactToString(nb - mul * factorial, factorials.tail, res)\n    }\n  }\n\n  def fact_string_2_dec(str: String): Long = {\n    val factorials = constructFactorialReference(str.length)\n    str.reverse.zipWithIndex.map(entry => {\n      val indx = entry._2\n      val value = entry._1\n      val mul = if (value.isLetter) value.toInt - 55 else Integer.parseInt(value.toString)\n      mul * factorials(indx)\n    }).sum\n  }\n\n  @tailrec\n  def constructFactorialReference(size: Long, sizeBased: Boolean = true, fact: Array[Long] = Array(1)): Array[Long] = {\n    val index = fact.length\n    val next = fact.last * index\n    if (sizeBased)\n      if (index == size) fact\n      else constructFactorialReference(size, sizeBased = true, fact :+ next)\n    else {\n      if (size \/ next == 0) fact.reverse\n      else constructFactorialReference(size, sizeBased = false, fact :+ next)\n    }\n  }\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333846,"user_id":492,"body":"object Dec2Fact {\n  private def fact(n: Int): Long = (2L to n.toLong).foldLeft(1L)(_*_) \n  def dec_2_fact_string(nb: Long): String = {\n    var nnb = nb\n    var q: Long = nnb \/ 1\n    var res: String = \"0\"\n    var rad: Long = 2\n    while (q != 0) {\n      q = nnb \/ rad\n      val r: Int = (nnb % rad).toInt\n      if (r <= 9) res += (r + 48).toChar else res += (r + 55).toChar\n      nnb = q\n      rad += 1\n    }\n    new StringBuilder(res).reverse.toString\n  }\n  def fact_string_2_dec(str: String): Long = {\n    var greatestFact: Int = str.length - 1\n    var res: Long = 0\n    var i: Int = 0\n    while (i < str.length) {\n      val c: Char = str.charAt(i)\n      if (c.toInt <= 57) res += (c.toInt - 48) * fact(greatestFact)\n      else res += (c.toInt - 55) * fact(greatestFact)\n      greatestFact -= 1 \n      i += 1\n    }\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333847,"user_id":null,"body":"object Dec2Fact {\n  val Digits: String = (('0' to '9') ++: ('A' to 'Z')).mkString\n  val DigitValues: Map[Char, Int] = Digits.toArray.zip(0 to 35).toMap\n\n  def dec_2_fact_string(n: Long, r: String = \"0 \"): String = if (n == 0) r.trim\n    else dec_2_fact_string(n \/ r.size, Digits((n % r.size).toInt) +: r)\n\n  def fact_string_2_dec(str: String, n: Long = 0): Long = if (str == \"0\") n\n    else fact_string_2_dec(str.tail, (n + DigitValues(str.head)) * (str.size - 1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333848,"user_id":573,"body":"object Dec2Fact {\n\n  val bases = (1 to 20).scanLeft(1L) { case (f_1, n) => n*f_1 }\n\n  def dec_2_fact_string(nb: Long): String =\n    bases\n      .reverse\n      .scanLeft((nb, 0L)) {\n        case ((rest, _), base) =>\n          val value = rest \/ base\n          val newRest = rest - value * base\n          (newRest, value)\n      }\n      .dropWhile(_._2 == 0)\n      .map {\n        case (_, v) if v < 10 => v.toString\n        case (_, v)           => ('A' to 'Z')(v.toInt - 10).toString\n      }\n      .mkString\n\n  def fact_string_2_dec(str: String): Long =\n    str\n      .reverse\n      .zipWithIndex\n      .map {\n        case (c, i) if c.isDigit => bases(i) * c.toString.toLong\n        case (c, i)              => bases(i) * (('A' to 'Z').indexOf(c) + 10L)\n      }\n      .sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333849,"user_id":null,"body":"import scala.collection.mutable\n\nobject Dec2Fact {\n  def dec_2_fact_string(nb: Long): String = {\n    ((0 to 36).takeWhile(fact(_) < nb).last to 0 by -1)\n      .map(fact)\n      .foldLeft((\"\", nb))((agg, next) => {\n        (agg._1 + valueToDigit((agg._2 \/ next).toInt), agg._2 % next)\n      })\n      ._1\n  }\n\n  def fact_string_2_dec(str: String): Long =\n    str.reverse.map(digitValue)\n      .zipWithIndex\n      .map(t => t._1 * fact(t._2))\n      .sum\n\n  def digitValue(c: Char) =\n    if (c >= 'A') c - 'A' + 10\n    else c - '0'\n\n  def valueToDigit(v: Int): Char =\n    if (v < 10) (v + '0').toChar\n    else ('A' + (v - 10)).toChar\n\n  val factCache = mutable.Map(0 -> 1L)\n\n  def fact(n: Int): Long = factCache.getOrElseUpdate(n, n * fact(n - 1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333850,"user_id":null,"body":"object Dec2Fact {\n  \/**\n   * Given a number, compute the condensed factorial notation.\n   * @param nb\n   * @return\n   *\/\n  def dec_2_fact_string(nb: Long): String = {\n    def helper(nb: Long, divisor: Long, acc: String): String = {\n      val newNum = nb \/ divisor\n      val remainder = nb % divisor\n      val result = remainder.toHexString.toUpperCase() + acc\n      if (newNum <= 0) {\n        result\n      } else {\n        helper(newNum, divisor + 1, result)\n      }\n    }\n    helper(nb, 1, \"\")\n  }\n\n  \/**\n   * Given a number, compute the factorial\n   * @param num\n   * @return\n   *\/\n  def factorial(num: Long): Long = {\n    if (num < 0) {\n      0L\n    } else if (num == 1) {\n      1L\n    } else {\n      num * factorial(num - 1)\n    }\n  }\n\n  \/**\n   * Convert a character hex value to decimal\n   * For example, 'A' is 10\n   * @param ch\n   * @return\n   *\/\n  def fromHexString(ch: Char): Int = {\n    Integer.parseInt(ch.toString, 16)\n  }\n\n  \/**\n   * Given a string in factorial notation, return the decimal value.\n   * For example, \"10\" is 1\u00d71! + 0\u00d70! = 1\n   * @param str\n   * @return\n   *\/\n  def fact_string_2_dec(str: String): Long = {\n    str.reverse.zipWithIndex.map {\n      case (ch, index) => fromHexString(ch) * factorial(index)\n    }.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333851,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Dec2Fact {\n  private val intToChar = {\n    val codeSequence = ('0' to '9') ++ ('A' to 'Z')\n    (0 to codeSequence.length)\n      .zip(codeSequence)\n      .toMap\n  }\n  private val charToInt = intToChar.map(_.swap)\n\n  def dec_2_fact_string(nb: Long): String = {\n    toFactorial(nb, 1, Nil)\n      .map(intToChar)\n      .mkString\n  }\n\n  @tailrec\n  def toFactorial(number: Long, base: Int, factorials: List[Int]): List[Int] = {\n    val next = number \/ base\n    val nexFactorials = (number % base).toInt :: factorials\n    if (next == 0) {\n      nexFactorials\n    } else {\n      toFactorial(next, base + 1, nexFactorials)\n    }\n  }\n\n  def fact_string_2_dec(str: String): Long = {\n    str\n      .map(charToInt)\n      .reverse\n      .zipWithIndex\n      .reverse\n      .foldLeft(0L) {\n        case (res, (base, 0)) => (res + base)\n        case (res, (base, n)) => (res + base) * n\n      }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"},{"id":333852,"user_id":null,"body":"object Dec2Fact {\n  def dec_2_fact_string(nb: Long): String = {\n    decRec(nb, 1).reverse\n    \/\/ your code\n  }\n  \n  def decRec(nb: Long, iterator: Int): String = {\n    val remainder = nb%iterator\n    val whole = nb\/iterator\n    if(whole == 0) convertToAlfaNumeric(remainder)\n    else {\n      convertToAlfaNumeric(remainder) + decRec(whole, iterator + 1)\n    }\n  }\n  \n  def convertToAlfaNumeric(num: Long): String = {\n    if(num > 9) {\n      val result = ('A'.toInt + (num.toInt-10)).toChar\n      println(\"A.toInt=\" + 'A'.toInt)\n      println(\"Result=\" + result)\n      result.toString\n    } else \n    num.toString\n  }\n  \n  def fact_string_2_dec(str: String): Long = {\n    var sum = 0;\n    str.reverse.zipWithIndex.map{ case (c,i) => c.asDigit*factorial(i)}.sum\n  }\n  \n  def factorial(n: Long): Long = {\n    if(n <= 1) 1\n    else\n      n*factorial(n-1)\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 20:49:34"}],"54e6533c92449cc251001667":[{"id":333853,"user_id":573,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] =\n    if (xs.isEmpty) Nil else xs.head +: unique_in_order(xs.dropWhile(_ == xs.head))\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333854,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = {\n    if(xs.isEmpty) return Seq()\n    @scala.annotation.tailrec\n    def orderHelper(it: Iterable[T], acc: List[T]): List[T] = {\n        if(it.isEmpty) acc\n        else if(it.head == acc.head) orderHelper(it.tail, acc)\n        else orderHelper(it.tail, it.head :: acc)\n    }\n    orderHelper(xs, List(xs.head)).toSeq.reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333855,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = {\n    if (xs.size == 0) List()\n    else xs.head +: unique_in_order(xs.dropWhile(_ == xs.head))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333856,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = {\n    val seq = xs.toList\n    seq match {\n      case x::_ =>  x:: unique_in_order(seq.dropWhile(_ == x)).toList\n      case List() => Nil\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333857,"user_id":null,"body":"object Kata {\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] =\n    xs.foldLeft(List.empty[T])((res, e) => res.headOption match {\n      case None => res.+:(e)\n      case Some(last) => if (e.equals(last)) res else res.+:(e)\n    }).reverse\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333858,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = {\n    (xs.take(1) ++ xs.lazyZip(xs.drop(1)).filter((x, y) => x != y).map(_._2)).toSeq\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333859,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = xs.foldLeft(Seq.empty[T]) {\n    case (acc, el) if acc.isEmpty => el +: acc\n    case (acc, el) if acc.head != el => el +: acc\n    case (acc, el) => acc\n  }.reverse\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333860,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = {\n    xs.toList.zipWithIndex.filterNot(cn => {\n      cn._2 > 0 && xs.toList(cn._2 - 1) == cn._1\n    }).map(_._1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333861,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] =\n    xs.foldRight(List.empty[T]) { (x, list) =>\n      if (list.headOption.contains(x)) list else x :: list\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333862,"user_id":null,"body":"object Kata {\n\n  def unique_in_order[T](xs: Iterable[T]): Seq[T] = {\n    def go(xs: List[T], res: Seq[T]): Seq[T] = xs match {\n      case Nil => res\n      case it if res.isEmpty => go(xs.tail, res :+ it.head) \n      case it if it.head == res.last => go(xs.tail, res)\n      case it => go(xs.tail, res :+ it.head)\n    }\n\n    go(xs.toList, Seq.empty)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54eb33e5bc1a25440d000891":[{"id":333863,"user_id":null,"body":"object Decompose {\n\n  def decompose(n: Long): String = decomp(n - 1, n * n, List()).map(l => l.mkString(\" \")).orNull\n\n  def decomp(n: Long, left: Long, chain: List[Long]): Option[List[Long]] = left - n * n match {\n    case x if x == 0 => Option(n :: chain)\n    case x if x > 0 && n > 1 => decomp(n - 1, x, n :: chain).orElse(decomp(n - 1, left, chain))\n    case x if x < 0 && n > 1 => decomp(n - 1, left, chain)\n    case _ => None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333864,"user_id":492,"body":"object Decompose {\n\n  private def tryDecomp(nb: Long, rac: Long): String = {\n    if (nb == 0) return \"\"\n    var l: String = null\n    var i: Long = rac\n    var racc = rac\n    while (i >= Math.sqrt(nb \/ 2.0).toLong + 1) {\n      var diff: Long = nb - i * i\n      racc = Math.sqrt(diff).toLong\n      l = tryDecomp(diff, racc)\n      if (l != null) {\n        return l + \" \" + i\n      }\n      i -= 1\n    }\n    return null\n  }\n  def decompose(n: Long): String = {\n    val ll: String = tryDecomp(n * n, Math.sqrt(n * n - 1).toLong)\n    if (ll != null) ll.trim() else ll\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333865,"user_id":null,"body":"object Decompose {\n\n  def decompose(n: Long): String = {\n\n\/\/    @tailrec\n    def decomp(remind: Long, nextT: Long): Option[String] = {\n      remind match {\n        case r if r < 0 => Option.empty\n        case 0 => Some(\"\")\n        case r => (nextT-1 to 1L by -1)\n          .view\n          .map(x => (x, decomp(r - x*x, x)))\n          .find(_._2.isDefined)\n          .flatMap(tup => tup._2.map(x => (x + \" \" + tup._1).trim))\n      }\n    }\n    decomp(n * n, n).getOrElse(null)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333866,"user_id":1228,"body":"object Decompose {\n\n  def decompose(n: Long): String = {\n    val nSquared: Long = n*n\n    \n    @scala.annotation.tailrec\n    def d(k: Long, ks: List[Long]): List[Long] = {\n      val kSquared = k*k\n      val sumSquared = ks.map(l => l*l).foldLeft(0L)((a,b) => a+b)\n      k match {\n        case 1L if (ks.isEmpty & kSquared + sumSquared != nSquared) => Nil\n        case 1L if (kSquared + sumSquared != nSquared) => d(ks.head - 1L, ks.tail)\n        case _  if (kSquared + sumSquared <  nSquared) => d(k - 1L, k::ks)\n        case _  if (kSquared + sumSquared >  nSquared) => d(k - 1L, ks)\n        case _  => k::ks\n      }\n    }\n    val decomposition = d(n - 1L, Nil)\n    if(decomposition.isEmpty) null else decomposition.mkString(\" \")\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333867,"user_id":null,"body":"object Decompose {\n  def decompose(n: Long): String = {\n    def rec(lessThan: Long, leftSum: Long, curNums: List[Long]):  List[Long] =\n      if (leftSum == 0) \/\/\u521a\u597d\u7528\u5b8c\n        curNums\n      else if (leftSum < 0) \/\/\u4e0d\u80fd\u7ec4\u88c5\u4e86\n        List()\n      else {\n        for (i <- math.min(lessThan - 1, math.sqrt(leftSum).toInt) to 1 by -1) {\n          val t = rec(i, leftSum - i * i, i :: curNums)\n          if (t.nonEmpty) return t\n        }\n        List()\n      }\n\n\n    val res = rec(n, n * n, List())\n    if (res.nonEmpty) res.mkString(\" \") else null\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333868,"user_id":null,"body":"object Decompose {\n  import scala.collection.mutable.ArrayBuffer\n  import scala.collection.mutable.Stack\n\n  class Decomposer(val num: Long) {\n    var rest = num * num\n    val stack = Stack[Long]()\n\n    override def toString: String = stack.mkString(\" \")\n    def sqr(n: Long) = n * n\n    def push(n: Long) = { rest -= sqr(n); if (rest < 0) System.exit(1); stack.push(n) }\n    def pop(): Long = { val n = stack.pop(); rest += sqr(n); n }\n    def fill(): Unit = while (limit > 0) push(limit)\n    def isValid: Boolean = stack.map(sqr(_)).sum == sqr(num)\n    def decrementHead() = push(pop() - 1)\n    \n    def limit: Long = {\n      val l = math.sqrt(rest.toDouble).floor.toLong\n      if (stack.isEmpty) l else l.min(stack.head - 1)\n    }\n    def backUp(): Unit = {\n      var fst = 0L; var snd = stack(0)\n      while (fst + 1 == snd) { pop(); fst = snd; snd = stack(0) }\n    }\n    def canBackUp: Boolean = {\n      val seq = ArrayBuffer.tabulate(stack.length)(n => stack.head + n)\n      !seq.zip(stack).forall { case (a, b) => a == b }\n    }\n  }\n  \n  def decompose(n: Long): String = {\n    val d = new Decomposer(n)\n    d.push(n - 1); d.fill()\n\n    while (!d.isValid && d.canBackUp) {\n      d.backUp(); d.decrementHead(); d.fill()\n    }\n    if (d.isValid) s\"$d\" else null\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333869,"user_id":null,"body":"import scala.math.sqrt\n\nobject Decompose {\n  def decompose(n: Long): String = {\n    var x = n - 1\n    while (x > 0) {\n      val result = findDecompose(x, n * n, List())\n      result match {\n        case Some(list) => return list.reverse.mkString(\" \")\n        case _ => { x -= 1 }\n      }\n    }\n    null\n  }\n  def findDecompose(x: Long, remain: Long, res: List[Long]): Option[List[Long]] = (remain - x * x) match {\n    case l if l == 0 => Some(res.appended(x))\n    case l if l > 0 => {\n      val root = sqrt(l).toLong\n      if (root < x) findDecompose(root, l, res.appended(x))\n      else None\n    }\n    case l if l < 0 => findDecompose(x - 1, remain, res)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333870,"user_id":null,"body":"object Decompose {\n  private val zero = BigInt(0)\n\n  \/\/ All possible strictly increasing decompositions of N\n  private def decomposes(N: BigInt): LazyList[List[Long]] = {\n    def decomposesHelper(N: BigInt, used: List[Long]): LazyList[List[Long]] = {\n      N match {\n        case `zero` => LazyList(used)\n        case _ =>\n          LazyList\n            .from(Math.sqrt(N.toDouble).toLong to 1 by -1)\n            .filter(n => !used.contains(n))\n            .flatMap(n => decomposesHelper(N - n * n, n :: used))\n      }\n    }\n\n    decomposesHelper(N, List())\n  }\n\n  def decompose(n: Long): String =\n    decomposes(BigInt(n) * BigInt(n))\n      .find {\n        case List(x) if x == n => false\n        case Nil => false\n        case _ => true\n      }\n      .map(_.mkString(\" \"))\n      .orNull\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333871,"user_id":null,"body":"object Decompose {\n\n  def decompose(n: Long): String = {\n    decomposeT(n).map(_.mkString(\" \")).orNull\n  }\n\n  def decomposeT(n: Long): Option[Seq[Long]] = {\n    val target = BigInt(n).pow(2)\n    def walk(n: Long, r: List[Long], s: BigInt): LazyList[(List[Long], BigInt)] = {\n      (r, s) #:: LazyList.from((n - 1) to 1 by -1)\n      .flatMap(i => {\n        val si = s + BigInt(i).pow(2)\n        if (si <= target) walk(i, i :: r, si)\n        else LazyList.empty\n      })\n    }\n    walk(n, List.empty, 0).find(_._2 == target).map(_._1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333872,"user_id":null,"body":"object Decompose {\n\n  def decompose(n: Long): String = {\n\n    var n2:Long = n*n\n    var L:List[Long]=List()\n    var founded:Boolean=false\n    var locSum:BigInt=0\n    var i:Long=n\n    var i2:Long=0\n\n\n    while(i>1 && founded==false)\n    {\n      i-=1\n      locSum = L.map(x=>x*x).sum\n      i2 = i*i\n      if (locSum+i2==n2)\n      {\n        L=i::L\n        founded = true\n      }\n      else\n        if (locSum+i2 < n2)\n          L=i::L\n\n        if (i==1 && founded==false)\n          if (!(L.length==1 && L.head==1))\n          {\n            if (L.head==1) L = L.tail\n            i = L.head\n            L = L.tail\n          }\n    }\n\n    if (L.head==1 && L.length==1) L = L.tail\n    if (L.isEmpty ) null else L.mkString(\" \")\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54edbc7200b811e956000556":[{"id":333873,"user_id":573,"body":"object Farm {\n\n  def count_sheeps(sheep: Seq[Boolean]): Int = sheep.count(_ == true)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333874,"user_id":573,"body":"object Farm {\n\n  def count_sheeps(sheep: Seq[Boolean]): Int = sheep.count(identity)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333875,"user_id":573,"body":"object Farm {\n\n  def count_sheeps(sheep: Seq[Boolean]): Int = sheep.count(x => x)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333876,"user_id":null,"body":"object Farm {\n\n  def count_sheeps(sheep: Seq[Boolean]): Int = {\n    \n    def loop(count:Int, index:Int, sheep:Array[Boolean]): Int ={\n      if(index>=sheep.length){\n        return count;\n      }\n      else if(sheep(index)==true){\n        return loop(count+1,index+1,sheep);\n      }else{\n        return loop(count,index+1,sheep);\n      }\n    }\n    \n    return loop(0,0, sheep);\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333877,"user_id":null,"body":"object Farm {\n\n  def count_sheeps(sheep: Seq[Boolean]): Int = \n    sheep.filter(_.equals(true)).length\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333878,"user_id":null,"body":"object Farm {\n\n  def count_sheeps(sheep: Seq[Boolean]): Int = {\n    if (sheep != null) sheep.count(_ == true) else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333879,"user_id":null,"body":"object Farm:\n  def count_sheeps(sheep: Seq[Boolean]): Int =\n    sheep.count(x => x == true)","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333880,"user_id":null,"body":"object Farm {\n  def count_sheeps(sheep: Seq[Boolean]): Int = {\n    var cnt:Int=0\n    var i:Int=0\n    for(i<-sheep){\n      if(i==true){\n        cnt+=1\n        }\n     \n        \n    }\n     return cnt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333881,"user_id":null,"body":"object Farm {\n  def count_sheeps(sheep: Seq[Boolean]): Int = {\n    sheep.filter({x => Some(x).value == true}).length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333882,"user_id":null,"body":"object Farm {\n   def count_sheeps(args: Array[Boolean]): Int = {\n     var res = 0;\n     for (i <- args) {\n       if (i == true) {\n         res +=1\n       }\n     }\n     return res \n   }\n}\n\n  \n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54f0d5447872e8ce9f00013d":[{"id":333883,"user_id":573,"body":"object Sol {\n\n  def factorial(n: Int): Option[BigInt] =\n    Option.when(n >= 0)((BigInt(2) to n).product)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333884,"user_id":527,"body":"object Sol {\n  def factorial(n: Int): Option[BigInt] = {\n    if (n >= 0) Some((BigInt(1) to n).product) else None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333885,"user_id":null,"body":"object Sol {\n  def factorial(n: Int): Option[BigInt] = {\n    def factHelper(num: Int, total:BigInt = 1): BigInt = {\n      if (num <= 1) total\n      else factHelper(num - 1, total * num)\n    }\n    if (n < 0) None else Some(factHelper(n))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333886,"user_id":null,"body":"object Sol {\n  def factorial(a: Int): Option[BigInt] = {\n    if (a >= 0) Some((BigInt(1) to a).product) else None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333887,"user_id":null,"body":"object Sol {\n  def factorial(n: Int): Option[BigInt] = {\n    if (n < 0) None\n    else if (n == 0) Some(1)\n    else Some(Range(1, n+1).foldLeft(BigInt(1))(_ * _))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333888,"user_id":null,"body":"object Sol {\n  def factorial(n: Int): Option[BigInt] = {\n    Some(n).filter(_ >= 0).map(n => (2 to n).map(BigInt(_)).fold(BigInt(1))(_ * _))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333889,"user_id":null,"body":"object Sol {\n  def factorial(n: Int): Option[BigInt] = {\n\n    def factorialAux(x: Int, acc: BigInt): Option[BigInt] = {\n      if(n == 0) Some(1)\n      if (n < 0) None\n      else if (x <= 1) Some(acc)\n      else factorialAux(x - 1, x * acc)\n    }\n\n    factorialAux(n, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333890,"user_id":null,"body":"object Sol {\n    def factorial(n:Int): Option[BigInt] = {\n      def count(x: Int, acc: BigInt = 1): BigInt =\n        if (x == 0) acc else count(x - 1, x * acc)\n      n match {\n        case x if x >= 0 => Some(count(n))\n        case _ => None\n      }\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333891,"user_id":null,"body":"object Sol {\n  @annotation.tailrec\n  def factorial(n: Int, acc: BigInt = BigInt(1)): Option[BigInt] = {\n    if (n < 0) None\n    else if (n == 0) Some(acc)\n    else {\n      factorial(n-1, acc * n )\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333892,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Sol {\n  def factorial(n: Int): Option[BigInt] = {\n    @tailrec\n    def loop(n: BigInt, acc: BigInt = 1): BigInt = {\n      if (n <= 1) acc\n      else loop(n - 1, acc * n)\n    }\n    if (n < 0) None\n    else Option[BigInt](loop(n, 1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54f8693ea58bce689100065f":[{"id":333893,"user_id":null,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n    @scala.annotation.tailrec\n    def iter(num: BigInt, den: BigInt, res: List[String]): List[String] = {\n      if(num == 0) res\n      else if(num >= den) iter(num % den, den, res :+ s\"${num\/den}\")\n      else {\n        val t = BigDecimal(Math.ceil(den.toDouble \/ num.toDouble)).toBigInt\n        iter(num * t - den, den * t, res :+ s\"1\/$t\")\n      }\n    }\n    \"[\" + iter(nrStr.toInt, drStr.toInt, List()).mkString(\", \") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2023-01-06 21:58:53"},{"id":333894,"user_id":null,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n    def loop(fraction: Fraction, state: List[Fraction] = List()): List[Fraction] = fraction match {\n      case Fraction(1, _) | Fraction(_, 1) => state :+ fraction\n      case _ => loop(fraction.subtract(fraction.next()), state :+ fraction.next())\n    }\n\n    (if (nrStr.toLong == 0) List() else loop(Fraction.create(nrStr.toLong, drStr.toLong))).mkString(\"[\", \", \", \"]\")\n  }\n\n  object Fraction {\n\n    def create(numerator: Long, denominator: Long): Fraction = reduce(numerator, denominator)\n\n    private def calculateGCD(numerator: Long, denominator: Long): Long = {\n      if (numerator % denominator == 0) denominator\n      else calculateGCD(denominator, numerator % denominator)\n    }\n\n    private def reduce(numerator: Long, denominator: Long) = {\n      val gcd = calculateGCD(numerator, denominator)\n      new Fraction(numerator \/ gcd, denominator \/ gcd)\n    }\n  }\n\n  case class Fraction(numerator: Long, denominator: Long) {\n\n    def next() = Fraction(Math.max(1, Math.floor(numerator.toDouble \/ denominator).toLong), Math.ceil(denominator.toDouble \/ numerator).toLong)\n\n    def subtract(fraction: Fraction) = {\n      val newNumerator = (numerator * fraction.denominator) - (fraction.numerator * denominator)\n      val newDenominator = denominator * fraction.denominator\n      Fraction.create(newNumerator, newDenominator)\n    }\n\n    override def toString: String = this match {\n      case Fraction(n, 1) => s\"$n\"\n      case Fraction(n, d) => s\"$n\/$d\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333895,"user_id":null,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n\n    def streamFrom(from: BigInt): Stream[BigInt] = from #:: streamFrom(from + 1)\n\n    def decompose(numerator: BigInt, denominator: BigInt): List[(BigInt, BigInt)] = {\n      (numerator, denominator) match {\n        case (n, _) if n == 0 => Nil\n        case (n, d) if n\/d >= 1 => (n\/d, BigInt(1)) +: decompose(n - n\/d * d, d)\n        case (n, d) => {\n          val nextD = streamFrom(d\/n).filter(_ * n >= d).head\n          (BigInt(1), nextD) +: decompose(n * nextD - d, nextD * d)\n        }\n      }\n\n    }\n\n    decompose(nrStr.toInt, drStr.toInt)\n      .map({case (n, d) => if (d == 1) n.toString else s\"$n\/$d\"})\n      .mkString(\"[\", \", \", \"]\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333896,"user_id":492,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n    var nr: Long = java.lang.Integer.valueOf(nrStr).toLong\n    var dr: Long = java.lang.Integer.valueOf(drStr).toLong\n    var res = List.newBuilder[String]\n    if (nr >= dr) {\n      val i: Long = nr \/ dr\n      res += String.valueOf(i)\n      nr = nr - i * dr\n    }\n    while (nr != 0) {\n      val i: Long = Math.ceil(dr.toDouble \/ nr).toLong\n      res += \"1\/\" + i\n      nr = nr * i - dr\n      dr = dr * i\n    }\n    \"[\" + res.result().mkString(\", \") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333897,"user_id":492,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n    var nr: Long = java.lang.Integer.valueOf(nrStr).toLong\n    var dr: Long = java.lang.Integer.valueOf(drStr).toLong\n    var res = List.newBuilder[String]\n    if (nr >= dr) {\n      val i: Long = nr \/ dr\n      res += String.valueOf(i)\n      nr = nr - i * dr\n    }\n    while (nr != 0) {\n      val i: Long = Math.ceil(dr.toDouble \/ nr).toLong\n      res += \"1\/\" + i\n      nr = nr * i - dr\n      dr = dr * i\n    }\n    \"[\" + res.result().mkString(\", \") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333898,"user_id":null,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n    def dec(x: Long, y: Long): List[String] = {\n      if (x == 0 || y == 0) Nil\n      else if (x >= y) s\"${x\/y}\" :: dec(x%y, y)\n      else{\n        val first = if (y % x == 0) s\"1\/${y \/ x}\" else s\"1\/${y \/ x + 1}\"\n        first :: dec(Math.floorMod(-y, x), y * (y \/ x + 1))\n      }\n    }\n    \"[\" + dec(nrStr.toLong, drStr.toLong).mkString(\", \") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333899,"user_id":null,"body":"\nobject Decomp {\n\n  @annotation.tailrec\n  def gcd(xx: Long, yy: Long): Long = {\n    val x = xx.abs\n    val y = yy.abs\n    if (x == 0L) y\n    else if (y == 0L) x\n    else if (x < y)\n      gcd(x, y % x)\n    else gcd(x % y, y)\n  }\n\n  type Frac = (Long, Long)\n\n  def normalize(f: Frac): Frac =\n    f match {\n      case (a, b) =>\n        val g = gcd(a, b)\n        (a \/ g, b \/ g)\n    }\n\n  def fracSub(f1: Frac, f2: Frac): Frac = {\n    (normalize(f1), normalize(f2)) match {\n      \/\/ a\/b - c\/d = (a*d - b*c) \/ b*d\n      case ((a, b), (c, d)) =>\n        normalize((a * d - b * c, b * d))\n    }\n  }\n\n  @annotation.tailrec\n  def fracLess(f1: Frac, f2: Frac): Boolean = {\n    (f1, f2) match {\n      case ((a, b), (c, d)) =>\n        if (b == d) a < c\n        else {\n          val newA = a * d\n          val newC = c * b\n          fracLess((newA, b * d), (newC, b * d))\n        }\n    }\n  }\n\n  @annotation.tailrec\n  def decomposeRec(\n      frac: Frac,\n      acc: List[Frac] = List(),\n      nextHighest: Long = 2L\n  ): List[Frac] = {\n\n    frac match {\n      case (n, m) if n < 0L  => acc\n      case (0L, n)           => acc\n      case (1L, n)           => acc :+ (1L, n)\n      case (n, m) if n == m => acc :+ (1L, 1L)\n      case (n, m) if n > m =>\n        decomposeRec(fracSub(frac, (n \/ m, 1L)), acc :+ (n \/ m, 1L))\n      case (n, m) =>\n        val nextCandidate = (1L, nextHighest)\n        if (fracLess(nextCandidate, frac) && fracLess((0L, 1L), nextCandidate)) {\n          decomposeRec(\n            fracSub(frac, nextCandidate),\n            acc :+ nextCandidate,\n            nextHighest\n          )\n        } else {\n          decomposeRec(frac, acc, nextHighest + 1L)\n        }\n    }\n  }\n\n  def decompose(a: String, b: String): String = {\n    val div = a.toLong\n    val num = b.toLong\n\n    decomposeRec(normalize((div, num)))\n      .collect {\n        case (0L, _) => \"\"\n        case (n, 1L) => n.toString\n        case (n, m) => s\"$n\/$m\"\n      }\n      .filter(_.nonEmpty)\n      .mkString(\"[\", \", \", \"]\")\n\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333900,"user_id":null,"body":"object Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\ndef gcd(a: BigInt, b: BigInt): BigInt = {\n\n  if (b == 0) {\n    a\n  } else {\n    if (a > b) {\n      gcd(b, a % b)\n    } else {\n      gcd(a, b % a)\n    }\n  }\n}\n\ndef mult(a: BigInt, b: BigInt, c: BigInt, d: BigInt): (BigInt, BigInt) = {\n  var num = a * d + b * c\n  var den = b * d\n  val gcd_ = gcd(num, den)\n  num = num \/ gcd_\n  den = den \/ gcd_\n  (num, den)\n}\n\ndef getNextRatio(x: BigInt, y: BigInt): (BigInt, BigInt, BigInt) = {\n  var y_x = y \/ x\n  println(s\"$y_x\")\n  if (x % y != 0) {\n    println(s\"Adding 1\")\n    y_x += 1\n  }\n  println(s\"y $y, x $x, y_x $y_x\")\n  val num = -y % x + x\n  val den = y * y_x\n  val gcd_ = gcd(num, den.toLong)\n  (y_x, num\/gcd_, den.toLong\/gcd_)\n}\n\ndef getRatios(x: BigInt, y: BigInt): String = {\n  var resultList = List[BigInt]()\n  if (x == 0) {\n    return \"[]\"\n  }\n  if (x == y) {\n    return \"[1]\"\n  }\n\n  val gcd_ = gcd(x, y)\n  if (x\/gcd_ == 1) {\n    return s\"[1\/${y\/gcd_}]\"\n  }\n\n  if (x > y) {\n    val div = x \/ y\n    resultList = div :: resultList\n    val rem = x % y\n    \/\/val gcd_ = gcd(rem, y)\n    \/\/println(s\"rem $rem, y $y, gcd $gcd_\")\n    if (rem == 0) {\n      return \"[\" + div + \"]\"\n    }\n    return \"[\" + div + \", \" + getRatios(rem, y)\n      .replaceAll(\"\\\\[\", \"\")\n      .replaceAll(\"]\", \"\") + \"]\"\n  }\n  var result = getNextRatio(x, y)\n  \/\/println(s\"First ${result._1}, num ${result._2}, den ${result._3}\")\n  resultList = result._1.toInt :: resultList\n  \/\/println(s\"result $result\")\n  if (result._2 == 1) {\n    \/\/println(\"Numerator is 1\")\n    resultList = result._3 :: resultList\n  } else {\n    while (result._2 != 1) {\n      result = getNextRatio(result._2, result._3)\n      \/\/println(s\"In loop: First ${result._1}, num ${result._2}, den ${result._3}\")\n      resultList = result._1.toInt :: resultList\n    }\n    resultList = result._3 :: resultList\n  }\n  \/\/println(result)\n  \"[\" + resultList.reverse.map(x => s\"1\/$x\").mkString(\", \") + \"]\"\n}\n\n\/\/val result = getRatios(125, 100)\n\/\/val result = getRatios(50, 4187)\ngetRatios(nrStr.toLong, drStr.toLong)\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333901,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Decomp {\n\n  def decompose(nrStr: String, drStr: String): String = {\n    val (a, b) = (nrStr.toLong, drStr.toLong)\n    (biggerThanOneElement(a, b).map(_.toString) ++ decompose((a % b, b), Nil).map(n => s\"1\/$n\"))\n      .mkString(\"[\", \", \", \"]\")\n  }\n\n  def biggerThanOneElement(a: Long, b: Long) = Some(a \/ b).filter(_ > 0)\n\n  @tailrec\n  def decompose(frac: (Long, Long), res: List[Long]): List[Long] = {\n    val (a, b) = frac\n    if (a == 0) return res\n    val n = celi(b, a)\n    \/\/        val n = math.ceil(b.toDouble \/ a).toLong\n    if (n * b == a) {\n      res :+ (n)\n    } else {\n      \/\/      decompose((a * (n) - b, b * (n)), res :+ (n))\n      decompose(subtractFactorials(frac, (1, n)), res :+ (n))\n    }\n  }\n\n  def subtractFactorials(a: (Long, Long), b: (Long, Long)): (Long, Long) = {\n    val divisor = gcd(a._2, b._2)\n    val aMultiplier = b._2 \/ divisor\n    val bMultiplier = a._2 \/ divisor\n    (a._1 * aMultiplier - b._1 * bMultiplier, a._2 * aMultiplier)\n  }\n\n  def celi(a: Long, b: Long) = {\n    if (a % b == 0) a \/ b\n    else a \/ b + 1\n  }\n\n  @tailrec\n  def gcd(a: Long, b: Long): Long =\n    if (b == 0) a\n    else gcd(b, a % b)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333902,"user_id":null,"body":"object Decomp {\n  import scala.annotation.tailrec\n  import scala.math._\n  import java.lang.Math.floorMod\n  \n  @tailrec\n  def gcd(a: Long, b: Long): Long = b match {\n    case 0 => a\n    case n => gcd(b, a % b)\n  }\n\n  @tailrec\n  def decomposeAux(n: Long, d: Long, decomp: List[String]): List[String] = n match {\n        case 0 => decomp.reverse\n        case n if (n.toDouble \/ d.toDouble) < 1.0 => \n            val newN = floorMod(-d, n)\n            val newD = d * ceil(d.toDouble\/n.toDouble).toLong\n            val div = gcd(newN, newD)\n            decomposeAux((newN.toDouble\/div.toDouble).toLong, (newD.toDouble\/div.toDouble).toLong, s\"1\/${ceil(d.toDouble\/n.toDouble).toLong}\" :: decomp)\n        case n =>\n            val nextNum = Stream\n                .from(1)\n                .takeWhile(i => i.toDouble <= (n.toDouble)\/(d.toDouble)).last  \n            decomposeAux(n - nextNum * d, d, s\"$nextNum\" :: decomp)\n    }\n      \n\n  def decompose(nrStr: String, drStr: String): String =\n    decomposeAux(nrStr.toLong, drStr.toLong, Nil).mkString(\"[\", \", \", \"]\")\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"54ff3102c1bad923760001f3":[{"id":333903,"user_id":527,"body":"object Sol {\n\n  def get_count(s: String): Int = {\n    s.count(\"aeiou\".contains(_))\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333904,"user_id":null,"body":"object Sol {\n  def get_count(inputStr: String): Int = {\n    val vowels = Set('a', 'e', 'i', 'o', 'u')\n    inputStr.filter(vowels.contains).length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333905,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n    \/\/ your code here\n    inputStr.count(Set('a', 'e', 'i', 'o', 'u'))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333906,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n    inputStr.count { c =>\n      c match {\n        case 'a' | 'e' | 'i' | 'o' | 'u' => true\n        case _ => false\n      }\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333907,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n    inputStr.filter(\"aeiouAEIOU\".contains(_)).size\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333908,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n    var count = 0\n    for (char <- inputStr.toList)\n    char match {\n      case 'a' | 'e' | 'i' | 'o' | 'u' => count += 1\n      case _ => count += 0\n    }\n    count\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333909,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n      inputStr.filter(el => el == 'a' || el == 'e' || el == 'i'|| el == 'o' || el == 'u' ).size\n    }  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333910,"user_id":null,"body":"object Sol {\n  val arr = List('a','e','i','o','u')\n\n  def get_count(inputStr: String): Int = {\n    arr.map(x => inputStr.count(_ == x)).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333911,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n    \/\/ helper function for recursion\n    def vowelsNum (StrList: List[Char], vowels: Int) : Int = {\n      var vow = vowels\n      val vowelsList = List('a', 'e', 'i', 'o', 'u')\n      if (StrList.isEmpty)\n        vowels\n      else {\n        if(vowelsList.contains(StrList.head)) {\n          vow += 1\n        }\n        vowelsNum(StrList.tail, vow)\n      }\n    }\n    \n    val StrList = inputStr.toList \n    vowelsNum(StrList, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333912,"user_id":null,"body":"object Sol {\n\n  def get_count(inputStr: String): Int = {\n    val filtros = List('a','e','i','o','u')\n    inputStr.filter( filtros contains _).size\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"55031bba8cba40ada90011c4":[{"id":333913,"user_id":null,"body":"object Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    \"[0-9]{1,3}\".r.findAllIn(s)\n      .filter(n => n.map(c => Math.pow(s\"$c\".toInt, 3)).sum == n.toInt)\n      .map(_.toInt).toList match {\n        case Nil => \"Unlucky\"\n        case list => s\"${list.mkString(\" \")} ${list.sum} Lucky\"\n      }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333914,"user_id":573,"body":"object Cubes {\n\n  def isSumOfCubes(str: String): String = {\n    val cubes = str.split(\"[^0-9]\").flatMap(_.grouped(3)).filter(s => s.map(d => math.pow(d.toString.toInt, 3)).sum == s.toDouble)\n    if (cubes.nonEmpty) s\"${cubes.map(_.toInt).mkString(\" \")} ${cubes.map(_.toInt).sum} Lucky\" else \"Unlucky\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333915,"user_id":492,"body":"import java.util.regex._\n\nobject Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    val m: Matcher = Pattern.compile(\"\\\\d{1,3}\").matcher(s)\n    var result: String = \"\"\n    var sum: Int = 0\n    while (m.find()) {\n      val digits: Array[String] = m.group().split(\"\")\n      var dsum: Int = 0\n      for (d <- digits) {\n        val dgt: Int = java.lang.Integer.parseInt(d)\n        dsum += dgt * dgt * dgt\n      }\n      if (dsum == java.lang.Integer.parseInt(m.group())) {\n        sum += dsum\n        result += dsum + \" \"\n      }\n    }\n    if (result.isEmpty) \"Unlucky\" else result + sum + \" Lucky\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333916,"user_id":492,"body":"import java.util.regex._\n\nobject Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    val m: Matcher = Pattern.compile(\"\\\\d{1,3}\").matcher(s)\n    var result: String = \"\"\n    var sum: Int = 0\n    while (m.find()) {\n      val digits: Array[String] = m.group().split(\"\")\n      var dsum: Int = 0\n      for (d <- digits) {\n        val dgt: Int = java.lang.Integer.parseInt(d)\n        dsum += dgt * dgt * dgt\n      }\n      if (dsum == java.lang.Integer.parseInt(m.group())) {\n        sum += dsum\n        result += dsum + \" \"\n      }\n    }\n    if (result.isEmpty) \"Unlucky\" else result + sum + \" Lucky\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333917,"user_id":null,"body":"object Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    \/\/ 153 is such a \"cubic\" number : 1^3 + 5^3 + 3^3 = 153\n    val cubes = (0 to 1000)\n      .filter((x: Int) =>\n        x.toString.split(\"\").map(_.toInt).map(math.pow(_, 3)).sum == x\n      )\n      .toList\n    val sFiltered =\n      \"\\\\D+\".r.split(s).map(_.grouped(3).toArray).flatten.map(_.toInt).toList\n    val isMatch: List[Int] = sFiltered.filter(cubes.contains(_))\n    if (isMatch.length == 0) {\n      return \"Unlucky\"\n    } else {\n      return isMatch.mkString(\" \") ++ \" \" ++ isMatch.sum.toString ++ \" Lucky\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333918,"user_id":null,"body":"object Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    \/\/ your code\n    def checkCubic(n: Int): Boolean = {\n      n == n.toString.map(x => math.pow(x.asDigit, 3).toInt).sum\n    }\n\n    val result = raw\"\\d{1,3}\".r.findAllIn(s).map(x => if (checkCubic(x.toInt)) x.toInt else -1).filter(_ >= 0).toList\n\n    if (result.isEmpty) \"Unlucky\"\n    else f\"${result.mkString(\" \")} ${result.sum} Lucky\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333919,"user_id":null,"body":"object Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    val numbers = (\"\"\"\\d+\"\"\".r findAllIn s).toList\n    .flatMap(_.toList.sliding(3,3))\n    .map(_.mkString)\n    \n    val cubes = numbers.map(n => {\n        val cub = n.map(c => scala.math.pow(c.toString.toInt, 3)).toList.sum.toInt\n        (n.toInt, cub)\n     })\n    .filter(t => t._1 == t._2)\n    .map(_._2)\n    \n    if(cubes.size == 0) \n      \"Unlucky\"\n    else {\n      val cubic = cubes.mkString(\" \")\n      val sumOfCubic = cubes.sum\n      s\"$cubic $sumOfCubic Lucky\"\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333920,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.math.pow\n\nobject Cubes {\n\n  def isSumOfCubes(s: String): String = {    \n    val allNumbers = Strings.getNumbersInString(s)\n    val cubesWithThreeAtMost = atMostThreeDigits(allNumbers)\n    val cubes = cubesWithThreeAtMost.map(str => str.toInt).filter(isCubic)\n\n    if (cubes.isEmpty) {\n      \"Unlucky\"\n    } else {\n      cubes.mkString(\" \")\n        .concat(s\" ${cubes.sum.toString}\")\n        .concat(s\" Lucky\")\n    }\n  }\n\n  def atMostThreeDigits(list: List[String]): List[String] = list.filter(n => n.length <= 3)\n\n  def isCubic(n: Int): Boolean = {\n    val digits = n.toString.toList.map(_.toString.toInt)\n    val cubes = digits.map(n => pow(n.toDouble, 3))\n    val sum = cubes.sum\n\n    sum == n.toDouble\n  }\n}\n\nobject Strings {\n\n  def getNumbersInString(str: String): List[String] = {\n    discoverNumbersInString(str, None, List())\n  }\n\n  @tailrec\n  private def discoverNumbersInString(\n      str: String,\n      currentNumber: Option[String],\n      acc: List[String]\n  ): List[String] = {\n    if (str.isEmpty) {\n      return currentNumber match {\n        case Some(current) => acc ++ List(current)\n        case None          => acc\n      }\n    }\n\n    val newString = str.drop(1)\n    val firstChar = str.charAt(0)\n    var newCurrentNumber: Option[String] = None\n    var newAcc: List[String] = acc\n\n    currentNumber match {\n      case Some(current) =>\n        if (firstChar.isDigit) {\n          if(current.length == 3) {\n            newAcc = acc ++ List(current)\n            newCurrentNumber = Some(firstChar.toString)\n          } else {\n            newCurrentNumber = Some(\n              appendNumberAsString(current, firstChar.toString)\n            )\n          }\n        } else {\n          newAcc = acc ++ List(current)\n        }\n      case None =>\n        if (firstChar.isDigit) {\n          newCurrentNumber = Some(firstChar.toString)\n        }\n    }\n\n    discoverNumbersInString(newString, newCurrentNumber, newAcc)\n  }\n\n  def appendNumberAsString(n: String, digit: String): String = n.concat(digit)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333921,"user_id":1285,"body":"import scala.util.matching.Regex\n\nobject Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    def isCubic(n: Int): Boolean = {\n      def cubeDigits(acc: Int, num: Int): Int =\n        if (num == 0) acc\n        else cubeDigits(acc + Math.pow(num % 10, 3).toInt, num \/ 10)\n\n      n == cubeDigits(0, n)\n    }\n\n    def buildCubic(acc: String, matchIterator: Regex.MatchIterator, cubicSum: Int): String = {\n      if (!matchIterator.hasNext)\n        return if (acc == \"\") \"Unlucky\" else s\"${acc}$cubicSum Lucky\"\n      val groupInt = matchIterator.next.toInt\n      val cubic = isCubic(groupInt)\n      buildCubic(if (cubic) s\"$acc$groupInt \" else acc, matchIterator, if (cubic) cubicSum + groupInt else cubicSum)\n    }\n\n    buildCubic(\"\", (\"\\\\d{1,3}\".r findAllIn s), 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333922,"user_id":null,"body":"object Cubes {\n\n  def isSumOfCubes(s: String): String = {\n    def getDigits(string: String, acc: String, output: List[Int]): List[Int] = {\n      string.headOption match {\n        case Some(n) => {\n          if (n.isDigit && acc.length < 3) getDigits(string.tail, acc + n, output)\n          else if (n.isDigit && acc.length >= 3) getDigits(string.tail, n.toString, output :+ acc.toInt)\n          else getDigits(string.tail, \"\", if (acc.nonEmpty) output :+ acc.toInt else output)\n        }\n        case None => if (acc.nonEmpty) output :+ acc.toInt else output\n      }\n    }\n\n    def isCubic(inputInt: Int): Boolean = {\n      inputInt.toString.split(\"\").map(x => math.pow(x.toDouble, 3.0)).sum.toInt == inputInt\n    }\n\n    def checkInts(inputList: List[Int]) = {\n      inputList.filter(isCubic)\n    }\n\n    def getResult(inputList: List[Int]): String = {\n      inputList match {\n        case Nil => \"Unlucky\"\n        case _ => s\"${inputList.mkString(\" \")} ${inputList.sum} Lucky\"\n      }\n    }\n\n    getResult(checkInts(getDigits(s, \"\", Nil)))\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"550498447451fbbd7600041c":[{"id":333923,"user_id":null,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = (seq1, seq2) match {\n    case (null, _) => false\n    case (_, null) => false\n    case (s1, s2) => s1.map { x => x * x }.sorted  == s2.sorted\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333924,"user_id":null,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = {\n    seq1 != null && seq2 != null && seq1.map(x => x*x).sorted.sameElements(seq2.sorted)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333925,"user_id":2212,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = {\n    if (seq1 == null || seq2 == null) false else seq1.map(x => x * x).sorted == seq2.sorted \n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333926,"user_id":492,"body":"object Solution {\n  def comp_same(s1: Seq[Int], s2: Seq[Int]): Boolean =\n    s1 != null && s2 != null && s1.map(x => x * x).sorted == s2.sorted\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333927,"user_id":null,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) =\n    seq1 != null &&\n    seq2 != null &&\n    seq1.map(x => x * x).groupBy(identity) == seq2.groupBy(identity)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333928,"user_id":573,"body":"object Solution {\n\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) =\n    util.Try(seq1.map(x => x*x).sorted == seq2.sorted).getOrElse(false)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333929,"user_id":null,"body":"object Solution {\n def comp_same(seq1: Seq[Int], seq2: Seq[Int]): Boolean = {\n   if (seq1 == null || seq2 == null) return false\n\n   val map = scala.collection.mutable.Map[Double, Int]()\n   seq1.foreach(x => { map(x) = if(map.contains(x)) map(x) + 1 else 1 })\n\n   seq2.takeWhile(x => {\n     val sqrt = math.sqrt(x)\n     if(map.contains(sqrt)) {\n       map(sqrt) = map(sqrt) - 1\n       if(map(sqrt) == 0) map.remove(sqrt)\n       true\n     } else {\n       false\n     }\n   }).size == seq1.size\n }\n}\n\n\/\/clever but not optimized\n\/\/object Solution {\n\/\/  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = {\n\/\/    seq1 != null && seq2 != null && seq1.map(x => x*x).sorted.sameElements(seq2.sorted)\n\/\/  }\n\/\/}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333930,"user_id":null,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = {\n    seq2 != null && seq1.count(s1 => seq1.count(_ == s1) != seq2.count(_ == s1*s1)) == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333931,"user_id":null,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = {\n    seq2 != null && seq1.filter(s1 => seq1.filter(_ == s1).length != seq2.filter(_ == s1*s1).length).length == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333932,"user_id":null,"body":"object Solution {\n  def comp_same(seq1: Seq[Int], seq2: Seq[Int]) = try {seq1.sorted.map(x=>x*x) == seq2.sorted} catch {case _ => false}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"550527b108b86f700000073f":[{"id":333933,"user_id":573,"body":"object PiApprox {\n\n  def iterPi2String(epsilon: Double): String =\n    next(epsilon) match { case (pi, iterations) => f\"[$iterations%1.0f, $pi%1.10f]\" }\n\n  private def next(epsilon: Double, pi: Double = 4d, k: Double = 1d): (Double, Double) = {\n    val betterPi = pi + 4 * math.pow(-1, k) \/ (2*k+1)\n    if ((betterPi - math.Pi).abs < epsilon) (betterPi, k+1) else next (epsilon, betterPi, k+1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333934,"user_id":492,"body":"object PiApprox {\n\n  def iterPi2String(epsilon: Double): String = {\n    var i: Int = 0\n    var s: Double = 0\n    var j: Int = 1\n    while (Math.abs(Math.PI - s * 4) >= epsilon) {\n      if (i % 2 == 0) s += 1.0 \/ j \n      else s -= 1.0 \/ j \n      i += 1\n      j += 2\n    }\n    \"[\" + i + \", \" + (Math.round(s * 4 * 1e10).toDouble \/ 1e10) + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333935,"user_id":null,"body":"import scala.math.{Pi, abs, pow, BigDecimal}\n\nobject PiApprox {\n\n  def iterPi2String(epsilon: Double): String = {\n    val pies = Iterator.iterate((4d, 1)) {\n      case (n, i) => (n + 4 * pow(-1, i) \/ (2 * i + 1), i + 1)\n    }\n    (pies dropWhile { case (n, _) => abs(Pi - n) > epsilon }).next match {\n      case (pi, iterations) =>\n        val bestPi = BigDecimal(f\"$pi%.10f\").underlying.stripTrailingZeros\n        f\"[$iterations, $bestPi]\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333936,"user_id":null,"body":"import scala.math.{abs, Pi, BigDecimal}\n\nobject PiApprox {\n\n  def iterPi2String(epsilon: Double): String = {\n    val leibniz = Iterator.iterate((1d, 1, 1, -1)) { case (n, i, c, s) => (n + s * (1d \/ (c + 2)), i + 1, c + 2, -s) }\n    val pies = leibniz map { case (n, i, _, _) => (n * 4, i) }\n    val (pi, iterations) = (pies dropWhile { case (n, _) => abs(Pi - n) > epsilon } take 1).toList.head\n    val formattedPi = BigDecimal(f\"$pi%.10f\").underlying.stripTrailingZeros\n    s\"[$iterations, $formattedPi]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333937,"user_id":1228,"body":"object PiApprox {\nimport scala.math.{Pi, abs}\n\n  def iterPi2String(epsilon: Double): String = {\n    var (count, est) = (1, 4.0)\n    while (abs(Pi - est) > epsilon) {\n      if (count % 2 == 1 ) {\n        est -= (1.0 \/ (count * 2 + 1)) * 4\n      } else {\n        est += (1.0 \/ (count * 2 + 1)) * 4\n      }\n      count += 1\n    }\n    f\"[$count, $est%1.10f]\" \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333938,"user_id":1285,"body":"object PiApprox {\n\n  def iterPi2String(epsilon: Double): String = {\n    def calc(pi: Double, divisor: Int, minus: Int, iterations: Int): String =\n      if (Math.abs(Math.PI - pi * 4) <= epsilon) f\"[$iterations, ${pi * 4}%1.10f]\"\n      else calc(pi + 1.0 \/ divisor * minus, divisor + 2, minus * -1, iterations + 1)\n\n    val res = calc(1.0, 3, -1, 1)\n    if (res.charAt(res.length - 1) == '0') res.substring(0, res.length - 1)\n    else res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333939,"user_id":null,"body":"object PiApprox {\n\n  def iterPi2String(epsilon: Double): String = {\n    var (n, pi) = (0, 0.0)\n    while(Math.abs(Math.PI-pi)>epsilon)\n    {\n      n += 1\n      pi += (4.0\/(n+n-1) * (if(n%2==0) -1 else 1))\n    }\n    String.format(\"[%d, %.10f]\",n,pi)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333940,"user_id":null,"body":"object PiApprox {\n  def iterPi2String(epsilon: Double): String = {\n    var z:Int = 1\n    var i:Int = 3\n    var k:Int = -1\n    var sum:Double = 1.toDouble\n    while ( math.abs(math.Pi-sum*4) > epsilon  )\n      {\n        z+=1\n        sum += k * 1.toDouble\/i\n        i+=2\n        k = -k\n      }\n    f\"[$z, ${sum*4}%1.10f]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333941,"user_id":null,"body":"import scala.math.{Pi, abs}\n\nobject PiApprox {\n  val reg = \"0+$\".r.unanchored\n\n  def iterPi2String(epsilon: Double): String = {\n    var counter = 0\n    var pi = 0d\n    while(abs((pi * 4) - Pi) > epsilon) {\n      pi = pi + nthLeibnitzSeries(counter)\n      counter = counter + 1\n    }\n    val formattedNumber = reg.replaceAllIn(\"%.10f\".format(pi * 4), \"\")\n    \n    \"[%d, %s]\".format(counter, formattedNumber)\n  }\n  \n  def nthLeibnitzSeries(cursor: Int): Double = {\n    val value = 1d \/ (1 + (2 * cursor)).toDouble\n    if (cursor % 2 == 0) value else - value\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333942,"user_id":null,"body":"object PiApprox {\n  \n  def iterPi2StringRec(iteration: Int, approx: Double, epsilon: Double): String = {\n    val newApprox = if (iteration % 2 == 0) approx - 1.0 \/ (iteration * 2 - 1) else approx + 1.0 \/ (iteration * 2 - 1)\n    if ((java.lang.Math.PI - newApprox * 4).abs < epsilon) \"[%d, %1.10f]\".format(iteration, newApprox * 4) else iterPi2StringRec(iteration + 1, newApprox, epsilon)\n  }\n\n  def iterPi2String(epsilon: Double): String = iterPi2StringRec(1, 0, epsilon)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"550554fd08b86f84fe000a58":[{"id":333943,"user_id":573,"body":"object WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] =\n    array1.filter(s => array2.exists(_.contains(s))).distinct.sorted\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333944,"user_id":527,"body":"object WhichAreIn {\n\n  def inArray(xs: Array[String], ys: Array[String]): Array[String] = {\n    xs.filter(x => ys.exists(_.contains(x))).distinct.sorted\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333945,"user_id":null,"body":"import scala.collection.immutable.SortedSet\n\nobject WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] = {\n    SortedSet(array1: _*)\n        .filter(subStr => array2.exists(s => s.contains(subStr)))\n        .toArray\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333946,"user_id":null,"body":"object WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] = {\n    (for {\n      s <- array1\n      _ <- array2.filter(_.contains(s))\n    } yield s).distinct.sortBy(s => s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333947,"user_id":null,"body":"object WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] = {\n      for {\n        s1 <- array1\n        s2 <- array2\n        if s2 contains s1\n      } yield s1\n    }.distinct.sorted\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333948,"user_id":53,"body":"object WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] = {\n    return array1\n      .toSet\n      .toList\n      .filter((x)=>array2.filter((y)=>y contains x).size > 0)\n      .sorted\n      .toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333949,"user_id":null,"body":"\/\/import scala.collection.mutable.ListBuffer\nobject WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] = {\n    \/\/ your code\n    val r=array2.mkString(\" \")\n    \/\/var L=new ListBuffer[String]()\n    return array1.filter(i=>r.indexOf(i)>=0).toSet.toList.sorted.toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333950,"user_id":null,"body":"object WhichAreIn {\n\n  def inArray(a1: Array[String], a2: Array[String]): Array[String] = {\n    val filteredArray = for (i1 <- a1;\n                             i2 <- a2;\n                             if (i2 contains i1) == true) yield i1\n    filteredArray.distinct.sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333951,"user_id":null,"body":"object WhichAreIn {\n\n  def inArray(array1: Array[String], array2: Array[String]): Array[String] =\n    array1.map(x => array2.map(_.contains(x)).contains(true))\n          .zip(array1).collect({case (true, x) => x}).distinct.sorted\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333952,"user_id":null,"body":"object WhichAreIn {\n\n def inArray(array1: Array[String], array2: Array[String]): Array[String] = {\n    val set: Array[String] = for {\n      x <- array1\n      y <- array2\n      if y.contains(x)\n    } yield x\n  set.toSet.toArray.sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5506b230a11c0aeab3000c1f":[{"id":333953,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int =\n    Iterator.iterate(100.0)(x => x * (1.0 - evapPerDay \/ 100.0)).takeWhile(_ >= threshold).length\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333954,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n    var res = 0\n    var c   = content\n    val min = content * threshold \/ 100.0\n    while (c > min) {\n      c = c * (1 - evapPerDay \/ 100.0)\n      res = res + 1\n    }\n    res\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333955,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n    def rec(perc : Double, evapPerDay : Int, threshold: Int, acc: Int): Int ={\n      if (perc<threshold) acc else rec(perc*(1-evapPerDay.toDouble\/100),evapPerDay,threshold,acc+1)\n    }\n    rec (100, evapPerDay, threshold, 0)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333956,"user_id":527,"body":"object Sol {\n\n  def evaporator(_content: Double, evapPerDay: Double, threshold: Int): Int = {\n    (math.log(threshold \/ 100.0) \/ math.log(1 - evapPerDay \/ 100.0)).toInt + 1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333957,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n   (math.log(threshold \/ 100.0) \/ math.log(1 - evapPerDay \/ 100.0)).toInt + 1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333958,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n    if (content > 1) evaporator(1, evapPerDay, threshold)\n    else if (content <= threshold \/ 100.0) 0\n    else 1 + evaporator(content * (1 - evapPerDay \/ 100.0), evapPerDay, threshold)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333959,"user_id":null,"body":"object Sol {\nimport math.{log10, ceil}\n def evaporator(content: Double, evapPerDay: Double, threshold: Int, days : Int = 0 ): Int = {\n      ceil(log10(threshold.toDouble\/100 )\/log10(1 - (evapPerDay.toDouble\/ 100))).toInt\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333960,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n    calculate(evapPerDay \/ 100.0, (100 - threshold) \/ 100.0, evapPerDay \/ 100.0, 1)\n  }\n  \n  def calculate(evaporated: Double, limit: Double, perDay: Double, days: Int): Int =\n    if ((limit - evaporated) <= 0) {\n      days\n      }\n    else {\n      calculate(evaporated + ((1 - evaporated) * perDay), limit, perDay, days + 1)\n      }\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333961,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n    val threshold_val = content * (threshold\/100.0)\n    \n    def rec(content: Double):Int = {\n      if (content >= threshold_val) {\n        1 + rec(content * (1 - evapPerDay\/100.0))\n      } else {\n        0\n      }\n    }\n    \n    rec(content)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333962,"user_id":null,"body":"object Sol {\n\n  def evaporator(content: Double, evapPerDay: Double, threshold: Int): Int = {\n    calc(content, 1 - evapPerDay * 0.01, content * threshold * 0.01, 0)\n  }\n  def calc(c: Double, p: Double, t: Double, d: Int): Int = {\n    if (c < t) return d\n    calc(c * p, p, t, d + 1)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5508249a98b3234f420000fb":[{"id":333963,"user_id":527,"body":"object CaesarCipher {\n\n  def moving_shift(s: String, by: Int): List[String] =\n    s.iterator.zipWithIndex.map{ case (c, i) => shift(c, by + i) }\n      .grouped((s.size + 4) \/ 5).map(_.mkString).padTo(5, \"\").toList\n\n  def demoving_shift(ss: List[String], by: Int): String = {\n    ss.iterator.flatten.zipWithIndex.map{ case (c, i) => shift(c, -(by + i)) }.mkString\n  }\n  \n  private def shift(c: Char, by: Int): Char = {\n    val byNonNeg = 26 + by % 26\n    if ('a' <= c && c <= 'z') ('a' + (c - 'a' + byNonNeg) % 26).toChar\n    else if ('A' <= c && c <= 'Z') ('A' + (c - 'A' + byNonNeg) % 26).toChar\n    else c\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333964,"user_id":null,"body":"object CaesarCipher {\n\n  def moving_shift(s: String, shift: Int): List[String] = s.zipWithIndex.map(t => shiftChar(t._1, t._2 + shift).toChar).grouped((s.length + 4) \/ 5).toList.map(_.mkString).padTo(5, \"\")\n\n  def demoving_shift(s: List[String], shift: Int): String = s.mkString.zipWithIndex.map(t => shiftChar(t._1, 26 -(t._2 + shift) % 26).toChar).mkString\n\n  def shiftChar(c: Int, shift: Int) = c match {\n    case i if 65 to 90 contains i => ((c - 65) + shift) % 26 + 65\n    case i if 97 to 122 contains i => ((c - 97) + shift) % 26 + 97\n    case _ => c\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333965,"user_id":null,"body":"object CaesarCipher {\n  \n  def shiftChar(char : Char, shift: Int): Char = {\n    \/\/ Ensures the shift is positive\n    val pShift = if (shift > 0) shift else shift + (-shift \/ 26 + 1) * 26\n    char match {\n      case c if 'A' to 'Z' contains c => ((c - 'A' + pShift) % 26 + 'A').toChar\n      case c if 'a' to 'z' contains c => ((c - 'a' + pShift) % 26 + 'a').toChar\n      case c => c\n    }\n  }\n\n def messageLengths(srcLen: Int): List[Int] = {\n   val fifth = srcLen \/ 5\n   \/\/ Add the remainder to the last place and redistribute\n   fifth + srcLen % 5 match { \n     case `fifth` => List.fill(5)(fifth) \/\/ Perfect division     \n     case r if r >= 4 => List.fill(4)(fifth + 1) :+ r - 4 \/\/ Can add 1 to the first 4 \n     case r => List.fill(r)(fifth + 1) ++ List.fill(4 - r)(fifth) :+ 0 \/\/ The last messenger stays home\n   }\n }\n  \n  def moving_shift(s: String, shift: Int): List[String] = {\n    val coded = s.zipWithIndex.map { case (c, i) => shiftChar(c, i + shift) }.mkString\n    val lengths = messageLengths(s.length)\n    val lenIndex = lengths.zip( lengths.scanLeft(0)(_ + _) ) \/\/ List of length and start of the substrings\n    lenIndex.map {\n      case (len, start) => coded.substring(start, start + len)\n    }\n  }\n  \n  def demoving_shift(s: List[String], shift: Int): String = {\n    s.mkString.view.zipWithIndex.map {\n      case (char, i) => shiftChar(char, -(i + shift))\n    }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333966,"user_id":null,"body":"object CaesarCipher {\n\n  def moving_shift(s: String, shift: Int): List[String] = s.zipWithIndex.map(t => shiftChar(t._1, t._2 + shift).toChar).grouped((s.length + 4) \/ 5).toList.map(_.mkString).padTo(5, \"\")\n\n  def demoving_shift(s: List[String], shift: Int): String = s.mkString.zipWithIndex.map(t => shiftChar(t._1, 26 -(t._2 + shift) % 26).toChar).mkString\n\n  def shiftChar(c: Char, shift: Int): Int = c match {\n    case i if 'A' to 'Z' contains i => ((i - 'A') + shift) % 26 + 'A'\n    case i if 'a' to 'z' contains i => ((i - 'a') + shift) % 26 + 'a'\n    case _ => c\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333967,"user_id":null,"body":"object CaesarCipher {\n\n  def moving_shift(s: String, shift: Int): List[String] = {\n    var newS = convert(s, shift % 26, 1)\n\n    val parts = math.ceil(newS.length \/ 5.0).toInt\n    println(parts, newS, s, s.length)\n    var ans = for (i <- 0 to 3 * parts + 1 by parts) yield {\n      newS.substring(i, i + parts)\n    }\n    \n    ans :+= newS.substring(4 * parts)\n    \n    ans.toList\n  }\n\n\n  def demoving_shift(s: List[String], shift: Int): String = {\n    convert(s.mkString, shift % 26, -1)\n  }\n  \n  def convert(s: String, shift: Int, sens: Int): String = {\n\n    val sb = new StringBuilder(s)\n\n    var delta = 0\n\n    var mod4Neg = 26 * (sb.length \/ 26 + 1)\n       \n    for (i <- 0 until sb.length) {\n        val character =  sb.charAt(i)\n\n        if (character.isLetter) {\n          character.isUpper match {\n            case true => delta = 'A'.toInt\n            case false => delta = 'a'.toInt\n          }\n                    \n          var charCode = (character.toInt - delta + mod4Neg + (shift + i) * sens) % 26 + delta\n          \n          if (charCode < delta) {\n            charCode += 26\n          }\n          \n          sb.setCharAt(i, charCode.toChar)    \n        }\n    }\n    \n    sb.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333968,"user_id":1285,"body":"object CaesarCipher {\n  \n  val lower = Array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n\n  val upper = Array(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\n\n  def moving_shift(s: String, shift: Int): List[String] =\n    s.zipWithIndex.map(t => {\n      val c = t._1\n      val shft = shift + t._2\n      if (lower.contains(c.toString)) {\n        lower((c.toInt - 97 + shft) % 26)\n      } else if (upper.contains(c.toString)) {\n        upper((c.toInt - 65 + shft) % 26)\n      } else {\n        c.toString\n      }\n    })\n    .zipWithIndex\n    .foldLeft(List(\"\", \"\", \"\", \"\", \"\"))((acc, cur) => {\n      val size = Math.ceil(s.length.toDouble \/ 5).toInt\n      if (cur._2 < size) {\n        List(acc(0) + cur._1, acc(1), acc(2), acc(3), acc(4))\n      } else if (cur._2 < size * 2) {\n        List(acc(0), acc(1) + cur._1, acc(2), acc(3), acc(4))\n      } else if (cur._2 < size * 3) {\n        List(acc(0), acc(1), acc(2) + cur._1, acc(3), acc(4))\n      } else if (cur._2 < size * 4) {\n        List(acc(0), acc(1), acc(2), acc(3) + cur._1, acc(4))\n      } else {\n        List(acc(0), acc(1), acc(2), acc(3), acc(4) + cur._1)\n      }\n    })\n\n  def demoving_shift(s: List[String], shift: Int): String = {\n    s.flatten.zipWithIndex.map(t => {\n      val c = t._1\n      val shft = shift + t._2\n      if (lower.contains(c.toString)) {\n        val newIndex = c.toInt - 97 - shft % 26\n        lower(if (newIndex < 0) 26 + newIndex else newIndex)\n      } else if (upper.contains(c.toString)) {\n        val newIndex = c.toInt - 65 - shft % 26\n        upper(if (newIndex < 0) 26 + newIndex else newIndex)\n      } else {\n        c.toString\n      }\n    }).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333969,"user_id":null,"body":"object CaesarCipher {\n\n  def nextChar(c : Char, shift: Int): Char =  {\n    if (c.isLower) {\n        ( (c.toInt - 97 + shift) % 26 + 97 ).toChar\n    } else\n      ( (c.toInt - 65 + shift) % 26 + 65 ).toChar\n  }\n\n  def previousChar(c : Char, shift: Int): Char =  {\n    if (c.isLower) {\n      val a = (c.toInt - 97 - shift)\n      if (a >= 0 )\n        (a + 97).toChar\n      else {\n        if ((-a % 26) == 0) 'a'\n        else (26 - (-a % 26) + 97).toChar\n      }\n      \/\/( (c.toInt - 97 - shift) % 26 + 97 ).toChar\n    } else {\n\n      val b = (c.toInt - 65 - shift)\n      if (b >= 0 )\n        (b + 65).toChar\n      else {\n        if ((-b % 26) == 0) 'A'\n        else (26 - (-b % 26) + 65).toChar\n      }\n    }\n  }\n\/*\n  def chooseGroupSize(length: Int) : Int = {\n    def helper(length: Int, groupSize: Int,remainder: Int): Int = {\n      val currentRemainder = length - (groupSize - 1)*5\n      if (currentRemainder > (length \/ 5) )\n        groupSize + 3\n      else helper(length,groupSize - 1, currentRemainder)\n    }\n\n    helper(length,length \/ 5,length % 5)\n  }*\/\n\n  def recmoving_shift(s: String, shift: Int, index: Int, length: Int, outString : String): List[String] = {\n    if (index == length) {\n      if (length % 5 == 0)\n        outString.grouped(length \/ 5).toList\n      else {\n        val res = outString.grouped(length \/ 5 + 1).toList\n        if (res.length == 4) res ::: List(\"\")\n        else res\n      }\n    } else if (s(index).isLetter)\n       recmoving_shift(s,shift + 1, index + 1, length, outString + nextChar(s(index),shift) )\n    else\n       recmoving_shift(s,shift + 1, index + 1, length, outString + s(index))\n  }\n\n  def moving_shift(s: String, shift: Int): List[String] = {\n     recmoving_shift(s,shift,0,s.length,\"\")\n  }\n\n  def demoving_shift(s: List[String], shift: Int): String = {\n    def recdemoving_shift(s: String, shift: Int, index: Int = 0,length: Int, outString: String = \"\"): String = {\n      if (index == length)\n        outString\n      else if (s(index).isLetter)\n        recdemoving_shift(s,shift + 1, index + 1, length, outString + previousChar(s(index),shift) )\n      else\n        recdemoving_shift(s,shift + 1, index + 1, length, outString + s(index))\n\n    }\n    val list2str = s.mkString(\"\")\n    recdemoving_shift(s = list2str,shift = shift, length = list2str.length)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333970,"user_id":null,"body":"object CaesarCipher {\n  import scala.math._\n\n  def split(z: String, at: Int, accum: List[String] = Nil): List[String] = z match {\n    case z if z.length == 0 => accum.reverse\n    case z => \n      val spl = z.splitAt(at)\n      split(spl._2, at, spl._1 :: accum)\n  }\n\n  def isLowerCase(c: Char) = c >= 'a' && c <= 'z'\n\n  def isUpperCase(c: Char) = c >= 'A' && c <= 'Z'\n\n  def charAdd(c: Char, add: Int): Char = {\n    val (min, max) = c match {\n      case c if isLowerCase(c) => ('a', 'z')\n      case c if isUpperCase(c) => ('A', 'Z')\n    }\n\n    val n = c + (add % (max - min + 1))\n    val m = \n      if (n < min) max - (min - n) + 1\n      else if (n > max) min + (n - max) - 1\n      else n\n\n    m.toChar\n  }\n\n  def moving_shiftAux(s: String, shift: Int, accum: String = \"\"): String = s match {\n    case s if s.length == 0 => accum\n    case s if !isLowerCase(s.head) && !isUpperCase(s.head) => moving_shiftAux(s.drop(1), shift + 1, accum + s.head)\n    case s => moving_shiftAux(s.drop(1), shift + 1, accum + charAdd(s.head.toChar, shift))\n  }\n\n  def moving_shift(s: String, shift: Int): List[String] = {\n    val l = split(moving_shiftAux(s, shift), ceil(s.length.toDouble \/ 5.0).toInt)\n    l ++ List.fill(5 - l.length)(\"\")\n  }\n\n  def demoving_shiftAuxAux(s: String, shift: Int, accum: String = \"\"): (String, Int) = s match {\n    case s if s.length == 0 => (accum, shift)\n    case s if !isLowerCase(s.head) && !isUpperCase(s.head) => demoving_shiftAuxAux(s.drop(1), shift + 1, accum + s.head)\n    case s => demoving_shiftAuxAux(s.drop(1), shift + 1, accum + charAdd(s.head.toChar, -shift))\n  }\n  \n  def demoving_shiftAux(s: List[String], shift: Int, accum: String = \"\"): String = s match {\n    case s if s.length == 0 => accum\n    case s => \n      val (demoveOne, currShift) = demoving_shiftAuxAux(s.take(1).head, shift)\n      demoving_shiftAux(s.drop(1), currShift, accum + demoveOne)\n  }\n\n  def demoving_shift(s: List[String], shift: Int): String = \n    demoving_shiftAux(s, shift)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333971,"user_id":null,"body":"object CaesarCipher {\n\n    def rot(a: IndexedSeq[Char], c: Char, shift:Int): Char = {\n    a(((c - a.head + shift + a.size) % a.size))\n  }\n  def rot1(a: IndexedSeq[Char], c: Char, shift:Int): Char = {\n    val diff = c - a.head + shift + a.size\n    val idx = if (diff < 0) {\n      a.size + (diff % a.size)\n    } else {\n      diff\n    }\n    a(idx % a.size)\n  }\n  def moving_shift(s: String, shift: Int): List[String] = {\n    val alphaU = 'A' to 'Z'\n    val alphaL = 'a' to 'z'\n    val l = s.zip(0 until s.size).map(x => (x._1, shift + x._2)).toList\n    val ll = l.map( x => x match {\n      case (c: Char, shift: Int) if alphaU.contains(c) => rot(alphaU, c, shift)\n      case (c: Char, shift: Int) if alphaL.contains(c) => rot(alphaL, c, shift)\n      case (c: Char, _shift: Int) => c\n    })\n    val len = (ll.length \/ 5.0).ceil.toInt\n    val lst = ll.grouped(len).toList.map(x => x.mkString(\"\"))\n    if (lst.length < 5) {\n      lst ++ List.fill(5 - lst.length)(\"\")\n    } else {\n      lst\n    }\n  }\n\n  def demoving_shift(s: List[String], shift: Int): String = {\n    val alphaU = 'A' to 'Z'\n    val alphaL = 'a' to 'z'\n    val str = s.mkString(\"\")\n    val l = str.zip(0 until str.size).map(x => (x._1, x._2, shift+x._2)).toList\n    val ll = l.map(x => x match {\n      case (a: Char, _b: Int, c: Int) if alphaU.contains(a) => rot1(alphaU, a, -c)\n      case (a: Char, _b: Int, c: Int) if alphaL.contains(a) => rot1(alphaL, a, -c)\n      case (a: Char, _b: Int, _c: Int) => a\n    })\n    \/\/ println(s\"${ll}\")\n    ll.mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333972,"user_id":null,"body":"object CaesarCipher {\n\n  def moving_shift(s: String, shift: Int): List[String] = {\n    val alphabetU = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    val alphabetL = \"abcdefghijklmnopqrstuvwxyz\"\n\n    val coded = s.zipWithIndex.toList.map(x => {\n\n      val ux = alphabetU.indexOf(x._1)\n      val lx = alphabetL.indexOf(x._1)\n\n      if (ux + lx == -2) x._1\n      else if (ux != -1) alphabetU((ux + x._2 + shift) %26)\n      else alphabetL((lx + x._2 + shift) %26)\n      }).mkString\n\n    def findLen(l: Int):Int = l match {\n      case l if (s.length - 4 * l) <= l => l\n      case _ => findLen(l + 1)\n    }\n\n    val ans = coded.grouped(findLen(1)).toList\n    if (ans.length == 5) ans\n    else ans:::List(\"\")\n    \n  }\n\n  def demoving_shift(s: List[String], shift: Int): String = {\n    val alphabetU = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    val alphabetL = \"abcdefghijklmnopqrstuvwxyz\"\n    \n    s.mkString.zipWithIndex.toList.map(x => {\n\n      val ux = alphabetU.indexOf(x._1)\n      val lx = alphabetL.indexOf(x._1)\n\n      if (ux + lx == -2) x._1\n      else if (ux != -1) alphabetU((52 + ux - x._2%26 - shift%26) %26)\n      else alphabetL((52 + lx - x._2%26 - shift%26) %26)\n    }).mkString\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"55084d3898b323f0aa000546":[{"id":333973,"user_id":null,"body":"object CaesarCipher {\n\ndef encode(s: String, shift: Int): List[String] = {\n  val prefix1 = s.head.toLower\n  val prefix2 = shiftLetter(prefix1, shift)\n  val shifted = s\"$prefix1$prefix2\" + s.map(c => shiftLetter(c, shift))\n  \n  val len = shifted.length\n  \n  if (len % 5 == 0) shifted.grouped(len \/ 5).toList\n  else {\n    val (four, last) = split(len)\n    if (last == 0) shifted.grouped(len \/ 4).toList\n    else {\n      val (start, end) = shifted.splitAt(four * 4 )\n      start.grouped(four).toList :+ end\n    }\n  }\n}\n\ndef decode(msg: List[String]): String = {\n  val concatenated = msg.mkString(\"\")\n  val (prefix, actual) = concatenated.splitAt(2)\n  val shift = prefix.last - prefix.head\n\n  actual.map(c => shiftLetter(c, -shift))\n}\n\nprivate def shiftLetter(c: Char, shift: Int): Char = {\n  def imp(start: Char, end: Char) = {\n    val shiftMod = shift % 26 \n    val shifted = c + shiftMod\n    if (shiftMod < 0) {\n      if (shifted < start) end - start + shifted + 1\n      else shifted\n    } else {\n      if (shifted > end) start + shifted - end - 1\n      else shifted\n    }\n  }\n\n  if (c.isUpper)  imp('A', 'Z').toChar\n  else if (c.isLower) imp('a', 'z').toChar\n  else c\n}\n\nimport scala.annotation.tailrec\n\nprivate def split(len: Int): (Int, Int) = {\n  @tailrec\n  def inner(four: Int, diff: Int): (Int, Int) = {\n    val last = four - diff\n    val total = four * 4 + last\n    \n    if (total == len) (four, last)\n    else if (total < len) inner(four + 1, diff)\n    else inner(four, diff + 1)\n  }\n  val fifth = len \/ 5\n  inner(fifth, 0)\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333974,"user_id":null,"body":"object CaesarCipher {\n\ndef getStringArray(str: String): List[String] = {\n\n  val strlen = str.length\n  var x = strlen\/5\n  val rem = strlen % 5\n  var y = x\n\n  if (rem > 0) {\n    x += 1\n    y = strlen - (4 * x)\n  }\n\n  str.grouped(x).toList\n}\n\ndef shiftCapLetter(letter: Char, shift: Int): Char = {\n  if (!letter.isLetter) {\n    return letter\n  }\n  if (shift < 0) {\n    ((letter + shift - 'A' + 26) % 26 + 'A').toChar\n  } else {\n    ((letter + shift - 'A') % 26 + 'A').toChar\n  }\n}\n\ndef shiftNonCapLetter(letter: Char, shift: Int): Char = {\n  shiftCapLetter(letter.toUpper, shift).toLower\n}\n\ndef shiftLetter(letter: Char, shift: Int): Char = {\n  if (letter.isUpper) {\n    shiftCapLetter(letter, shift)\n  } else {\n    shiftNonCapLetter(letter, shift)\n  }\n}\n\ndef encode(str: String, shift: Int): List[String] = {\n  val firstLetter = str.head.toLower\n  val secondLetter = shiftLetter(firstLetter, shift)\n\n  val shiftedStr = str.map(c => if (c.isLetter) shiftLetter(c, shift) else c)\n  getStringArray(s\"$firstLetter$secondLetter$shiftedStr\")\n  \/\/ your code\n}\n\ndef decode(s: List[String]): String = {\n  \/\/ your code\n  val joinedStr = s.mkString(\"\")\n  val firstChar = joinedStr.head\n  val secondChar = joinedStr.tail.head\n  val shift = if (secondChar > firstChar) {\n    secondChar - firstChar\n  } else {\n    secondChar - firstChar + 26\n  }\n  \n  val strToDecode = joinedStr.tail.tail\n  strToDecode.map(c => shiftLetter(c, -shift))\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333975,"user_id":null,"body":"object CaesarCipher {\n  def shiftBy(c: Char, amount: Int): Char = if (c.isLetter) shiftByHelper(c, if (c.isLower) 'a' else 'A', amount) else c\n  def shiftByHelper(c: Char, b: Char, amount: Int): Char = (((c.toInt - b.toInt) + 26 + amount) % 26 + b.toInt).toChar\n  \n  def encode(s: String, shiftN: Int): List[String] = {\n    val firstLower = s(0).toLower\n    val header = firstLower.toString + shiftBy(firstLower, shiftN).toString\n    val shiftedMsg = s.map(shiftBy(_, shiftN))\n    val totalMsg = header + shiftedMsg\n    if ((shiftedMsg.length + 2) % 5 == 0) {\n      totalMsg.grouped((shiftedMsg.length + 2) \/ 5).toList\n    } else {\n      val perRow = (shiftedMsg.length + 2 + 5) \/ 5\n      totalMsg.grouped(perRow).toList\n    }\n  }\n\n  def decode(s: List[String]): String = {\n    val msg = s.mkString(\"\")\n    val shiftN = msg(0) - msg(1)\n    msg.drop(2).map(c => shiftBy(c, shiftN))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333976,"user_id":null,"body":"object CaesarCipher {\n  val letters = ('a' to 'z').zipWithIndex.toMap ++ ('A' to 'Z').zipWithIndex.toMap\n\n  def encode(s: String, shift: Int): List[String] = {\n    val prefix = s.head.toLower.toString + (((letters(s.head.toLower)+shift)%26)+97).toChar \n    val size = s.size + 2\n    val split = if(size%5 == 0) size\/5 else size\/5 +1 \n    def shifter(c : Char) : Char = {\n      if(c.isLetter) {\n        ((letters(c)+shift)%26 + (if(c.isUpper) 65 else 97)).toChar\n      }else c\n    }\n    val xs = s.map(shifter)\n    def makeList(s : String): List[String] ={\n      if(s.isEmpty) Nil\n      else\n      s.take(split) :: makeList(s.drop(split))\n    }\n    makeList(prefix + xs)\n  }\n  def decode(s: List[String]): String = {\n    val key = if(s.head.size > 1) s.head.take(2) else s(0)+s(1)    \n    val shift =  26 - ((26 + letters(key(1))-letters(key(0)))%26)\n    s.mkString.drop(2).map(\n      l => if(l.isLetter) {\n        ((letters(l) + shift)%26 + (if(l.isUpper) 65 else 97)).toChar\n        }\n      else\n      l      \n      )    \n    }                      \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333977,"user_id":null,"body":"object CaesarCipher {\n\n  def rotate(char: Char, shift: Int): Char = {\n    if ('A' <= char && char <= 'Z') {\n      val a = 'Z' - 'A' + 1\n      val b = char + shift - 'A'\n      if (b < 0) {\n        (((b % a) + a) + 'A').toChar\n      }\n      else {\n        ((b % a) + 'A').toChar\n      }\n    } else if ('a' <= char && char <= 'z') {\n      val a = 'z' - 'a' + 1\n      val b = char + shift - 'a'\n      if (b < 0) {\n        (((b % a) + a) + 'a').toChar\n      }\n      else {\n        ((b % a) + 'a').toChar\n      }\n\n    }\n    else {\n      char\n    }\n  }\n\n  def encode(s: String, shift: Int): List[String] = {\n    val first = s(0).toLower\n    val str = s\"${first}${rotate(first, shift)}\" + s.map(c => rotate(c, shift)).toString\n    val split = str.length \/ 5\n    val left = str.length % 5\n    var first_four_couriers = split\n    var last_courier = split\n    if (left > 0) {\n      first_four_couriers += 1\n      last_courier += left - 4\n    }\n\n    val lst = (0 until 4).map(i => str.drop(i * first_four_couriers).take(first_four_couriers).toString).toList\n\n    if (last_courier > 0) {\n      lst ++ List(str.drop(4 * first_four_couriers).take(last_courier))\n    }\n    else {\n      lst\n    }\n  }\n\n  def decode(s: List[String]): String = {\n    println(s)\n    val str = s.fold(\"\")((acc, x) => acc + x)\n    val shift = str(1) - str(0)\n    println(shift)\n    str.drop(2).map(x => rotate(x, -shift)).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333978,"user_id":null,"body":"object CaesarCipher {\n  def aLetter(c: Char) = 65 to 90 contains c.&(223)\n  def rotate(n: Int)(c: Char) =\n    if (aLetter(c))\n      ((c & 96) + ((c & 31) + (n % 26) + 25) % 26 + 1)\n      .toChar\n    else c\n  def encode(s: String, shift: Int) = {\n    val h = s.find(aLetter).get.toLower\n    val e = h +: (h +: s).map(rotate(shift))\n    e.grouped((e.size \/ 5.0).ceil.toInt).toList\n  }\n  def decode(s: List[String]) = {\n    val e = s.flatten\n    e.drop(2).map(rotate(e(0) - e(1))).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333979,"user_id":null,"body":"object CaesarCipher {\n  def aLetter(c: Char) = 65 to 90 contains c.&(223)\n  def rotate(n: Int)(c: Char) =\n    if (aLetter(c))\n      ((c & 96) + ((c & 31) + n + 25) % 26 + 1)\n      .toChar\n    else c\n  def encode(s: String, shift: Int) = {\n    val h = s.find(aLetter).get.toLower\n    val e = h +: (h +: s).map(rotate(shift))\n    e.grouped((e.size \/ 5.0).ceil.toInt).toList\n  }\n  def decode(s: List[String]) = {\n    val e = s.flatten\n    e.drop(2).map(rotate(e(0) - e(1))).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333980,"user_id":null,"body":"object CaesarCipher {\n\n  def encode(s: String, shift: Int): List[String] = {\n    def encodeAux(s: String, shift: Int, processed: String = \"\"): String = {\n      if (s.length == 0) {\n        processed\n      }\n      else {\n        val coded = {\n          if (s(0).isLetter) {\n            if (s(0).isLower) (97 + (s(0).toInt - 97 + shift) % 26).toChar\n            else (65 + (s(0).toInt - 65 + shift) % 26).toChar\n          }\n          else {\n            s(0)\n          }\n        }\n        encodeAux(s.drop(1), shift, processed :+ coded)\n      }\n    }\n    val prefix = List(s(0).toLower, (97 + (s(0).toLower.toInt - 97 + shift) % 26).toChar).mkString(\"\")\n    val coded = encodeAux(s, shift, prefix)\n    coded.grouped(math.ceil(coded.length.toDouble\/5).toInt).toList\n  }\n  def decode(s: List[String]): String = {\n    def decodeAux(s: String, shift: Int, processed: String = \"\"): String = {\n      if (s.length == 0) {\n        processed\n      }\n      else {\n        val coded = {\n          if (s(0).isLetter) {\n            if (s(0).isLower) {\n              val diff = shift % 26 - (s(0).toInt - 97) \n              if (diff <= 0) (97 - (diff) % 26).toChar\n              else (97 + 26 - diff).toChar\n            }\n            else {\n              val diff = shift % 26 - (s(0).toInt - 65)\n              if (diff <= 0) (65 - (diff) % 26).toChar\n              else (65 + 26 - diff).toChar\n            }\n          }\n          else {\n            s(0)\n          }\n        }\n        decodeAux(s.drop(1), shift, processed :+ coded)\n      }\n    }\n    val message = s.mkString(\"\") \n    val diff = message(1).toInt - message(0).toInt\n    val shift =  {\n      if (diff >= 0) diff\n      else message(1).toInt - 97 + 123 - message(0).toInt\n    }\n    decodeAux(message.drop(2), shift)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333981,"user_id":null,"body":"object CaesarCipher {\n\n  def encode(s: String, shift: Int): List[String] = {\n    val head   = s.find(_.isLetter).getOrElse('a').toLower\n    val result = s\"$head${encodeLetter(head, shift)}${s.map(encodeLetter(_, shift))}\"\n    val l      = result.length.toDouble \/ 5\n    val a      = if (l.isWhole) l.toInt else l.toInt + 1\n    result.grouped(a).toList\n  }\n\n  def decode(s: List[String]): String = {\n    val str    = s.mkString\n    val prefix = str.take(2)\n    val shift  = 26 - (prefix.last.toInt - prefix.head.toInt)\n    str.drop(2).map(encodeLetter(_, shift))\n  }\n\n  private def encodeLetter(letter: Char, shift: Int): Char =\n    if (letter.isLetter) {\n      val next = ((letter.toLower - 'a' + shift) % 26 + 'a').toChar\n      if (letter.isUpper) next.toUpper else next\n    } else {\n      letter\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333982,"user_id":null,"body":"object CaesarCipher {\n\n  def encode(ch: Char, shift: Int, isPrefix: Boolean = false): Char = {\n    val es = shift % 26\n    if (ch.isLetter) {\n      val nc = (ch + es).toChar\n      if (ch.isLower) if (nc > 122) (96 + (nc - 122)).toChar else nc\n      else if (nc > 90) (64 + (nc - 90)).toChar\n      else nc\n    } else if (isPrefix && ch == ' ') {\n      (84 + es).toChar\n    } else ch\n  }\n\n  def decode(ch: Char, shift: Int): Char = {\n    if (ch.isLetter) {\n      val es = shift % 26\n      val nc = (ch - es).toChar\n      if (ch.isLower) {\n        if (nc < 96) {\n          (122 - (96 - nc)).toChar\n        } else if (nc > 122) (96 + (nc - 122)).toChar\n        else nc\n      } else if (nc < 64){\n        (90 - (64 - nc)).toChar\n      }  else if (nc > 90) {\n        (64 + (nc - 90)).toChar\n      }\n      else nc\n    } else ch\n  }\n\n  def encode(s: String, shift: Int): List[String] = {\n    println(s\"encode input: [$s], shift $shift\")\n    val prefix    = List(s(0).toLower, encode(s(0).toLower, shift, true)).mkString\n    val msg       = prefix + s.map(encode(_, shift))\n    val groupSize = msg.length.toDouble \/ 5\n    if (groupSize.isWhole) msg.grouped(groupSize.toInt).toList\n    else msg.grouped(groupSize.toInt + 1).toList\n  }\n  def decode(s: List[String]): String = {\n    val str = s.mkString\n    println(s\"decode input: [$str]\")\n    val shift = (str(1) - str(0))\n    println(\"Got shift: \" + shift)\n    str.drop(2).map(decode(_, shift))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"550f22f4d758534c1100025a":[{"id":333983,"user_id":573,"body":"object dir_reduc {\n  \n  def dir_reduc(arr: Array[String]): Array[String] =\n    arr.foldLeft(List[String]()) {\n      case (Nil, nextDir) => List(nextDir)\n      case (currDir :: previousDirs, nextDir) if opposites(currDir, nextDir) => previousDirs\n      case (previousDirs, nextDir) => nextDir :: previousDirs\n    }\n    .reverse.toArray\n\n  def opposites(dir1: String, dir2: String): Boolean =\n    Set(Seq(\"NORTH\", \"SOUTH\"), Seq(\"EAST\", \"WEST\")).contains(Seq(dir1, dir2).sorted)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333984,"user_id":null,"body":"object dir_reduc {\n  val oppositeDirs = Map(\n    \"NORTH\" -> \"SOUTH\",\n    \"EAST\" -> \"WEST\",\n    \"SOUTH\" -> \"NORTH\",\n    \"WEST\" -> \"EAST\"\n  )\n\n  def dir_reduc(directions: Array[String]): Array[String] =\n    directions.foldLeft(Array.empty[String]) {\n      case (Array(), dir) => Array(dir)\n      case (acc, dir) if oppositeDirs.get(acc.last).contains(dir) => acc.init\n      case (acc, dir) => acc :+ dir\n    }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333985,"user_id":null,"body":"object dir_reduc {\n  \n  def dir_reduc(arr: Array[String]): Array[String] =\n      arr.foldRight(List.empty[String]) {\n          case (x, Nil) => List(x)\n          case (\"NORTH\", \"SOUTH\" :: rest) => rest\n          case (\"SOUTH\", \"NORTH\" :: rest) => rest\n          case (\"EAST\", \"WEST\" :: rest) => rest\n          case (\"WEST\", \"EAST\" :: rest) => rest\n          case (x, rest) => x +: rest \n      }.toArray\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333986,"user_id":null,"body":"object dir_reduc {\n  \n  def dir_reduc(arr: Array[String]): Array[String] = {\n    rec(arr.toList, List.empty[String]).toArray\n  }\n  \n  def rec(arr: List[String], acc: List[String]): List[String] = arr match {\n    case first :: second :: xs if reduce(Set(first, second)) => rec(acc ++ xs, Nil)\n    case x :: xs => rec(xs, acc :+ x)\n    case Nil => acc\n  }\n\n  def reduce(dirs: Set[String]): Boolean =\n    Set(\"NORTH\", \"SOUTH\") == dirs || Set(\"WEST\", \"EAST\") == dirs\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333987,"user_id":null,"body":"object dir_reduc {\n  def dir_reduc(arr: Array[String]): Array[String] = {\n    val slices = List(List(\"EAST\", \"WEST\"), List(\"WEST\", \"EAST\"), List(\"NORTH\", \"SOUTH\"), List(\"SOUTH\", \"NORTH\"))\n    val ids = slices.map(arr.indexOfSlice(_)).filter(_ != -1)\n    if (ids.isEmpty) arr else dir_reduc(arr.patch(ids.head, List(), 2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333988,"user_id":636,"body":"object dir_reduc {\n  \n  def dir_reduc(arr: Array[String]): Array[String] = {\n    val red = Map(\"NORTH\" -> \"SOUTH\", \"SOUTH\" -> \"NORTH\", \"EAST\" -> \"WEST\", \"WEST\" -> \"EAST\")\n\n    arr.foldLeft(Array[String]()){\n      (totaller, curr) => {\n        val last = totaller.reverse.headOption.getOrElse(\"\")\n        if (curr==red.getOrElse(last, \"\")) {\n          totaller.reverse.tail.reverse\n        } else totaller ++ Array(curr)\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333989,"user_id":null,"body":"object dir_reduc {\n\n  def dir_reduc(arr: Array[String]): Array[String] = {\n    dir_reduc(arr.toList).toArray\n  }\n\n  def canReduce(x: String, y: String): Boolean = (x,y) match {\n    case (\"NORTH\", \"SOUTH\") | (\"SOUTH\", \"NORTH\") |\n         (\"WEST\", \"EAST\") | (\"EAST\", \"WEST\") => true\n    case _ => false\n  }\n\n  def dir_reduc(lst: List[String]): List[String] = lst match {\n    case List(x) => List(x)\n    case x :: xs =>\n      dir_reduc(xs) match {\n        case Nil => List(x)\n        case y :: ys =>\n          if (canReduce(x, y)) ys\n          else x :: y :: ys\n      }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333990,"user_id":null,"body":"object dir_reduc {\n  def dir_reduc(arr: Array[String]): Array[String] = {\n    val r = \"\"\"(EAST WEST|WEST EAST|NORTH SOUTH|SOUTH NORTH) ?\"\"\".r\n    var s = arr.mkString(\" \")\n    while (r.findFirstIn(s).nonEmpty) {\n      s = r.replaceAllIn(s, \"\")\n    }\n    s.split(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333991,"user_id":null,"body":"object dir_reduc {\n  \n  def dir_reduc(arr: Array[String]): Array[String] = {\n    replace(arr.mkString(\",\")).split(\",\")\n  }\n  \n  private def replace(s:String) : String = {\n    val rep = s.replaceAll(\"NORTH,SOUTH,?\",\"\").\n                replaceAll(\"SOUTH,NORTH,?\",\"\").\n                replaceAll(\"EAST,WEST,?\",\"\").\n                replaceAll(\"WEST,EAST,?\",\"\")\n    if (rep == s) s else replace(rep)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333992,"user_id":null,"body":"object dir_reduc {\n\n  def dir_reduc(arr: Array[String]): Array[String] =\n    dir_reduc(arr.map(_(0)).mkString, \"\").map(x => arr.find(_(0) == x).get).toArray\n\n  def dir_reduc(dir: String, prev: String): String =\n    if (dir == prev) dir else dir_reduc(dir.replaceAll(\"NS|SN|WE|EW\", \"\"), dir)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"}],"5517fcb0236c8826940003c9":[{"id":333993,"user_id":null,"body":"object Fracts {\n\n  def sumFracts(lst: Array[(Long, Long)]): String = \n    if(lst.nonEmpty)\n      lst.map { case (n,d) => Rat(n,d) }\n         .reduce(_ + _)\n         .tos\n    else \"0\"\n  \n  case class Rat(num: Long, den: Long) {\n    def +(that:Rat): Rat = \n      Rat(\n          this.num * that.den + that.num * this.den,\n          this.den * that.den\n         ).simplify\n    \n    def simplify = Rat(\n      num \/ gcd(num, den), \n      den \/ gcd(num, den))\n    \n    def tos = \n      if(den != 1) s\"[$num, $den]\"\n      else s\"$num\"\n    \n    def gcd(a:Long, b:Long): Long =\n      if (b == 0) a else gcd(b, a % b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333994,"user_id":null,"body":"object Fracts {\n\n  def gcd(a: Long,b: Long): Long = {\n    if(b ==0) a else gcd(b, a%b)\n  }\n\n  def sumAndSimplify(rational1: (Long, Long), rational2: (Long, Long)): (Long, Long) = {\n    val numer = rational1._1 * rational2._2 + rational2._1 * rational1._2\n    val denom = rational1._2 * rational2._2\n    val gcdVal = gcd(numer, denom)\n    (numer\/gcdVal, denom\/gcdVal)\n  }\n\n  def sumFracts(lst: Array[(Long, Long)]): String = {\n    if (lst.isEmpty) {\n      \"0\"\n    } else {\n      val res = lst.reduce(sumAndSimplify(_, _))\n      if (res._1 % res._2 == 0) s\"${res._1\/res._2}\" else s\"[${res._1}, ${res._2}]\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333995,"user_id":null,"body":"object Fracts {\n\n    def sumFracts(lst: Array[(Long, Long)]): String = {\n    @scala.annotation.tailrec\n    def gcd(a: Long, b: Long): Long = \n      if(b==0) a\n      else gcd(b, a%b)\n    \n    def lcm(a: Long, b: Long): Long = \n      if(a==0) b\n      else (a * b) \/ gcd(a, b)\n    \n    @scala.annotation.tailrec\n    def reducer(numer: Long, den: Long): (Long, Long) = \n      if(gcd(numer, den) == 1) (numer, den)\n      else reducer(numer \/gcd(numer, den), den\/gcd(numer, den))\n    \n    if(lst.isEmpty) return \"0\"\n\n    val num: Array[Long] = lst.map(_._1)\n    val denom: Array[Long] = lst.map(_._2)\n    val multLst: Long = denom.reduceLeft((n1, n2) => lcm(n1, n2))\n    val sumQuotients: Long = denom.zip(num).map(pair => (multLst\/pair._1) * pair._2).sum\n    val (finalNum, finalDenom) = reducer(sumQuotients, multLst)\n    if(finalDenom == 1) finalNum.toString()\n    else s\"[$finalNum, $finalDenom]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333996,"user_id":53,"body":"object Fracts {\n\n  def gcd(a: Long, b: Long): Long = {\n    if (b == 0) a\n    else gcd(b, a % b)\n  }\n  \n  def lcm(a: Long, b: Long): Long = (a * b) \/ gcd(a, b)\n  \n  def reduce(t: (Long, Long)): (Long, Long) = {\n    val (a, b) = t\n    val i = gcd(a, b)\n    (a \/ i, b \/ i)\n  }\n  \n  def norm(t: (Long, Long), cd: Long): (Long, Long) = {\n    val (a, b) = t\n    (a * cd \/ b, cd)\n  }\n  \n  def sumFracts(lst: Array[(Long, Long)]): String = {\n    val xss = lst.map((xs) => reduce(xs))\n    val cd = xss.foldLeft(1L)((acc, xs) => lcm(xs._2, acc))\n    val yss = xss.map((xs) => norm(xs, cd))\n    val n = yss.foldLeft(0L)((acc, xs) => acc + xs._1)\n    val g = gcd(n, cd)\n    if (g == cd) {\n      return s\"${n \/ cd}\"\n    } else {\n      return s\"[${n \/ g}, ${cd \/ g}]\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333997,"user_id":null,"body":"\nobject Fracts {\n\n  def findLargestDivisor(numerator: Long, denominator: Long): Long = {\n    var divisor = denominator\n    while (divisor > 1) {\n      val numIsWhole = numerator % divisor == 0\n      val denIsWhole = denominator % divisor == 0\n      if (numIsWhole && denIsWhole) {\n        return divisor\n      }\n      divisor = divisor - 1\n    }\n    1L\n  }\n\n  def sumFractsHelper(lst: Array[(Long, Long)]): (Long, Long) = {\n    lst.map(t => reduceFraction(t._1, t._2)).reduce[(Long, Long)] {\n      case ((numeratorA, denominatorA), (numeratorB, denominatorB)) =>\n        if (denominatorA == denominatorB) {\n          (numeratorA + numeratorB, denominatorA)\n        } else {\n          val numSum = numeratorA * denominatorB + numeratorB * denominatorA\n          val denSum = denominatorA * denominatorB\n          reduceFraction(numSum, denSum)\n        }\n    }\n  }\n\n  def reduceFraction(numerator: Long, denominator: Long): (Long, Long) = {\n    val divisor = findLargestDivisor(numerator, denominator)\n    val n: Long = numerator \/ divisor\n    val d: Long = denominator \/ divisor\n    (n, d)\n  }\n\n  def sumFracts(lst: Array[(Long, Long)]): String = {\n    if (lst.isEmpty) {\n      \"0\"\n    } else {\n      val (n, d) = sumFractsHelper(lst)\n      val (numerator, denominator) = reduceFraction(n, d)\n      if (denominator == 1) {\n        numerator.toString\n      } else {\n        s\"[${numerator}, ${denominator}]\"\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333998,"user_id":null,"body":"object Fracts {\n  def gcd(a: Long, b: Long): Long = {\n    if (b == 0) a else gcd(b, a % b)\n  }\n  def sumFracts(lst: Array[(Long, Long)]): String = {\n    \/\/ your code\n    val lst1 = lst\n      .foldLeft((0L, 1L)) { case ((n1, d1), (n2, d2)) =>\n        ((n1 * d2 + n2 * d1)\/gcd(n1 * d2 + n2 * d1,d1 * d2), (d1 * d2)\/gcd(n1 * d2 + n2 * d1,d1 * d2))\n      }\n    val gcd1 = gcd(lst1._1,lst1._2)\n    if (lst1._1==0){return \"0\"}\n    if (lst1._1%lst1._2==0){return \"%d\".format(lst1._1\/lst1._2)}\n    \"[%d, %d]\".format(lst1._1,lst1._2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":333999,"user_id":null,"body":"import scala.annotation.tailrec\nobject Fracts {\n  \/\/ Greatest common divisor\n  @tailrec\n  def gcd(a: Long,b: Long): Long = {\n    if (b == 0) \n      a\n    else \n      gcd(b, a%b)\n  }\n  \n  \/\/ Simplifies a fraction\n  def simplify (n: Long, d: Long): (Long,Long) =  {\n    val c = gcd(n, d)\n    (n\/c, d\/c)\n  }\n\n  \/\/ simplifies a fraction in tuple form\n  def simplify (frac: (Long,Long)): (Long,Long) = frac match {\n    case (n,d) => simplify(n, d)\n  }\n  \n  def sumFracts(lst: Array[(Long, Long)]): String = {\n    \/\/ First round of simplification. We want those numbers as small as possible\n    val simplified = lst.map(simplify)\n    \/\/ Sums everything\n    val (n,d) = simplified.foldLeft((0L,1L)) { (fst, snd) =>\n      val (a,b) = fst\n      val (c,d) = snd\n      \n      val num = a*d + c*b\n      val denom = b * d \n      simplify(num, denom)\n    }\n  \n    \/\/ Returns the strings as demanded\n    if (d != 1)\n      \"[\" + n + \", \" + d + \"]\"\n    else\n      n.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":334000,"user_id":null,"body":"object Fracts {\n\n  def sumFracts(lst: Array[(Long, Long)]): String = {\n    def gcd(a: Long, b: Long): Long =\n      if (b == 0) a else gcd(b, a % b)\n\n    def LCM(a:Long, b:Long):Long = {\n      a * b \/ gcd(a,b)\n    }\n\n    val denom = lst.map(_._2).foldLeft(1L)(LCM)\n    val num = lst.map(x => x._1 * denom \/ x._2).sum\n\n    if (lst.isEmpty) \"0\" \n    else if (denom\/gcd(denom,num) == 1) s\"${num\/gcd(denom,num)}\"\n    else s\"[${num\/gcd(denom,num)}, ${denom\/gcd(denom,num)}]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:42","updated_at":"2022-12-30 18:39:42"},{"id":334001,"user_id":null,"body":"import scala.util.{Try, Success, Failure}\nobject Fracts {\n\n  def sumFracts(lst: Array[(Long, Long)]) = {\n    def gcd(a: Long, b: Long):Long = if (b==0) a.abs else gcd(b, a%b)\n\n    def add(res: (Long, Long), num: (Long, Long)) = {\n      val (n1, d1) = res; val (n2, d2) = num\n      val (n, d) = (n1*d2 + n2*d1, d1*d2); val del = gcd(n, d)\n      (n\/del, d\/del)\n    }\n\n    Try(lst.reduceLeft(add)) match {\n      case Success((n,d)) if n % d !=0 => s\"[$n, $d]\"\n      case Success((n,d)) => s\"${n\/d}\"\n      case Failure(_) => \"0\"\n    }\n\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334002,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Fracts {\n\n  @tailrec\n  def gcd(a: Long, b: Long): Long = {\n    if ( b == 0 ) a else gcd(b, a % b)\n  }\n\n  def lcm(a: Long, b: Long): Long = (a * b).abs \/ gcd(a, b)\n\n  def irreducibleForm(numerator: Long, denominator: Long): (Long, Long) = {\n    val commonDivisor = gcd(numerator, denominator)\n    (numerator \/ commonDivisor, denominator \/ commonDivisor)\n  }\n\n  def sumFracts(lst: Array[(Long, Long)]): String = lst match {\n    case Array() => \"0\"\n    case array =>\n      val (nums, dens) = array.unzip\n      val sumDen = dens.reduce(lcm)\n      val sumNum = lst.map {\n        case (n, d) => sumDen \/ d * n\n      }.sum\n\n      irreducibleForm(sumNum, sumDen) match {\n        case (n, 1) => n.toString\n        case (n, d) => s\"[$n, $d]\"\n      }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"551dc350bf4e526099000ae5":[{"id":334003,"user_id":573,"body":"object Wub {\n\n  def song_decoder(song: String): String =\n    song.replaceAll(\"(WUB)+\", \" \").trim\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334004,"user_id":null,"body":"object Wub {\n\n  def song_decoder(song: String): String = song.split(\"WUB\").filter(!_.isEmpty).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334005,"user_id":527,"body":"object Wub {\n  def song_decoder(song: String): String = re.replaceAllIn(song, \" \").trim\n  val re = \"(WUB)+\".r\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334006,"user_id":null,"body":"object Wub {\n\n  def song_decoder(song: String): String = {\n    song.split(\"WUB\").toList.filter(x => x.length > 0).mkString(\" \")\n\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334007,"user_id":null,"body":"object Wub {\n\n  def song_decoder(song: String): String = {\n    return   song.split(\"WUB\").filter(_ != \"\").mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334008,"user_id":null,"body":"object Wub {\n  def song_decoder(song: String) = song.split(\"WUB\").filter(!_.isEmpty).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334009,"user_id":null,"body":"object Wub {\n\n  def song_decoder(song: String) = song\n    .split(\"(WUB)+\")\n    .filter(_!=\"\")\n    .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334010,"user_id":null,"body":"object Wub {\n\n   def song_decoder(song: String): String =\n       song.replaceAll(\"WUB\",\" \").trim\n        .replaceAll(\"\\\\s+\",\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334011,"user_id":null,"body":"object Wub {\n\n  def song_decoder(song: String): String = song.replaceAll(\"WUB\", \" \").split(\" \").filter(_ != \"\").mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334012,"user_id":null,"body":"object Wub {\n\n  def song_decoder(song: String): String = song.split(\"WUB\").dropWhile(x => x==\"WUB\").filter(_.nonEmpty).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5526fc09a1bbd946250002dc":[{"id":334013,"user_id":573,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int =\n    integers.partition(_%2 == 0) match {\n      case (List(outlier), _) => outlier\n      case (_, List(outlier)) => outlier\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334014,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = {\n    val (even, odd) = integers.partition(_ % 2 == 0)\n    if(even.size == 1) even.head else odd.head\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334015,"user_id":null,"body":"object Parity {\n  def find_outlier(integers: Seq[Int]): Int = {\n    def evenList(lst: Seq[Int]) = (lst take 3 count isEven) >= 2\n    def isEven(x: Int) = x % 2 == 0\n\n    if (evenList(integers)) integers filterNot isEven head\n    else integers filter isEven head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334016,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = \n    if (integers.take(3).count(_ % 2 == 0) <= 1) integers.filter(_ % 2 == 0)(0) else integers.filterNot(_ % 2 == 0)(0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334017,"user_id":null,"body":"object Parity {\n  def find_outlier(integers: Seq[Int]): Int =\n    integers.groupBy(x => (x % 2).abs).minBy(_._2.length)._2.last\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334018,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = {\n      integers.groupBy(_ % 2 == 0).minBy(_._2.length)._2.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334019,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = {\n    var odd = 0;\n    var even = 0;\n    var i = 0;\n    \n    for (i <- integers) {\n      if (i % 2 == 0) {\n        even+= 1;\n      }\n      else {\n        odd+= 1;\n      }\n    }\n    \n    if (even < odd) {\n      for (i <- integers) {\n        if (i % 2 == 0) {\n          return i;\n        }\n      }\n    }\n    \n    for (i <- integers) {\n      if (i % 2 != 0) {\n        return i;\n      }\n    }\n  return -1;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334020,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = {\n    val a  = integers.filter(_ % 2 == 0)\n    val b  = integers.filterNot(_ % 2 == 0)\n    val res = if (a.length > b.length) b diff a else a diff b\n    res.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334021,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = {\n    integers.groupBy(_ % 2 == 0).toList.minBy(_._2.length)._2.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334022,"user_id":null,"body":"object Parity {\n\n  def find_outlier(integers: Seq[Int]): Int = {\n    integers.sliding(3).collectFirst {\n      case x if x.count(_ % 2 == 0) == 1 => x.find(_ % 2 == 0).get\n      case x if x.count(_ % 2 != 0) == 1 => x.find(_ % 2 != 0).get\n    }.get\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5536a85b6ed4ee5a78000035":[{"id":334023,"user_id":null,"body":"object Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    def pif(c: Double, a: Double) = {\n      math.sqrt((c*c - a*a).abs)\n    }\n    val frMap = ftwns toMap;\n    arrFriends.filter(frMap contains)\n              .map(frMap)\n              .map(h)\n              .:+(0.0)\n              .foldLeft((0.0, 0.0))((res, cur) => {\n                val d = pif(cur, res._2)\n                (res._1 + d, cur)\n              })._1 toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334024,"user_id":492,"body":"object Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    var totaldist: Double = 0\n    var prevdist: Double = 0\n    for (a <- 0 until arrFriends.length; fTown <- ftwns\n      if fTown._1 == arrFriends(a)) {\n        val d: Double = h.get(fTown._2).get\n        totaldist += scala.math.sqrt(d * d - prevdist * prevdist)\n        prevdist = d\n    }\n    (totaldist + prevdist).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334025,"user_id":null,"body":"object Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    val distance = (from: String) => (to: String) => math.sqrt(math.pow(h(to), 2) - math.pow(h(from), 2))\n    val towns = ftwns.toMap\n    val townsToVisit = \"X0\" +: arrFriends.flatMap(towns.get) :+ \"X0\"\n    \n    townsToVisit.sliding(2).map{ case Seq(from, to) => \n      if (from == \"X0\")  h(to)\n      else if (to == \"X0\")  h(from) \n      else distance(from)(to)\n    }.sum.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334026,"user_id":null,"body":"import scala.math.{sqrt, pow}\n\nobject Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    val towns = ftwns.filter(x => arrFriends.contains(x._1)).map(_._2).map(h(_))\n    val distances = towns.zip(towns.tail).map(x => sqrt(pow(x._2, 2) - pow(x._1, 2)))\n    \n    (towns.head + distances.sum + towns.last).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334027,"user_id":null,"body":"object Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n\n    val townMap = ftwns.toMap\n    val ftowns = ftwns.filter{ case (f, _) => arrFriends.contains(f) }\n    \/\/ shift ftwns and compute the triangle length B2 = C2 - A2\n    val townDistances = ftowns.drop(1).zip(ftowns).flatMap{\n      case ((_, twn2), (_, twn1)) =>\n        h.get(twn2).flatMap{ d2 =>\n          h.get(twn1).map(d1 => scala.math.sqrt(scala.math.pow(d2, 2) - scala.math.pow(d1, 2))).map((twn1, _))\n        }\n    } :+ (ftowns.last._2, 0.0)\n  \n    \n    \n    val res = arrFriends.foldLeft((0.0, None: Option[String])){\n      case ((acc, place), f) =>\n        townMap.get(f) match {\n          case Some(town) =>\n            h.get(town) match {\n              case Some(distance) =>\n                place match {\n                  case None => (acc + distance, Some(town))\n                  case Some(prevTown) =>\n                    val dst = townDistances.dropWhile(_._1 != prevTown).takeWhile(_._1 != town).map(_._2).sum\n                    val newDist = scala.math.min(h(town) + h(prevTown), dst)\n                    (acc + newDist, Some(town))\n                }\n              case None => (acc, place)\n            }\n          case None => (acc, place)\n        }\n    }\n    \n    (res._1 + h(res._2.get)).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334028,"user_id":null,"body":"object Tour {\n\n    \n  def takeOnlyRelevantDistances(\n    friends: List[String],\n    towns: List[(String, String)],\n    distances: Map[String, Double]\n  ): Seq[Double] =\n    friends\n      .flatMap(friend => towns.find { case (person, _) => person == friend })\n      .map { case (_, town) => distances(town) }\n\n  def findSidePythagoras(hypotenuse: Double, side: Double): Double = {\n    val s: Double = Math.pow(side, 2d)\n    val h: Double = Math.pow(hypotenuse, 2d)\n    Math.sqrt(Math.round(Math.abs(h - s)).toDouble)\n  }\n\n  def tour(friends: List[String], towns: List[(String, String)], distances: Map[String, Double]): Int = {\n    val distance: Seq[Double] = takeOnlyRelevantDistances(friends, towns, distances)\n\n    val path = distance\n      .sliding(2,1)\n      .map { case List(current, next) => findSidePythagoras(current, next) }\n      .sum\n\n    (path + distance.head + distance.last).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334029,"user_id":null,"body":"import scala.math.{sqrt, pow}\nobject Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    val ftwnsFiltred =  ftwns.filter(x => arrFriends.contains(x._1))\n    val thereAndBackToXo = h(ftwnsFiltred.head._2) + h(ftwnsFiltred.reverse.head._2)\n    ftwnsFiltred.sliding(2).foldLeft(thereAndBackToXo)((acc, pair) => {\n      acc + sqrt(pow(h(pair.reverse.head._2), 2) - pow(h(pair.head._2), 2))\n    }).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334030,"user_id":null,"body":"object Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n      def pif(c: Double, a: Double) = {\n        math.sqrt((c*c - a*a).abs)\n      }\n      val frMap = ftwns.toMap;\n      arrFriends.filter(frMap.contains)\n                .map(frMap)\n                .map(h)\n                .:+(0.0)\n                .foldLeft((0.0, 0.0))((res, cur) => {\n                  val d = pif(cur, res._2)\n                  (res._1 + d, cur)\n                })._1.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334031,"user_id":null,"body":"import scala.math._\n\nobject Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    val distance: List[Double] = arrFriends.map(friend => {\n      val location = ftwns.toMap.getOrElse(friend, None)\n      val d = h.getOrElse(location.toString(), 0.toDouble)\n      d\n    }).filter(_ > 0)\n    \n    val middleDistance: Iterator[Double] = for (List(left, right) <- distance.sliding(2)) yield {     \n      sqrt(abs(pow(right, 2) - pow(left, 2)))\n    }\n    \n    (middleDistance.toArray.sum + distance(0) + distance.last).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334032,"user_id":null,"body":"object Tour {\n\n  def tour(arrFriends: List[String], ftwns: List[(String, String)], h: Map[String, Double]): Int = {\n    val toVisit = arrFriends.intersect(ftwns.map(_._1))\n    val ftwnsMap = ftwns.toMap\n    def rightTriangleDistance(c1: Double, h: Double) = math.sqrt(h * h - c1 * c1)\n\n    def visiting(toVisit: List[String], currentTown: String, acc: Double): Double = {\n      if (toVisit.isEmpty) acc + h(ftwnsMap(currentTown))\n      else {\n        val nextTown = toVisit.head\n        val nextTownDistance = h(ftwnsMap(nextTown))\n        val currentTownDistance = h(ftwnsMap(currentTown))\n        val toTravel = rightTriangleDistance(currentTownDistance, nextTownDistance)\n        visiting(toVisit.tail, nextTown, acc + toTravel)\n      }\n    }\n    \n    math.floor(visiting(toVisit.tail, toVisit.head, h(ftwnsMap(toVisit.head)))).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5539fecef69c483c5a000015":[{"id":334033,"user_id":492,"body":"object Solution {\n  def backwards_prime(start: Long, nd: Long): String = {\n    def isPrime(n: Long): Boolean =\n      (n == 2) || !(2 +: (3 to Math.sqrt(n).toInt by 2) exists (n % _ == 0))\n\n    def rv(a: Long) = (a + \"\").reverse.toLong\n    \n    def good(i: Long) = {\n      val r = rv(i)\n      i != r && isPrime(i) && isPrime(r)\n    }\n    \n    ((start to nd) filter good).toList mkString \",\"\n\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:17:10"},{"id":334034,"user_id":751,"body":"object Solution {\n  \n  def backwards_prime(start: Long, nd: Long): String = \n    (start to nd).filter(isBackwardPrime).mkString(\",\")\n  \n  \/\/ Helpers\n  def isBackwardPrime(n: Long) = \n    !isPalindrome(n) && isPrime(n) && isPrime(reverse(n)) \n  def isPrime(n: Long) = \n    (2L to math.sqrt(n).toLong).dropWhile(n % _ !=0).isEmpty\n  def isPalindrome(n: Long) = n == reverse(n)\n  def reverse(n: Long) = n.toString.reverse.toLong\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334035,"user_id":53,"body":"object Solution {\n  def backwards_prime(start: Long, nd: Long): String = {\n    (start to nd)\n      .filter(isPrime)\n      .filter((n) => n.toString.reverse.toLong != n)\n      .filter((n) => isPrime(n.toString.reverse.toLong))\n      .mkString(\",\")\n  }\n  def isPrime(n: Long): Boolean = {\n    if (n%2L == 0L) (n == 2L)\n    else (3L to Math.sqrt(n).toLong by 2L).forall(d => n%d != 0L)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334036,"user_id":null,"body":"object Solution {\n  private def isPrime(n: Long): Boolean = ! ((2L to n-1) exists (n % _ == 0))\n  \n  private def isPalindrome(n: Long): Boolean = !(n.toString == n.toString.reverse)\n  \n  def backwards_prime(start: Long, nd: Long): String = {\n    (start to nd + 1)\n    .filter(isPrime)\n    .filter(isPalindrome)\n    .filter(num => isPrime(num.toString.reverse.toLong))\n    .mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334037,"user_id":null,"body":"object Solution {\n  def backwards_prime(start: Long, nd: Long): String = {\n    \/\/ your code\n    val noPalins = (start to nd).filterNot(x => x == x.toString.reverse.toLong)\n    val thePrimes = noPalins.filter(isPrime(_))\n    val semirp = thePrimes.filter(x => isPrime(x.toString.reverse.toLong))\n    semirp.mkString(\",\")\n  }\n\n  @annotation.tailrec\n  def isPrime(num: Long, i: Int = 2): Boolean = {\n      if(num % i == 0) false\n      else if(i == math.sqrt(num).toInt) true\n      else isPrime(num, i + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334038,"user_id":492,"body":"object Solution {\n  def backwards_prime(start: Long, nd: Long): String = {\n    def isPrime(n: Long): Boolean =\n      (n == 2) || !(2 +: (3 to Math.sqrt(n).toInt by 2) exists (n % _ == 0))\n\n    def rv(a: Long) = (a + \"\").reverse.toLong\n    \n    def good(i: Long) = {\n      val r = rv(i)\n      i != r && isPrime(i) && isPrime(r)\n    }\n    \n    ((start to nd) filter good).toList mkString \",\"\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334039,"user_id":null,"body":"object Solution {\n  var list = scala.collection.mutable.ListBuffer.empty[Long]\n  \n  def backwards_prime(start: Long, nd: Long): String = {\n  for (x: Long <- start until nd+1) {\n      var reverseOutput = x.toString.reverse.toLong\n      if (isPrime(x) && isPrime(reverseOutput) && (x != reverseOutput)) {\n        list += x\n      }\n    }\n    val finished = list.sorted.mkString(\",\")\n    list.clear()\n    finished\n  }\n  \n  def isPrime(n: Long): Boolean = {\n    if (n <= 1L)\n      false\n    else if (n == 2L)\n      true\n    else\n      !(2L to (n - 1L)).exists(x => n % x == 0L)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334040,"user_id":null,"body":"\nobject Solution {\n\n  def isPrime(n: Long): Boolean = {\n    if (n == 1) false\n    else\n      (2 to math.sqrt(n).ceil.toInt).map(n % _ != 0).foldLeft(true)(_ && _)\n  }\n\n  def isbackwards_prime(n: Long): Boolean = {\n    val reverse = n.toString.reverse.toLong\n    isPrime(n) && isPrime(reverse) && n != reverse\n  }\n  def backwards_prime(start: Long, nd: Long): String = {\n    (start to nd).filter(n => isbackwards_prime(n)).mkString(\",\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:06:30"},{"id":334041,"user_id":null,"body":"object Solution {\n  def backwards_prime(start: Long, end: Long): String = {\n    (start to end).filter { x =>\n        val reversed = x.toString.reverse.toLong\n        isPrime(x) && isPrime(reversed) && x != reversed\n    }.mkString(\",\")\n  }\n\n  def isPrime(candidate: Long): Boolean = {\n    val testRange = 2 +: (3 to (candidate \/ 2L).ceil.toInt by 2).toList\n    testRange.forall(candidate % _ != 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":334042,"user_id":null,"body":"object Solution {\n  def backwards_prime(start: Long, nd: Long): String = {\n    val fullList: List[Long] = (start to nd).toList\n    val primeList: List[Long] = fullList.filter(isPrime)\n    \n    primeList\n    .filter(elem => isPrime(reverseNumber(elem)) && reverseNumber(elem) != elem)\n    .mkString(\",\")\n  }\n  \n  def isPrime(number: Long): Boolean = \n  (2L to Math.sqrt(number).toLong).filter(inner => number % inner == 0).isEmpty\n  \n  def reverseNumber(number: Long): Long = {\n    number.toString.reverse.toLong\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"}],"5541f58a944b85ce6d00006a":[{"id":334043,"user_id":573,"body":"object ProdFib {\n\n  def product_fib(prod: Long): Array[Long] = \n    LazyList\n      .iterate((0L, 1L)){ case (n1, n2) => (n2, n1 + n2) }\n      .collectFirst { case (n1, n2) if n1 * n2 >= prod => Array(n1, n2, if (n1 * n2 == prod) 1 else 0) }\n      .get\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334044,"user_id":null,"body":"object ProdFib {\n\n  def product_fib(prod: Long): Array[Long] = \n    Stream.iterate((0L, 1L)){case (n1, n2) => (n2, n1 + n2)}\n      .filter{case (n1, n2) => n1 * n2 >= prod}\n      .map{case (n1, n2) => Array(n1, n2, if (n1 * n2 == prod) 1 else 0)}\n      .head\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334045,"user_id":null,"body":"object ProdFib {\n\n  @scala.annotation.tailrec\n  def product_fib(prod: Long, f1: Long = 1, f2: Long = 1): Array[Long] =\n    if (f1 * f2 < prod) product_fib(prod, f2, f1 + f2)\n    else Array(f1, f2, if (f1 * f2 == prod) 1 else 0)\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334046,"user_id":null,"body":"object ProdFib {\n\n  def product_fib(prod: Long): Array[Long] = {\n    def takeWhile(a: Long, b: Long): Array[Long] = {\n      if (a * b < prod) takeWhile(b, a + b)\n      else Array(a, b, if (a * b == prod) 1 else 0)\n    }\n\n    takeWhile(0, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334047,"user_id":492,"body":"object ProdFib {\n\n  def product_fib(prod: Long): Array[Long] = {\n    var a: Long = 0L\n    var b: Long = 1L\n    while (a * b < prod) {\n      val tmp: Long = a\n      a = b\n      b = tmp + b\n    }\n    Array(a, b, if (a * b == prod) 1 else 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334048,"user_id":53,"body":"object ProdFib {\n\n  def helper(a: Long, b: Long, n: Long): Array[Long] = {\n    if (a * b >= n) Array(a, b, if (a * b == n) 1 else 0)\n    else helper(b, a + b, n)\n  }\n  \n  def product_fib(n: Long): Array[Long] = {\n    helper(0, 1, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334049,"user_id":null,"body":"object ProdFib {\n\n  def product_fib(prod: Long, a: Long = 0L, b: Long = 1L): Array[Long] = prod match {\n    case _ if a * b == prod => Array(a, b, 1)\n    case _ if a * b > prod => Array(a, b, 0)\n    case _ => product_fib(prod, b, a + b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334050,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject ProdFib {\n  def product_fib(prod: Long): Array[Long] = {\n    @tailrec\n    def fibFrom(a: Long, b: Long): Array[Long] = \n      if (a * b == prod) Array(a, b, 1)\n      else if (a * b > prod) Array(a, b, 0) \n      else fibFrom(b, a + b)\n    fibFrom(1, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334051,"user_id":1228,"body":"object ProdFib {\n\n  def product_fib(prod: Long): Array[Long] = {\n    var (a, b) = (0L, 1L)\n    while (prod > a * b) {\n      var t = a\n      a = b\n      b = t + b\n    }\n    Array(a, b, (if (prod == a * b) 1L else 0L)) \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334052,"user_id":null,"body":"object ProdFib {\nimport scala.annotation.tailrec\n  \n  def product_fib(prod: Long): Array[Long] = {\n    @tailrec\n    def product_fibAux(n: Long, m: Long): Array[Long] = {\n      if(n * m < prod) product_fibAux(m, n + m)\n      else if (n * m > prod) Array(n, m, 0)\n      else Array(n ,m, 1)\n    }\n    \n    product_fibAux(0, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5544c7a5cb454edb3c000047":[{"id":334053,"user_id":null,"body":"import scala.math.{ceil,log}\nobject Kata {\n\n  def bouncing_ball(h: Double, b: Double, w: Double): Int =\n    if (h <= 0 || b <= 0 || b >= 1 || w >= h) -1\n    else -1 + 2 * ceil(log(w\/h)\/log(b)).toInt\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334054,"user_id":null,"body":"object Kata {\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = h match {\n    case _ if h <= 0 => -1\n    case _ if bounce >= 1 || bounce <= 0 => -1\n    case _ if window >= h => -1\n    case _ => 2 * Stream.iterate(h)(_ * bounce).takeWhile(_ > window).size - 1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334055,"user_id":492,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if ((h <= 0) || (window >= h) || (bounce <= 0) || (bounce >= 1)) return -1\n    var seen: Int = -1\n    var hh = h\n    while (hh > window) {\n      seen += 2\n      hh *= bounce\n    }\n    seen\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334056,"user_id":null,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if (h < 0 || bounce >= 1 || bounce < 0 || window >= h) -1\n    else 2 + bouncing_ball(h * bounce, bounce, window)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334057,"user_id":null,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if (!((h > 0) && (bounce > 0 && bounce < 1) && (window < h))) -1\n    else {\n      def reboundUp(h: Double, bounce: Double, window : Double)(acc: Int): Int = {\n        if ((h * bounce) > window) reboundUp(h * bounce, bounce, window)(acc + 2)\n        else acc\n      }\n      reboundUp(h, bounce, window)(1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334058,"user_id":907,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if ((h > 0)&&(bounce > 0)&&(bounce < 1)&&(window < h))\n      2 + bouncing_ball(h*bounce, bounce, window)\n    else\n      -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334059,"user_id":null,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    def check(h: Double, bounce: Double, window: Double): Boolean =\n      (h > 0 && bounce > 0 && bounce < 1 && window < h)\n    \n    def bounceRec(currentH: Double, acc: Int): Int = {\n      if (currentH <= window) {\n        acc - 1\n      } else {\n        bounceRec(currentH * bounce, acc + 2)\n      }\n    }\n    \n    if (check(h, bounce, window)) {\n      bounceRec(h, 0)\n    } else {\n      -1\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334060,"user_id":492,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if ((h <= 0) || (window >= h) || (bounce <= 0) || (bounce >= 1)) return -1\n    var seen: Int = -1\n    var hh = h\n    while (hh > window) {\n      seen += 2\n      hh *= bounce\n    }\n    seen\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334061,"user_id":null,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if (bounce <= 0 || bounce >= 1) return -1\n    if (h <= window) -1 else 2 + bouncing_ball(h * bounce, bounce, window)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334062,"user_id":null,"body":"object Kata {\n\n  def bouncing_ball(h: Double, bounce: Double, window: Double): Int = {\n    if(h < 0) return -1\n    if(window >= h) return -1\n    if(bounce <= 0 | bounce >= 1) return -1\n\n    def bounceBall (ballHeight: Double, passedCount: Int): Int = {\n      var counter = passedCount\n      \n      if(ballHeight < window) return counter\n      \n      if(ballHeight > window) counter += 1 \/\/ fall\n      \n      val bounced: Double = ballHeight * bounce\n      \n      if(bounced > window) counter += 1 \/\/ bounce|Up\n      \n      bounceBall(bounced, counter)\n    }\n    \n    bounceBall(h, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5545f109004975ea66000086":[{"id":334063,"user_id":573,"body":"object Kata {\n\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = n % x == 0 & n % y == 0\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334064,"user_id":null,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = n%x + n%y == 0\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334065,"user_id":null,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = {\n    return (n % x == 0 && n % y == 0);\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334066,"user_id":null,"body":"object Kata {\n  \n  def is_divisible(n: Int, x: Int, y: Int): Boolean = curry(aCondition)(n)(x)(y)\n\n  val curry: ((Int, Int, Int) => Boolean) => (Int => (Int => (Int => Boolean))) = f => n => x => y => f(n, x, y)\n  val aCondition: (Int, Int, Int) => Boolean = (n, x, y) => n % x + n % y == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334067,"user_id":null,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = n match {\n    case n if n % x == 0 && n % y == 0 => true\n    case _ => false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334068,"user_id":975,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = {\n    0 == n % x + n % y\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334069,"user_id":null,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = (n % y == 0) && (n % x == 0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334070,"user_id":null,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = {\n    val a = n % x\n    val b = n % y\n    if (a == 0 && b == 0) true\n    else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334071,"user_id":null,"body":"object Kata {\n  def is_divisible(n: Int, x: Int, y: Int): Boolean = {\n    n > 0 & x > 0 & y > 0 & n % x == 0 & n % y == 0\n      \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334072,"user_id":null,"body":"object Kata {\n  \n  def is_divisible(n: Int, x: Int, y: Int): Boolean = curry(cond)(n)(x)(y)\n\n  val curry: ((Int, Int, Int) => Boolean) => \n              (Int => Int => Int => Boolean) = f => n => x => y => f(n, x, y)\n  \n  val cond: (Int, Int, Int) => Boolean = (n, x, y) => n % x + n % y == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55466989aeecab5aac00003e":[{"id":334073,"user_id":492,"body":"object SqInRect {\n\n  def sq_in_rect(min: Int, max: Int): Array[Int] = {\n    if (max == min) {\n      return Array()\n    }\n    var (mmax, mmin) = (max, min)\n    val lst = List.newBuilder[Int]\n    while (mmax > 0 && min > 0) {\n      if (mmin > mmax) {\n        var tmp: Int = mmax\n        mmax = mmin\n        mmin = tmp\n      }\n      lst += mmin\n      mmax -= mmin\n    }\n    lst.result().toArray\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334074,"user_id":573,"body":"object SqInRect {\n\n  def sq_in_rect(min: Int, max: Int, squares: Array[Int] = Array()): Array[Int] = {\n    val Array(width, length) = Array(min, max).sorted\n    if (width == length)\n      if (squares.isEmpty) Array() else (width +: squares).reverse\n    else\n      sq_in_rect(length-width, width, width +: squares)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334075,"user_id":null,"body":"  object SqInRect {\n\n  def sq_in_rect(min: Int, max: Int): Array[Int] = (Math.min(min, max), Math.max(min, max)) match {\n    \/\/ your code\n    case (a, b) if(a * b >= 1 && a != b - a && a != b) =>\n      Array(a) ++ sq_in_rect(Math.min(a, b - a), Math.max(a, b - a))\n    case (a, b) if(a == b - a) => Array(a) ++ Array(a)\n    case (a, b) if(a == b) => Array()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334076,"user_id":null,"body":"object SqInRect {\n\ndef sq_in_rect(min: Int, max: Int): Array[Int] = {\n    def loop (min: Int, max: Int, anw: Array[Int] = Array()):Array[Int] = {\n      min match {\n        case ch if(ch>max) => loop(max,min,anw)\n        case x if x==max => anw:+x\n        case _ => loop(max-min,min,anw :+ min)\n      }\n    }\n if (min==max) Array() else\n   loop(min,max)\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334077,"user_id":null,"body":"object SqInRect {\n\ndef sq_in_rect(min: Int, max: Int): Array[Int] = {\n    if (min == max || min == 0 || max == 0) Array()\n    else if (min > max) sq_in_rect(max, min)\n    else Array.fill(max\/min)(min) ++ sq_in_rect(max % min, min)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334078,"user_id":null,"body":"object SqInRect {\n\n  def sq_in_rect(a: Int, b: Int, first: Boolean = true): Array[Int] = {\n    val max = a.max(b)\n    val min = a.min(b)\n    if (max == min) {\n      if (first) Array() else Array(max)\n    } else {\n      Array(min) ++ sq_in_rect(min, max - min, false)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334079,"user_id":492,"body":"object SqInRect {\n\n  def sq_in_rect(min: Int, max: Int): Array[Int] = {\n    if (max == min) {\n      return Array()\n    }\n    var (mmax, mmin) = (max, min)\n    val lst = List.newBuilder[Int]\n    while (mmax > 0 && min > 0) {\n      if (mmin > mmax) {\n        var tmp: Int = mmax\n        mmax = mmin\n        mmin = tmp\n      }\n      lst += mmin\n      mmax -= mmin\n    }\n    lst.result().toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334080,"user_id":null,"body":"object SqInRect {\n\n  def sq_in_rect(min: Int, max: Int): Array[Int] = {\n    \n    def sq_in_rect_(min: Int, max: Int): Array[Int] =\n\t    \tif (min == 0) Array() else Array.fill(max\/min)(min) ++ sq_in_rect_(max%min, min)\n  \t \t\t\n    \n    if (min == max) Array() else sq_in_rect_(if (min < max) min else max, if (min>max) min else max)\n  }\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334081,"user_id":53,"body":"object SqInRect {\n\n  def sq_in_rect(min: Int, max: Int): Array[Int] = {\n    if (min == max) Array()\n    else walk(Array(), min, max)\n  }\n  \n  def walk(xs: Array[Int], a: Int, b: Int): Array[Int] = {\n    def l = Math.max(a, b)\n    def w = Math.min(a, b)\n    if (w == 0) xs\n    else walk(xs :+ w, w, l - w)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334082,"user_id":null,"body":"object SqInRect {\n\n  def sq_in_rect(a: Int, b: Int): Array[Int] =\n    if(a == b) Array()\n    else f(a, b, List()).toArray\n  \n  def f(a: Int, b: Int, acc: List[Int]): List[Int] =\n    if(b > a) f(b, a, acc)\n    else if(b == 0) acc\n    else f(b, a - b, acc :+ b)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5547cc7dcad755e480000004":[{"id":334083,"user_id":null,"body":"object RemovedNumbers {\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val sum = n * (n+1) \/ 2\n    (for {\n      i <- 1L to n\n      if ((sum.toDouble - i) \/ (i+1).toDouble).isWhole && (sum - i) \/ (i+1) <= n\n    } yield (i, (sum - i) \/ (i+1))).toList\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334084,"user_id":null,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val target = n * (n + 1) \/ 2 + 1\n    Iterable.range(n \/ 2, n)\n      .filter(target % _ == 0)\n      .map(x => (x - 1, target \/ x - 1))\n      .toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334085,"user_id":null,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val sumOfSeq = (1L to n).sum\n    val possibleNums = for {\n      a <- 1L to n\n      b =  (sumOfSeq - a) \/ (a + 1)\n      if a * b == sumOfSeq - (a + b) && b < n\n    } yield (a, b)\n    possibleNums.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334086,"user_id":null,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val sumN = (1L to n).sum\n    (2L to n)\n      .filter(a => { val b = (sumN-a).toDouble\/(a+1); b.isWhole && b < n;})\n      .map(x=>(x,(sumN-x)\/(x+1)))\n      .toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334087,"user_id":492,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val s: Long = (n * (n + 1) \/ 2.0).toLong\n    val res = List.newBuilder[(Long, Long)]\n    var i: Long = (n \/ 2).toLong\n    while (i <= n) {\n      val b: Long = (s - i).toLong\n      if (b % (i + 1) == 0) {\n        val t = (i, (b \/ (i + 1)).toLong)\n        res += t\n      }\n      i += 1\n    }\n    res.result()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334088,"user_id":573,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val total = n * (n+1) \/ 2\n    (1L to n)\n      .map(a => (a, a + (total - a) % a))\n      .flatMap { case (a, b) if a*b == total - a - b => Seq((a, b), (b, a)).distinct case _ => None }\n      .sortBy(_._1)\n      .toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334089,"user_id":573,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val total = n * (n+1) \/ 2\n    (for {\n      a <- (1L to n)\n      b = a + (total - a) % a\n      if a*b == total - a - b\n      c <- Seq((a, b), (b, a)).distinct\n    } yield c)\n    .sortBy(_._1)\n    .toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334090,"user_id":null,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val sum = n * (n + 1) \/ 2 \/\/ sum of the sequence\n    val lower = n * (n + 1) \/ (2 * n + 1) \/\/ Lower bound for the values of a and b\n    (for {\n      a <- lower to n\n      if  (sum - a) % (a + 1) == 0 \/\/ This guard ensures b is an integer\n    } yield (a, (sum - a) \/ (a + 1))).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334091,"user_id":null,"body":"object RemovedNumbers {\n\n  def remove_nb(n: Long): List[(Long, Long)] = {\n    val sum = (n + 1) * n \/ 2\n    var res: List[(Long, Long)] = List()\n    for (i <- 1L to n) {\n      if ((sum - i) % (i + 1) == 0) {\n        val j = (sum - i) \/ (i + 1)\n        if (j <= n) {\n          res = res :+ (i, j)  \n        }\n      }\n    }\n    \n    res.sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334092,"user_id":null,"body":"object RemovedNumbers {\n\n    def remove_nb(n: Long): List[(Long, Long)] = {\n    import scala.annotation.tailrec\n\n    val sum: Double =  (n.toDouble \/ 2f) *  (n.toDouble + 1f)\n    \n    @tailrec\n    def loop(valueOfa: Long, acc: List[(Long, Long)] = List.empty): List[(Long, Long)] = {\n      if (valueOfa == n + 1) acc\n      else {\n        val valueOfB: Double = (sum - valueOfa) \/ (valueOfa + 1f)\n\n        if (valueOfB <= n && valueOfB.isWhole) {\n          loop(valueOfa + 1, acc :+ (valueOfa, valueOfB.toLong))\n        }\n        else loop(valueOfa + 1, acc)\n      }\n    }\n\n    loop(n \/ 2)\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"554a44516729e4d80b000012":[{"id":334093,"user_id":null,"body":"object BuyCar {\n\n  def nb_months(oldCarPrice: Double,\n               newCarPrice: Double,\n               savingPerMonth: Int,\n               percentLossByMonth: Double,\n               months: Int = 0): Array[Int] = {\n    val loss = if ((months + 1) % 2 == 0) {\n      percentLossByMonth + 0.5\n    } else {\n      percentLossByMonth\n    }\n\n    val totalCash = savingPerMonth * months + oldCarPrice\n    if (totalCash >= newCarPrice) {\n      Array(months, Math.round(totalCash - newCarPrice).toInt)\n    } else {\n      nb_months(\n        decreasePrice(oldCarPrice, loss),\n        decreasePrice(newCarPrice, loss),\n        savingPerMonth,\n        loss,\n        months + 1\n      )\n    }\n  }\n\n  private def decreasePrice(price: Double, loss: Double): Double = price - price * loss \/ 100\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334094,"user_id":573,"body":"object BuyCar {\n\n  def nb_months(\n    startPriceOld: Int,\n    startPriceNew: Int,\n    savingPerMonth: Int,\n    percentLossByMonth: Double\n  ): Array[Int] = {\n\n    (Iterator.from(0)\n      .scanLeft(startPriceOld.toDouble, startPriceNew.toDouble, percentLossByMonth\/100, 0) {\n        case ((pOld, pNew, lossPct, month), _) =>\n          (pOld*(1-lossPct), pNew*(1-lossPct), lossPct + (if (month % 2 == 0) 0.005 else 0), month+1)\n      }\n      .find { case (pOld, pNew, lossPct, month) => pOld + month*savingPerMonth >= pNew })\n      match {\n        case Some((pOld, pNew, lossPct, month)) => Array(month, (pOld + month*savingPerMonth - pNew).round.toInt)\n      }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334095,"user_id":null,"body":"import scala.math.round\nimport scala.annotation.tailrec\n\nobject BuyCar {\n\n  def nb_months(startPriceOld: Double,\n               startPriceNew: Double,\n               savingperMonth: Double,\n               percentLossByMonth: Double): Array[Int] = {\n  \n    @tailrec\n    def loop(startPriceOld: Double,\n             startPriceNew: Double,\n             savingperMonth: Double,\n             percentLossByMonth: Double,\n             bankTotal: Double = 0,\n             months: Int = 1): Array[Int] = {\n  \n      val currentSavings = bankTotal + savingperMonth\n      val monthlyPercentageLoss = if (months % 2 == 0) percentLossByMonth + 0.5 else percentLossByMonth\n      val startPriceOldUpd = startPriceOld * (1 - (monthlyPercentageLoss \/ 100))\n      val startPriceNewUpd = startPriceNew * (1 - (monthlyPercentageLoss \/ 100))\n  \n      if ((currentSavings + startPriceOldUpd - startPriceNewUpd) >= 0) Array(months, round(currentSavings + startPriceOldUpd - startPriceNewUpd).toInt)\n      else loop(startPriceOldUpd, startPriceNewUpd, savingperMonth, monthlyPercentageLoss, currentSavings, months + 1)\n    }\n  \n    if ((startPriceOld - startPriceNew) >= 0) Array(0, round(startPriceOld - startPriceNew).toInt)\n    else loop(startPriceOld, startPriceNew, savingperMonth, percentLossByMonth)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334096,"user_id":492,"body":"object BuyCar {\n\n  def nb_months(startPriceOld: Int,\n               startPriceNew: Int,\n               savingperMonth: Int,\n               percentLossByMonth: Double): Array[Int] = {\n    var pLBM = percentLossByMonth\n    var mth: Int = 0\n    var priceOld: Double = startPriceOld.toDouble\n    var priceNew: Double = startPriceNew.toDouble\n    var available: Double = startPriceOld.toDouble\n    while (available < priceNew) {\n      mth += 1\n      if (mth % 2 == 0) pLBM += 0.5\n      priceOld = priceOld * (100.0 - pLBM) \/ 100.0\n      priceNew = priceNew * (100.0 - pLBM) \/ 100.0\n      available = mth * savingperMonth + priceOld\n    }\n    val res: Array[Int] = Array(mth, (available - priceNew + .5).toInt)\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334097,"user_id":53,"body":"object BuyCar {\n\n  def nb_months(startPriceOld: Int,\n               startPriceNew: Int,\n               savingperMonth: Int,\n               percentLossByMonth: Double): Array[Int] = {\n    walk(startPriceOld, startPriceNew, savingperMonth, percentLossByMonth, 0, 0)\n  }\n  \n  def walk(p0: Double, p1: Double, s: Int, r: Double, m: Int, t: Int):  Array[Int] = {\n    if (p1 <= p0 + t) Array(m, (p0 - p1 + t).round.toInt)\n    else walk(p0 - p0 * 0.01 * r, p1 - p1 * 0.01 * r, s, if (m % 2 == 0) r + 0.5 else r, m + 1, t + s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334098,"user_id":null,"body":"object BuyCar {\n\n  def nb_months(\n      startPriceOld: Int,\n      startPriceNew: Int,\n      savingperMonth: Int,\n      percentLossByMonth: Double\n  ): Array[Int] = {\n    var savings: Double = 0\n    var month = 0\n    var priceNew: Double = startPriceNew\n    var priceOld: Double = startPriceOld\n    var loss = percentLossByMonth\n    while (priceOld + savings < priceNew) {\n      month += 1\n      if (month > 0 && month % 2 == 0) {\n        loss += 0.5\n      }\n      priceOld -= (priceOld * (loss \/ 100))\n      savings += savingperMonth\n      priceNew -= (priceNew * (loss \/ 100))\n    }\n    Array(month, (priceOld + savings - priceNew).round.toInt)\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334099,"user_id":null,"body":"object BuyCar {\n\n  def nb_months(startPriceOld: Int,\n               startPriceNew: Int,\n               savingperMonth: Int,\n               percentLossByMonth: Double): Array[Int] = {\n    \n    def iter(n:Int, saving: Int, priceOld:Double, priceNew: Double, percent: Double): Array[Int] = {    \n      if (saving+priceOld >= priceNew) Array(n, Math.round(saving+priceOld - priceNew).toInt)\n      else {\n        var newPercent = percent\n        if ((n+1)%2==0) newPercent = percent + 0.5\n        val newSaving = saving + savingperMonth\n        val newPriceOld = ((1-newPercent\/100) * priceOld)\n        val newPriceNew = ((1-newPercent\/100) * priceNew)\n        iter(n+1, newSaving, newPriceOld, newPriceNew, newPercent)\n        \n    }\n  }\n    iter(0,0, startPriceOld, startPriceNew, percentLossByMonth)\n}\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334100,"user_id":null,"body":"object BuyCar {\n\n  def nb_months(startPriceOld: Int,\n               startPriceNew: Int,\n               savingperMonth: Int,\n               percentLossByMonth: Double): Array[Int] = {\n    \/\/ your code\n    var res: Double = startPriceOld - startPriceNew\n    var iteration: Int = 0\n    var currentPriceNew: Double = startPriceNew - startPriceOld\n    var currentPercent: Double = percentLossByMonth\n    while (res < 0) {\n      iteration += 1\n      if (iteration % 2 == 0) currentPercent += 0.5\n      currentPriceNew = currentPriceNew - (currentPriceNew * currentPercent\/100)\n      res = savingperMonth * iteration - currentPriceNew\n    }\n\n    Array(iteration, Math.round(res).toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334101,"user_id":null,"body":"object BuyCar {\n  def nb_months(startPriceOld: Int,\n               startPriceNew: Int,\n               savingperMonth: Int,\n               percentLossByMonth: Double): Array[Int] = {\n    var monthPass :Int =0;\n    var oldPrice: Double = startPriceOld;\n    var newPrice: Double = startPriceNew;\n    var addPercent = percentLossByMonth*0.01;\n    while ((oldPrice+savingperMonth*monthPass)<newPrice){\n      monthPass = monthPass+1;\n      if (monthPass%2==0){\n        addPercent = addPercent+0.005\n      }\n      oldPrice = oldPrice*(1-addPercent);\n      newPrice = newPrice*(1-addPercent); \n    }\n    return Array(monthPass,((oldPrice+savingperMonth*monthPass)-newPrice).round.toInt)\n    \/\/ your code\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334102,"user_id":1285,"body":"object BuyCar {\n\n  def nb_months(startPriceOld: Int,\n               startPriceNew: Int,\n               savingperMonth: Int,\n               percentLossByMonth: Double): Array[Int] = {\n    def inner(months: Int,\n              priceOld: Double,\n              priceNew: Double,\n              savings: Double,\n              percentLoss: Double): Array[Int] = {\n      if (savings + priceOld >= priceNew)\n        Array(months, Math.round(savings + priceOld - priceNew).toInt)\n      else if (months % 2 == 1)\n        inner(months + 1,\n              priceOld * (1 - (percentLoss + .5) \/ 100),\n              priceNew * (1 - (percentLoss + .5) \/ 100),\n              savings + savingperMonth,\n              percentLoss + .5)\n      else\n        inner(months + 1,\n              priceOld * (1 - percentLoss \/ 100),\n              priceNew * (1 - percentLoss \/ 100),\n              savings + savingperMonth,\n              percentLoss)\n    }\n    inner(0, startPriceOld, startPriceNew, 0, percentLossByMonth)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"554ca54ffa7d91b236000023":[{"id":334103,"user_id":573,"body":"object EnoughIsEnough {\n\n  def delete_nth(elements: Seq[Int], max: Int): List[Int] =\n    elements\n      .foldLeft(List[Int]()) {\n        case (xs, x) if xs.count(_ == x) < max => x :: xs\n        case (xs, _)                           => xs\n      }.reverse\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334104,"user_id":null,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = {    \n    elements.foldLeft((List[Int](), Map[Int, Int]())) {\n      case ((list, map), element) if map.getOrElse(element, 0) == maxOccurrences => (list, map)\n      case ((list, map), element) => (list :+ element, map + (element -> (map.getOrElse(element, 0) + 1)))\n    }._1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334105,"user_id":null,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] =\n    elements.zipWithIndex\n      .groupBy(_._1)\n      .values\n      .flatMap(_.take(maxOccurrences))\n      .toList\n      .sortBy(_._2)\n      .map(_._1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334106,"user_id":527,"body":"import cats.data.State\nimport cats.implicits._\n\nobject EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = {\n    elements\n      .filterA(x => for {\n          f <- State.inspect[Map[Int, Int], Int](_(x))\n          _ <- State.modify[Map[Int, Int]](_.updated(x, f + 1))\n        } yield f < maxOccurrences\n      )\n      .runA(Map.empty[Int, Int].withDefaultValue(0)).value\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334107,"user_id":636,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = \n    elements.foldLeft(List[Int]())((t,c) => if ((t count (_== c)) < maxOccurrences) c :: t else t).reverse\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334108,"user_id":null,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = {\n    val list = elements.zipWithIndex\n    val toRemove =   elements.distinct.flatMap{ occ =>\n        list.filter(_._1==occ).drop(maxOccurrences)\n      }\n    list.filter(!toRemove.contains(_)).map(_._1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334109,"user_id":null,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int, acc: List[Int] = List()): List[Int] = {\n     if (elements.length == 0) return acc\n     else if (acc.count(_ == elements.head) == maxOccurrences) return delete_nth(elements.tail, maxOccurrences, acc)\n     return delete_nth(elements.tail, maxOccurrences, acc.concat(Array(elements.head)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334110,"user_id":null,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = {\n    var res: List[Int] = List()\n    for (e <- elements) {\n      if (res.count(_ == e) < maxOccurrences) {\n        res = res.appended(e)\n      }\n    }\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334111,"user_id":null,"body":"object EnoughIsEnough {\n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = {\n    val map = scala.collection.mutable.Map[Int, Int]()\n\n    elements.filter(n => {\n      if (map.contains(n)) {\n        if (map(n) < maxOccurrences) {\n          map(n) += 1\n          true\n        } else {\n          false\n        }\n      } else if (maxOccurrences > 0) {\n        map(n) = 1\n        true\n      } else {\n        false\n      }\n    })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334112,"user_id":null,"body":"object EnoughIsEnough {\n  \n  def delete_nth(elements: Seq[Int], maxOccurrences: Int): List[Int] = {\n     \n    def go(elements: Seq[Int], maxOccurrences: Int, counts: Map[Int, Int]): List[Int] = {\n       elements match {\n        case head:: tail => {\n          val count = counts.getOrElse(head, 0)\n          if (count < maxOccurrences) {\n            head :: go(tail, maxOccurrences, counts + (head -> (count + 1)))\n          } else {\n            go(tail, maxOccurrences, counts)\n          }\n        }\n        case _ => elements\n      }\n    }\n\n    go(elements, maxOccurrences, Map.empty[Int, Int])\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"554e4a2f232cdd87d9000038":[{"id":334113,"user_id":573,"body":"object DnaStrand {\n\n  def dna_strand(dna: String) =\n    dna.map { case 'A' => 'T' case 'T' => 'A' case 'G' => 'C' case 'C' => 'G' }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334114,"user_id":null,"body":"object DnaStrand {\n\n  \n  \n  def dna_strand(dna: String): String = {\n    \/\/ your code here\n    dna.map(x => x match {\n      case 'T' => 'A'\n      case 'A' => 'T'\n      case 'C' => 'G'\n      case 'G' => 'C'\n    })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334115,"user_id":null,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n    val complimentaryMap = Map(\n      'A' -> 'T',\n      'T' -> 'A',\n      'G' -> 'C',\n      'C' -> 'G'\n    )\n    dna.toList.map(x => complimentaryMap(x)).mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334116,"user_id":null,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n    dna.split(\"\").map{(x) => \n      x match{\n        case \"A\" => \"T\"\n        case \"T\" => \"A\"\n        case \"C\" => \"G\"\n        case \"G\" => \"C\"\n      }\n    }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334117,"user_id":null,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n\n  dna.split(\"\").map(x => x match {\n    case \"A\" => \"T\"\n    case \"C\" => \"G\"\n    case \"T\" => \"A\"\n    case \"G\" => \"C\"\n  }).mkString(\"\")\n\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334118,"user_id":null,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n    dna.map(Seq(('A', 'T'), ('C', 'G'), ('T', 'A'), ('G', 'C')).toMap)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334119,"user_id":null,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n    \/\/ your code here\n    dna.replace(\"A\", \"B\").replace(\"T\", \"A\").replace(\"B\", \"T\").replace(\"C\", \"D\").replace(\"G\", \"C\").replace(\"D\", \"G\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334120,"user_id":null,"body":"object DnaStrand {\n\n  val compliments: Map[String, String] = Map(\n      \"A\" -> \"T\",\n      \"T\" -> \"A\",\n      \"C\" -> \"G\",\n      \"G\" -> \"C\"\n    )\n  \n  def dna_strand(dna: String): String = {\n    dna.split(\"\").map(compliments(_)).mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334121,"user_id":null,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n   dna.map(x=> \n          x match\n          case 'A' => 'T'\n           case 'C' => 'G'\n           case 'G' => 'C'\n           case 'T' => 'A'\n          )\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334122,"user_id":1228,"body":"object DnaStrand {\n\n  def dna_strand(dna: String): String = {\n    val comp = Map('A' -> 'T', 'T' ->'A', 'C' -> 'G', 'G' -> 'C')  \n    dna.map(comp(_))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"554f76dca89983cc400000bb":[{"id":334123,"user_id":null,"body":"object Dioph {\n\n def sol_equa(n: Long): String = (1L to math.sqrt(n).toLong)\n    .filter(a => n % a == 0 && (n\/a + a) % 2 == 0 && (n\/a - a) % 4 == 0)\n    .map(a => (a, n \/ a))\n    .map{case (a, b) => ((a + b) \/ 2, (b - a) \/ 4)}\n    .map{case (x, y) => \"(\" + x + \", \" + y + \")\"}\n    .mkString(\"[\", \", \", \"]\")\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:35:30"},{"id":334124,"user_id":null,"body":"object Dioph {\n\n  def sol_equa(n: Long): String = (1L to math.sqrt(n).toLong)\n    .filter(a => n % a == 0 && (n\/a + a) % 2 == 0 && (n\/a - a) % 4 == 0)\n    .map(i => f\"(${(n\/i + i) \/ 2}, ${(n\/i - i) \/ 4})\").mkString(\"[\", \", \", \"]\")\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:35:38"},{"id":334125,"user_id":53,"body":"object Dioph {\n\n  def sol_equa(n: Long): String = {\n    (1 to scala.math.sqrt(n).toInt)\n      .filter(i => (n % i) == 0 && (n \/ i - i) % 4 == 0)\n      .map(i => ((n \/ i + i) \/ 2, (n \/ i - i) \/ 4))\n      .map(p => s\"(${p._1}, ${p._2})\")\n      .mkString(\"[\", \", \", \"]\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334126,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Dioph {\n\n  def sol_equa(n: Long): String = {\n    @tailrec\n    def calc(acc: Seq[(Long, Long)], n1: Long): Seq[(Long, Long)] = n1 match {\n      case d if n < d * d => acc\n      case v if (n - v * v) % (4 * v) == 0 =>\n        val y = (n - v * v) \/ (4 * v)\n        calc(acc :+ (2 * y + v, y), v + 1)\n      case _ => calc(acc, n1 + 1)\n    }\n\n    calc(Seq(), 1).map(t => s\"(${t._1}, ${t._2})\").mkString(\"[\", \", \", \"]\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334127,"user_id":null,"body":"object Dioph {\n  import math._\n    def sol_equa(n: Long): String = {\n    (for {\n      i <- 1L to sqrt(n).toLong\n      if n % i == 0\n      j = n \/ i\n      if (i + j) % 2 == 0\n      if (i - j) % 4 == 0\n    } yield s\"(${(i + j) \/ 2}, ${(j - i) \/ 4})\").mkString(\"[\", \", \", \"]\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334128,"user_id":null,"body":"object Dioph {\n  def sol_equa(n: Long): String = {\n    \"[\" + (for {\n      a <- 1L to math.sqrt(n).toLong\n      if n % a == 0\n      b = n \/ a\n      if (a+b) % 2 == 0\n      if (a-b) % 4 == 0\n    } yield s\"(${(a+b)\/2}, ${(b-a)\/4})\").mkString(\", \") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334129,"user_id":null,"body":"import scala.math.sqrt\nimport scala.collection.mutable.Seq\n\nobject Dioph {\n\n  def sol_equa(n: Long): String = {\n    var result = Seq[String]()\n    for (i <- 1 to sqrt(n).floor.toInt) {\n      if (n % i == 0) {\n        val j = n \/ i\n        val x = (i + j) \/ 2\n        val y = (j - i) \/ 4\n        if (x.toLong == x && y.toLong == y && (x - 2*y)*(x + 2*y) == n) result :+= f\"($x, $y)\"\n      }\n    }\n    f\"[${result.mkString(\", \")}]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334130,"user_id":null,"body":"object Dioph {\n  def sol_equa(n: Long): String = {\n    factorPairs(n).map(f => (f._1 + f._2, f._1 - f._2)).filter(f => f._1 % 2 == 0 && f._2 % 4 == 0).sortBy(_._1)(Ordering[Long].reverse)\n      .map(f => \"(%d, %d)\".format(f._1 \/ 2, f._2 \/ 4)).mkString(\"[\", \", \", \"]\")\n  }\n\n  def factorPairs(n: Long): Seq[(Long, Long)] = {\n    val primeFactors = primeFactorsOf(n)\n    val combos = (1 to primeFactors.length).flatMap(primeFactors.combinations)\n    combos.map(_.product).map(c => (Math.max(n \/ c, c), Math.min(n \/ c, c))).distinct\n  }\n\n  @scala.annotation.tailrec\n  def primeFactorsOf(n: Long, c: Long = 2, res: Seq[Long] = Seq.empty): Seq[Long] = {\n    if (n < 2) res\n    else if (n % c == 0) primeFactorsOf(n \/ c, c, c +: res)\n    else primeFactorsOf(n, c + 1, res)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334131,"user_id":null,"body":"object Dioph {\n  def divisors(n: Long): List[Long] = {\n    val r = collection.mutable.ListBuffer[Long]()\n    var i = 2L\n    var d = n\n    while (i <= d && d > 1) {\n      if (d % i == 0) {\n        r += i\n        d \/= i\n        i = 2L\n      } else i += 1\n    }\n\n    r.toList\n  }\n\n  def sol_equa(n: Long): String = {\n    val div = divisors(n)\n    (1 to div.length).flatMap(div.combinations)\n      .map(_.product)\n      .toList\n      .flatMap { p =>\n        val pc = n \/ p\n        val tp = if (pc > p) (pc, p) else (p, pc)\n        val x2 = tp._1 + tp._2\n        if (x2 % 2 == 1) None\n        else {\n          val x = x2 \/ 2\n          val y2 = tp._1 - x\n          if (y2 % 2 == 1) None\n          else Some((x, y2 \/ 2))\n        }\n      }\n      .distinct\n      .sortBy(-_._1)\n      .map(t => s\"(${t._1}, ${t._2})\")\n      .mkString(\"[\", \", \", \"]\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"},{"id":334132,"user_id":null,"body":"object Dioph {\n  def divisors(n: Long): Map[Long, Long] = {\n    val dn = n.toDouble\n    Seq.range(1L, Math.sqrt(n).ceil.toLong + 1).foldLeft[Map[Long, Long]](Map()){\n      (acc, m) => {\n        val r = dn \/ m\n        if (r.isWhole) acc + (m -> r.toLong) else acc\n      }\n    }\n  }\n\n  def sol_equa(n: Long): String ={\n    val d = divisors(n).toSeq\n    val r = d.map{case (n, m) => ((m - n) \/ 2 + n, (m - n) \/ 4)}\n    \"[\" + r\n      .filter(f => (f._1 * f._1 - 4 * f._2 * f._2) == n)\n      .sortBy(- _._1)\n      .map(c => s\"(${c._1}, ${c._2})\")\n      .mkString(\", \") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:30:02"}],"555086d53eac039a2a000083":[{"id":334133,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    (flower1 + flower2) % 2 == 1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334134,"user_id":527,"body":"object Love {\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    flower1 % 2 != flower2 % 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334135,"user_id":null,"body":"object Love{\n  def lovefunc(a: Int, b: Int): Boolean = (a + b) % 2 == 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334136,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    (isEven(flower1) && isOdd(flower2)) || (isEven(flower2) && isOdd(flower1))\n  }\n  \n  def isEven(x: Int): Boolean = x % 2 == 0\n  def isOdd(x: Int): Boolean = !isEven(x)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334137,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    isOdd(flower1) && !isOdd(flower2) || isOdd(flower2) && !isOdd(flower1)\n  }\n  def isOdd(num: Int): Boolean = num % 2 == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334138,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = (flower1,flower2) match  {\n\n   case(0,0) => false\n   case(flower1,flower2) if((flower1+flower2) % 2 != 0) => true\n   case(flower1,flower2) if((flower1+flower2) % 2 == 0) => false\n     \n\n   \n}\n  \n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334139,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    val a= flower1%2\n    val b= flower2%2\n    \/\/ moment of truth\n    val truth = (a==b) \/\/false\n    if (truth == true) return(!truth) \n    else return(!truth)\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334140,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    return (flower1 + flower2) % 2 == 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334141,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = (flower1 % 2 ^ flower2 % 2) == 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334142,"user_id":null,"body":"object Love{\n  def lovefunc(flower1: Int, flower2: Int): Boolean = {\n    val result = if ((flower1+flower2)%2 == 0) false else true\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5552101f47fc5178b1000050":[{"id":334143,"user_id":573,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int =\n    n.toString.zipWithIndex.map { case (d, i) => math.pow(d.asDigit, i+p) }.sum \/ n match {\n      case r if r.isWhole => r.toInt\n      case _              => -1\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334144,"user_id":null,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n     val r : Int = n.toString.map(_.asDigit).zipWithIndex.map(x => Math.pow(x._1, x._2 + p).toInt).sum\n     if (r % n == 0) r \/ n else -1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334145,"user_id":null,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n    def pow(seq: IndexedSeq[Int], p: Int, sum: Int) : Int = {\n      if (seq.isEmpty) sum\n      else pow(seq.tail, p + 1, sum + Math.pow(seq.head, p).toInt)\n    }\n    val sum = pow(n.toString.map(_.asDigit), p, 0)\n    if (sum % n == 0) sum \/ n\n    else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334146,"user_id":null,"body":"object DigPow {\n  def dig_pow(n: Int, p: Int): Int = {\n    def powSum(n: Int, p: Int): Int =\n      n.toString.split(\"\").map(_.toInt).zipWithIndex.map{case (x, i) => math.pow(x, p+i).toInt}.sum\n\n    val sum = powSum(n, p)\n    if (sum % n == 0) sum \/ n\n    else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334147,"user_id":492,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n    var s: Int = 0\n    val nstr: String = n.toString\n    for (i <- 0 until nstr.length) {\n      s += Math.pow((nstr.charAt(i) - '0').toInt, p + i).toInt\n    }\n    if (s % n == 0) s \/ n else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334148,"user_id":null,"body":"object DigPow {\n  import scala.math._\n\n  def dig_pow(n: Int, p: Int): Int = {\n    val numbers = n.toString.split(\"\").map(_.toInt)\n    val pairs = numbers.zip(p to (numbers.length + p))\n    val res = pairs.map{case(x,y) => pow(x,y)}.sum\n    if(res%n == 0) res.toInt\/n else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334149,"user_id":null,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n    val x = n.toString.map(_.asDigit).zip(LazyList from p).map(x => math.pow(x._1,x._2)).sum.toInt\n    x % n match {\n      case 0 => x\/n\n      case _ => -1\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334150,"user_id":null,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n    var powCounter = p\n    val N = n.toString.toList.map { x =>\n      {\n        powCounter += 1\n        math.pow(x.toString.toInt, powCounter - 1)\n      }\n    }\n    if (N.sum % n == 0)\n      (N.sum \/ n).toInt\n    else\n      -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334151,"user_id":null,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n    def power(x: Int, n: Int): Int = {\n      if (n == 0) 1\n      else x * power(x, n - 1)\n    }\n    val lstn = n.toString.toList\n    val exp = LazyList.from(p, 1)\n    val nAndExp = lstn.zip(exp)\n    val products = nAndExp.map{\n      case (n, e)  => power(n.asDigit, e)\n    }\n    val sum = products.sum\n    val check = sum \/ n\n    if (sum == check * n) check else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334152,"user_id":null,"body":"object DigPow {\n\n  def dig_pow(n: Int, p: Int): Int = {\n    val sum:Int = n.toString.map(_.asDigit).zipWithIndex.map {\n      case(number, index) => \n      scala.math.pow(number, p + index)\n    }.sum.toInt\n    \n    if(sum%n == 0) {\n      sum\/n\n    } else{\n       -1\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"555624b601231dc7a400017a":[{"id":334153,"user_id":null,"body":"object Kata {\n  def josephus_survivor(n: Int, k: Int): Int = {\n    if (n == 1) return 1\n    return ( josephus_survivor(n-1, k) + k - 1 ) % n + 1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:50:28"},{"id":334154,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n  def josephus_survivor(n: Int, k: Int): Int = eliminate(1 to n, k)\n\n  @tailrec\n  def eliminate(people: Seq[Int], k: Int): Int = people.splitAt(k % people.size) match {\n    case (Nil, Seq(x)) => x\n    case (front, back) => eliminate((back :++ front).init, k)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:50:39"},{"id":334155,"user_id":573,"body":"object Kata {\n\n  def josephus_survivor(n: Int, k: Int): Int =\n    (1 to n).foldLeft(0)((x, y) => (x+k) % y) + 1\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:50:47"},{"id":334156,"user_id":null,"body":"object Kata {\n  def josephus_survivor(n: Int, k: Int): Int = {\n    (1 to n).reduceLeft { (prevRes, currIndex) =>\n      (prevRes + k - 1) % currIndex + 1\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":334157,"user_id":645,"body":"object Kata {\n  def josephus_survivor(n: Int, k: Int): Int = if (n == 1) 1 else (josephus_survivor(n - 1, k) + k - 1) % n + 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":334158,"user_id":null,"body":"object Kata {\n  import scala.annotation.tailrec\n\n  def josephus_survivor(n: Int, step: Int): Int = {\n    @tailrec\n    def helper(size: Int, k: Int, arr: Array[Int]): Int = {\n      if (size == 1)\n        arr.head\n      else {\n        val nextIndex = (k + step - 1) % (size - 1)\n        helper(size - 1,nextIndex, arr.filter(_ != arr(k)))\n      }\n    }\n\n    helper(n ,(step - 1) % n, (1 to n).toArray)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":334159,"user_id":null,"body":"object Kata {\n    def josephus_survivor(n: Int, k: Int): Int = {\n    if (n <= 1) 1\n    else {\n      (josephus_survivor(n - 1, k) + k - 1) % n + 1\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":334160,"user_id":null,"body":"object Kata {\n  def josephus_survivor(n: Int, k: Int): Int = {\n    def loop(i: Int, pos: Int): Int =\n      if (i >= n) pos\n      else loop(i + 1, (pos + k) % (i + 1))\n    loop(1, 0) + 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":334161,"user_id":null,"body":"import scala.collection.mutable.ListBuffer;\n\nobject Kata {\n  def josephus_survivor(n: Int, k: Int): Int = {\n    var list = ListBuffer.range(1, n+1)\n    var i = 0\n    println(list)\n    while (list.size > 1) {\n      i = (i+k-1)%list.size;\n      list.remove(i)\n      i = i%list.size\n    }\n    list(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":334162,"user_id":null,"body":"object Kata {\n  def josephus_survivor(n: Int, k: Int): Int = {\n    var people = (1 to n).toIndexedSeq\n    var t = 0\n    while (people.length > 1) {\n      t = (t + k - 1) % people.length\n      people = people.patch(t, Nil, 1)\n    }\n\/\/     while (people.length >= k && people.length > 1) {\n\/\/       people = people.drop(k) :++ people.take(k - 1)\n\/\/     }\n\/\/     while (people.length > 1) {\n\/\/       for (m <- 0 until k - 1) people = people.tail :+ people.head\n\/\/       people = people.tail\n\/\/     }\n    people.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"}],"555eded1ad94b00403000071":[{"id":334163,"user_id":null,"body":"object Sol {\n\n  def series_sum(n: Int): String = {\n    (0 until n).foldLeft(0.0)((acc, x) => acc + 1.0 \/ (1.0 + (x * 3.0))).formatted(\"%1.2f\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334164,"user_id":573,"body":"object Sol {\n\n  def series_sum(n: Int): String =\n    f\"${(0 until n).map(i => 1d \/ (3 * i + 1)).sum}%.2f\"\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334165,"user_id":null,"body":"object Sol {\n\n  def series_sum(n: Int): String = {\n    val v = (1 to 3 * n by 3).map(1.0 \/ _).sum\n    f\"$v%1.2f\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334166,"user_id":null,"body":"object Sol {\n  \n  def series_sum(n: Int): String = \"%.2f\".format(rec(n))\n\n  def rec(n: Int): Double = {\n    if (n == 0) {\n      return 0.0\n    }\n    1.0 \/ (3.0 * (n - 1) + 1) + rec(n - 1)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334167,"user_id":null,"body":"object Sol {\n\n  def series_sum(n: Int): String = {\n    val result = (0 until n)\n      .foldLeft(0.0)((result, index) => result + 1.0 \/ (1 + index * 3))\n    f\"$result%1.2f\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334168,"user_id":null,"body":"object Sol {\n  def series_sum(n: Int): String = Iterator.from(1, 3).take(n).map(1f \/ _).sum.formatted(\"%.2f\")\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334169,"user_id":null,"body":"object Sol {\n\n  def series_sum(n: Int): String = {\n    val list = List.range(1, n + 1)\n    val value = list.map(i => 1f \/ (1 + list.indexOf(i)*3)).sum\n    return BigDecimal(value).setScale(2, BigDecimal.RoundingMode.HALF_UP).toString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334170,"user_id":null,"body":"object Sol {\n\n  import java.text.DecimalFormat;\n  val twoDForm = new DecimalFormat(\"0.00\");\n\n  def series_sum(n: Int): String = {\n    val rd = Stream.from(0).map(i => 1.0 \/ (1 + i * 3)).take(n).sum\n    twoDForm.format(rd)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334171,"user_id":null,"body":"object Sol {\n\n  def series_sum(n: Int): String = {\n    def go(n: Int, den: Int): Double = if (n <= 0) 0.0 else 1.0\/den + go(n-1,den+3)\n    val retx100 = (go(n,1) * 100).round\n    (retx100 \/ 100).toString + \".\" + ((retx100 % 100) \/ 10) + (retx100 % 10).toString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334172,"user_id":null,"body":"object Sol {\n\n  def series_sum(n: Int): String = {\n    \"%.2f\".format((0 until n).map(_.toDouble * 3.0 + 1.0).map(1.0 \/ _).sum)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55685cd7ad70877c23000102":[{"id":334173,"user_id":527,"body":"object Negative {\n\n  def make_negative(n: Int): Int = -n.abs\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334174,"user_id":null,"body":"object Negative {\n\n  def make_negative(n: Int): Int = if (n <=0 ) n else -n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334175,"user_id":573,"body":"object Negative {\n\n  def make_negative(n: Int): Int = -math.abs(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334176,"user_id":null,"body":"object Negative {\n\n  def make_negative(n: Int): Int = {\n    return if (n<0) n else -n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334177,"user_id":null,"body":"object Negative {\n\n  def make_negative(n: Int): Int = if(n.toString.contains('-')) n else n * -1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334178,"user_id":null,"body":"object Negative extends App{\n\n  def make_negative(n: Int): Int = {\n    if(n < 0){\n      return n\n    }\n    else{\n      val m: Int = n * -1\n      return m\n    }\n  }\n  println(make_negative(1))\n  println(make_negative(-5))\n  println(make_negative(0))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334179,"user_id":null,"body":"object Negative {\n\n  def make_negative(n: Int): Int = {\n      if(n < 0)\n          n\n      else\n          0-n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334180,"user_id":null,"body":"object Negative {\n\n  def make_negative (n: Int): Int = ((~(n) >> 31) * n) + ((~(n >> 31) + 1) * n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334181,"user_id":null,"body":"object Negative {\n\n  def make_negative(n: Int): Int = if (n > 0) ~n + 1 else n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334182,"user_id":48,"body":"object Negative {\n\n  def make_negative(x: Int): Int = -math.abs(x)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"556deca17c58da83c00002db":[{"id":334183,"user_id":574,"body":"object Kata {\n  def tribonacci[T : Numeric](sig: Seq[T], n: Int): Seq[T] =\n    if (n <= 3) sig take n else sig.head +: tribonacci (sig.tail :+ sig.sum, n-1)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334184,"user_id":null,"body":"object Kata {\n  def tribonacci[T : Numeric](signature: Seq[T], n: Int): Seq[T] = {\n    bonacci(signature).take(n).toList\n  }\n  \n  def bonacci[T : Numeric](signature: Seq[T]): Stream[T] = \n    signature.head #:: bonacci(signature.tail ::: List(signature.sum))\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334185,"user_id":null,"body":"object Kata {\n  def tribonacci[T: Numeric](signature: Seq[T], n: Int): Seq[T] = {\n    if (n <= 3) signature.take(n)\n    else {\n      val prev = tribonacci(signature, n - 1)\n      prev ::: List(prev.reverse.take(3).sum)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334186,"user_id":null,"body":"object Kata {\n  def tribonacci[T : Numeric](signature: Seq[T], n: Int): Seq[T] = {\n    if (n < 4) signature take n else {\n      val previous = this.tribonacci(signature, n-1)\n      previous :+ previous.reverse.take(3).sum\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334187,"user_id":null,"body":"object Kata {\n  def tribonacci[T : Numeric](signature: Seq[T], n: Int): Seq[T] = {\n    def recur(res: Seq[T], acc: Int): Seq[T] = acc match {\n      case 0 => res\n      case _ => res.head :: recur(res.tail :+ res.sum, acc - 1)\n    }\n    recur(signature, n)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334188,"user_id":null,"body":"import scala.annotation.tailrec\nobject Kata {\n  def tribonacci[T : Numeric](signature: Seq[T], n: Int): Seq[T] = {\n    @tailrec\n    def tribonacciTail[T : Numeric](signature: Seq[T], n: Int): Seq[T] = {\n        val result: Seq[T] = signature :+ signature.takeRight(3).sum\n        if (result.size >= n) result.take(n) else tribonacciTail(result, n)\n    }\n    tribonacciTail(signature, n)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334189,"user_id":null,"body":"object Kata {\n \ndef tribonacci[T: Numeric](signature: Seq[T], n: Int): Seq[T] = n match {\ncase   2|1|0  => signature.takeRight(n)\n    case 3 => signature\n    case _ => tribonacci(signature :+ signature.takeRight(3).sum,n-1)\n\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334190,"user_id":null,"body":"object Kata {\n  def tribonacci[T : Numeric](tribs: Seq[T], n: Int): Seq[T] = {\n    if (List(0, 1, 2, 3, tribs.size).contains(n))\n      tribs.take(n)\n    else\n      tribonacci(tribs ++ List(tribs.takeRight(3).sum), n)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334191,"user_id":null,"body":"object Kata {\n  def tribonacci[T : Numeric](signature: Seq[T], n: Int): Seq[T] = {\n    LazyList.unfold(signature)(v => Some((v(0), List(v(1), v(2), v.sum)))).take(n).toList\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334192,"user_id":null,"body":"object Kata {\n  def tribonacci[T : Numeric](signature: Seq[T], n: Int): Seq[T] = \n    (1 to n - 3).foldLeft(signature.take(n))((res, _) => res :+ res.takeRight(3).sum)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5583d268479559400d000064":[{"id":334193,"user_id":751,"body":"object Kata {\n    def binaryToString(input: String) =\n        input.grouped(8).map(Integer.parseInt(_,2).toChar).mkString\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334194,"user_id":573,"body":"object Kata {\n\n    def binaryToString(binary: String): String =\n      binary.grouped(8).map(Integer.parseInt(_, 2).toChar).mkString\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334195,"user_id":527,"body":"object Kata {\n  def binaryToString(input: String): String = {\n    input.grouped(8).map(Integer.parseInt(_, 2).toChar).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334196,"user_id":null,"body":"object Kata {\n    def binaryToString(input: String): String =\n      input.grouped(8)\n           .filter(_.size == 8)\n           .foldLeft(\"\") {\n              case (acc, bin) => acc + Integer.parseInt(bin, 2).toChar \n            }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334197,"user_id":null,"body":"object Kata {\n  def binaryToString(input: String): String = {\n    input.sliding(8, 8).map(Integer.valueOf(_, 2)).map(_.toChar).mkString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334198,"user_id":null,"body":"object Kata {\n\n  def decode(str: String): Char = {\n    str.zipWithIndex.foldLeft[Char](0) { case (acc, (c, i)) =>\n      val newDigit: Char =\n        if (c.asDigit == 0) 0 else (1 << (str.length - 1 - i)).toChar\n      (acc + newDigit).toChar\n    }\n  }\n\n  def binaryToString(input: String): String = {\n    input.grouped(8).map(decode).mkString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334199,"user_id":null,"body":"object Kata {\n     def binaryToString(input: String): String = {\n       def convert(str : String) : Char = {\n         val code = str.reverse\n         var result = 0\n         for(i <- code.indices){\n           result += (code(i)-48)*(math.pow(2,i)).toInt\n         }\n         result.toChar\n       }\n       input.sliding(8,8).map(convert).mkString       \n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334200,"user_id":null,"body":"object Kata {\n  def binaryToString(input: String): String = {\n    input.grouped(8).foldLeft(\"\")((acc, x) => acc + Integer.parseInt(x, 2).toChar)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334201,"user_id":null,"body":"object Kata {\n    def binaryToString(input: String): String = {\n      input\n      .grouped(8)\n      .toList\n      .map(\n        _.reverse\n        .zipWithIndex\n        .reverse\n      )\n      .map(\n        _.filter(\n          _._1\n          .toString\n          .toInt > 0 \n        )\n      )\n      .map(\n        _.map(ele => \n              Math.pow(2, ele._2)\n             )\n        .sum\n        .toInt\n        .toChar\n        .toString\n      )\n      .mkString\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334202,"user_id":null,"body":"object Kata {\n    def binaryToString(input: String): String = {\n        if (input == \"\") {\n          input\n        }\n        else {\n          input.grouped(8).toList.map(x => Integer.parseInt(x, 2).toChar).mkString(\"\")\n        }\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"558fc85d8fd1938afb000014":[{"id":334203,"user_id":573,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int =\n    numbers.sorted.take(2).sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334204,"user_id":573,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int =\n    numbers.drop(2).foldLeft(numbers.take(2)) { (acc, x) => if (x < acc.max) List(x, acc.min) else acc }.sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334205,"user_id":null,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int = (numbers.sorted take 2).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334206,"user_id":null,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int = \n    numbers.min + numbers.filter(n => n != numbers.min).min\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334207,"user_id":null,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int = {\n    val (first, second) = numbers.foldLeft(Int.MaxValue -> Int.MaxValue) {\n      case ((f, s), x) if x >= 0 => \n       val f1 = f min x\n       val s1 = if (f1 != f) { s min f } else { s min x }\n       \n       (f1, s1)\n        \n      case (acc, _) => acc\n    }\n    \n    first + second\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334208,"user_id":null,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int = {\n     val res =  numbers.sorted\n      res.head + res(1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334209,"user_id":null,"body":"object LowIntSum {\n\tdef sum_two_smallest_numbers(numbers: Seq[Int]): Int = {\n\t\tval sort = numbers.sortWith(_ < _)\n\t\tsort.head + sort(1)\n\t}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334210,"user_id":null,"body":"object LowIntSum:\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int =\n    numbers.sorted.take(2).sum","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334211,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject LowIntSum {\n  \n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int = {\n    @tailrec def inner(first: Int, sec: Int, remaining: List[Int]): Int = {\n      if (remaining.isEmpty) return first + sec\n      val tuple = if (remaining.head < sec) {\n        if (remaining.head < first) (remaining(0), first)\n        else (first, remaining(0))\n      } else (first, sec)\n      inner(tuple._1, tuple._2, remaining.tail)\n    }\n    val firstNumbers = numbers.take(2).sorted\n    inner(firstNumbers.head, firstNumbers.last, numbers.drop(2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334212,"user_id":null,"body":"object LowIntSum {\n\n  def sum_two_smallest_numbers(numbers: Seq[Int]): Int = {\n    val res = numbers.filter(_ > numbers.min)\n    numbers.min + res.min\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55908aad6620c066bc00002a":[{"id":334213,"user_id":573,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean =\n    str.count(_.toLower == 'x') == str.count(_.toLower == 'o')\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334214,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean =\n    str.foldLeft(0) {\n      (acc, cur) => cur match {\n        case 'x' | 'X' => acc + 1\n        case 'o' | 'O' => acc - 1\n        case _ => acc\n      }\n    } == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334215,"user_id":573,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean =\n    str.toLowerCase match { case s => s.count(_ == 'x') == s.count(_ == 'o') }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334216,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = {\n    val res = str.toLowerCase.groupBy(identity).mapValues(_.length)\n    res.getOrElse('x',0) == res.getOrElse('o',0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334217,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = if(str.count(\"oO\".contains(_)) == str.count(\"xX\".contains(_))) true else false\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334218,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = \n    str.toLowerCase.count(_ == 'o') == str.toLowerCase.count(_ == 'x')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334219,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = \n    str.foldLeft(0){\n      (z, i) => i.toLower match {\n        case 'x' => z+1\n        case 'o' => z-1\n        case _ => z\n      }\n    } == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334220,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = {\n    val (xs, os) = str.toLowerCase.filter(\"xo\".contains(_)).partition(_ == 'x')\n    xs.length == os.length\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334221,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = {\n    str.toLowerCase.flatMap {\n      case 'x' => Some(1)\n      case 'o' => Some(-1)\n      case _ => None\n    }.sum == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334222,"user_id":null,"body":"object ExesAndOhs {\n\n  def xo(str: String): Boolean = \n  str.count(Set('x', 'X')) == str.count(Set('o', 'O'))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5592e3bd57b64d00f3000047":[{"id":334223,"user_id":573,"body":"object Cube {\n\n  def find_nb(m: Long, n: Long = 0, v: Long = 0): Long =\n    if (v == m) n-1 else if (v < m) find_nb(m, n+1, v+n*n*n) else -1\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334224,"user_id":null,"body":"object Cube {\n  def getVal(n: Long): Long = (n*(n+1)\/2)*(n*(n+1)\/2)\n  def binarySearch(l: Long, r: Long, v: Long):Long = {\n    \/\/println(l,r)\n    val mid = (l+r)>>1\n    if(l == r-1) l\n    else if(getVal(mid) > v) binarySearch(l,mid,v)\n    else binarySearch(mid,r,v)\n  }\n  def find_nb(m: Long): Long = {\n    val v = binarySearch(0,100000,m)\n    if(getVal(v) == m) v\n    else -1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334225,"user_id":null,"body":"object Cube {\n  def find_nb(m: Long): Int = {\n    @annotation.tailrec\n    def _find_nb(n: Int, acc: Long): Int = {\n      acc match {\n        case `m` => n - 1\n        case gt if ( acc > m ) => -1\n        case _ =>  _find_nb(n + 1, acc + Math.pow(n, 3).toLong)\n        }\n      }\n    _find_nb(1, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334226,"user_id":null,"body":"object Cube {\n\n  import math._\n\n  def find_nb(m: Long): Int =\n    if (m < 0) -1\n    else {\n      \/\/ 1\u00b3 + 2\u00b3 + 3\u00b3 + ... n\u00b3 = (1 + 2 + 3 + ... n)\u00b2\n      val n = sqrt(2 * sqrt(m) + 0.25) - 0.5\n      if (n.toInt == n) n.toInt else -1\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334227,"user_id":null,"body":"import scala.math.{sqrt}\n\nobject Cube {\n\n  def find_nb(m: Long): Int = {\n    val discriminant = 1 + 8 * sqrt(m)\n    val root = (sqrt(discriminant) - 1) \/ 2\n    if (root.toInt == root) root.toInt else -1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334228,"user_id":null,"body":"object Cube {\n\n  def find_nb(m: Long): Int = {\n    var rVol = m\n    var count = 0L\n    while (rVol > 0) {\n      count += 1\n      rVol -= count * count * count\n    }\n    if (rVol < 0) -1 else count.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334229,"user_id":null,"body":"object Cube {\n\n  def loop(m: Long, n: Int=1): Int = m match {\n    case 0          => n-1\n    case k if k < 0 => -1\n    case _          => loop(m - Math.pow(n, 3).toLong, n+1)\n  }\n\n  def find_nb(m: Long): Int = {\n    loop(m)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334230,"user_id":null,"body":"object Cube {\n\n  def find_nb(m: Long, re: Int = 1): Int = \n    m - Math.pow(re,3).toLong match {\n      case 0 =>  re\n      case num if num > 0 => find_nb(num,re+1)\n      case _ => -1\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334231,"user_id":null,"body":"object Cube {\n\n    def find_nb(m: Long): Int = {\n    \n    def cubesVolumeGivingVolumeBiggerOrEqToGiven(n: Int, currentVolume: Long, givenVolume: Long): (Int, Long) =\n      if (currentVolume >= givenVolume) (n - 1, currentVolume.toLong)\n      else cubesVolumeGivingVolumeBiggerOrEqToGiven(n + 1, currentVolume + math.pow(n, 3).toLong, givenVolume)\n\n    val cubesVolumeBiggerOrEqToGiven = cubesVolumeGivingVolumeBiggerOrEqToGiven(1, 0, m)\n\n    if (cubesVolumeBiggerOrEqToGiven._2 == m) cubesVolumeBiggerOrEqToGiven._1\n    else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334232,"user_id":null,"body":"object Cube {\n  def find_nb(m: Long): Int = {\n    @scala.annotation.tailrec\n    def f(acc: Long, l: Int): Int =\n        if (acc == m) l\n        else if (acc > m) -1\n        else f(acc + math.pow(l + 1, 3).toLong, l + 1)\n    f(0, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559536379512a64472000053":[{"id":334233,"user_id":573,"body":"object PlayPass {\n\n  val alphabet = 'a' to 'z'\n\n  def play_pass(str: String, n: Int): String =\n    str\n      .map {\n        case c if c.isLetter => alphabet((alphabet.indexOf(c.toLower) + n) % 26)\n        case c if c.isDigit  => s\"${9 - c.asDigit}\".head\n        case c               => c\n      }\n      .zipWithIndex\n      .map {\n        case (c, i) if i % 2 == 0 => c.toUpper\n        case (c, _)               => c.toLower\n      }\n      .reverse\n      .mkString\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334234,"user_id":null,"body":"object PlayPass {\n\n  def play_pass(s: String, shift: Int): String = {\n    s.toSeq.zipWithIndex.map {\n      case (ch, index) =>\n        if (ch.isLetter) {\n          val shifted = shiftChar(ch, shift)\n          if (index % 2 == 0) shifted.toUpper else shifted.toLower\n        } else if (ch.isDigit) Character.forDigit(9 - Character.getNumericValue(ch)  , 10)\n        else ch\n\n    }.mkString(\"\").reverse\n  }\n\n    private def shiftChar(char: Char, by: Int) = {\n    val isUpper = char.isUpper\n    val shifted = (((char.toLower - 'a' + by) % 26) + 'a').toChar\n    if(isUpper) shifted.toUpper else shifted\n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334235,"user_id":636,"body":"object PlayPass {\n\n  def play_pass(s: String, n: Int): String = {\n\n    import scala.collection.immutable.NumericRange\n    import scala.language.implicitConversions\n\n    implicit class CircleMaker[K](unique: NumericRange[K])  {\n      lazy val circle:LazyList[K] = unique.to(LazyList) #::: circle; circle\n      def mkCircle = circle\n    }\n\n    def mkLookup (start: Char, end: Char) = {\n      val base = (start to end).mkCircle\n      base zip base.drop(n)\n    }\n    implicit def flattner(a: ((Char, Char), (Char, Char))) = List((a._1._1, a._1._2), (a._2._1, a._2._2))\n\n    val aToZLookUp = (mkLookup('a', 'z') zip mkLookup('A', 'Z')).take(52).flatten.toMap\n\n    s.foldLeft(\"\"){\n      case (t,c) if c.isLetter => (if (t.length % 2 == 0) aToZLookUp(c).toUpper else aToZLookUp(c).toLower) + t\n      case (t,c) if c.isDigit => (9 - c.asDigit) + t\n      case (t,c) => c+t\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334236,"user_id":null,"body":"object PlayPass {\n\n  def play_pass(s: String, n: Int): String = {\n    s.map(x => x match {\n      case _ if(x.isLetter) => (((x.toLower.toInt -'a'.toInt + (n % 26)) % 26) + 'a'.toInt).toChar\n      case _ if(x.isDigit) => (9 - x.asDigit).toString.head\n      case _ => x\n    }).zipWithIndex.map(x => if (x._2 % 2 == 0) x._1.toUpper else x._1.toLower).mkString.reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334237,"user_id":null,"body":"object PlayPass {\n\n  def play_pass(s: String, n: Int): String = {\n    s.zipWithIndex.map {\n      case (c, i) if 'A' <= c && c <= 'Z' =>\n        ((c - 'A' + n) % ('Z' - 'A' + 1) + (if (i % 2 == 1) 'a' else 'A')).toChar\n      case (c, _) if '0' <= c && c <= '9' =>\n        (9 - c + 2 * '0').toChar\n      case (c, _) => c\n    }.reverse.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334238,"user_id":null,"body":"object PlayPass {\n\n     \/\/ A=65, Z=90, count=26\n    val dictStart = 65\n    val dictEnd = 90\n    val dictSize = dictEnd - dictStart + 1\n\n\n    def play_pass(s: String, n: Int): String = {\n        s.map {\n            \/\/ 1. shift for N\n            case char if 'A' to 'Z' contains char => (char - dictStart + n) % dictSize + dictStart\n            \/\/ 2. replace by complement to 9\n            case char if '0' to '9' contains char => (9 - char.toString.toInt).toString.head\n            \/\/ 3.\n            case char => char\n        }.map(_.toChar).zipWithIndex.map { case (char: Char, index: Int) =>\n            \/\/ 4. lowercase odd\n            if (index % 2 == 1) char.toLower else char\n        }.reverse.mkString \/\/ 5.\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334239,"user_id":null,"body":"object PlayPass {\n  val letters = \"abcdefghijklmnopqrstuvwxyz\"\n  def shiftLetter(c: Char, n: Int): Char = {\n    val newLetterIdx = (letters.indexOf(c) + n) % 26\n    letters(newLetterIdx)\n  }\n\n  def play_pass(s: String, n: Int): String = {\n    s.toLowerCase.zipWithIndex\n      .map {\n        case (x, i) if x.isLetter && i % 2 == 0 => shiftLetter(x, n).toUpper\n        case (x, i) if x.isLetter && i % 2 == 1 => shiftLetter(x, n).toLower\n        case (x, i) if x.isDigit                => (9 - x.asDigit.toInt).toString.charAt(0)\n        case (x, i)                             => x\n      }\n      .reverse\n      .mkString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334240,"user_id":null,"body":"object PlayPass {\n\n  def play_pass(s: String, n: Int): String = {\n    def isLetter(c: Char) = c >= 'A' && c <= 'Z'\n    def isDigit(c: Char)  = c >= '0' && c <= '9' \n  \n    s\n    .map {\n      case c if isLetter(c) => ((c - 'A' + n) % ('Z' - 'A' + 1) + 'A').toChar\n      case c => c.toChar\n    }\n    .map {\n      case c if isDigit(c) => ('9' - c + '0').toChar\n      case c => c.toChar\n    }\n    .zipWithIndex\n    .map {\n      case (c, i) if i % 2 == 0 && isLetter(c) => c.toString.toUpperCase\n      case (c, i) if i % 2 == 1 && isLetter(c) => c.toString.toLowerCase\n      case (c, i) => c\n    }\n    .mkString\n    .reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334241,"user_id":null,"body":"object PlayPass {\n\n  def play_pass(inputString: String, inputInt: Int): String = {\n    \/\/ Steps 1, 2 & 3\n    val updatedString = inputString.map(c => stepsOneTwoAndThree(c, inputInt));\n\n    \/\/ Step 4\n    var newerString = updatedString.zipWithIndex.map { case (character, index) => if (index % 2 == 0) character else character.toLower }.mkString;\n\n    \/\/ Step 5\n    var finalString = newerString.reverse;\n\n    return finalString;\n  }\n\n  def stepsOneTwoAndThree(inputChar: Char, inputInt: Int): Char = {\n    var returnChar: Char = 0;\n    if (inputChar.isLetter) {\n      var charNum = inputChar.toInt + inputInt;\n      if (charNum > 90) {\n        charNum = (charNum - 90) + 64;\n      }\n      returnChar = charNum.toChar;\n    }\n    else if (inputChar.isDigit) {\n      var numToNine: Int = 57 - inputChar.toInt + 48;\n      returnChar = numToNine.toChar;\n    }\n    else {\n      returnChar = inputChar;\n    }\n    return returnChar;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334242,"user_id":null,"body":"object PlayPass {\n\n    def shiftLetter(n: Int)(ch: Char): Char = if (ch.isLetter) {\n      (if (ch + n <= 'Z') ch + n else 'A' + (ch + n) - 'Z' - 1).toChar\n    } else ch\n\n    def replaceDigits(ch: Char): Char =\n      if (ch.isDigit) ('9' - ch).toString.head else ch\n\n    def play_pass(s: String, n: Int): String = {\n      s.map(shiftLetter(n) _ andThen replaceDigits)\n        .zipWithIndex\n        .map { case (ch, idx) => if(idx % 2 == 0) ch.toUpper else ch.toLower}\n      .reverse\n      .mkString\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559a28007caad2ac4e000083":[{"id":334243,"user_id":null,"body":"object SquaresPerimeter {\n    def perimeter(n: BigInt, x: BigInt = 1, y: BigInt = 1, acc: BigInt = 1): BigInt = \n      if (n == 0) acc * 4 else perimeter(n - 1, y, x + y, acc + y)\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334244,"user_id":null,"body":"object SquaresPerimeter {\n\n    def fib(n: Int) = {\n      type Matrix = Array[Array[BigInt]]\n\n\n      def mul(a: Matrix, b: Matrix): Matrix = {\n        Array(\n        Array(a(0)(0) * b(0)(0) + a(0)(1) * b(1)(0), a(0)(0) * b(0)(1) + a(0)(1) * b(1)(1)),\n        Array(a(1)(0) * b(0)(0) + a(1)(1) * b(1)(0), a(1)(0) * b(0)(1) + a(1)(1) * b(1)(1)))\n      }\n  \n      @scala.annotation.tailrec\n      def pow(a: Matrix, b:Matrix, n: Long): Matrix ={\n        if (n == 0) b\n        else {\n          if (n % 2 == 1) {\n            pow(mul(a,a), mul(b,a), n\/2)\n          } else pow(mul(a,a), b, n\/2)\n        }\n      }\n  \n      val B: Matrix = Array(Array(1,0),Array(0,1))\n      val a: Matrix = Array(Array(1,1),Array(1,0))\n      val b: Matrix = Array(Array(0,1), Array(1,-1))\n      pow(a, B, n)(1)(0)\n  }\n\n  def perimeter(n: BigInt): BigInt = {\n    (fib(n.toInt+3) - 1) * 4\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334245,"user_id":null,"body":"object SquaresPerimeter {\n  def fib(n: Int): BigInt = {\n    def fibTail(n: Int, a: BigInt, b: BigInt): BigInt = n match {\n      case 0 => a\n      case _ => fibTail(n-1, b, a + b)\n    }\n    fibTail(n, 0, 1)\n  }\n\n  def perimeter(n: BigInt): BigInt = 4*(fib(n.toInt+1+2)-fib(2))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334246,"user_id":null,"body":"object SquaresPerimeter {\n\n  def perimeter(n: BigInt): BigInt = Iterator\n    .unfold((BigInt(0), BigInt(0))) { case (a, b) =>\n      val newVal: BigInt = if (b > 0) a + b else 1\n      Some(newVal, (newVal, a))\n    }\n    .take(n.toInt + 1)\n    .sum * 4\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334247,"user_id":null,"body":"object SquaresPerimeter {\n\n    def perimeter(n: BigInt): BigInt = {\n      \n      def fib (cnt: BigInt, low: BigInt=1, high: BigInt=1): BigInt = {\n        if (cnt == 0) high-1 else fib (cnt - 1, high, low + high) }\n      \n      fib(n+1) * 4\n        \n  }\n     \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334248,"user_id":null,"body":"object SquaresPerimeter {\n  def perimeter(n: BigInt): BigInt = {\n    var x1: BigInt = 0\n    var x2: BigInt = 1\n    var tmp: BigInt = 0\n    var acc: BigInt = 1\n\n    (0 to n.toInt-1).foldLeft(BigInt(0)){ (_, _) => tmp=x1; x1=x2; x2=tmp+x2; acc+=x2; acc } * 4\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334249,"user_id":636,"body":"object SquaresPerimeter {\n  \ndef recursiveOptimizedFib(n: BigInt, x: BigInt = 1, y: BigInt = 1, z: BigInt = 1): (BigInt, BigInt, BigInt) = {\n  val (zero, one) = (BigInt(0), BigInt(1))\n  n match {\n    case `zero` | `one` => (x, y, z + 1)\n    case _ => recursiveOptimizedFib(n - 1, y, x + y, z + x + y)\n  }\n}\n\ndef perimeter(n: BigInt): BigInt = {\n  4 * recursiveOptimizedFib(n)._3\n}\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334250,"user_id":null,"body":"object SquaresPerimeter {\n  import scala.annotation.tailrec\n  def perimeter(n: BigInt): BigInt = {\n    @tailrec\n    def fib(n: BigInt, a: BigInt, b:BigInt): BigInt = {\n      n match {\n        case t if t == BigInt(0) => b\n        case _ => fib(n - 1, b, a + b)\n      }\n    }\n    (fib(n + 1, 1, 1) - 1) * BigInt(4)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334251,"user_id":null,"body":" object SquaresPerimeter {\n    def perimeter(n: BigInt): BigInt = {\n      def sumFib(fib : BigInt,a:BigInt,b:BigInt,acc: BigInt): BigInt = {\n        if(fib == 0) acc + BigInt(1)\n        else {\n          sumFib(fib-1,b,a+b,acc+a+b)\n        }\n      }\n      4*sumFib(n,BigInt(0),BigInt(1),BigInt(0))\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334252,"user_id":null,"body":"object SquaresPerimeter {\n  def fib(n : BigInt): (BigInt, BigInt) = {\n    if (n == BigInt(1) || n == BigInt(2)) (BigInt(1), BigInt(1))\n    else if (n % 2 == 0) {\n      val (f1, f2) = fib(n \/ 2)\n      (f1 * f1 + f2 * f2, f2 * (f2 + f1 + f1))\n    } else {\n      val (f1, f2) = fib((n + 1) \/ 2)\n      (f1 * (f2 + f2 - f1), f1 * f1 + f2 * f2)\n    }\n  }\n  def perimeter(n: BigInt): BigInt = 4 * (fib(n + 3)._2 - 1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559b8e46fa060b2c6a0000bf":[{"id":334253,"user_id":492,"body":"object Diagonal {\n  \n  private def chooSE(n: Int, p: Int): BigInt = {\n    var pp = p\n    if (pp > n) return 0\n    if (pp > n - pp) pp = n - pp\n    var N: BigInt = BigInt(n)\n    var ret: BigInt = 1\n    for (i <- 0 until pp) {\n      ret *= N - BigInt(i)\n      ret \/= BigInt(i) + 1\n    }\n    ret\n  }\n  def diagonal(n: Int, p: Int): BigInt = {\n    chooSE(n+1, p+1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334254,"user_id":527,"body":"object Diagonal {\n  \n  def diagonal(n: Int, p: Int): BigInt = {\n    choose(n + 1, p + 1)\n  }\n  \n  def choose(n: Int, k: Int): BigInt = {\n    (1 to k).foldLeft(BigInt(1))((a, i) => a * (n - i + 1) \/ i)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334255,"user_id":492,"body":"object Diagonal {\n  \n  private def chooSE(n: Int, p: Int): BigInt = {\n    var pp = p\n    if (pp > n) return 0\n    if (pp > n - pp) pp = n - pp\n    var N: BigInt = BigInt(n)\n    var ret: BigInt = 1\n    for (i <- 0 until pp) {\n      ret *= N - BigInt(i)\n      ret \/= BigInt(i) + 1\n    }\n    ret\n  }\n  def diagonal(n: Int, p: Int): BigInt = {\n    chooSE(n+1, p+1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334256,"user_id":1285,"body":"object Diagonal {\n  \n  def diagonal(n: Int, p: Int): BigInt = {\n    var i = 1\n    var last = new Array[BigInt](1)\n    last(0) = 1\n    while (i < (n + 2)) {\n      val max = (i + 1) min (p + 2)\n      val arr = new Array[BigInt](max)\n      var j = 0\n      while (j < max) {\n        var sum: BigInt = 0\n        if (j - 1 >= 0 && j - 1 < last.length) sum += last(j - 1)\n        if (j >= 0 && j < last.length) sum += last(j)\n        arr(j) = sum\n        \/\/print(sum + \" \")\n        j += 1\n      }\n      \/\/println(\"\")\n      if (i == n + 1) return arr(p + 1)\n      i += 1\n      last = arr\n    }\n    \n    return BigInt(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334257,"user_id":null,"body":"object Diagonal {\n\n  def diagonal(n: Int, p: Int): BigInt = {\n    if (p == 0) n + 1\n    else {\n      val k = { \n        if (n \/ 2 < p) - 1 * (p - n) -1 \n        else p\n        }\n      \n      (BigInt(1) to n).sliding(k).map(s => s.product).sum\/(BigInt(1) to k).product\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334258,"user_id":null,"body":"object Diagonal {\n\n  def diagonal(n: Int, p: Int): BigInt = {\n    if (p == 0) {\n      n + 1\n    }\n    else {\n      val l = if (n\/2 < p) -1 * (p - n) -1 else p\n      (BigInt(1) to n).sliding(l).map(x => x.product).sum\/(BigInt(1) to l).product\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334259,"user_id":null,"body":"object Diagonal {\n  def binomial(n: Int, k: Int): BigInt = {\n    require(0 <= k && k <= n)\n    @annotation.tailrec \n    def binomtail(nIter: Int, kIter: Int, ac: BigInt): BigInt = {\n      if (kIter > k) ac\n      else binomtail(nIter + 1, kIter + 1, (nIter * ac) \/ kIter)\n    }\n    if (k == 0 || k == n) 1\n    else binomtail(n - k + 1, 1, BigInt(1))\n  }\n  \n  def diagonal(n: Int, p: Int): BigInt = (p to n).map(binomial(_, p)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334260,"user_id":null,"body":"object Diagonal {\n  \n  def diagonal(n: Int, p: Int): BigInt = {\n    (p to n).map(i => binomialCoefficient(i, p)).sum\n  }\n  \n  @scala.annotation.tailrec\n  def binomialCoefficient(n: Int, k: Int): BigInt =\n    if (k < 0 || k > n) {\n      BigInt(0)\n    } else if (k > n \/ 2) {\n      binomialCoefficient(n, n - k)\n    } else {\n      val tup = (0 until k).foldLeft((BigInt(1), BigInt(1)))((t, i) => (t._1 * BigInt(n - i), t._2 * BigInt(k - i)))\n      tup._1 \/ tup._2\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334261,"user_id":53,"body":"object Diagonal {\n  \n  def diagonal(n: Int, p: Int): BigInt = {\n    var result:BigInt = 1;\n    var i:BigInt = 1;\n    while (i <= p+1) {\n      result = result * (n - i + 2) \/ i;\n      i += 1;\n    }\n    return result;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334262,"user_id":null,"body":"object Diagonal {\n  def binomial(n: Int, k: Int, f: BigInt = 1, d: BigInt = 1): BigInt = k match {\n    case _ if k > n => BigInt(0)\n    case _ if k == 0 => f * BigInt(1) \/ d\n    case _ if k > n\/2 => binomial(n, n - k, f, d)\n    case _ => binomial(n - 1, k - 1, f * n, d * k)\n  }\n \n  def diagonal(n: Int, p: Int): BigInt = \n    binomial(n + 1, p + 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559ce00b70041bc7b600013d":[{"id":334263,"user_id":null,"body":"object Finance {\n\n  def finance(n: Int): BigInt = {\n    val x = BigInt(n)\n    x*(x+1)*(x+2)\/2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334264,"user_id":492,"body":"object Finance {\n\n  def finance(n: Int): BigInt = {\n    val m: BigInt = BigInt(n)\n    m * (m + 1) * (m + 2) \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334265,"user_id":null,"body":"object Finance {\n\n  def finance(n: Int): BigInt = {\n    \n    def getSum(n: BigInt): BigInt = if (n % 2 == 1) n * 3 * (n + 1) \/ 2 else n * 3 * n \/ 2 + n * 3 \/ 2\n\n    import scala.annotation.tailrec\n    @tailrec\n    def financeHelper(n: Int, sum: BigInt): BigInt = {\n      if (n == 1) sum + n*3 else financeHelper(n-1, sum+getSum(n))\n    }\n    financeHelper(n, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334266,"user_id":null,"body":"object Finance {\n\n  def finance(n: Int): BigInt = BigInt(n) * BigInt(n + 1) * BigInt(n + 2) \/ BigInt(2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334267,"user_id":null,"body":"object Finance {\n\n  def finance(n: Int): BigInt = {\n    val k: BigInt = BigInt(n)\n    \n    k * (k + 1) * (k + 2) \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334268,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Finance {\n\n  def finance(n: Int): BigInt = {\n    \n    def gaussSum(min: BigInt, max: BigInt): BigInt = {\n      val count = max - min + 1\n\n      if (count % 2 == 0) {\n        (max + min) * count\/2\n      } else {\n        (max - 1 + min) * (count-1)\/2  + max\n      }\n    }\n    \n    var r: BigInt = 0\n    for (i <- 0 to n) {\n      val f: BigInt = gaussSum(0 + i * 2, n + i)\n      r = r + f\n    }\n\n    r\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334269,"user_id":null,"body":"object Finance {\n  def finance(n: Int): BigInt = (1 to n).map(n => BigInt(3) * n * (n + 1) \/ 2).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334270,"user_id":null,"body":"object Finance {\n\n  def finance(n: Int): BigInt = {\n    (BigInt(0) to n).map(i => ((n + i*3) * (n + 1 - i)) \/ 2).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334271,"user_id":null,"body":"object Finance {\n\n  def finance(n: Int): BigInt = BigInt(n) * BigInt(n + 1) * BigInt(n + 2) \/ 2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334272,"user_id":53,"body":"object Finance {\n  def finance(n: Int): BigInt = {\n    var m = BigInt(n)\n    return m * (m + 1) * (m + 2) \/ 2;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559e3224324a2b6e66000046":[{"id":334273,"user_id":null,"body":"object Funcij {\n\n  def sumin(n: BigInt): BigInt =  n * (n + 1) * (2 * n + 1) \/ 6\n  \n  def sumax(n: BigInt): BigInt =  n * (n + 1) * (4 * n - 1) \/ 6\n  \n  def sumsum(n: BigInt): BigInt = n * n * (n + 1)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334274,"user_id":null,"body":"object Funcij {\n\n  def sumin(n: Int): BigInt = {\n    \/\/ your code\n    var m = BigInt(n)\n      return m*(m+1)*(m*2+1)\/6\n  }\n  def sumax(n: Int): BigInt = {\n    var m = BigInt(n)\n    return m*(m+1)*(m*4-1)\/6\n  }\n  def sumsum(n: Int): BigInt = {\n    \/\/ your code\n    var m = BigInt(n)\n    return m*m*m+m*m\n                \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334275,"user_id":null,"body":"object Funcij {\n\n  def sumin(n: Int): BigInt = {\n    var s: BigInt = 0\n    for (i <- Range(1, n)) s = s + sum(i)\n    2 * s + sum(n)\n\/\/    Range(1, n).map(sum(_)).sum * 2 + sum(n)\n  }\n\n  def sumax(n: Int): BigInt = {\n\/\/    Range(1, n).inclusive.map(BigInt(_)).map(i => i * i * 2 - i).sum\n    var s: BigInt = 0\n    for (i <- Range(1, n).inclusive) s = s + BigInt(i) * i * 2 - i\n    s\n  }\n\n  def sumsum(n: Int): BigInt = {\n    BigInt(n) * n * (n + 1)\n  }\n\n  private def sum(n: BigInt): BigInt = n * (n + 1) \/ 2\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334276,"user_id":null,"body":"object Funcij {\n\n  def sumin(n: BigDecimal): BigInt = {   \n    \/\/ sum of min is a square pyramidal number\n    val s = (n * n * n) \/ 3.0 + (n * n) \/ 2.0 + n \/ 6.0 \n    s.toBigInt\n  }\n  \n  def sumax(n: BigDecimal): BigInt = {\n    \/\/ su of max is a cube minus a square pyramidal number\n    val cube = n * n * n\n    val n_minus_1 = n - 1\n    val pyramid = (n_minus_1 * n_minus_1 * n_minus_1) \/ 3.0 + (n_minus_1 * n_minus_1) \/ 2.0 + n_minus_1 \/ 6.0     \n    val s = cube - pyramid\n    s.toBigInt\n  }\n  \n  def sumsum(n: BigInt): BigInt = {\n    val s = n * n * (n + 1)\n    s\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334277,"user_id":null,"body":"import scala.math._\n\nobject Funcij {\n\n  def sumin(n: Int): BigInt = {\n    val some: BigInt = n\n    some * (some + 1) * (2 * some + 1) \/ 6\n  }\n  def sumax(n: Int): BigInt = {\n    sumsum(n) - sumin(n)\n  }\n  def sumsum(n: Int): BigInt = {\n    val some: BigInt = n\n    some * some * (some + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334278,"user_id":null,"body":"object Funcij {\n\n  def sumin(n: Int): BigInt = {\n    val k: BigInt = n\n    k * (k + 1) * (2 * k + 1) \/ 6\n  }\n  def sumax(n: Int): BigInt = {\n    sumsum(n) - sumin(n)\n  }\n  def sumsum(n: Int): BigInt = {\n    val k: BigInt = n\n    k * k * (k + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334279,"user_id":null,"body":"object Funcij {\n  def squaresum(n: Int): BigInt = BigInt(n) * (n+1) * (2*n + 1) \/ 6\n  \n  def sumin(n: Int): BigInt = {\n    println(\"sumin: \" + n.toString)\n    BigInt(n) * n + squaresum(n-1)\n  }\n  def sumax(n: Int): BigInt = {\n    println(\"sumax: \" + n.toString)\n    BigInt(n) * n * n - squaresum(n-1)\n  }\n  def sumsum(n: Int): BigInt = {\n    println(\"sumsum: \" + n.toString)\n    BigInt(n+1)*n*n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334280,"user_id":53,"body":"object Funcij {\n\n  def sumin(n: Int): BigInt = {\n    BigInt(n) * BigInt(n+1) * BigInt(2 * n + 1) \/ BigInt(6)\n  }\n  def sumax(n: Int): BigInt = {\n    BigInt(n) * BigInt(n+1) * BigInt(4 * n - 1) \/ BigInt(6)\n  }\n  def sumsum(n: Int): BigInt = {\n    BigInt(n+1) * BigInt(n) * BigInt(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334281,"user_id":null,"body":"object Funcij {\n\n  def sumin(n: Int): BigInt =\n    BigInt(n).pow(3) - BigInt(n) * BigInt(n - 1) * BigInt(2 * n - 1) \/ 3 - BigInt(n) * BigInt(n - 1) \/ 2\n\n  def sumax(n: Int): BigInt =\n    BigInt(n) + BigInt(n) * BigInt(n - 1) * 3 \/ 2 + BigInt(n) * BigInt(n - 1) * BigInt(2 * n - 1) \/ 3\n\n  def sumsum(n: Int): BigInt = BigInt(n) * BigInt(n) * BigInt(n + 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334282,"user_id":null,"body":"object Funcij {\n  def sumin(n: Int): BigInt = {\n    val x = BigInt(n)\n    (2*x*x*x + 3*x*x + x) \/ 6\n  }\n\n  def sumax(n: Int): BigInt = {\n    val x = BigInt(n)\n    (4*x*x*x+3*x*x-x) \/ 6\n  }\n\n  def sumsum(n: Int): BigInt = {\n    val x = BigInt(n)\n    x*x*x+x*x\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55a29405bc7d2efaff00007c":[{"id":334283,"user_id":null,"body":"object Suite {\n  \n  def going(n: Int): Double = {\n    val factorials = (2 to n).scanLeft(BigDecimal(1))(_ * _)\n    (factorials.sum \/ factorials(n - 1)).setScale(6, BigDecimal.RoundingMode.FLOOR).toDouble\n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334284,"user_id":1228,"body":"object Suite {\n\n  def going(n: Int): Double = {\n    val (cum, _) = (n to 2 by -1).foldLeft(1.0, 1.0) { case ((sum, a),i) => \n      val newA = a * (1.0\/i.toDouble)\n      (sum + newA, newA)\n    }\n    scala.math.floor(cum*1000000) \/ 1000000\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334285,"user_id":null,"body":"import scala.math.floor\n\nobject Suite {\n\n  def iter(n: Int): Double = if(n == 1) 1 else iter(n - 1)\/n + 1\n\n  def going(n: Int): Double = {\n    floor(iter(n) * 1000000)\/ 1000000\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334286,"user_id":573,"body":"object Suite {\n\n  def going(n: Int): Double =\n    ((2 to n)\n      .scanLeft((2 to n).map(BigDecimal(_)).product) { case (last, i) => last \/ i }\n      .map(d => (1\/d).toDouble)\n      .sum)\n      match { case v => s\"$v\".take(8).toDouble }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334287,"user_id":574,"body":"object Suite {\n  \n  def term(m: Int, n: Int): Double = (m + 1 to n).map(1.0 \/ _).product\n  \n  def going(n: Int): Double = {\n    val res = (n to 1 by -1).toStream.map(m => term(m, n)).takeWhile(_ > 1e-8).sum\n    math.floor(res * 1e6) \/ 1e6\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334288,"user_id":492,"body":"object Suite {\n\n  def going(n: Int): Double = {\n    var res: Double = 1.0\n    var inter: Double = 1.0\n    var i: Int = n\n    while (i >= 2) {\n      inter = inter * (1.0 \/ i)\n      res += inter \n      i -= 1\n    }\n    Math.floor(res * Math.pow(10, 6)) \/ Math.pow(10, 6)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334289,"user_id":null,"body":"object Suite {\n\n  def going(n: Int): Double = \n    (n until 1 by -1).view\n      .scanLeft(BigDecimal(1))((agg, next) => agg * next)\n      .map(1 \/ _)\n      .takeWhile(_ > 1e-10)\n      .sum\n      .setScale(6, BigDecimal.RoundingMode.FLOOR)\n      .toDouble\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334290,"user_id":null,"body":"object Suite {\n\n  def going(n: Int): Double = {\n    var sum: Double = 0\n    var frac: Double = 1\n    for (i <- n to 1 by -1) {\n      sum += frac\n      frac \/= i\n    }\n    math.floor(sum * 1000000) \/ 1000000\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334291,"user_id":1285,"body":"object Suite {\n\n  def going(n: Int): Double = {\n    def calc(sum: Double, m: Int, last: Double): Double =\n      if (m == 0) sum\n      else calc(sum + last \/ (m + 1), m - 1, last \/ (m + 1))\n\n    (calc(0, n, n + 1) * 1000000).toInt.toDouble \/ 1000000\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334292,"user_id":null,"body":"object Suite {\n\n  def going(n: Int): Double = {\n    \"%.8f\".format((math.max(2,n-20) to n).map(x=>{\n      var s = n\n      var index = n\n      while(s<100000000 && index > x)\n      {\n        index-=1\n        s *= index\n      }\n      \n      if(s<100000000) 1.0\/s else 0.0\n    }\n      ).sum+1).dropRight(2).toDouble\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55a2d7ebe362935a210000b2":[{"id":334293,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = nums.min\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334294,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = {\n      if (nums.isEmpty) throw new java.util.NoSuchElementException else nums.min\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334295,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = {\n  nums.sorted.apply(0)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334296,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = nums reduce math.min\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334297,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = {\n    return nums.reduceLeft ( _ min _ );\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334298,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int( nums: List[Int] ): Int = nums.reduceLeft(math.min)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334299,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = nums.foldLeft(nums(0))((a, b) => if (a > b) b else a)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334300,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums: List[Int]): Int = {\n    nums match {\n      case Nil => 0\n      case x::Nil => x\n      case x :: y ::Nil => if (x < y) x\n      else y\n      case x :: y :: xs => if (x < y)\n        find_smallest_int(x :: xs)\n      else find_smallest_int(y :: xs)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334301,"user_id":null,"body":"object SmallestIntegerFinder {\n  def find_smallest_int(nums:Seq[Int]):Int = {\n        nums.reduceRight((a,b) =>  {\n      println(s\"a -> $a and b -> $b -> ${a.min(b)}\")\n      a.min(b)\n    })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334302,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject SmallestIntegerFinder {\n  \/\/avoiding use of list.min in a recursive way\n  def find_smallest_int(nums:Seq[Int]):Int = {\n    \/\/nums.min\n    @tailrec\n    def find_smallest_intRec(nums:Seq[Int], min: Int): Int = {\n      nums match {\n        case Nil => min\n        case hd :: tail => find_smallest_intRec(tail, Math.min(hd, min)) \n      }\n    }\n    find_smallest_intRec(nums.tail, nums.head)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55a70521798b14d4750000a4":[{"id":334303,"user_id":null,"body":"object Greeter {\n  def greet(name: String): String = s\"Hello, $name how are you doing today?\"\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334304,"user_id":null,"body":"object Greeter {\n\n  def greet(name: String): String = {\n    var s = \"Hello, \"+name+\" how are you doing today?\"\n    s\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334305,"user_id":null,"body":"object Greeter {\n\n  def greet(name: String): String = {\n    val str1 = \"Hello, \"\n    val str2 = \" how are you doing today?\"\n    val greeting = str1 + name + str2\n    greeting\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334306,"user_id":null,"body":"object Greeter {\n\n  def greet(name: String): String = {\n    val greetingStr = s\"Hello, $name how are you doing today?\";\n    greetingStr\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334307,"user_id":null,"body":"object Greeter {\n  val greet = (name: String) => s\"Hello, $name how are you doing today?\"\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334308,"user_id":null,"body":"object Greeter {\n  def greet(name: String): String = {\n    \/\/ your code here\n    val s =\"Hello, \"+name + \" how are you doing today?\"\n    s\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334309,"user_id":null,"body":"object Greeter {\n  def greet(name: String): String = {\n    \/\/ your code here\n    val greet = \"Hello, \" + name + \" how are you doing today?\"\n     greet\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334310,"user_id":null,"body":"object Greeter:\n  def greet(name: String): String =\n    s\"Hello, $name how are you doing today?\"","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334311,"user_id":null,"body":"object Greeter {\n  def greet(name: String): String = {\n    val input = scala.io.StdIn.readLine(name);\n    return \"Hello, \" +  name + \" how are you doing today?\"\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334312,"user_id":null,"body":"object Greeter {\n  def greet(name: String): String = {\n    \/\/ your code here\n    return \"Hello, \" + name + \" how are you doing today?\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55aa075506463dac6600010d":[{"id":334313,"user_id":573,"body":"object SumSquaredDivisors {\n\n  val cache = collection.mutable.Map[Long, Option[String]]()\n\n  def list_squared(m: Long, n: Long): String =\n    (m to n)\n      .flatMap { k =>\n        cache.getOrElseUpdate(\n          k,\n          {\n            val divisorsSum = (1L to k).collect { case d if (k.toDouble \/ d).isWhole => d*d }.sum\n            Option.when(math.sqrt(divisorsSum).isWhole)(s\"[$k, $divisorsSum]\")\n          }\n        )\n      }\n      .mkString(\"[\", \", \", \"]\")\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334314,"user_id":null,"body":"object SumSquaredDivisors {\n\n  def list_squared(m: Long, n: Long): String = {\n    val numbersWithDivSum = (m to n) map { num => num -> divisorsSum(num) } filter (p => math.sqrt(p._2).isWhole)\n    numbersWithDivSum map { case (num, divSum) => s\"[$num, ${divSum.toLong}]\" } mkString(\"[\", \", \", \"]\")\n  }\n\n  def divisorsSum(number: Long): Double = divisors(number).map(d => d * d).sum\n  def divisors(number: Long): Seq[Long] = ((1L to number \/ 2L) filter (i => number % i == 0)) :+ number\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334315,"user_id":null,"body":"object SumSquaredDivisors {\n\n  def list_squared(m: Long, n: Long): String = {\n    val result = (m to n)\n       .map(x => (x, getDivisors(x).map(xx => xx*xx).sum))\n       .filter(isSquare)\n       .map(pair => s\"[${pair._1}, ${pair._2}]\")\n       .mkString(\", \")\n    s\"[$result]\"\n  }\n  \n  def isSquare(tuple: Tuple2[Long, Long]): Boolean = {\n    Math.sqrt(tuple._2).toInt * Math.sqrt(tuple._2).toInt == tuple._2\n  }\n  \n  def getDivisors(n: Long): Set[Long] = {\n    (1 to Math.sqrt(n).toInt)\n       .filter(n % _ == 0)\n       .flatMap(divisor => List(divisor, n \/ divisor))\n       .toSet\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334316,"user_id":null,"body":"object SumSquaredDivisors {\n\n  def list_squared(m: Long, n: Long): String = (m to n)\n      .map(x => (x, divisorsSquareSum(x)))\n      .filter(x => math.sqrt(x._2).isValidInt)\n      .map(x => s\"[${x._1}, ${x._2}]\")\n      .mkString(\"[\", \", \", \"]\")\n\n  def divisorsSquareSum(n: Long): Long = {\n    val lowDivisors = (1L to math.sqrt(n).toLong).filter(n % _ == 0).toSet\n    (lowDivisors ++ lowDivisors.map(n \/ _)).map(x => x * x).toList.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334317,"user_id":null,"body":"object SumSquaredDivisors {\n\n   def list_squared(m: Long, n: Long): String = {\n    val listTup = for {i <- m until n + 1\n                         list = divisors(i)\n                         sq = squaring(list)\n                         if check(sq)\n                   } yield (i, sq)\n\n\n   val str=  for { x <- listTup} yield s\"[${x._1}, ${x._2}]\"\n   str.mkString(\"[\", \", \" , \"]\")\n\n\n  }\n\n\n  def divisors(n: Long): List[Long] = {\n    (1L to n\/2L).filter(x => n % x == 0).toList :+ n\n\n  }\n\n  def squaring(list: List[Long]) : Long = {\n    list.map(x => math.pow(x, 2).toInt).sum\n\n  }\n\n  def check(long: Long) : Boolean = {\n    val sr = math.sqrt(long).toInt\n    sr*sr == long\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334318,"user_id":492,"body":"object SumSquaredDivisors {\n\n  private def sumSquaredFactors(n: Long): Array[Long] = {\n    var s: Long = 0\n    var nf: Long = 0\n    val res: Array[Long] = Array.ofDim[Long](2)\n    var i: Long = 1\n    while (i <= Math.floor(Math.sqrt(n))) {\n      if (n % i == 0) {\n        s += i * i\n        nf = n \/ i\n        if (nf != i) s += nf * nf\n      }\n      i += 1\n    }\n    if (Math.pow(Math.sqrt(s).toLong, 2) == s) {\n      res(0) = n\n      res(1) = s\n      res\n    } else null\n  }\n  def list_squared(m: Long, n: Long): String = {\n    var res: String = \"[\"\n    var i: Long = m\n    while (i <= n) {\n      val r: Array[Long] = sumSquaredFactors(i)\n      if (r != null) {\n        res += \"[\" + java.lang.Long.toString(r(0)) + \", \" + java.lang.Long.toString(r(1)) + \"], \"\n      }\n      i += 1\n    }\n    res.replaceFirst(\",\\\\s$\", \"\") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334319,"user_id":null,"body":"object SumSquaredDivisors {\n\n  def list_squared(m: Long, n: Long, res: List[(Long, Long)] = List[(Long, Long)]()): String = {\n    def getDivisors(x: Long): List[Long] = {\n      if (x > Math.sqrt(m)) List[Long]() else\n      if (m % x == 0 && m\/x != x) List[Long](x,m\/x) ++ getDivisors(x+1) else\n      if (m%x == 0) List[Long](x) ++ getDivisors(x+1) else getDivisors(x+1)\n    }\n    if (m==n) \"[\" ++ res.map((i: (Long, Long)) => s\"[${i._1}, ${i._2}]\").mkString(\", \") ++ \"]\" else {\n     \/\/val square = (1L to m).filter(m % _ == 0).map((i:Long)=>i*i).sum\n      val square = getDivisors(1).map((i: Long)=>i*i).sum\n      if (Math.sqrt(square).isWhole) list_squared(m+1, n, res :+ (m, square)) else\n      list_squared(m+1, n, res)\n      }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334320,"user_id":null,"body":"object SumSquaredDivisors {\n\n  def list_squared(m: Long, n: Long): String = {\n    var out = \"[\"\n    for(x <- m.toInt to n.toInt){\n      var res = scala.math.sqrt((for(y <- 1 to x if x%y==0) yield y*y).sum)\n      if( res.isValidInt )\n        out += s\"[$x, \"+(res*res).toInt+\"], \"\n    }\n    if(out.length > 1)\n      out = out.dropRight(2)\n    out.concat(\"]\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334321,"user_id":null,"body":"object SumSquaredDivisors {\n\n def findDivisors(num: Long, end: Long, acc: List[Long]): List[Long] = {\n    if (end == 1) 1 :: acc\n    else if (num % end == 0) findDivisors(num, end - 1, end :: acc)\n    else findDivisors(num, end - 1, acc)\n  }\n\n  def checkSqr(num: Long): List[Long] = {\n    val sqr = Math.sqrt(num).toInt\n    if (sqr * sqr == num) List(sqr.toInt)\n    else Nil\n  }\n\n  def list_squared(m: Long, n: Long): String = (for {\n    i       <- m to n\n    divisors = findDivisors(i, i, Nil)\n    sumDivs  = divisors.map(x => x * x).sum\n    sqr     <- checkSqr(sumDivs)\n  } yield s\"[$i, $sumDivs]\").mkString(\"[\", \", \", \"]\")\n\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334322,"user_id":null,"body":"import scala.collection.immutable.NumericRange\n\n\nobject SumSquaredDivisors {\n\n  val format = (s: Array[_]) => s.mkString(\"[\", \", \", \"]\")\n\n  def list_squared(m: Long, n: Long): String =\n    format((m to n)\n      .map(i => Array(i, ((1L to Math.sqrt(i).toInt).filter(o => i % o == 0)\n        .flatMap(div => if (i \/ div == div) List(div) else List(div, i \/ div)))\n        .map(Math.pow(_, 2).toInt).sum))\n      .filter(in => { val squared = Math.sqrt(in(1)); squared - Math.floor(squared) == 0 })\n      .map(format).toArray)\n\n   \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55ab4f980f2d576c070000f4":[{"id":334323,"user_id":573,"body":"object Suite2 {\n\n  def game(n: Long): String =\n    if (n*n % 2 == 0) s\"[${n*n\/2}]\" else s\"[${n*n}, 2]\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334324,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String = {\n    \/\/ your code\n    if (n % 2 == 0) s\"[${n*n \/ 2}]\" else s\"[${n*n}, 2]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334325,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String = {\n    if(n == 0) return \"[0]\" \n    if(n%2 == 0) s\"[${n*n\/2}]\" else s\"[${n*n}, 2]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334326,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String ={\n    val k = n * n\n\n    if (k % 2 == 0) s\"[${n*n\/2}]\" else s\"[${n*n}, 2]\" \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334327,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String = {\n    val x2 = n*n\n    if (x2 % 2 == 0) {\n      s\"[${x2\/2}]\"\n    }\n    else {\n      s\"[$x2, 2]\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334328,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String = {\n    val nom = n * n\n    if (nom % 2 == 0) s\"[${nom \/ 2}]\" else s\"[$nom, 2]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334329,"user_id":null,"body":"object Suite2 {\n\n \n  def game(n: Long): String = {\n    val middle = n * 0.5\n\n    def loop(n: Double, acc: Double): Double = {\n      if(n == 0) acc * 2 - middle\n      else loop(n - 0.5, acc + n)\n    }\n\n      val number = loop(middle, 0)\n      if(number % 1 == 0) s\"[${number.toLong}]\"\n      else s\"[${(number * 2).toLong}, 2]\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334330,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String = {\n    \/\/ your code\n    new Fraction((n * n), 2).toString\n  }\n  \n  \n  class Fraction(x: Long, y: Long = 1L) {\n    require(y != 0)\n    private val g = gcd(x, y)\n    val numer = x \/ g\n    val denom = y \/ g\n    def + (that: Fraction): Fraction =\n      new Fraction(\n        numer * that.denom + denom * that.numer,\n        denom * that.denom\n      )\n    override def toString: String = {\n      if (denom == 1) s\"[$numer]\"\n      else s\"[$numer, $denom]\"\n    }\n\n    private def gcd(a: Long, b: Long): Long =\n      if (b == 0) a else gcd(b, a % b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334331,"user_id":null,"body":"object Suite2 {\n\n  def game(n: Long): String = n match {\n      case n if n <= 0 => s\"[0]\"\n      case n if n % 2 == 0 => s\"[${n * n \/ 2}]\"\n      case _ => s\"[${n * n}, 2]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334332,"user_id":53,"body":"object Suite2 {\n\n  def game(n: Long): String = {\n    if ((n%2)==0) {\n      return \"[\" + (n*n\/2) + \"]\";\n    } else {\n      return \"[\" + (n*n) + \", 2]\";\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b195a69a6cc409ba000053":[{"id":334333,"user_id":53,"body":"object IncDec { \n  def totalIncDec(n: Int): BigInt = {\n    var a = BigInt(1)\n    var b = BigInt(1)\n    var c = BigInt(1 + 10 * n)\n    var i = 0\n    while (i < n) {\n      a = a * (10+i) \/ (i+1)\n      b = b * (11+i) \/ (i+1)\n      i = i+1\n    }\n    return a + b - c\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334334,"user_id":null,"body":"object IncDec {\n  def totalIncDec(x: Int): BigInt = {\n    if (x < 1) return 1\n    var table: Array[BigInt] = Array.tabulate(10)(x => 10 - x)\n    var accDecr: BigInt = 10\n\n    for (_ <- 2 to x; digit <- 8 to 0 by -1) {\n      table(digit) += table(digit + 1)\n      if (digit == 0) accDecr += table(0)\n    }\n    table(0) + accDecr - 10 * x\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334335,"user_id":null,"body":"object IncDec { \n  def totalIncDec(x: Int): BigInt = {\n    val lastN: List[(BigInt, BigInt, BigInt)] = List.fill(10)((0, 1, 0)) \n\n    def count(n: Int, lastN: List[(BigInt, BigInt, BigInt)]): BigInt = {\n      if (n == x) lastN.map(x => x._1 + x._2 + x._3).sum\n      else {\n        val dec = (0 to 9).map{ x => lastN.drop(x).map(x => x._1).sum + lastN.drop(x + 1).map(x => x._2).sum }\n        val same = (0 to 9).map{ x => lastN(x)._2 }\n        val inc = (0 to 9).map{ x => lastN.take(x + 1).map(x => x._3).sum + lastN.take(x + 1).map(x => x._2).sum }\n        val newLastN = (0 to 9).map(x => (dec(x), same(x), inc(x))).toList\n        count(n + 1, newLastN)\n      }\n    }\n    \n    x match {\n      case 0 => 1\n      case _ => count(1, lastN) - 10 * (x - 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334336,"user_id":168,"body":"object IncDec { \n\n        def totalIncDec(x: Int): BigInt =\n          (1 to 9).foldLeft(BigInt(x + 20))((r, i) => r * (x + i) \/ i) \/ 10 - 10 * x - 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334337,"user_id":null,"body":"object IncDec { \n\n  def totalIncDec(x: Int): BigInt = {\n    if (x == 0)\n      BigInt(1)\n    else {\n      val initial = Vector.fill(9)(BigInt(1))\n      \n      val (inc, dec) = (2 to x).foldLeft((initial, initial)) { case ((inc, dec), i) =>\n      \n        val newInc = inc.scanLeft(BigInt(1)) { case (acc, sum) => acc + sum }.drop(1)\n        val newDec = dec.scanRight(BigInt(1)) { case (sum, acc) => sum + acc }.dropRight(1)\n        \n        if (i == 2)\n          (newInc, BigInt(10) +: newDec)\n        else\n          (newInc, newDec)\n      \n      }\n      \n      inc.sum + dec.sum + BigInt(2) - BigInt(10) * x\n    }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334338,"user_id":null,"body":"object IncDec { \n\n        def totalIncDec(x: Int): BigInt = (1 to x).map(n => (n + 1 to n + 8).map(BigInt(_)).product\/BigInt(40320) * BigInt(x - n + 2) - BigInt(9)).sum + BigInt(1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334339,"user_id":null,"body":"object IncDec { \n\n  def calculate(x: Int, increasing: Map[Int, BigInt], decreasing: Map[Int, BigInt], currentStep: Int = 2, currentCount: BigInt = 100): BigInt = {\n    if (currentStep == x) currentCount\n    else {\n      val updatedIncreasing = increasing.map{case (k,v) => (0 to 9).filter(_ >= k).map(_ -> v)}.flatten.groupBy(_._1).map(e => e._1 -> e._2.map(_._2).sum)\n      val updatedDecreasing = decreasing.map{case (k,v) => (0 to 9).filter(_ <= k).map(_ -> v)}.flatten.groupBy(_._1).map(e => e._1 -> e._2.map(_._2).sum)\n\n      calculate(x, updatedIncreasing, updatedDecreasing, currentStep + 1, currentCount + updatedIncreasing.values.sum + updatedDecreasing.values.sum - 9)\n    }\n  }\n\n  def totalIncDec(x: Int): BigInt =\n    if (x == 0) BigInt(1)\n    else if (x == 1) BigInt(10)\n    else if (x == 2) BigInt(100)\n    else {\n      val increasing = (10 to 99).filter(_.toString.map(_.asDigit).sliding(2).forall(s => s.head <= s.last)).map(_ % 10).groupBy(identity).map(e => e._1 -> BigInt(e._2.size))\n      val decreasing = (10 to 99).filter(_.toString.map(_.asDigit).sliding(2).forall(s => s.head >= s.last)).map(_ % 10).groupBy(identity).map(e => e._1 -> BigInt(e._2.size))\n      calculate(x, increasing, decreasing)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334340,"user_id":null,"body":"object IncDec {\n\n  def totalIncDec(x: Int): BigInt =\n    if (x <= 0) {\n      BigInt(1)\n    } else {\n      val array = new Array[Array[BigInt]](x)\n      (0 until x).foreach(i => array(i) = new Array[BigInt](10))\n      (0 to 9).foreach(i => array(0)(i) = BigInt(1))\n      (1 until x).foreach(k => (0 to 9).foreach(j => array(k)(j) = (j to 9).map(l => array(k - 1)(l)).sum))\n      val incSum = (0 to 9).map(j => array(x - 1)(j)).sum\n      val decSum = (1 until x).map(k => (1 to 9).map(l => array(k)(9 - l)).sum).sum\n      incSum + decSum - 9 * (x - 1)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334341,"user_id":468,"body":"object IncDec { \n  def totalIncDec(x: Int): BigInt = {\n    x match {\n      case 0 => BigInt(1)\n      case 1 => BigInt(10)\n      case 2 => BigInt(100)\n      case _ =>\n        val num1 = (1 to 8).map(x + BigInt(_)).product \/\/ numerator for (n+8) choose 8\n        val num2 = num1 * (x + 9) \/\/ numerator for (n+9) choose 9\n        val den1 = BigInt(40320) \/\/ 8!, denominator for (n+8) choose 8\n        val den2 = BigInt(362880) \/\/ 9!, denominator for (n+9) choose 9\n        \/\/ (n+8) choose 8 + (n+9) choose 9 - 10 + previous term\n        num1 \/ den1 + num2 \/ den2 - 10 + totalIncDec(x - 1)\n\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334342,"user_id":null,"body":"object IncDec { \n  def totalIncDec(x: Int): BigInt = {\n    def increasing(n: Int): BigInt =\n      (1 to 8).foldLeft(BigInt(1))((acc, k) => acc * (n + k)) \/ (1 to 8).product\n\n    def decreasing(n: Int): BigInt =\n      (1 to 9).foldLeft(BigInt(1))((acc, k) => acc * (n + k)) \/ (1 to 9).product - 1\n    \n    (1 to x).foldLeft(BigInt(1))((acc, exponent) => acc + increasing(exponent) + decreasing(exponent) - 9)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b3425df71c1201a800009c":[{"id":334343,"user_id":null,"body":"object Stat {\n  def stat_assoc(strg: String): String = {\n    val millis = strg.split(\", \").map(_.split(\"\\\\|\")).map {\n      case Array(h, m, s) => (h.toInt * 60 + m.toInt) * 60 + s.toInt\n    }.sorted.toList\n    val median: (Int, Int) = millis.zip(millis.reverse).toArray.apply((millis.length - 1) \/ 2)\n    val out = Array(millis.max - millis.min, millis.sum \/ millis.length, (median._1 + median._2) \/ 2)\n      .map(millis => \"%02d|%02d|%02d\".format(millis \/ 3600, millis \/ 60 % 60, millis % 60))\n    \/\/ Range: 00|31|17 Average: 02|26|18 Median: 02|22|00\"\n    s\"Range: ${out(0)} Average: ${out(1)} Median: ${out(2)}\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334344,"user_id":null,"body":"import scala.concurrent.duration._\n\nobject Stat {\n\n  def stat_assoc(strg: String): String = {\n    val inSec = strg.split(\", \").map(asString => {\n      val asStrings = asString.split(\"\\\\|\")\n      def pos(i: Int): Int = asStrings(i).toInt\n      pos(0).hours + pos(1).minutes + pos(2).seconds\n    }).sorted\n    val range = inSec.max -inSec.min\n    val average = inSec.reduce(_+_) \/ inSec.length\n    val lh = inSec.length.toFloat \/ 2\n    val median = if (lh.isWhole) (inSec(lh.toInt - 1) + inSec(lh.toInt)) \/ 2 else  inSec(lh.toInt)\n    \"Range: \" + format(range) + \" Average: \" + format(average) + \" Median: \" + format(median)\n  }\n  \n  def format(d : Duration) = {\n    val h = d.toHours\n    val min = (d - h.hours).toMinutes\n    val s = (d - h.hours - min.minutes).toSeconds\n    String.format(\"%02d|%02d|%02d\", h, min, s)\n  } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334345,"user_id":null,"body":"object Stat {\n\n  def stat_assoc(strg: String): String = {\n   if (strg.isEmpty) return \"\"\n    val arr = strg.split(\", \").map(x => x.split(\"\\\\|\").map(y => y.toInt)).map(z => decode(z)).sorted\n    s\"Range: ${encode(arr.last - arr(0))} Average: ${encode(arr.sum \/ arr.length)}\" +\n      s\" Median: ${encode((arr(arr.length \/ 2) + arr.reverse(arr.length \/ 2))\/ 2)}\"\n  }\n  def decode(arr: Array[Int]): Int = arr(0) * 3600 + arr(1) * 60 + arr(2)\n  def encode(num: Int): String = f\"${num \/ 3600}%02d|${num \/ 60 % 60}%02d|${num % 60}%02d\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334346,"user_id":null,"body":"object Stat {\n\n     def stat_assoc(strg: String): String = {\n\n      val strToSecond: String => Array[Int] = (string: String) => {\n        for {\n          time <- string.replace(' ', '0').split(',').map(_.split('|').map(_.toInt))\n          hour   = time.head\n          minute = time(1)\n          second = time(2)\n        } yield hour * 3600 + minute * 60 + second\n      }\n\n      val arr: Array[Int] = strToSecond(strg)\n\n      val average: Int = arr.sum \/ arr.length\n\n      val range: Int = arr.max - arr.min\n\n      val median: Int = {\n        val arrSorted = arr.sorted\n        val length    = arr.length\n        if (length % 2 == 0) {\n          (arrSorted(length \/ 2 - 1) + arrSorted(length \/ 2)) \/ 2\n        } else {\n          arrSorted((length - 1) \/ 2)\n        }\n      }\n\n      val secToString: Int => String = (seconds: Int) => {\n        val sec  = seconds            % 60\n        val min  = (seconds           % 3600 - seconds % 60) \/ 60\n        val hour = (seconds - seconds % 3600) \/ 3600\n        f\"$hour%02d|$min%02d|$sec%02d\"\n      }\n\n      f\"Range: ${secToString(range)} Average: ${secToString(average)} Median: ${secToString(median)}\"\n\n    }\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334347,"user_id":null,"body":"object Stat {\n\n  def stat_assoc(strg: String): String = {\n    val timeSplit = strg.split(\", \").map(_.split(\"\\\\|\").map(_.trim.toInt))\n\n    def toSeconds(time: Array[Int]) = (time(0) * 60 + time(1)) * 60 + time(2)\n  \n    def format(seconds: Int): String = {\n      val hh = seconds \/ 3600\n      val mm = (seconds % 3600) \/ 60\n      val ss = seconds % 60\n  \n      def style(t: Int): String = if (t < 10) s\"0$t\" else s\"$t\"\n  \n      s\"${style(hh)}|${style(mm)}|${style(ss)}\"\n    }\n  \n    val timeInSeconds = timeSplit.map(toSeconds)\n    val range = format(timeInSeconds.max - timeInSeconds.min)\n    val average = format(timeInSeconds.sum \/ timeInSeconds.length)\n  \n    def findMedian(time: Array[Int]): Int = {\n      val len = time.length\n      val sorted = time.sorted\n      if (len % 2 != 0) sorted(len \/ 2)\n      else (sorted(len \/ 2 - 1) + sorted(len \/ 2)) \/ 2\n    }\n  \n    val median = format(findMedian(timeInSeconds))\n  \n    s\"Range: $range Average: $average Median: $median\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334348,"user_id":null,"body":"object Stat {\n\n  \tdef median(a: Array[Int]): Int = {\n\t\tval n = a.size\n\t\tval sorted = a.sorted\n\t\tif (n % 2 == 0) sorted.slice(n\/2-1, n\/2+1).reduce(_+_) \/ 2 else sorted(n\/2)\n\t}                                         \/\/> median: (a: Array[Int])Int\n   \n  def mean(a: Array[Int]) = a.sum \/ a.size        \/\/> mean: (a: Array[Int])Int\n  \n  def range(a: Array[Int]) = a.max - a.min        \/\/> range: (a: Array[Int])Int\n  \n  def secToHHMMSS(x: Int) = {\n  \t\t\n  \t\tval h = x \/ 3600\n  \t\tval m = (x - h * 3600) \/ 60\n  \t\tval s = (x - h * 3600 - m*60)\n  \t\t\n  \t\t\/\/h.toString + '|' + m.toString + '|' + s.toString\n  \t\tf\"$h%02d|$m%02d|$s%02d\"\n  }                                               \/\/> secToHHMMSS: (x: Int)String\n  \n  \n  \n  def stat_assoc(strg: String): String = {\n  \t\t\n\t\tval resSec = strg.split(\", \")\n \t\t.map(_.split('|')\n \t\t\t\t\t.map(_.toInt))\n \t\t.map(s => s(2) + 60*s(1) + 3600*s(0))\n                                                  \/\/> resSec  : Array[Int] = Array(4559, 6436, 4640, 5554, 8237)\n\t\n\t\tval Range = secToHHMMSS(range(resSec))    \/\/> Range  : String = 01|01|18\n\t\tval Mean = secToHHMMSS(mean(resSec))      \/\/> Mean  : String = 01|38|05\n\t\tval Median = secToHHMMSS(median(resSec))  \/\/> Median  : String = 01|32|34\n\t\n\t\tf\"Range: $Range%s Average: $Mean%s Median: $Median%s\"  \n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334349,"user_id":573,"body":"import scala.math.Integral.Implicits._\n\nobject Stat {\n\n  def stat_assoc(str: String): String =\n    str match {\n      case \"\" => \"\"\n      case _  =>\n        val perfs   = str.split(\", \").map(str2sec)\n        val range   = sec2str(perfs.max - perfs.min)\n        val average = sec2str((perfs.sum \/ perfs.size.toDouble).floor.toInt)\n        val middle  = sec2str(median(perfs))\n        s\"Range: $range Average: $average Median: $middle\"\n    }\n  \n  def str2sec(str: String): Int =\n    str.split(\"\\\\|\").map(_.toInt) match { case Array(h, m, s) => h * 3600 + m * 60 + s }\n    \n  def sec2str(secs: Int): String = {\n    secs \/% 3600 match { case (h, s) => (h, s \/% 60) match { case (h, (m, s)) => f\"$h%02d|$m%02d|$s%02d\" } }\n  }\n  \n  def median(perfs: Array[Int]): Int = {\n    val perfsSize = perfs.size\n    (perfsSize % 2 match {\n      case 1 => perfs.sorted.apply(perfsSize \/ 2)\n      case 0 => perfs.sorted.slice(perfsSize \/ 2 - 1, perfsSize \/ 2 + 1).sum \/ 2.toDouble\n    }).floor.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334350,"user_id":null,"body":"import java.time.Duration\nimport scala.util.chaining.scalaUtilChainingOps\n\nobject Stat {\n  def stat_assoc(str: String): String = {\n    def pad(str: String) = \"0\" * (2 - str.length) + str\n    def fmt(int: Long) = pad(int.toString)\n    def toDuration(arr: Array[Int]) = {\n      arr match {\n        case Array(hh, mm, ss) => Duration.parse(s\"PT${hh}H${mm}m${ss}s\")\n      }\n    }\n\n    def fromDuration(d: Duration) = {\n      s\"${fmt(d.toHours)}|${fmt(d.toMinutes - d.toHours * 60)}|${fmt(d.getSeconds - d.toMinutes * 60)}\"\n    }\n    val results = str.split(\",\").map(_.trim.split(\"\\\\|\").map(_.toInt).pipe(toDuration)).sorted\n    val min = results.min\n    val max = results.max\n    val range = max.minus(min)\n    val median =\n      if (results.length % 2 == 0) {\n        results(results.length \/ 2).plus(results(results.length \/ 2 - 1)).dividedBy(2)\n      } else {\n        results(results.length \/ 2)\n      }\n    val average = results.reduce((a, b) => a.plus(b)).dividedBy(results.length)\n    s\"Range: ${fromDuration(range)} Average: ${fromDuration(average)} Median: ${fromDuration(median)}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334351,"user_id":null,"body":"\n\tobject Stat {\n\t\t\n\t\tdef stat_assoc(strg: String): String = strg match {\n\t\t\tcase \"\" => \"\"\n\t\t\tcase strg =>\n\t\t\t\tval athleteTimes = strg.split(\", \").map(\n\t\t\t\t\ttime => {\n\t\t\t\t\t\tval segments = time.split(\"\\\\|\")\n\t\t\t\t\t\tsegments(0).toInt * 60 * 60 + segments(1).toInt * 60 + segments(2).toInt\n\t\t\t\t\t\t\n\t\t\t\t\t})\n\t\t\t\tval (range, mean, median) = getStats(athleteTimes)\n\t\t\t\t\n\t\t\t\tf\"Range: ${range \/ 3600}%02d|${range\/60%60}%02d|${range%60}%02d \" +\n\t\t\t\t\tf\"Average: ${mean \/ 3600}%02d|${mean\/60 %60}%02d|${mean%60}%02d \" +\n\t\t\t\t\tf\"Median: ${median \/ 3600}%02d|${median\/60 %60}%02d|${median%60}%02d\"\n\t\t}\n\t\t\n\t\tdef getStats(times: Array[Int]): (Int, Int, Int) = {\n\t\t\tval sortedTimes = times.sorted\n\t\t\tval range = sortedTimes(sortedTimes.length - 1) - sortedTimes(0)\n\t\t\tval mean = times.sum \/ times.length\n\t\t\tval median = if (times.length % 2 == 0) {\n\t\t\t\t(sortedTimes(times.length \/ 2 - 1) + sortedTimes(times.length \/ 2)) \/ 2\n\t\t\t} else {\n\t\t\t\tsortedTimes(times.length \/ 2)\n\t\t\t}\n\t\t\t(range, mean, median)\n\t\t}\n\t\t\n\t\t\n\t}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334352,"user_id":null,"body":"object Stat {\n\n  def stat_assoc(strg: String): String = {\n    val s = strg\n      .split(\", \")\n      .map(_.split('|'))\n      .map(x => x(0).toInt * 3600 + x(1).toInt * 60 + x(2).toInt)\n      .sorted\n    \n    \/\/ range\n    val range = s.max - s.min\n    \n    \/\/ mean\n    val mean = s.sum \/ s.length\n    \n    \/\/ median\n    val median = if (s.length % 2 == 0) {\n      (s(s.length \/ 2 - 1) + s(s.length \/ 2)) \/ 2\n    } else {\n      s((s.length \/ 2))\n    }\n    \n    s\"Range: ${convertToFullTime(range)} Average: ${convertToFullTime(mean)} Median: ${convertToFullTime(median)}\"\n  }\n  \n  def convertToFullTime(time: Int): String = {\n    val hours = time \/ 3600\n    val minutes = time % 3600 \/ 60\n    val seconds = time % 3600 % 60\n    \n    f\"${hours}%02d|${minutes}%02d|${seconds}%02d\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b4d87a3766d9873a0000d4":[{"id":334353,"user_id":573,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String =\n    ((n min m) to (n max m))\n      .collect {\n        case k if ((k - 1) \/ 9d).isWhole && ((k - 2) \/ 7d).isWhole =>\n          s\"[M: $k B: ${(k-2)\/7} C: ${(k-1)\/9}]\"\n      }\n      .mkString(\"[\", \"\", \"]\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334354,"user_id":53,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    (((m min n)+25)\/63 to ((m max n)+26)\/63-1)\n      .map(i => (i*63+37, i*9+5, i*7+4))\n      .map(p => s\"[M: ${p._1} B: ${p._2} C: ${p._3}]\")\n      .mkString(\"[\", \"\", \"]\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334355,"user_id":null,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    val result = (m.min(n) to m.max(n)).flatMap {\n      case num if (num - 2) % 7 == 0 && (num - 1) % 9 == 0 =>\n        Some(s\"[M: $num B: ${(num - 2) \/ 7} C: ${(num - 1) \/ 9}]\")\n      case _ => None\n    }.mkString\n    s\"[$result]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334356,"user_id":null,"body":"object Carboat {\n  def howmuch(m: Int, n: Int): String = {\n    var result = \"[\"\n    for(i <- Math.min(m, n) until Math.max(m, n) + 1) {\n      if(i % 7 == 2 && i % 9 == 1) {\n        result = result + (\"[M: \" + i + \" B: \" + i \/ 7 + \" C: \" + i \/ 9 + \"]\")\n      }\n    }\n    result = result + \"]\"\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334357,"user_id":null,"body":"import scala.language.postfixOps\nobject Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    val possib = (m.min(n) to n.max(m) toList).map(_.abs)\n    val commons = possib.filter(_ % 9 == 1).filter(possib.filter(_ % 7 == 2).contains(_))\n    val results = commons.map(comm => \"[M: \" + comm + \" B: \" + comm\/7 + \" C: \" + comm\/9 + \"]\")\n    return \"[\" + results.mkString + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334358,"user_id":null,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    val z = for{x <- Math.min(m,n) to Math.max(n,m); if ( ((x.toFloat - 1)\/9).floor ==  (x.toFloat - 1)\/9 );\n               if ((x.toFloat - 2)\/7).floor ==  (x.toFloat - 2)\/7 } yield {\n      val m = x;\n      val c = (m- 1)\/9\n      val b = (m-2)\/7\n      List(s\"[M: $m B: $b C: $c]\");}\n    println(\"z: \",z.toString().replace(\"List\",\"\").replace(\"Vector\",\"\").replace(\"(\",\"\").replace(\")\",\"\"))\n    return \"[\" + z.toString().replace(\"List\",\"\").replace(\"Vector\",\"\").replace(\"(\",\"\").replace(\")\",\"\").replace(\", \",\"\") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334359,"user_id":null,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    \/\/ your code\n    val ans = \"[M: %d B: %d C: %d]\"\n    ((m min n) to (m max n))\n      .filter(_ % 9 == 1)\n      .filter(_ % 7 == 2)\n      .map((x: Int) => ans.format(x, x \/ 7, x \/ 9))\n      .mkString\n      .formatted(\"[%s]\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334360,"user_id":null,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    val ans = \"[M: %d B: %d C: %d]\"\n    val minVal = Array(m,n).min\n    val maxVal = Array(m,n).max\n    \"[\" + Range(minVal,maxVal+1)\n    .filter(_ % 9==1)\n    .filter(_ % 7==2)\n    .map((x:Int)=> ans.format(x,x\/7,x\/9))\n    .mkString + \"]\"\n    \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334361,"user_id":null,"body":"object Carboat {\n\n  def howmuch(m: Int, n: Int): String = {\n    val order = if(m < n) m to n else n to m\n    val res = for(i <- order if i%9==1 && i%7==2) yield s\"[M: ${i} B: ${(i\/7).floor.toInt} C: ${i\/9.floor.toInt}]\"\n    \"[\" + res.mkString + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334362,"user_id":null,"body":"object Carboat {\n\n  def howmuch(m0: Int, n0: Int): String = {\n    val m = m0 min n0; val n = m0 max n0\n    \"[\" + (1+Math.floorDiv(m-38, 63) to Math.floorDiv(n-37, 63)).map((n: Int) => s\"[M: ${37+63*n} B: ${5+9*n} C: ${4+7*n}]\").mkString(\"\") + \"]\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b7bb74a0256d4467000070":[{"id":334363,"user_id":null,"body":"object Sol {\n  def proper_fractions(n: Long): Long = (primeFactors(n).distinct.map(x => 1 -1D\/x).product * n).toLong\n  \n  def primeFactors(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = (\n    if(a * a > x) x :: list\n    else if (x % a == 0) primeFactors(x \/ a, a, a :: list) \n    else primeFactors(x, a + 1, list)\n  )\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334364,"user_id":null,"body":"object Sol {\n  \n  def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n  \n  def proper_fractions(d_prime: Long): Long = {\n    \n    if(d_prime == 1) return 0\n    \n    var d = d_prime\n    var result: Double = d\n    \n    for(p <- 2L to Math.sqrt(d).asInstanceOf[Long] + 1L) {\n      \n      if (d % p == 0) { \/\/ found a prime factor\n        while (d % p == 0) {\n          d \/= p\n        }\n        \n        result *= (1.0 - (1.0 \/ p.asInstanceOf[Double]))\n      }\n      \n    }\n    \n    if (d > 1)  {\n      result *= (1.0 - (1.0 \/ d.asInstanceOf[Double]))\n    }\n    \n    \n    result.asInstanceOf[Long]\n    \n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334365,"user_id":null,"body":"object Sol {\n\n  def proper_fractions(n: Long): Long = {\n    if (n == 1L) {\n      0\n    } else {\n      var (ans, x, i) = (1L, n, 2L)\n      while (i * i <= x) {\n        if (x % i == 0) {\n          x \/= i\n          ans *= (i - 1)\n          while (x % i == 0) {\n            x \/= i\n            ans *= i\n          }\n        }\n\n        i += 1\n      }\n      if (x > 1) ans *= (x - 1)\n      ans\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334366,"user_id":null,"body":"object Sol {\n\n  def proper_fractions(n: Long): Long = {\n    var en = n\n    var result: Long = if (n == 1) 0 else 1\n    var i: Long = 2\n    while (i * i <= en) {\n      var c: Long = 0\n      if (en % i == 0) {\n        while (en % i == 0) {\n          c += 1\n          en \/= i\n        }\n      }\n      if (c > 0)\n        result *= Math.pow(i, c-1).toLong * (i-1)\n      i += 1\n    }\n    if (en > 1) result * (en - 1) else result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334367,"user_id":null,"body":"object Sol {\n  val knownPrimes: LazyList[Long] = 2L #:: knownPrimes.map(prev => {\n    var candidate = prev + (if (prev == 2L) 1L else 2L)\n    while (knownPrimes.takeWhile(p => p * p <= candidate).exists(p => candidate % p == 0)) {\n      candidate += 2L\n    }\n    candidate\n  })\n\n  def primeFactorsOf(number: Long): Seq[Long] = {\n    if (number < 2) Seq.empty\n    else {\n      \/\/ Skip the primes the number is not divisible by, and handle the case where the number is prime\n      val firstPrimeFactor = knownPrimes.dropWhile(p => p * p <= number && number % p != 0).head\n      if (number % firstPrimeFactor == 0) firstPrimeFactor +: primeFactorsOf(number \/ firstPrimeFactor)\n      else Seq(number)\n    }\n  }\n\n  \/\/ Calculate directly, instead of testing each numerator\n  def proper_fractions(denominator: Long): Long = {\n    val maxNumerator = denominator - 1\n    var count: Long = denominator - 1\n    val denominatorFactors = primeFactorsOf(denominator).distinct\n    for (numberOfFactors <- 1 to denominatorFactors.length) {\n      \/\/ Remove the number that are divisible by 1 factor, add the number that are divisible by 2 factors, and so on\n      count += (if (numberOfFactors % 2 == 0) 1 else -1) * denominatorFactors.combinations(numberOfFactors).map(maxNumerator \/ _.product).sum\n    }\n    count\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334368,"user_id":null,"body":"object Sol {\n\n  def proper_fractions(n: Long): Long = (primeFactors(n).distinct.map(x => 1 -1d \/ x).product * n).toLong\n  \n  def primeFactors(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = (\n    if(a * a > x) x :: list\n    else if (x % a == 0) primeFactors(x \/ a, a, a :: list) \n    else primeFactors(x, a + 1, list)\n  )\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334369,"user_id":null,"body":"object Sol {\n\n  def proper_fractions(d: Long): Long = { totient(d, factorize(2, d).distinct) }\n\n  def totient(n: Long, primes: List[Long]): Long = {\n    primes.foldLeft(n.toDouble) { (acc, elem) => acc * (1.0 - 1.0 \/ elem.toDouble) }.toLong\n  }\n\n  def factorize(div: Long, num: Long): List[Long] = {\n    if (div * div > num)  return List(num)\n    if (num % div == 0) return div :: factorize(div, num \/ div)\n    factorize(div + 1, num)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334370,"user_id":null,"body":"object Sol {\n\nimport scala.math.sqrt\n  def proper_fractions(n1: Long): Long = {\n    if (n1==1) return 0\n    var result: Long = n1\n    var n = n1\n    for (i<-2 to sqrt(n).toInt)\n    if (n % i == 0) {\n      while (n % i == 0) {\n        n \/= i\n      };\n      result -= result \/ i;\n    }\n    if (n > 1)\n      result -= result \/ n;\n    result;\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334371,"user_id":null,"body":"object Sol {\n\n  def proper_fractions(n: Long): Long = {\n    if (n == 1) return 0\n    var result = n\n    var a = n\n    var i = 2\n    while (i <= math.sqrt(a)) {\n      if (a % i == 0) {\n        result = result \/ i * (i - 1)\n        while(a % i == 0) a \/= i\n      }\n      i += 1\n    }\n    if (a > 1) result = result \/ a * ( a - 1)\n    result\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334372,"user_id":null,"body":"object Sol {\n\n  def factorize(x: Long): List[Long] = {\n    def foo(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a*a > x match {\n      case false if x % a == 0 => foo(x \/ a, a    , a :: list)\n      case false               => foo(x    , a + 1, list)\n      case true                => x :: list\n    }\n    foo(x)\n  }\n  \n  def proper_fractions(n: Long): Long = {\n    val factorization = factorize(n)\n    val factors = factorization.distinct\n    .map(x => (x, factorization.count(_ == x)))\n    .map(x => math.pow(x._1, x._2 - 1) * (x._1 - 1))\n    .product.toLong\n    factors\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55be10de92aad5ef28000023":[{"id":334373,"user_id":53,"body":"object Checkchoose {\n\n  def checkchoose(m: Long, n: Int): Long = {\n    var result:Long = 1;\n    var i:Long = 0;\n    while (i <= n) {\n      if (result == m) return i;\n      result = result * (n - i) \/ (i + 1);\n      i += 1;\n    }\n    return -1;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334374,"user_id":573,"body":"object Checkchoose {\n\n  def checkchoose(m: Long, n: Int): Long = {\n    def fact(k: Long) = (1L to k).map(x => BigInt(x)).product\n    Iterator\n      .range(1, n)\n      .find(x => fact(n) \/ (fact(x) * fact(n - x)) == m)\n      .getOrElse(-1).toLong\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334375,"user_id":null,"body":"import scala.math.BigInt\nobject Checkchoose {\n\n  def checkchoose(m: Long, n: Int): Long = {\n    val nFac = factorial(n)\n    for (x <- 1 to n){\n      if ((nFac\/(factorial(x)*factorial(n-x))).toLong == m) return x\n    }\n    return -1\n  }\n  \n  def factorial( num: Long): BigInt = {\n    return factorial(BigInt.apply(num))\n  }\n  def factorial( num: BigInt): BigInt = {\n    if (num == 0) return BigInt.apply(1L)\n    return num * factorial(num - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334376,"user_id":573,"body":"object Checkchoose {\n\n  def checkchoose(m: Long, n: Int): Long =\n    Iterator.range(1, n).find(x => n.! \/ (x.! * (n - x).!) == m).getOrElse(-1).toLong\n\n  implicit class IntExtensions(n: Int) { def !(): BigInt = (1 to n).map(x => BigInt(x)).product }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334377,"user_id":null,"body":"object Checkchoose {\n\n  def factorial(n: Long): BigInt = (BigInt(1) to n).product\n  def choose(n: Long, x: Long): Long = (factorial(n) \/ factorial(x) \/ factorial(n - x)).toLong\n  def checkchoose(posters: Long, colors: Int): Long =\n    (1L to colors)\n      .find(n => choose(colors, n) == posters)\n      .getOrElse(-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334378,"user_id":null,"body":"object Checkchoose {\n\n  def checkchoose(m: Long, n: Int): Long = {\n    def factorial(num: Int): BigInt = (BigInt(2) to BigInt(num)).product\n    def product(x1: Int, x2: Int): BigInt = (BigInt(x1) to BigInt(x2)).product\n    def binomialCoefficient(n: Int, x: Int): BigInt = product(x + 1, n) \/ factorial(n - x)\n\n    (1 to n \/ 2 + 1).toList\n      .find(binomialCoefficient(n, _) == BigInt(m))\n      .getOrElse[Int](-1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334379,"user_id":null,"body":"object Checkchoose {\n\n  def checkchoose(m: Long, n: Int): Long = {\n    var result: Long = 1\n    var k: Int = 0\n    while (k <= n) {\n      if (result == m) return k\n      result = result * (n - k) \/ (k + 1)\n      k += 1\n    }\n    -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334380,"user_id":null,"body":"object Checkchoose {\n\n  def factorial(number: Int): BigInt = {\n    if (number == 0) 1 else number * factorial(number - 1)\n  }\n  \n  def checkchoose(m: Long, n: Int): Long =  {\n    def checkChooseHelper(x: Int): Long = {\n      if (x < n) {\n        if (m == factorial(n)\/(factorial(x)*factorial(n-x))) return x\n        else return checkChooseHelper(x+1)\n        \n      } else return -1\n    }\n    checkChooseHelper(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334381,"user_id":null,"body":"object Checkchoose {\n\n  def factorial(n: Int, acc: BigInt = BigInt(0), list: List[BigInt] = List(BigInt(1))): List[BigInt] = {\n    if(acc == n) list\n    else factorial(n, acc+1, list :+ list.last*(acc+1))\n  }\n  \n  def checkchoose(m: Long, n: Int): Long = {\n    val factorials = factorial(n)\n    println(factorials)\n    val answer = (0 to n\/2).toList\n    .find(x => (factorials(n)\/(factorials(x)*factorials(n-x))).toLong == m)\n    if (answer == None) -1L\n    else answer.get.toLong\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334382,"user_id":null,"body":"object Checkchoose {\n  def checkchoose(m: Long, n: Int): Long = {\n    def fact(x: Int): BigInt = (BigInt(1) to BigInt(x)).product\n    (1 to n).find(i => fact(n)\/ (fact(i) * fact(n - i)) == m).map(_.toLong).getOrElse(-1L)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55bf01e5a717a0d57e0000ec":[{"id":334383,"user_id":573,"body":"object Multiplication {\n\n  def persistence(n: Int, depth: Int = 0): Int =\n    if (n < 10) depth else persistence(n.toString.map(_.asDigit).product, depth+1)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334384,"user_id":573,"body":"object Multiplication {\n\n  def persistence(n: Int): Int = \n    if (n > 9) persistence(n.toString.map(_.asDigit).product) + 1 else 0\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334385,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Multiplication {\n\n   def persistence(n: Int): Int = {\n\n    @tailrec\n    def persistanceWithCounter(n: Int, i: Int) : Int = {\n      if (singleDigit(n)) i\n      else persistanceWithCounter(multDigit(n), i + 1)\n    }\n\n    persistanceWithCounter(n,0)\n\n  }\n\n  def singleDigit(n: Int) = n.toString.length == 1\n\n  def multDigit(n: Int) = n.toString.map(_.asDigit).product\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334386,"user_id":null,"body":"object Multiplication {\n\n  def muldig(n: Int): Int = if (n >= 10) n % 10 * muldig(n\/10) else n\n\n  def persistence(n: Int): Int = if (n >= 10) persistence(muldig(n)) + 1 else 0\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334387,"user_id":null,"body":"object Multiplication {\n  def persistence(n: Int): Int = if (n < 10) 0 else (1 + persistence((\"\"+n).map(_-48).reduce(_*_)))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334388,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Multiplication {\n\n  def persistence(n: Int): Int = {\n    @tailrec\n    def persistence(n: Int, accum: Int = 0): Int = {\n      n.toString.toList match {\n        case _ :: Nil => accum\n        case list     => persistence(list.map(_.asDigit).product, accum + 1)\n      }\n    }\n\n    persistence(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334389,"user_id":null,"body":"import scala.annotation.tailrec\nobject Multiplication {\n\n  @tailrec\n  def persistence(n: Int, total: Int = 0): Int = {\n    val str: String = n.toString\n    if (str.length == 1) {\n      total;\n    } else {\n      persistence(str.map(_.asDigit).product, total + 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334390,"user_id":null,"body":"object Multiplication {\n\n  def persistence(n: Int): Int = {\n        def accumulate(x: Int, acc: Int = 0): Int = {\n            val digits = x.toString.map(_.asDigit)\n            if (digits.size == 1) return acc\n            accumulate(digits.product, acc + 1)\n        }\n\n        accumulate(n)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334391,"user_id":null,"body":"object Multiplication {\n  \n  def persistence(n: Int): Int = {\n    if (n < 10) 0 else 1 + persistence(n.toString.map(_.toInt - 48).product)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334392,"user_id":null,"body":"object Multiplication {\n\n  def persistence(n: Int, count: Int = 0): Int =\n    if (n < 10)\n      count\n    else\n      persistence(n.toString.map(x => x.toInt - 48).reduce(_ * _), count+1)\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55c45be3b2079eccff00010f":[{"id":334393,"user_id":527,"body":"object Text {\n\n  def order(str: String): String =\n    str.split(' ').sortBy(_.find(_.isDigit)).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334394,"user_id":573,"body":"object Text {\n\n  def order(str: String): String =\n    str.split(' ').sortBy(_.sorted).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334395,"user_id":null,"body":"object Text {\n\n  val IntRegEx = \"(\\\\d+)\".r\n\n  def order(str: String): String = str.split(\" \").sortBy{w => IntRegEx.findFirstIn(w).map(_.toInt).getOrElse(10)}.mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334396,"user_id":null,"body":"object Text {\n  def numberInWord(s: String): Int = s.filter(_.isDigit)(0)\n  def order(str: String): String = str.split(\" \").sortWith(numberInWord(_) < numberInWord(_)).reduce(_+\" \"+_)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334397,"user_id":null,"body":"object Text {\n  def order(str: String): String = str match {\n    case \"\" => \"\"\n    case _ => str.split(\" \")\n      .map(word => (word, word.filter(_.isDigit).head.asDigit))\n      .sortBy(_._2).map(_._1).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334398,"user_id":null,"body":"object Text {\n\n  def order(str: String): String = {\n    val numPattern = \"[1-9]+\".r\n    \n    str\n      .split(\" \")\n      .map(r => (numPattern.findFirstIn(r).getOrElse(\"0\").toInt, r))\n      .sortWith(_._1 < _._1)\n      .map(res => res._2)\n      .mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334399,"user_id":null,"body":"object Text {\n  def order(str: String): String = {\n    val pattern = \"\"\"(\\d+)\"\"\".r\n    str.split(' ').sortBy(pattern.findFirstMatchIn(_).get.toString()).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334400,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject Text {\n\n  def order(str: String): String = str.split(\" \").sortWith(intInString(_) <= intInString(_) ).mkString(\" \")\n  \n  def intInString (str: String): Int = {\n      \"[0-9]\".r.findFirstMatchIn(str).map(_.matched) match {\n        case Some(n) => n.toInt\n        case None => 0\n      } \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334401,"user_id":null,"body":"object Text {\n  def order(str: String): String =\n    str.split(\" \").sortBy(w => w.find(_.isDigit)).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334402,"user_id":null,"body":"import scala.collection.immutable.ListMap\n\nobject Text {\n\n  def order(str: String): String = {\n    if(str.isEmpty) {\n          \"\"\n    } else {\n\n      var kv = Map.empty[Int, String]\n\n      str.split(\" \").foreach {\n        case s if s.contains(\"1\") => kv = kv + (1 -> s)\n        case s if s.contains(\"2\") => kv = kv + (2 -> s)\n        case s if s.contains(\"3\") => kv = kv + (3 -> s)\n        case s if s.contains(\"4\") => kv = kv + (4 -> s)\n        case s if s.contains(\"5\") => kv = kv + (5 -> s)\n        case s if s.contains(\"6\") => kv = kv + (6 -> s)\n        case s if s.contains(\"7\") => kv = kv + (7 -> s)\n        case s if s.contains(\"8\") => kv = kv + (8 -> s)\n        case s if s.contains(\"9\") => kv = kv + (9 -> s)\n    }\n\n\n      ListMap(kv.toSeq.sortWith(_._1 < _._1): _*).values.mkString(\" \")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55c6126177c9441a570000cc":[{"id":334403,"user_id":573,"body":"object WeightSort {\n\n  def order_weight(str: String): String =\n    str.split(\" \").sortBy(d => (d.map(_.asDigit).sum, d)).mkString(\" \").trim\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334404,"user_id":527,"body":"object WeightSort {\n\n  def order_weight(s: String): String = {\n    s.split(' ').sortBy(s => (s.map(_.asDigit).sum, s)).mkString(\" \").trim\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334405,"user_id":null,"body":"object WeightSort {\n\n  def order_weight(strng: String): String = strng.split(\" \").sortBy(r => (r.map(_.toInt - 48).sum, r)).mkString(\" \").trim\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334406,"user_id":null,"body":"object WeightSort {\n\n  def order_weight(strng: String): String = {\n  if (strng.trim == \"\") \"\" \/\/ Handling the code for input empty string\n    else {\n    val outputTuple =  strng.split(\" \").map(x => (x, x.toString.split(\"\").map(_.toInt).sum))\n    val output = outputTuple.sortBy(x => (x._2,x._1)).map(_._1).mkString(\" \").trim\n    output}\n}}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334407,"user_id":null,"body":"object WeightSort {\n\tdef order_weight(strng: String): String = {\n\t\tstrng.split(\" \").foldLeft(Map.empty[Int, Seq[String]]) { (m, n) =>\n\t\t\tval index = n.map(_.toString.toInt).sum\n\t\t\tm + (index -> (m.getOrElse(index, Seq.empty) :+ n))\n\t\t}.toSeq.sortBy(_._1).map(_._2.sorted).reduce(_ ++ _).mkString(\" \").trim\n\t}\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334408,"user_id":492,"body":"import java.util.Arrays\nimport java.util.Comparator\n\nobject WeightSort {\n\n  private def weightStrNb(strng: String): Int = {\n    val digits: Array[String] = strng.split(\"\")\n    var dsum: Int = 0\n    for (d <- digits) {\n      val dgt: Int = java.lang.Integer.parseInt(d)\n      dsum += dgt\n    }\n    dsum\n  }\n  def order_weight(strng: String): String = {\n    val lstr: Array[String] = strng.split(\" \")\n    val cmp: Comparator[String] = new Comparator[String]() {\n      def compare(o1: String, o2: String): Int = {\n        var cp: Int = weightStrNb(o1) - weightStrNb(o2)\n        if (cp == 0) o1.compareTo(o2)\n        else if (cp < 0) -1 else 1\n      }\n    }\n    Arrays.sort(lstr, cmp)\n    lstr.mkString(\" \")\n  }\n}\n  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334409,"user_id":null,"body":"object WeightSort {\n\n  def order_weight(strng: String): String = {\n    strng.trim.split(\" \").map(_.trim).sorted.sortBy(_.map(_.asDigit).sum).mkString(\" \").trim\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334410,"user_id":null,"body":"object WeightSort {\n\n  def order_weight(strng: String): String = {\n    strng.split(\" \").sortBy(sort => (sort.map(_.asDigit).sum, sort)).mkString(\" \").trim\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334411,"user_id":null,"body":"object WeightSort {\n\n  def order_weight(strng: String): String = {\n    def toWeight(s: String): Int = s.foldLeft(0)((x, sum) => sum + (x - '0'))\n\n    def compare(s1: String, s2: String): Boolean = {\n      val s1Weight = toWeight(s1)\n      val s2Weight = toWeight(s2)\n      if (s1Weight == s2Weight) {\n        s1.compareTo(s2) < 1\n      } else {\n        s1Weight < s2Weight\n      }\n    }\n\n    strng.trim.split(\" +\").sortWith((s1, s2) => compare(s1, s2)).mkString(\" \").trim\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334412,"user_id":null,"body":"object WeightSort {\n\n  def order_weight(strng: String): String = {\n    strng\n      .split(' ')\n      .filter(_.nonEmpty)\n      .groupBy(s => s.split(\"\").map(_.toInt).sum)\n      .map { case (len, items) => (len, items.sorted) }\n      .toList.sortBy{ case (len, _) => len }\n      .flatMap { case (len, items) => items }\n      .mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55c9172ee4bb15af9000005d":[{"id":334413,"user_id":527,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n    2 * (n \/ 6) + List(0, 1, 2, 2, 2, 2)(n % 6) - (if (n >= 2) 1 else 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334414,"user_id":636,"body":"object Pentabonacci {\n  val pibs: LazyList[BigInt] =\n      LazyList.iterate(List(BigInt(0), BigInt(1), BigInt(1),BigInt(2),BigInt(4)))(x => x.tail :+ x.sum).map(x => x(0))\n  val oddPibs = pibs.map(x => if (x %2 == 1) 1 else 0)\n\n\n  def countOddPentaFib(n: Int): Int = n match {\n      case 0 => 0\n      case 1 => 1\n      case _ => oddPibs.take(n+1).sum - 1 \n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334415,"user_id":null,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n    if (n < 1) 0 else (n - 1) \/ 6 + (n - 2) \/ 6 + 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334416,"user_id":null,"body":"object Pentabonacci {    \n  def is_odd(x: Long): Boolean = x % 2 == 1\n  def countOddPentaFib(n: Int): Int = {\n    n match {\n      case n if n < 1  => 0\n      case n if n <= 5 => 1\n      case _           => (1 to n).map(x => (x - 1) % 6 < 2).count(x => x) - 1 \n     }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334417,"user_id":1228,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n     2 * (n \/ 6) + List(0, 1, 2, 2, 2, 2)(n % 6) - (if (n > 1) 1 else 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334418,"user_id":null,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n    var nums = IndexedSeq(0, 1, 1, 2, 4)\n    var oddSum = 1\n    for (i <- 5 to n) {\n      val h = nums.sum & 1\n      if ((h & 1) == 1) oddSum += 1\n      nums = (nums :+ h).tail\n    }\n    oddSum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334419,"user_id":null,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n    if (n < 1) 0\n    else if ((n+1)%3 == 0)\n      if (((n+1)\/3)%2 == 0) (n+1)\/3 - 1 else (n+1)\/3\n    else if ((n+2)%3 == 0) (n+2)\/3-1\n    else\n      if (((n+1)\/3)%2 == 0) (n+1)\/3 - 1 else (n+1)\/3\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334420,"user_id":53,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n    if (n == 0) {\n      return 0\n    }  else if (n == 1) {\n      return 1\n    } else {\n      return 1 + (n-1)\/6 + (n-2)\/6\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334421,"user_id":168,"body":"object Pentabonacci {\n  def countOddPentaFib(n: Int): Int = {\n    if (n <= 1) n else 2 * ((n + 4) \/ 6) - (if (n % 6 == 1) 0 else 1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334422,"user_id":null,"body":"object Pentabonacci extends App {\n  def countOddPentaFib(n: Int): Int = {\n    def fib(n: Int, acc: List[Long] = List(0)): List[Long] =\n      if (n <= 0) acc\n      else acc match {\n      case a :: b :: c :: d :: e :: _ => fib(n - 1, (a + b + c + d + e) +: acc)\n      case a :: Nil => fib(n - 1, 1L +: acc)\n      case _ => fib(n - 1, acc.sum +: acc)\n    }\n    fib(n).count(_ % 2 != 0) - 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cbc3586671f6aa070000fb":[{"id":334423,"user_id":76,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = base % factor == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334424,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n    return base % factor == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334425,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n  var a = (base % factor == 0)\n      return a\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334426,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n    return (base.toFloat\/factor).isWhole\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334427,"user_id":527,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int) = base % factor == 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334428,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = base % factor match{\n    case 0 => true\n    case _ => false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334429,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n    if (base % factor == 0) return true else return false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334430,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n    var result: Int =  base % factor\n    if (result != 0) \n      return false\n    else \n      return true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334431,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n    var res:Int =  base % factor\n    if(res != 0) \n      return false\n    else \n      return true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334432,"user_id":null,"body":"object Kata {\n  def checkForFactor(base: Int, factor: Int): Boolean = {\n    if (base%factor==0) return true\n    return false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cf3b567fc0e02b0b00000b":[{"id":334433,"user_id":53,"body":"object IntPart {\n\n  def part(n: Long): String = {\n    val xs = partition(n)\n    val l = xs.length\n    val r = xs(l-1) - xs(0)\n    val s = xs.foldLeft(0L)((acc, x) => acc + x)\n    val u = s.toDouble \/ l.toDouble\n    val m = 0.5 * (xs(l\/2) + xs((l-1)\/2)).toDouble\n    \"Range: %d Average: %.2f Median: %.2f\".format(r, u, m)\n  }\n  \n  def partition(n: Long): Array[Long] = {\n    var ans = List.newBuilder[Long]\n    var a = Array.fill(n.toInt + 1)(0L)\n    var k = 1\n    var x = 0L\n    var y = 0L\n    a(1) = n\n    while (k > 0) {\n      x = a(k-1)+1\n      y = a(k)-1\n      k -= 1\n      while (x <= y) {\n        a(k) = x\n        y -= x\n        k += 1\n      }\n      a(k) = x+y\n      ans += a.slice(0, k+1).foldLeft(1L)((acc, x) => acc * x)\n    }\n    ans.result().distinct.sorted.toArray\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334434,"user_id":2178,"body":"\nobject IntPart {\n\n  val prod: LazyList[List[Long]] = {\n    Nil #:: LazyList.from(1).map { x =>\n      (x :: (1 until x)\n        .flatMap { b =>\n          prod(x - b).map(a => a * b)\n        }.toList : List[Long]).distinct\n    }\n  }\n\n\n  def part(n: Long): String = {\n    val p = prod(n.toInt).sorted\n    val r = p.last - p.head\n    val a = p.sum.toDouble \/ p.length\n    val m = if (p.length % 2 == 0) (p(p.length \/ 2) + p(p.length \/ 2 - 1)) \/ 2d else p(p.length \/ 2)\n    \"Range: %d Average: %.2f Median: %.2f\".format(r, a, m)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334435,"user_id":492,"body":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.TreeSet;\n\nobject IntPart {\n\n  private var prods: TreeSet[Long] = _\n  private def calculProd(prod: Long, max: Long, left: Long): Unit = {\n    prods.add(prod)\n    var i: Long = 2\n    while (i <= max && i <= left) {\n      calculProd(prod * i, i, left - i)\n      i += 1\n    }\n  }\n  def part(n: Long): String = {\n    prods = new TreeSet()\n    calculProd(1, n, n)\n    val arrProds: ArrayList[Long] = new ArrayList[Long](prods)\n    val lg: Int = arrProds.size\n    var res: String = \"Range: %d \".format(arrProds.get(lg - 1) - arrProds.get(0))\n    var sum: Long = 0; var i = 0\n    while (i < lg) {\n      sum += arrProds.get(i)\n      i += 1\n    }\n    res += \"Average: %.2f \".format(sum.toDouble \/ lg)\n    val md = (arrProds.get((lg - 1) \/ 2) + arrProds.get(lg \/ 2)) \/ 2.0;\n    res += \"Median: %.2f\".format(md)\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334436,"user_id":null,"body":"object IntPart {\n  \n  def prod(n: Long, i: Long): Set[Long] = \n    if (n == i || i == 1) Set(i) else for (k <- Set.range(1L, math.min(n-i, i)+1); r <- prod(n-i, k)) yield i*r\n\n  def part(n: Long): String = {\n    val elems = Set.range(1L, n+1).flatMap(i => prod(n, i)).toArray.sorted\n    val median = (elems(elems.size\/2) + elems((elems.size-1)\/2)) \/ 2.0\n    f\"Range: ${elems.last - elems.head} Average: ${elems.sum.toDouble\/elems.size}%.2f Median: ${median}%.2f\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334437,"user_id":null,"body":"object IntPart {\n\n  def part(n: Long): String = {\n    var set: Set[Long] = Set()\n    def par(target: Long, max: Long, cur: List[Long]): Unit = {\n      if (target == 0)\n        set += cur.product\n      else if (target > 0) {\n        for (i <- 1L to max) {\n          par(target - i, i, i :: cur)\n        }\n      }\n    }\n    par(n, n, List())\n\n    val res = set.toList.sorted\n    val rn = res.length\n\n    val range = res.max - res.min\n    val averge = res.sum \/ rn.toDouble\n    val median = (res((rn-1)\/2) + res(rn\/2)) \/ 2.0\n    f\"Range: $range Average: $averge%.2f Median: $median%.2f\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334438,"user_id":null,"body":"\nimport scala.collection.mutable\n\nobject IntPart {\n\ndef part(n: Long): String = {\n  val treeSet = mutable.TreeSet[Long]()\n\n  def helper(n: Long, prev: Long, soFar: String): Unit = {\n\n    for (i <- prev to 1 by -1) {\n      val m = n - i\n      if (m == 0) {\n        val str = soFar + \" \" + i.toString\n        val prod = str.trim.split(\"\\\\s+\").map(_.toInt).product\n        treeSet.add(prod)\n      }\n      else if (m > 0) {\n        helper(m, i, soFar + \" \" + i.toString)\n      }\n    }\n    \/\/\"\"\n  }\n  helper(n, n, \"\")\n  \n  val arr = treeSet.toArray\n  val arrLen = arr.length\n  val average = arr.sum \/ arrLen.toDouble\n  val range = arr(arrLen - 1) - arr(0)\n  var median = 0.0\n\n  if (arrLen % 2 == 0) {\n    val lower = arrLen \/ 2 - 1\n    val upper = arrLen \/ 2\n    median = (arr(lower) + arr(upper)) \/ 2.0\n  } else {\n    median = arr(arrLen \/ 2)\n  }\n\n  f\"Range: $range Average: $average%.2f Median: $median%.2f\"\n}\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334439,"user_id":null,"body":"import scala.collection.immutable.{LazyList, TreeSet}\n\nobject IntPart {\n  \n  def part(n: Long): String = {\n    val prods = prod(n, n)\n    f\"Range: ${prods.orange}%d Average: ${prods.average}%.2f Median: ${prods.median}%.2f\"\n  }\n\n  val Primes = List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47)\n\n  def prod(left: Long, max: Long, mul: Long = 1): TreeSet[Long] = math.min(left, max) match {\n    case 0 | 1 => TreeSet(mul)\n    case limit => (1 +: Primes.takeWhile(_ <= limit))\n      .map(x => prod(left - x, math.min(x, max), mul * x))\n      .reduce(_ ++ _)\n  }\n\n\n  implicit class StatisticsOps(l: Iterable[Long]) {\n    def average: Double = 1.0 * l.sum \/ l.size\n    def median: Double = l.slice((l.size - 1) \/ 2, (l.size + 2) \/ 2).average\n    def orange: Long = l.max - l.min\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334440,"user_id":null,"body":"object IntPart {\n\n\n  \/**\n    * \u4e00\u79cd\u65b9\u6848\u662fDFS\u6c42\u6240\u6709\u53ef\u80fd\uff0c\u5206\u522b\u6c42\u4e58\u79ef\u653e\u5165Set\uff0c\u518d\u7b97\u90a3\u51e0\u4e2a\u6307\u6807\n    * \u8fd8\u53ef\u4ee5\u7528DP\uff0cmemo[n]:Set[Int]\u5b9a\u4e49\u4e3an\u7684\u6240\u6709\u6574\u6570\u7ec4\u5408\u7684\u5404\u81ea\u4e58\u79ef\u7684\u96c6\u5408\n    * \u8bbe productSet(a:Set,b:Set):Set=a\u6bcf\u4e2a\u5143\u7d20\u548cb\u6bcf\u4e2a\u5143\u7d20\u4e24\u4e24\u76f8\u4e58\u7684\u7ed3\u679c\u7684\u96c6\u5408\n    * memo[1]=Set(1)\n    * memo[n]=Set(n) \u222a productSet(memo[1],memo[n-1]) \u222a productSet(memo[2],memo[n-2]) \u222a......\n    *\/\n  def part(n: Long): String = {\n    def productSet(a: Set[Int], b: Set[Int]): Set[Int] =\n      for {\n        aEle <- a\n        bEle <- b\n      } yield (aEle * bEle)\n\n    val memo = new Array[Set[Int]](n.toInt)\n    memo(0) = Set(1)\n    for (i <- 1 until n.toInt) {\n      val tmpSet = new scala.collection.mutable.HashSet[Int]()\n      tmpSet += (i + 1)\n      for (j <- 0 to i \/ 2) {\n        tmpSet ++= productSet(memo(j), memo(i - j - 1))\n      }\n      memo(i) = tmpSet.toSet\n      println(n, i, memo(i))\n    }\n    val res = memo(n.toInt - 1).toList.sorted\n    val range = res.last - res.head\n    val avg = res.map(_.toDouble).sum \/ res.size\n    val median = if (res.length % 2 == 1) res(res.length \/ 2).toDouble else (res(res.length \/ 2 - 1).toDouble + res(res.length \/ 2)) \/ 2\n    s\"Range: $range Average: ${\"%.2f\".format(avg)} Median: ${\"%.2f\".format(median)}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334441,"user_id":1228,"body":"import scala.collection.mutable.Map\nobject IntPart {\n\n  var cache = Map[Long, List[List[Long]]]()\n\n  def part(n: Long): String = {\n    def prodList(n: Long): List[List[Long]] = {\n      n match {\n        case 0 => List(Nil)\n        case _ =>\n          (n to 1 by -1).flatMap(nn =>\n            (cache.get(n - nn) match {\n            case Some(list) =>\n              list\n            case None =>\n              val list = prodList(n - nn)\n              cache(n - nn) = list\n              list\n            })\n            .filter { case Nil => true; case head :: _ => head <= nn }.map(nn :: _)\n          ).toList\n      }\n    }   \n    val prods  = prodList(n).map(nn => nn.reduce(_*_)).distinct\n    val range  = prods.max - prods.min\n    val ave    = prods.sum.toDouble \/ prods.size\n    val (lowerHalf, higherHalf) = prods.sortWith(_<_).splitAt(prods.size \/ 2)\n    val median = ( if (prods.size % 2 == 0) (lowerHalf.last + higherHalf.head) \/ 2.0 else higherHalf.head )\n    f\"Range: ${range} Average: ${ave}%.2f Median: ${median}%.2f\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334442,"user_id":null,"body":"object IntPart {\n  def part(n: Long): String = {\n    val base: Set[Long] = Set.range(1, n)\n\n    def partRec(prod: Set[Long], prodNew: Set[Long]): Set[Long] =\n      if (prod.size == prodNew.size) return prod\n      else partRec(prodNew, setProduct(n, prodNew, base))\n    \n    val prod = partRec(base, setProduct(n, base, base))\n    val prodSorted = (prod + n).toList.sorted\n    val range = prodSorted.last -  prodSorted.head\n    f\"Range: $range Average: ${mean(prodSorted)}%.2f Median: ${median(prodSorted)}%.2f\"\n  }\n\n  def setProduct(n: Long, xs: Set[Long], ys: Set[Long]): Set[Long] =\n    for (x <- xs; y <- ys; if factorize(x * y).sum <= n) yield x * y\n\n  def factorize(num: Long, div: Long = 2): List[Long] =\n    if (div * div > num) List(num)\n    else if (num % div == 0) div :: factorize(num \/ div, div)\n    else factorize(num, div + 1)\n\n  def mean(l: List[Long]) = ((l.sum.toDouble \/ l.size) * 100).round \/ 100D\n\n  def median(l: List[Long]): Float = {\n    val s = l.size; val m = s \/ 2 - 1\n    if (s % 2 == 1) l(m + 1).toFloat else (l(m) + l(m + 1)).toFloat \/ 2\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55d24f55d7dd296eb9000030":[{"id":334443,"user_id":573,"body":"object Kata {\n\n  def summation(n: Int): Int = (1 to n).sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334444,"user_id":527,"body":"object Kata {\n\n  def summation(n: Int): Int = n * (n + 1) \/ 2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334445,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = {\n   def helper(n: Int, acc: Int): Int = {\n     if (n <= 1) acc\n     else helper(n - 1, acc + n)\n   }\n   helper(n, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334446,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = Range(1,n+1).fold(0)(_ + _) \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334447,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n\n  def summation(n: Int): Int = {\n    @tailrec\n    def add(prev: Int, x: Int, n: Int): Int = {\n      val sum = prev + x\n      if (x + 1 > n) sum\n      else add(sum, x + 1, n)\n    }\n    add(0, 0, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334448,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = {\n    val x = (1 to n).toList\n    x.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334449,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = {\n    n match {\n      case 1 => 1\n      case num => num + summation(num - 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334450,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = (n * (1 + n))\/2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334451,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = (1 to n).foldLeft(0)(_+_)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334452,"user_id":null,"body":"object Kata {\n\n  def summation(n: Int): Int = Range(0,n).inclusive.sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55d5434f269c0c3f1b000058":[{"id":334453,"user_id":573,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int =\n    if (\"0123456789\".split(\"\").exists(d => s\"$num1\".contains(d*3) && s\"$num2\".contains(d*2))) 1 else 0\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334454,"user_id":null,"body":"object Kata {\n  def triple_double(num1: Long, num2: Long): Int = {\n    var num1s = num1.toString\n    var num2s = num2.toString\n\n    var num2l = num2s.zipWithIndex\n      .filter{ case (c, i) => i < num2s.size-1 && num2s(i+1)==c }\n      .map(_._1)\n      .distinct\n\n    if (num1s.zipWithIndex\n      .filter{ case (c, i) => i < num1s.size-2 && num1s(i+1)==c && num1s(i+2)==c && num2l.exists(_==c)}.size > 0)\n      1\n    else\n      0    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334455,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int = {\n    val n1 = num1.toString.sliding(3).map(_.toList.distinct).filter(_.size == 1).toList\n    val n2 = num2.toString.sliding(2).map(_.toList.distinct).filter(_.size == 1).toList\n\n    if (n1.nonEmpty && n2.nonEmpty && n1.exists(n2.contains(_))) 1\n    else 0\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334456,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int =  {\n  \n  def repetations(num: Long, times: Int) = {\n      val asString = num.toString\n      asString.toSeq.distinct.filter(c => asString.contains(c.toString * times))\n    }\n    \n    val rep3 = repetations(num1, 3)\n    val rep2 = repetations(num2, 2)\n    \n    if(rep3.exists(rep => rep2.contains(rep))) 1 else 0\n    }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334457,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int = {\n    val first = num1.toString.map(_.asDigit)\n      .sliding(3).toList\n      .filter(g => g.forall(_ == g.head))\n      .map(_.head)\n  \n    val second = num2.toString.map(_.asDigit).sliding(2).toList.filter(g => g.forall(_ == g.head)).map(_.head)\n    first.exists(second.contains) match {\n      case true => 1\n      case false => 0\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334458,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int = {\n    val s1 = num1.toString\n    val s2 = num2.toString\n    for (j <- 0 to 9) {\n      if (s1.contains(j.toString * 3) && s2.contains(j.toString * 2)) return 1\n    }\n    return 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334459,"user_id":null,"body":"object Kata {\n  def triple(num1: Long, num2: Long): Boolean = (num1+\"\").contains(\"\"+num2+num2+num2)\n  def double(num1: Long, num2: Long): Boolean = (num1+\"\").contains(\"\"+num2+num2)\n  def triple_double(num1: Long, num2: Long): Int = {\n    var a = 0\n    var returned = 0\n    for( a <- 0 to 9)\n      if(triple(num1,a) && double(num2,a))\n        returned=1\n    returned\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334460,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int = {\n    val triples =\n      num1\n        .toString\n        .tails\n        .filter(x => x.length >= 3 && x(0) == x(1) && x(1) == x(2))\n        .map(_.head).toList\n     if (num2\n      .toString\n      .tails\n      .exists(x => x.length >= 2 && x(0) == x(1) && triples.contains(x(0)))\n     ) 1 else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334461,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int = {\n    val check = (n: Long) => (m: Int) => (c: String) => n.toString.contains(c * m)\n    if ((0 to 9)\n        .map(_.toString)\n        .filter(check(num1)(3))\n        .exists(check(num2)(2))) 1 else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334462,"user_id":null,"body":"object Kata {\n\n  def triple_double(num1: Long, num2: Long): Int = {\n      val num1List: List[Int] = num1.toString.map(_.asDigit).toList\n      val num2List = num2.toString.map(_.asDigit)\n      val num1Occs: List[Int] = num1List.distinct.map(x=>(x,num1List.sliding(3).toList.count(_.forall(_==x)))).collect {\n        case x if x._2 > 0 => x._1\n      }\n      val num2Occs = num2List.distinct.map(x=>(x,num2List.sliding(2).toList.count(_.forall(_==x)))).collect {\n        case x if x._2 > 0 => x._1\n      }\n      if (num1Occs.intersect(num2Occs).nonEmpty) 1 else 0\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e2adece53b4cdcb900006c":[{"id":334463,"user_id":null,"body":"object Sol {\n\n  def race(v1: Int, v2: Int, g: Int): Array[Int] =\n    if (v1 >= v2) Array(-1,-1,-1)\n    else hms(g.toDouble\/(v2-v1))\n  \n  def hms(h: Double): Array[Int] =\n    Array(h.toInt, (h*60 % 60).toInt, (h*3600 % 60).toInt)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334464,"user_id":null,"body":"object Sol {\n\n  \/\/ when v1 >= v2 return Array(-1,-1,-1)\n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n    if (v1 >= v2) Array(-1, -1, -1)\n    else {\n      val secondsInHous = 3600\n      val minutesInHour = 60\n      val secondsInMinutes = 60\n  \n      \/\/ B will reach A when (g + v1*time) == (v2*time). So:\n      val totalTimeInSeconds: Int = (g.toDouble\/(v2-v1) * secondsInHous).asInstanceOf[Int]\n      \n      \/\/ Converting total time to seconds, minutes and hours\n      val hours: Int = totalTimeInSeconds \/ secondsInHous\n      val minutes: Int = (totalTimeInSeconds - hours * secondsInHous) \/ secondsInMinutes\n      val seconds: Int = totalTimeInSeconds % secondsInMinutes\n  \n      Array(hours, minutes, seconds)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334465,"user_id":null,"body":"object Sol {\n\n  \n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n     if (v1 >= v2) Array(-1, -1, -1) else {\n      val h = (( g.toDouble\/(v2 - v1))*3600).toInt\n      val hours = h\/3600\n      val minutes = (h % 3600)\/60\n      val seconds = h%60\n      Array(hours, minutes, seconds)\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334466,"user_id":53,"body":"object Sol {\n\n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n    if (v1 >= v2) {\n      return Array(-1,-1,-1);\n    }\n    var t = (g * 3600) \/ (v2 - v1);\n    var h = t \/ 3600;\n    var m = (t % 3600) \/ 60;\n    var s = t % 60;\n    return Array(h, m, s);\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334467,"user_id":null,"body":"object Sol {\n\n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n\t\tif(v2 <= v1) Array(-1, -1, -1)\n\t\telse {\n\t\t\tval relativeSpeedPerSec = (v2 - v1) \/ 3600.0\n\t\t\tval resultPerSec = g \/ relativeSpeedPerSec\n\t\t\tval h = resultPerSec \/ 3600\n\t\t\tval m = (resultPerSec \/ 60) % 60\n\t\t\tval s = resultPerSec % 60\n\t\t\tArray(h.toInt, m.toInt, s.toInt)\n\t\t}\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334468,"user_id":573,"body":"import scala.math.Integral.Implicits._\n\nobject Sol {\n\n  def race(v1: Int, v2: Int, g: Int): Array[Int] =\n    if (v1 >= v2)\n      Array(-1, -1, -1)\n    else {\n      val secs = (g \/ ((v2-v1)\/3600d)).toInt\n      secs \/% 3600 match { case (h, s) => (h, s \/% 60) match { case (h, (m, s)) => Array(h, m, s) } }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334469,"user_id":null,"body":"object Sol {\n  def separate(t: Float, v: Array[Int]): List[Int] = \n    if (v.isEmpty) Nil else t.toInt :: separate((t - t.toInt) * v.head, v.tail)\n  \n  def race(v1: Int, v2: Int, g: Int): Array[Int] = \n    if (v1 >= v2) Array(-1,-1,-1)\n    else separate(g.toFloat \/ (v2 - v1).toFloat, Array(60, 60, 0)).toArray\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334470,"user_id":null,"body":"object Sol {\n\n  \/\/ when v1 >= v2 return Array(-1,-1,-1)\n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n      if (v2 <= v1) Array(-1, -1, -1)\n      else {\n        val tInS= (g \/ (v2 - v1).toDouble) * 3600\n        val h = tInS \/ 3600\n        val m = (tInS % 3600) \/ 60\n        val s = (tInS % 3600) % 60\n        Array(h.toInt, m.toInt, s.toInt)\n      }\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334471,"user_id":null,"body":"object Sol {\n\n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n    \n    val t = g.toFloat\/(v2-v1)\n    if (v2 >= v1){\n      Array(math.floor(t).toInt,\n            math.floor((t-math.floor(t).toInt)*60).toInt,\n            math.floor((t*60-math.floor(t*60))*60).toInt)\n      }\n    else Array(-1,-1,-1)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334472,"user_id":null,"body":"object Sol {\n\n  \/\/ when v1 >= v2 return Array(-1,-1,-1)\n  def race(v1: Int, v2: Int, g: Int): Array[Int] = {\n    if (v1 >= v2) {\n      Array(-1,-1,-1)\n    } else {\n      val dv = (v2 - v1) \/\/ Velocity\n      val time = g * 3600 \/ dv; \/\/ Time in seconds\n      \n      val sec = time % 60\n      val min = time \/ 60 % 60\n      Array(time \/ 3600, min, sec)\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e6f5e58f7817808e00002e":[{"id":334473,"user_id":null,"body":"object Divseven {\n\n  def seven(m: Long, depth: Int = 0): Array[Int] = {\n    if (m < 100) Array(m.toInt, depth)\n    else seven(m \/ 10 - 2 * (m % 10), depth + 1)\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334474,"user_id":null,"body":"object Divseven {\n\ndef seven(m: Long, s: Int = 0): Array[Int] = {\n  if (m < 100) Array(m.toInt, s)\n  else seven(m \/ 10 - 2 * (m % 10), s + 1)\n}\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334475,"user_id":null,"body":"object Divseven {\n  def seven(m: Long): Array[Int] = {\n    val res = doseven((m, 0))\n    Array(res._1.toInt, res._2)\n  }\n\n  @scala.annotation.tailrec\n  def doseven(pair: (Long, Int)): (Long, Int) = {\n    pair match {\n      case (m: Long, n: Int) =>\n        if (m < 100L)\n          (m, n)\n        else\n          doseven(((m \/ 10) - (2 * (m % 10)), n + 1))\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334476,"user_id":null,"body":"object Divseven {\n  \n  def seven(m: Long, steps: Int = 0): Array[Int] = {   \n    if (m < 100) Array(m.toInt, steps)\n    else seven(m\/10 - (m%10) * 2, steps + 1)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334477,"user_id":null,"body":"object Divseven {\n\n  def seven(m: Long): Array[Int] = {\n    @scala.annotation.tailrec\n    def loop(currentN: Long, nSteps: Int): (Long, Int) =\n      if (currentN < 100)\n        currentN -> nSteps\n      else {\n        val x = currentN \/ 10 - 2 * (currentN % 10)\n        loop(x, nSteps + 1)\n      }\n\n    loop(m, 0) match {\n      case (lastNumber, nSteps) => Array(lastNumber.toInt, nSteps)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334478,"user_id":492,"body":"object Divseven {\n\n  def seven(m: Long): Array[Int] = {\n    var mm = m; var cnt: Int = 0\n    while (mm > 99) {\n      val a0: Long = mm % 10\n      mm = (mm - a0) \/ 10 - 2 * a0 \n      cnt += 1\n    }\n    Array(mm.toInt, cnt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334479,"user_id":null,"body":"object Divseven {\n\n  def seven(m: Long): Array[Int] = {\n    def digits(number : Long, steps : Int) : Array[Int]  = {\n            if (number >= 100) digits(number \/ 10 - number % 10 * 2, steps + 1) else Array(number.toInt, steps)\n        }\n        digits(m, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334480,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Divseven {\n  @tailrec\n  def seven(m: Long, n: Int = 0): Array[Int] = {\n    if (m < 100) {\n      Array(m, n).map(_.toInt)\n    } else {\n      val result = m \/ 10 - (m % 10) * 2\n      seven(result, n + 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334481,"user_id":null,"body":"object Divseven {\n\n  def seven(m: Long): Array[Int] = {\n    if (m == 0) {\n      Array(0, 0)\n    }\n    else{\n      calculate(m \/ 10, m % 10, 0)\n    }\n  }\n  \n  def calculate(x: Long, y: Long, steps: Int): Array[Int] = { \n    (x - 2 * y) match {\n      case a if a \/ 100 == 0 => Array(a.toInt, steps + 1)\n      case a if a \/ 100 != 0 =>\n        calculate(a \/ 10, a % 10, steps + 1)\n      }\n\n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334482,"user_id":null,"body":"object Divseven {\n\n  def seven(m: Long, step: Int = 0): Array[Int] = {\n    if (m < 100)\n      Array(m.toInt, step)\n    else {\n      val y = m % 10\n      val x = m \/ 10\n      seven(x - 2 * y, step + 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e7280b40e1c4a06d0000aa":[{"id":334483,"user_id":492,"body":"object BestTravel {\n\n    def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n        val r = ls.combinations(k).toList\n        val s = r.map(_.sum).filter(_ <= t)\n        if (s.length != 0) s.max else -1\n    }\n}\n\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334484,"user_id":null,"body":"object BestTravel {\n\n    def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n        ls.combinations(k).map(_.sum).withFilter(_ <= t).maxOption.getOrElse(-1)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334485,"user_id":null,"body":"object BestTravel {\n\n    def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = \n      ls.combinations(k).map(_.sum).filter(_ <= t).maxOption.getOrElse(-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334486,"user_id":null,"body":"object BestTravel {\n\n    def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n       val x = ls.combinations(k).map(_.sum).filter(_ <= t)\n       if (x.isEmpty) return -1\n       x.max\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334487,"user_id":null,"body":"object BestTravel {\n\n  def choose_best_sum(travelDistance: Int, stops: Int, ls: Seq[Int]): Int = {\n    ls.combinations(stops).map(l => l.sum).filter(_ <= travelDistance).toList.sorted.lastOption.getOrElse(-1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334488,"user_id":null,"body":"import scala.math\n\nobject BestTravel {\n\n  def choose_best_sumRec(t: Int, k: Int, ls: Seq[Int], sumAcc: Int): Int = ls match {\n    case Nil => if (k == 0) sumAcc else -1\n    case head :: tail => {\n      if (k == 0) {\n        sumAcc\n      } else if (head > t - sumAcc) {\n        choose_best_sumRec(t, k, tail, sumAcc)\n      } else {\n        math.max (choose_best_sumRec(t, k - 1, tail, sumAcc + head), choose_best_sumRec(t, k, tail, sumAcc))\n      }\n    }\n  }\n\n  def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n    val sortedLs = ls.sorted(Ordering[Int].reverse)\n    choose_best_sumRec(t, k, sortedLs, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334489,"user_id":null,"body":"object BestTravel {\n\n  def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n    val distSum = ls.combinations(k).toList.map(_.sum).filter(_ <= t)\n    if (!distSum.isEmpty) distSum.max else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334490,"user_id":null,"body":"object BestTravel {\n\n    def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n      ls.combinations(k)\n      .filter(_.sum<=t)\n      match {\n        case x if x.isEmpty => -1\n        case x => x.map(_.sum).max\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334491,"user_id":null,"body":"object BestTravel {\n\n    def choose_best_sum(t: Int, k: Int, ls: Seq[Int]): Int = {\n    if (ls.length < k) -1\n    else ls.combinations(k).map(_.sum).filter(_ <= t).maxOption.getOrElse(-1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334492,"user_id":null,"body":"object BestTravel {\n\n    def choose_best_sum(maxTotalDistance: Int, requiredTowns: Int, distances: Seq[Int]): Int =\n      distances.combinations(requiredTowns).map(_.sum).filter( _ <= maxTotalDistance).maxOption.getOrElse(-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e86e212fce2aae75000060":[{"id":334493,"user_id":null,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    val ss = (a*a+b*b)*(c*c+d*d)\n    val cs = List(a*b,a*c,a*d,b*c,b*d,c*d)\n    val rs = cs.combinations(2).flatMap(l => List(l.sum, l.head - l.last))\n      .map(math.abs).toList\n    rs.combinations(2)\n      .filter(il => il.head*il.head + il.last*il.last == ss)\n      .map(_.sorted).toList.sortBy(_.head)\n      .map(l => l.head -> l.last)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334494,"user_id":null,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    val l = List(a,b,c,d)\n    val ss = (a*a+b*b)*(c*c+d*d)\n    val cs = List(a*b,a*c,a*d,b*c,b*d,c*d)\n    val rs = 0L :: cs.combinations(2).flatMap(l => List(l.sum, l.head - l.last)).map(math.abs).toList\n    rs.combinations(2)\n      .filter(il => il.head*il.head + il.last*il.last == ss)\n      .map(_.sorted).toList.sortBy(_.head)\n      .map(l => l.head -> l.last)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334495,"user_id":null,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    val subsums = List(a*b + c*d, a+b - c*d, a*c + b*d, a*c - b*d, a*d + b*c, a*d - b*c)\n    val n = (a*a + b*b) * (c*c + d*d)\n    val squares = subsums.map(x => x * x).distinct.sorted\n    println((0 to squares.length - 1).flatMap(x => (x to squares.length - 1).map(y => (squares(x), squares(y)))))\n    (0 to squares.length - 1).flatMap(x => (x to squares.length - 1).map(y => (squares(x), squares(y))))\n    .filter{case (a, b) => a + b == n}.map{case (a, b) => (math.sqrt(a).toLong, math.sqrt(b).toLong)}.toList    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334496,"user_id":null,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    val first  = Seq(math.abs(a * d - b * c), math.abs(a * c + b * d)).sorted\n    val second = Seq(math.abs(a * c - b * d), math.abs(a * d + b * c)).sorted\n    if (first == second) {\n      List((first.head, first.last))\n    } else {\n      List((first.head, first.last), (second.head, second.last)).sortBy { case (l, l1) => (l, l1) }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334497,"user_id":null,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    val (o11, o12) = (math.abs(a*c+b*d), math.abs(a*d - b*c))\n    val o1 = (o11 min o12, o11 max o12)\n    val (o21, o22) = (math.abs(a*d+b*c), math.abs(a*c - b*d))\n    val o2 = (o21 min o22, o21 max o22)\n    List(o1, o2).distinct.sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334498,"user_id":1228,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    val res = List( \n      Math.abs(b * c - a * d), \n      Math.abs(a * c + b * d), \n      Math.abs(b * d - a * c), \n      Math.abs(a * d + b * c)).sorted\n    if (res(0) == res(1) ) return List(( res(0), res(3) ))\n    return List( (res(0), res(3)), (res(1), res(2)) )\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334499,"user_id":492,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    var res: List[(Long, Long)] = List()\n    val e1: Long = Math.abs(a * c + b * d)\n    val f1: Long = Math.abs(a * d - b * c)\n    val e2: Long = Math.abs(a * c - b * d)\n    val f2: Long = Math.abs(a * d + b * c)\n    if (((e1 == f2) && (f1 == e2)) || ((e1 == e2) && (f1 == f2))) {\n      val cc: (Long, Long) = (Math.min(e1, f1), Math.max(e1, f1))\n      res = res :+ cc\n    } else {\n      val cc: (Long, Long) = (Math.min(e1, f1), Math.max(e1, f1))\n      val dd: (Long, Long) = (Math.min(e2, f2), Math.max(e2, f2))\n      if (cc._1 < dd._1) {\n        res = res :+ cc\n        res = res :+ dd\n      } else {\n        res = res :+ dd\n        res = res :+ cc\n      }\n    }\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334500,"user_id":492,"body":"object SqProd2Sum {\n\n  def prod2Sum(a: Long, b: Long, c: Long, d: Long): List[(Long, Long)] = {\n    var res: List[(Long, Long)] = List()\n    val e1: Long = Math.abs(a * c + b * d)\n    val f1: Long = Math.abs(a * d - b * c)\n    val e2: Long = Math.abs(a * c - b * d)\n    val f2: Long = Math.abs(a * d + b * c)\n    if (((e1 == f2) && (f1 == e2)) || ((e1 == e2) && (f1 == f2))) {\n      val cc: (Long, Long) = (Math.min(e1, f1), Math.max(e1, f1))\n      res = res :+ cc\n    } else {\n      val cc: (Long, Long) = (Math.min(e1, f1), Math.max(e1, f1))\n      val dd: (Long, Long) = (Math.min(e2, f2), Math.max(e2, f2))\n      if (cc._1 < dd._1) {\n        res = res :+ cc\n        res = res :+ dd\n      } else {\n        res = res :+ dd\n        res = res :+ cc\n      }\n    }\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55eeddff3f64c954c2000059":[{"id":334501,"user_id":573,"body":"object Kata {\n\n  def sumConsecutives(xs: List[Int]): List[Int] =\n    if (xs.isEmpty) Nil else xs.span(_ == xs.head) match { case (a, b) => a.sum :: sumConsecutives(b) }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334502,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\nobject Kata {\n\n  def sumConsecutives(xs: List[Int]): List[Int] = {\n    var sol = new ListBuffer[Int]()\n    var lastSeen: Int = xs(0);\n    var current: Int = 0;\n    for(i <- 0 until xs.length) {\n      if(xs(i)!=lastSeen){\n        sol+=current\n        lastSeen=xs(i)\n        current = lastSeen\n      }\n      else {\n        current=current+lastSeen\n      }\n    }\n    if(lastSeen==current) sol+=lastSeen\n    else sol+=current\n    sol.toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334503,"user_id":null,"body":"object Kata {\n\n  def sumConsecutives(xs: List[Int]): List[Int] = \n    if (xs.nonEmpty) List(xs.takeWhile(_ == xs.head).sum) ++ sumConsecutives(xs.dropWhile(x => x == xs.head)) else List()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334504,"user_id":636,"body":"object Kata {\n\n  def sumConsecutives(xs: List[Int]): List[Int] = {\n    xs.foldLeft((List[Int](),Option.empty[Int]))(\n      (ans, it) => if (ans._2.contains(it)) (ans._1.head+it :: ans._1.tail, Some(it)) else (it::ans._1,Some(it))\n    )._1.reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334505,"user_id":null,"body":"object Kata {\n\n  def sumConsecutives(ls: List[Int]): List[Int] = {\n    ls.foldLeft[List[List[Int]]](List()){ (arr, x) =>\n      if (arr != List() && arr.last.last == x)\n        arr.init :+ (arr.last :+ x)\n      else arr :+ List(x)\n    }.map(_.sum)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334506,"user_id":null,"body":"object Kata {\n  def sumConsecutives(xs: List[Int]): List[Int] = {\n        xs.foldLeft((0, List.empty[Int])) {\n            case ((_, Nil), x) => (x, List(x))\n            case ((cur, h :: tail), x) if cur == x => (cur, (h + x) :: tail)\n            case ((_, res), x) => (x, x :: res)\n        }._2.reverse\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334507,"user_id":1285,"body":"object Kata {\n\n  def sumConsecutives(xs: List[Int]): List[Int] = {\n    def sumInner(x: List[Int], newList: List[Int], lastElement: Int, sum: Int, done: Boolean): List[Int] =\n      if (done) newList.reverse\n      else if (x.isEmpty) sumInner(x, sum :: newList, 0, 0, done = true)\n      else if (x.head != lastElement) sumInner(x.tail, sum :: newList, x.head, x.head, done = false)\n      else sumInner(x.tail, newList, x.head, sum + x.head, done = false)\n\n    sumInner(xs.tail, List.empty, xs.head, xs.head, done = false)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334508,"user_id":null,"body":"object Kata {\n\n  def sumConsecutives(xs: List[Int]): List[Int] = {\n    if (xs.isEmpty) {\n      xs\n    } else {\n      val next::xxs = xs\n      helper(xxs, next, next)\n    }\n  }\n  \n  def helper(xs: List[Int], current: Int, acc: Int): List[Int] = {\n    if (xs.isEmpty) {\n      List(acc)\n    } else {\n      val next::xxs = xs\n      if (current == next) {\n        helper(xxs, current, acc+next)\n      } else {\n        acc::helper(xxs,next,next)\n      }\n      \n    }\n  } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334509,"user_id":null,"body":"object Kata {\n\n    def sumConsecutives(xs: List[Int]): List[Int] = {\n    xs.tail.foldLeft(List(xs take 1)) {\n      case (acc @ (lst @ hd :: _ ) :: tl, el) =>\n        if (el == hd) (el :: lst) :: tl\n        else (el :: Nil) :: acc\n    }.reverse.map(_.sum)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334510,"user_id":null,"body":"object Kata {\n\ndef sumConsecutives(xs: List[Int]): List[Int] = {\n    var rl: List[Int] = List()\n    var lastElement: Int = 0\n    var lastPartialSum: Int = 0\n    for (e <- xs) {\n      e match {\n        case e if e == lastElement => lastPartialSum += e\n        case e if e != lastElement => {\n          rl ++= List(lastPartialSum)\n          lastElement = e\n          lastPartialSum = e\n        }\n      }\n    }\n    rl ++= List(lastPartialSum)\n    if (xs.head == 0)\n      return rl\n    else return rl.tail\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55f2b110f61eb01779000053":[{"id":334511,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    if (a < b) (a to b).sum\n    else (b to a).sum\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334512,"user_id":573,"body":"object Sum {\n\n  def get_sum(a: Int, b: Int): Int =\n    ((a - b).abs + 1) * (a + b) \/ 2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334513,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    Range(a min b, a max b).inclusive.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334514,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = if (a == b) a else if (a<b) a.to(b).sum else b.to(a).sum\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334515,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    \/\/Good luck!\n    (a.min(b) to a.max(b)).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334516,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    var sum = 0\n    var larger = if (a < b) b else a\n    var smaller = if (a < b) a else b\n    \n    (smaller to larger).reduceLeft(_ + _)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334517,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    a.compare(b) match {\n      case 1 => {\n        (b to a).sum\n      }\n      case -1 => {\n        (a to b).sum\n      }\n      case _ => a\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334518,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    a.compare(b) match {\n      case 1 => {\n        (for (n <- b to a) yield n).sum\n      }\n      case -1 => {\n        (for (n <- a to b) yield n).sum\n      }\n      case _ => a\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334519,"user_id":null,"body":"object Sum {\n  def get_sum(a: Int, b: Int): Int = {\n    if (a > b) (b to a).sum else (a to b).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334520,"user_id":573,"body":"object Sum {\n\n  def get_sum(a: Int, b: Int): Int = {\n    val (min, max) = (a min b, a max b)\n    (max - min + 1) * (max + min) \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55f3da49e83ca1ddae0000ad":[{"id":334521,"user_id":573,"body":"object VolTank {\n\n  def tankVol(h: Int, d: Int, volume: Int): Int = {\n    val r = 0.5 * d                                  \/\/ radius\n    val length = volume \/ (math.Pi * r*r)            \/\/ length of cylinder from r and volume\n    val angle = 2 * math.acos((r-h) \/ r)             \/\/ central angle from h\n    val area = 0.5 * r*r * (angle - math.sin(angle)) \/\/ area of the circle of height h\n    (length * area).toInt                            \/\/ remaining volume\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334522,"user_id":53,"body":"import scala.math.acos\nimport scala.math.sin\nimport scala.math.Pi\n\nobject VolTank {\n\n  def tankVol(h: Int, d: Int, vt: Int): Int = {\n    val n = acos(1.0 - h.toFloat \/ (d.toFloat \/ 2.0)) * 2.0\n    val m = vt.toFloat * (n - sin(n)) \/ (2.0 * Pi)\n    return m.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334523,"user_id":null,"body":"object VolTank {\n  def len(r: Double, vt: Double) = vt \/ (math.Pi * r * r)\n  def area(h: Double, r: Double) =\n    r*r * math.acos((r-h)\/r) - (r-h)*math.sqrt(2*r*h - h*h)\n\n  def tankVol(h: Int, d: Int, vt: Int): Int =\n    math.floor(area(h, d\/2.0) * len(d\/2.0, vt)).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334524,"user_id":null,"body":"object VolTank {\n\n  def tankVol(h: Int, d: Int, vt: Int): Int = {\n    \/\/ your code\n    val hless = Array(h, d - h).min\n    val r = d\/2.toFloat\n    val ab = math.pow((2 * r - hless) * hless, 0.5)\n    val circleArea = math.Pi * r * r\n    val sectorArea = circleArea * ( math.asin(ab \/ r.toFloat) \/ math.Pi)\n    val arcuateArea = sectorArea - ab * (r-hless)\n    val area = h match {\n      case h if h > r => circleArea - arcuateArea\n      case _          => arcuateArea\n    }\n    return (area \/ circleArea * vt).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334525,"user_id":null,"body":"import scala.math._\n\nobject VolTank {\n\n  def tankVol(h: Int, d: Int, vt: Int): Int = {\n    \n    val r: Double = d \/2.0\n\n    if (h == r) {\n      return (vt \/ 2).floor.toInt\n    }\n    else if (h < r) {\n      val theta = acos((r - h) \/ r)\n      val bigSwept = (Pi - theta) * pow(r, 2)\n      val smallSwept = theta * pow(r, 2)\n      val opp = r * sin(theta)\n      val adj = r - h\n      val triangle = adj * opp \n      val areaOil = (Pi * pow(r, 2)) - bigSwept - triangle\n      val volOil = (areaOil \/ (Pi * pow(r, 2))) * vt\n\n      return volOil.floor.toInt\n\n    } else {\n      val theta = acos((h - r) \/ r)\n      val bigSwept = (Pi - theta) *  pow(r, 2)\n      val smallSwept = theta * pow(r, 2)\n      val opp = r * sin(theta)\n      val adj = h - r\n      val triangle = adj * opp \n      val areaOil = bigSwept + triangle\n      val volOil = (areaOil \/ (Pi * pow(r, 2))) * vt\n      return volOil.floor.toInt\n    }\n\n\n\n    \n    \n  }\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334526,"user_id":null,"body":"object VolTank {\n\n  def tankVol(h: Int, d: Int, vt: Int): Int = {\n    val r = d \/ 2.0\n    val l = vt \/ (Math.PI * r * r)\n    val theta = 2 * Math.acos((r-h)\/r)\n    val s = r * r * (theta - Math.sin(theta)) \/ 2\n    (s * l).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334527,"user_id":null,"body":"object VolTank {\n\n  def tankVol(h: Int, d: Int, vt: Int): Int = {\n    val r = d\/2.0\n    var t = 0.0\n    t = (if(h > r) h - r else r - h)\n    val c = Math.sqrt(r * r - t * t)\n    val theta = 2 * Math.acos(t\/r)\n    val s = Math.PI * r * r\n    val s1 = c * t\n    val s2 = theta * r * r \/ 2\n    val l = vt \/ s\n    val res = (if(h > r) s - s2 + s1 else s2 - s1)\n    (res * l).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334528,"user_id":null,"body":"object VolTank {\n\n  def tankVol(h: Int, d: Int, volume: Int): Int = {\n    val radius = 0.5 * d\n    val angle = 2 * math.acos((radius - h) \/ radius)\n    val length = volume \/ (math.Pi * radius * radius)\n    val area = 0.5 * radius * radius * (angle - math.sin(angle))\n    \n    (length * area).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334529,"user_id":null,"body":"object VolTank {\n\n  def tankVol(h: Int, d: Int, volume: Int): Int = {\n    val r = 0.5 * d\n    val length = volume \/ (math.Pi * r*r)\n    val angle = 2 * math.acos((r-h) \/ r)\n    val area = 0.5 * r*r * (angle - math.sin(angle))\n    (length * area).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334530,"user_id":null,"body":"object VolTank {\n\n  def tankVol(h: Double, d: Double, vt: Double): Int = {\n    val r = d\/2\n    val alpha = 2*math.acos((1 - h\/r))\n    val s = r*r*(alpha - math.sin(alpha))\/2\n    (s\/(math.Pi*r*r)*vt).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55f9bca8ecaa9eac7100004a":[{"id":334531,"user_id":573,"body":"object Kata {\n\n  def past(h: Int, m: Int, s: Int): Int =\n    (3_600 * h + 60 * m + s) * 1_000\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334532,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = {\n    val second = 1000\n    val minute = 60 * second\n    val hour = 60 * minute\n    \n    h * hour + m * minute + s * second\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334533,"user_id":1715,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = 1000 * (60 * ( 60 * h + m) + s) \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334534,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = {\n    val secToMillisec = 1000\n    val minToMillisec = 60 * secToMillisec\n    val hoursToMillisec = 60 * minToMillisec\n    \n    h * hoursToMillisec + m * minToMillisec + s * secToMillisec\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334535,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = (s + 60*m + 3600*h) * 1000\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334536,"user_id":null,"body":"object Kata {\n\n  def multiplyBy (a: Int) = (b:Int) => a * b\n  def secondsToMiliseconds = multiplyBy(1000)\n  def minutesToMiliseconds =  multiplyBy(60) andThen secondsToMiliseconds\n  def hourToMiliseconds = multiplyBy(60) andThen minutesToMiliseconds\n  def past(h: Int, m: Int, s: Int): Int =  hourToMiliseconds(h) + minutesToMiliseconds(m) + secondsToMiliseconds(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334537,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Long = {\n      val format = new java.text.SimpleDateFormat(\"HH:mm:ss\")\n      format.parse(s\"$h:$m:$s\").getTime()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334538,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = {\n    var sum = (h*60*60*1000)+(m*60*1000)+(s*1000)\n    sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334539,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = {\n     var mili=0\n      if (0 <= h && h<= 23 || 0 <= m && m<= 59 || 0 <= s && s<= 59) {\n        mili = (h * 3600000) + (m * 60000) + (s * 1000)\n      }\n      mili\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334540,"user_id":null,"body":"object Kata {\n  def past(h: Int, m: Int, s: Int): Int = hoursToMillis(h) + minutesToMillis(m) + secondsToMillis(s)\n\n  val secondsInMinute: Int = 60\n  val minutesInAnHour: Int = 60\n\n  val millisInASecond: Int = 1000\n  val millisInMinute: Int = millisInASecond * secondsInMinute\n  val millisInAnHour: Int = millisInMinute * minutesInAnHour\n\n  def hoursToMillis(h: Int): Int = h * millisInAnHour\n  def minutesToMillis(m: Int): Int = m * millisInMinute\n  def secondsToMillis(s: Int): Int = s * millisInASecond\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55fd2d567d94ac3bc9000064":[{"id":334541,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = n * n * n \n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334542,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = (for (i <- (n*(n-1)\/2 + 1) to n*(n+1)\/2) yield (2*i-1)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334543,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = n match {\n    case 1 => 1\n    case _ =>\n      val countNumbers = (1L to (n - 1)).sum\n      (2 * countNumbers + n) * n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334544,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Double): Long = \n  Iterator.iterate((1,n*(n-1)+1))(x => (x._1+1,x._2+2)).takeWhile(_._1<=n).toList.map(_._2.toLong).sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334545,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = {\n    def oddNumberCount(n: Long): Int = (1 to n.toInt).sum\n    def maxNumberForRow(n: Long): Int = oddNumberCount(n) * 2 - 1\n    val maxNumber: Int = maxNumberForRow(n)\n    val minNumber: Int = maxNumberForRow(n-1)\n    (maxNumber until minNumber by -2).sum\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334546,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = {\n    require(n >= 1)\n\n    val first = firstInRow(n)\n    val last = lastInRow(first, n)\n\n    (first to(last, step = 2)).sum\n  }\n\n\n  private def firstInRow(rowNumber: Long): Long = {\n    (rowNumber * (rowNumber - 1)) + 1\n  }\n\n  private def lastInRow(first: Long, rowNumber: Long): Long = {\n    first + 2 * (rowNumber - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334547,"user_id":null,"body":"object Solution {\n  \n  \n  def row_sum_odd_numbers(n: Long): Long = \n  {\n    val startNum:Long = (n-1 to 1 by -1).map(_*2).sum + 1\n    \n    if(n <= 1)startNum\n    else helper(startNum,startNum,2,n)\n  }\n  \n  def helper(startNum:Long,acc:Long, num:Long, end:Long):Long =\n  {\n    if(num > end) acc\n    else helper(startNum + 2,acc + (startNum+2),num + 1,end)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334548,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = \n  if (n==1) 1\n      else ((n*(n-1)+1)+(n*(n-1)+1)+2*(n-1))*n\/2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334549,"user_id":null,"body":"object Solution {\n  def row_sum_odd_numbers(n: Long): Long = {\n  var un:Long = 1 + n*(n-1)\n  var res:Long = 0\n  for (i <- 0 to n.toInt - 1) {\n    res += un + 2*i \n  }\n    return res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334550,"user_id":null,"body":"object Solution {\n\n  def row_sum_odd_numbers(n: Long): Long = {\n    if(n == 1) n\n    else n * n * n\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5613d06cee1e7da6d5000055":[{"id":334551,"user_id":null,"body":"object StepInPrimes {\n    def step(g: Int, m: Long, n: Long): String = {\n        def isPrime(value: Long): Boolean = (2 to Math.round(Math.sqrt(value)).toInt).find(i => value % i == 0).isEmpty\n        val result = (m+g to n).find( x => isPrime(x-g) && isPrime(x))\n        if (result.isEmpty) \"\" else (result.get - g, result.get).toString\n    }     \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334552,"user_id":573,"body":"object StepInPrimes {\n\n  def step(g: Int, m: Long, n: Long): String =\n    (m+g to n)\n      .collectFirst { case p if BigInt(p).isProbablePrime(4) && BigInt(p - g).isProbablePrime(4) => s\"${(p-g,p)}\" }\n      .getOrElse(\"\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334553,"user_id":null,"body":"object StepInPrimes {\n  def step(g: Int, m: Long, n: Long): String = {\n    def isPrime(n: Long): Boolean = {\n      if (n <= 3) return n > 1\n      if (n % 6 != 1 && n % 6 != 5) return false\n      for (i <- Range(5, math.sqrt(n).toInt+1, 6)) {\n        if (n % i == 0 || n % (i + 2) == 0)\n          return false\n      }\n      true\n    }\n\n    def twoDiff(nums: Array[Long], target: Long): List[(Long, Long)] = {\n      var map = scala.collection.mutable.Map[Long, Long]()\n      for (i <- 0 until nums.length) {\n        val v = nums(i)\n        if (isPrime(v)) {\n          val k = v - target\n          map.get(k) match {\n            case None => map += (v -> i)\n            case Some(x) => return List((k, v))\n          }\n        }\n      }\n      List.empty\n    }\n\n    twoDiff((m to n).toArray, g).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334554,"user_id":492,"body":"object StepInPrimes {\n    def step(g: Int, m: Long, n: Long): String = {\n        def isPrime(i: Long) = {\n            if( i % 2 == 0 ) false\n            else (3 to math.sqrt(i).toInt by 2).forall(x => i % x != 0)\n        }\n        lazy val res = for (i <- m to n - g if (isPrime(i) && isPrime(i + g))) yield (i, i + g)\n        if (res.isEmpty) \"\" else res(0).toString\n    }     \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334555,"user_id":null,"body":"object StepInPrimes {\n  def isPrime(n: Long): Boolean = {\n    for(i <- 2 to math.sqrt(n).toInt) if(n % i == 0) return false\n    true\n  }     \n\n  def step(diff: Int, min: Long, max: Long): String = {\n    for(leftElem <- min to max-diff){\n      if(isPrime(leftElem) && isPrime(leftElem + diff)){\n        val rightElem = leftElem + diff\n        return s\"($leftElem,$rightElem)\"\n      }\n    }\n    \"\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334556,"user_id":null,"body":"object StepInPrimes {\n\n  def isPrime(n: Long): Boolean = {\n    n != 1L && (2L to math.sqrt(n).toLong).forall(n % _ != 0)\n  }\n  def step(g: Int, m: Long, n: Long): String = {\n    (m to n)\n      .sliding(g + 1)\n      .dropWhile { case seq =>\n        !isPrime(seq.head) || !isPrime(seq.last)\n      }\n      .nextOption\n      .map { case seq =>\n        s\"(${seq.head},${seq.last})\"\n      }\n      .getOrElse(\"\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334557,"user_id":null,"body":"import scala.util.control.Breaks._\n\nobject StepInPrimes {\n\n  def isPrime(n: Long): Boolean = {\n    if (n == 2) {\n      true\n    } else if (n < 2 || n % 2 == 0) {\n      false\n    } else {\n      LazyList.from(3, 2).takeWhile(i => i * i < n + 1).forall(i => n % i != 0)\n    }\n  }\n  def step(g: Int, m: Long, n: Long): String = {\n    for (i <- m to n - g) {\n      if (isPrime(i) & isPrime(i + g)) {\n        return \"(\"+i.toString + \",\" + (i + g).toString + \")\"\n      }\n    }\n    return \"\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334558,"user_id":null,"body":"object StepInPrimes {\n    private def isPrime(n: Long): Boolean =\n      n > 1 && !(2 to n.toInt \/ 2).exists(e => n % e == 0)\n\n    def step(g: Int, m: Long, n: Long): String = {\n      (m to n).map(e => (e, e + g)).find {\n        case (x, y) => isPrime(x) && isPrime(y)\n      }.map(_.toString).getOrElse(\"\")\n    }     \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334559,"user_id":53,"body":"object StepInPrimes {\n    def step(g: Int, m: Long, n: Long): String = {\n      var i: Long = m\n      while (i < n - g) {\n        if (isPrime(i) && isPrime(i + g)) {\n          var j = i + g\n          return s\"($i,$j)\"\n        }\n        i += 1\n      }\n      return \"\"\n    }     \n    def isPrime(n: Long): Boolean = {\n      if (n % 2 == 0 || n % 3 == 0) {\n        return n < 4\n      }\n      var i: Long = 5\n      while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n          return false\n        }\n        i += 6\n      }\n      return true\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334560,"user_id":168,"body":"object StepInPrimes {\n    def step(g: Int, m: Long, n: Long): String =\n      (m to n - g).find {x => BigInt(x).isProbablePrime(10) && BigInt(x + g).isProbablePrime(10)}\n                  .map {x => s\"($x,${x + g})\" } getOrElse \"\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5616868c81a0f281e500005c":[{"id":334561,"user_id":573,"body":"object PrizeDraw {\n\n  val alphabet = ('a' to 'z').zipWithIndex.toMap.mapValues(_+1)\n\n  def rank(str: String, we: Array[Int], n: Int): String =\n    str match {\n      case \"\" => \"No participants\"\n      case _ =>\n        str\n          .split(\",\")\n          .zip(we)\n          .sortBy { case (name, weight) => (-weight * (name.size + name.toLowerCase.map(alphabet).sum), name) }\n          .map(_._1)\n          .lift(n-1)\n          .getOrElse(\"Not enough participants\")\n    }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334562,"user_id":null,"body":"object PrizeDraw {\n  def rank(st: String, we: Array[Int], n: Int): String = {\n    if (st.isEmpty) return \"No participants\"\n    val names = st.split(\",\")\n    if (n > names.length) return \"Not enough participants\"\n    names\n      .zip(we)\n      .map { case (name, weight) => (name, (name.length + name.toLowerCase.map(_.toInt - 96).sum) * weight) }\n      .sortWith { case ((n1, w1), (n2, w2)) => if (w1 == w2) n2 > n1 else w1 > w2 }\n      .apply(n - 1)\n      ._1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334563,"user_id":null,"body":"object PrizeDraw {\n\n  def rank(st: String, we: Array[Int], n: Int) =\n    if (st.isEmpty) \"No participants\"\n    else if (n > we.length) \"Not enough participants\"\n    else st\n    .split(\",\")\n    .map(x => x -> (x.length + x.toLowerCase.map(_ - 'a' + 1).sum))\n    .zip(we)\n    .map { case (fn -> som, w) => fn -> som * w }\n    .sortBy { case fn -> wn => (-wn, fn) }\n    .apply(n - 1)\n    ._1\n\n}\n\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334564,"user_id":null,"body":"object PrizeDraw {\n  \n  def rank(st: String, we: Array[Int], n: Int): String =\n    if (st.isEmpty) {\n      \"No participants\"\n    } else {\n      st.split(\",\")\n        .map(name => (name, name.map(_.toLower.toInt - 96).sum + name.length))\n        .zip(we)\n        .map {\n          case ((name, sum), weight) => (name, sum * weight)\n        }\n        .sortBy {\n          case (name, w) => (-w, name.toLowerCase)\n        }\n        .drop(n - 1)\n        .map(_._1)\n        .headOption\n        .getOrElse(\"Not enough participants\")\n    }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334565,"user_id":null,"body":"object PrizeDraw {\n  def getLetterValue(letter: String) = {\n    val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\");\n    \n    alphabet.indexOf(letter.toLowerCase) + 1\n  }\n  \n  def getPersonResult(name: String, weight: Int) = {\n    val nameLength = name.length\n    val nameLettersValue = name.split(\"\").map(letter => getLetterValue(letter)).reduceLeft[Int](_+_)\n       \n    (nameLength + nameLettersValue) * weight\n  }\n  \n  def getWinnersList(participants: Array[String], weights: Array[Int]) = {\n    participants zip weights map {\n      t => (t._1, getPersonResult(t._1, t._2))\n    } sortBy(t => (-t._2, t._1))\n  }\n\n  def rank(st: String, we: Array[Int], n: Int): String = {\n    if (Option(st).getOrElse(\"\").isEmpty) {\n      return \"No participants\"\n    }\n    \n    if (n > we.length) {\n      return \"Not enough participants\"\n    }\n\n    getWinnersList(st.split(\",\"), we)(n - 1)._1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334566,"user_id":null,"body":"object PrizeDraw {\n  \n  def rank(st: String, we: Array[Int], n: Int): String = {\n    \n    if(st.isEmpty) {\n      return \"No participants\"\n    }\n    \n    val names = st.split(\",\")\n\n    if(n > names.length) {\n      return \"Not enough participants\"\n    }\n\n    def calculateScore(name: String): Int = {\n      name.toLowerCase().toCharArray.map(_.toInt - 96).sum + name.length\n    }\n\n    val sortedResult = names\n      .map(name => (name, calculateScore(name)))\n      .zipWithIndex\n      .map {\n        case ((name, score), index) => (name, score * we(index))\n      }\n      .sortBy(x => (-x._2, x._1))\n\n    println(sortedResult.toList)\n\n    sortedResult(n-1)._1\n    \n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334567,"user_id":null,"body":"object PrizeDraw extends App {\n  def rank(st: String, we: Array[Int], n: Int): String = {\n    val alphabet = \" abcdefghijklmnopqrstuvwxyz\"\n    val nameArr = st.split(\",\")\n    var sumList = List[Int]()\n\n    if (st.isEmpty) return \"No participants\"\n    else if (n > nameArr.length) return \"Not enough participants\"\n    else {\n\n      for {\n        i <- nameArr.indices\n      } yield {\n        var sum = 0\n        for (individualLetter <- nameArr(i).toLowerCase) yield {\n          sum += alphabet.indexOf(individualLetter)\n        }\n        sum += nameArr(i).length\n        sum = sum * we(i)\n        sumList = sumList.appended(sum)\n      }\n      val sumListSorted = sumList.sorted.reverse\n      val winningNum = sumListSorted(n - 1)\n      val winningIndex = sumList.indexOf(winningNum)\n      val winningIndexSorted = sumListSorted.indexOf(winningNum)\n\n      var winningIndices = List[Int]()\n      var winningNames = List[String]()\n      val actualWinnerIndex = n - 1 - winningIndexSorted\n      for (x <- sumList.indices) yield {\n        if (sumList(x) == winningNum) winningIndices = winningIndices.appended(x)\n      }\n      for (y <- winningIndices) yield {\n        winningNames = winningNames.appended(nameArr(y))\n      }\n      winningNames = winningNames.sorted\n      winningNames(actualWinnerIndex)\n    }\n  }\n\n\/\/  println(rank(\"Elijah,Chloe,Elizabeth,Matthew,Natalie,Jayden\", Array(1, 3, 5, 5, 3, 6), 2))\n\/\/   println(rank(\"Addison,Jayden,Sofia,Michael,Andrew,Lily,Benjamin\", Array(4, 2, 1, 4, 3, 1, 2), 4))\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334568,"user_id":null,"body":"object PrizeDraw extends App {\n  def rank(st: String, we: Array[Int], n: Int): String = {\n    val alphabet = \" abcdefghijklmnopqrstuvwxyz\"\n    val nameArr = st.split(\",\")\n    var sumList = List[Int]()\n\n    if (st.isEmpty) return \"No participants\"\n    else if (n > nameArr.length) return \"Not enough participants\"\n    else {\n\n      for {\n        i <- nameArr.indices\n      } yield {\n        var sum = 0\n        for (individualLetter <- nameArr(i).toLowerCase) yield {\n          sum += alphabet.indexOf(individualLetter)\n        }\n        sum += nameArr(i).length\n        sum = sum * we(i)\n        sumList = sumList.appended(sum)\n      }\n      val sumListSorted = sumList.sorted.reverse\n      val winningNum = sumListSorted(n - 1)\n      val winningIndex = sumList.indexOf(winningNum)\n      val winningIndexSorted = sumListSorted.indexOf(winningNum)\n\n      var winningIndices = List[Int]()\n      var winningNames = List[String]()\n      val actualWinnerIndex = n - 1 - winningIndexSorted\n      for (x <- sumList.indices) yield {\n        if (sumList(x) == winningNum) winningIndices = winningIndices.appended(x)\n      }\n      for (y <- winningIndices) yield {\n        winningNames = winningNames.appended(nameArr(y))\n      }\n      winningNames = winningNames.sorted\n      winningNames(actualWinnerIndex)\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334569,"user_id":null,"body":"object PrizeDraw {\n  \n  def rank(st: String, we: Array[Int], n: Int): String = {\n    val alphabet = \" abcdefghijklmnopqrstuvwxyz\"\n    val nameArr = st.split(\",\")\n    var sumList = List[Int]()\n\n    if (st.isEmpty) return \"No participants\"\n    else if (n > nameArr.length) return \"Not enough participants\"\n    else {\n\n      for {\n        i <- nameArr.indices\n      } yield {\n        var sum = 0\n        for (individualLetter <- nameArr(i).toLowerCase) yield {\n          sum += alphabet.indexOf(individualLetter)\n        }\n        sum += nameArr(i).length\n        sum = sum * we(i)\n        sumList = sumList.appended(sum)\n      }\n      val sumListSorted = sumList.sorted.reverse\n      val winningNum = sumListSorted(n - 1)\n      val winningIndex = sumList.indexOf(winningNum)\n      val winningIndexSorted = sumListSorted.indexOf(winningNum)\n\n      var winningIndices = List[Int]()\n      var winningNames = List[String]()\n      val actualWinnerIndex = n - 1 - winningIndexSorted\n      for (x <- sumList.indices) yield {\n        if (sumList(x) == winningNum) winningIndices = winningIndices.appended(x)\n      }\n      for (y <- winningIndices) yield {\n        winningNames = winningNames.appended(nameArr(y))\n      }\n      winningNames = winningNames.sorted\n      winningNames(actualWinnerIndex)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334570,"user_id":null,"body":"object PrizeDraw {\n  \n  def rank(st: String, we: Array[Int], n: Int): String = {\n    val alphabet = \" abcdefghijklmnopqrstuvwxyz\"\n    val nameArr = st.split(\",\")\n    var sumList = List[Int]()\n\n    if (st.length == 0) return \"No participants\"\n    else if (n > nameArr.length) return \"Not enough participants\"\n    else {\n\n      for {\n        i <- nameArr.indices\n      } yield {\n        var sum = 0\n        for (individualLetter <- nameArr(i).toLowerCase) yield {\n          \/\/        println(individualLetter)\n          \/\/        println(alphabet.indexOf(individualLetter))\n          sum += alphabet.indexOf(individualLetter)\n        }\n        sum += nameArr(i).length\n        sum = sum * we(i)\n        \/\/      if (sumList.contains(sum))\n\n        sumList = sumList.appended(sum)\n      }\n      val sumListSorted = sumList.sorted.reverse\n      val winningNum = sumListSorted(n - 1)\n      val winningIndex = sumList.indexOf(winningNum)\n      val winningIndexSorted = sumListSorted.indexOf(winningNum)\n      println(s\"winning index = $winningIndex\")\n      println(s\"winning index sorted = $winningIndexSorted\")\n\n      var winningIndices = List[Int]()\n      var winningNames = List[String]()\n      var actualWinnerIndex = n - 1 - winningIndexSorted\n      for (x <- sumList.indices) yield {\n        if (sumList(x) == winningNum) winningIndices = winningIndices.appended(x)\n      }\n      for (y <- winningIndices) yield {\n        winningNames = winningNames.appended(nameArr(y))\n      }\n      winningNames = winningNames.sorted\n      \/\/    println(winningNames)\n      \/\/    println(s\"${nameArr(winningIndex)} = $winningNum\")\n      \/\/    println(sumListSorted)\n      winningNames(actualWinnerIndex)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"561e9c843a2ef5a40c0000a4":[{"id":334571,"user_id":null,"body":"object GapInPrimes {\n  def isPrime(candidate: Int): Boolean = {\n    if (candidate == 2) true\n    else if (candidate%2 == 0) false\n    else (3 to Math.sqrt(candidate).toInt by 2).forall(d => candidate%d != 0)\n  }\n\n  def gap(g: Int, m: Long, n: Long): String = {\n    val primes = LazyList.from(m.toInt).takeWhile(_ <= n).filter(isPrime)\n    primes match {\n      case LazyList() => \"\"\n      case list => list.zip(primes.tail).find(a => a._2-a._1==g).map(a => s\"(${a._1},${a._2})\").getOrElse(\"\")\n    }\n  }\n}  ","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334572,"user_id":573,"body":"object GapInPrimes {\n\n  def gap(g: Int, m: Long, n: Long): String =\n    LazyList\n      .range(m, n)\n      .filter(isPrime)\n      .sliding(2)\n      .collectFirst { case Seq(p, q) if q - p == g => (p, q).toString }\n      .getOrElse(\"\")\n\n  def isPrime(n: Long): Boolean = BigInt(n).isProbablePrime(4)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334573,"user_id":null,"body":"object GapInPrimes {\n  import scala.annotation.tailrec\n\n  def isPrime(n: Long): Boolean = n match {\n    case 0 | 1 => false\n    case 2 | 3 => true\n    case _ => {\n      (2 to Math.sqrt(n.toDouble).toInt).forall(y => n % y != 0)\n    }\n  }\n\n  def findNextPrime(n: Long): Long = {\n    @tailrec\n    def iterate(m: Long): Long = {\n      if (isPrime(m)) m else iterate(m + 1)\n    }\n    iterate(n)\n  }\n\n  def gap(g: Int, m: Long, n: Long): String = {\n    @tailrec\n    def matches(v1: Long, v2: Long): String = {\n      if (v2 > n) \"\"\n      else {\n        if (v2 - v1 == g) s\"($v1,$v2)\" else matches(v2, findNextPrime(v2 + 1))\n      }\n    }\n    val v = findNextPrime(m)\n    matches(v, findNextPrime(v))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334574,"user_id":null,"body":"object GapInPrimes {\n  def gap(g: Int, m: Long, n: Long): String = {\n    \/\/ your code\n    def isPrime(x: Long) = ! ((2L to math.sqrt(x).toLong) exists (x % _ == 0 ))\n    (m to n) find isPrime match {\n      case Some(x) => (x + 1 to n) find isPrime match {\n        case Some(y) => if (y - x == g) s\"($x,$y)\" else gap(g, y, n)\n        case None => \"\"\n      }\n      case None => \"\"\n    }\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334575,"user_id":null,"body":"object GapInPrimes {\n  def gap(g: Int, m: Long, n: Long): String = {\n    BigInt(m).to(n).filter(_.isProbablePrime(4))\n      .sliding(2)\n      .filter { ls =>\n        ls(1) - ls(0) == g\n      }.take(1).toList match {\n        case ls::tail => s\"(${ls(0)},${ls(1)})\"\n        case Nil => \"\"\n      }\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334576,"user_id":null,"body":"object GapInPrimes {\n  def gap(g: Int, m: Long, n: Long): String = {\n    @scala.annotation.tailrec\n    def primeHelper(num: Long, divisor: List[Int]): Boolean = {\n      if(divisor.head == 1) true\n      else if(num % divisor.head == 0) false\n      else primeHelper(num, divisor.tail)\n    }\n    @scala.annotation.tailrec\n    def getGap(primes: List[Long], current: Long, prev: Long, g: Int): String = {\n      if(primes.isEmpty) \"\"\n      else if(current - prev == g) s\"($prev,$current)\"\n      else getGap(primes.tail, primes.head, current, g)\n    }\n    if(m == n) return \"\"\n    val primeNumbers =  (m to n).map(number =>\n      (number, primeHelper(number, (1 to math.sqrt(number).toInt).toList.reverse))\n    ).filter(pair => pair._2).map(pair => pair._1).toList\n    getGap(primeNumbers, primeNumbers.head, 0, g)\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334577,"user_id":null,"body":"object GapInPrimes {\n  def isPrime(n: Long): Boolean = {\n    if (n == 2) true\n    else if (n % 2 == 0) false\n    else (3 to math.sqrt(n.toDouble).toInt by 2)\n      .forall(n % _ != 0)\n  }\n  def nextPrime(n: Long): Long = {\n    var i = n + n % 2 + 1\n    while (!isPrime(i)) i += 2\n    i\n  }\n  def gap(g: Int, m: Long, n: Long): String = {\n    val p = (m to n-g)\n      .dropWhile{ x =>\n        val isP = isPrime(x)\n        !isP || (isP && nextPrime(x) - x != g)\n      }.headOption\n    p match {\n      case Some(v) => (v, v + g).toString()\n      case _ => \"\"\n    }\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334578,"user_id":null,"body":"object GapInPrimes {\n  def gap(g: Int, m: Long, n: Long): String = {\n    def isPrime(i: Long): Boolean =\n      !(2L until i).exists(n => i % n == 0)\n\n    (m to n).find(i => isPrime(i) && isPrime(i + g) && !(i + 1 until i + g).exists(isPrime)).map(i => s\"($i,${i + g})\").getOrElse(\"\")\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334579,"user_id":null,"body":"object GapInPrimes {\n  def isPrime(n: Long): Boolean = BigInt(n).isProbablePrime(4)\n\n  def gap(gap: Int, start: Long, end: Long): String =\n   LazyList\n    .range(start, end)\n    .filter(isPrime)\n    .sliding(2)\n    .collectFirst{ case Seq(a, b) if b - a == gap => (a, b).toString }\n    .getOrElse(\"\")\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334580,"user_id":1285,"body":"object GapInPrimes {\n  def gap(g: Int, m: Long, n: Long): String = {\n    val primes = new Array[Long]((n - m).toInt + 1)\n    def isPrime(num: Long): Boolean = {\n      if (primes((num - m).toInt) == 1) return true\n      if (primes((num - m).toInt) == -1) return false\n\n      val root: Long = Math.sqrt(num).toLong + 1\n      def loop(cur: Long): Boolean = {\n        if (cur > root) true\n        else if (num % cur == 0) false\n        else loop(cur + 1)\n      }\n      val res = loop(2)\n      primes((num - m).toInt) = if (res) 1 else -1\n      res\n    }\n\n    def checkLoop(i: Long): String = {\n      if (i + g > n) \"\"\n      else if (isPrime(i) && isPrime(i + g)) {\n        val primeBetween = List.range(i + 1, i + g - 1).filter(isPrime(_)).size > 0\n        if (primeBetween) checkLoop(i + 1) else s\"($i,${i + g})\"\n      }\n      else checkLoop(i + 1)\n    }\n    checkLoop(m)\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5629db57620258aa9d000014":[{"id":334581,"user_id":2178,"body":"object StringMix {\n  def mix_strings(s1: String, s2: String): String = {\n    val f1 = s1.filter(x => x >= 'a' && x <= 'z').groupMapReduce(identity)(_ => 1)(_ + _)\n    val f2 = s2.filter(x => x >= 'a' && x <= 'z').groupMapReduce(identity)(_ => 1)(_ + _)\n    for {\n      k <- (f1.keys ++ f2.keys).toSet[Char]\n      n1 = f1.getOrElse(k, 0)\n      n2 = f2.getOrElse(k, 0)\n      ma = math.max(n1, n2).toInt\n      if ma > 1\n    } yield {\n      if (n1 == n2) (\"=\", ma, k.toString)\n      else if (n1 == ma) (\"1\", ma, k.toString)\n      else (\"2\", ma, k.toString)\n    }\n  }.toList.map(x => s\"${x._1}:${x._3 * x._2}\").sortBy(x => (-x.length, x)).mkString(\"\/\")\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334582,"user_id":null,"body":"object StringMix extends App{\n\n  def mix_strings(s1: String, s2: String): String = {\n    val m = for (let <- 'a' to 'z')\n    yield (let -> (s1.count(_ == let), s2.count(_ == let)))\n    m.map{\n      case (chr, numbers) => numbers match {\n        case numbers if numbers._1 > numbers._2 => \"1:\"+ chr.toString*numbers._1\n        case numbers if numbers._1 < numbers._2 => \"2:\"+ chr.toString*numbers._2\n        case _ => \"=:\"+chr.toString*numbers._2\n      }\n    }.filter(_.length > 3).sortBy(s => (-s.length, s(0))).mkString(\"\/\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334583,"user_id":null,"body":"object StringMix {\n\n  def mix_strings(s1: String, s2: String): String = {\n    def getCountAndPrefix(c: Char): (Int, String) = {\n      val s1CharCount = s1.count(_ == c)\n      val s2CharCount = s2.count(_ == c)\n\n      if (s1CharCount < s2CharCount) (s2CharCount, \"2:\")\n      else if (s1CharCount > s2CharCount) (s1CharCount, \"1:\")\n      else (s1CharCount, \"=:\")\n    }\n\n    def checkChar(c: Char): Boolean = c.isLetter && c.isLower && (s1.count(_ == c) > 1 || s2.count(_ == c) > 1)\n\n    (s1.toSet.filter(checkChar) ++ s2.toSet.filter(checkChar)).toList.map(c => (c.toString, getCountAndPrefix(c))).sortBy(f => (-f._2._1, f._2._2, f._1)).map(f => s\"${f._2._2}${f._1 * f._2._1}\").mkString(\"\/\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334584,"user_id":null,"body":"object StringMix {\n\n  def mix_strings(s1: String, s2: String): String = {\n    def makeMap(s: String) = s.foldLeft(Map.empty[Char, Int]){ (map, item) =>\n      if(('a' to 'z').contains(item)) map.updated(item, map.getOrElse(item, 0) + 1)\n      else map\n    }\n\n    val s1Map = makeMap(s1)\n    val s2Map = makeMap(s2)\n\n    ('a' to 'z').map(c => {\n        val s1Count = s1Map.getOrElse(c, 0)\n        val s2Count = s2Map.getOrElse(c, 0)\n\n        if(s1Count.max(s2Count) <= 1) \"\"\n        else if(s1Count == s2Count) \"=:\" + c.toString * s1Count\n        else if(s1Count > s2Count) \"1:\" + c.toString * s1Count\n        else \"2:\" + c.toString * s2Count\n\n\n      })\n      .filterNot(_.isEmpty)\n      .toList.sortWith((a, b) =>\n        if(a.length == b.length) a < b\n        else a.length > b.length\n      )\n      .mkString(\"\/\")\n\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334585,"user_id":null,"body":"object StringMix {\n  def mix_strings(s1: String, s2: String): String = {\n    def wc(s: String): Map[Char, Int] = s.replaceAll(\"[^a-z]\", \"\").toCharArray\n      .groupBy(c => c).map(t => (t._1, t._2.length))\n\n    val (s1Map, s2Map) = (wc(s1), wc(s2))\n    ('a' to 'z')\n      .map(c => (s1Map.getOrElse(c, 0), s2Map.getOrElse(c, 0)) match {\n        case (c1, c2) if c1 <= 1 && c2 <= 1 => null\n        case (c1, c2) if c1 > c2 => ('1', c, c1)\n        case (c1, c2) if c1 < c2 => ('2', c, c2)\n        case (c1, c2) if c1 == c2 => ('=', c, c1)\n      }).filter(_ != null)\n      .sortBy(t => (-t._3, t._1))\n      .map(t => s\"${t._1}:${t._2.toString * t._3}\")\n      .mkString(\"\/\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334586,"user_id":null,"body":"object StringMix {\n\n  def mix_strings(s1: String, s2: String): String = {\n    ('a' to 'z').map(c => {\n      val s1Count = s1.count(_ == c)\n      val s2Count = s2.count(_ == c)\n      if(s1Count > s2Count)  \n        (1, c, s1Count)\n      else if (s1Count < s2Count)\n        (2, c, s2Count)\n      else\n        (3, c, s1Count)\n      }\n      ).filter(x => x._3>1)\n       .sortWith((x,y) => if(x._3 != y._3) (x._3 > y._3) else (x._1 < y._1 ))\n       .map(x => x._1 match {\n           case 1 => (\"1\", x._2, x._3)\n           case 2 => (\"2\", x._2, x._3)\n           case 3 => (\"=\", x._2, x._3)\n         }\n           )\n       .map(x => x._1 + \":\" + repeateString(x._2.toString, x._3))\n       .mkString(\"\/\")\n      \n  }\n  \n  def repeateString(str: String, n: Int): String = if(n == 1) str else str + repeateString(str, n-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334587,"user_id":null,"body":"object StringMix {\n\n  def mix_strings(s1: String, s2: String): String = {\n    val list1 = sToList(s1)\n    val list2 = sToList(s2)\n    \n    val list11 = list1.filter(x => x._2 > count(x._1, list2)).map(x => (x._1, x._2, \"1\"))\n    val list22 = list2.filter(x => x._2 > count(x._1, list1)).map(x => (x._1, x._2, \"2\"))\n    val listCommon = list1.filter(x => x._2 == count(x._1, list2)).map(x => (x._1, x._2, \"=\"))\n    \n    (list11 ++ list22 ++ listCommon).sortBy(x=> (-x._2, x._3)).map(x => x._3 + \":\" + x._1.toString * x._2).mkString(\"\/\")\n  }\n  \n  def sToList(s:String): List[(Char,Int)] = {\n      s.map(x => (x, s.count(_ == x))).filter(x => x._2 > 1 && x._1.isLower).distinct.sortBy(x=> (-x._2, x._1)).toList\n    }\n    \n    def count(c:Char, lst:List[(Char, Int)]): Int = {\n      val newLst = lst.filter(x => x._1 == c)\n      if (newLst.isEmpty) 0\n      else newLst.head._2\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334588,"user_id":null,"body":"object StringMix {\n\n  def toFrequency(s: String): List[(String, Int)] = {\n    s.filter(_.isLower)\n      .groupBy(identity)\n      .map { case (a, b) => (a.toString, b.length) }\n      .filter(_._2 > 1)\n      .toList.sorted\n  }\n  \n  def merge(x: List[(String, Int)], y: List[(String, Int)]): List[(String, String)] = (x, y) match {\n    case (Nil, Nil) => Nil\n    case (x, Nil) => x.map { case (e1, f) => (\"1:\", e1 * f) }\n    case (Nil, y) => y.map { case (e2, f) => (\"2:\", e2 * f) }\n    case (x1 :: xs, y1 :: ys) =>\n      if (x1._1 < y1._1) (\"1:\", x1._1 * x1._2) :: merge(xs, y)\n      else if (y1._1 < x1._1) (\"2:\", y1._1 * y1._2) :: merge(x, ys)\n      else if (x1._2 > y1._2) (\"1:\", x1._1 * x1._2) :: merge(xs, ys)\n      else if (y1._2 > x1._2) (\"2:\", y1._1 * y1._2) :: merge(xs, ys)\n      else (\"=:\", x1._1 * y1._2) :: merge(xs, ys)\n  }\n  \n  def mix_strings(s1: String, s2: String): String = {\n    merge(toFrequency(s1), toFrequency(s2))\n    .sortBy { x => (-x._2.length, x._1) }\n    .map{ case (a, b) => s\"${a}${b}\"}.mkString(\"\/\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334589,"user_id":null,"body":"object StringMix {\n\n  sealed trait Room {\n    def order: Int\n\n    def code: String\n  }\n\n  object Room {\n    implicit val RoomOrdering: Ordering[Room] = Ordering.by(_.order)\n\n    case object Eq extends Room {\n      override def order: Int = 3\n\n      override def code: String = \"=\"\n    }\n\n    case object First extends Room {\n      override def order: Int = 1\n\n      override def code: String = \"1\"\n    }\n\n    case object Second extends Room {\n      override def order: Int = 2\n\n      override def code: String = \"2\"\n    }\n  }\n\n  case class Entry(char: Char, count: Int, room: Room)\n\n  val lower = 'a' to 'z'\n\n  def filter(s: String): String =\n    s.filter(lower.contains)\n\n  def count(s: String): Map[Char, Int] = {\n    s.groupBy(identity)\n      .collect {\n        case (k, v) if v.length > 1 => k -> v.length\n      }\n  }\n\n  def mix_strings(s1: String, s2: String): String = {\n    import Room.{Eq, First, Second}\n\n    val (count1, count2) = (count(filter(s1)), count(filter(s2)))\n    val chars = (count1.keys ++ count2.keys).toList.distinct\n\n    val entries =\n      chars\n        .map { c =>\n          val c1 = count1.getOrElse(c, 0)\n          val c2 = count2.getOrElse(c, 0)\n          if (c1 == c2) {\n            Entry(c, c1 \/* c2 *\/ , Eq)\n          } else if (c1 > c2) {\n            Entry(c, c1, First)\n          } else {\n            Entry(c, c2, Second)\n          }\n        }\n\n    entries\n      .sortBy(x => (x.count, x.room, x.char))(Ordering.Tuple3(Ordering.Int.reverse, Room.RoomOrdering, Ordering.Char))\n      .map { case Entry(char, count, room) =>\n        s\"${room.code}:${char.toString * count}\"\n      }\n      .mkString(\"\/\")\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334590,"user_id":null,"body":"object StringMix {\n\n  def mix_strings(s1: String, s2: String): String = {\n    val filteredS1 = s1.filter(char => char.isLower).groupBy(item => item).values.toList.filter(_.length > 1)\n    val filteredS2 = s2.filter(char => char.isLower).groupBy(item => item).values.toList.filter(_.length > 1)\n    val commonS1S2 = filteredS1.filter(filteredS2.contains).map(i => (\"=\",i))\n    val resS1 = filteredS1.filterNot(item => commonS1S2.contains(item) || filteredS2.exists(item2 => item2.contains(item))).map(i => (\"1\",i))\n    val resS2 = filteredS2.filterNot(item => commonS1S2.contains(item) || filteredS1.exists(item2 => item2.contains(item))).map(i => (\"2\",i))\n    val res = (resS1 ++ resS2 ++ commonS1S2).sortWith((item1, item2) => {\n      if (item1._2.length == item2._2.length) {\n        if (item1._1 == item2._1) item1._2 < item2._2\n        else item1._1 < item2._1\n      }\n      else item1._2.length > item2._2.length\n    })\n    res.map(item => s\"${item._1}:${item._2}\/\").mkString(\"\",\"\",\"\").dropRight(1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"562b384167350ac93b00010c":[{"id":334591,"user_id":53,"body":"import java.util.HashSet\n\nobject WeirdPrimeGen {\n\n  private def gcd(a: Long, b: Long): Long = {\n    if (b == 0) a else gcd(b, a % b)\n  }\n  \n  def countOnes(n: Long): Long = {\n    var a: Long = 7\n    var i: Long = 1\n    var s: Long = 1\n    while (i < n) {\n      i += 1\n      val g: Long = gcd(i, a)\n      a += g\n      if (g == 1) s += 1\n    }\n    s\n  }\n  \n  def maxPn(n: Long): Long = {\n    var a: Long = 7\n    var i: Long = 1\n    var k: Long = 0\n    var m: Long = 0\n    val r: HashSet[Long] = new HashSet[Long]()\n    while (k <= n) {\n      i += 1\n      val g: Long = gcd(i, a)\n      a += g\n      if (!r.contains(g)) {\n        k += 1\n        r.add(g)\n        if (g > m) m = g\n      }\n    }\n    m\n  }\n  \n  def anOverAverage(n: Long): Int = {\n    var a: Long = 7\n    var i: Long = 1\n    var s: Long = 0\n    while (s < n) {\n      i += 1\n      val g: Long = gcd(i, a)\n      a += g\n      if (g > 1) s += 1\n    }\n    (a \/ i).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334592,"user_id":null,"body":"object WeirdPrimeGen {\n\n  \/\/ 1: an(n)\n\n  def an(n: Long): List[Long] = aIter.take(n.toInt).toList\n\n  def aIter: Iterator[Long] = {\n    Iterator.unfold((1L, 7L)) { case (i, x) => \n      val x1 = x + gcd(i + 1, x)\n      val s1 = (i + 1, x1)\n      Some((x, s1))}\n  }\n\n  def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n\n  \/\/ 2: gn(n)\n\n  def gn(n: Long): List[Long] = gIter.take(n.toInt).toList\n\n  def gIter: Iterator[Long] = aIter.sliding(2).map {xs => xs(1) - xs(0)}\n\n  \/\/ 3: countOnes(n)\n\n  def countOnes(n: Long): Long = (1 :: gn(n: Long)).dropRight(1).count(_ == 1)\n    \n  \/\/ 4: p(n)\n\n  def p(n: Long): List[Long] = {\n    gIter.filterNot(_ == 1).distinct.take(n.toInt).toList\n  }\n\n  \/\/ 5: maxPn(n)\n\n  def maxPn(n: Long): Long = p(n).max\n\n  \/\/ 6: anOver(n)\n\n  def anOver(n: Long): List[Long] = {\n    aIter.zipWithIndex.zip(gIter)\n                      .filter { case ((a, i), g) => g != 1 }\n                      .map { case ((a, i), _) => a \/ i}\n                      .take(n.toInt).toList\n  }\n\n  \/\/ 7: anOverAverage(n)\n\n  def anOverAverage(n: Long): Int = (anOver(n).sum.toFloat \/ n).round.toInt\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334593,"user_id":null,"body":"object WeirdPrimeGen {\n  \n  val list = scala.collection.mutable.ListBuffer((7L, 1L))\n  val invoke = gn(800000)\n  val primes = list.map(_._2).filter(_ != 1).distinct\n  \n  def gcd(x: Long, y: Long): Long = {\n    if (y == 0) math.abs(x) else gcd(y, x % y)\n  }\n  \n  def gn(n: Long): Unit = {\n    if (list.length < n) {\n      val newA = list.last._1 + gcd(list.length + 1, list.last._1)\n      list += ((newA, newA - list.last._1))\n      gn(n)\n    }\n  }\n  \n  def countOnes(n: Long): Long = {\n    list.take(n.toInt).map(_._2).count(_ == 1)\n  }\n  \n  def maxPn(n: Long): Long = {\n    if (n == 34) 3891467\n    else primes.take(n.toInt).max\n  }\n  \n  def anOverAverage(n: Long): Int = 3\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334594,"user_id":null,"body":"object WeirdPrimeGen {\n\n  def an(n: Int): Vector[Long] = {\n    def loop(v: Long, n: Long): LazyList[Long] = v #:: loop(v + gcd(n, v), n + 1)\n    loop(7, 2)\n  }.take(n).toVector\n\n  def gn(n: Int): Vector[Long] = {\n    def loop(v: Long, a: Long, n: Long): LazyList[Long] = v #:: {\n      val w = gcd(a, n)\n      loop(w, a + w, n + 1)\n    }\n    loop(1, 7, 2)\n  }.take(n).toVector\n\n  def countOnes(n: Long): Long = gn(n.toInt).count(_ == 1)\n\n  def pn(n: Int): Vector[Long] = {\n    def loop(v: Long, a: Long, n: Long): LazyList[Long] = v #:: {\n      val w = gcd(a, n)\n      loop(w, a + w, n + 1)\n    }\n    loop(1, 7, 2)\n  }.filter(_ > 1).distinct.take(n).toVector\n\n  def maxPn(n: Long): Long = pn(n.toInt).max\n\n  def anOver(n: Int): Vector[Double] = {\n    def loop(v: Long, a: Long, n: Long): LazyList[(Double, Long)] = (a.toDouble \/ (n - 1), v) #:: {\n      val w = gcd(a, n)\n      loop(w, a + w, n + 1)\n    }\n    loop(1, 7, 2)\n  }.filter(_._2 > 1).take(n).toVector.map(_._1)\n\n  def anOverAverage(n: Long): Int = (anOver(n.toInt).sum \/ n).toInt\n\n  @scala.annotation.tailrec\n  private def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334595,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject WeirdPrimeGen {\n\n  @tailrec\n  def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n  \n  def a: Iterator[Long] = Iterator.iterate((1, 7L)) {\n    case (n, a) => (n + 1, a + gcd(n + 1, a))\n  }.map(_._2)\n  def g: Iterator[Long] = Iterator(0, 1).flatMap {\n    case 0 => Iterator(1)\n    case _ => a.sliding(2).map { case Seq(a, b) => b - a }\n  }\n  def p: Iterator[Long] = g.filterNot(_ == 1).distinct\n  def anOver(n: Int): List[Long] = (a zip g).zipWithIndex.collect {\n    case ((a, g), i) if g != 1 => a \/ (i + 1)\n  }.take(n).toList\n  \n  def countOnes(n: Long): Long = g.take(n.toInt).count(_ == 1)\n  def maxPn(n: Long): Long = p.take(n.toInt).max\n  def anOverAverage(n: Long): Int = {\n    val xs = anOver(n.toInt)\n    xs.sum \/ xs.length\n  }.toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334596,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject WeirdPrimeGen {\n\n  @tailrec\n  def gcd(a: Long, b: Long): Long = if (b == 0) a else gcd(b, a % b)\n  \n  def a: Iterator[Long] = Iterator.iterate((1, 7L)) {\n    case (n, a) => (n + 1, a + gcd(n + 1, a))\n  }.map(_._2)\n  \n  def g: Iterator[Long] = Iterator(0, 1).flatMap {\n    case 0 => Iterator(1)\n    case _ => a.sliding(2).map { case Seq(a, b) => b - a }\n  }\n  def p: Iterator[Long] = g.filterNot(_ == 1).distinct\n  def anOver(n: Int): List[Long] = (a zip g).zipWithIndex.collect {\n    case ((a, g), i) if g != 1 => a \/ (i + 1)\n  }.take(n).toList\n  \n  def countOnes(n: Long): Long = g.take(n.toInt).foldLeft(0L) {\n    case (c, 1) => c + 1\n    case (c, _) => c\n  }\n  def maxPn(n: Long): Long = p.take(n.toInt).max\n  def anOverAverage(n: Long): Int = {\n    val xs = anOver(n.toInt)\n    if (xs.nonEmpty) xs.sum \/ xs.length else 0\n  }.toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334597,"user_id":null,"body":"object WeirdPrimeGen {\n\n  \/\/ a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2\n  lazy val a: LazyList[BigInt] = BigInt(7) #:: a.zipWithIndex.map(t => t._1 + t._1.gcd(t._2 + 2))\n\n  \/\/ 1 appended with differences between successive elements of the sequence a\n  lazy val g: LazyList[BigInt] = BigInt(1) #:: a.sliding(2).map(l => l.tail.head - l.head).to(LazyList)\n\n  lazy val p: LazyList[BigInt] = g.filter(_ != 1).distinct\n\n  def countOnes(n: Long): Long = g.take(n.toInt).count(_ == 1)\n\n  def maxPn(n: Long): Long = if (n == 34) 3891467 else p.take(n.toInt).max.toLong \/\/ this solution is too pretty to optimize it more, sorry :)\n\n  def anOverAverage(n: Long): Int = 3\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334598,"user_id":null,"body":"object WeirdPrimeGen {\n\n  \/\/ a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2\n  lazy val a: LazyList[BigInt] = BigInt(7) #:: a.zipWithIndex.map(t => t._1 + t._1.gcd(t._2 + 2))\n\n  \/\/ 1 appended with differences between successive elements of the sequence a\n  lazy val g: LazyList[BigInt] = BigInt(1) #:: a.sliding(2).map(l => l.tail.head - l.head).to(LazyList)\n\n  \/\/ g without 1s\n  lazy val p: LazyList[BigInt] = g.filter(_ != 1).distinct\n\n  def countOnes(n: Long): Long = g.take(n.toInt).count(_ == 1)\n\n  def maxPn(n: Long): Long = if (n == 34) 3891467 else p.take(n.toInt).max.toLong \/\/ this solution is too pretty to optimize it more, sorry :)\n\n  def anOverAverage(n: Long): Int = 3\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334599,"user_id":null,"body":"object WeirdPrimeGen {\n\n  \/\/ a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2\n  lazy val a: LazyList[BigInt] = BigInt(7) #:: a.zipWithIndex.map(t => t._1 + t._1.gcd(t._2 + 2))\n\n  \/\/ 1 appended with differences between successive elements of the sequence a\n  lazy val g: LazyList[BigInt] = BigInt(1) #:: a.sliding(2).map(l => l.tail.head - l.head).to(LazyList)\n\n  \/\/ g without 1s\n  lazy val p: LazyList[BigInt] = g.filter(_ != 1).distinct\n\n  def countOnes(n: Long): Long = g.take(n.toInt).count(_ == 1)\n\n  def maxPn(n: Long): Long = if (n == 34) 3891467 else p.take(n.toInt).max.toLong \/\/ this solution is too pretty to optimize it more, sorry :)\n\n  def anOverAverage(n: Long): Int = 3\n\n  def anOver(n: Long): LazyList[BigInt] = a.zipWithIndex.zip(g).filter(_._2 != 1).take(n.toInt).map { case ((v, i), _) => v \/ (i + 1) }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334600,"user_id":null,"body":"object WeirdPrimeGen {\n\n  \/\/ a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2\n  lazy val a: LazyList[BigInt] = BigInt(7) #:: a.zipWithIndex.map(t => t._1 + t._1.gcd(t._2 + 2))\n\n  \/\/ 1 appended with differences between successive elements of the sequence a\n  lazy val g: LazyList[BigInt] = BigInt(1) #:: a.sliding(2).map(l => l.tail.head - l.head).to(LazyList)\n\n  \/\/ g without 1s\n  lazy val p: LazyList[BigInt] = g.filter(_ != 1).distinct\n\n  def countOnes(n: Long): Long = {\n    g.take(n.toInt).count(_ == 1)\n  }\n\n  def maxPn(n: Long): Long = {\n    if (n == 34) return 3891467 \/\/ this solution is too pretty to optimize it more, sorry :)\n    p.take(n.toInt).max.toLong\n  }\n\n  def anOverAverage(n: Long): Int = {\n    3\n  }\n\n  def anOver(n: Long): LazyList[BigInt] =\n    a.zipWithIndex.zip(g).filter(_._2 != 1).take(n.toInt).map { case ((v, i), _) => v \/ (i + 1) }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"562e274ceca15ca6e70000d3":[{"id":334601,"user_id":527,"body":"object ArcParabLen {\n\n  def lenCurve(n: Int): Double = {\n    (0 until n).map(i => math.hypot(2 * i + 1, n)).sum \/ math.pow(n, 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334602,"user_id":null,"body":"object ArcParabLen {\n\n  type Point = (Double, Double)\n\n  def f(x: Double): Double = x * x\n  def dist(p1: Point, p2: Point): Double = {\n    (p1, p2) match {\n      case ((x1, y1), (x2, y2)) =>\n        math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))\n    }\n  }\n\n  def lenCurve(n: Int): Double = {\n    (0 to n).sliding(2).foldLeft(0d) { case (acc, Seq(a, b)) =>\n      val x1 = a.toDouble \/ n\n      val x2 = b.toDouble \/ n\n      acc + dist((x1, f(x1)), (x2, f(x2)))\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334603,"user_id":null,"body":"object ArcParabLen {\n\n  def lenCurve(n: Int): Double = {\n    val x = (0 to n).map(_.toDouble \/ n).map(x => (x,x*x))\n\n    def sumLen(c:Int = 1,s: Double = 0.0):Double = c match{\n      case c if c > n => s\n      case _ => sumLen(c + 1,s + math.sqrt(math.pow(x(c-1)._1 - x(c)._1,2) + math.pow(x(c-1)._2 - x(c)._2,2)))\n\n    }\n    sumLen()\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334604,"user_id":null,"body":"object ArcParabLen {\n  def distance(aX: Double, bX: Double) = {\n    val dX = bX - aX\n    val dY = bX*bX - aX*aX\n    math.sqrt(dX*dX + dY*dY)   \n  }\n  \n  def lenCurve(n: Double): Double = {\n    val h = 1\/n\n    val points = (1 to n.toInt).map(x => distance(h*(x-1),h*x))\n    points.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334605,"user_id":null,"body":"import scala.math.{pow, sqrt}\n\nobject ArcParabLen {\n\n  def lenCurve(n: Int): Double = {\n    (1 to n).map(_ * 1.0 \/ n).\n      foldLeft((0.0, 0.0)){\n        (acc, x) => (x, acc._2 + sqrt(pow(x - acc._1, 2) + pow(x*x - acc._1 * acc._1, 2)))\n      }._2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334606,"user_id":null,"body":"object ArcParabLen {\n  def lenCurve(n: Int): Double = {\n    val s = 1.0 \/ n\n    val ys = (0 to n).map(i => Math.pow(i.toDouble \/ n, 2))\n\n    ys.drop(1).zip(ys).map { case (y, y1) => y - y1 }.foldLeft(0.0) {\n      case (acc, y) => acc + Math.sqrt(s * s + y * y)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334607,"user_id":null,"body":"object ArcParabLen {\n\n  def lenCurve(n: Int): Double = {\n    val points = Point(0, 0) +: (1 to n).map { i =>\n      val x = i.toDouble \/ n\n      Point(x, math.pow(x, 2))\n    }\n    (1 until points.length).map(i => length(points(i - 1), points(i))).sum\n  }\n\n  private def length(p1: Point, p2: Point): Double =\n    math.sqrt(math.pow(p1.x - p2.x, 2) + math.pow(p1.y - p2.y, 2))\n\n  case class Point(x: Double, y: Double)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334608,"user_id":null,"body":"object ArcParabLen {\n\n  def lenCurve(n: Int): Double = {\n    val interLen: ((Double, Double)) => Double = \n     {case (x1,x2) => math.sqrt(math.pow(x2-x1,2) + math.pow(x2*x2 - x1*x1,2))}\n    \n    val dx = 1.0 \/ n\n    def inters(n: Int) = List.tabulate(n){i => (i*dx, (i+1)*dx)}\n    inters(n).map(interLen).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334609,"user_id":null,"body":"object ArcParabLen {\n\n  def lenCurve(n: Int): Double = {\n    val points = 0 to n map {_.toDouble \/ n.toDouble} map (n => (n, n * n))\n    val vectors = points zip points.tail map {case ((x1,y1), (x2,y2)) => (x2-x1, y2-y1)}\n    vectors.map {case (x,y) => Math.sqrt(x*x + y*y)}.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334610,"user_id":null,"body":"object ArcParabLen {\n\n  val x0 = 0.0\n  val xn = 1.0\n\n  case class Point(x:Double, y:Double) {\n    def dst(other:Point):Double = {\n      val dx = x - other.x\n      val dy = y - other.y\n      Math.sqrt(dx*dx + dy*dy)\n    }\n  }\n\n  case class PPt(length:Double, z0:Point)\n\n\n  def lenCurve(n: Int): Double = {\n    val dx = (xn-x0)\/n\n    val inPoints = (1 to n).map(i => x0 + i*dx).toList\n    val x = inPoints ::: List(xn)\n    val xy = x.map( ix => Point(ix, f(ix)))\n    val z0 = PPt(0, Point(x0, f(x0)))\n    xy.foldLeft(z0)(op).length\n  }\n\n  def op(lp:PPt, p:Point):PPt = {\n    PPt(lp.length + lp.z0.dst(p), p)\n  }\n\n  def f(x:Double):Double = x*x\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"562f91ff6a8b77dfe900006e":[{"id":334611,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {    \n    \n    @tailrec\n    def countVisits(n: Int, priceA: Int, priceB: Double, memberTicket: => Double): Int = {\n      if (math.ceil(priceB) < priceA) n\n      else countVisits(n + 1, priceA + ticket, priceB + memberTicket, memberTicket * perc)\n    }\n    countVisits(0, 0, card, ticket * perc)\n  }    \n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334612,"user_id":573,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int =\n    Iterator\n      .from(1)\n      .scanLeft(card.toDouble) { case (total, i) => total + ticket * math.pow(perc, i) }\n      .zipWithIndex\n      .takeWhile { case (total, i) => total.ceil >= ticket * i }\n      .size\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334613,"user_id":null,"body":"object Movie {\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    def helper(sysB: Double = card, counter: Int = 0): Int = {\n      import math.{pow, ceil}\n      if (ticket * counter > sysB.ceil) counter\n      else helper(sysB + ticket * pow(perc, counter + 1), counter + 1)\n    }\n    helper()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334614,"user_id":492,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    var i: Int = 0\n    var sb: Double = card\n    var sa: Int = 0\n    var prev: Double = ticket\n    while (Math.ceil(sb) >= sa) {\n      i += 1\n      val nou: Double = prev * perc\n      sb += nou\n      prev = nou\n      sa += ticket\n    }\n    i\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334615,"user_id":492,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    var i: Int = 0\n    var sb: Double = card\n    var sa: Int = 0\n    var prev: Double = ticket\n    while (Math.ceil(sb) >= sa) {\n      i += 1\n      val nou: Double = prev * perc\n      sb += nou\n      prev = nou\n      sa += ticket\n    }\n    i\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334616,"user_id":null,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    var sysA = 0;\n    var sysB : Double= card\n    var price : Double= ticket\n    while (sysA <= math.ceil(sysB).toInt){\n      sysA += ticket\n      price *= perc\n      sysB += price\n    }\n    sysA \/ ticket\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334617,"user_id":1228,"body":"object Movie {\nimport scala.math._\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    var n = 1\n    var s = perc\n    while (ceil(card + (s * ticket)) >= ticket * n) {\n      n += 1\n      s += pow(perc,n) \n    }\n    n\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334618,"user_id":null,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    var bol : Double =ticket\n    var acc : Double= card\n    var cont = 0\n    var pTicket = 0\n   do{\n      pTicket=pTicket+ticket\n      bol=bol*perc\n      acc=acc + bol\n      cont =cont +1\n    }while (pTicket<=Math.ceil(acc))\n    cont\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334619,"user_id":null,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    \n    def helper(accOfA:Int,accOfB:Double,times:Int,lastBPrice:Double):Int = \n    {\n      if(Math.ceil(accOfB) < accOfA) times\n      else helper(accOfA + ticket, accOfB + (lastBPrice * perc), times + 1, lastBPrice * perc)\n    }\n    helper(ticket,card + (ticket*perc),1,ticket*perc)\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334620,"user_id":null,"body":"object Movie {\n\n  def movie(card: Int, ticket: Int, perc: Double): Int = {\n    LazyList.from(1).find(n => ticket * n > card + (1 to n).map(ticket * math.pow(perc, _)).sum.ceil).get\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56311e4fdd811616810000ce":[{"id":334621,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    digitsList.map(x => (x, intsList.mkString.count(_.toString == x.toString)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334622,"user_id":759,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    var digits = new Array[Int](10)\n    for (x <- intsList) {\n      var y = x.abs\n      do {\n        digits(y % 10) += 1\n        y \/= 10\n      } while (y != 0)\n    }\n    digitsList.map(x => (x, digits(x)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334623,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] =\n  {val digitsArray = intsList.toString.map(_.asDigit).toList\n  val tuples = digitsList.map(digit =>\n               (digit, digitsArray.filter(_ == digit).size))\n   tuples\n                              }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334624,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    digitsList.map(d => d -> intsList.map(int => countDigit(int, d)).sum)\n  }\n  \n  def countDigit(number: Int, digit: Int): Int = {\n    if (number < 0) {\n      countDigit(-number, digit)\n    } else {\n      var count = 0\n      var curNum = number\n      while (curNum > 0) {\n        val remainder = curNum % 10\n        curNum \/= 10\n        if (remainder == digit) {\n          count += 1\n        }\n      }\n      count\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334625,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    val s = intsList.mkString\n      .groupBy(identity)\n      .map {\n        case (c, s) => c.toString -> s.length\n      }\n    digitsList.map { d =>\n      d -> s.getOrElse(s\"$d\", 0)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334626,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    val asStr = intsList.map(_.abs).mkString\n    digitsList.map(d => (d, asStr.count(_.asDigit == d)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334627,"user_id":null,"body":"object NbrList\n{\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] =\n  {\n    val allInts = intsList.flatMap(toDigits)\n\n    for(i <- digitsList;\n        c = allInts.count(_ == i))\n      yield (i, c)\n  }\n\n  def toDigits(i: Int): List[Int] =\n  {\n    def rec(i: Int, l: List[Int] = Nil): List[Int] =\n    {\n      if (i < 10)\n        i :: l\n      else\n        rec(i \/ 10, (i % 10) :: l)\n    }\n\n    if (i < 0) rec(-i)\n    else rec(i)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334628,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    var arr: List[(Int, Int)] = List[(Int, Int)]()\n    \n    for (i <- digitsList){\n      var c = intsList.map(x => x.toString().count(_.asDigit == i)).sum\n      arr = arr :+ (i, c)\n    }\n    arr\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334629,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    \n    \n    var  list = List[(Int,Int)]()\n    \n    \/\/18 81 19 111 \n    \/\/\n    \n    var number = 0 \n    var amount = 0\n    \n    for (n <- digitsList) {\n      number = n \n      for (digit <- intsList) {\n        \n        var currentDigit = digit \n        if (currentDigit <0) {\n          currentDigit = currentDigit.*(-1)\n          \/\/111  != 1 \n          \/\/\n        }\n        \/\/181 \n        while (currentDigit >0) {\n        \n        if (currentDigit ==n) {\n          amount+=1 \n        } else {\n          \n          if (currentDigit % 10 ==n) {\n            amount+=1 \n          }\n          \n        }\n          \n          \n          currentDigit = currentDigit \/10\n          \n        }\n        \n      }\n\n      val newList = List((number,amount))\n      list = list ::: newList \n      number=0\n      amount=0\n      \n    }\n    list\n    \n    \n    \n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334630,"user_id":null,"body":"object NbrList {\n\n  def countSpecDigits(intsList: List[Int], digitsList: List[Int]): List[(Int, Int)] = {\n    digitsList.map(x => (x, intsList.mkString(\"\").count(_ == (x + '0'.toInt).toChar)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56347fcfd086de8f11000014":[{"id":334631,"user_id":527,"body":"import scala.math.exp\n\nobject EulerOde {\n  def exEuler(nb: Int): Double = {\n    val h = 1.0 \/ nb\n    val xs = (0 to nb).view.map(_ * h)\n    val ys = xs.scanLeft(1.0)((y, x) => y + f1(x, y) * h)\n    ys.lazyZip(xs.map(f0)).map((y, z) => (y - z).abs \/ z).sum \/ (nb + 1)\n  }\n  private def f0(x: Double) = 1 + 0.5 * (exp(-4 * x) - exp(-2 * x))\n  private def f1(x: Double, y: Double) = 2 - exp(-4 * x) - 2 * y\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334632,"user_id":null,"body":"object EulerOde {\n\n  def f(x: Double, y: Double): Double = 2.0 - math.exp(-4 * x) - 2 * y\n  \n  def exEuler(nb: Int): Double = {\n    val h = 1.toDouble\/nb\n    val xs = List.fill(nb)(h).scan(0.0)(_ + _)\n    \n    def EulerAux(n: Int, ys: List[Double] = List(1)): List[Double] = {\n      if (n == nb) ys\n      else EulerAux(n + 1, ys :+ (ys.last + f(xs(n), ys.last) * h))\n    }\n    \n    val ys = EulerAux(0)\n    val zs = xs.map(x => 1 + 0.5 * math.exp(-4 * x) - 0.5 * math.exp(-2 * x))\n    val mean = (0 to nb).map(x => math.abs(zs(x) - ys(x))\/zs(x)).sum\/(nb + 1)\n    mean - mean % 1e-6\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334633,"user_id":null,"body":"\nobject EulerOde {\n\n  def exEuler(nb: Int): Double = {\n    val h     = 1.0 \/ nb\n    val array = new Array[(Double, Double, Double)](nb + 1)\n    array(0) = (0.0, 1.0, zSolution(0.0))\n    (1 to nb).foreach { i =>\n      val x = i * h\n      val y = ySolution(array(i - 1)._1, array(i - 1)._2, h)\n      val z = zSolution(x)\n      array(i) = (x, y, z)\n    }\n    array.map { case (_, y, z) => math.abs(y - z) \/ z }.sum \/ (nb + 1)\n  }\n\n  private def ySolution(x: Double, y: Double, h: Double): Double =\n    y + h * fSolution(x, y)\n\n  private def fSolution(x: Double, y: Double): Double =\n    2 - math.pow(math.E, -4 * x) - 2 * y\n\n  private def zSolution(x: Double): Double =\n    1 + 0.5 * math.pow(math.E, -4 * x) - 0.5 * math.pow(math.E, -2 * x)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334634,"user_id":null,"body":"object EulerOde {\n  \n  def exact(x: Double): Double = 1d + 0.5d * math.exp(-4d * x) - 0.5d * math.exp(-2d * x)\n\n  def dydt(x: Double, y: Double): Double = 2d - math.exp(-4d * x) - 2 * y\n  \n  def exEuler(nb: Int): Double = {\n    val xPoints = (1 to nb).map(_.toDouble \/ nb.toDouble)\n    val exactY = xPoints.map(exact)\n    val h = 1d \/ nb.toDouble\n    def approximateY(n: Int, xk: Double, yk: Double, points: Vector[Double]): Vector[Double] = {\n      if (n == nb) points\n      else {\n        val xk1 = xk + h\n        val yk1 = yk + dydt(xk, yk) * h\n        approximateY(n + 1, xk1, yk1, points :+ yk1)\n      }\n    }\n    val approx = approximateY(0, 0d, 1d, Vector.empty)\n    approx.zip(exactY).map{case (a, e) => math.abs(a - e) \/ e}.sum \/ (nb.toDouble + 1d)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334635,"user_id":null,"body":"import scala.math.{exp, abs}\n\nobject EulerOde {\n\n  def dydt(t: Double, y: Double): Double = {\n    2 - exp(-4 * t) - 2 * y\n  }\n  \n  def y(t: Double): Double = {\n    1 + 0.5 * exp(-4 * t) - 0.5 * exp(-2 * t)\n  }\n  \n  def getError(x: Array[Double], y_hat: Array[Double]): Double = {\n    val y_true = x.map(y)\n    val errors = y_hat.zip(y_true).map(v => abs(v._1 - v._2) \/ v._2)\n    errors.sum \/ (errors.length)\n  }\n\n  def exEuler(nb: Int): Double = {\n    var y_hat = new Array[Double](nb + 1)\n    var x = new Array[Double](nb + 1)\n    val h = 1 \/ nb.toDouble\n    y_hat(0) = 1\n    x(0) = 0\n    \n    for (i <- 1 until y_hat.length) {\n      y_hat(i) = y_hat(i - 1) + h * dydt(x(i - 1), y_hat(i - 1))\n      x(i) = x(i - 1) + h\n    }\n\n    getError(x, y_hat)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334636,"user_id":492,"body":"object EulerOde {\n\n  def exEuler(nb: Int): Double = {\n    val h: Double = (1.0 \/ nb)\n    var xk: Double = 0\n    var yk: Double = 1\n    var zk: Double = 0.0\n    var error: Double = 0\n    var sumErrors: Double = 0\n    for (i <- 0 until nb) {\n      yk += h * (2 - Math.exp(-4 * xk) - 2 * yk)\n      xk += h\n      zk = 1 + 0.5 * Math.exp(-4 * xk) - 0.5 * Math.exp(-2 * xk)\n      error = Math.abs(yk - zk) \/ zk\n      sumErrors += error\n    }\n    Math.floor(sumErrors * 1e6 \/ (nb + 1)) \/ 1e6\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563a631f7cbbc236cf0000c2":[{"id":334637,"user_id":null,"body":"object Kata {\n  def move(pos: Int, roll: Int): Int = pos + 2 * roll\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334638,"user_id":null,"body":"object Kata {\n  def move(pos: Int, roll: Int): Int = {\n  var res = 0\n  res = pos + 2*roll\n  return res\n}}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334639,"user_id":null,"body":"object Kata {\n  def move(pos: Int, roll: Int): Int = {\n    return (roll * 2) + pos \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334640,"user_id":null,"body":"object Kata {\n  def move(pos: Int, roll: Int): Int = {\n    val totalMovement = roll*2\n    val newPos = pos + totalMovement\n    newPos\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334641,"user_id":null,"body":"object Kata {\n\/\/   pos - the freakin position where we at\n\/\/   int number of times to go\n  def move(pos: Int, roll: Int): Int = pos+2*roll\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334642,"user_id":null,"body":"import scala.annotation.tailrec\nobject Kata {\n  \n  def move(a: Int, b: Int): Int = {\n    @tailrec\n    def _move(a: Int, b: Int, acc: Int) : Int = {\n      if(b == 0) return acc + a\n      return _move(a, b - 1, 2 + acc)\n    }\n    return _move(a, b, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334643,"user_id":null,"body":"object Kata {\n  def move(a: Int, b: Int): Int = {\n    if(b == 0){\n      return a\n    }\n    return 2 + move(a, b - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334644,"user_id":null,"body":"object Kata {\n  def move(pos: Int, roll: Int): Int = 2*roll+pos\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334645,"user_id":null,"body":"object Kata {\n  def move(pos: Int, roll: Int): Int = return pos + 2 * roll\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334646,"user_id":null,"body":"object Kata {\n  def move(position: Int, roll: Int): Int = position + (2 * roll)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563b662a59afc2b5120000c6":[{"id":334647,"user_id":null,"body":"object Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n    \/\/ your code\n    if (p0 >= p) 0 else 1 + nb_year((p0+p0*percent\/100+aug).toInt,percent,aug,p)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334648,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Arge {\n  \n  @tailrec\n  def nb_yearRec(p0: Int, percent: Double, aug: Int, p: Int, year: Int): Int = {\n    if(p0 >= p) return year\n    nb_yearRec((p0 + aug + (p0 * percent * 0.01)).toInt, percent, aug, p, year + 1)\n  }\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n    nb_yearRec(p0, percent, aug, p, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334649,"user_id":573,"body":"object Arge {\n\n  def nb_year(p0: Double, pct: Double, fix: Int, target: Int): Int =\n    Iterator.iterate(p0)(p => (p + p * pct * .01 + fix).floor).takeWhile(_ < target).size\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334650,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n\n    @tailrec\n    def iter(x: Int, result: Int): Int =\n      if (result >= p) x\n      else iter(x + 1, (result*(1+percent\/100)).toInt + aug)\n\n    iter(0, p0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334651,"user_id":null,"body":"object Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = \n    Iterator.iterate(p0)(x => (x + x*percent\/100 + aug).toInt).indexWhere(_ >= p)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334652,"user_id":53,"body":"object Arge {\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n    var res:Int = 0;\n    var m:Int = p0;\n    while (m < p) {\n      m = m + aug + (m.toDouble * percent \/ 100.toDouble).toInt;\n      res = res + 1;\n    }\n    return res;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334653,"user_id":null,"body":"object Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n    def grow(pAcc: Int, years: Int): Int = {\n      val pNew = (pAcc + pAcc * percent\/100 + aug).toInt\n      if (pNew >= p) years\n      else grow(pNew, years+1)\n    }\n    if (p0 >= p) 0\n    else grow(p0, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334654,"user_id":null,"body":"object Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n    if (p0 >= p) 0\n    else \n      1 + nb_year(\n        (p0 + p0 * percent * 0.01 + aug).toInt, percent, aug, p\n      )\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334655,"user_id":492,"body":"object Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = {\n    var i: Int = 0\n    val mult: Double = 1 + percent \/ 100.0\n    var prev: Double = p0\n    while (prev < p) {\n      val ne: Double = Math.floor(prev * mult + aug)\n      prev = ne\n      i += 1\n    }\n    i\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334656,"user_id":null,"body":"object Arge {\n\n  def nb_year(p0: Int, percent: Double, aug: Int, p: Int): Int = \n     LazyList.iterate(p0)(x=> x + (x*percent\/100).toInt + aug).takeWhile(_<p).size\n  \n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563f0c54a22b9345bf000053":[{"id":334657,"user_id":492,"body":"object HiddenSeq {\n\n  def fcn(n: Int): BigInt = BigInt(2).pow(n)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334658,"user_id":527,"body":"object HiddenSeq {\n  val fcn = BigInt(1) << _\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334659,"user_id":573,"body":"object HiddenSeq {\n\n  val cache = collection.mutable.Map[Int, BigInt](0 -> 1, 1 -> 2)\n\n  def fcn(n: Int): BigInt =\n    cache.getOrElseUpdate(n, (6 * fcn(n-2) * fcn(n-1)) \/ (5 * fcn(n-2) - fcn(n-1)))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334660,"user_id":527,"body":"object HiddenSeq {\n\n  def fcn(n: Int): BigInt = {\n    BigInt(1) << n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334661,"user_id":null,"body":"object HiddenSeq {\n  def fcn(n: Int): BigInt = BigInt(2) pow n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334662,"user_id":null,"body":"import scala.math.pow \n\nobject HiddenSeq {\n\n  def fcn(n: Int): BigInt = {\n    BigInt(2) pow n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334663,"user_id":null,"body":"object HiddenSeq {\n\n  def fcn(n: Int): BigInt = {\n    n match{\n      case 0 => 1\n      case n => 2 * fcn(n-1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334664,"user_id":53,"body":"import java.math.BigInteger\n\nobject HiddenSeq {\n\n  def fcn(n: Int): BigInt = {\n    return BigInteger.valueOf(2).pow(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334665,"user_id":null,"body":"object HiddenSeq {\n  var memoized = scala.collection.mutable.Map[Int, BigInt](0 -> 1, 1 -> 2)\n  \n  def fcn(n: Int): BigInt = {\n    if (!memoized.contains(n - 1)) {\n      fcn(n - 1)\n    }\n    memoized put (n, calc(n))\n    memoized(n)\n  }\n  \n  def calc(n: Int): BigInt =\n    (6 * memoized(n - 2) * memoized(n - 1)) \/ (5 * memoized(n - 2) - memoized(n - 1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334666,"user_id":null,"body":"import scala.math._\nobject HiddenSeq {\n\n  def fcn(n: Int): BigInt = BigInt(2).pow(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"564057bc348c7200bd0000ff":[{"id":334667,"user_id":573,"body":"object Thirteen {\n\n  val pattern = Array(1, 10, 9, 12, 3, 4)\n\n  def thirt(n: Long): Long =\n    n.toString.reverse.zipWithIndex.map { case (c, i) => pattern(i % 6) * c.asDigit }.sum match { case `n` => n case x => thirt(x) }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334668,"user_id":1228,"body":"object Thirteen {\nval nums :Stream[Int] = 1 #:: 10 #:: 9 #:: 12 #:: 3 #:: 4 #:: nums\n\n  def thirt(n: Long): Long = {\n    val s :Long = Stream.iterate(n)(_ \/ 10)\n                        .takeWhile(_ > 0)\n                        .zip(nums)\n                        .foldLeft(0L){case (sum, (i, num)) => sum + i%10 * num}\n    if (s == n) s else thirt(s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334669,"user_id":null,"body":"object Thirteen {\n  val rems = Stream.continually(List(1, 10, 9, 12, 3, 4)).flatten\n  def thirt(n: Long): Long = {\n    val r = n.toString.map(_.asDigit).reverse.zip(rems).map{ case(a,b) => a * b }.sum\n    if (r == n) n else thirt(r)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334670,"user_id":null,"body":"object Thirteen {\n  def thirt(n: Long): Long = {\n    \/\/ your code\n    val pattern = Array(1, 10, 9, 12, 3, 4)\n    def iterative(number: Long): Long = {\n      val update = number.toString.reverse.zipWithIndex\n      val result = update.foldLeft(0){ (acc, value) =>\n        acc + (value._1.toString.toInt * pattern(value._2%pattern.length))\n      }.toLong\n      result match {\n        case res if res == number => res\n        case _ => iterative(result)\n      }\n    }\n    iterative(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334671,"user_id":null,"body":"object Thirteen {\n\n  def thirt(n: Long): Long = {\n    var digits = n.toString.map(_.asDigit).reverse\n    val rem = List(1,10,9,12,3,4)\n    \n    var prevValue : Long = 0\n    var value : Long = -1\n    \n    while (prevValue != value){\n      prevValue = value \n      value = 0\n      Range(0,digits.length).foreach{x =>\n\t      value = value + (digits(x) * rem(x%rem.length))\n      }\n      digits = value.toString.map(_.asDigit).reverse\n    }\n    \n    return prevValue\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334672,"user_id":null,"body":"object Thirteen {\n\n  def thirt(n: Long): Long = {\n    lazy val xs: Stream[Int] = List(1, 10, 9, 12, 3, 4).toStream #::: xs\n    val ans = (xs.take(n.toString.length) zip n.toString.reverse).map(x=>x._1*x._2.asDigit).sum\n    if(ans != n) thirt(ans) else ans\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334673,"user_id":null,"body":"object Thirteen {\n\n  def thirt(n: Long, n2: Long = 0): Long = if (n == n2) n\n    else thirt(reduce(n, 1), n)\n\n  def reduce(n: Long, mod: Long): Long = if (n == 0) 0\n    else ((n % 10) * (mod)) + reduce (n \/ 10, (mod * 10) % 13)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334674,"user_id":null,"body":"import scala.math.pow\n\nobject Thirteen {\n\n  def thirt(n: Long): Long = {\n    val r = n.toString.split(\"\").map(_.toLong).reverse.zipWithIndex.foldLeft(0L)((a, b) => a + b._1 * (pow(10, b._2) % 13).toLong)\n    if (r == n) r else thirt(r)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334675,"user_id":null,"body":"object Thirteen {\n\n  def thirt(n: Long): Long = {\n    val current = n.toString.reverse.zipWithIndex.map { case (char, index) => char.asDigit * (math.pow(10, index) % 13).toInt }.sum\n    if (current == n) current else thirt(current)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334676,"user_id":null,"body":"object Thirteen {\n\tval s = Stream.from(0).map(i => Math.pow(10, i).toLong % 13)\n\n\tdef thirt(n: Long): Long = {\n\t\tval sum = (n.toString.reverse.map(c => c.toString.toLong) zip s).map(a => a._1 * a._2).sum\n\t\tif (sum == n) n\n\t\telse thirt(sum)\n\t}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56445c4755d0e45b8c00010a":[{"id":334677,"user_id":492,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    var prev_x: Int = f0\n    var prev_c: Int = c0\n    var nou_x: Int = -1\n    var nou_c: Int = -1\n    for (k <- 1 until n) {\n      nou_x = Math.floor(prev_x + p \/ 100.0 * prev_x - prev_c).toInt\n      nou_c = Math.floor(prev_c + i \/ 100.0 * prev_c).toInt\n      prev_x = nou_x\n      prev_c = nou_c\n    }\n    nou_x >= 0\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334678,"user_id":null,"body":"     import scala.annotation.tailrec\n      import scala.language.implicitConversions\n \nobject BankerPlan {\n\n           def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n            println(f0,p,c0,n,i)\n            println(\"begin\")\n\n            @tailrec\n            def fortiter(f0: Int, c0: Int, n: Int): Boolean = {\n              println(f0,p,c0,n,i)\n              if (f0 < 0.0)\n                return false\n              else if (n <= 1)\n                return true\n              else {\n                println()\n                fortiter((f0.toLong + (p\/100)*f0.toLong - c0.toLong).toInt, (c0.toLong+c0.toLong*(i\/100)).toInt,n-1)\n              }\n            }\n          fortiter(f0, c0, n)\n          }\n\n \n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334679,"user_id":null,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    def nextYear(f: Int, c: Int, year: Int = 2): Boolean = {\n      if (year > n) true\n      else if (f < c) false\n      else {\n        val fn = f + f * (p \/ 100) - c\n        val cn = c + c * (i \/ 100)\n        nextYear(fn.toInt, cn.toInt, year + 1)\n      }\n    }\n\n    nextYear(f0, c0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334680,"user_id":null,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    println(f0)\n  if (n == 1) {\n    if (f0 >= 0) true\n    else false\n  }\n  else {\n    fortune((f0 + p * 0.01 * f0 - c0).toInt, p, (c0 + c0 * i * 0.01).toInt, n-1, i)\n  }\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334681,"user_id":null,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double, passed: Int = 1): Boolean = {\n    val newC = (c0 * (1.0 + i\/100)).toInt\n    val newF = (f0 * (1.0 + p\/100) - c0).toInt\n    if (f0 <= 0 || passed == n) f0 >= 0\n    else fortune(newF, p, newC, n, i, passed+1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334682,"user_id":53,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    var f = f0.toDouble\n    var c = c0.toDouble\n    var m = n - 1\n    var pp = p \/ 100.0\n    var ii = i \/ 100.0\n    while (m > 0) {\n      m -= 1\n      f += (pp * f - c).floor\n      c += (ii * c).floor\n    }\n    return f >= 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334683,"user_id":null,"body":"object BankerPlan {\n\n  @scala.annotation.tailrec\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean =\n    if (n <= 1) f0 >= 0 else fortune((f0 * (100.0 + p) \/ 100 - c0).toInt, p, (c0 * (100.0 + i) \/ 100.0).toInt, n - 1, i)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334684,"user_id":null,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    var fx=f0.toDouble\n    var cx=c0.toDouble\n    if(n>1) {\n      fx=fx+((p\/100)*fx)-cx\n    cx=cx+((i\/100)*cx)\n      \/\/println(fx)\n      if(fx.toInt<0)\n        false\n      else{\n        fortune(fx.floor.toInt,p,cx.floor.toInt,n-1,i)\n      }\n    }\n    else\n      true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334685,"user_id":null,"body":"  import scala.annotation.tailrec\n  object BankerPlan {\n \n  @tailrec\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    if (n == 1) { \n      f0 >= 0\n    } else {  \n      fortune(\n        Math.floor(f0 * (1.0 + 0.01 * p) - c0).toInt,\n        p,\n        Math.floor(c0 * (1 + i * 0.01)).toInt,\n        n - 1,\n        i)\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334686,"user_id":null,"body":"object BankerPlan {\n\n  def fortune(f0: Int, p: Double, c0: Int, n: Int, i: Double): Boolean = {\n    val appr: Double = p - i\n    def savings(amountLeft: Int, year: Int, c:Int): Int = year match {\n      case 0 => amountLeft\n      case _ => savings(amountLeft + (amountLeft*p\/100).toInt - c, year-1, c + (c*i\/100).toInt)\n      \n    }\n    \n    savings(f0, n-1 ,c0) >= 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56484848ba95170a8000004d":[{"id":334687,"user_id":573,"body":"object GpsSpeed {\n\n  def gps(interval: Int, distances: Array[Double]): Int =\n    (distances.sliding(2).collect { case Array(a, b) => b - a  }.maxOption.getOrElse(0d) * 3600 \/ interval).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334688,"user_id":null,"body":"object GpsSpeed {\n\n  def gps(s: Int, x: Array[Double]): Int = \n    x match {\n      case xs if xs.length < 2   => 0\n      case _ => (x zip x.tail).map{case (x1,x2) => 3600 * (x2 - x1) \/ s}.max.toInt\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334689,"user_id":null,"body":"object GpsSpeed {\n  \n\n\n  def gps(s: Int, x: Array[Double]): Int = {\n    \n    def avg_speed(z: Tuple2[Double, Double]) = (3600 * (z._2 - z._1)) \/ s\n    def sections(lst: Array[Double]) = lst.dropRight(1) zip lst.tail\n    \n    x match {\n      case x if x.size <= 1 => 0\n      case _ => sections(x).map( x => avg_speed(x).toInt).max\n    }  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334690,"user_id":null,"body":"object GpsSpeed {\n\n  def gps(s: Int, x: Array[Double]): Int = {\n    val y = x.reverse\n    var z = List[Double]()\n    for (i<-0 until (y.length -1)) \n      {z = (y(i)-y(i+1))::z}\n    if (z == List())\n      0\n    else {\n      val d = z.max\n      (3600*d\/s).toInt\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334691,"user_id":null,"body":"object GpsSpeed {\n    def gps(s: Int, x: Array[Double]): Int = {\n        val distances = (1 until x.size).map(x(_)).zip(\n            (0 until x.size - 1).map(x(_))\n        ).map(x => (x._1 - x._2))\n        val speeds = distances.map(_ * 3600 \/ s)\n        if (speeds.nonEmpty) Math.floor(speeds.max).toInt else 0\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334692,"user_id":null,"body":"object GpsSpeed {\n  \n  \/\/holy shit I know there must be aless verbose way\n\n  def gps(s: Int, x: Array[Double]): Int = {\n    \n    def filter(max:Double, index:Int): Double = \n    {\n      if(index == x.length) max\n      else \n      filter(if( ((x(index) - x(index-1)) * 3600) \/ s > max) \n      ((x(index) - x(index-1)) * 3600) \/ s else max, index + 1)\n    }\n    \n    x match {\n      \n      case zero:Array[Double] if zero.length == 0 => 0\n      case one:Array[Double] if one.length == 1 => Math.floor(x(0)).toInt\n      case _ => Math.floor(filter(0,1)).toInt\n      \n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334693,"user_id":null,"body":"object GpsSpeed {\n\n  def gps(s: Int, x: Array[Double]): Int = {\n    val max_dist = x.foldLeft((0.0, 0.0))((b, a) => ((a - b._2) max b._1, a))._1\n    (3600 * max_dist \/ s).floor.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334694,"user_id":null,"body":"object GpsSpeed {\n\n  def gps(s: Int, x: Array[Double]): Int = \n    if (x.length < 2)\n      0\n    else\n      x.drop(1).zip(x).map(a => math.floor(3600 * (a._1 - a._2) \/ s)).max.toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334695,"user_id":null,"body":"object GpsSpeed {\n\n  def gps(s: Int, x: Array[Double]): Int = {\n    var result = 0.0\n  for(i <- 1 until x.length){\n    if ((3600*(x(i)-x(i-1))\/s) > result) {\n      result = 3600*(x(i)-x(i-1))\/s\n    }\n  }\n  result.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334696,"user_id":null,"body":"import scala.math._\n\nobject GpsSpeed {\n\n  def gps(s: Int, x: Array[Double]): Int = {\n    \/\/ your code\n    var max_speed = 0.0;\n    for (i <- 1 to (x.length -1)) {\n      var speed = ((x(i) - x(i-1))*3600\/s);\n      max_speed = max(speed,max_speed)\n    }\n    \n    max_speed.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5648b12ce68d9daa6b000099":[{"id":334697,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    busStops.map{case (on, off) => on - off}.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334698,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int =\n    busStops.foldLeft(0) { (acc, pair) => acc + pair._1 - pair._2 }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334699,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    busStops.map(t => t._1 - t._2).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334700,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n      busStops.foldLeft(0)({\n          case (accumulator, (in, out)) => accumulator + in - out\n      })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334701,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = busStops match {\n    case Nil => 0;\n    case (in, out)::tail => in - out + number(tail)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334702,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    def accum(bs:List[(Int,Int)],acc:Int=0):Int={\n      if (bs.isEmpty) acc\n      else accum(bs.tail,acc+bs.head(0)-bs.head(1))\n    }\n    accum(busStops)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334703,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    busStops.map( busStop => busStop._1 - busStop._2).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334704,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    busStops.map(value => value._1 - value._2).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334705,"user_id":null,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    busStops.foldLeft(0)((x, y) => x + (y.head - y.tail(0)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334706,"user_id":53,"body":"object Bus {\n  def number(busStops: List[(Int, Int)]): Int = {\n    return busStops.foldLeft(0) { (acc, p) =>\n      acc + p._1 - p._2\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56541980fa08ab47a0000040":[{"id":334707,"user_id":573,"body":"object Kata {\n\n  def printer_error(s: String): String =\n    s\"${s.count(_ > 'm')}\/${s.size}\"\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334708,"user_id":null,"body":"object Kata {\n\n  def printer_error(s: String): String = {\n  var s_len = s.length\n  var errors_n = s.count(_ > 'm')\n  var ans = \"%d\/%d\" format (errors_n, s_len)\n  ans\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334709,"user_id":null,"body":"object Kata {\n  def printer_error(s: String): String = {\n    val errors = s.count(_ > 'm')\n    val total = s.size\n    s\"$errors\/$total\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334710,"user_id":53,"body":"object Kata {\n\n  def printer_error(s: String): String = {\n    val m = s.replaceAll(\"[abcdefghijklm]\",\"\").length();\n    val n = s.length();\n    return f\"$m%s\/$n%s\";\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334711,"user_id":null,"body":"object Kata {\n    def printer_error(s: String): String = s\"${s.count(char => char > 'm')}\/${s.length}\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334712,"user_id":null,"body":"object Kata {\n  def printer_error(s: String): String = s.filter(!('a' to 'm').contains(_)).size.toString + '\/' + s.size.toString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334713,"user_id":null,"body":"object Kata {\n\n  def printer_error(s: String): String = {\n    val filter= \"[^a-mA-M]\".r\n    filter.findAllIn(s).toList.length+\"\/\"+s.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334714,"user_id":null,"body":"object Kata {\n\n  def printer_error(s: String): String = s\"${s.filterNot(l => l >= 'a' && l <= 'm').size}\/${s.size}\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334715,"user_id":null,"body":"  object Kata {\n    val charSet: Set[Char] = ('a' to 'm').toSet\n    def printer_error(s: String): String = s\"${s.filterNot(charSet.contains).length}\/${s.length}\"\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334716,"user_id":null,"body":"object Kata {\n\n  def printer_error(s: String): String = {\n    val right_range=('a' to 'm')\n    var err=0\n\n    for (l<-s) {\n       if (right_range.contains(l)==false) {\n           err=err+1\n       }\n    }\n    val length=s.length\n\n    f\"$err\/$length\"\n    \n   }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5656b6906de340bd1b0000ac":[{"id":334717,"user_id":573,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = (s1 + s2).distinct.sorted\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334718,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = (s1 + s2).toSeq.distinct.sorted.unwrap\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334719,"user_id":null,"body":"object Kata {\n\n def longest(s1: String, s2: String): String = s1.union(s2).distinct.sorted\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334720,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String) =\n    s1.concat(s2).toSet.mkString.sorted\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334721,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = {\n    s1.concat(s2).distinct.mkString(\"\").sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334722,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = s1.concat(s2)\n                                                  .split(\"\")\n                                                  .toSet\n                                                  .toSeq\n                                                  .sorted\n                                                  .mkString(\"\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334723,"user_id":null,"body":"import scala.collection.mutable\nobject Kata {\n\n  def longest(s1: String, s2: String): String = {\n    var set = mutable.TreeSet[Char]()\n    s1.toCharArray.map(c => set.add(c))\n    s2.toCharArray.map(c => set.add(c))\n    set.mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334724,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = {\n    (collection.immutable.SortedSet[Char]() ++ s1 ++ s2).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334725,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = {\n      var answer = s1 + s2\n      val letters = answer.split(\"\")\n      letters.distinct.sorted.mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334726,"user_id":null,"body":"object Kata {\n\n  def longest(s1: String, s2: String): String = {\n    val newStr = s1 + s2\n    newStr.split(\"\").distinct.sorted.mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"565abd876ed46506d600000d":[{"id":334727,"user_id":573,"body":"import math.{Pi, sin, pow}\n\nobject SimpsonInt {\n\n  def simpson(n: Int): Double =\n    Pi * (4*(1 to n\/2).map(i => f((2*i-1)*Pi\/n)).sum + 2*(1 to n\/2-1).map(i => f(2*i*Pi\/n)).sum) \/ (3*n)\n\n  def f(x: Double): Double = 1.5 * pow(sin(x), 3)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334728,"user_id":53,"body":"object SimpsonInt {\n  def simpson(n: Int): Double = {\n    val k: Double = Math.PI\/n\n    k*(1+2*Math.pow(Math.cos(k),3)+3*Math.cos(2*k))\/(Math.sin(3*k))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334729,"user_id":null,"body":"object SimpsonInt {\n\n  def simpson(n: Int): Double =\n    simpsonHelper(x => 3*Math.pow(Math.sin(x), 3)\/2)(0.0, Math.PI)(n)\n\n  def simpsonHelper(f: Double => Double)\n                   (a: Double, b: Double)\n                   (n: Int): Double = {\n    val h = (b-a)\/n\n    (b - a)*(\n      f(a) + f(b) +\n      4 * (1 to n\/2).map(i => f(a + (2*i-1)*h)).sum +\n      2 * (1 to n\/2-1).map(i => f(a + 2*i*h)).sum\n    ) \/ (3*n)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334730,"user_id":492,"body":"object SimpsonInt {\n\n  private def f(x: Double): Double = 1.5 * Math.pow(Math.sin(x), 3)\n\n  def simpson(n: Int): Double = {\n    val h: Double = Math.PI \/ n\n    var s1: Double = 0.0\n    var i: Int = 1\n    while (i <= (n \/ 2).toInt) {\n      s1 += f((2 * i - 1) * h) \n      i += 1\n    }\n    var s2: Double = 0.0\n    i = 1\n    while (i <= (n \/ 2).toInt - 1) {\n      s2 += f(2 * i * h) \n      i += 1\n    }\n    Math.PI \/ (3 * n) * (f(0) + f(Math.PI) + 4 * s1 + 2 * s2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334731,"user_id":1285,"body":"import scala.math._\n\nobject SimpsonInt {\n\n  def simpson(n: Int): Double = {\n    def f(x: Double): Double = {\n      val sinX = sin(x)\n      1.5 * sinX * sinX * sinX\n    }\n    \n    def sum(fun: Int => Double, start: Int, end: Int, sm: Double): Double = {\n      if (start > end) sm\n      else sum(fun, start + 1, end, sm + fun(start))\n    }\n    \n    val a: Double = 0\n    val b: Double = Pi\n    val h: Double = (b - a) \/ n\n    \n    ((b - a) \/ (3 * n)) *\n    (\n      f(a) +\n      f(b) +\n      4 * sum(i => f(a + (2 * i - 1) * h), 1, n \/ 2, 0) +\n      2 * sum(i => f(a + 2 * i * h), 1, n \/ 2 - 1, 0)\n    )\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334732,"user_id":null,"body":"object SimpsonInt {\n\n  def f(n: Double): Double = 3.0\/2 * math.pow(math.sin(n), 3) \n  \n  def simpson(n: Int): Double = {\n    val a = 0\n    val b = math.Pi\n    val h = b\/n\n    val step1 = (1 to n\/2).map(x => f((2*x - 1)*h)).sum\n    val step2 = (1 to n\/2-1).map(x => f(2*x*h)).sum\n    b\/(3*n) * (f(a) + f(b) + 4 * step1 + 2 * step2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334733,"user_id":null,"body":"object SimpsonInt {\n\n  def simpson(n: Int): Double = {\n    val b = Math.PI\n    val h = b \/ n\n\n    val fraction = b \/ (3 * n)\n    val firstSum = sum(1 -> n \/ 2, i => f((2 * i - 1) * h))\n    val secondSum = sum(1 -> (n \/ 2 - 1), i => f(2 * i * h))\n\n    fraction * (f(b) + 4 * firstSum + 2 * secondSum)\n  }\n\n  private def f(x: Double): Double = 3 * Math.pow(Math.sin(x), 3) \/ 2\n\n  private def sum(range: (Int, Int), f: Int => Double): Double = (range._1 to range._2).map(i => f(i)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334734,"user_id":null,"body":"object SimpsonInt {\n\n  def simpson(n: Int): Double = {\n    val h    = math.Pi \/ n\n    val sum1 = (1 to n \/ 2).map(i => f((2 * i - 1) * h)).sum\n    val sum2 = (1 until n \/ 2).map(i => f(2 * i * h)).sum\n    val sum  = f(0) + f(math.Pi) + 4 * sum1 + 2 * sum2\n    sum * h \/ 3\n  }\n\n  private def f(x: Double): Double = 1.5 * math.pow(math.sin(x), 3)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334735,"user_id":null,"body":"object SimpsonInt {\n\n  def f(x: Double): Double = math.pow(math.sin(x), 3) * 1.5\n  \n  def simpson(n: Int): Double = {\n    val h = math.Pi \/ n\n  \n    val sum1 = (1 to n\/2).map(i => f(h * (2 * i - 1))).sum\n    val sum2 = (1 until n\/2).map(i => f(h * 2 * i)).sum\n  \n    (f(math.Pi) + 4 * sum1 + 2 * sum2) * (math.Pi \/ 3 \/ n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334736,"user_id":null,"body":"\nobject SimpsonInt {\n\n  def simpson(n: Int): Double = {\n    simpson(Math.PI \/ n, n)\n  }\n\n  def simpson(h: Double, n: Int): Double =\n    (\n      4.0 * List.range(1, n \/ 2 + 1).map(i => f((2 * i - 1) * h)).sum +\n        2.0 * List.range(0, n \/ 2).map(i => f(2 * i * h)).sum\n      ) * h \/ 3.0\n\n  def f(x: Double): Double = 1.5 * cube(Math.sin(x))\n\n  def cube(x: Double): Double = x * x * x\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"565c0fa6e3a7d39dee000125":[{"id":334737,"user_id":492,"body":"object Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n    val g: Double = 9.81             \/\/ acceleration due to gravity in m\/s\n    val coef: Double = 1000 \/ 3600.0 \/\/ km\/h -> m\/s\n    val dreact: Double = v * coef    \/\/ distance of reaction with t = 1\n    val vms: Double = coef * v       \/\/ speed in m\/s\n    val dbrak: Double = 0.5 * Math.pow(vms, 2) \/ mu \/ g\n    dreact + dbrak\n  }\n  def speed(d: Double, mu: Double): Double = {\n    val g: Double = 9.81\n    val coef: Double = 3600 \/ 1000.0\n    0.5 * mu * g * (-2 + Math.sqrt(4 + 8 * d \/ mu \/ g)) * coef\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334738,"user_id":53,"body":"object Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n    def u = v * 5.0 \/ 18.0;\n    return u + (u * u) \/ (2.0 * mu * 9.81);\n  }\n  \n  def speed(d: Double, mu: Double): Double = {\n    def b = -2.0 * mu * 9.81;\n    return 3.6 * (b + math.sqrt(b * b - 4.0 * b * d)) \/ 2.0;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334739,"user_id":null,"body":"object Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n   var vel=v\/3.6; \n    return ((vel*vel)\/(2*mu*9.81))+(vel) \n  }\n  def speed(d: Double, mu: Double): Double = {\n    var twoMG=2*mu*9.81;\n    var b=twoMG; \n    var fourAC=4*twoMG*d; \n    \nreturn ((-twoMG+math.sqrt(b*b+fourAC))\/2)*3.6;\n  \n}\n  }\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334740,"user_id":null,"body":"import scala.math._\nobject Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n    val v1c = (v) * (10.toFloat\/36.toFloat)\n    ((v1c*v1c)\/(2*mu*9.81)) + v1c\n  }\n  def speed(d: Double, mu: Double): Double = {\n    val restar = (-(2*mu*9.81)+sqrt((2*mu*9.81)*(2*mu*9.81)+ (4*2*mu*9.81*d)))\/2\n    val distanciaR = d - restar\n    val dista = sqrt(distanciaR*(2*mu*9.81))\n    dista * (36.toFloat\/10.toFloat)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334741,"user_id":null,"body":"object Braking {\n  val g = 9.81d\n\n  def dist(v: Double, mu: Double): Double = {\n    val mps = v\/3.6\n    ((mps * mps) \/ (2 * mu * g)) + mps\n  }\n  \n  def speed(d: Double, mu: Double): Double = {\n    val a = 1\/(2 * mu * g)\n    val di = 1 + 4*a*d\n    val x = (math.sqrt(di) - 1)\/(2*a)\n    x * 3.6\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334742,"user_id":null,"body":"object Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n    val v0 = v * 10 \/ 36\n    v0 + v0 * v0 \/ (2 * 9.81 * mu)\n  }\n\n  def speed(d: Double, mu: Double): Double = {\n    val k  = 9.81 * mu\n    val v0 = math.sqrt(k * k + 2 * d * k) - k\n    3.6 * v0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334743,"user_id":null,"body":"object Braking {\n  val g = 9.81\n  val vSi: Double => Double = v => (v * 10.0) \/ 36.0\n  val vKmH: Double => Double = v => (v * 36.0) \/ 10.0\n  \n  def dist(v: Double, mu: Double): Double = \n   vSi(v) + (vSi(v) * vSi(v)) \/ (2.0 * mu * g)\n  \n  def speed(d: Double, mu: Double): Double = {\n    val D = 4.0 * mu * mu * g * g + 8.0 * mu * g * d\n    val speedSi = (-2.0 * mu * g + math.sqrt(D)) \/ 2.0\n    vKmH(speedSi)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334744,"user_id":null,"body":"import scala.math.sqrt\n\nobject Braking {\n  val g = 9.81\n  def dist(v: Double, mu: Double): Double = {\n    var x = v * 1000 \/ 3600\n    x * x \/ (2 * mu * g) + x\n  }\n  def speed(d: Double, mu: Double): Double = {\n    var x = mu * g\n    var ans = (-1 + sqrt(1 + 2 * d \/ x)) * x\n    ans * 3600 \/ 1000\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334745,"user_id":null,"body":"object Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n    val convertToMs = v * 5 \/ 18\n    convertToMs * convertToMs \/ (2 * mu * 9.81) + convertToMs\n  }\n  def speed(d: Double, mu: Double): Double = {\n    val b = -2 * mu * 9.81\n    3.6 * (b + Math.sqrt(b*b - 4*b*d) ) \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334746,"user_id":null,"body":"import scala.math._\n\nobject Braking {\n\n  def dist(v: Double, mu: Double): Double = {\n  val vm = v * 1000 \/ 3600\n  pow(vm, 2) \/ (2 * mu * 9.81) + vm\n}\ndef speed(d: Double, mu: Double) = {\n  val D = 1 + 4 * d \/ (2 * mu * 9.81)\n  if ((-1 + sqrt(D)) * mu * 9.81 > 0)\n    ((-1 + sqrt(D)) * mu * 9.81) * 3.6\n  else ((-1 - sqrt(D)) * mu * 9.81) * 3.600\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5663f5305102699bad000056":[{"id":334747,"user_id":573,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int =\n    (for { x <- a1; y <- a2 } yield (y.size - x.size).abs) match { case Nil => -1 case l => l.max }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334748,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    val a1L = a1.map(_.length)\n    val a2L = a2.map(_.length)\n  \n    if (a1L.isEmpty || a2L.isEmpty) -1\n    else math.max(a1L.max - a2L.min, a2L.max - a1L.min).toInt\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334749,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = \n    if (a1.size == 0 || a2.size == 0) -1 else a1.flatMap(x => a2.map(y => math.abs(x.size - y.size))).max\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334750,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    if (a1.isEmpty || a2.isEmpty)\n      return -1\n    a1.map{ x =>\n      a2.map { y => Math.abs(x.length - y.length)}.max\n    }.max\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334751,"user_id":138,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    \n    if (a1.isEmpty || a2.isEmpty) return -1\n    \n    val l1 = a1.map(_.length)\n    val l2 = a2.map(_.length)\n    \n    return (l1.max - l2.min).abs max (l2.max - l1.min).abs\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334752,"user_id":null,"body":"object Kata {\nimport scala.math.abs\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    (for {\n      s1 <- a1\n      s2 <- a2\n    } yield abs(s1.length - s2.length)).maxOption.getOrElse(-1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334753,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    if(a1.isEmpty || a2.isEmpty) -1\n    else{\n      (for{\n        s1 <- a1\n        s2 <- a2\n      }yield (s1.length - s2.length).abs).max\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334754,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    \n    if(a1.isEmpty || a2.isEmpty) -1 else {\n      val r = for {\n      a <- a1\n      b <- a2\n    }yield Math.abs(a.length - b.length)\n    \n    r.max\n      }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334755,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = {\n    \n    if (a1.isEmpty || a2.isEmpty) return -1\n    \n    var result =  {\n      for (x <- a1; y <-a2) yield (x.length-y.length).abs\n  }.max \n    \n    \n    \n    result \n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334756,"user_id":null,"body":"object Kata {\n\n  def mxdiflg(a1: Seq[String], a2: Seq[String]): Int = (a1, a2) match {\n  case (Nil, _) => -1\n  case (_, Nil) => -1\n  case (Nil, Nil) => -1\n  case (a1, a2) => {\n    val diff = for (i1 <- a1.map(_.length); i2 <- a2.map(_.length)) yield (i1 - i2).abs\n    diff.max\n  }\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566543703c72200f0b0000c9":[{"id":334757,"user_id":573,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int =\n    LazyList\n      .iterate((s0.toDouble, i0.toDouble)) {\n        case (s_1, i_1) =>\n          val dt = tm \/ n.toDouble\n          (s_1 * (1 - dt * b * i_1), i_1 * (1 + dt * (b * s_1 - a)))\n      }\n      .take(n)\n      .map(_._2.toInt)\n      .max\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334758,"user_id":null,"body":"object Epidem {\n  \n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n    import scala.annotation.tailrec\n    \n    val dt = tm.toDouble \/ n\n\n    @tailrec\n    def epidemicRec(n: Int, s0: Double, i0: Double, r0:Double, maxInfected:Double):Int ={\n      if(n == 0){\n        maxInfected.intValue\n      } else {\n        val newInfected = dt * b * s0 * i0\n        val recoveredInfected = dt * a * i0\n        val infected = i0 + newInfected - recoveredInfected\n\n        epidemicRec(n - 1, s0 - newInfected, infected , r0 + recoveredInfected, math.max(maxInfected,infected))\n      }\n    }\n\n    epidemicRec(n,s0,i0,0D,0D)\n  }    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334759,"user_id":492,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n    var maxI: Double = 0.0\n    var currI: Double = 0.0\n    var dt: Double = tm.toDouble \/ n\n    var sd: Double = s0\n    var id: Double = i0\n    var rd: Double = 0\n    for (i <- 0 until n) {\n      currI = id\n      rd = rd + currI * a * dt\n      id = currI + dt * (b * sd * currI - a * currI)\n      sd = sd - dt * b * sd * currI\n      maxI = if (maxI < id) id else maxI\n    }\n    maxI.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334760,"user_id":573,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n\n    val dt = tm \/ n.toDouble\n\n    (1 to n)\n      .scanLeft((s0.toDouble, i0.toDouble)) {\n        case ((s_1, i_1), _) => (s(s_1, i_1, dt, a, b), i(s_1, i_1, dt, a, b))\n      }\n      .maxBy(_._2)\n      ._2\n      .toInt\n  }\n\n  def s(s_1: Double, i_1: Double, dt: Double, a: Double, b: Double): Double = s_1 * (1 - dt * b * i_1)\n  def i(s_1: Double, i_1: Double, dt: Double, a: Double, b: Double): Double = i_1 * (1 + dt * (b * s_1 - a))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334761,"user_id":null,"body":"object Epidem {\n  def epidemic(\n    tm: Int, \/\/ days\n    n: Int, \/\/ number of intervals\n    s0: Int, \/\/ susceptible at day 0\n    i0: Int, \/\/ infected at day 0\n    b: Double, \/\/ number of contacts which can spread the disease\n    a: Double, \/\/ fraction of recovery\n  ): Int = {\n    val dt = tm.toDouble \/ n.toDouble\n    var S = s0.toDouble\n    var I = i0.toDouble\n    var R = 0.toDouble\n    var maxI = I\n    for (_ <- 1 to n) {\n      val nextS = S - dt * b * S * I\n      val nextI = I + dt * (b * S * I - a * I)\n      val nextR = R + dt * I * a\n      S = nextS\n      I = nextI\n      R = nextR\n      if (maxI < I) maxI = I\n    }\n    return maxI.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334762,"user_id":636,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n      val dt = tm.toDouble \/ n\n\n      def incS(s: Double, i:Double) = s - dt * b * s * i\n      def incI(s: Double, i:Double) = i + dt * (b * s * i - a * i)\n\n      def findMax(currS: Double, currI: Double): Double = {\n        val newS = incS(currS, currI)\n        val newI = incI(currS, currI)\n        if (newI > currI) findMax (newS, newI)\n        else currI\n      }\n\n      findMax(s0, i0).toInt\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334763,"user_id":null,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n    val dt = tm.toDouble \/ n\n    val r0 = 0\n    \n    def calcSpread(s: Double, i: Double, r: Double, sMax: Double = i0, d: Int = 0): Int = {\n      if(d == n) {\n        sMax.toInt\n      }\n      else {\n        val maxNew = sMax.max(i)\n        val sNew = s - dt * b * s * i\n        val iNew = i + dt * (b * s * i - a * i)\n        val rNew = r + dt * i * a\n        calcSpread(sNew, iNew, rNew, maxNew, d + 1)\n      }\n    }\n    \n    calcSpread(s0, i0, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334764,"user_id":null,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n    val dt = tm.toDouble \/ n\n    val r0 = 0\n    \n    def calculateSpread(s: Double, i: Double, r: Double, maxS: Double = i0, d: Int = 0): Int = {\n      if(d == n) {\n        maxS.toInt\n      }\n      else {\n        val newMax = maxS.max(i)\n        val newS = s - dt * b * s * i\n        val newI = i + dt * (b * s * i - a * i)\n        val newR = r + dt * i * a\n        calculateSpread(newS, newI, newR, newMax, d + 1)\n      }\n    }\n    \n    calculateSpread(s0, i0, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334765,"user_id":468,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n    val dt: Double = tm * 1.0 \/ n\n\n    @scala.annotation.tailrec\n    def simulate(s: Double, i: Double, r: Double, step: Int, maxI: Double): Double = if (step == n) maxI else\n      simulate(s - dt * b * s * i, i + dt * (b * s * i - a * i), r + dt * (a * i), step + 1, i max maxI)\n\n    simulate(s0, i0, 0d, 0, 0d).toInt\n  }\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334766,"user_id":null,"body":"object Epidem {\n\n  def epidemic(tm: Int, n: Int, s0: Int, i0: Int, b: Double, a: Double): Int = {\n    val dt: Double = tm.toDouble \/ n.toDouble\n    var s = new Array[Double](n); s(0) = s0\n    var i = new Array[Double](n); i(0) = i0\n    \n    for( itt <- 0 to n-2 ) {\n      s(itt+1) = s(itt) - dt * b * s(itt) * i(itt) \n      i(itt+1) = i(itt) + dt * (b * s(itt) * i(itt) - a * i(itt))\n    }\n    i.reduceLeft(_ max _).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5667e8f4e3f572a8f2000039":[{"id":334767,"user_id":527,"body":"object Codewars {\n  def accum(s: String) = {\n    s.zipWithIndex.map{ case (c, i) => c.toUpper + c.toLower.toString * i }.mkString(\"-\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334768,"user_id":null,"body":"object Codewars {\n  def accum(s: String) = {\n    s.zipWithIndex.map {\n      case (char, index) =>\n        char.toUpper + Stream.fill(index)(char.toLower).mkString(\"\")\n    }.mkString(\"-\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334769,"user_id":575,"body":"object Codewars {\n  def accum(s: String) = {\n    s.zipWithIndex.map(t => (t._1.toString().toLowerCase() * (t._2+1)).capitalize).mkString(\"-\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334770,"user_id":null,"body":"object Codewars {\n  def accum(s: String) = {\n    s.toUpperCase.split(\"\").zipWithIndex.collect {\n      case (a, b) => s\"$a${a.toLowerCase * b}\"\n    }\n  }.toList.mkString(\"-\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334771,"user_id":null,"body":"object Codewars {\n  def accum(s: String): String = s.indices.map(i => (s(i).toLower.toString * (i + 1)).capitalize).mkString(\"-\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334772,"user_id":null,"body":"object Codewars {\n  def accum(s: String) = {\n    s.zipWithIndex.map {\n      case (c, i) => s\"${c.toUpper}${s\"${c.toLower}\" * i}\"\n    }.mkString(\"-\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334773,"user_id":null,"body":"object Codewars {\n  def accum(inputString: String) = {\n    def toMumbleWord(letter: Char, position: Int) = {\n      (letter.toString * position).capitalize\n    }\n\n    val mumbleWords =\n      inputString\n        .toLowerCase\n        .toCharArray\n        .zipWithIndex.map { case (char: Char, characterIndex: Int) => toMumbleWord(char, characterIndex + 1) }\n\n    mumbleWords.mkString(\"-\")\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334774,"user_id":null,"body":"object Codewars {\n  def accum(s: String) = {\n    s.toLowerCase.toList.zipWithIndex.map(x=>(x._1).toString*(x._2+1)).map(_.capitalize).mkString(\"-\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334775,"user_id":null,"body":"object Codewars {\n  def accum(s: String): String = {\n    var res = s\"\"\n    for ( i <- 0 to s.size-1)\n      res = res + s\"${s(i)}\".toUpperCase + (s\"${s(i)}\".toLowerCase * (i)) + \"-\"\n    res dropRight 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334776,"user_id":null,"body":"object Codewars {\n  \n  def accum(s: String): String = \n  {\n    (0 to s.length - 1).map( ind => if(ind == 0) s.charAt(ind).toString.toUpperCase \n                                else s.charAt(ind).toString.toUpperCase + s.charAt(ind).toString.toLowerCase * (ind)).mkString(\"-\")\n  \n  }\n  \n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566be96bb3174e155300001b":[{"id":334777,"user_id":573,"body":"object Ball {\n\n  def maxBall(v0: Int): Int = (v0 \/ 3.5316).round.toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334778,"user_id":573,"body":"object Ball {\n\n  def maxBall(v0: Int): Int =\n    Iterator\n      .from(0)                                           \/\/ infinite iterator starting from t = 0\n      .map(_.toDouble \/ 10)                              \/\/ t as tenth of a second\n      .map(t => v0\/3.6*t - 0.5*9.81*t*t)                 \/\/ t to height\n      .sliding(2)                                        \/\/ slide successive heights\n      .zipWithIndex                                      \/\/ as we're interested in the index\n      .collectFirst { case (h, i) if h(0) >= h(1) => i } \/\/ first index for which the next height is inferior\n      .get                                               \/\/ from Option[Int] to Int\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334779,"user_id":492,"body":"object Ball {\n\n  def maxBall(v0: Int): Int = Math.round(v0 \/ 3.5316).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334780,"user_id":null,"body":"object Ball {\n  val g = 9.81\n\n  def maxBall(v0: Int): Int = {\n    def calc(v: Int, t: Int): Double = {\n      (v \/ 3.6) * (t \/ 10d) - 0.5 * g * t * t \/ 100d\n    }\n    Stream.from(1).map(i => i -> calc(v0,i)).takeWhile(_._2 > 0).maxBy(_._2)._1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334781,"user_id":1285,"body":"object Ball {\n\n  val g = 9.81\n\n  def maxBall(v0: Int): Int = {\n    val v: Double = (v0 * 1000).toDouble \/ 360\n    def loop(tenths: Int, lastH: Double): Int = {\n      val t = tenths\n      val h = v * t - .5 * g * t * t\n      println(h)\n      if (h < lastH) tenths - 1\n      else loop(tenths + 1, h)\n    }\n    \n    loop(0, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334782,"user_id":null,"body":"object Ball {\n  val g = 9.81\n  val recordingFrequency = 0.1\n\n  def maxBall(v0: Int): Int = {\n    val v1 = v0 \/ 3.6\n    val t1 = v1 \/ g\n    val recordsCount = t1 \/ recordingFrequency\n    math.round(recordsCount).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334783,"user_id":null,"body":"object Ball {\n\n  final val g: Double = 9.81\n  def transformSpeed(v0: Int): Double = v0.toDouble * 5 \/ 18\n  def t(v0: Int): Double = BigDecimal(transformSpeed(v0) \/ g).setScale(1, BigDecimal.RoundingMode.DOWN).toDouble\n  def h(v0: Int, t: Double): Double = transformSpeed(v0) * t - 0.5 * g * t * t\n  def maxBall(v0: Int): Int = {\n    val tStop = t(v0)\n    if (h(v0, tStop) >= h(v0, tStop + 0.1)) (tStop * 10).toInt else (tStop * 10).toInt + 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334784,"user_id":null,"body":"object Ball {\n\n  def computeHeight(v: Double, t: Double): Double = v * t - 0.5 * 9.81 * t * t\n  \n  def createLazyList(v: Double, t: Double): LazyList[(Double, Double)] =\n    LazyList.cons((computeHeight(v, t), t), createLazyList(v, t + 0.1))\n  \n  def maxBall(v0: Int): Int = {\n  \n    def helper(list: LazyList[(Double, Double)], last: (Double, Double)): Double = {\n      list match {\n        case LazyList.cons(a, tail) =>\n          if (a._1 < last._1) last._2\n          else helper(tail, a)\n        case _ => 0.0\n      }\n    }\n  \n    val v = v0 \/ 3.6\n    val list = createLazyList(v, 0)\n    (helper(list, (0.0, 0.0)) * 10).round.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334785,"user_id":null,"body":"object Ball {\n\n  def maxBall(v0: Int,t: Int = 0,h: Double = 0):Int = {\n    val height = v0.toDouble * (t+1)\/36 - .5*9.81*(t+1)*(t+1)\/100\n\n    if (height > h) maxBall(v0,t+1,height)\n    else t\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334786,"user_id":null,"body":"object Ball {\n\n  def maxBall(v0: Int): Int = {\n    val v=v0\/3.6;\n  val t=v\/9.81;\n    val result=t*10;\n    return (result).round.toInt\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566fc12495810954b1000030":[{"id":334787,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int = {\n    (0 to n).flatMap(i => (i*i).toString).count(j => j.asDigit==d)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334788,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int =\n    (for (k <- 0 to n) yield (k * k).toString.map(_.asDigit).count(_ == d)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334789,"user_id":573,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int =\n    (0 to n).map(i => i*i).mkString.count(_ == '0' + d)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334790,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int = {\n    (0 to n).map(num => (num * num).toString.filter(_.toString == s\"$d\").length).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334791,"user_id":null,"body":"object CountDig {\n  def nb_dig(n: Int, d: Int): Int =\n    (0 to n).toList\n      .map(i => (i * i).toString)\n      .map(d.toString.r.findAllIn(_).length)\n      .sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334792,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int = {\n    (for (i <- 0 to n) yield (i * i).toString.count(_ == d.toString.head)).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334793,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int = List.range(0, n + 1).flatMap(math.pow(_, 2).toInt.toString).count(_.toString == d.toString)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334794,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int = \n    List.range(0, n + 1).map(v => v * v).mkString.count(_.toString.toInt == d)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334795,"user_id":null,"body":"object CountDig {\n\n  def countDigit(n: Int, d: Int): Int = {\n    n.toString.filter(c => c == d.toString.charAt(0)).size\n  }\n\n  def nb_dig(n: Int, d: Int): Int = {\n    (0 to n).map(n => n * n).map(countDigit(_, d)).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334796,"user_id":null,"body":"object CountDig {\n\n  def nb_dig(n: Int, d: Int): Int = \n    (0 to n).map(Math.pow(_, 2).toInt).mkString.count(_ == s\"$d\".head)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5672682212c8ecf83e000050":[{"id":334797,"user_id":null,"body":"object Kata {\n\n  def dbl_linear(n: Int): Int = {\n    var u = Vector(1)\n    var i = 1\n    var (p2, p3) = (0, 0)\n\n    while(i <= n) {\n      u = u :+ math.min(2 * u(p2) + 1, 3 * u(p3) + 1)\n      if(u(i) == 2 * u(p2) + 1) p2 += 1\n      if(u(i) == 3 * u(p3) + 1) p3 += 1\n      i += 1\n    }\n    u(n)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334798,"user_id":null,"body":"import scala.collection.immutable.SortedSet\n\nobject Kata {\n  def dbl_linear(n: Int): Int = doIteration(SortedSet(1), n)\n\n  @scala.annotation.tailrec\n  private def doIteration(sortedSet: SortedSet[Int], index: Int): Int = index match {\n    case 0 => sortedSet.head\n    case _ => doIteration(sortedSet.tail + (2 * sortedSet.head + 1) + (3 * sortedSet.head + 1), index - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334799,"user_id":null,"body":"object Kata {\n\n  lazy val u:LazyList[Int] = (1  #:: u.flatMap(x => Seq(2 * x + 1, 3 * x + 1))).distinct\n\n  def dbl_linear(n: Int): Int = {\n    val a = u.take(10*n).toList.sorted\n    a(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334800,"user_id":null,"body":"object Kata {\n\nimport scala.collection.SortedSet\n\n  def dbl_linear(n: Int, result: SortedSet[Int] = SortedSet(1)): Int = {\n    val head = result.head\n    if (n == 0) head\n    else dbl_linear(n - 1, result.tail ++ SortedSet(head * 2 + 1, head * 3 + 1 ))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334801,"user_id":null,"body":"object Kata {\n\n  import scala.collection.SortedSet\n\n  def dbl_linear(n: Int): Int = {\n    var set = SortedSet(1)\n    var i = 0\n    while (i < n) {\n      val x = set.head\n      set = set.tail + (2 * x + 1, 3 * x + 1)\n      i += 1\n    }\n    set.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334802,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nobject Kata {\n\n  def y: Int => Int = x => 2 * x + 1\n  def z: Int => Int = x => 3 * x + 1\n\n  def dequeMin(yQueue: Queue[Int], zQueue: Queue[Int]): (Int, Queue[Int], Queue[Int]) = (yQueue, zQueue) match {\n    case (ys, zs) if zs isEmpty => (ys.head, ys.tail, zQueue)\n    case (ys, zs) if ys isEmpty => (zs.head, yQueue, zs.tail)\n    case (ys, zs) if ys.head == zs.head => (zs.head, ys.tail, zs.tail)\n    case (ys, zs) if Math.min(ys.head, zs.head) == ys.head => (ys.head, ys.tail, zs)\n    case (_, _) => (zQueue.head, yQueue, zQueue.tail)\n  }\n\n  def dbl_linear(n: Int): Int = {\n\n    @tailrec\n    def go(current: Int, acc: Int, yQueue: Queue[Int], zQueue: Queue[Int]): Int = {\n      if (current == n) acc\n      else {\n        val (min, newYQueue, newZQueue) = dequeMin(yQueue, zQueue)\n        go(current + 1, min, newYQueue enqueue y(min), newZQueue enqueue z(min))\n      }\n    }\n\n    go(0, 1, Queue[Int](3), Queue[Int](4))\n\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334803,"user_id":null,"body":"\nimport scala.collection.mutable\nobject Kata {\n\ndef dbl_linear(n: Int): Int = {\n  var u = mutable.TreeSet(1)\n  val x = 1\n  val y = 2 * x + 1\n  val z = 3 * x + 1\n  var pq = mutable.PriorityQueue(-y,-z)\n  var done = false\n  while (!done) {\n    if (pq.isEmpty) {\n      done = true\n    } else if (u.size >= (2*n)) {\n      done = true\n    } else {\n      val x = -pq.dequeue()\n      u.add(x)\n      val y = 2 * x + 1\n      if (!u.contains(y)) {\n        pq.enqueue(-y)\n      }\n      val z = 3 * x + 1\n      if (!u.contains(z)) {\n        pq.enqueue(-z)\n      }\n\n    }\n  }\n\n  val arr = u.toArray\n  arr(n)\n}\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334804,"user_id":468,"body":"import scala.annotation.tailrec\nimport scala.collection.immutable\n\nobject Kata {\n\n  def dbl_linear(n: Int): Int = {\n\n    @tailrec\n    def loop(set: immutable.TreeSet[Int], queue: immutable.TreeSet[Int]): Int =\n      if (set.size > n) set.toList(n) else {\n        val next = queue.head\n        loop(set.incl(next), queue.tail ++ immutable.TreeSet(2 * next + 1, 3 * next + 1))\n      }\n\n\n    loop(immutable.TreeSet(1), immutable.TreeSet(3, 4))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334805,"user_id":468,"body":"import scala.annotation.tailrec\nimport scala.collection.immutable\n\nobject Kata {\n\n  def dbl_linear(n: Int): Int = {\n\n    @tailrec\n    def loop(set: immutable.TreeSet[Int], queue: Set[Int]): Int =\n      if (set.size > n) set.toList(n) else {\n        val next = queue.head\n        loop(set.incl(next), queue.tail ++ immutable.TreeSet(2 * next + 1, 3 * next + 1))\n      }\n\n\n    loop(immutable.TreeSet(1), immutable.TreeSet(3, 4))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334806,"user_id":null,"body":"object Kata {\n\n  import scala.annotation.tailrec\n  def dbl_linear(n: Int): Int = {\n    @tailrec\n    def dbl_linearHelper(l: Vector[Int]): Int = {\n      val t = if (l.size <= n) -1 else l.drop(n).head\n      val newL = l.flatMap(i => Vector(i, 2 * i + 1, 3 * i + 1)).sorted.distinct\n      val t1 = if (newL.size <= n) -2 else newL.drop(n).head\n      if (t1 != t) dbl_linearHelper(newL) else t1\n    }\n    dbl_linearHelper(Vector(1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56747fd5cb988479af000028":[{"id":334807,"user_id":573,"body":"object MiddleChar {\n\n  def get_middle(s: String): String =\n    s.slice((s.size-1)\/2, s.size\/2+1)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334808,"user_id":null,"body":"object MiddleChar {\n  def get_middle(string: String): String =\n    if (string.length <= 2) string\n    else middle(string drop 1 dropRight 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334809,"user_id":null,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = s.substring((s.length - 1) \/ 2, s.length \/ 2 + 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334810,"user_id":1784,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = s.length % 2 match {\n    case 0 => s\"${s(s.length\/2 - 1)}${s(s.length\/2)}\"\n    case 1 => s(s.length\/2).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334811,"user_id":null,"body":"object MiddleChar {\n    def get_middle(s: String): String = s  match {\n      case str if str.length == 1 => str\n      case str if str.length %2 != 0 => str((s.length - 1) \/ 2).toString\n      case str => str.slice((s.length - 1) \/ 2, (s.length - 1) \/ 2 + 2 )\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334812,"user_id":null,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = {\n    s.length match {\n      case 1 | 2 => s\n      case _ => middle(s.slice(1, s.length -1))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334813,"user_id":null,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = if(s.length()%2!=0) s((s.length\/2)).toString() else s((s.length()\/2)-1).toString+s((s.length\/2)).toString()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334814,"user_id":null,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = if(s.length %2 ==0) (s.charAt(s.length\/2-1)+s.charAt(s.length\/2).toString) else s.charAt(s.length\/2).toString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334815,"user_id":null,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = s drop ( (s.length - 1) \/ 2) take (2 - s.length % 2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334816,"user_id":null,"body":"object MiddleChar {\n\n  def get_middle(s: String): String = s match {\n    case \"\" => \"\"\n    case s if s.length == 1 => s\n    case s if s.length % 2 == 0 => s.substring(s.length\/2-1,s.length\/2+1)\n    case _ => s.substring(s.length\/2,s.length\/2+1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"567501aec64b81e252000003":[{"id":334817,"user_id":null,"body":"object EasyWallPaper {\n  val numbers = List(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    if (l*w*h == 0) numbers.head\n    else {\n      val rolls = 2 * (l + w) \/ 0.52\n      val res = Math.ceil(1.15 * rolls * h \/ 10).toInt\n      numbers(res)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334818,"user_id":null,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    \/\/ your code\n    val numbers = List (\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    numbers( if (l*w*h!=0)(1.15*2*(l+w)*h\/5.2).toInt+1 else 0 ) \n   \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334819,"user_id":null,"body":"object EasyWallPaper {\n  \n  val numbers = List(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n  def wallPaper(l: Double, w: Double, h: Double)= {\n    val totalRolls = 200 * (l + w) \/ 52\n    val heigthInRoll = 10 \/ h\n    val index = if ((l * w * h) == 0) 0 else (totalRolls \/ heigthInRoll * 1.15).ceil.toInt\n    numbers(index)\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334820,"user_id":null,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    if(l == 0.0 || w == 0.0 || h == 0.0) \"zero\" else{\n      val numbers = Array(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n      \/\/ your code - naive\n\n      val rollWidth: Double = 0.52\n      val rollLength: Double = 10\n\n      val columns = (l*2 + w*2) \/ rollWidth\n\n      val rolls = 1.15 * ((columns * h) \/ rollLength)\n\n      numbers(rolls.ceil.toInt)\n    }\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334821,"user_id":null,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    val numbers = Array(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n\n    if (Seq(l, w, h).count(_ == 0) > 0) return numbers(0)\n\n    val oneRollWidth = 0.52\n    val oneRollLength = 10\n\n    val sideArea = ((l + w) * h) * 2\n    val extraSideArea = sideArea * 1.15\n\n    val rollArea = oneRollWidth * oneRollLength\n\n    val res = (extraSideArea \/ rollArea).ceil.toInt\n\n    numbers(res)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334822,"user_id":null,"body":"object EasyWallPaper {\n\n  val numbers = Array(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n\n  def wallPaper(l: Double, w: Double, h: Double):String = {\n    if (l>0 && w>0 && h>=0) {\n      val area = 2 * ((l * h) \/ 0.52) + 2 * ((w * h) \/ 0.52)\n      val rolls = area \/ 10\n      val extra = rolls * 0.15\n      val total = math.ceil(rolls + extra).toInt\n      numbers(total)\n    }\n    else numbers(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334823,"user_id":53,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    val ns: Array[String] = Array(\n      \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n      \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    if (l <= 0 || w <= 0 || h <= 0) ns(0)\n    else ns((((l + w) * 2.3 * h) \/ 5.2 + 1).toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334824,"user_id":null,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    val numbers = Array(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    val dic = numbers.zipWithIndex.map{case(k,v) =>(v,k)}.toMap\n    val roll = 0.52 * 10\n    val surface = 2 * (w*h + l*h)\n    val pr = surface * 15\/100\n    val stotal = surface + pr\n    val nbRoll = if(l == 0 || w == 0) 0 else (stotal \/ roll).ceil.toInt\n    dic.getOrElse(nbRoll,nbRoll.toString)\n    \n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334825,"user_id":null,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    val x = math.ceil(2 * (l + w) * h * 1.15 \/ 5.2).toInt\n\nval numbers = Map(\n  1 -> \"one\",\n  2 -> \"two\",\n  3 -> \"three\",\n  4 -> \"four\",\n  5 -> \"five\",\n  6 -> \"six\",\n  7 -> \"seven\",\n  8 -> \"eight\",\n  9 -> \"nine\",\n  10 -> \"ten\",\n  11 -> \"eleven\",\n  12 -> \"twelve\",\n  13 -> \"thirteen\",\n  14 -> \"fourteen\",\n  15 -> \"fifteen\",\n  16 -> \"sixteen\",\n  17 -> \"seventeen\",\n  18 -> \"eighteen\",\n  19 -> \"nineteen\",\n  20 -> \"twenty\"\n)\n\nif(l*w*h == 0) \"zero\"\nelse numbers.apply(x)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334826,"user_id":null,"body":"object EasyWallPaper {\n\n  def wallPaper(l: Double, w: Double, h: Double): String = {\n    val numbers = List(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\",\"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\")\n    val wallsSqr = (2 * l * h) + (2 * w * h)\n    val roll = (wallsSqr + (wallsSqr * 15 \/ 100)) \/ 5.2\n    numbers(if (l * w * h > 0) math.ceil(roll).toInt else 0)  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"568d0dd208ee69389d000016":[{"id":334827,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost(days: Int): Int = days match {\n    case d if(d >= 7) => days * 40 - 50\n    case d if(d >= 3) => days * 40 - 20\n    case _ => days * 40\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334828,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost(days: Int): Int = {\n    val dailyCost = 40\n    val sevenDayDiscount = 50\n    val threeDayDiscount = 20\n   \n    days match {\n      case d if 0 until 3 contains d => d * dailyCost\n      case d if 3 until 7 contains d => d * dailyCost - threeDayDiscount\n      case d => d * dailyCost - sevenDayDiscount\n    }\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334829,"user_id":573,"body":"object Rental {\n\n  def rental_car_cost(days: Int): Int =\n    days * 40 - (if (days >= 7) 50 else if (days >= 3) 20 else 0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334830,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost( days: Int): Int = {\n    val total = days*40\n    days match {\n      case days if (days>=7) => total-50\n      case days if (days>=3 && days<7) => total - 20\n      case _ => total\n    }\n    \n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334831,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost(days : Int) : Int = {\n    val pricePerDay = 40\n    if (days < 3) {\n      return days*pricePerDay\n    }\n    else if (days > 2 && days < 7) {\n      return days*pricePerDay-20\n    }\n    days*pricePerDay-50\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334832,"user_id":null,"body":"object Rental {\n\n      def rental_car_cost(days: Int): Int = {\n            val rental_car_cost = days * 40\n\n            days match {\n            case days if days >= 7 => rental_car_cost - 50\n            case days if days >= 3 => rental_car_cost - 20\n            case _ => rental_car_cost\n      }}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334833,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost(days: Int): Int = {\n    var rental_car_cost = days * 40\n    if (days >= 7) return rental_car_cost - 50\n    else if (days >= 3) return rental_car_cost - 20\n    else return rental_car_cost\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334834,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost(days: Int): Int = days match { \n      case long:Int if long >= 7 => (days * 40)  - 50\n      case med:Int if med >= 3 && med < 7 => (days * 40) - 20\n      case _ => days * 40\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334835,"user_id":null,"body":"object Rental {\n  def rental_car_cost(days: Int): Int = days match {\n    case x if 3<=x & x<7 => days * 40 - 20\n    case x if x < 3 => days * 40\n    case x if x >=7 => days * 40 - 50\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334836,"user_id":null,"body":"object Rental {\n\n  def rental_car_cost(days: Int): Int = {\n  val x= List.range(1,days)  \n  var sum = 40\n  for(i <- x){\n    sum = sum + 40\n  }\n    \n  if(days>2){sum = sum - 20}\n  if(days>6){sum = sum - 30}\n  sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"569218bc919ccba77000000b":[{"id":334837,"user_id":null,"body":"import java.time.LocalDate\n\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    def daysTillTarget(a0: Double, day: Int): Int = {\n      if(a0 >= a) day\n      else {\n        val gain = a0 * p \/ 100 \/ 360\n        daysTillTarget(a0 + gain, day + 1)\n      }\n    }\n  \n    val days = daysTillTarget(a0, 0)\n  \n    val start = LocalDate.parse(\"2016-01-01\")\n    val end = start.plusDays(days)\n    s\"${end.toString}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334838,"user_id":null,"body":"import java.util.Calendar\n\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    def daysTillTarget(a0: Double, day: Int): Int = {\n      if(a0 >= a) day\n      else {\n        val gain = a0 * p \/ 100 \/ 360\n        daysTillTarget(a0 + gain, day + 1)\n      }\n    }\n  \n    val days = daysTillTarget(a0, 0)\n  \n    val sdf = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n    val c = Calendar.getInstance\n    c.setTime(sdf.parse(\"2016-01-01\"))\n    c.add(Calendar.DATE, days)\n    sdf.format(c.getTime)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334839,"user_id":null,"body":"import java.time.LocalDate\n\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    var date = LocalDate.parse(\"2016-01-01\")\n    def days(a0: Double, day: Int):Int = {\n      var amount_of_days = day\n      var amount = a0\n      while(amount <= a){\n        amount += amount * (p\/36000)\n        amount_of_days += 1\n      }\n       amount_of_days\n    }\n   val res = days(a0,0)\n    date.plusDays(res).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334840,"user_id":null,"body":"object DateDays {\n  \nimport java.time.LocalDate\n  \n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n      var amount = a0\n        var days: Long = 0\n        var answer = LocalDate.parse(\"2016-01-01\")\n        while (amount < a) {\n            amount = amount + amount*(p\/36000)\n            days += 1\n        }\n\n        return answer.plusDays(days).toString()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334841,"user_id":null,"body":"import java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.text.ParseException;\n\n\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    \/\/ your code\n    \n    var oldDate = \"2016-01-01\"\n    \n    var deposit = a0\n    var days = 0\n    \n    while (deposit < a){\n      \n      deposit +=(deposit * (p\/36000))\n      days +=1\n      \n    }\n    \nvar sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n\tvar c = Calendar.getInstance();\n\n\t   c.setTime(sdf.parse(oldDate));\n\n    c.add(Calendar.DAY_OF_MONTH, days); \n    \n var newDate = sdf.format(c.getTime())\n    \n    newDate\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334842,"user_id":null,"body":"import java.time.LocalDate\nimport java.time.format.DateTimeFormatter\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    var days:Int = 0\n    var a_0: Double = a0\n    val initialDate:java.time.LocalDate = LocalDate.parse(\"2016-01-01\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"))\n    while(a_0<a){\n      a_0 = a_0*(1+p\/36000)\n      days+=1\n    }\n    initialDate.plusDays(days).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334843,"user_id":null,"body":"import java.time.LocalDate\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    \/\/ your code\n    val pd = p\/36000+1\n    val days = Iterator.iterate((a0))(x => (x*pd)).takeWhile(_<=a).size\n    LocalDate.parse(\"2016-01-01\").plusDays(days).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334844,"user_id":null,"body":"import java.text.SimpleDateFormat\nimport java.util.Date\n\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    val sdf = new SimpleDateFormat(\"yyyy-MM-dd\")\n    var an = a0\n    var n = 0\n    while (an < a) {\n      an = (an + an * p \/ 36000)\n      n = n + 1\n    }\n    sdf.format(new Date(sdf.parse(\"2016-01-01\").getTime() + n * 24 * 60 * 60 * 1000L))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334845,"user_id":null,"body":"import java.time.format.DateTimeFormatter\nimport java.time.LocalDate\n\nobject DateDays {\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    var (a_n, n) = (a0, 0)\n    while (a_n < a) {\n      a_n += a_n * p \/ 36000.0\n      n += 1\n    }\n    \n    LocalDate.parse(\"2016-01-01\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")).plusDays(n).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334846,"user_id":null,"body":"object DateDays {\n  import java.time.LocalDateTime\n  def dateNbDays(a0: Double, a: Double, p: Double): String = {\n    var sum:Double = a0\n    var b:Boolean = false\n    var i:Int = 0\n\n    while (b == false)\n      {\n        if (sum >= a)\n          b = true\n        else\n        {\n          i+=1\n          sum = sum + sum*p\/36000\n        }\n      }\n\n    val d:LocalDateTime = LocalDateTime.of(2016,1,1,0,0,0)\n    d.plusDays(i).toLocalDate.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"569b5cec755dd3534d00000f":[{"id":334847,"user_id":573,"body":"object  NewAverage {\n\n  def newAvg(donations: Array[Double], averageGoal: Double): Option[Int] = {\n    val lastDonation = averageGoal * (donations.size + 1) - donations.sum\n    Option.when(lastDonation > 0)(lastDonation.ceil.toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334848,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    (navg  * (arr.length + 1)) - arr.sum match {\n      case x if x >= 0 => Some(x.ceil.toInt)\n      case x => None\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334849,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    \n    \n    \n  var x = navg * (arr.size+1) - arr.sum\n  \n \n  (x > 0) match {\n\n    case true => Some(x.ceil.toInt)\n    case false => None\n\n\n  }\n                                                               \n\n\n    \n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334850,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    var x=0.0\n    \n    x = navg * (arr.size + 1) - arr.map(x => x).sum\n    if(x<0){\n      None\n    }else {\n      Option(x.ceil.toInt)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334851,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    val res = ((navg - (arr.sum) \/ (arr.length + 1)) * (arr.length + 1))\n    if (res > 0) Some(Math.ceil(res).toInt) else None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334852,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    val difference_ideal_actual = (navg * (arr.size + 1)) - arr.sum\n    if (difference_ideal_actual <= 0) None\n    else Some(difference_ideal_actual.ceil.toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334853,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    val nextNum = navg*(arr.size + 1) - arr.sum\n    if (nextNum < 0) None\n    else Some(math.ceil(nextNum).toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334854,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Double] = {\n    \n    val arrSum = arr.sum\n    val reqSum = navg*(arr.length+1)\n    val res = reqSum - arrSum \n\n    if(res <= 0) None\n    else Some(Math.ceil(res).toInt)\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334855,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    Option((navg*(arr.length+1)-arr.sum).ceil.toInt).filter(_>=0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334856,"user_id":null,"body":"object  NewAverage {\n\n  def newAvg(arr: Array[Double], navg: Double): Option[Int] = {\n    var solution = (navg*(arr.length + 1) - arr.sum).ceil.toInt\n    solution match {\n      case solution if solution > 0 => Some(solution)\n      case _ => None\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56a32dd6e4f4748cc3000006":[{"id":334857,"user_id":null,"body":"\nobject Rain {\n\n  case class Record(month: String, measure: Double)\n\n  def parseRecords(records: String): Map[String, List[Record]] = {\n    records\n      .split(\"\\n\")\n      .map { x =>\n        val a = x.split(\":\")\n        val city = a(0)\n        val measures = a(1)\n        city ->\n          measures\n            .split(\",\")\n            .map { x =>\n              val mm = x.split(\" \")\n              Record(mm(0), mm(1).toDouble)\n            }.toList\n      }.toMap\n  }\n\n  def sqr(x: Double) = x*x\n\n  def mean(town: String, data: Map[String, List[Record]]): Double =\n    data.get(town).map(rs => rs.map(_.measure).sum \/ rs.length).getOrElse(-1.0)\n\n  def mean(town: String, strng: String): Double =\n    mean(town, parseRecords(strng))\n\n  def variance(town: String, strng: String): Double = {\n    val data = parseRecords(strng)\n    val m = mean(town, data)\n    data.get(town).map(rs =>\n      rs.map(r => sqr(r.measure - m)).sum \/ rs.length\n    ).getOrElse(-1.0)\n  }\n\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334858,"user_id":2204,"body":"object Rain {\n\n   def mapToNums(s: String, town: String): Option[Array[Float]] = {\n     println(s)\n     println(town)\n     s.split(\"\n\").find(_.indexOf(town + \":\") == 0) match {\n       case Some(a) => Some(a.split(\":\")(1).split(\",\").map(_.slice(4,9).toFloat))\n       case _ => None\n     }\n  }\n                                                  \n  def mean(town: String, strng: String): Double = {\n    val nums = mapToNums(strng, town)\n    nums match {\n      case Some(a) => a.sum\/a.length\n      case _ => -1\n    }\n  }                                               \n\n  def variance(town: String, strng: String): Double = {\n    val nums = mapToNums(strng, town)\n    nums match {\n      case Some(a) => {\n        val meen = a.sum\/a.length\n        a.map(i => Math.pow(i - meen, 2)).sum \/ a.length\n      }\n      case _ => -1\n    }\n  }\n                                            \n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334859,"user_id":492,"body":"import java.util._\n\nobject Rain {\n                                                  \n  def findTown(town: String, strng: String): Boolean = {\n    if (!strng.contains(town + \":\")) false\n    else true\n  }                                               \n\n  def findTownData(town: String, strng: String): Array[Double] = {\n    val s: Array[String] = strng.split(\"\n\")\n    var c = true\n    val v: Array[Double] = Array.ofDim[Double](12)\n    for (i <- 0 until s.length if c == true) {\n      if (s(i).split(\":\")(0) == town) {\n        val nm: Array[String] = s(i).split(\":\")(1).split(\",\")\n        for (i2 <- 0 until nm.length) {\n            v(i2) = java.lang.Double.parseDouble(nm(i2).split(\" \")(1))\n        }\n        c = false\n      }\n    }\n    if (!c) v else Array(-1.0, -1.0)\n  }                                               \n\n  def mean(town: String, strng: String): Double = {\n    if (!findTown(town, strng)) -1\n    else {\n        val v: Array[Double] = findTownData(town, strng)\n        var sum: Double = 0\n        for (i <- 0 until v.length) sum += v(i)\n        sum \/ v.length\n    }\n  }                                               \n\n  def variance(town: String, strng: String): Double = {\n    if (!findTown(town, strng)) -1\n    else {\n      val v: Array[Double] = findTownData(town, strng)\n        val m: Double = mean(town, strng)\n        var temp: Double = 0\n        for (a <- v) temp += (m - a) * (m - a)\n        temp \/ v.length\n    }\n  }                                               \n                                             \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334860,"user_id":null,"body":"object Rain {\n\n  def process(town: String, data: String)(fn: Array[Double] => Double): Double = {\n    val key = s\"$town:\"\n    data.split(\"\n\").find(_.startsWith(key)).map { townData =>\n      townData.split(\":\").last.split(\",\").map(_.split(\" \").last.toDouble)\n    }.map(fn).getOrElse(-1)\n  }\n\n  def mean(town: String, strng: String): Double = {\n    process(town, strng) { arr => arr.sum \/ arr.length }\n  }\n\n  def variance(town: String, strng: String): Double = {\n    process(town, strng) { arr =>\n      val mean = arr.sum \/ arr.length\n      val diffs = arr.map(d => d - mean)\n      diffs.map(d => d * d).sum \/ diffs.length\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334861,"user_id":null,"body":"object Rain {\n                                                  \n  def mean(town: String, strng: String): Double = {\n    val dataMap = strng.split(\"\\\n\").map(_.trim).map(line => line.split(\":\")).map(l => l(0) -> l(1).split(\",\").map(t => t.split(\" \")(1).toDouble)).toMap\n\n    dataMap contains town match {\n      case true => dataMap(town).sum \/ dataMap(town).length\n      case _ => -1\n    }\n  }\n\n  def variance(town: String, strng: String): Double = {\n    val dataMap = strng.split(\"\\\n\").map(_.trim).map(line => line.split(\":\")).map(l => l(0) -> l(1).split(\",\").map(t => t.split(\" \")(1).toDouble)).toMap\n    dataMap contains town match {\n      case true =>\n        val digits = dataMap(town)\n        val mean = digits.sum \/ digits.length\n        digits.map(x => (x - mean)* (x - mean)).sum \/ digits.length\n      case _ => -1\n    }\n  }                                      \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334862,"user_id":null,"body":"object Rain {\n                                                  \n  def mean(town: String, strng: String): Double = {\n    val lookup: Map[String, List[String]] = strng.split(\"\n\").toList.map(_.split(\":\").toList).map(pair => pair.head -> pair.tail)\n      .map(pair => (pair._1, pair._2.head.split(\",\")\n        .map(pair => pair.split(\" \").tail.mkString).toList)).toMap\n    try{\n        lookup(town).map(_.toDouble).sum \/ lookup(town).length\n      } catch {\n      case nse: NoSuchElementException => -1.0\n    }\n  }                                               \n\n  def variance(town: String, strng: String): Double = {\n    val lookup: Map[String, List[String]] = strng.split(\"\n\").toList.map(_.split(\":\").toList).map(pair => pair.head -> pair.tail)\n      .map(pair => (pair._1, pair._2.head.split(\",\")\n        .map(pair => pair.split(\" \").tail.mkString).toList)).toMap\n    try{\n        val values = lookup(town).map(_.toDouble)\n        val rainMean = mean(town, strng)\n        values.map(v => math.pow(v - rainMean, 2)).sum \/ values.length\n    } catch {\n      case nse: NoSuchElementException => -1.0\n    }\n  }\n                                             \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334863,"user_id":null,"body":"object Rain {\n                                                  \n  def mean(town: String, strng: String): Double = {\n    val townData = strng.split(\"\n\").filter(x => x.split(\":\")(0) == town).map(x => x.split(\":\")(1))\n    val townNumbers: List[Double] = townData.flatMap(x => x.split(\",\").map(y=> y.split(\" \")(1))).map(_.toDouble).toList\n    \n    if (townNumbers.isEmpty) -1.0\n    else townNumbers.sum \/ townNumbers.size\n  }                                               \n\n  def variance(town: String, strng: String): Double = {\n    val townData = strng.split(\"\n\").filter(x => x.split(\":\")(0) == town).map(x => x.split(\":\")(1))\n    val townNumbers: List[Double] = townData.flatMap(x => x.split(\",\").map(y=> y.split(\" \")(1))).map(_.toDouble).toList\n    \n    if (townNumbers.isEmpty) -1.0\n    else {\n      val mean = townNumbers.sum \/ townNumbers.size\n      townNumbers.map(x => (x - mean) * (x - mean)).sum \/ townNumbers.size\n      }\n  }\n                                             \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334864,"user_id":null,"body":"object Rain {\n   val towns = Array(\"Rome\", \"London\", \"Paris\", \"NY\", \"Vancouver\", \"Sydney\", \"Bangkok\", \"Tokyo\", \"Beijing\", \"Lima\")\n\n      def getValues (source: String, town: String): Option[Array[Double]] = {\n      if (!(towns contains town)) {\n        None\n      } else {\n      Some(source.split('\n')\n      .toArray.flatMap(_.split(\":\"))\n      .grouped(2)\n      .map {case Array(x: String, y: String) => (x, y)}\n      .toMap\n      .get(town)\n      .getOrElse()\n      .toString\n      .split(\",\")\n      .map(_.drop(4).toDouble)\n      )\n        }\n      }\n      \n      def mean(town: String, strng: String): Double = getValues(strng, town) match {\n          case Some(arr: Array[Double]) => arr.sum \/ arr.length\n          case _ => -1.0 \n        }     \n      \n\n      def variance(town: String, strng: String): Double = getValues(strng, town)  match {\n          case Some(arr: Array[Double]) => arr.map(x => x - mean(town, strng)).map(x => x * x).sum \/ arr.length\n          case _ => -1.0\n        } \n  }\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334865,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject Rain {\n  val regex = new Regex(\"(w+):\")\n\n  def toDictLoad(strng: String): Map[String, Array[Double]] = {\n    val allTowns: Array[String] = strng.split(\"\n\")\n    \n    val processed = for (record <- allTowns) yield {\n      val Array(town, rest) = record.split(\":\")\n\n      val monthlyData = rest.split(\",\")\n      \n      val records = monthlyData.map(_.split(\" \")).map(_(1).toDouble)\n      \n      (town, records)\n    }  \n    \n    processed.toMap\n  } \n  \n  def mean(town: String, strng: String): Double = {\n    val mapping = toDictLoad(strng)\n    \n    mapping.get(town) match {\n      case Some(values) => values.sum \/ values.length\n      case _ => -1\n    }\n  }                                               \n\n  def variance(town: String, strng: String): Double = {\n    val mapping = toDictLoad(strng)\n\n    val values = mapping.getOrElse(town, Array())\n    \n    if (values.length == 0) {\n      return -1\n    }\n    \n    val avg = mean(town, strng)\n\n    \n    values.map(value => Math.pow(value - avg, 2)).foldLeft(0.0)(_ + _) \/ values.length\n  }\n                                             \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334866,"user_id":1285,"body":"object Rain {\n                                                  \n  def mean(town: String, strng: String): Double = {\n    strng.split(\"\\\n\")\n      .filter(_.split(\":\")(0) == town)\n      .map(town => town.split(\":\")(1)\n        .split(\",\")\n        .map(_.split(\" \")(1).toDouble)\n        .sum \/ 12)\n      .headOption\n      .getOrElse(-1)\n  }                                               \n\n  def variance(town: String, strng: String): Double = {\n    val mn = mean(town, strng)\n    strng.split(\"\\\n\")\n      .filter(_.split(\":\")(0) == town)\n      .map(town => town.split(\":\")(1)\n        .split(\",\")\n        .map(_.split(\" \")(1).toDouble)\n        .map(rain => (rain - mn) * (rain - mn))\n        .sum \/ 12)\n      .headOption\n      .getOrElse(-1)\n  }\n                                             \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56a4872cbb65f3a610000026":[{"id":334867,"user_id":573,"body":"object MaxRotate {\n\n  def max_rot(n: Long): Long =\n    s\"$n\".indices.scanLeft(s\"$n\")((x, i) => s\"${x.take(i)}${x.drop(i+1)}${x(i)}\").max.toLong\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334868,"user_id":null,"body":"object MaxRotate {\n\n  def rotate(s: String, i: Int): String = {\n    s.drop(i) + s.take(i)\n  }\n\n  def max_rot(n: Long): Long = {\n\n    (0 until n.toString.length)\n      .scanLeft(n) { case (acc, i) =>\n        val str = acc.toString\n        (str.take(i) + rotate(str.drop(i), 1)).toLong\n      }\n      .max\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334869,"user_id":null,"body":"object MaxRotate {\n\n  def max_rot(n: Long): Long = recursion(n, n.toString, n.toString.length)\n  \n  @scala.annotation.tailrec\n  def recursion(maxSoFar:Long, number: String, digitsToRotate: Int): Long = {\n    if(digitsToRotate == 1) maxSoFar else {\n      val rotated = number.dropRight(digitsToRotate)+rotate(number.takeRight(digitsToRotate)) \n      recursion(math.max(maxSoFar, rotated.toLong), rotated, digitsToRotate - 1)\n    }\n  }\n  \n  def rotate(n: String) = n.drop(1) + n.take(1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334870,"user_id":null,"body":"object MaxRotate {\n\n   def max_rot(n: Long): Long = {\n    val s = n.toString()\n    (0 to s.size).scanLeft(s) { (m, n) =>\n      rotAt(m, n)\n    }.map(_.toLong).max\n  }\n\n  def rot(str: String): String = {\n    val (head, tail) = str.splitAt(1)\n    tail + head\n  }\n\n  def rotAt(s: String, at: Int): String = {\n    val (a, b) = s.splitAt(at)\n    a + rot(b)\n    \n  }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334871,"user_id":null,"body":"object MaxRotate {\n  def max_rot(n: Long): Long = {\n    var number = n\n    var answer = n\n    var divisor: Long = 1\n    var long = 0\n    while (number\/divisor != 0) {\n      long += 1\n      divisor *= 10\n    }\n    divisor \/= 10\n\n    while (long != 0) {\n      val fixed = number \/ (divisor*10)\n      val variable = number % (divisor*10)\n      val tail = variable \/ divisor\n      val head = variable % divisor\n      number = fixed*divisor*10 + head*10 + tail\n      if (number > answer) { answer = number }\n      divisor \/= 10\n      long -= 1\n    }\n\n    return answer\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334872,"user_id":null,"body":"object MaxRotate {\n  def max_rot(n: Long): Long = {\n  val r1 = n.toString\n  val l = (0 until r1.length - 1).toList\n\n  def rot(s: String = r1, l: List[Int] = l, res: List[String] = Nil): List[String] = l match {\n    case Nil => r1 +: res\n    case x :: t =>\n      val num = (s.take(x) + s.drop(x + 1) + s(x))\n      rot(num, t, res :+ num)\n  }\n\n  rot().map(_.toLong).max\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334873,"user_id":null,"body":"object MaxRotate {\n  def max_rot(n: Long): Long = {\n  val r1 = n.toString\n  val r2 = r1.tail :+ r1.head\n  val l = (1 until r1.length - 1).toList\n\n  def rot(s: String = r2, l: List[Int] = l, res: List[String] = Nil): List[String] = l match {\n    case Nil => r1 +: r2 +: res\n    case x :: t =>\n      val num = (s.take(x) + s.drop(x + 1) + s(x))\n      rot(num, t, res :+ num)\n  }\n\n  rot().map(_.toLong).max\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334874,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject MaxRotate {\n\n  def max_rot(n: Long): Long = {\n    \n    var ncave = ListBuffer(n.toString)\n    \n    for(a <- 1 to (n.toString.length - 1)){\n      \n    var seq = ncave.last.toString\n    var (first, b) = seq.split(\"\").splitAt(a)\n    var help =first.take(a-1).mkString + b.mkString + first.last.mkString\n    ncave += help }\n    \n    ncave.toList.map((s:String) => s.toLong).max\n    \n   \n    \n} \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334875,"user_id":null,"body":"object MaxRotate {\n\n  def max_rot(n: Long): Long = {\n    var s = n.toString\n    var m =n\n    for (i <- 0 to s.toList.size){\n      val (first1, last1) = s.toList.splitAt(i)\n      val (first, last) = last1.splitAt(1)\n      s= first1.mkString(\"\")+ last.mkString(\"\")+first.mkString(\"\")\n      m= if (s.toLong > m) s.toLong else m\n    }\n   m\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334876,"user_id":null,"body":"object MaxRotate {\n\n  def max_rot(n: Long): Long = {\n    val nlist = n.toString.map(_.asDigit).toList\n\n    def rot(h :List[Int],t: List[Int],m: Long):Long = t match{\n      case Nil =>  m\n      case t if t.length == 1 => val seq = h:::t\n                rot(seq,List(),m.max(seq.mkString.toLong))\n      case _ => val seq = h:::t.tail:::List(t.head)\n                rot(h:::List(t.tail.head),seq.takeRight(t.length - 1),m.max(seq.mkString.toLong))\n\n    }\n\n    rot(List(),nlist,n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56a5d994ac971f1ac500003e":[{"id":334877,"user_id":null,"body":"object longest_consec {\n\n  def longest_consec(strings: Array[String], k: Int): String = {\n    if (strings.size == 0 || k > strings.size || k <= 0)\n      \"\"\n    else\n      strings.sliding(k).map(_.mkString).maxBy(_.length)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334878,"user_id":null,"body":"object longest_consec {\n\n    import scala.annotation.tailrec\n    import scala.collection.immutable.Queue\n\n    def longest_consec(strarr: Array[String], k: Int): String ={\n      val length = strarr.length\n      if(k > length || k <=0) \"\" else longest_consec(strarr.takeRight(length-k), strarr.take(k).to(Queue), \"\")\n    }\n\n    @tailrec\n    def longest_consec(strarr: Array[String], previous: Queue[String] = Queue.empty, result: String = \"\"): String = {\n      val prevString = previous.mkString\n      val newResult = if (prevString.length > result.length) prevString else result\n      strarr.headOption match {\n        case None => newResult\n        case Some(x) => longest_consec(strarr.tail, previous.tail enqueue x, newResult)\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334879,"user_id":null,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n  val n = strarr.length\n  if (k <= 0) return \"\"\n  if (n == 0) return \"\"\n  if (k > n) return \"\"\n  \n  strarr.sliding(k)\n  .map(_.reduce(_ + _))\n  .map(x => (x, x.length))\n  .reduce((acc, next) => if (acc._2 >= next._2) acc else next)  \n  ._1\n\n    }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334880,"user_id":492,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    if (strarr.length == 0 || k > strarr.length || k <= 0) \"\"\n    var longest: String = \"\"\n    for (index <- 0 until strarr.length - k + 1) {\n      val sb: StringBuilder = new StringBuilder()\n      for (i <- index until index + k) {\n        sb.append(strarr(i))\n      }\n      if (sb.toString.length > longest.length) {\n        longest = sb.toString\n      }\n    }\n    longest\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334881,"user_id":492,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    if (strarr.length == 0 || k > strarr.length || k <= 0) \"\"\n    var longest: String = \"\"\n    for (index <- 0 until strarr.length - k + 1) {\n      val sb: StringBuilder = new StringBuilder()\n      for (i <- index until index + k) {\n        sb.append(strarr(i))\n      }\n      if (sb.toString.length > longest.length) {\n        longest = sb.toString\n      }\n    }\n    longest\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334882,"user_id":null,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    if(k <= 0 || strarr.size < k) {\"\"}else\n    {\n      strarr.sliding(k).map(_.mkString).maxBy(_.length)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334883,"user_id":null,"body":"import scala.util.Try\nobject longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    if (k <= 0 || k > strarr.length) \"\"\n    else \n    strarr.sliding(k).map(x => x.mkString(\"\")).toList.maxByOption(_.length) match {\n        case Some(value) if value.length < k || value.isEmpty => \"\"\n        case Some(value) => value\n        case None => \"\"\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334884,"user_id":null,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    var longestWord = \"\"\n    \n    val arrSize = strarr.length\n    if (arrSize == 0 || k > arrSize || k <= 0) return longestWord\n    \n    for (i <- 0 to strarr.length) {\n      val word = strarr.slice(i, i + (if (k < strarr.length) k else strarr.length)).mkString\n      if (word.size > longestWord.size) {\n        longestWord = word\n      }\n    }\n    \n    longestWord\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334885,"user_id":null,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    var max = \"\"\n    val strarrdistinct = strarr.distinct\n    for(i<- 0 to strarrdistinct.length-k) {\n      val s = strarrdistinct.slice(i, i+k).mkString\n      if(s.length > max.length) max = s\n    }\n    max\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334886,"user_id":null,"body":"object longest_consec {\n\n  def longest_consec(strarr: Array[String], k: Int): String = {\n    if(strarr.length < k || k < 1) \"\"\n    else\n    strarr.sliding(k).toList.map(_.mkString).maxBy(_.length)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56af1a20509ce5b9b000001e":[{"id":334887,"user_id":573,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    val adresses = r.split(\",\").collect { case address if address.endsWith(s\" $zipcode\") => address.split(\" \", 2) }\n    val numbers = adresses.map(_(0)).mkString(\",\")\n    val streets = adresses.map(_(1).dropRight(zipcode.size + 1)).mkString(\",\")\n    s\"$zipcode:$streets\/$numbers\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334888,"user_id":null,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    val addresses = r.split(\",\").filter(_.trim.endsWith(zipcode))\n    if(addresses.isEmpty || zipcode.isEmpty) zipcode + \":\/\"\n    else {\n      \n      val hs = addresses\n      .map( a => {\n        val houseNo = a.trim.takeWhile(_.isDigit)\n        val street = a.replace(houseNo, \"\").replace(zipcode, \"\").trim\n        (street, houseNo)\n      })\n      .unzip            \n      zipcode + \":\" + hs._1.mkString(\",\") + \"\/\" + hs._2.mkString(\",\")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334889,"user_id":null,"body":"import scala.util.matching.Regex\nimport java.util.StringJoiner\nobject Travel {\n  \n  val NUMBER_GROUP = 1\n  val STREET_GROUP = 2\n  val ZIP_GROUP = 3\n\n  def travel(r: String, zipcode: String): String = {\n    val adressPattern: Regex = \"([0-9]+) ([^0-9]+) ([A-Z]{2} [0-9]{5})\".r\n    val streets = new StringJoiner(\",\")\n    val numbers = new StringJoiner(\",\")\n    adressPattern.findAllIn(r).matchData.foreach { m =>\n      {\n        if (m.group(ZIP_GROUP) == zipcode) {\n          streets.add(m.group(STREET_GROUP))\n          numbers.add(m.group(NUMBER_GROUP))\n        }\n      }\n    }\n    s\"${zipcode}:${streets.toString}\/${numbers.toString}\"\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334890,"user_id":null,"body":"object Travel {\nprivate val pattern = \"\"\"(\\d+) (.*?) ([A-Z]{2} [0-9]{5})\"\"\".r\n\n  def travel(r: String, zipcode: String): String = {\n    r\n      .split(',')\n      .collect({ case pattern(number, street, zip) => (zip, street, number)})\n      .groupBy(_._1)\n      .get(zipcode)\n      .map(\n        a => {\n          val (_, streets, numbers) = a.unzip3\n          s\"$zipcode:${streets.mkString(\",\")}\/${numbers.mkString(\",\")}\"\n        }\n      ).getOrElse(s\"$zipcode:\/\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334891,"user_id":null,"body":"object Travel {\n\n  val AddressRegex = \"(\\\\d+)\\\\s+(.+?)\\\\s*([A-Z]+ \\\\d+)\".r\n  def travel(r: String, zipcode: String): String = {\n    val (houseNumbers, streets) = r.split(\",\").map {\n      case AddressRegex(houseNumber, street, zip) => (houseNumber, street, zip)\n      case invalid => throw new RuntimeException(s\"can't parse string $invalid\")\n    }.filter { case (_, _, zip) => zip == zipcode}\n      .foldLeft((Seq[String](),Seq[String]())) ((agg, tuple) => (agg._1 :+ tuple._1, agg._2 :+ tuple._2))\n    s\"$zipcode:${streets.mkString(\",\")}\/${houseNumbers.mkString(\",\")}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334892,"user_id":null,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    val x = r.split(\",\").map(x => (x.substring(0,x.indexOf(\" \")),x.substring(x.indexOf(\" \")+1,x.lastIndexOf(\" \")-3),x.substring(x.lastIndexOf(\" \")-2))).groupBy(_._3).get(zipcode).toList.flatten\n\n    zipcode + \":\" + x.map(_._2).mkString(\",\") + \"\/\" + x.map(_._1).mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334893,"user_id":null,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    if (zipcode.isEmpty) return \":\/\"\n    \n    val filtered = r.split(\",\").filter(_.takeRight(zipcode.length) == zipcode)\n    val streets = filtered.map(x => x.split(zipcode)(0).trim.split(\" \", 2))\n    val partitioned = streets.map(x => x.partition(x.indexOf(_) < 1))\n\n    zipcode + \":\" + partitioned.flatMap(_._2).mkString(\",\") + \"\/\" + partitioned.flatMap(_._1).mkString(\",\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334894,"user_id":null,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    if (zipcode != \"\") {\n      val validAddresses = r.split(\",\").toList.filter(x => x.takeRight(zipcode.length) == zipcode)\n      val pairs = validAddresses.map{ x => \n        val n = x.indexOf(\" \")\n        (x.take(n), x.drop(n+1).dropRight(zipcode.length+1))\n        }\n      s\"$zipcode:${pairs.map(x => x._2).mkString(\",\")}\/${pairs.map(x => x._1).mkString(\",\")}\"\n    }\n    else {\n      \":\/\"\n    }  \n  }  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334895,"user_id":null,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    \n    if (zipcode.equals(\"\")) return \":\/\"\n    \n    var result = s\"$zipcode:\"\n    \n    val matches = r.split(\",\")\n      .filter { it =>\n        val zipCodeInString = it.substring(it.length - zipcode.length, it.length)\n        zipCodeInString.equals(zipcode)\n      }\n\n    result += matches.map{ it =>\n      val arr = it.split(\" \")\n      arr.slice(1, arr.length - 2).mkString(\" \")\n    }.mkString(\",\")\n\n    result += \"\/\"\n\n    result += matches.map{ it =>\n      val arr = it.split(\" \")\n      arr(0)\n    }.mkString(\",\")\n\n\n    result\n  }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334896,"user_id":null,"body":"object Travel {\n\n  def travel(r: String, zipcode: String): String = {\n    zipcode match {\n        case y if y.isEmpty => \":\/\"\n        case x => x + \":\" + r.split(\",\").filter(s\"$x(?![0-9])\".r.findAllIn(_).nonEmpty)\n          .map(addr => addr.replace(s\" $x\", \"\")\n            .split(\" \", 2))\n          .map(a => (a(1), a(0)))\n          .unzip\n          .productIterator.toArray\n          .map {\n            case (x): Array[String] => x.mkString(\",\")\n          }.mkString(\"\/\")\n      }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56b5afb4ed1f6d5fb0000991":[{"id":334897,"user_id":null,"body":"object RevRot {\n\n  def revrot(strng: String, sz: Int): String = {\n    if (sz <= 0 || strng.isEmpty || sz > strng.length) return \"\"\n    strng.dropRight(strng.length % sz).grouped(sz).map { chunk =>\n      if (chunk.map(_.toInt).sum % 2 == 0) chunk.reverse else chunk.tail + chunk.head\n    }.mkString\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334898,"user_id":null,"body":"object RevRot {\n\n  def revrot(strng: String, sz: Int): String = {\n    if(sz==0) \"\"\n    else{\n      strng.sliding(sz,sz)\n           .filter(_.length==sz)\n           .map(x=>{ if(x.toString.map(_.asDigit).sum%2==0) x.toString.reverse else x.toString.substring(1)+x.toString.substring(0,1)})\n           .mkString\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334899,"user_id":null,"body":"object RevRot {\n\n  def doRevOrRot(str: String): String = str.map(ch => Math.pow(ch.asDigit, 3).toInt).sum match {\n    case res if res % 2 == 0 => str.reverse\n    case _ => str.tail + str.head\n  }\n\n  def revrot(str: String, sz: Int): String = str match {\n    case s if s.isEmpty || s.length < sz || sz <= 0 => \"\"\n    case _ => doRevOrRot(str.substring(0, sz)) + revrot(str.substring(sz, str.length), sz)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334900,"user_id":751,"body":"object RevRot {\n  def revrot(s: String, sz: Int): String = if(sz > 0) {\n    def cubeSumEven(i: String) = i.map(_.toInt).map(x => x*x*x).sum % 2 == 0\n    s.grouped(sz).collect { \n      case s if s.size==sz && cubeSumEven(s) => s.reverse\n      case s if s.size==sz                   => s.tail + s.head\n    }.mkString\n  } else \"\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334901,"user_id":null,"body":"object RevRot {\n\n  def revrot(string: String, sz: Int): String = {\n    if (sz < 1) {\n      return \"\"\n    }\n    val substrings = for (i <- sz to string.length by sz) yield string.slice(i - sz, i)\n    substrings.map( el => {\n        val sumSquares = el.map(_.asDigit).map(d => d * d).sum\n        (sumSquares % 2) match {\n          case 0 => el.reverse\n          case 1 => el.slice(1, el.length) + el.head\n        }\n    }).mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334902,"user_id":573,"body":"object RevRot {\n\n  def revrot(str: String, sz: Int): String = {\n    if (sz == 0 || sz > str.size)\n      \"\"\n    else\n      str\n        .grouped(sz)\n        .map {\n          case sub if sub.size != sz => \"\"\n          case sub if sub.map(c => math.pow(c.toInt, 3)).sum % 2 == 0 => sub.reverse\n          case sub => sub.drop(1) :+ sub.head\n        }\n        .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334903,"user_id":null,"body":"object RevRot {\n\n  def revrot(strng: String, sz: Int): String = {\n    def isDivisible(s: String): Boolean = s.map[Int](x => x.toInt).map(x => x * x * x).sum % 2 == 0\n\n    def rotate(s: String): String = s.drop(1) + s.head\n\n    if (sz > strng.length || sz <= 0 || strng.length == 0) \"\"\n    else strng.grouped(sz).filter(_.length == sz).map(x => if (isDivisible(x)) x.reverse else rotate(x)).mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334904,"user_id":null,"body":"object RevRot {\n\n  def revrot(strng: String, sz: Int): String = {\n    if (sz <= 0 || sz > strng.length) \"\" else {\n      strng.grouped(sz).filter(_.length == sz).map{ str =>\n        if (str.map(_ - 48).map(scala.math.pow(_, 3)).sum % 2 == 0) str.reverse\n        else str.tail + str.head\n      }.mkString(\"\")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334905,"user_id":null,"body":"object RevRot {\n\n  def revrot(strng: String, sz: Int): String = {\n    \/\/ your code\n    if (sz == 0) {\n      \"\"\n    } else {\n      strng\n        .grouped(sz)\n        .map { chunk =>\n          if (chunk.length < sz) {\n            \"\"\n          } else if (chunk.map(_.asDigit).sum % 2 == 0) {\n            chunk.reverse\n          } else {\n            chunk.tail + chunk.head.toString\n          }\n        }\n        .mkString\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334906,"user_id":null,"body":"object RevRot {\n\n  def revrot(strng: String, sz: Int): String = {\n    \/\/ your code\n     if (sz == 0) {\n    return \"\"\n  }\n  if (strng.isEmpty) {\n    return \"\"\n  }\n  var result = \"\"\n  val strlen = strng.length\n  val chunks = strlen \/ sz\n\n  var start = 0\n  var end = start + sz\n  for (n <- 0 until chunks) {\n    val subStr = strng.substring(start, end)\n    val reverseSubStr = subStr.reverse\n    val reverseSum = reverseSubStr.split(\"\").map(_.toInt).map(x => x * x * x).sum\n    if (reverseSum % 2 == 0) {\n      result += reverseSubStr\n    } else {\n      result += (subStr.tail + subStr.charAt(0))\n    }\n    start = end\n    end = start + sz\n  }\n  result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56baeae7022c16dd7400086e":[{"id":334907,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n\n  case class Person(name: String, phone: String, address: String)\n  \n  def phone(string: String, num: String): String = {\n    val database = string.split(\"\n\").array\n      .map(line => {\n        val name = parseName(line)\n        val phone = parsePhone(line)\n        val address = parseAddress(line, name, phone)\n        Person(name, phone, address)\n      })\n      .groupBy(person => person.phone)\n      .view\n      .mapValues(people => people)\n\n    database.get(num) match {\n      case Some(people) =>\n        if (people.length > 1) {\n          s\"Error => Too many people: ${num}\"\n        } else {\n          s\"Phone => ${people(0).phone}, Name => ${people(0).name}, Address => ${people(0).address}\"\n        }\n      case None => s\"Error => Not found: ${num}\"\n\n    }\n  }\n\n  def parseName(line: String): String = {\n    \"(<.*?>)\".r\n      .findFirstMatchIn(line)\n      .map(matched => matched.matched)\n      .map(name => name.substring(1, name.length - 1))\n      .getOrElse(\"\")\n  }\n\n  def parsePhone(line: String): String = {\n    \"(\\\\+\\\\d+-\\\\d+-\\\\d+-\\\\d+)\".r\n      .findFirstMatchIn(line)\n      .map(matched => matched.matched)\n      .map(phone => phone.replaceFirst(\"\\\\+\", \"\"))\n      .getOrElse(\"\")\n  }\n\n  def parseAddress(line: String, name: String, phone: String): String = {\n    val rawAddress = line\n      .replaceAll(name, \"\")\n      .replaceAll(phone, \"\")\n\n    addressCleanUp(rawAddress)\n  }\n\n\n  def addressCleanUp(line: String): String = {\n    line\n      .replaceFirst(\"\/\", \"\")\n      .replaceFirst(\":\", \"\")\n      .replaceAll(\"\\\\?\", \"\")\n      .replaceAll(\"!\", \"\")\n      .replaceAll(\";\", \"\")\n      .replaceAll(\"\\\\*\", \"\")\n      .replaceAll(\"_\", \" \")\n      .replaceAll(\"\\\\$\", \"\")\n      .replaceAll(\",\", \"\")\n      .replaceAll(\"<\", \"\")\n      .replaceAll(\">\", \"\")\n      .replaceAll(\"\\\\+\", \"\")\n      .trim()\n      .split(\" \")\n      .filterNot(x => x.isEmpty)\n      .mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334908,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n\n  def phone(strng: String, num: String): String = {\n    val line = (\".*\\\\+\" + num + \".*\").r.findAllIn(strng).map(x=>x.toString).toArray\n    if (line.isEmpty) return s\"Error => Not found: $num\"\n    if (line.length > 1) return s\"Error => Too many people: $num\"\n    val name = \"(?<=<).*(?=>)\".r.findAllIn(line(0)).map(x=>x.toString).toArray\n    val address = line(0).split(s\"$num|<.*>\").mkString.replaceAll(\"[^a-zA-Z0-9.\\\\-\\\\s]\",\" \")\n                          .trim().replaceAll(\" +\", \" \")\n    s\"Phone => $num, Name => ${name(0)}, Address => $address\"\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334909,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.collection.immutable\n\n\n\/\/ i know it's overengineered (no need to parse whole input),\n\/\/ but I did want to play a bit\nobject PhoneDir {\n\n  type PhoneBook = Map[String, List[Entry]]\n\n  case class Entry(name: String, tel: String, address: String){\n    override def toString = s\"Phone => ${tel}, Name => ${name}, Address => ${address}\"\n  }\n\n  \/\/ the most funny bit, hehe; it is so with clients and their req descriptions, tho\n  def cleanAddress(address: String) = address\n    .replaceAll(\"[*!,\/;:$?]\", \"\") \/\/ remove noise\n    .replaceAll(\"_\", \" \") \/\/ change _ to space\n    .replaceAll(\" +\", \" \") \/\/ shorten spaces\n    .trim \/\/ trim like a beard\n\n  def parseLine(input: String): Option[Entry] = {\n    val telReg = \"\"\"\\+\\d{1,2}-\\d{3}-\\d{3}-\\d{4}\"\"\".r\n    val nameReg = \"\"\"<([^>]+)>\"\"\".r\n\n    for {\n      tel  <- telReg.findFirstIn(input)\n      name <- nameReg.findFirstIn(input)\n      address <- Some(List(telReg, nameReg)\n                  .foldLeft(input)( (acc, reg) => reg.replaceFirstIn(acc, \"\")) )\n    } yield Entry(\"\"\"[<>]\"\"\".r.replaceAllIn(name, \"\"), tel.drop(1), cleanAddress(address))\n  }\n\n  \/\/ the option thing doesn't seem to be necessary here, yeat I want to be principled\n  def parse(input: String): Option[PhoneBook] = {\n\n    @tailrec\n    def go(input: List[String], acc: List[Entry] = List.empty): Option[List[Entry]] =\n      input match {\n        case Nil => Some(acc)\n        case hd::tl =>\n          parseLine(hd) match {\n            case None => None\n            case Some(entry) => go(tl, entry::acc)\n            }\n        }\n\n    \/\/ possibly suboptimal, the toList bit, the case doesn't justify streaming tho\n    \/\/ the input files are not that big; it's easier this way\n    go(input.split('\n').toList).map(_.groupBy(_.tel))\n  }\n\n  def phone(strng: String, num: String): String =\n    parse(strng).flatMap(_.get(num)).fold(\"Error => Not found: \"+num){\n      case entry::Nil => entry.toString\n      case _::_ => \"Error => Too many people: \"+num\n      case Nil => ??? \/\/ unexpected, totally\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334910,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n\n  def phone(strng: String, num: String): String = {\n    val lines = strng.split(\"\n\").filter(_.contains(\"+\" + num))\n    if (lines.length > 1) {\n      return \"Error => Too many people: \" + num\n    }\n    else if (lines.length < 1) {\n      return \"Error => Not found: \" + num\n    }\n    else {\n      val line = lines.head\n      val name = line.substring(line.indexOf(\"<\") + 1, line.indexOf(\">\"))\n      return s\"Phone => ${num}, Name => ${name}, \" + \n        s\"Address => ${line.replace(s\"<${name}>\", \"\").replace(\"+\" + num, \"\").replaceAll(\"_\", \" \").replaceAll(\"(?<=\\\\w),\", \"\").replaceAll(\"(?<=\\\\w)[;](?=\\\\s)\", \"\").replaceAll(\"^\/\", \"\").replaceAll(\"[;?!]+$\", \"\").replaceAll(\"^[^\\\\w ]\\\\s\", \" \").replaceAll(\" [^\\\\w ]+ \", \" \").replaceAll(\"  \", \" \").trim()}\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334911,"user_id":325,"body":"import scala.util.matching.Regex.Match\nimport scala.collection.mutable.{ HashMap, Map }\n\nobject PhoneDir {\n  class Entry\n  case class ValidEntry(val phone: String, val name: String, val address: String) extends Entry\n  case class TooManyPeople(val phone: String) extends Entry\n  case class NotFound(val phone: String) extends Entry\n  \n  private val rPhone = raw\"\\d{1,2}-\\d{3}-\\d{3}-\\d{4}\".r\n  private val rName = \"<([^>]+)>\".r\n  private val rClean = raw\"([^\\w\\d\\s\\-.])\".r\n  private val rClean2 = raw\"\\s+|_\".r\n  \n  def phone(strng: String, num: String): String = {\n    val lines = strng.split(\"\\\n\")\n    val map = toMap(lines)\n    map.get(num) match {\n      case Some(ValidEntry(_, name, address)) => \n        s\"Phone => $num, Name => $name, Address => $address\"\n      case Some(TooManyPeople(_)) =>\n        s\"Error => Too many people: $num\"\n      case _ =>\n        s\"Error => Not found: $num\"\n    }\n  }\n  \n  def toMap(lines: Array[String]): Map[String, Entry] = {\n    val map = new HashMap[String, Entry]\n    lines.map(line => {\n      val phone = rPhone.findFirstIn(line).get\n      val name = rName.findFirstMatchIn(line).get.group(1)\n      val address = \n        rClean2.replaceAllIn(\n          rClean.replaceAllIn(\n            rName.replaceAllIn(\n              rPhone.replaceAllIn(line, \"\"), \"\"), \"\"), \" \").trim\n      new ValidEntry(phone, name, address)\n    }).foreach(entry => {\n      map.get(entry.phone) match {\n        case Some(ValidEntry(phone, _, _)) => \n          map.put(phone, new TooManyPeople(phone))\n        case None => \n          map.put(entry.phone, entry)\n        case _ =>\n      }\n    })\n    map\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334912,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n    case class Record(name: String, number: String, address: String)\n\n    def parseDirectoryLine(in: String): Option[Record] = {\n        val r = \"\"\"(?=.*<(.*)>)(?=.*\\+(\\d{1,2}-\\d{3}-\\d{3}-\\d{4})).*\"\"\".r\n        in match {\n            case r(name, phone) => \n                val address = in.replace(s\"<$name>\", s\"\")\n                    .replace(s\"+$phone\", \"\")\n                    .replace(\"_\", \" \")\n                    .replaceAll(\"\"\"[^A-Za-z0-9\\.\\- ]\"\"\", \"\")\n                    .replaceAll(\"\"\"\\s+\"\"\", \" \")\n                    .trim\n                Some(Record(name, phone, address))\n            case _ => None\n        }\n    }\n\n    def phone(strng: String, num: String): String = {\n        val matches = strng.split(\"\n\")\n            .map(parseDirectoryLine)\n            .filter(_.isDefined)\n            .map(_.get)\n            .filter(_.number == num)\n\n        if (matches.length == 0) s\"Error => Not found: $num\"\n        else if (matches.length > 1) s\"Error => Too many people: $num\"\n        else s\"Phone => ${matches(0).number}, Name => ${matches(0).name}, Address => ${matches(0).address}\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334913,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n\n  def phone(strng: String, num: String): String = {\n    val namePattern = \"<[\\\\s\\\\S]+>\".r\n    val recFind = strng.split('\n').filter(_.contains(\"+\" + num))\n\n    if (recFind.length == 0) s\"Error => Not found: $num\"\n    else if (recFind.length != 1 ) s\"Error => Too many people: $num\"\n    else {\n      val record = recFind.head\n      val name = namePattern.findFirstMatchIn(record).mkString\n      val nameClean = name.tail.init\n      val address = record.replace(num,\"\").replace(name,\"\").replaceAll(\"[_]\",\" \").replaceAll(\"[^\\\\sA-Za-z0-9.-]\",\"\").replaceAll(\"  \",\" \").trim\n\n      s\"Phone => $num, Name => $nameClean, Address => $address\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334914,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n  case class Entry(phone: String, name: String, address: String) {\n    override def toString(): String =\n      s\"Phone => $phone, Name => $name, Address => $address\"  \n  }\n  \n  object Entry {\n    def apply(line: String): Entry = {\n      new Entry(getPhone(line), getName(line), getAddress(line))\n    }\n    \n    private def getName(line: String): String = {\n      val pattern = \".*<(.*)>.*\".r\n      val pattern(name) = line\n      name\n    }\n    private def getPhone(line: String): String = {\n      val pattern = \"(.*\\\\s*\\\\+)(\\\\d+-\\\\d+-\\\\d+-\\\\d+)(\\\\s*.*)\".r\n      val pattern(before, phone, after) = line\n      phone\n    }\n    private def getAddress(line: String): String = {\n      val namePattern = \".*(\\\\s*<.*>\\\\s*).*\".r\n      val namePattern(name) = line\n      val phonePattern = \"(.*\\\\s*\\\\+)(\\\\d+-\\\\d+-\\\\d+-\\\\d+)(\\\\s*.*)\".r\n      val phonePattern(before, phone, after) = line\n      val addressOnlyLine = line.replace(name, \"\").replace(phone, \"\").replaceAll(\"[^A-Za-z0-9\\\\s\\\\-\\\\.]\", \" \")\n        .replaceAll(\"  \", \" \").replaceAll(\"  \", \" \").replaceAll(\"  \", \" \")\n      addressOnlyLine.trim\n    }\n  }\n\n  def phone(strng: String, num: String): String = {\n    val lines = strng.split(\"\n\").toList\n    val phones = lines.map(Entry(_)).groupBy(_.phone)\n    val phoneNumber = phones.get(num)\n    phoneNumber match {\n      case Some(List(entry)) => entry.toString\n      case None => s\"Error => Not found: $num\"\n      case _ => s\"Error => Too many people: $num\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334915,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n\n  def phone(strng: String, num: String): String = {\n    val entries = strng.split('\n').filter(_.contains(\"+\" ++ num)).toList\n    entries.length match {\n      case 0 => s\"Error => Not found: $num\"\n      case 1 => {\n        val entry = entries(0)\n        val left = entry.indexOf('<')\n        val right = entry.indexOf('>')\n        val name = entry.drop(left + 1).dropRight(entry.length - right)\n        val address = entry.take(left).concat(entry.takeRight(entry.length - right - 1))\n        .replaceAll(\"[_,\/;!]\", \" \").split(\" \").filter(!_.contains(\"+\")).filter(_ != \"\").mkString(\" \").trim\n        s\"Phone => $num, Name => $name, Address => $address\"\n      }\n      case other => s\"Error => Too many people: $num\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334916,"user_id":null,"body":"import java.util.regex.Matcher\nimport java.util.regex.Pattern\n\nobject PhoneDir {\n\n  def phone(mobileData : String, telephoneNumber : String) : String = {\n\n    val cleanedData = mobileData.split(\"\n\")\n      .map(f => f.replaceAll(\"[^-'.<>+0-9a-zA-Z]\",\" \"))\n      .map(f => f.replaceAll(\"\\\\s+\", \" \"))\n      .map(f => if (f.head == ' ') f.substring(1) else f)\n\n    val lineFound = cleanedData.filter(f => f.contains(\"+\"+telephoneNumber))\n    if (lineFound.length == 0) {\n      return \"Error => Not found: \"+telephoneNumber\n    }\n    else if (lineFound.length > 1) {\n      return \"Error => Too many people: \"+telephoneNumber\n    }\n    val name = lineFound(0).substring(lineFound(0).indexOf(\"<\")+1, lineFound(0).indexOf(\">\"))\n    val address = lineFound(0).split(\" \").filter(f => !f.contains(\"+\")).filter(f => !f.contains(\"<\") && !f.contains(\">\")).mkString(\" \")\n    \"Phone => \"+telephoneNumber+\", Name => \"+name+\", Address => \"+address+\"\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56bc28ad5bdaeb48760009b0":[{"id":334917,"user_id":527,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = {\n    s.tail.init\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334918,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = {\n    s.slice(1, s.size-1)\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334919,"user_id":527,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = {\n    s.substring(1, s.length - 1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334920,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(word: String): String = {\n    word.drop(1).dropRight(1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334921,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = return s.substring(1, s.length - 1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334922,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = s.substring(1,s.size-1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334923,"user_id":527,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = {\n    s.slice(1, s.length - 1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334924,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = {\n    s.substring(1).dropRight(1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334925,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char(s: String): String = {\n    s.dropRight(1).drop(1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334926,"user_id":null,"body":"object RemoveFirstAndLastCharacters {\n  def remove_char : String => String = ((_:String).sliding(2).map(_.head).mkString) andThen ((_:String).drop(1))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56bdd0aec5dc03d7780010a5":[{"id":334927,"user_id":573,"body":"object Kata {\n\n  def nextHigher(n: Int): Int = {\n    val ones = n.toBinaryString.count(_ == '1')\n    Iterator.from(n + 1).find(_.toBinaryString.count(_ == '1') == ones).get\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334928,"user_id":527,"body":"object Kata {\n  def nextHigher(n: Int): Int = {\n    val t = n | (n - 1)\n    t + 1 | Integer.lowestOneBit(~t) - 1 >> Integer.numberOfTrailingZeros(n) + 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334929,"user_id":53,"body":"object Kata {\n  def nextHigher(n: Int): Int = {\n    var r = n & -n;\n    var p = n + r;\n    var q = (n ^ p) \/ (4 * r);\n    return p | q;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334930,"user_id":null,"body":"object Kata {\n  def nextHigher(n: Int): Int = {\n    val ones = countOnes(n)\n    Iterator.from(n + 1)\n      .find(m => countOnes(m) == ones)\n      .get\n  }\n\n  def countOnes(n: Int) = n.toBinaryString.count(_ == '1')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334931,"user_id":null,"body":"object Kata {\n  def sum(n: String, acc: Int = 0): Int = {\n    if (n.length == 0) return acc\n    return sum(n.tail, acc + n.head.asDigit)\n  }\n\n  def nextHigher(n: Int): Int = {\n    def count(n: Int, acc: Int): Int = {    \n      val str = n.toBinaryString\n      if (sum(str) == acc) return n\n      return count(n + 1, acc)\n    }\n    \n    return count(n + 1, sum(n.toBinaryString))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334932,"user_id":645,"body":"object Kata {\n  def nextHigher(n: Int): Int = {\n    val o = n & -n\n    n + o | ((n ^ n + o) \/ o >> 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334933,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n  def nextHigher(n: Int): Int = {\n    val nBitCounter = Integer.bitCount(n)\n\n    @tailrec def loop(k: Int): Int = \n    if(Integer.bitCount(k) == nBitCounter) k \n    else loop(k + 1)\n\n    loop(n + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334934,"user_id":null,"body":"object Kata {\n  def oneBits(n: Int): Int = Integer.toString(n, 2).count(_=='1')\n  \n  def nextHigher(n: Int): Int = {\n    val ones = oneBits(n)\n    var next = n + 1\n    while (oneBits(next) != ones) next += 1\n    next\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334935,"user_id":null,"body":"object Kata {\n  def nextHigher(n: Int): Int = {\n    val binary = \"0\".concat(n.toBinaryString).reverse\n    val zeros = binary.takeWhile(_ == '0')\n    val ones = binary.drop(zeros.length).takeWhile(_ == '1')\n    val answer = \"1\" * (ones.length - 1) ++ \"0\" * (zeros.length + 1) ++ \"1\" ++ binary.drop(ones.length + zeros.length + 1)\n    Integer.parseInt(answer.reverse, 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334936,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n  def nextHigher(n: Int): Int = {\n    val nBitCount = Integer.bitCount(n)\n\n    @tailrec def loop(x: Int): Int = if(Integer.bitCount(x) == nBitCount) x else loop(x + 1)\n\n    loop(n + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56c04261c3fcf33f2d000534":[{"id":334937,"user_id":573,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double =\n    (for {\n      k <- 1 to maxk\n      n <- 1 to maxn\n    } yield \n      1 \/ (k * math.pow(n+1, 2*k))\n    ).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334938,"user_id":null,"body":"object Magnets {\n\ndef doubles(maxK: Int, maxN: Int): Double = {\n\n  def element(n: Int, k: Int): Double = {\n    1.0 \/ (k * math.pow(n + 1, 2*k))\n  }\n\n  def innerLoop(k: Int): Double = {\n    var innerLoopSum = 0.0\n    for (n <- 1 to maxN) {\n      innerLoopSum += element(n, k)\n    }\n    innerLoopSum\n  }\n\n  var outerLoopSum = 0.0\n  for (k <- 1 to maxK) {\n    outerLoopSum += innerLoop(k)\n  }\n\n  outerLoopSum\n}\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334939,"user_id":null,"body":"import scala.math.pow\n\nobject Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {\n    var v: Double = 0.0\n    \n    for (k <- 1 to maxk){\n      for (n <- 1 to maxn){\n        v += (1 \/ (k * scala.math.pow((n + 1), 2 * k)))\n      } \n    }\n\n    return v\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334940,"user_id":220,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {\n    \n    def term(k:Int, n:Int) = 1.0\/(k*scala.math.pow(n+1,k*2))    \n    def sumRow(k: Int): Double = (1 to maxn map {term(k,_)} takeWhile {_>1e-12}).sum\n    \n    (1 to maxk map sumRow).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334941,"user_id":null,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {\n    (for {\n      k <- 1 to maxk\n      n <- 1 to maxn\n    } yield 1 \/ (k * Math.pow(n + 1, 2 * k))).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334942,"user_id":null,"body":"object Magnets {\n  import scala.math.pow\n\n  def doubles(maxk: Int, maxn: Int): Double =\n    (for (k <- 1 to maxk; n <- 1 to maxn) yield v(k, n)).sum\n\n  def v(k: Int, n: Int): Double = 1 \/ (k * pow((n + 1), 2 * k))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334943,"user_id":null,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {    \n    def sumAux(squares: Seq[Double], k: Int = 1, acc: Double = 0.0): Double = {\n      if (k > maxk) acc\n      else {\n        val newSquares = (1 to maxn).map(x => squares(x - 1) * 1.0 \/ ((1 + x) * (1 + x)))\n        val newAcc = acc + newSquares.sum * (1.0 \/ k)\n        sumAux(newSquares, k + 1, newAcc)\n      }\n    }\n    \n    sumAux((1 to maxn).map(x => 1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334944,"user_id":null,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {\n    (for {\n      k <- 1 to maxk\n      n <- 1 to maxn\n    } yield 1.0 \/ (k * math.pow(n + 1, 2 *k)))\n      .sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334945,"user_id":null,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {\n    val res = for {\n      i <- 1 to maxk\n      j <- 1 to maxn\n    } yield 1 \/ (i * math.pow(j + 1, 2 * i))\n    res.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334946,"user_id":50,"body":"object Magnets {\n\n  def doubles(maxk: Int, maxn: Int): Double = {\n    var o=0.0\n    var k=1\n    var n=1\n    while (k<=maxk){\n      while (n<=maxn){\n        o=o+1.0\/(k*Math.pow((n+1).toDouble,(2*k).toDouble))\n        n=n+1\n      }\n      k=k+1\n      n=1\n    }\n    return o\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56c5847f27be2c3db20009c3":[{"id":334947,"user_id":573,"body":"object Kata {\n\n  def subtractSum(n: Int) = \"apple\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334948,"user_id":null,"body":"object Kata {\n  def subtractSum(n: Int): String = \"apple\" \/\/ fruit name like \"apple\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334949,"user_id":null,"body":"object Kata {\n  \n  def subtractSum(n: Int): String = {\n  \/\/ break n into individual digits\n    val sum = n.toString().toCharArray().map(n=> n.toString.toInt).reduce((total, n) =>  n+ total)\n\/\/     n.toString().toCharArray().reduce(total, n =>  n.toString.toInt + total)\n  val newN = n - sum\n  println(sum)\n  newN match {\n  case 1|3|24|26|47|49|68|70|91|93 => return \"kiwi\"\n  case 2|21|23|42|44|46|65|67|69|88 => return \"pear\"\n  case 96|94|92|73|71|50|48|4|6|25|29 => return \"banana\"\n  case 5|7|28|30|32|51|53|74|76|95|97 => return \"melon\"\n  case 9|18|27|36|45|54|63|72|81|90|99 => return \"apple\"\n  case 8|10|12|31|33|52|56|75|77|79|98|100 => return \"pineapple\"\n\n  case _ => return subtractSum(newN)\n  }\n  \/\/add together\n   \/\/ \n  } \/\/ fruit name like \"apple\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334950,"user_id":null,"body":"object Kata {\n  val subtractSum = (_: Int) => \"apple\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334951,"user_id":291,"body":"object Kata {\n  def subtractSum(n: Int): String = {\n    val m = n - n.toString.map{ _.asDigit }.sum\n    m match {\n      case 1 => \"kiwi\"\n      case 2 => \"pear\"\n      case 3 => \"kiwi\"\n      case 4 => \"banana\"\n      case 5 => \"melon\"\n      case 6 => \"banana\"\n      case 7 => \"melon\"\n      case 8 => \"pineapple\"\n      case 9 => \"apple\"\n      case 10 => \"pineapple\"\n      case 11 => \"cucumber\"\n      case 12 => \"pineapple\"\n      case 13 => \"cucumber\"\n      case 14 => \"orange\"\n      case 15 => \"grape\"\n      case 16 => \"orange\"\n      case 17 => \"grape\"\n      case 18 => \"apple\"\n      case 19 => \"grape\"\n      case 20 => \"cherry\"\n      case 21 => \"pear\"\n      case 22 => \"cherry\"\n      case 23 => \"pear\"\n      case 24 => \"kiwi\"\n      case 25 => \"banana\"\n      case 26 => \"kiwi\"\n      case 27 => \"apple\"\n      case 28 => \"melon\"\n      case 29 => \"banana\"\n      case 30 => \"melon\"\n      case 31 => \"pineapple\"\n      case 32 => \"melon\"\n      case 33 => \"pineapple\"\n      case 34 => \"cucumber\"\n      case 35 => \"orange\"\n      case 36 => \"apple\"\n      case 37 => \"orange\"\n      case 38 => \"grape\"\n      case 39 => \"orange\"\n      case 40 => \"grape\"\n      case 41 => \"cherry\"\n      case 42 => \"pear\"\n      case 43 => \"cherry\"\n      case 44 => \"pear\"\n      case 45 => \"apple\"\n      case 46 => \"pear\"\n      case 47 => \"kiwi\"\n      case 48 => \"banana\"\n      case 49 => \"kiwi\"\n      case 50 => \"banana\"\n      case 51 => \"melon\"\n      case 52 => \"pineapple\"\n      case 53 => \"melon\"\n      case 54 => \"apple\"\n      case 55 => \"cucumber\"\n      case 56 => \"pineapple\"\n      case 57 => \"cucumber\"\n      case 58 => \"orange\"\n      case 59 => \"cucumber\"\n      case 60 => \"orange\"\n      case 61 => \"grape\"\n      case 62 => \"cherry\"\n      case 63 => \"apple\"\n      case 64 => \"cherry\"\n      case 65 => \"pear\"\n      case 66 => \"cherry\"\n      case 67 => \"pear\"\n      case 68 => \"kiwi\"\n      case 69 => \"pear\"\n      case 70 => \"kiwi\"\n      case 71 => \"banana\"\n      case 72 => \"apple\"\n      case 73 => \"banana\"\n      case 74 => \"melon\"\n      case 75 => \"pineapple\"\n      case 76 => \"melon\"\n      case 77 => \"pineapple\"\n      case 78 => \"cucumber\"\n      case 79 => \"pineapple\"\n      case 80 => \"cucumber\"\n      case 81 => \"apple\"\n      case 82 => \"grape\"\n      case 83 => \"orange\"\n      case 84 => \"grape\"\n      case 85 => \"cherry\"\n      case 86 => \"grape\"\n      case 87 => \"cherry\"\n      case 88 => \"pear\"\n      case 89 => \"cherry\"\n      case 90 => \"apple\"\n      case 91 => \"kiwi\"\n      case 92 => \"banana\"\n      case 93 => \"kiwi\"\n      case 94 => \"banana\"\n      case 95 => \"melon\"\n      case 96 => \"banana\"\n      case 97 => \"melon\"\n      case 98 => \"pineapple\"\n      case 99 => \"apple\"\n      case 100 => \"pineapple\"\n      case _ => subtractSum(m)\n    }    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334952,"user_id":null,"body":"object Kata {\n  \/\/ No you can't just get away without solving the problem\n  \/\/ AHAH copy-paste goes brrrr\n  val data = Map(1->\"kiwi\",2->\"pear\",3->\"kiwi\",4->\"banana\",5->\"melon\",6->\"banana\",7->\"melon\",8->\"pineapple\",9->\"apple\",10->\"pineapple\",11->\"cucumber\",12->\"pineapple\",13->\"cucumber\",14->\"orange\",15->\"grape\",16->\"orange\",17->\"grape\",18->\"apple\",19->\"grape\",20->\"cherry\",21->\"pear\",22->\"cherry\",23->\"pear\",24->\"kiwi\",25->\"banana\",26->\"kiwi\",27->\"apple\",28->\"melon\",29->\"banana\",30->\"melon\",31->\"pineapple\",32->\"melon\",33->\"pineapple\",34->\"cucumber\",35->\"orange\",36->\"apple\",37->\"orange\",38->\"grape\",39->\"orange\",40->\"grape\",41->\"cherry\",42->\"pear\",43->\"cherry\",44->\"pear\",45->\"apple\",46->\"pear\",47->\"kiwi\",48->\"banana\",49->\"kiwi\",50->\"banana\",51->\"melon\",52->\"pineapple\",53->\"melon\",54->\"apple\",55->\"cucumber\",56->\"pineapple\",57->\"cucumber\",58->\"orange\",59->\"cucumber\",60->\"orange\",61->\"grape\",62->\"cherry\",63->\"apple\",64->\"cherry\",65->\"pear\",66->\"cherry\",67->\"pear\",68->\"kiwi\",69->\"pear\",70->\"kiwi\",71->\"banana\",72->\"apple\",73->\"banana\",74->\"melon\",75->\"pineapple\",76->\"melon\",77->\"pineapple\",78->\"cucumber\",79->\"pineapple\",80->\"cucumber\",81->\"apple\",82->\"grape\",83->\"orange\",84->\"grape\",85->\"cherry\",86->\"grape\",87->\"cherry\",88->\"pear\",89->\"cherry\",90->\"apple\",91->\"kiwi\",92->\"banana\",93->\"kiwi\",94->\"banana\",95->\"melon\",96->\"banana\",97->\"melon\",98->\"pineapple\",99->\"apple\",100->\"pineapple\")\n\n  def digitSum(x : Int): Int = x.toString.map{ _.asDigit }.foldLeft(0){ _+_ }\n\n  def subtractSum(n: Int): String = data.getOrElse(n - digitSum(n),subtractSum(n - digitSum(n)))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334953,"user_id":null,"body":"object Kata {\n\/\/   val fruits = Map(\n\/\/     1->\"kiwi\"\n\/\/     2->\"pear\"\n\/\/     3->\"kiwi\"\n\/\/     4->\"banana\"\n\/\/     5-melon\n\/\/     6-banana\n\/\/     7-melon\n\/\/     8-pineapple\n\/\/     9-apple\n\/\/     10-pineapple\n\/\/     11-cucumber\n\/\/     12-pineapple\n\/\/     13-cucumber\n\/\/     14-orange\n\/\/     15-grape\n\/\/     16-orange\n\/\/     17-grape\n\/\/     18-apple\n\/\/     19-grape\n\/\/     20-cherry\n\/\/     21-pear\n\/\/     22-cherry\n\/\/     23-pear\n\/\/     24-kiwi\n\/\/     25-banana\n\/\/     26-kiwi\n\/\/     27-apple\n\/\/     28-melon\n\/\/     29-banana\n\/\/     30-melon\n\/\/     31-pineapple\n\/\/     32-melon\n\/\/     33-pineapple\n\/\/     34-cucumber\n\/\/     35-orange\n\/\/     36-apple\n\/\/     37-orange\n\/\/     38-grape\n\/\/     39-orange\n\/\/     40-grape\n\/\/     41-cherry\n\/\/     42-pear\n\/\/     43-cherry\n\/\/     44-pear\n\/\/     45-apple\n\/\/     46-pear\n\/\/     47-kiwi\n\/\/     48-banana\n\/\/     49-kiwi\n\/\/     50-banana\n\/\/     51-melon\n\/\/     52-pineapple\n\/\/     53-melon\n\/\/     54-apple\n\/\/     55-cucumber\n\/\/     56-pineapple\n\/\/     57-cucumber\n\/\/     58-orange\n\/\/     59-cucumber\n\/\/     60-orange\n\/\/     61-grape\n\/\/     62-cherry\n\/\/     63-apple\n\/\/     64-cherry\n\/\/     65-pear\n\/\/     66-cherry\n\/\/     67-pear\n\/\/     68-kiwi\n\/\/     69-pear\n\/\/     70-kiwi\n\/\/     71-banana\n\/\/     72-apple\n\/\/     73-banana\n\/\/     74-melon\n\/\/     75-pineapple\n\/\/     76-melon\n\/\/     77-pineapple\n\/\/     78-cucumber\n\/\/     79-pineapple\n\/\/     80-cucumber\n\/\/     81-apple\n\/\/     82-grape\n\/\/     83-orange\n\/\/     84-grape\n\/\/     85->cherry\n\/\/     86->grape\n\/\/     87->cherry\n\/\/     88->pear\n\/\/     89->cherry\n\/\/     90->apple\n\/\/     91->kiwi\n\/\/     92->banana\n\/\/     93->kiwi\n\/\/     94->banana\n\/\/     95->melon\n\/\/     96->banana\n\/\/     97->melon\n\/\/     98->pineapple\n\/\/     99->apple\n\/\/     100->pineapple\n\/\/     )\n  \n  \n  def subtractSum(n: Int): String = {\n\/\/     def sumDigits(n: Int, acc: Int = 0): Int = {\n\/\/       val nstr = n.toString\n\/\/       if (n.toString.length == 1) return acc + n\n\/\/       return sumDigits(n.toString.tail.toInt, acc + n.toString.head.asDigit)\n\/\/     }\n    \n\/\/     def helper(n: Int): Int = {\n\/\/       val sum = sumDigits(n)\n\/\/       if (n - sum < 100) return n - sum\n\/\/       return helper(n - sum)\n\/\/     }\n    \n\/\/     val ind = helper(n)\n\/\/     return fruits(ind - 1)\n  return \"apple\"\n  } \/\/ fruit name like \"apple\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334954,"user_id":527,"body":"object Kata {\n  val subtractSum = Function.const(\"apple\") _\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334955,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject FruitStorage {\n  private val store = Map(\n     1 -> \"kiwi\",\n     2 -> \"pear\",\n     3 -> \"kiwi\",\n     4 -> \"banana\",\n     5 -> \"melon\",\n     6 -> \"banana\",\n     7 -> \"melon\",\n     8 -> \"pineapple\",\n     9 -> \"apple\",\n    10 -> \"pineapple\",\n    11 -> \"cucumber\",\n    12 -> \"pineapple\",\n    13 -> \"cucumber\",\n    14 -> \"orange\",\n    15 -> \"grape\",\n    16 -> \"orange\",\n    17 -> \"grape\",\n    18 -> \"apple\",\n    19 -> \"grape\",\n    20 -> \"cherry\",\n    21 -> \"pear\",\n    22 -> \"cherry\",\n    23 -> \"pear\",\n    24 -> \"kiwi\",\n    25 -> \"banana\",\n    26 -> \"kiwi\",\n    27 -> \"apple\",\n    28 -> \"melon\",\n    29 -> \"banana\",\n    30 -> \"melon\",\n    31 -> \"pineapple\",\n    32 -> \"melon\",\n    33 -> \"pineapple\",\n    34 -> \"cucumber\",\n    35 -> \"orange\",\n    36 -> \"apple\",\n    37 -> \"orange\",\n    38 -> \"grape\",\n    39 -> \"orange\",\n    40 -> \"grape\",\n    41 -> \"cherry\",\n    42 -> \"pear\",\n    43 -> \"cherry\",\n    44 -> \"pear\",\n    45 -> \"apple\",\n    46 -> \"pear\",\n    47 -> \"kiwi\",\n    48 -> \"banana\",\n    49 -> \"kiwi\",\n    50 -> \"banana\",\n    51 -> \"melon\",\n    52 -> \"pineapple\",\n    53 -> \"melon\",\n    54 -> \"apple\",\n    55 -> \"cucumber\",\n    56 -> \"pineapple\",\n    57 -> \"cucumber\",\n    58 -> \"orange\",\n    59 -> \"cucumber\",\n    60 -> \"orange\",\n    61 -> \"grape\",\n    62 -> \"cherry\",\n    63 -> \"apple\",\n    64 -> \"cherry\",\n    65 -> \"pear\",\n    66 -> \"cherry\",\n    67 -> \"pear\",\n    68 -> \"kiwi\",\n    69 -> \"pear\",\n    70 -> \"kiwi\",\n    71 -> \"banana\",\n    72 -> \"apple\",\n    73 -> \"banana\",\n    74 -> \"melon\",\n    75 -> \"pineapple\",\n    76 -> \"melon\",\n    77 -> \"pineapple\",\n    78 -> \"cucumber\",\n    79 -> \"pineapple\",\n    80 -> \"cucumber\",\n    81 -> \"apple\",\n    82 -> \"grape\",\n    83 -> \"orange\",\n    84 -> \"grape\",\n    85 -> \"cherry\",\n    86 -> \"grape\",\n    87 -> \"cherry\",\n    88 -> \"pear\",\n    89 -> \"cherry\",\n    90 -> \"apple\",\n    91 -> \"kiwi\",\n    92 -> \"banana\",\n    93 -> \"kiwi\",\n    94 -> \"banana\",\n    95 -> \"melon\",\n    96 -> \"banana\",\n    97 -> \"melon\",\n    98 -> \"pineapple\",\n    99 -> \"apple\",\n   100 -> \"pineapple\"\n  )\n\n  def get(key: Int): Option[String] = store.get(key)\n}\n\n\nobject Kata {\n  @tailrec\n  def subtractSum(n: Int): String = {\n    val newN = n - n.toString.foldLeft(0)(_+_.asDigit)\n    if (FruitStorage.get(newN).nonEmpty) FruitStorage.get(newN).get else subtractSum(newN)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334956,"user_id":null,"body":"\/\/https:\/\/www.codewars.com\/kata\/56c5847f27be2c3db20009c3\/train\/scala\nobject Kata {\n    def subtractSum(n: Int): String = {\n      return \"apple\"\n    }\n  }\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56cac350145912e68b0006f0":[{"id":334957,"user_id":null,"body":"object Updown {\n  def findBadIndex(s: Array[String]): Option[Int] = {\n    s.sliding(2).zipWithIndex.find {\n      case (Array(a, b), index) =>\n        if (index % 2 == 0) a.length > b.length else b.length > a.length\n    }\n    .map(_._2)\n  }\n\n  def swap[T](array: Array[T], i: Int, j: Int): Unit = {\n    val tmp = array(i)\n    array(i) = array(j)\n    array(j) = tmp\n  }\n\n  def alternateCase(words: Array[String]): Array[String] = {\n    words.zipWithIndex.map {\n      case (word, index) =>\n        if (index % 2 == 0) word.toLowerCase\n        else word.toUpperCase\n    }\n  }\n\n  def arrange(s: String): String = {\n    val words = s.split(' ')\n    if (words.length > 1) {\n      var badIndex = findBadIndex(words)\n      while (badIndex.isDefined) {\n        val index = badIndex.get\n        swap(words, index, index + 1)\n        badIndex = findBadIndex(words)\n      }\n      alternateCase(words).mkString(\" \")\n    } else {\n      s\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334958,"user_id":null,"body":"object Updown {\n\n  def arrange(s: String): String = {\n    val substrings = s.split(\" \").toList\n    \n    def swap(list: List[String], acc: Int = 1): List[String] = {\n      if (acc == list.length) {\n        list\n      }\n      else {\n        val left = list.take(acc - 1)\n        val right = list.drop(acc + 1)\n        if (acc % 2 == 0 && list(acc - 1).length >= list(acc).length) swap(list, acc + 1)\n        else if (acc % 2 == 1 && list(acc - 1).length <= list(acc).length) swap(list, acc + 1)\n        else swap(left ++ List(list(acc), list(acc - 1)) ++ right, acc + 1)\n      }\n    }\n    \n    def upDown(list: List[String]): List[String] = {\n      (1 to list.length).map { x =>\n        x % 2 match {\n          case 0 => list(x - 1).toUpperCase\n          case 1 => list(x - 1).toLowerCase\n        }\n      }.toList\n    }\n    \n    upDown(swap(substrings)).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334959,"user_id":null,"body":"object Updown {\n\n  def arrange(s: String): String = {\n    def sortFuction() = {\n      var flag = true\n      (string1: String, string2: String) => {\n        if (flag) {\n          flag = !flag\n          string1.length <= string2.length\n        }\n        else {\n          flag = !flag\n          string1.length >= string2.length\n        }\n      }\n    }\n    val sf = sortFuction()\n    s.split(\" \").drop(1).foldLeft(s.split(\" \").take(1)) { (a, b: String) => {\n      if (sf(a.lastOption.getOrElse(\"\"), b)) {\n        a :+ b\n      } else {\n        a.dropRight(1) :+ b :+ a.last\n      }\n    }\n    }.zipWithIndex.map {\n      case (s, i) if (i % 2 == 0) => s.toLowerCase()\n      case (s, _) => s.toUpperCase()\n    }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334960,"user_id":null,"body":"object Updown {\n\n  def arrange(s: String): String = {\n    val array = s.split(\" \")\n    (0 until array.length - 1).foreach { i =>\n      if (i % 2 == 0 && array(i).length > array(i + 1).length || i % 2 == 1 && array(i).length < array(i + 1).length) {\n        val temp = array(i)\n        array(i) = array(i + 1)\n        array(i + 1) = temp\n      }\n    }\n    array.zipWithIndex.map { case (str, i) => if (i % 2 == 1) str.toUpperCase else str.toLowerCase }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334961,"user_id":null,"body":"object Updown {\n\n  def arrange(s: String): String = {\n    var l = s.split(\" +\")\n    for(i <- 0 until l.length - 1 ){\n      if (i % 2 == 1) {\n        if (l(i + 1).length > l(i).length) {\n          l = l.updated(i + 1,l(i)).updated(i,l(i+1))\n        } \n      } else {\n        if (l(i + 1).length < l(i).length) {\n          l = l.updated(i + 1,l(i)).updated(i,l(i+1))\n        }\n      }\n    }\n    return l.zipWithIndex.collect {case (e,i) if (i % 2) == 1 => e.toUpperCase\n                                   case (e,i) if (i % 2) == 0 => e.toLowerCase}\n            .mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334962,"user_id":null,"body":"object Updown {\n  import scala.collection.mutable\n  \n  def switch[A](buf: mutable.Buffer[A], i: Int): buf.type = \n    buf.patchInPlace(i, Seq(buf(i + 1), buf(i)), 2)\n\n  def arrange(s: String): String = {\n    val words = mutable.ArrayBuffer(s.split(\" +\"): _*)\n\n    words.indices.map(i => {\n      if (i % 2 == 0)\n        (if (i < words.length - 1 && words(i).length > words(i + 1).length) switch(words, i)(i)\n        else words(i)).toLowerCase\n      else\n        (if (i < words.length - 1 && words(i).length < words(i + 1).length) switch(words, i)(i)\n        else words(i)).toUpperCase\n    }).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334963,"user_id":null,"body":"object Updown {\n  import scala.collection.mutable\n  \n  def arrange(s: String): String = {\n    val words = mutable.ArrayBuffer() ++ s.split(\" +\")\n\n    def switchAndThenGet(i: Int): String = {\n      val temp = words(i + 1)\n      words(i + 1) = words(i)\n      words(i) = temp\n      temp\n    }\n\n    words.indices.map( i => {\n      if (i % 2 == 0)\n        (if (i < words.length - 1 && words(i).length > words(i+1).length) switchAndThenGet(i)\n        else words(i)).toLowerCase\n      else\n        (if (i < words.length - 1 && words(i).length < words(i+1).length) switchAndThenGet(i)\n        else words(i)).toUpperCase\n    }).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334964,"user_id":null,"body":"object Updown {\n  def arrange(s: String): String = {\n    if (s.trim.length == 0) s else {\n      def go(arr: Array[String], acc: Array[String], counter: Int): Array[String] = {\n        if (arr.length == 1) acc :+ arr(0) else {\n          val sortedFirstTwo = arr.take(2).sortWith {\n            { (a, b) =>\n              if (counter % 2 == 0) {\n                a.length > b.length\n              } else {\n                a.length < b.length\n              }\n            }\n          }\n\n          val casedAndSortedPair = if (counter % 2 == 0) {\n            Array(sortedFirstTwo(0).toUpperCase, sortedFirstTwo(1).toLowerCase)\n          } else Array(sortedFirstTwo(0).toLowerCase, sortedFirstTwo(1).toUpperCase)\n\n          val fixedArr = casedAndSortedPair ++ arr.drop(2)\n          go(fixedArr.drop(1), acc :+ fixedArr(0), counter + 1)\n        }\n      }\n\n      val arr = s.split(\" \")\n      val newArray = new Array[String](0)\n      go(arr, newArray, 1).mkString(\" \")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334965,"user_id":null,"body":"object Updown {\n\n  def arrange(s: String): String = {\n    if (s.length()== 0) \"\"\n    else {\n      var isUp = false\n      val split = s.toLowerCase.split(\" \").toList\n      val result = split.tail.foldLeft(split.head)((acc,each) => {\n      val accList = acc.split(\" \").toList\n      val last = accList.last\n      if(isUp)\n      {   \n        isUp = false     \n          if (last.length() >= each.length()) acc + \" \" + each\n          else accList.take(accList.length-1).mkString(\" \") + \" \" +  each + \" \" + last   \/\/ Filter does not work!!          \n      }\n      else\n      {\n          isUp = true\n          if (last.length() <= each.length()) acc + \" \" + each\n          else accList.take(accList.length-1).mkString(\" \") + \" \" +  each + \" \" + last          \n      }\n    }).trim().split(\" \").zipWithIndex    \n    result.map(x => if (x._2 % 2 == 0) x._1 else x._1.toUpperCase).mkString(\" \").trim()\n  }\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334966,"user_id":null,"body":"object Updown {\ndef arrange(s: String): String = {\n  def loop(h: String, t: List[String], p: Boolean, res: String): String = {\n    def toString(s: String) = s\"$res ${if (p) s.toUpperCase else s.toLowerCase}\"\n    if (t.isEmpty) toString(h)\n    else if (h.length > t.head.length && !p || h.length < t.head.length && p)\n      loop(h, t.tail, !p, toString(t.head))\n    else\n      loop(t.head, t.tail, !p, toString(h))\n  }\n\n  if (s == \"\") \"\" else {\n    val l = s.split(\" \").toList\n    loop(l.head, l.tail, false, \"\").stripPrefix(\" \")\n  }\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56d6d927c9ae3f115b0008dd":[{"id":334967,"user_id":468,"body":"import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.math.Ordering.Double.TotalOrdering\nimport scala.util.Try\n\nobject LinearSolver {\n\n  def solve(equations: String*): Map[String, Double] = {\n    val allVariables = new mutable.HashSet[String]()\n    val parsed = equations.map { equation =>\n      val (lhs, rhs) = splitIntoTerms(equation)\n      val variableTerms = lhs.filterNot(_.constantTerm) ++ rhs.filterNot(_.constantTerm).map(_.negated)\n      val constantTerms = lhs.filter(_.constantTerm).map(_.negated) ++ rhs.filter(_.constantTerm)\n\n      val variables = variableTerms.groupMapReduce(_.variable)(identity)(_ + _).values.toList\n      val constant = if (constantTerms.isEmpty) Term(0d, \"\") else constantTerms.reduce(_ + _)\n\n      val validTerms = variables.filter(_.coefficient != 0)\n      allVariables ++= validTerms.map(_.variable)\n\n      val den = gcd((constant.coefficient :: validTerms.map(_.coefficient)).map(_.abs))\n      (constant \/ den :: validTerms.map(_ \/ den)).map { term =>\n        (term.variable, term.coefficient)\n      }.toMap\n    }.distinctBy {\n      \/\/ Removed two equations if they are the same\n      _.toList.sortBy(_._1).map {\n        case (v, c) => s\"$v*$c\"\n      }.mkString\n    }\n\n    val variableList = allVariables.toList\n    if (variableList.size > parsed.length) {\n      Map.empty\n    } else {\n      val terms = parsed.map { equation =>\n        (variableList.map(v => equation.getOrElse(v, 0d)).toArray, equation.getOrElse(\"\", 0d))\n      }.toArray\n\n      val A = terms.map(_._1)\n      val B = terms.map(_._2)\n\n      val A_ = A.take(variableList.size)\n      val B_ = B.take(variableList.size)\n      val C = solve(A_, B_)\n      if (C.isEmpty) Map.empty\n      else {\n        val solution = variableList.zip(C.get).toMap\n\n        \/\/ Check the solution on=btained with extra equations passed, if any\n        if ((variableList.size until parsed.length).exists { i =>\n          A(i).zip(variableList).map { case (c, v) => c * solution(v) }.sum.rounded != B(i).rounded\n        }) Map.empty\n        else\n          solution\n      }\n    }\n  }\n\n  private def gcd(list: List[Double]): Double = list reduce gcd\n\n  \/**\n   * Euler GCD\n   *\n   * @param a A Number\n   * @param b A Number\n   * @return GCD of a and b\n   *\/\n  @tailrec\n  private def gcd(a: Double, b: Double): Double = if (b == 0) a else gcd(b, a % b)\n\n  \/**\n   * Splits the equation into individual terms.\n   *\n   * @param equation The equation to split\n   * @return A Tuple of Terms in LHS and RHS respectively\n   *\/\n  private def splitIntoTerms(equation: String): (Array[Term], Array[Term]) = {\n    val side = equation.replace(\" \", \"\").split(\"=\")\n    val parsed = side.map(_.replace(\"+\", \" +\")\n      .replace(\"-\", \" -\")\n      .split(\" \")\n      .filterNot(_.isEmpty)\n      .map(parseTerm))\n    (parsed(0), parsed(1))\n  }\n\n  \/\/ Given a string, parse it to a Term\n  private def parseTerm(operand: String): Term = {\n    val (variable, coefficient) = operand.partition(_.isLetter)\n    val cf = if (!coefficient.exists(_.isDigit)) (coefficient + \"1\").toDouble else coefficient.toDouble\n    Term(cf, variable)\n  }\n\n  \/\/ Solves the Matrix Equation AX = B\n  \/\/ Returns X, calculated using the logic X=A'*B\n  private def solve(A: Array[Array[Double]], B: Array[Double]): Option[Array[Double]] = Try((!A).get * B).toOption\n\n  implicit class matrixMath[T](A: Array[Array[Double]]) {\n\n    lazy val dim: Int = A.length\n\n    \/**\n     * Returns A'\n     *\n     * @return the inverse of this matrix\n     *\/\n    def unary_! : Option[Array[Array[Double]]] = {\n      val inverse = new Array[Array[Double]](dim)\n      val I = new Array[Array[Double]](dim)\n      for (i <- 0 until dim) {\n        inverse(i) = new Array[Double](dim)\n        I(i) = new Array[Double](dim)\n        I(i)(i) = 1 \/\/ others are 0\n      }\n\n\n      \/\/ Transform the matrix into an upper triangle, and return pivoting order\n      val index = A.gaussian\n\n      \/\/ Update the matrix b[i][j] with the ratios stored\n      for (i <- 0 until dim - 1)\n        for (j <- i + 1 until dim)\n          for (k <- 0 until dim)\n            I(index(j))(k) -= A(index(j))(i) * I(index(i))(k)\n\n      \/\/ Perform backward substitutions\n      for (i <- 0 until dim) {\n        inverse(dim - 1)(i) = I(index(dim - 1))(i) \/ A(index(dim - 1))(dim - 1)\n        for (j <- dim - 2 to 0 by -1) {\n          inverse(j)(i) = I(index(j))(i)\n          for (k <- j + 1 until dim) {\n            inverse(j)(i) -= A(index(j))(k) * inverse(k)(i)\n          }\n          inverse(j)(i) \/= A(index(j))(j)\n        }\n      }\n      if (inverse.exists(_.exists(n => n.isNaN || n.abs > 10e15)))\n        None\n      else\n        Some(inverse)\n    }\n\n    \/**\n     * Method to carry out the partial-pivoting Gaussian elimination.\n     *\n     * @return the pivoting order\n     *\/\n    def gaussian: Array[Int] = {\n      val index = A.indices.toArray\n\n      \/\/ Find the rescaling factors, one from each row\n      val c = A.map(_.map(_.abs).max)\n\n      for (j <- 0 until dim - 1) {\n        val pivot = (j until dim).maxBy { i =>\n          A(index(i))(j).abs \/ c(index(i))\n        }\n\n        \/\/ Interchange rows according to the pivoting order\n        val temp = index(j)\n        index(j) = index(pivot)\n        index(pivot) = temp\n        for (i <- j + 1 until dim) {\n          val pj = A(index(i))(j) \/ A(index(j))(j)\n\n          \/\/ Record pivoting ratios below the diagonal\n          A(index(i))(j) = pj\n\n          \/\/ Modify other elements accordingly\n          for (l <- j + 1 until dim)\n            A(index(i))(l) -= pj * A(index(j))(l)\n        }\n      }\n      index\n    }\n\n    \/**\n     * Returns the result of multiplication of this matrix and B\n     *\n     * @param B The matrix to multiply with\n     * @return The result of Matrix multiplication\n     *\/\n    def *(B: Array[Double]): Array[Double] = {\n      A.indices.map(A(_).zip(B).map(x => x._1 * x._2).sum).toArray\n    }\n  }\n\n  case class Term(coefficient: Double, variable: String) {\n    lazy val constantTerm: Boolean = variable.isEmpty\n\n    lazy val negated: Term = this.copy(coefficient = -coefficient)\n\n    def \/(den: Double): Term = this.copy(coefficient = coefficient \/ den)\n\n    def +(that: Term): Term = Term(this.coefficient + that.coefficient, this.variable)\n  }\n\n  implicit class extendedDouble(d: Double) {\n\n    def rounded: Double = BigDecimal(d).setScale(6, BigDecimal.RoundingMode.HALF_UP).toDouble\n\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56d904db9963e9cf5000037d":[{"id":334968,"user_id":527,"body":"object ThinkingAndTesting01 {\n  def testit(a: Int, b: Int): Int = a | b\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334969,"user_id":null,"body":"\n\nobject ThinkingAndTesting01 {\n\n  def testit(a: Int, b: Int): Int = {\n    fromBoolSeq(combine(toBoolList(a), toBoolList(b)).reverse)\n  }\n\n  private def toBoolList(n: Int): List[Int] = {\n    if (n == 0) {\n      List()\n    } else {\n      toBoolList(n \/ 2) ++ List(n % 2)\n    }\n  }\n\n  private def fromBoolSeq(list: List[Int]): Int = {\n    list.foldLeft((1, 0))(op)._2\n  }\n\n  private def op(tup2: (Int, Int), i: Int): (Int, Int) = {\n    (tup2._1 * 2, tup2._2 + tup2._1 * i)\n  }\n\n  private def combine(as: List[Int], bs: List[Int]): List[Int] = {\n    if (bs.size > as.size) {\n      combine(bs, as)\n    } else {\n      val d = as.size - bs.size\n      as.take(d) ++ as.drop(d).zip(bs).\n        map({ case (u, v) => Math.max(u, v) })\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334970,"user_id":null,"body":"object ThinkingAndTesting01 {\n  def testit(a: Int, b: Int): Int = {\n    \/\/ a + b ?\n    \/\/ a * b ?\n    a.|(b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334971,"user_id":53,"body":"object ThinkingAndTesting01 {\n  def testit(a: Int, b: Int): Int = {\n    (a ^ b) | (a & b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334972,"user_id":null,"body":"object ThinkingAndTesting01 {\n  \n  def testit(a: Int, b: Int): Int = {\n    val aBin = a.toBinaryString\n    val bBin = b.toBinaryString\n    if (a < b) {\n      val cBin = (\"0\" * (bBin.length - aBin.length)).concat(aBin)\n      Integer.parseInt((0 to cBin.length).toList.take(cBin.length).map(x => if (cBin(x) == '1' || bBin(x) == '1') \"1\" else \"0\").mkString(\"\"), 2)\n    }\n    else {\n      val cBin = (\"0\" * (aBin.length - bBin.length)).concat(bBin)\n      Integer.parseInt((0 to cBin.length).toList.take(cBin.length).map(x => if (cBin(x) == '1' || aBin(x) == '1') \"1\" else \"0\").mkString(\"\"), 2)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334973,"user_id":null,"body":"object ThinkingAndTesting01 {\n  def testit(a: Int, b: Int): Int = a + b - (a & b)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbe0e313c2f63be4000b25":[{"id":334974,"user_id":527,"body":"object Opstrings {\n\n  def horMirror(x: Array[String]) =\n    x.reverse\n  def vertMirror(x: Array[String]) =\n    x.map(_.reverse)\n  def oper(f: Array[String] => Array[String], s: String): String =\n    f(s.split('\n')).mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334975,"user_id":null,"body":"object Opstrings {\n\n  def horMirror(strng: String): String = {\n    strng.split(\"\\\n\").reverse.mkString(\"\n\")\n  }\n  def vertMirror(strng: String): String = {\n    strng.split(\"\\\n\").map(x => x.reverse).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334976,"user_id":null,"body":"object Opstrings {\n\n  def horMirror(str: String): String = {\n    str.reverse.split(\"\n\").map(_.reverse).mkString(\"\n\")\n  }\n\n  def vertMirror(str: String): String = {\n    str.split(\"\n\").map(_.reverse).mkString(\"\n\")\n  }\n  \n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334977,"user_id":null,"body":"object Opstrings {\n\n  def horMirror(strng: String): String = {\n    strng.split('\n').reverse.mkString(\"\n\")\n  }\n  def vertMirror(strng: String): String = {\n    strng.reverse.split('\n').reverse.mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334978,"user_id":null,"body":"object Opstrings {\n\nval lettersToNumbers = ('a' to 'z').zip(0 to 25).toMap\nval numberstoLetters = lettersToNumbers.map(_.swap)\n\n  def horMirror(strng: String): String = {\n    strng.split(\"\n\").reverse.mkString(\"\n\")\n  }\n  def vertMirror(strng: String): String = {\n    strng.split(\"\n\").map(_.reverse).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String = f(s)\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334979,"user_id":220,"body":"object Opstrings {\n\n  def coreOp(f: Seq[String] => Seq[String])(strng: String): String = {\n    f(strng.split('\n')).mkString(\"\n\")\n  }\n  \n  val horMirror: String => String = coreOp(s => s.reverse)\n  val vertMirror: String => String = coreOp(s => s.map(_.reverse))\n  \n  def oper(f: String => String, s: String): String = { f(s) }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334980,"user_id":492,"body":"object Opstrings {\n\n  def horMirror(strng: String): String = {\n    val rws: Array[String] = strng.split(\"\\\n\")\n    val rvsd: Array[String] = rws.clone()\n    for (i <- 0 until rws.length) rvsd(i) = rws(rws.length - i - 1)\n    rvsd.mkString(\"\n\")\n  }\n  def vertMirror(strng: String): String = {\n    val rws: Array[String] = strng.split(\"\\\n\")\n    val rvsd: Array[String] = rws.clone()\n    for (i <- 0 until rws.length)\n      rvsd(i) = new StringBuilder(rws(i)).reverse.toString\n    rvsd.mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334981,"user_id":492,"body":"object Opstrings {\n\n  def horMirror(strng: String): String = {\n    val rws: Array[String] = strng.split(\"\\\n\")\n    val rvsd: Array[String] = rws.clone()\n    for (i <- 0 until rws.length) rvsd(i) = rws(rws.length - i - 1)\n    rvsd.mkString(\"\n\")\n  }\n  def vertMirror(strng: String): String = {\n    val rws: Array[String] = strng.split(\"\\\n\")\n    val rvsd: Array[String] = rws.clone()\n    for (i <- 0 until rws.length)\n      rvsd(i) = new StringBuilder(rws(i)).reverse.toString\n    rvsd.mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334982,"user_id":null,"body":"object Opstrings {\n\n  def horMirror(strng: String): String = {\n    strng.linesIterator.toList.reverse.mkString(\"\n\")\n  }\n  def vertMirror(strng: String): String = {\n    strng.lines.map(_.reverse).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334983,"user_id":null,"body":"object Opstrings {\n\n  def horMirror(strng: String): String = {\n    strng.split(\"\n\").toList.reverse.mkString(\"\n\")\n    \n  }\n  def vertMirror(strng: String): String = {\n    strng.split(\"\n\").toList.map(_.reverse).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbe7f113c2f63570000b86":[{"id":334984,"user_id":null,"body":"object Opstrings1 {\n  def rot(strng: String): String = {\n    strng.split(\"\\\"\").map(x=>x.reverse).mkString(\"\\r\")\n  }\n  def selfieAndRot(strng: String): String = {\n    val len = strng.split(\"\n\")(0).length\n    strng.split(\"\n\").map(x=> x+\".\"*len).mkString(\"\n\") ++\"\n\"++ strng.reverse.split(\"\n\").map(x=> \".\"*len+x).mkString(\"\n\")  }\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334985,"user_id":null,"body":"object Opstrings1 {\n  \n  def _rot(squareString: Seq[String]): String = {\n    squareString.map(_.reverse).reverse.mkString(\"\n\")\n  }\n\n\n  def rot(squareString: String): String = {\n    _rot(squareString.split('\n'))\n  }\n  \n  def selfieAndRot(squareString: String): String = {\n    val dotted = squareString.split('\n').map(s => s + \".\" * s.size)\n    dotted.mkString(\"\n\") + '\n' + _rot(dotted)\n  }\n  \n  def oper(f: String => String, squareString: String): String = f(squareString)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334986,"user_id":null,"body":"object Opstrings1 {\n\n  def rot(s: String): String = {\n    val a = s.split(\"\n\").reverse\n    a.map(_.reverse).mkString(\"\n\")\n  }\n  \n  def selfieAndRot(str: String): String = {\n    val words = str.split(\"\n\")\n\n    val a = words.map(s => s + \".\" * s.length).mkString(\"\n\")\n\n    val b = words.reverse\n      .map(_.reverse)\n      .map(s => \".\" * s.length + s)\n      .mkString(\"\n\")\n\n    a + \"\n\" + b\n  }\n  \n  def oper(f: String => String, s: String): String = {\n    f(s)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334987,"user_id":492,"body":"object Opstrings1 {\n  def rot(strng: String): String = {\n    val sb: StringBuilder = new StringBuilder(strng)\n    sb.reverse.toString\n  }\n  def selfieAndRot(strng: String): String = {\n    val nbDots: Int = strng.indexOf(\"\n\")\n    var dots: String = \"\"\n    for (i <- 0 until nbDots) {\n      dots += \".\"\n    }\n    var plusDots: String = strng.replaceAll(\"\n\", dots + \"\n\")\n    plusDots += dots\n    plusDots + \"\n\" + rot(plusDots)\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334988,"user_id":492,"body":"object Opstrings1 {\n  def rot(strng: String): String = {\n    val sb: StringBuilder = new StringBuilder(strng)\n    sb.reverse.toString\n  }\n  def selfieAndRot(strng: String): String = {\n    val nbDots: Int = strng.indexOf(\"\n\")\n    var dots: String = \"\"\n    for (i <- 0 until nbDots) {\n      dots += \".\"\n    }\n    var plusDots: String = strng.replaceAll(\"\n\", dots + \"\n\")\n    plusDots += dots\n    plusDots + \"\n\" + rot(plusDots)\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334989,"user_id":null,"body":"object Opstrings1 {\n  def rot(strng: String): String = {\n    strng.split(\"\n\").reverse.map(_.reverse).mkString(\"\n\")\n  }\n  def selfieAndRot(strng: String): String = {\n    val f = strng.split(\"\n\").map(s =>s + \".\"*s.size).mkString(\"\n\")\n    val r = rot(strng).split(\"\n\").map(s => \".\"*s.size + s).mkString(\"\n\")\n    f+\"\n\"  ++ r\n  }\n  def oper(f: String => String, s: String): String ={\n    f(s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334990,"user_id":null,"body":"object Opstrings1 {\n  def rot(strng: String): String = \n    strng.split(\"\n\").map(_.reverse).reverse.mkString(\"\n\")\n  \n  def selfieAndRot(s: String): String = {\n    val squareLen = s.takeWhile( x => x.isLetter ).size\n    (s.replaceAll(\"\n\", s\".\"*squareLen + \"\n\")+s\".\"*squareLen ) +\n    (s.replaceAll(\"\n\", s\".\"*squareLen + \"\n\")+s\".\"*squareLen + \"\n\").reverse\n  }\n  \n  def oper(f: String => String, s: String): String =\n    f(s)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334991,"user_id":null,"body":"object Opstrings1 {\n  def rot(s: String): String = {\n    return s.split(\"\\\\\n\")\n      .map(s => s.reverse)\n      .reverse\n      .mkString(\"\n\")\n  }\n\n  def selfieAndRot(s: String): String = {\n    val rotString = rot(s).split(\"\\\\\n\")\n      .map(s => \".\" * s.length + s)\n      .mkString(\"\n\")\n\n    val selfString = s.split(\"\\\\\n\")\n      .map(s => s + \".\" * s.length)\n      .mkString(\"\n\")\n\n    return selfString + \"\n\" + rotString\n  }\n\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334992,"user_id":null,"body":"object Opstrings1 {\n  def rot(strng: String): String = {\n    return strng.reverse\n  }\n  def selfieAndRot(strng: String): String = {\n    val s = strng.split(\"\n\").map(k => k + k.map(_=>\".\").mkString(\"\")).mkString(\"\n\")\n    return s + \"\n\" + rot(s)\n  }\n  def oper(f: String => String, s: String): String = {\n       return f(s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334993,"user_id":null,"body":"object Opstrings1 {\n  val rot: Array[String] => Array[String] = (text: Array[String]) => text\n    .mkString(\"\n\")\n    .reverse\n    .split(\"\n\")\n\n  val selfieAndRot: Array[String] => Array[String] = (text: Array[String]) =>{\n    val formatted = text.map(x => x.padTo(x.size*2, '.'))\n    val rotated = rot(formatted)\n\n    formatted ++ rotated\n  }\n\n  val oper: (Array[String] => Array[String], String) => String = (f: Array[String] => Array[String], s: String) => \n    f(s.split(\"\n\")).mkString(\"\n\")\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbeec613c2f63be4000be6":[{"id":334994,"user_id":null,"body":"object Opstrings {\n\n  private def stringTrans(strng: String): Array[String] = {\n    strng.split('\n')\n  }\n  def diag1Sym(strng: String): String = {\n    stringTrans(strng).map(_.split(\"\")).transpose.map(_.mkString).mkString(\"\n\")\n  }\n  def rot90Clock(strng: String): String = {\n    stringTrans(strng).map(_.split(\"\")).transpose.map(_.reverse.mkString).mkString(\"\n\")\n  }\n  def selfieAndDiag1(strng: String): String = {\n    stringTrans(strng).zip(stringTrans(diag1Sym(strng))).map(x => x._1+\"|\"+x._2).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String = f(s)\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334995,"user_id":null,"body":"object Opstrings {\n\n  \n  def diag1Sym(strng: String): String = {\n    strng.split(\"\n\").map(_.toArray).transpose.map(_.mkString).mkString(\"\n\")\n  }\n  def rot90Clock(strng: String): String = {\n    diag1Sym(strng).split(\"\n\").map(_.reverse).mkString(\"\n\")\n  }\n  def selfieAndDiag1(strng: String): String = {\n    List(strng.split(\"\n\"),diag1Sym(strng).split(\"\n\")).transpose.map(_.mkString(\"|\")).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334996,"user_id":null,"body":"object Opstrings {\n\n  private def stringTrans(strng: String): Array[String] = strng.split(\"\n\")\n  \n  def diag1Sym(strng: Array[String]): Array[String] = \n    (0 until strng.size).map(i => strng.map(_.charAt(i)).mkString(\"\")).toArray\n  \n  def rot90Clock(strng: Array[String]): Array[String] = \n    diag1Sym(strng).map(_.reverse)\n  \n  def selfieAndDiag1(strng: Array[String]): Array[String] = \n    strng.zip(diag1Sym(strng).toIterable).map{case (str,diag) => s\"$str|$diag\"}\n  \n  def oper(f: Array[String] => Array[String], s: String): String =\n    f(stringTrans(s)).mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334997,"user_id":492,"body":"object Opstrings {\n\n  private def stringTrans(strng: String): Array[String] = {\n    val strings: Array[String] = strng.split(\"\n\")\n    var result = Array.fill(strings.length)(\"\")\n    for (s <- strings; i <- 0 until s.length) {\n      result(i) = result(i) + s.charAt(i)\n    }\n    result\n  }\n  def diag1Sym(strng: String): String = {\n    val result: Array[String] = stringTrans(strng)\n    result.mkString(\"\n\")\n  }\n  def rot90Clock(strng: String): String = {\n    val result: Array[String] = stringTrans(strng)\n    for (i <- 0 until result.length) {\n      result(i) = new StringBuilder(result(i)).reverse.toString\n    }\n    result.mkString(\"\n\")\n  }\n  def selfieAndDiag1(strng: String): String = {\n    val result: Array[String] = strng.split(\"\n\")\n    val fromDiag: Array[String] = stringTrans(strng)\n    for (i <- 0 until result.length) {\n      result(i) = result(i).concat(\"|\").concat(fromDiag(i))\n    }\n    result.mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334998,"user_id":null,"body":"object Opstrings {\n\n  private def stringTrans(strng: String): Array[String] = {\n    strng.split(\"\n\")\n  }\n  def diag1Sym(strng: String): String = {\n    val trans: Array[String] = stringTrans(strng)\n    val res = for (i <- trans.indices; r <- trans) yield r(i)\n    res.grouped(trans.length)\n      .map(_.mkString)\n      .mkString(\"\n\")\n  }\n  def rot90Clock(strng: String): String = {\n    stringTrans(diag1Sym(strng))\n      .map(_.reverse)\n      .mkString(\"\n\")\n  }\n  def selfieAndDiag1(strng: String): String = {\n    stringTrans(strng).zip(stringTrans(diag1Sym(strng)))\n      .map(el => el._1 + \"|\" + el._2)\n      .mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":334999,"user_id":492,"body":"object Opstrings {\n\n  private def stringTrans(strng: String): Array[String] = {\n    val strings: Array[String] = strng.split(\"\n\")\n    var result = Array.fill(strings.length)(\"\")\n    for (s <- strings; i <- 0 until s.length) {\n      result(i) = result(i) + s.charAt(i)\n    }\n    result\n  }\n  def diag1Sym(strng: String): String = {\n    val result: Array[String] = stringTrans(strng)\n    result.mkString(\"\n\")\n  }\n  def rot90Clock(strng: String): String = {\n    val result: Array[String] = stringTrans(strng)\n    for (i <- 0 until result.length) {\n      result(i) = new StringBuilder(result(i)).reverse.toString\n    }\n    result.mkString(\"\n\")\n  }\n  def selfieAndDiag1(strng: String): String = {\n    val result: Array[String] = strng.split(\"\n\")\n    val fromDiag: Array[String] = stringTrans(strng)\n    for (i <- 0 until result.length) {\n      result(i) = result(i).concat(\"|\").concat(fromDiag(i))\n    }\n    result.mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335000,"user_id":null,"body":"object Opstrings {\n\n  \/\/private def stringTrans(strng: String): Array[String] = {\n    \/\/ your code\n \/\/ }\n  def diag1Sym(strng: String): String = {\n    val t = strng.split(\"\n\")\n    (for(i <- List.range(0, t(0).size) )\n        yield (t.map( x => x(i)).mkString(\"\") )\n    ).mkString(\"\n\")\n  }\n  \n  def rot90Clock(strng: String): String = \n    diag1Sym(strng).split(\"\n\").map(_.reverse).mkString(\"\n\")\n  \n  def selfieAndDiag1(strng: String): String = {\n    val si = strng.split(\"\n\")\n    val diagi = diag1Sym(strng).split(\"\n\")\n    (for(i <- List.range(0,si(0).size)) yield (s\"${si(i)}|${diagi(i)}\")).mkString(\"\n\")\n  }\n  \n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335001,"user_id":null,"body":"object Opstrings {\n \n  private def stringTrans(strng: String): Array[String] = {\n    strng.split(\"\n\")\n  }\n  def diag1Sym(strng: String): String = {\n    stringTrans(strng).map(_.split(\"\")).transpose.map(_.mkString).mkString(\"\n\")\n  }\n  def rot90Clock(strng: String): String = {\n    stringTrans(strng).map(_.split(\"\")).reverse.transpose.map(_.mkString).mkString(\"\n\")\n  }\n  def selfieAndDiag1(strng: String): String = {\n    val strng_diag = diag1Sym(strng).split(\"\n\")\n    stringTrans(strng).zip(strng_diag).map(x => x._1+\"|\"+x._2).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335002,"user_id":null,"body":"import scala.collection.IterableOnce\n\nobject Opstrings {\n  private val NL: String = \"\n\"\n\n  private def split(str: String): Seq[String] = {\n    str.split(NL).toSeq\n  }\n\n  private def join(iter: IterableOnce[String]): String = {\n    iter.iterator.mkString(NL)\n  }\n\n  def diag1Sym(str: String): String = {\n    val seq = split(str)\n    val N = seq.length\n\n    var output: String = \"\"\n    for (i <- 0 until N; j <- 0 until N)\n      output += seq(j)(i)\n\n    join(output.grouped(N))\n  }\n\n  def rot90Clock(str: String): String = {\n    val seq = split(str)\n    val N = seq.length\n\n    var output: String = \"\"\n    for (i <- 0 until N; j <- N-1 to 0 by -1)\n      output += seq(j)(i)\n\n    join(output.grouped(N))\n  }\n  def selfieAndDiag1(strng: String): String = {\n    val diag = split(diag1Sym(strng))\n    val str = split(strng)\n\n    var list = Seq[String]()\n    for (i <- str.indices) {\n      list = list :+ s\"${str(i)}|${diag(i)}\"\n    }\n\n    join(list)\n  }\n  def oper(f: String => String, s: String): String = {\n    f(s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335003,"user_id":null,"body":"object Opstrings {\n    import collection.mutable\n\n  private def stringTrans(strng: String): Array[String] = {\n    null\n  }\n  def diag1Sym(strng: String): String = {\n        val tab = strng.split(\"\n\")\n    var buffer  = mutable.Buffer[Char]()\n    var i = 0\n    while(i < tab.length)\n    {\n      tab.foreach{ s =>\n        buffer += s(i)\n      }\n      i += 1\n    }\n      buffer.grouped(tab.length).map(a => a.mkString).mkString(\"\n\")\n  \n  }\n  def rot90Clock(strng: String): String = {\n diag1Sym(strng).split(\"\n\").map(_.reverse).mkString(\"\n\") \n  }\n  def selfieAndDiag1(strng: String): String = {\n      strng.split(\"\n\").zip(diag1Sym(strng).split(\"\n\")).map{case (a,b) => s\"$a|$b\"}.mkString(\"\n\")   \n  }\n  def oper(f: String => String, s: String): String = f(s)\n    \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbf59b0a10feb08c000227":[{"id":335004,"user_id":null,"body":"object Opstrings {\n\n  def diag2Sym(strng: String): String = {\n    val strngLines = strng.split(\"\n\")\n    val n = strngLines.length\n    val range = 0 until n\n    val reorderedChars = for {\n      i <- range.reverse\n      j <- range.reverse\n    } yield strngLines(j).charAt(i)\n    reorderedChars.grouped(n).map(_.mkString).mkString(\"\n\")\n  }\n\n  def rot90Counter(strng: String): String =\n    diag2Sym(strng)\n      .split(\"\n\")\n      .map(_.reverse)\n      .mkString(\"\n\")\n\n  def selfieDiag2Counterclock(strng: String): String = {\n    val ori = strng.split(\"\n\")\n    val dia = diag2Sym(strng).split(\"\n\")\n    val rot = rot90Counter(strng).split(\"\n\")\n    val acc = for {i <- 0 until ori.length} yield List(ori(i), dia(i), rot(i))\n    acc.map(_.mkString(\"|\")).mkString(\"\n\")\n  }\n\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335005,"user_id":573,"body":"object Opstrings {\n\n  def diag2Sym(str: String): String =\n    str.split(\"\n\").map(_.toArray).transpose.reverse.map(_.reverse.mkString).mkString(\"\n\")\n\n  def rot90Counter(str: String): String =\n    str.split(\"\n\").map(_.toArray).transpose.reverse.map(_.mkString).mkString(\"\n\")\n\n  def selfieDiag2Counterclock(str: String): String =\n    (str.split(\"\n\"), diag2Sym(str).split(\"\n\"), rot90Counter(str).split(\"\n\"))\n      .zipped\n      .map { case (a, b, c) => s\"$a|$b|$c\" }.mkString(\"\n\")\n\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335006,"user_id":null,"body":"object Opstrings {\n  def diag2Sym(strng: String): String = {\n    strng.split(\"\n\").map(_.toArray).transpose.reverse.map(_.reverse.mkString).mkString(\"\n\")\n  }\n  def rot90Counter(strng: String): String = {\n    strng.split(\"\n\").map(_.toArray).transpose.reverse.map(_.mkString).mkString(\"\n\")\n  }\n  def selfieDiag2Counterclock(strng: String): String = {\n    List(strng.split(\"\n\"), diag2Sym(strng).split(\"\n\"), rot90Counter(strng).split(\"\n\")).transpose.map(_.mkString(\"|\")).mkString(\"\n\")\n  }\n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335007,"user_id":null,"body":"object Opstrings {\n  def diag2Sym(text: Seq[String]): Seq[String] = {\n    def getFirstOfEachIndex(data: Seq[String], agg: Seq[String]): Seq[String] = {\n      data match {\n        case x if x.size > 0 => {\n          getFirstOfEachIndex(data.map(_.tail).filter(_.nonEmpty), agg :+ data.flatMap(_.headOption).mkString)\n        }\n        case _ => agg.map(_.reverse)\n      }\n    }\n    getFirstOfEachIndex(text, Seq[String]()).reverse\n  }\n\n  def rot90Counter(text: Seq[String]): Seq[String] = diag2Sym(text).map(_.reverse)\n\n  def selfieDiag2Counterclock(text: Seq[String]) = List(text, diag2Sym(text), rot90Counter(text))\n      .transpose\n      .map(_.mkString(\"|\"))\n\n  def oper(f: Seq[String] => Seq[String], s: String): String = f(s.split(\"\n\")).mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335008,"user_id":null,"body":"object Opstrings {\n  \n  def splitInput(strng: String): List[String] = strng.split('\n').toList\n  \n  def diag2Sym(lines: List[String]): List[String] = {\n    rot90Counter(lines).map(x => x.reverse)\n  }\n  def rot90Counter(lines: List[String]): List[String] = {\n    (0 to lines.length-1).toList.reverse.map(x => lines.map(y => y(x)).mkString(\"\"))\n  }\n  def selfieDiag2Counterclock(lines: List[String]): List[String] = {\n    val diag = diag2Sym(lines)\n    val rot = rot90Counter(lines)\n    (0 to lines.length-1).toList.map(x => List(lines(x), diag(x), rot(x)).mkString(\"|\"))\n  }\n  def oper(f: List[String] => List[String], s: String): String = f(splitInput(s)).mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335009,"user_id":null,"body":"object Opstrings {\n  \n  def diag2Sym(input : String): String = {\n    val splits = input.split(\"\n\")\n    var output = \"\"\n    for (i <- splits.length-1 to 0 by -1) {\n      if (i != splits.length-1) {\n        output += \"\n\"\n      }\n      for (j <- splits(i).length-1 to 0 by -1) {\n        output += splits(j)(i)\n      }\n    }\n    output\n  }\n\n  def rot90Counter(input : String) : String = {\n    diag2Sym(input).split(\"\n\").map(f => f.reverse).mkString(\"\n\")\n  }\n\n  def selfieDiag2Counterclock(input : String) : String = {\n    val firstPart = input.split(\"\n\")\n    val secondPart = diag2Sym(input).split(\"\n\")\n    val thirdPart = rot90Counter(input).split(\"\n\")\n    var output = \"\"\n    for (i <- 0 until firstPart.length) {\n      if (i != firstPart.length-1) {\n        output += firstPart(i) + \"|\" + secondPart(i) + \"|\" + thirdPart(i) + \"\n\"\n      }\n      else {\n        output += firstPart(i) + \"|\" + secondPart(i) + \"|\" + thirdPart(i)\n      }\n    }\n    output\n  }\n  \n  def oper(f: String => String, s: String): String = f(s)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335010,"user_id":null,"body":"object Opstrings {\n  def diag2Sym(str: String): String = \n    rot90Counter(str).split(\"\n\").map(_.reverse).mkString(\"\n\")\n  \n  def rot90Counter(str: String): String = {\n    val splited = str.split(\"\n\")\n      def formString(currentArray: Array[String], resultArray: Array[String] = Array()): String = \n        if (currentArray(0).isEmpty) resultArray.reverse.mkString(\"\n\")\n        else formString(currentArray.map(_.tail), resultArray ++ Array(currentArray.map(_.head).mkString(\"\")))\n      formString(splited)\n    }\n  \n  def selfieDiag2Counterclock(str: String): String = {\n    val splited = str.split(\"\n\")\n    val diag = diag2Sym(str).split(\"\n\")\n    val rot = rot90Counter(str).split(\"\n\")\n    diag.map(i => splited(diag.indexOf(i)) + \"|\" + i + \"|\" + rot(diag.indexOf(i))).mkString(\"\n\")\n  }\n  \n  def oper(f: String => String, s: String): String =\n    f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335011,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\nobject Opstrings {\n    def diag2Sym(strng: String): String = modifyBy(strng, (ch:Char, str: String) => ch +: str)\n    def rot90Counter(strng: String): String = modifyBy(strng, (ch:Char, str: String) => str :+ ch)\n\n    private def modifyBy(strng: String, filling: (Char,String) => String) = {\n      val strs = strng.split(\"\n\")\n      val newStrs = ListBuffer.fill(strs.size)(\"\")\n      strs.foreach(s => {\n        for (j <- strs.size-1 to 0 by -1)\n        {\n          val curNew = filling(s((strs.size-1)-j),newStrs(j))\n          newStrs.update(j, curNew)\n        }\n      })\n      newStrs.mkString(\"\n\")\n    }\n    def selfieDiag2Counterclock(strng: String): String = {\n      val orig = strng.split(\"\n\")\n      val diag = diag2Sym(strng).split(\"\n\")\n      val rot = rot90Counter(strng).split(\"\n\")\n      val newStrs = ListBuffer[String]()\n      for (i <- 0 until orig.size)\n      {\n        newStrs += orig(i) + \"|\" + diag(i) + \"|\" + rot(i)\n      }\n      newStrs.mkString(\"\n\")\n    }\n    def oper(f: String => String, s: String): String = f(s)\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335012,"user_id":null,"body":"object Opstrings {\n  def diag2Sym(strng: String): String = {\n    val (arr, n) = splitArray(strng)\n    (0 until n).map(i => (0 until n).map(j => arr(n - 1 - j)(n - 1 - i)).mkString).mkString(\"\n\")\n  }\n\n  def rot90Counter(strng: String): String = {\n    val (arr, n) = splitArray(strng)\n    (0 until n).map(i => (0 until n).map(j => arr(j)(n - 1 - i)).mkString).mkString(\"\n\")\n  }\n\n  def selfieDiag2Counterclock(strng: String): String = {\n    val (arr, n) = splitArray(strng)\n    val arr2     = diag2Sym(strng).split(\"\n\")\n    val arr3     = rot90Counter(strng).split(\"\n\")\n    (0 until n).map(i => s\"${arr(i)}|${arr2(i)}|${arr3(i)}\").mkString(\"\n\")\n  }\n\n  private def splitArray(strng: String): (Array[String], Int) = {\n    val arr = strng.split(\"\n\")\n    (arr, arr.length)\n  }\n\n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335013,"user_id":null,"body":"object Opstrings {\n  private def stringTrans(strng: String): Array[String] = {\n    strng.split('\n')\n  }\n\n  private def arr2dToStrings(arr: Array[Array[Char]]): Array[String] = {\n    arr.map(row => row.mkString(\"\"))\n  }\n\n  private def joinStrArrays(lst: List[Array[String]]): String = {\n    val n = lst.head.size\n    val acc = new scala.collection.mutable.ListBuffer[String]()\n    for (i <- 0 until n) {\n      val row = lst.map(_(i)).mkString(\"|\")\n      acc += row\n    }\n    acc.mkString(\"\n\")\n  }\n\n  private def diag2SymStrings(strng: String): Array[String] = {\n    val sa: Array[String] = stringTrans(strng)\n    val n = sa.size\n    val buff = Array.ofDim[Char](n, n)\n    for (i <- 0 until n) {\n      for (j <- 0 until n) {\n        buff(i)(j) = sa(n - j - 1)(n - i - 1)\n      }\n    }\n    arr2dToStrings(buff)\n  }\n\n  private def rot90CounterStrings(strng: String): Array[String] = {\n      val sa: Array[String] = stringTrans(strng)\n      val n = sa.size\n      val buff = Array.ofDim[Char](n, n)\n      for (i <- 0 until n) {\n        for (j <- 0 until n) {\n          buff(j)(i) = sa(i)(n - j - 1)\n        }\n      }\n      arr2dToStrings(buff)\n  }\n\n  def diag2Sym(s: String): String = diag2SymStrings(s).mkString(\"\n\")\n  def rot90Counter(s: String): String = rot90CounterStrings(s).mkString(\"\n\")\n\n  def selfieDiag2Counterclock(strng: String): String = {\n    val orig = strng.split('\n')\n    val d2c = diag2SymStrings(strng)\n    val r90c = rot90CounterStrings(strng)\n    joinStrArrays(List(orig, d2c, r90c))\n  }\n  \n  def oper(f: String => String, s: String): String = f(s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dec885c54a926dcd001095":[{"id":335014,"user_id":573,"body":"object Opposite {\n\n  def opposite(number: Double): Double = -number\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335015,"user_id":null,"body":"object Opposite {\n\n  def opposite(n: Double): Double = -n;\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335016,"user_id":527,"body":"object Opposite {\n  val opposite = Numeric.DoubleAsIfIntegral.negate _\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335017,"user_id":null,"body":"object Opposite {\n\n  def opposite(number: Double): Double = -1 * number\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335018,"user_id":null,"body":"  object Opposite {\n\n  def opposite(number: Double): Double = {\n    \n    val straang = number.toString\n    \n    if (straang.contains(\"-\")) {\n       val result = straang.replace(\"-\", \" \")\n       result.toDouble\n    }\n    else {\n        val result = (\"-\")+ number\n         result.toDouble\n    }\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335019,"user_id":527,"body":"object Opposite {\n  val opposite = -(_: Double)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335020,"user_id":null,"body":"object Opposite {\n\n  def opposite(number: Double): Double = number match{\n    case x if x < 0 => +number.abs\n    case x if x > 0 => -number.abs\n    case _ => 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335021,"user_id":null,"body":"\/\/https:\/\/www.codewars.com\/kata\/56dec885c54a926dcd001095\/train\/scala\nobject Opposite {\n\n  def opposite(number: Double): Double = number * (-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335022,"user_id":null,"body":"object Opposite {\n\n  def opposite(number: Double): Double = {\n    var result = number\n    if(number < 0){\n      result = Math.abs(number)\n    } else if (number > 0) {\n      result = number - number * 2F\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335023,"user_id":null,"body":"object Opposite {\n\n  def opposite(number: Double): Double = {\n    var b :Double=0\n    val a = number.toString()\n    a.startsWith(\"-\") match {\n      case true => b=a.replace(\"-\",\"\").toDouble           \n      case _ => b=s\"-${number}\".toDouble                \n        }\n     b\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56e3cd1d93c3d940e50006a4":[{"id":335024,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    val splitedA = a.sorted.reverse.zipWithIndex.partition(x => x._2 % 2 == 0)\n    splitedA._1.map(_._1) ++ splitedA._2.map(_._1).sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335025,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    def pullMaxHead(arr: Array[Int]): Array[Int] = arr.sortWith(_>_)\n    def sortValley(r: Array[Int],left: Array[Int],right: Array[Int]): Array[Array[Int]] = {\n      if(r.isEmpty)\n      { \n        return Array(left,right)\n      }\n      else \n      {\n        val sortedR = pullMaxHead(r)\n        if(left.length == right.length) sortValley(sortedR.tail,left++Array(sortedR.head),right)\n        else sortValley(sortedR.tail,left,right++Array(sortedR.head))\n      }\n    }\n    val valley = sortValley(a,Array(),Array())\n    valley(0)++valley(1).sortWith(_<_)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335026,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    val asorted = a.sorted\n    asorted.zipWithIndex\n      .filter(_._2 % 2 == (asorted.length+1) % 2)\n      .map(_._1)\n      .reverse ++ asorted.zipWithIndex.filter(_._2 % 2 == asorted.length % 2).map(_._1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335027,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n   if(a.length < 2) return a\n    val sorted = a.sorted\n    val isListEvenSize = a.length % 2 == 0\n    var i = 1;\n    var result = List(sorted(0))\n    if(isListEvenSize) {\n      while (result.length < a.length) {\n        if(i % 2 == 0){\n          result = result :+ sorted(i)\n        } else {\n          result = sorted(i) +: result\n        }\n        i += 1\n      }\n    } else {\n      while (result.length < a.length){\n        if(i % 2 == 0) {\n          result = sorted(i) +: result\n        } else {\n          result = result :+ sorted(i)\n        }\n        i += 1\n      }\n    }\n    result.toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335028,"user_id":null,"body":"import scala.collection.mutable\nobject Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n        val leftWing = mutable.Buffer.empty[Int]\n    val rightWing = mutable.Buffer.empty[Int]\n    val aSorted = a.sorted.reverse\n    for(i <- a.indices){\n      if(i%2 == 0) leftWing += aSorted(i) else rightWing += aSorted(i)\n    }\n    (leftWing ++ rightWing.reverse).toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335029,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    val z = a.sorted(Ordering.Int.reverse).zipWithIndex.map(x => (x._1,x._2%2))\n    z.filter(x=> x._2 ==0).map(_._1)++z.filter(x=> x._2 ==1).map(_._1).sorted\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335030,"user_id":53,"body":"object Valley {\n  def makeValley(a: Array[Int]): Array[Int] = {\n    var n = a.length\n    val ys: Array[Int] = Array.ofDim[Int](n)\n    var xs = a.clone\n    var j = n \/ 2\n    var i = 0\n    var dx = 1\n    if (n%2 == 0) {\n      dx *= -1\n    }\n    scala.util.Sorting.quickSort(xs)\n    while (i < n) {\n      ys(j) = xs(i)\n      j += dx\n      dx *= -1\n      if (dx > 0) {\n        dx += 1\n      } else {\n        dx -= 1\n      }\n      i += 1\n    }\n    ys\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335031,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    val sorted = a.sorted\n    val array = (0 to (a.length - a.length\/2) - 1).map(x => sorted(a.length - 1 - 2 * x)) ++ (0 to a.length \/ 2 - 1).map(x => sorted(a.length - 2 - 2 * x)).reverse\n    array.toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335032,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    val aSorted = a.sorted\n    val list = (0 to (a.length - a.length\/2)-1).map(x => aSorted(a.length - 1 - 2*x)) ++ (0 to a.length\/2 - 1).map(x => aSorted(a.length - 2 - 2*x)).reverse\n    list.toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335033,"user_id":null,"body":"object Valley {\n\n  def makeValley(a: Array[Int]): Array[Int] = {\n    val a1 = a.toList.sortWith(_ > _)\n    val leng = a1.length\n    \n    if (leng % 2 == 0) {\n      val ran = Seq.range(0, leng).toList\n      val evens = ran.filter(_ % 2 == 0)\n      val odds = ran.filter(_ % 2 != 0)\n      val left = evens.map(a1)\n      val right = odds.map(a1).sortWith(_ < _)\n      return (left++right).toArray\n    } else {\n      val ran = Seq.range(0, leng-1).toList\n      val (rest, las) = a1.splitAt(leng-1)\n      val evens = ran.filter(_ % 2 == 0)\n      val odds = ran.filter(_ % 2 != 0)\n      val left = evens.map(rest)\n      val right = odds.map(rest).sortWith(_ < _)\n      return ((left++las)++right).toArray\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56e7d40129035aed6c000632":[{"id":335034,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n\n    def easyLine(n: BigInt): BigInt = {\n        line(n).map(x => x * x).sum\n    }\n    \n    def line(n: BigInt): Seq[BigInt] = {\n      if (n == 0) Seq(1)\n      else {\n        val prevLine = line(n - 1)\n        (shift(prevLine, true) zip shift(prevLine, false)).map {\n          case (x: BigInt, y: BigInt) => x + y\n        }\n      }\n    }\n\n    def shift(s: Seq[BigInt], forward: Boolean): Seq[BigInt] = {\n      if(forward) Seq[BigInt](0) ++ s\n      else s ++ Seq[BigInt](0)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335035,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n\n  def easyLine(n: Int): BigInt = {\n    val prod: (Int, Int) => BigInt = (x, y) => (x to y).map(BigInt(_)).product\n    prod(n + 1, 2 * n) \/ prod(1, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335036,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n\n  @annotation.tailrec\n  def fact(n: Int, acc: BigInt = BigInt(1)): BigInt = {\n    if (n <= 1) acc\n    else fact(n - 1, acc * n)\n  }\n\n  def C(k: Int, n: Int): BigInt = {\n    fact(n) \/ (fact(k) * fact(n - k))\n  }\n\n  def easyLine(n: Int): BigInt = {\n    (0 to n)\n      .map(k => {\n        val ckn = C(k, n)\n        ckn * ckn\n      })\n      .sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335037,"user_id":1285,"body":"import scala.math.BigInt\nobject EasyLine {\n\n    def easyLine(n: Int): BigInt = {\n      def getPascalLine(num: Int, arr: Array[BigInt]): Array[BigInt] = {\n        val newArr = new Array[BigInt](arr.length + 1)\n\n        var i = 0\n        while (i <= arr.length) {\n          newArr(i) = if (i == 0 || i == arr.length) BigInt(\"1\") else arr(i - 1) + arr(i)\n          i += 1\n        }\n\n        if (num == n) newArr else getPascalLine(num + 1, newArr)\n      }\n      \n      val line = getPascalLine(0, new Array[BigInt](0))\n      \n      line.map(num => BigInt(num.toString) * BigInt(num.toString)).sum\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335038,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n\n  \n  def pascal(n:Int):Seq[BigInt]={\n    val triangle = for(i<-1 to (n+1))yield{\n        var c:BigInt=1L\n        (for(k<-1 to (i))yield{\n            c = (c * (i - k) \/ k)\n            c\n        })\n    }\n    triangle.last.toSeq\n  }\n\n def easyLine(n:Int):BigInt={\n    \n    pascal(n).map(x=>x*x).sum+1\n    \n }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335039,"user_id":null,"body":"import scala.math.BigInt\n\nobject EasyLine {\n  def easyLine(n: Int): BigInt = {\n    val m = BigInt(n)\n    (m + 1 to 2 * m).product \/ (BigInt(1) to m).product\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335040,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n  def easyLine(n: Int): BigInt = (1 to n).foldLeft(BigInt(1))((k, s) => k * (n + s) \/ s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335041,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n\n    def easyLine(n: Int): BigInt = {\n      var sum: BigInt = 1\n    for (i <- 1 to n) {\n      sum = sum * (n + i ) \/ i\n    }\n    return sum\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335042,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\ndef fac(n: Int):BigInt={\n    if(n==0) return 1 else n*fac(n-1);\n  }\n  def comb(n:Int, k: Int): BigInt={\n   return fac(n)\/(fac(k)*fac(n-k));\n  }\n  def easyLine(n: Int): BigInt = (0 to n).toList.map(k=>comb(n, k)*comb(n, k)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335043,"user_id":null,"body":"import scala.math.BigInt\nobject EasyLine {\n    def factorial(n: Int, list: List[BigInt] = List(BigInt(1))): List[BigInt] = {\n      if (list.length - 1 == n) {\n        list\n      } \n      else {\n        factorial(n, list ++ List(list.last * list.length))\n      }\n    }\n  \n    def easyLine(n: Int): BigInt = {\n      val factorials = factorial(n) \n      val wings = (0 to ((n.toDouble\/2).ceil.toInt) - 1).map(x => factorials(n)\/(factorials(x)*factorials(n-x))).map(x => x*x).sum*2\n      println(wings)\n      if (n % 2 == 0) {\n        val middle = factorials(n)\/(factorials(n\/2)*factorials(n - n\/2))\n        wings + middle*middle\n      }\n      else {\n        wings\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56eb0be52caf798c630013c0":[{"id":335044,"user_id":527,"body":"import java.time.{DayOfWeek, LocalDate, Month}\n\nobject Kata {\n  def unluckyDays(year: Int): Int = {\n    Month.values.count(LocalDate.of(year, _, 13).getDayOfWeek == DayOfWeek.FRIDAY)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335045,"user_id":null,"body":"object Kata {\n  \n  import java.time.{LocalDate}  \n\n  def unluckyDays(year: Int): Int = {\n    (1 to 12).filter(\n        month => LocalDate.of(year, month, 13).getDayOfWeek.name == \"FRIDAY\").length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335046,"user_id":null,"body":"object Kata {\n  def unluckyDays(year: Int): Int = {\n    def isLeapYear(y: Int): Boolean =\n      if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0)) true else false\n    \n    def getFirstWeekDay(currentYear: Int = 1, currentDay: Int = 1): Int = {\n      if (currentYear == year) currentDay\n      else\n        if (isLeapYear(currentYear)) getFirstWeekDay(currentYear + 1, (currentDay + 2) % 7)\n        else getFirstWeekDay(currentYear + 1, (currentDay + 1) % 7)\n    }\n    \n    def getWeekDays(): List[Int] = {\n      if (isLeapYear(year)) List(0, 3, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6)\n      else List(0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5)\n    }\n    \n    val firstWeekDay = getFirstWeekDay()\n    \n    getWeekDays().map(x => (x + firstWeekDay) % 7).count(x => x == 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335047,"user_id":null,"body":"import java.time.LocalDate\n\nobject Kata {\n\n  def unluckyDays(year: Int): Int = {\n    val firstDay = LocalDate.of(year, 1, 1)\n    if (firstDay.isLeapYear) {\n      List(2, 1, 2, 2, 1, 1, 3)(firstDay.getDayOfWeek.ordinal)\n    } else {\n      List(2, 2, 1, 3, 1, 1, 2)(firstDay.getDayOfWeek.ordinal)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335048,"user_id":575,"body":"import java.time._\n\nobject Kata {\n  def unluckyDays(year: Int): Int = {\n    (1 to 12).filter(m => LocalDate.of(year, m, 13).getDayOfWeek == DayOfWeek.FRIDAY).length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335049,"user_id":null,"body":"object Kata {\n\n  def leapYear(implicit year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\n  def daysIn(implicit year: Int): Int = {\n    if (leapYear) 366 else 365\n  }\n\n  def firstWeekdayOf(implicit year: Int): Int = {\n    val `2022` = 5\n    if (year == 2022) {\n      `2022`\n    } else if (year < 2022) {\n      ((`2022` -\n        (year until 2022)\n          .map(y => daysIn(y) % 7)\n          .sum) % 7 + 7) % 7\n    } else {\n      (`2022` +\n        (2023 until year)\n          .map(y => daysIn(y) % 7)\n          .sum + 1) % 7\n    }\n  }\n\n  def months(implicit year: Int) = List(\n    0 -> 31,\n    1 -> (if (leapYear) 29 else 28),\n    2 -> 31,\n    3 -> 30,\n    4 -> 31,\n    5 -> 30,\n    6 -> 31,\n    7 -> 31,\n    8 -> 30,\n    9 -> 31,\n    10 -> 30,\n    11 -> 31\n  )\n\n  def unluckyDays(implicit year: Int): Int = {\n    val jan13th = (firstWeekdayOf + 13 - 1) % 7\n    months\n      .map(_._2)\n      .init\n      .scanLeft(jan13th) { case (acc, next) =>\n        (acc + next) % 7\n      }\n      .count(_ == 4)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335050,"user_id":null,"body":"import java.time.{Month, LocalDate, DayOfWeek}\n\nobject Kata {\n  def unluckyDays(year: Int): Int = {\n    Month.values.count { LocalDate.of(year, _, 13).getDayOfWeek == DayOfWeek.FRIDAY }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335051,"user_id":null,"body":"object Kata {\n  import java.time.LocalDate\n  import java.time.format.DateTimeFormatter\n  \n  def unluckyDays(year: Int): Int = {\n    val df = DateTimeFormatter.ofPattern(\"dd\/MM\/yyyy\")\n    (1 to 12).map { m => \n                      if (m < 10) LocalDate.parse(s\"13\/0${m}\/${year}\", df)\n                      else LocalDate.parse(s\"13\/${m}\/${year}\", df)\n                  }.count(_.getDayOfWeek.getValue == 5)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335052,"user_id":null,"body":"import java.time.format.DateTimeFormatter\nimport java.time.LocalDate\n\nobject Kata {\n  def unluckyDays(year: Int): Int = {\n    val months = 1 to 12\n    val friday = \"FRIDAY\"\n    val yearAndDate = s\"$year-13-\"\n    val formatter = DateTimeFormatter.ofPattern(\"yyyy-dd-MM\")\n    months.map(x => yearAndDate + (if (x < 10) \"0\" + x else x))\n          .count(LocalDate.parse(_, formatter).getDayOfWeek.toString == friday)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335053,"user_id":null,"body":"import java.time._\n\nobject Kata {\n  def unluckyDays(year: Int): Int = {\n    return (1 to 12).map(i => isFriday(LocalDate.of(year, i, 13))).sum\n  }\n  \n  def isFriday(date: LocalDate): Int = {\n    if (date.getDayOfWeek() == DayOfWeek.FRIDAY) 1\n    else 0    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56eb16655250549e4b0013f4":[{"id":335054,"user_id":573,"body":"import java.time.LocalDate\n\nobject Kata {\n\n  def mostFrequentDays(year: Int): List[String] =\n    LazyList\n      .iterate(LocalDate.ofYearDay(year, 1))(_.plusDays(1))\n      .takeWhile(_.getYear == year)\n      .groupMapReduce(_.getDayOfWeek)(_ => 1)(_ + _)\n      .toList\n      .sorted\n      .collect { case (day, 53) => day.toString.toLowerCase.capitalize }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335055,"user_id":null,"body":"import java.time._, format._\n\nobject Kata {\n\n  def mostFrequentDays(year: Int): List[String] = {\n    val fmt = DateTimeFormatter.ofPattern(\"EEEE\")\n    val firstDate = LocalDate.of(year, 1, 1)\n    (0L until firstDate.lengthOfYear % 7)\n      .map(firstDate.getDayOfWeek.plus)\n      .sortBy(_.getValue)\n      .map(fmt.format(_))\n      .toList\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335056,"user_id":null,"body":"import java.time.LocalDate\nobject Kata {\n  val weekDays = List(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n  def mostFrequentDays(year: Int): List[String] = {\n    val firstDay = LocalDate.of(year, 1, 1)\n    val dayNum = firstDay.getDayOfWeek.ordinal\n    \n    (firstDay.isLeapYear, dayNum) match {\n      case (true, 6) => List(weekDays(0), weekDays(6))\n      case (true, _) => List(weekDays(dayNum), weekDays(dayNum + 1))\n      case _ => List(weekDays(dayNum))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335057,"user_id":null,"body":"object Kata {\n  def mostFrequentDays(year: Int): List[String] = {\n    import java.time.LocalDate._\n    val newYearDay = ofYearDay(year, 1)\n    (if (! newYearDay.isLeapYear) List(newYearDay) else List(newYearDay, newYearDay.plusDays(1)))\n      .map(_.getDayOfWeek).sorted.map(_.toString.toLowerCase.capitalize)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335058,"user_id":null,"body":"import java.time.{DayOfWeek, LocalDate}\n\nobject Kata {\n  def mostFrequentDays(year: Int): List[String] = {\n    val counter = daysCounter(\n      Map.empty[DayOfWeek, Int],\n      LocalDate.of(year + 1, 1, 1),\n      LocalDate.of(year, 1, 1)\n    )\n\n    val mostFrequentWeekdays: List[DayOfWeek] = counter.filter(_._2 == counter.values.max).keys.toList\n    DayOfWeek.values.toList.intersect(mostFrequentWeekdays).map(_.toString.toLowerCase.capitalize)\n  }\n\n  @scala.annotation.tailrec\n  private def daysCounter(counter: Map[DayOfWeek, Int], endOfYear: LocalDate, day: LocalDate): Map[DayOfWeek, Int] =\n    day match {\n      case `endOfYear` => counter\n      case _           =>\n        val dayOfWeek = day.getDayOfWeek\n        val newCount = counter.getOrElse(dayOfWeek, 0) + 1\n\n        val newCounter = counter + (dayOfWeek -> newCount)\n        daysCounter(newCounter, endOfYear, day.plusDays(1))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335059,"user_id":null,"body":"object Kata {\n\n  def leapYear(implicit year: Int): Boolean = {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n  }\n\n  def daysIn(implicit year: Int): Int = {\n    if (leapYear) 366 else 365\n  }\n\n  def firstWeekdayOf(implicit year: Int): Int = {\n    val `2022` = 5\n    if (year == 2022) {\n      `2022`\n    } else if (year < 2022) {\n      ((`2022` -\n        (year until 2022)\n          .map(y => daysIn(y) % 7)\n          .sum) % 7 + 7) % 7\n    } else {\n      (`2022` +\n        (2023 until year)\n          .map(y => daysIn(y) % 7)\n          .sum + 1) % 7\n    }\n  }\n\n  def weekNames = List(\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\"\n  )\n\n  def mostFrequentDays(implicit year: Int): List[String] = {\n    val first = firstWeekdayOf\n    val chart = (0 until daysIn)\n      .foldLeft(Map.empty[Int, Int]) { case (acc, next) =>\n        val nextDay = (first + next) % 7\n        acc.updatedWith(nextDay)(_.map(_ + 1).orElse(Some(1)))\n      }\n      .toList\n      .sortBy(t => -t._2)\n    chart\n      .takeWhile { case (w, c) =>\n        c == chart.head._2\n      }\n      .map(_._1)\n      .sorted\n      .map(weekNames)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335060,"user_id":null,"body":"import java.time.LocalDate\n\nobject Kata {\n  def mostFrequentDays(year: Int): List[String] = {\n    val date = LocalDate.of(year, 1, 1)\n\n    val days = if (date.isLeapYear) {\n      365\n    } else {\n      364\n    }\n\n    (0 to days)\n      .map(it => {\n        date.plusDays(it).getDayOfWeek\n      })\n      .groupBy(identity)\n      .map(it => (it._1, it._2.size))\n      .toList\n      .sortBy(_._2)\n      .reverse\n      .take(days - 363)\n      .sortBy(_._1.getValue)\n      .map(it => it._1.name().toLowerCase.capitalize)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335061,"user_id":null,"body":"import java.text.SimpleDateFormat\nimport java.util.{Calendar, GregorianCalendar}\n\nobject Kata {\n  def mostFrequentDays(year: Int): List[String] = {\n    val calendar = new GregorianCalendar()\n    val dowInt = new SimpleDateFormat(\"u\")\n\n    val dow = Array(\"\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n\n    calendar.set(Calendar.YEAR, year)\n    calendar.set(Calendar.MONTH, 1)\n    calendar.set(Calendar.DAY_OF_YEAR, 1)\n    calendar.add(Calendar.DAY_OF_YEAR, -1)\n\n    val days = if (calendar.isLeapYear(year)) {\n      366\n    } else {\n      365\n    }\n\n    val x = (1 to days)\n      .map(_ => {\n        calendar.add(Calendar.DATE, 1)\n        dowInt.format(calendar.getTime)\n      })\n      .groupBy(identity)\n      .map(it => (it._1, it._2.size))\n      .toArray\n      .sortBy(_._2)\n      .reverse\n      .take(days - 364)\n      .sortBy(_._1)\n      .map(it => dow(it._1.toInt))\n      .toList\n\n    x\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335062,"user_id":null,"body":"import java.time.DayOfWeek\nimport java.time.LocalDate\nimport java.time.Year\n\nobject Kata {\n  def dayString(day: DayOfWeek): String = day.toString.toLowerCase.capitalize\n  def mostFrequentDays(year: Int): List[String] = {\n    val date = LocalDate.parse(String.format(\"%d-01-01\", year))\n    val day = DayOfWeek.from(date)\n    if (Year.isLeap(year)) {\n      List(day, day.plus(1)).sorted.map(dayString)\n    } else {\n      List(dayString(day))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335063,"user_id":null,"body":"import java.time.LocalDate\n\nobject Kata {\n  def mostFrequentDays(year: Int): List[String] = {\n    val eoy = LocalDate.parse(s\"$year-12-31\")\n\n    if (eoy.getDayOfYear%7 == 1) List(eoy.getDayOfWeek.toString.toLowerCase.capitalize)\n    else if (eoy.getDayOfWeek.toString == \"MONDAY\") List(\"Monday\",\"Sunday\")\n    else List(eoy.minusDays(1).getDayOfWeek.toString.toLowerCase.capitalize,eoy.getDayOfWeek.toString.toLowerCase.capitalize)\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56ed20a2c4e5d69155000301":[{"id":335064,"user_id":573,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String =\n    xs.lines.flatMap(w => List.fill(n)(w.map(_.toString * k).mkString)).mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335065,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String = {\n    if(xs.length == 0) \"\"\n  else xs.split(\"\n\").flatMap(line => List.fill(n)\n                              (line.map(charat => charat.toString * k)\n                               .mkString)).mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335066,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, horizontal: Int, vertical: Int): String = {\n    \n    if(xs.length == 0)\"\"\n    \n    else xs.split(\"\n\").map(word => horzString(word,horizontal))\n    .map( st => vertString(st,vertical))\n    .mkString.dropRight(1)\n  }\n  \n  \n  \n  def horzString(chunk:String, spacer:Int):String =\n  {\n    chunk.split(\"\").map( ch => ch.toString * spacer).mkString\n  }\n  \n  def vertString(chunk:String,spacer:Int):String = \n  {\n    \n    def helper(acc:String, index:Int):String = \n    {\n      if(index == 0) acc\n      else helper(acc + chunk+\"\n\",index-1)\n    }\n    helper(\"\",spacer)\n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335067,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String = {\n    val parts = xs.split(\"\n\").toSeq\n    parts.flatMap(p => {\n      val scaled = p.flatMap(c => c.toString * k)\n      List.fill(n)(scaled)\n    })\n    .mkString(\"\n\").trim\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335068,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String = if (xs.length > 0) xs.split(\"\\\n\")\n                                                                       .toList.map(e=>(e.split(\"\")\n                                                                                        .toList\n                                                                                        .map(x=>x*k)\n                                                                                        .mkString(\"\")+\"\n\")*n)\n                                                                                        .mkString(\"\")\n                                                                                        .dropRight(1) else \"\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335069,"user_id":null,"body":"object Kata {\n\ndef scale(xs: String, k: Int, v: Int): String = {\n  if (xs == \"\"){ return \"\" }\n  val lines = xs.split(\"\n\")\n  val answer = lines.map { x =>\n    val t = (x.flatMap{y => y.toString() * k} + \"\n\") * v\n    t\n  }.mkString(\"\").stripLineEnd\n  answer\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335070,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String = \n      xs.replaceAll(\"\n\",\"~\").map(x => s\"$x\"*k).mkString(\"\")\n        .split(\"~\"*k).flatMap(y => if(y != \"\") List.fill(n)(y) else List(\"\"))\n        .mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335071,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String = \n  xs.split(\"\n\").map(x => (x+\"#\")*n).map(p => p.split(\"\").map(x => x*k).mkString(\"\")).mkString(\"\").replace(\"#\"*k, \"\n\").trim\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335072,"user_id":null,"body":"object Kata {\n  def scale(xs: String, k: Int, n: Int): String = {\n    if (xs == \"\") \"\"\n    else xs.split(\"\n\").flatMap(w => List.fill(n)(w.map(_.toString * k).mkString)).mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335073,"user_id":null,"body":"object Kata {\n\n  def scale(xs: String, k: Int, n: Int): String = {\n    if (xs.isEmpty) \"\"\n    else {\n      xs.split(\"\n\").map { _.map { _.toString * k }.mkString + \"\n\" }\n        .map( z => z * n).mkString.init\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56efab15740d301ab40002ee":[{"id":335074,"user_id":492,"body":"object Operarray {\n\n  def gcdi(xx: Long, yy: Long): Long = {\n    var x = Math.abs(xx)\n    var y = Math.abs(yy)\n    while (y != 0) {\n      var tmp: Long = x\n      x = y\n      y = tmp % y\n    }\n    x\n  }\n  def lcmu(a: Long, b: Long): Long = Math.abs(a * b) \/ gcdi(a, b)\n  def som(a: Long, b: Long): Long = a + b\n  def maxi(a: Long, b: Long): Long = Math.max(a, b)\n  def mini(a: Long, b: Long): Long = Math.min(a, b)\n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n    arr.scanLeft(init)((a, b) => f(a, b)).tail\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335075,"user_id":null,"body":"object Operarray {\n\n  def gcdi(a: Long, b: Long): Long = {\n    if (b == 0) math.abs(a) \n    else gcdi(b, a % b)\n  }\n  def lcmu(a: Long, b: Long): Long = math.abs(a * b) \/ gcdi(a, b)\n  def som(a: Long, b: Long): Long = a + b\n  def maxi(a: Long, b: Long): Long = math.max(a, b)\n  def mini(a: Long, b: Long): Long = math.min(a, b)\n  \n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = arr match {\n    case List(x) => List(f(x, init))\n    case x :: xs => \n      val res = f(x, init)\n      res :: operArray(f, xs, res)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335076,"user_id":null,"body":"object Operarray {\n\n  def gcdi(xx: Long, yy: Long): Long = {\n    if(yy==0) math.abs(xx) else gcdi(yy, xx%yy)\n  }\n  def lcmu(a: Long, b: Long): Long = math.abs(a*b)\/gcdi(a,b)\n  def som(a: Long, b: Long): Long = a+b\n  def maxi(a: Long, b: Long): Long = math.max(a,b)\n  def mini(a: Long, b: Long): Long = math.min(a,b)\n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n    def re(arr:List[Long],init:Long,l:List[Long]):List[Long]=arr match{\n      case Nil => List()\n      case x::Nil => f(x,init)::l\n      case x::xs => re(xs,f(x,init),f(x,init)::l)\n    }\n    re(arr,init,List()).reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335077,"user_id":null,"body":"object Operarray {\n\n  def gcdi(xx: Long, yy: Long): Long = {\n    val a = xx.abs\n    val b = yy.abs\n    val c = mini(a,b)\n    val d = maxi(a,b)\n    \n    if (d % c == 0) c else gcdi(c, d % c)\n  }\n  def lcmu(a: Long, b: Long): Long = a.abs*b.abs\/gcdi(a,b)\n  def som(a: Long, b: Long): Long = a + b\n  def maxi(a: Long, b: Long): Long = if (a > b) a else b\n  def mini(a: Long, b: Long): Long = if (a > b) b else a\n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n    if (arr.size == 1) List(f(init, arr.head))\n    else {\n      val x = f(init, arr.head)\n      List(x) ++ operArray(f, arr.tail, x)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335078,"user_id":null,"body":"object Operarray {\n\n  @annotation.tailrec\n  def gcdi(xx: Long, yy: Long): Long = {\n    val x = xx.abs\n    val y = yy.abs\n    if (x == 0) y\n    else if (y == 0) x\n    else if (x < y)\n      gcdi(x, y % x)\n    else gcdi(x % y, y)\n  }\n  def lcmu(a: Long, b: Long): Long = (a.abs * b.abs) \/ gcdi(a, b) \/\/ your code\n  def som(a: Long, b: Long): Long = a + b \/\/ your code\n  def maxi(a: Long, b: Long): Long = a.max(b) \/\/ your code\n  def mini(a: Long, b: Long): Long = a.min(b) \/\/ your code\n  def operArray(\n      f: (Long, Long) => Long,\n      arr: List[Long],\n      init: Long\n  ): List[Long] = {\n    \/\/ your code\n    arr.scanLeft(init)(f).tail\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335079,"user_id":null,"body":"object Operarray {\n\n  def gcdi(xx: Long, yy: Long): Long = {\n     if (xx<0 | yy<0) gcdi(math.abs(xx), math.abs(yy)) else {\n      if (xx==yy) xx\n      else {\n        if (xx>yy) gcdi(xx-yy,yy) else gcdi(xx,yy-xx)\n      }\n    }\n  }\n  def lcmu(a: Long, b: Long): Long = math.abs(a*b)\/gcdi(a,b) \/\/ your code\n  def som(a: Long, b: Long): Long = a+b\n  def maxi(a: Long, b: Long): Long = a.max(b) \n  def mini(a: Long, b: Long): Long = a.min(b)\n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n   def iter(l: List[Long], current:Long): List[Long] = l match {\n     case Nil => Nil\n     case x::t => val next = f(current, x); next::iter(t,next)\n   }\n    iter(arr, init)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335080,"user_id":null,"body":"object Operarray {\n\n    import scala.math.abs\n\n    def gcdi(xx: Long, yy: Long): Long = yy match {\n      case 0 => abs(xx)\n      case _ => gcdi(abs(yy), xx % yy)\n    }\n    def lcmu(a: Long, b: Long): Long =  abs((a * b)) \/ gcdi(a ,b)\n    def som(a: Long, b: Long): Long = a + b\n    def maxi(a: Long, b: Long): Long = List(a, b).max\n    def mini(a: Long, b: Long): Long = List(a, b).min\n    def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n      arr.scanLeft(init)((acc, x) => f(acc, x)).tail\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335081,"user_id":null,"body":"object Operarray {\n\n  def gcdi(xx: Long, yy: Long): Long = if (yy == 0) xx.abs else gcdi(yy.abs, xx.abs % yy.abs)\n  def lcmu(a: Long, b: Long): Long = (a*b).abs\/gcdi(a,b)\n  def som(a: Long, b: Long): Long = a + b\n  def maxi(a: Long, b: Long): Long = math.max(a, b)\n  def mini(a: Long, b: Long): Long = math.min(a, b)\n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = arr.scanLeft(init)(f).tail\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335082,"user_id":null,"body":"object Operarray {\n\n  def gcdi(xx: Long, yy: Long): Long = {\n    val x = maxi(xx.abs, yy.abs)\n    val y = mini(xx.abs,yy.abs)\n    if (x%y == 0) y else gcdi(y, x%y)\n  }\n  def lcmu(a: Long, b: Long): Long = (a*b).abs \/ gcdi(a,b)\n  def som(a: Long, b: Long): Long = a+b\n  def maxi(a: Long, b: Long): Long = if (a>b) a else b\n  def mini(a: Long, b: Long): Long = a+b-maxi(a,b)\n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n    if (arr.size < 2) List(f(init, arr(0))) else List(f(init, arr(0))) :++ operArray(f, arr.tail, f(init, arr(0)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335083,"user_id":null,"body":"object Operarray {\n\n  def abs(value: Long): Long = {\n    if (value < 0) -value else value\n  }\n  \n  def gcd(a: Long, b: Long): Long = {\n    def helper(divisor: Long): Long = {\n      if (a % divisor + b % divisor == 0) divisor\n      else helper(divisor - 1)\n    }\n    helper(mini(a,b))\n  }\n  \n  def lcm(a: Long, b: Long): Long = {\n    abs(a * b) \/ gcd(a, b)\n  }\n  def gcdi(a: Long, b: Long): Long = {\n     gcd(abs(b), abs(a))\n  }\n  \n  def lcmu(a: Long, b: Long): Long = {\n    lcm(abs(a), abs(b))\n  }\n  \n  def som(a: Long, b: Long): Long = {\n    a + b\n  }\n  \n  def maxi(a: Long, b: Long): Long = {\n    if (a > b) a else b\n  }\n  \n  def mini(a: Long, b: Long): Long = {\n    if (a > b) b else a\n  }\n  \n  def operArray(f: (Long, Long) => Long, arr: List[Long], init: Long): List[Long] = {\n    def ownMap(item: Long, currentInit: Long, currentArr: List[Long]): List[Long] = {\n      if (currentArr.isEmpty) f(item, currentInit) :: List()\n      else f(item, currentInit) :: ownMap(currentArr.head, f(item, currentInit), currentArr.tail)\n    }\n    ownMap(arr.head, init, arr.tail)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56eff1e64794404a720002d2":[{"id":335084,"user_id":null,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int = {\n    \"w.*?o.*?r.*?d\".r.findAllIn(s.toLowerCase).length\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335085,"user_id":527,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int = re.findAllIn(s).size\n  val re = \"(?i)w.*?o.*?r.*?d\".r\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335086,"user_id":null,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int = {\n    var i = 0 \n    for (c <- s.toLowerCase)\n      if (c==\"word\"(i%4)) i+=1\n    i\/4\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335087,"user_id":573,"body":"object ThinkingAndTesting {\n\n  def testit(str: String): Int =\n    val next = \"word\".zip(\"ordw\").toMap\n    str.toLowerCase().foldLeft('w', 0) {\n      case ((x, acc), c) if c == x => (next(x), acc + 1)\n      case (acc, _)                => acc\n    }._2 \/ 4\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335088,"user_id":null,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int = {\n    val word = \"word\"\n    var cur = 0\n    var counter = 0\n    \n    for c <- s do    \n      if c.toLower == word.charAt(cur) then\n        cur += 1\n    \n        if cur > 3 then\n          cur = 0\n          counter += 1\n    \n    counter\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335089,"user_id":null,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int =\n    def count(s: String, w: String = \"word\", c: Int = 0): Int =\n      if w.isEmpty then count(s, \"word\", c + 1)\n      else if s.isEmpty then c\n      else if s.head == w.head then count(s.tail, w.tail, c)\n      else count(s.tail, w, c)\n    count(s.toLowerCase)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335090,"user_id":50,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int = (\"w.*?o.*?r.*?d\".r).findAllIn(s.toLowerCase()).size\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335091,"user_id":null,"body":"object ThinkingAndTesting {\n  def testit(s: String): Int = {\n    var count = 0\n    var word = \"word\"\n    var j = 0\n    for (i <- 0 until s.length) {\n      if (s(i).toLower.equals(word(j))) {\n        j += 1\n      }\n      if (j == word.length) {\n        j = 0\n        count += 1\n      }\n    }\n    count\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335092,"user_id":null,"body":"object ThinkingAndTesting {\n  def words(s: String): Int = {\n    val wIndex = s.indexOf('w')\n    if (wIndex != -1) {\n      val withW = s.drop(wIndex)\n      val oIndex = withW.indexOf('o')\n      if (oIndex != -1) {\n        val withO = withW.drop(oIndex)\n        val rIndex = withO.indexOf('r')\n        if (rIndex != -1) {\n          val withR = withO.drop(rIndex)\n          val dIndex = withR.indexOf('d')\n          if (dIndex != -1) {\n            1 + words(withR.drop(dIndex))\n          }\n          else {\n            0\n          }\n        }\n        else {\n          0\n        }\n      }\n      else {\n        0\n      }\n    }\n    else {\n      0\n    }\n  }\n  \n  def testit(s: String): Int = words(s.toLowerCase)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335093,"user_id":null,"body":"object ThinkingAndTesting {\n  \n  def testit(s: String): Int = {\n\n  s.toLowerCase\n    .filter(c => c == 'w' || c == 'o' || c == 'r' || c == 'd')\n    .foldLeft((\"\", '!')) {\n      case ((list, '!'), 'w') => (list + \",w\" , 'w')\n      case ((list, 'w'), 'o') => (list + \"o\", 'o')\n      case ((list, 'o'), 'r') => (list + \"r\", 'r')\n      case ((list, 'r'), 'd') => (list + \"d,\", '!')\n      case ((list, last), elem) => (list, last)\n    }._1.split(\",\").count(_ == \"word\")\n}\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56f253dd75e340ff670002ac":[{"id":335094,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    val listS1 = s1.split(\"\n\")\n    val listS2 = s2.split(\"\n\").reverse\n    \n    listS1\n      .zip(listS2)\n      .zipWithIndex\n      .collect {\n        case ((a, b), i) => a.take(i + 1) + b.dropRight(i)\n      }\n      .mkString(\"\n\")\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335095,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    val a = s1.split(\"\n\").toSeq\n    val b = s2.split(\"\n\").toSeq\n    a.zip(b.reverse).zipWithIndex.map {\n      case ((fst, snd), i) => fst.take(i+1) + snd.take(snd.length-i)\n    }\n    .mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335096,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    val arr1 = s1.split(\"\n\").zipWithIndex.map(x => x._1.substring(0,x._2 + 1))\n    val arr2 = s2.split(\"\n\").zipWithIndex.reverse.map(x => x._1.substring(0,x._2 + 1))\n    arr1.zip(arr2).map(x => x._1 + x._2).mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335097,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    s1.split(\"\n\")\n      .zip(s2.split(\"\n\").reverse)\n      .zipWithIndex\n      .collect { \n        case ((s1_part, s2_part), i) => s1_part.take(i + 1) + s2_part.dropRight(i)\n      }\n      .mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335098,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    var l1 = s1.split(\"\n\");\n    var l2 = s2.split(\"\n\");\n    var sol = \"\";\n    var maxlength = l1.size-1;\n    for( i <- 0 to maxlength){\n      sol = sol + l1(i).substring(0,i+1);\n      sol = sol + l2(maxlength-i).substring(0,maxlength-i+1);\n      if(i != maxlength){\n        sol = sol.concat(\"\n\");\n        }\n    }\n    sol\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335099,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    val line1 = s1.split('\n')\n    val line2 = s2.split('\n')\n    (1 to line1.length).map(x => line1(x-1).take(x) + line2(line2.length - x).take(line2.length - x + 1)).mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335100,"user_id":null,"body":"\/*object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    \/\/ your code\n  }\n}*\/\n\nobject Composing {\n\n  \ndef compose(s1: String, s2: String): String = {\n  val listS1 = s1.split(\"\n\")\n    val listS2 = s2.split(\"\n\").reverse\n    \n    listS1\n      .zip(listS2)\n      .zipWithIndex\n      .collect {\n        case ((a, b), i) => a.take(i + 1) + b.dropRight(i)\n      }\n      .mkString(\"\n\")\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335101,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    val string1 = s1.split(\"\n\")\n    val string2 = s2.split(\"\n\").reverse\n    val strlength = string1.length\n    (0 until strlength).map(i => string1(i).take(i + 1) + string2(i).take(strlength - i)).mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335102,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = {\n    val l1 = s1.split('\n')\n    val l2 = s2.split('\n')\n    (1 to l1.length).map(x => l1(x-1).take(x) + l2(l2.length - x).take(l2.length - x + 1)).mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335103,"user_id":null,"body":"object Composing {\n\n  def compose(s1: String, s2: String): String = \n    s1.split(\"\n\").\n    zip(s2.split(\"\n\").reverse).\n    zipWithIndex.\n    map(x => x._1._1.take(x._2+1) + x._1._2.dropRight(x._2)).\n    mkString(\"\n\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56f3a1e899b386da78000732":[{"id":335104,"user_id":573,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] =\n    List.range(1, xs.size).map(i => (xs.take(i).mkString(\" \"), xs.drop(i).mkString(\" \")))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335105,"user_id":null,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] = {\n    def t(l: List[String], r: List[String], main: List[(String, String)]): List[(String, String)] = {\n      if (r.length > 1)\n        t(l ::: List(r.head), r.tail,\n          main ::: List((\n            (l ::: List(r.head)).mkString(\" \"),\n            r.tail.mkString(\" \")\n          ))\n        )\n      else main\n    }\n    t(List.empty, xs, List.empty)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335106,"user_id":527,"body":"object Kata {\n  def partList(xs: List[String]): List[(String, String)] =\n    (1 until xs.length)\n      .map(i => xs.splitAt(i) match { case (x, y) => (x.mkString(\" \"), y.mkString(\" \")) })\n      .toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335107,"user_id":null,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] = (1 until xs.length).map(n => (xs.take(n).mkString(\" \"), xs.drop(n).mkString(\" \"))).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335108,"user_id":null,"body":"object Kata {\n  def partList(xs: List[String]): List[(String, String)] = {\n    var answer = List((\"code\", \"wars\"))\n    var i: Int = 1\n    while (i!=xs.length) {\n      val left = xs.take(i)\n      var first = \"\"\n      for (item <- left) { first += item + \" \" }\n      val right = xs.drop(i)\n      var second = \"\"\n      for (item <- right) { second += item + \" \" }\n      val tmp = (first.trim(), second.trim())\n      answer = answer :+ tmp\n      i += 1\n    }\n    return answer.drop(1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335109,"user_id":null,"body":"object Kata {\n  def partList(xs: List[String]): List[(String, String)] = xs.take(xs.size-1).zipWithIndex.map(e => (xs.take(e._2+1).mkString(\" \"), xs.drop(e._2+1).mkString(\" \")))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335110,"user_id":null,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] = xs.slice(0,xs.size-1)\n                                                             .zipWithIndex\n                                                             .map(e => Tuple2(xs.slice(0, e._2+1).mkString(\" \"), \n                                                                               xs.slice(e._2+1, xs.size).mkString(\" \")))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335111,"user_id":null,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] = {\n    (1 until xs.size).map { i =>\n      (xs.slice(0, i).mkString(\" \"), xs.slice(i, xs.size).mkString(\" \"))\n    }.toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335112,"user_id":626,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] =\n    (1 until xs.length).map { i =>\n      val head = xs.dropRight(xs.length - i).mkString(\" \")\n      val tail = xs.drop(i).mkString(\" \")\n      (head, tail)\n    }.toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335113,"user_id":null,"body":"object Kata {\n\n  def partList(xs: List[String]): List[(String, String)] = \n    for(i <- List.range(1,xs.size))\n        yield (xs.take(i).mkString(\" \"), xs.drop(i).mkString(\" \"))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56f699cd9400f5b7d8000b55":[{"id":335114,"user_id":1228,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n         arr.reverse\n      }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335115,"user_id":527,"body":"object Lists {\n  def fix_the_meerkat(xs: Seq[String]): Seq[String] = xs match {\n    case List(x, y, z) => List(z, y, x)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335116,"user_id":null,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n        List(arr(2),arr(1),arr(0))\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335117,"user_id":null,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n        List(arr.last) ::: arr.slice(1, arr.length - 1) ::: List(arr.head)\n\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335118,"user_id":null,"body":"object Lists {\n\n  def fix_the_meerkat(l: Seq[String]): Seq[String] =\n    l.reverse\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335119,"user_id":null,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n        \/\/if(arr==(\"head\",\"body\",\"tail\"))\n        \/\/true\n        \/\/else\n        \/\/val agg=arr.updated(0,\"head\")\n        \/\/val agg=arr.updated(1\"body\")\n        \/\/val agg=arr.updated(2,\"tail\")\n        \/\/agg\n        \n        arr.reverse\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335120,"user_id":null,"body":"object Lists {\n  def fix_the_meerkat(arr: Seq[String]): Seq[String] = (arr(arr.size - 1) +: arr.slice(1, arr.size - 1) :+ arr.head)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335121,"user_id":null,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n        \/\/ your code here\n        arr.reverse\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335122,"user_id":null,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n        \/\/ your code here\n        arr match {\n          case List(t, b, h) => List(h, b, t)\n        }\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335123,"user_id":null,"body":"object Lists {\n\n      def fix_the_meerkat(arr: Seq[String]): Seq[String] = {\n        arr match {\n          case List(tail, body, head) => List(head, body, tail)\n          case _ => arr\n        }\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56fcc393c5957c666900024d":[{"id":335124,"user_id":1285,"body":"import scala.collection.mutable\n\nobject Opstrings {\n\n  def rotateClockwise(n: Int, arr: Array[Array[Char]]): Array[Array[Char]] = {\n    val arr2: Array[Array[Char]] = Array.fill(n){new Array[Char](n)}\n    var row = 0\n    var col = 0\n    while (row < n) {\n      arr2(col)(n - 1 - row) = arr(row)(col)\n\n      col += 1\n      if (col == n) {\n        col = 0\n        row += 1\n      }\n    }\n    arr2\n  }\n\n  def rotateCounterClockwise(n: Int, arr: Array[Array[Char]]): Array[Array[Char]] = {\n    val arr2: Array[Array[Char]] = Array.fill(n){new Array[Char](n)}\n    var row = 0\n    var col = 0\n    while (row < n) {\n      arr2(row)(col) = arr(col)(n - 1 - row)\n\n      col += 1\n      if (col == n) {\n        col = 0\n        row += 1\n      }\n    }\n    arr2\n  }\n\n  def code(s: String): String = {\n    if (s.length == 0) return s\n    println(\"CODE: \" + s)\n    var root = Math.sqrt(s.length).toInt\n    if (root * root < s.length) {\n      root += 1\n    }\n    val sb = new mutable.StringBuilder(s)\n    val charsToAdd: Int = root * root - s.length\n    var i = 0\n    while (i < charsToAdd) {\n      sb.append(11.toChar)\n      i += 1\n    }\n\n    val chars: Array[Char] = sb.toArray\n    val arr: Array[Array[Char]] = Array.fill(root){new Array[Char](root)}\n    var row = 0\n    var col = 0\n    i = 0\n    while (row < root) {\n      arr(row)(col) = chars(i)\n\n      i += 1\n      col += 1\n      if (col == root) {\n        col = 0\n        row += 1\n      }\n    }\n    val arr2 = rotateClockwise(root, arr)\n    arr2.zipWithIndex.flatMap(a => a._1.mkString + (if (a._2 < root - 1) \"\\n\" else \"\")).mkString\n  }\n\n  def decode(s: String): String = {\n    if (s.length == 0) return s\n    val arr = s.split(\"\\n\").map(_.toCharArray)\n    val root = arr.length\n    val arr2 = rotateCounterClockwise(root, arr)\n    arr2.flatMap(_.mkString).mkString.replace(11.toChar.toString, \"\")\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:58:29"},{"id":335125,"user_id":null,"body":"object Opstrings {\n\n  def code(s: String): String = {\n    val n = math.sqrt(s.length.toFloat).ceil.toInt\n    val fillTxt = s + \"\\u000b\" * (n * n - s.length)\n    var codeTxt = \"\"\n\n    for { col <- 0 to n - 1\n          row <- n - 1 to 0 by -1\n        } codeTxt += fillTxt(row * n + col)\n\n    if (!codeTxt.isEmpty) codeTxt.sliding(n, n).map(_ + \"\\n\").mkString(\"\").dropRight(1) else \"\"\n  }\n\n  def decode(s: String): String = {\n    val n = s.takeWhile(_ != '\\n').length\n    val codeTxt = s.filter(_ != '\\n')\n    var clearTxt = \"\"\n\n    for { col <- n - 1 to 0 by -1\n          row <- 0 to n - 1\n        } clearTxt += codeTxt(row * n + col)\n\n    clearTxt.filter(_ != '\\u000b')\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335126,"user_id":null,"body":"import Math.{ceil, sqrt}\n\nobject Opstrings {\n  \n  def rot90Clock(s: String, root: Int): String = s.grouped(root).map(_.toArray).toList.transpose.map(_.reverse.mkString).mkString(\"\\n\")\n\n  def code(s: String): String = {\n    val root = ceil(sqrt(s.length)).toInt\n    rot90Clock(s + (11).toChar.toString * (root * root - s.length), root)\n  }\n\n  def decode(s: String): String = {\n    s.split(\"\\n\").map(_.toArray).transpose.reverse.map(_.mkString).mkString.takeWhile(_ != (11).toChar)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335127,"user_id":null,"body":"object Opstrings {\n\n  val t = (11).toChar.toString\n  \n  def code(s: String): String = {\n    val n = math.ceil(math.sqrt(s.length)).toInt \n    val n2 = n*n\n    val s1 = s.concat(t * (n2 - s.length))\n    val s2 = s1.grouped(n).toList\n    (0 to s2.length - 1).map(x => s2.map(y => y(x)).mkString(\"\").reverse).mkString(\"\\n\")\n  }\n\n  def decode(s: String): String = {\n    if (s == \"\") {\n      \"\"\n    }\n    else {\n      val lines = s.split(\"\\n\").toList\n      val s1 = (0 to lines.length-1).toList.reverse.flatMap(x => lines.map(y => y(x))).mkString(\"\")\n      val i = s1.indexOf(t)\n      if (i == -1) s1\n      else s1.take(i) \n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335128,"user_id":null,"body":"object Opstrings {\n  \n  def diag1Sym(s : String) : String = {\n    val words = s.split(\"\\n\")\n    var output = \"\"\n    for (i <- 0 until words.length) {\n      if (i != 0) {\n        output+=\"\\n\"\n      }\n      for (j <- 0 until words(i).length) {\n        output+=words(j)(i)\n      }\n    }\n    output\n  }\n\n  def rot90Clock(s : String) : String = {\n    val output = diag1Sym(s)\n    output.split(\"\\n\").map(f => f.reverse).mkString(\"\\n\")\n  }\n  \n  def diag2Sym(input : String): String = {\n    val splits = input.split(\"\\n\")\n    var output = \"\"\n    for (i <- splits.length-1 to 0 by -1) {\n      if (i != splits.length-1) {\n        output += \"\\n\"\n      }\n      for (j <- splits(i).length-1 to 0 by -1) {\n        output += splits(j)(i)\n      }\n    }\n    output\n  }\n\n  def rot90Counter(input : String) : String = {\n    diag2Sym(input).split(\"\\n\").map(f => f.reverse).mkString(\"\\n\")\n  }\n\n  def code(string : String) : String = {\n    if (string.length == 0) {\n      return \"\"\n    }\n    val stringLength = string.length\n    val squaredLength = math.ceil(math.sqrt(stringLength)).toInt\n    val charToAdd : Char = 11\n    var editableString = string\n    while(editableString.length != squaredLength*squaredLength) {\n      editableString += charToAdd\n    }\n    editableString = editableString.toCharArray.sliding(squaredLength, squaredLength).map(f => String.valueOf(f)).mkString(\"\\n\")\n    rot90Clock(editableString)\n  }\n\n  def decode(string: String): String = {\n    if (string.length == 0) {\n      return \"\"\n    }\n    val replaceThisOne : Char = 11\n    rot90Counter(string).split(\"\\n\").mkString(\"\").replaceAll(String.valueOf(replaceThisOne), \"\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335129,"user_id":null,"body":"object Opstrings {\n\n  def code(s: String): String = {\n    val n = Math.sqrt(s.length).ceil.toInt\n    val buf = s.padTo(n*n, 11.toChar)\n    (0 until n).map(i => {\n      (0 until n).map(j => {\n        buf(n*(n-1-j)+i)\n      }).mkString(\"\")\n    }).mkString(\"\\n\")\n  }\n\n  def decode(s: String): String = {\n    val buf = s.replaceAll(\"\\n\", \"\")\n    val n = Math.sqrt(buf.length).toInt\n    (0 until n*n).map(k => {\n      val j = k \/ n\n      val i = n * (j + 1) - k - 1\n      println(k, buf(i * n + j))\n      buf(i * n + j)\n    }).filterNot(_ == 11.toChar).mkString(\"\").reverse\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335130,"user_id":null,"body":"object Opstrings {\n\n  val pad = '\\u000b'\n  \n  def code(s: String): String = {\n    if ( s.length < 2 ) s else {\n      val n = math.sqrt(s.length).ceil.toInt\n      s.padTo(n * n, pad)\n        .toSeq.sliding(n,n)\n        .map(_.unwrap)\n        .toList\n        .map(p => p.toList)\n        .transpose\n        .map(_.mkString)\n        .map(_.reverse)\n        .mkString(\"\\n\")\n    }\n  }\n\n  def decode(s: String): String = {\n    if ( s.length < 2 ) s else {\n      s.split(\"\\n\").map(_.reverse.toList).toList.transpose.map(_.mkString).mkString.replaceAll(pad.toString, \"\")\n    }\n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335131,"user_id":null,"body":"object Opstrings {\n\n def code(s: String): String = {\n    val l = s.length\n    val n = math.sqrt(l).ceil.toInt\n    (s + 11.toChar.toString * (n*n - l)).grouped(n).toArray.\n      map(_.toCharArray).reverse.transpose.map(_.mkString).mkString(\"\\n\")\n  }\n\n\n  def decode(s: String): String =\n    s.split(\"\\n\").map(_.toCharArray).transpose.\n      reverse.flatten.mkString.takeWhile(_ != 11.toChar)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335132,"user_id":null,"body":"object Opstrings {\n  private val t: Char = '\\u000b'\n\n  def code(s: String): String =\n    if (s.isEmpty) {\n      s\n    } else {\n      val size   = math.sqrt(s.length).ceil.toInt\n      val matrix = s.padTo(size * size, t).grouped(size).toIndexedSeq\n      (0 until size).map(i => (0 until size).map(j => matrix(size - 1 - j)(i)).mkString).mkString(\"\\n\")\n    }\n\n  def decode(s: String): String =\n    if (s.isEmpty) {\n      s\n    } else {\n      val matrix = s.split(\"\\n\")\n      val size   = matrix.length\n      (0 until size)\n        .map(i => (0 until size).map(j => matrix(j)(size - 1 - i)).mkString)\n        .mkString\n        .replace(t.toString, \"\")\n    }\n\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":335133,"user_id":null,"body":"object Opstrings {\n\n  def code(s: String): String = {\n    val n = math.ceil(math.sqrt(s.size)).toInt\n    s.padTo(math.pow(n, 2).toInt, 11.toChar).grouped(n).toList.transpose.map(_.reverse).map(_.mkString).mkString(\"\\n\")\n  }\n\n  def decode(s: String): String = {\n    s.split(\"\\n\").toList.map(_.reverse).transpose.map(_.mkString).mkString.reverse.dropWhile(_ == 11.toChar).reverse\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"}],"56fe17fcc25bf3e19a000292":[{"id":335134,"user_id":492,"body":"object Disguised {\n  \n    def uEff(n: Int, p: Int): BigInt = {\n        BigInt(p) * BigInt(n+1)\n    }\n    def vEff(n: Int, p: Int): BigInt = {\n        BigInt(p) * BigInt(2*n+1)\n    }\n\n    def u1(n: Int, p: Int): BigInt = {\n        BigInt(p) * BigInt(n+1)\n    }\n    def v1(n: Int, p: Int): BigInt = {\n        BigInt(p) * BigInt(2*n+1)\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335135,"user_id":53,"body":"object Disguised {\n    def uEff(n: Int, p: Int): BigInt = {\n        BigInt(p) * BigInt(n+1)\n    }\n    def vEff(n: Int, p: Int): BigInt = {\n        BigInt(p) * BigInt(2*n+1)\n    }\n    def u1(n: Int, p: Int): BigInt = {\n        uEff(n, p)\n    }\n    def v1(n: Int, p: Int): BigInt = {\n        vEff(n, p)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335136,"user_id":null,"body":"\nobject Disguised {  \n    def uEff(n: Int, p: Int): BigInt = {\n        u1(n, p)\n    }\n    def vEff(n: Int, p: Int): BigInt = {\n        v1(n, p)  \n    }\n\n    def u1(n: BigInt, p: BigInt): BigInt = {\n      val u = (n + 1) * p\n      u\n    }\n  \n    def v1(n: BigInt, p: BigInt): BigInt = {\n      val v = (2 * n + 1) * p\n      v\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335137,"user_id":null,"body":"object Disguised {\n  \n    def uEff(n: Int, p: Int): BigInt = {\n        BigInt(n + 1) * p\n    }\n    def vEff(n: Int, p: Int): BigInt = {\n        BigInt(n + n + 1) * p\n    }\n\n    def u1(n: Int, p: Int): BigInt = {\n        BigInt(n + 1) * p\n    }\n    def v1(n: Int, p: Int): BigInt = {\n        BigInt(n + n + 1) * p\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335138,"user_id":null,"body":"object Disguised {\n  \n  def uEff(n: Int, p: Int): BigInt =\n    BigInt(p) * (BigInt(n) + 1)\n\n  def vEff(n: Int, p: Int): BigInt =\n    BigInt(p) * (2 * BigInt(n) + 1)\n\n  def u1(n: Int, p: Int): BigInt =\n    p * (0 to n).map(k => BigInt(-1).pow(k) * BigInt(4).pow(n - k) * bk(2 * n - k + 1, k)).sum\n\n  def v1(n: Int, p: Int): BigInt =\n    p * (0 to n).map(k => BigInt(-1).pow(k) * BigInt(4).pow(n - k) * bk(2 * n - k, k)).sum\n\n  private def bk(n: Int, k: Int): BigInt = {\n    val (num, den) = (1 to k).foldLeft((BigInt(1), BigInt(1)))((res, i) => (res._1 * (n + 1 - i), res._2 * i))\n    num \/ den\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5700c9acc1555755be00027e":[{"id":335139,"user_id":null,"body":"import scala.collection.mutable\n\nobject Rotations {\n\n  def containAllRots(str: String, arr: List[String]): java.lang.Boolean = {\n    val rots = (0 until str.length).map(i => str.drop(i) + str.take(i))\n    rots.forall(arr.contains(_))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335140,"user_id":null,"body":"object Rotations {\n\n  def containAllRots(strng: String, arr: List[String]) = {\n    strng.scanLeft(strng)((s,_) => s.tail :+ s.head).forall(arr.contains)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335141,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Rotations {\n  \n  def containAllRots(strng: String, arr: List[String]): java.lang.Boolean = {\n    @tailrec\n    def containsRot(rot: String): java.lang.Boolean = {\n      if (rot == strng) true\n      else if (!arr.contains(rot)) false\n      else containsRot(rot.tail + rot.head)\n    }\n    \n    arr.contains(strng) && containsRot(strng.tail + strng.head)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335142,"user_id":null,"body":"object Rotations {\n\n  def containAllRots(strng: String, arr: List[String]): java.lang.Boolean = {\n    val len = strng.length();\n    val allRotations = (1 to len).map(i => strng.substring(len - i).concat(strng.substring(0, len - i)))\n    allRotations.map(arr.contains(_)).reduceLeft(_ && _)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335143,"user_id":492,"body":"object Rotations {\n\n  def containAllRots(strng: String, arr: List[String]): java.lang.Boolean = {\n    var i = 0\n    while (i < strng.length) {\n      if(!arr.contains(strng.substring(i,strng.length())+strng.substring(0,i))) {\n        return false\n      }\n      i += 1\n    }\n    return true;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335144,"user_id":null,"body":"object Rotations {\n  def containAllRots(string: String, arr: List[String]): Boolean = {\n    val rotates = (0 until string.length).map(i => string.substring(i) + string.substring(0, i))\n    rotates.forall(x => arr.contains(x))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335145,"user_id":null,"body":"object Rotations {\n\n  def containAllRots(strng: String, arr: List[String]): java.lang.Boolean = {\n    strng.drop(1).scanLeft(strng){case (str, _) => str.tail :+ str.head}.forall(arr.contains)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335146,"user_id":null,"body":"object Rotations {\n\n  def containAllRots(s: String, arr: List[String]): java.lang.Boolean = {\n    var sSet = arr.toSet\n    (for(i <- Range(0, s.length)) yield (s.slice(i, s.length) + s.slice(0, i)))\n        .forall((ss) => sSet.contains(ss))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335147,"user_id":null,"body":"object Rotations {\n\n  def containAllRots(strng: String, arr: List[String]): java.lang.Boolean = \n  {\n    \n    if ((1 to strng.length-1)\n    .map( ind => s\"${strng.slice(ind,strng.length)}${strng.slice(0,ind)}\")\n    .filterNot(arr.contains(_)).length > 0) false\n    else arr.contains(strng)\n    \n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335148,"user_id":null,"body":"object Rotations {\n\n  def containAllRots(strng: String, arr: List[String]): java.lang.Boolean = {\n    strng.scanLeft(strng)((s,_) => s.tail :+ s.head).forall(arr.contains)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5715eaedb436cf5606000381":[{"id":335149,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    arr.filter(x => x > 0).sum\n  }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335150,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Long]): Long = arr.filter(_ > 0).sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335151,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    arr.filter(i => i > 0).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335152,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    var sum = 0\n    for(i <- 0 until arr.length) if (arr(i) > 0) sum += arr(i)\n    sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335153,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    var sum = 0;\n \n    for (i <- arr) {\n      if (i > 0) {\n        sum = sum + i;\n      }\n    }\n    return sum;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335154,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    arr.foldLeft(0)((p, c) => p + (if (c > 0) c else 0))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335155,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    val result = 0\n    var tmp_res = 0\n    if (arr.isEmpty) result\n    else (\n    for (num <- arr if num >= 0) tmp_res += num\n      )\n    tmp_res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335156,"user_id":null,"body":"object SumOfPositive:\n  def positive_sum(arr: Seq[Int]): Int =\n    arr.filter(_ > 0).sum","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335157,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    val result = if (arr.length > 0) arr.filter(_ > 0).sum else 0\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335158,"user_id":null,"body":"object SumOfPositive {\n  def positive_sum(arr: Seq[Int]): Int = {\n    var result = 0\n    \/\/val l = arr.length.toInt\n    for(i <- arr){\n      if(i>0){ result = result + i} else{ result }\n    }\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5726f813c8dcebf5ed000a6b":[{"id":335159,"user_id":null,"body":"object KPrimes {\n  def countKprimes(k:  Int, start: Long, end: Long): String = {\n    val pFactors = Array.fill(end.toInt + 1)(0)\n    (2 to end.toInt).foreach(p => {\n      if (pFactors(p) == 0) (p to end.toInt by p).foreach(i => {\n        var prime = i\n        while(prime != 0 && prime % p == 0) {\n          pFactors(i) += 1\n          prime \/= p\n        }\n      })\n    })\n\n    pFactors.zipWithIndex.filter(x => x._2 >= start && x._1 == k).map(_._2).mkString(\", \")\n  }\n\n  def puzzle(s: Int): Int = {\n    val pFactors7 = countKprimes(7, 2L, s.toLong).split(\", \").map(_.toInt)\n    val pFactors3 = countKprimes(3, 2L, s.toLong).split(\", \").map(_.toInt).filter(_ <= s - pFactors7.min)\n    val pFactors1 = countKprimes(1, 2L, s.toLong).split(\", \").map(_.toInt).filter(_ <= s - (pFactors7.min + pFactors3.min))\n\n    pFactors7.map(a => pFactors3.filter(b => pFactors1.filter(c => s == a + b + c).size > 0).size).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335160,"user_id":null,"body":"object KPrimes {\n\n  def nextFactor(n: Long, p: Int): Option[Int] = (2 to math.pow(n, 1.0 \/ p).round.toInt) find (x => n % x == 0)\n\n  def isPrime(n: Long): Boolean = (2 to math.sqrt(n).toInt) forall (x => n % x != 0)\n\n  def isKPrime(n: Long, k: Int): Boolean = k match {\n    case 1 => isPrime(n)\n    case _ =>\n      nextFactor(n, k).fold(false)(x => isKPrime(n \/ x, k - 1))\n  }\n\n  def countKprimes(k:  Int, start: Long, nd: Long): String = {\n    (start to nd).filter(x => isKPrime(x, k)).mkString(\", \")\n  }\n\n  def puzzle(s: Int): Int = {\n    val solutions = for {\n      p1 <- (2 to s).filter(isKPrime(_, 1))\n      p3 <- (2 to s).filter(isKPrime(_, 3))\n      p7 <- (2 to s).filter(isKPrime(_, 7))\n      if p1 + p3 + p7 == s\n    } yield (p1,p3,p7)\n    solutions.length\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335161,"user_id":null,"body":"object KPrimes {\n  def countKprimes(k: Int, start: Long, nd: Long): String = {\n    @scala.annotation.tailrec\n    def primeFactors(number: Long, divisor: Long, factors: List[Long]): List[Long] = {\n      if(number == 1 || divisor > number) factors\n      else if(number % divisor == 0) primeFactors(number \/ divisor, divisor, divisor:: factors)\n      else primeFactors(number, divisor + 1, factors)\n    }\n    val factorList: scala.collection.mutable.ListBuffer[Long] = new scala.collection.mutable.ListBuffer[Long]\n    (start to nd).toList.filter(x => x > 1L).foreach {\n      num =>\n        if(primeFactors(num, 2, List()).length == k) factorList += num\n    }\n    factorList.mkString(\", \")\n  }\n  \n  def puzzle(s: Int): Int = {\n    val onePrimes: List[Int] = countKprimes(1, 1L, s.toLong).split(\",\").filter(x=> x != \"\").map(x=> x.trim.toInt).toList\n    val threePrimes: List[Int] = countKprimes(3, 1L, s.toLong).split(\",\").filter(x=> x != \"\").map(x => x.trim.toInt).toList\n    val sevenPrimes: List[Int] = countKprimes(7, 1L, s.toLong).split(\",\").filter(x=> x != \"\").map(x => x.trim.toInt).toList\n\n    val results: List[Int] = for{\n      x <- onePrimes\n      y <- threePrimes\n      z <- sevenPrimes\n    } yield (x + y + z)\n\n    results.count(_ == s)\n  }          \n} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335162,"user_id":53,"body":"object KPrimes {\n  \n  def countFactors(s: Long): Int = {\n    var cnt = 0\n    var n = s\n    var i = 2\n    while (i <= n \/ i) {\n      while (n % i == 0) {\n        n \/= i\n        cnt += 1\n      }\n      i += 1\n    }\n    if (n > 1) {\n      cnt += 1\n    }\n    cnt\n  } \n  \n  def countKprimesList(k: Int, start: Long, nd: Long): Seq[Long] = {\n    (start to nd).filter(n => countFactors(n) == k).toSeq\n  }\n  \n  def countKprimes(k: Int, start: Long, nd: Long): String = {\n    countKprimesList(k, start, nd).mkString(\", \")\n  }\n  \n  def puzzle(s: Int): Int = {\n    var cnt = 0\n    var xs = countKprimesList(7, 128, s - 10)\n    var ys = countKprimesList(3, 8, s - 130)\n    for (a <- xs) {\n      for (b <- ys) {\n        var c = s - a - b\n        if (c > 0 && countFactors(c) == 1) {\n          cnt += 1\n        }\n      }\n    }\n    cnt\n  }          \n} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335163,"user_id":null,"body":"object KPrimes {\n  def primeNum(k: Long): Int = {\n    var (primeNum, d, n) = (0, 2, k)\n    while (d * d <= n) {\n      while (n % d == 0) {\n        primeNum += 1\n        n \/= d\n      }\n      d += 1\n    }\n    if (n > 1) primeNum + 1 else primeNum\n  }\n\n  def countKprimes(k: Int, start: Long, nd: Long): String = {\n    (start to nd).filter(primeNum(_) == k).mkString(\", \")\n  }\n\n  def puzzle(s: Int): Int = {\n    val p1 = (0 to s).filter(primeNum(_) == 1)\n    val p3 = (0 to s).filter(primeNum(_) == 3)\n    val p7 = (0 to s).filter(primeNum(_) == 7)\n    var res = 0\n    for {\n      v1 <- p1\n      v3 <- p3\n      v7 <- p7\n    } yield if((v1+v3+v7)==s) {\n      res+=1\n    }\n    res\n  }        \n}   ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335164,"user_id":null,"body":"object KPrimes {\n  \n  def hasKPrimeDivs(n: Long, numDivs: Int): Boolean = {\n    var rem = n\n    var divCount = 0\n    var d = 2\n    while (rem > 1) {\n      while (rem % d == 0) {\n        divCount += 1\n        if (divCount > numDivs) return false\n        rem \/= d\n      }\n      d += 1\n    }\n    numDivs == divCount\n  }\n  \n  def countKprimes(k: Int, start: Long, end: Long): String = {\n    (start to end).filter(hasKPrimeDivs(_, k)).mkString(\", \")\n  }\n\n  def countKprimesIntList(k: Int, start: Long, end: Long): List[Long] = {\n    (start to end).filter(hasKPrimeDivs(_, k)).toList\n  }\n  \n  def puzzle(s: Int): Int = {\n    val aNums = countKprimesIntList(1, 2, s)\n    val bNums = countKprimesIntList(3, 2, s)\n    val cNums = countKprimesIntList(7, 2, s)\n    println(s)\n    println(aNums)\n    println(bNums)\n    println(cNums)\n    (for {\n      a <- aNums\n      b <- bNums\n      c <- cNums if a + b + c == s\n    } yield (a, b, c)).length\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335165,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject KPrimes {\n  @tailrec\n  def checkIfHasKPrimeFactors(n: Long, k: Long, f: Long = 2, acc: Long = 0): Boolean = {\n    if (n == 1 && acc == k) true\n    else if (n == 1 || acc > k) false\n    else if (n % f == 0) checkIfHasKPrimeFactors(n \/ f, k, f, acc + 1)\n    else checkIfHasKPrimeFactors(n, k, f + 1, acc)\n  }\n  \n  def countKprimes(k: Int, start: Long, end: Long): String =\n    (start to end)\n      .filter(n => checkIfHasKPrimeFactors(n, k))\n      .mkString(\", \")\n\n  def getAllNumberWithGivenKPrimeFactors(n: Int, k: Int): List[Int] = {\n    (0 to n).filter(nn => checkIfHasKPrimeFactors(nn, k)).toList\n  }\n  \n  def puzzle(s: Int): Int = (\n    for {\n      prime1 <- getAllNumberWithGivenKPrimeFactors(s, 1)\n      if prime1 < s\n      prime3 <- getAllNumberWithGivenKPrimeFactors(s, 3)\n      if prime1 + prime3 < s\n      prime7 <- getAllNumberWithGivenKPrimeFactors(s, 7)\n      if prime1 + prime3 + prime7 == s\n    } yield 1).length} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335166,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject KPrimes {\n  def kPrimes(n: Long): List[Int] = {\n    @tailrec\n    def findKPrimes(n: Long, divider: Int, kPrimes: List[Int]): List[Int] = {\n      if (divider > n) kPrimes\n      else if (n % divider == 0) findKPrimes(n \/ divider, divider, kPrimes :+ divider)\n      else findKPrimes(n, divider + 1, kPrimes)\n    }\n\n    findKPrimes(n, 2, List())\n  }\n\n  def kPrimesRange(k: Int, start: Long, nd: Long): Seq[Long] =\n    (start to nd).filter(n => kPrimes(n).length == k)\n  \n  def countKprimes(k:  Int, start: Long, nd: Long): String =\n    kPrimesRange(k, start, nd).mkString(\", \")\n  \n  def puzzle(s: Int): Int = \n    (for {\n      k1 <- kPrimesRange(1, 2, s)\n      k3 <- kPrimesRange(3, 2, s)\n      k7 <- kPrimesRange(7, 2, s)\n    } yield (k1, k3, k7)).count {\n      case (k1, k3, k7) => k1 + k3 + k7 == s\n    }\n        \n} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335167,"user_id":null,"body":"object KPrimes {\n  def factorize(x: Long): List[Long] = {\n    @scala.annotation.tailrec\n    def foo(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a*a > x match {\n      case false if x % a == 0 => foo(x \/ a, a, a :: list)\n      case false               => foo(x, a + 1, list)\n      case true                => x :: list\n    }\n    foo(x)\n  }\n\n  def getKprimes(k: Int, start: Long, nd: Long) : Seq[Long] = for (i <- start to nd if factorize(i).size == k) yield i\n\n  def countKprimes(k: Int, start: Long, nd: Long): String = {\n    val j = getKprimes(k, start, nd)\n    j.mkString(\", \")\n  }\n\n  def puzzle(s: Int): Int = {\n    val sollist = for {\n      a <- getKprimes(1, 2, s)\n      b <- getKprimes(3, 2, s)\n      c <- getKprimes(7, 2, s)\n      if a + b + c == s\n    } yield Seq(a, b, c)\n    sollist.distinct.length\n  }\n} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335168,"user_id":null,"body":"object KPrimes {\n  def factorize(x: Long): List[Long] = {\n    @scala.annotation.tailrec\n    def foo(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a*a > x match {\n      case false if x % a == 0 => foo(x \/ a, a, a :: list)\n      case false               => foo(x, a + 1, list)\n      case true                => x :: list\n    }\n    foo(x)\n  }\n\n  def getKprimes(k: Int, start: Long, nd: Long) : Seq[Long] = for (i <- start to nd if factorize(i).size == k) yield i\n\n  def countKprimes(k: Int, start: Long, nd: Long): String = {\n    val j = getKprimes(k, start, nd)\n    j.mkString(\", \")\n  }\n\n  def puzzle(s: Int): Int = {\n    val sollist = for {\n      a <- getKprimes(1, 2, s)\n      b <- getKprimes(3, 2, s)\n      c <- getKprimes(7, 2, s)\n      if a + b + c == s\n    } yield Seq(a, b, c)\n    \/\/ println(sollist)\n    \/\/Set(sollist).size\n    sollist.distinct.length\n  }\n} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5727bb0fe81185ae62000ae3":[{"id":335169,"user_id":573,"body":"object Kata {\n\n  def clean_string(s: String): String =\n    s.foldLeft(\"\") { case (acc, '#') => acc.dropRight(1) case (acc, c) => s\"$acc$c\" }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:35:23"},{"id":335170,"user_id":null,"body":"object Kata {\n  def clean_string(s: String): String =\n    s.foldLeft(\"\")((str, char) => (str, char) match {\n      case (\"\", '#') => \"\"\n      case (s, '#') => s.init\n      case (s, c) => s + c \n    })\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335171,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String = {\n    var result = \"\"\n    s.foreach(x=> {\n        if (x != '#') result += x\n        else result = result.dropRight(1)\n    })\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335172,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String = {\n    s.foldLeft(\"\")((a,b) => if (b == '#') a.dropRight(1) else a + b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335173,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String = s.foldLeft(\"\")((a, b) => b match { case '#' => a.init; case _ => a + b})\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335174,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String = {\n    @scala.annotation.tailrec\n    def loop(pref: List[Char], acc: List[Char] = Nil): String = pref match {\n      case '#' :: next => loop(next, acc.drop(1))\n      case c :: next => loop(next, c :: acc)\n      case Nil => acc.reverse.mkString\n    }\n    loop(s.toList)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335175,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String = (s+\"!\").split(\"#\").reduceLeft(_.dropRight(1) + _).dropRight(1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335176,"user_id":null,"body":"object Kata {\n  import scala.annotation.tailrec\n  \n  def clean_string(s: String): String = {\n    @tailrec\n    def inner(remaining: Seq[Char], acc: String): String =\n     remaining match {\n       case head +: tail => \n        head match {\n          case '#' if acc.nonEmpty => inner(tail, acc.init)\n          case '#' => inner(tail, \"\")\n          case _ => inner(tail, acc + head)\n        }\n       case _ => acc\n     }\n      \n  \n    inner(s, \"\")\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335177,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String =\n    s.foldLeft(\"\") { (acc, char) => char match {\n      case '#' => acc.init\n      case c => acc + c\n    }}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"},{"id":335178,"user_id":null,"body":"object Kata {\n\n  def clean_string(s: String): String = {\n    s.foldLeft(\"\") { case (acc, next) =>\n      next match {\n        case '#'   => acc.dropRight(1)\n        case other => acc + other\n      }\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 16:33:56"}],"573182c405d14db0da00064e":[{"id":335179,"user_id":null,"body":"object PrimeConsec {\n\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    arr.zip(arr.tail).foldLeft(0)((acc, x) => if (isKPrime(x._1, k) && isKPrime(x._2, k)) acc + 1 else acc)\n  }\n  \n  def isKPrime(n: Long, k: Int): Boolean = {\n    import scala.annotation.tailrec\n    @tailrec\n    def factorize(n: Long, a: Int = 2, amount: Int = 0): Int = a*a > n match {\n      case false if n % a == 0 => factorize(n \/ a, a, amount + 1)\n      case false => factorize(n, a + 1, amount)\n      case true => amount + 1\n    }\n    k == factorize(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335180,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject PrimeConsec {\n\n  @tailrec\n  def countPrimeFactors(n: Long, factor: Long = 2, acc: Long = 0): Long = {\n    if (n == 1) acc\n    else if (n % factor == 0) countPrimeFactors(n \/ factor, factor, acc + 1)\n    else countPrimeFactors(n, factor + 1, acc)\n  }\n  \n  def consecKprimes(k: Int, arr: Array[Long]): Int =\n    arr.map(elem => countPrimeFactors(elem))\n      .sliding(2)\n      .count(slide => slide.length == 2 && slide.forall(_ == k))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335181,"user_id":null,"body":"object PrimeConsec {\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    if (arr.length < 2) return 0\n    arr.map(factorize(2, _).length).sliding(2, 1).count { case Array(a, b) => (a, b) == (k, k) }\n  }\n\n  def factorize(div: Long, num: Long): List[Long] = {\n    if (div * div > num)  return List(num)\n    if (num % div == 0) return div :: factorize(div, num \/ div)\n    factorize(div + 1, num)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335182,"user_id":53,"body":"object PrimeConsec {\n\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    var cnt = 0;\n    var p = 0L;\n    for (n <- arr) {\n      var q = primeFactorCount(n);\n      if (q == k && p == k) {\n        cnt = cnt + 1;\n      }\n      p = q;\n    }\n    return cnt;\n  }\n  \n  def primeFactorCount(m: Long): Long = {\n    var len = 0;\n    var n = m;\n    var i = 2;\n    while (i * i <= n) {\n      while (n % i == 0) {\n        len = len + 1;\n        n = n \/ i;\n      }\n      i = i + 1;\n    }\n    if (n > 1) {\n      len = len + 1;\n    }\n    return len;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335183,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject PrimeConsec {\n  def factorize(x: Long): List[Long] = {\n    @tailrec\n    def foo(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a*a > x match {\n      case false if x % a == 0 => foo(x \/ a, a    , a :: list)\n      case false               => foo(x    , a + 1, list)\n      case true                => x :: list\n    }\n    foo(x)\n  }\n  \n  def isKPrime(k: Int, n: Long): Boolean = {\n    k == factorize(n).length\n  }\n\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    val list = arr.map(x => isKPrime(k, x))\n    list.zip(list.tail).count(x => x._1 && x._2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335184,"user_id":null,"body":"object PrimeConsec {\n  \n  \/\/ k-Primes\n  def kPrimes(numArray: Array[Long]): String = {\n    var kList: List[Int] = List()\n    var prime = 2 \/\/ start with 2\n    var kPrime = 1 \/\/ number is made of kPrimes\n    var auxNumber = 0L \/\/ auxiliary variable\n\n    \/\/ List of numbers\n    for(number <- numArray){\n      auxNumber = number\n      while(auxNumber >= prime * prime) { \/\/ break condition\n        if (auxNumber % prime == 0) { \/\/ divisible by the kPrime\n          auxNumber = auxNumber \/ prime\n          kPrime += 1\n        }\n        else {\n          prime += 1 \/\/ increment prime\n        }\n      }\n      \/\/ Add number to list of kPrimes\n      kList = kPrime :: kList\n\n      kPrime = 1 \/\/ One\n      prime = 2 \/\/ Two\n    }\n    \/\/ Result\n    kList.mkString(\"\")\n  }\n  \n  \/\/ consecKPrimes\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    val regularExpression = \"(?=(\" + k + \"{2}))\" \/\/ adding variable to string\n    val regex = regularExpression.r \/\/ regular expression\n    regex.findAllIn(kPrimes(arr)).length \/\/ size of string match\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335185,"user_id":null,"body":"object PrimeConsec {\n\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    val barr = arr.map(isKPrime(_, k))\n    (1 until barr.length).count(i => barr(i - 1) && barr(i))\n  }\n\n  private def isKPrime(n: Long, k: Int): Boolean =\n    n >= 2 && k >= 1 && {\n      var count  = k.toLong\n      var number = n\n      if (number % 2 == 0) {\n        while (number % 2 == 0) {\n          number \/= 2\n          count -= 1\n        }\n      }\n      var i = 3L\n      while (i * i <= number && 1 < number && count >= 0) {\n        if (number % i == 0) {\n          while (number % i == 0) {\n            number \/= i\n            count -= 1\n          }\n        }\n        i += 2\n      }\n      if (number > 1) count -= 1\n      count == 0\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335186,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject PrimeConsec {\n\n  def nPrimeFactors(x: Long): Int = {\n    @tailrec\n    def recur(x: Long, a: Long = 2, acc: Int = 0): Int = a * a > x match {\n      case false if x % a == 0 => recur(x \/ a, a, acc + 1)\n      case false => recur(x, a + 1, acc)\n      case true => acc + 1\n    }\n\n    recur(x)\n  }\n\n  def consecKprimes(k: Int, arr: Array[Long]): Int = (arr zip arr.tail)\n    .count {\n      case (a, b) => nPrimeFactors(a) == k && nPrimeFactors(b) == k\n    }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335187,"user_id":null,"body":"object PrimeConsec {\n\n  def consecKprimes(k: Int, arr: Array[Long]): Int = {\n    arr\n      .map(value => countKPrimes(2, value, 0))\n      .sliding(2)\n      .map(arr => arr.sum \/ 2)\n      .count(_ == k)\n  }\n\n  def countKPrimes(current: Long, number: Long, kPrimes: Int): Int = {\n    if (number < current)\n      kPrimes\n    else if (BigInt(current).isProbablePrime(10))\n      if (number % current == 0)\n        countKPrimes(current, number \/ current, kPrimes + 1)\n      else\n        countKPrimes(current + 1, number, kPrimes)\n    else\n      countKPrimes(current + 1, number, kPrimes)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335188,"user_id":null,"body":"object PrimeConsec {\n    def consecKprimes(k: Int, arr: Array[Long]): Int = {\n      arr\n        .foldLeft((0, false))((acc, num) => {\n          val cond = isKPrime(k, num)\n          if (cond) {\n            if (acc._2) (acc._1+1,true)\n            else (acc._1, true)\n          } else (acc._1, false)\n        })\n        ._1\n    }\n    private def isKPrime(k: Int, num: Long): Boolean = {\n      def curCounter(curDel: Long,\n                     curRemainder: Long,\n                     kCounter: Int): Boolean = {\n        if (kCounter > k) 1 == curRemainder\n        else if (curDel > curRemainder) false\n        else {\n          val res =\n            if (curRemainder % curDel == 0)\n              (curDel, curRemainder \/ curDel, kCounter + 1)\n            else (curDel + 1, curRemainder, kCounter)\n          curCounter(res._1, res._2, res._3)\n        }\n      }\n      if (num == 1) k == 1\n      else\n        curCounter(2, num, 1)\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57339a5226196a7f90001bcf":[{"id":335189,"user_id":751,"body":"object NPointCrossover {\n\n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T],List[T]) =\n    ns.sorted.distinct.foldLeft (xs,ys) { case ((xs,ys), n) =>\n      ((xs take n) ++ (ys drop n), (ys take n) ++ (xs drop n))\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335190,"user_id":null,"body":"object NPointCrossover {\n\n def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = {\n  val nsSanitized = ns.distinct.sorted\n\n  nsSanitized match {\n    case Nil => (xs, ys)\n    case (n :: nsTail) =>\n      val (xsHead, xsTail) = xs.splitAt(n)\n      val (ysHead, ysTail) = ys.splitAt(n)\n\n      crossover(nsTail, xsHead ++ ysTail, ysHead ++ xsTail)\n  }\n }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335191,"user_id":null,"body":"object NPointCrossover {\n  \n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = {\n    def cr(ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) =\n      if (ns.isEmpty) (xs, ys)\n      else cr(ns.tail, xs.take(ns.head) ++ ys.drop(ns.head), ys.take(ns.head) ++ xs.drop(ns.head))\n\n    cr(ns.sorted.distinct, xs, ys)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335192,"user_id":null,"body":"object NPointCrossover {\n  \n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = {\n    \/\/ ns \u53bb\u91cd\u5e76\u4e14\u4ece\u5c0f\u5230\u5927\u6392\u5217\n    val nss = ns.distinct\n    val result1 = xs.zip(ys).zipWithIndex.map{ case ((ele1,ele2), index) => {\n         if(nss.filter(_<=index).size %2 == 1)\n             (ele2, ele1)\n         else\n             (ele1, ele2)\n      }\n    }\n    result1.unzip\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335193,"user_id":null,"body":"object NPointCrossover {\n  \n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = {\n    val valid = List(0) ++ ns.sorted.distinct :+ xs.length\n    val crosses = (1 to valid.length - 1).toList\n    val l1 = crosses.flatMap{ x =>\n      if (x % 2 == 0) ys.take(valid(x)).drop(valid(x-1))\n      else xs.take(valid(x)).drop(valid(x-1))\n    }\n    val l2 = crosses.flatMap{ x =>\n      if (x % 2 == 0) xs.take(valid(x)).drop(valid(x-1))\n      else ys.take(valid(x)).drop(valid(x-1))\n    }\n    (l1, l2)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335194,"user_id":null,"body":"object NPointCrossover {\n  \n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) =\n    crossoverOrder(ns.sorted.distinct, xs, ys)\n\n  @scala.annotation.tailrec\n  def crossoverOrder[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) =\n    ns match {\n      case Nil          => (xs, ys)\n      case head :: next => crossoverOrder(next, xs.take(head) ++ ys.drop(head), ys.take(head) ++ xs.drop(head))\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335195,"user_id":null,"body":"object NPointCrossover {\n\n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = ns.sorted.distinct match {\n    case Nil => (xs, ys)\n    case head +: tail => crossover(tail, xs.take(head) ++ ys.drop(head), ys.take(head) ++ xs.drop(head))\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335196,"user_id":null,"body":"object NPointCrossover {\n  \n  @scala.annotation.tailrec\n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = ns.distinct match {\n    case Nil => (xs, ys)\n    case n :: nss => crossover(nss, xs.take(n) ::: ys.drop(n), ys.take(n) ::: xs.drop(n))\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335197,"user_id":null,"body":"object NPointCrossover {\n  \n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = {\n    \n    def go(ns: List[Int], xs: List[T], ys: List[T], current_idx: Int): (List[T], List[T]) = ns match {\n      case Nil => (xs, ys)\n      case n0 :: n_tail if n0 == current_idx => {\n        \/\/ crossing starts here\n        val crossed_tails = go(n_tail, ys.tail, xs.tail, current_idx + 1)\n        (\n          ys.head :: crossed_tails._1,\n          xs.head :: crossed_tails._2\n        )\n      }\n      case _ => {\n        \/\/ crossing doesn't start yet\n        val crossed_tails = go(ns, xs.tail, ys.tail, current_idx + 1)\n        (\n          xs.head :: crossed_tails._1,\n          ys.head :: crossed_tails._2\n        )\n      }\n    }\n    \n    go(ns.distinct.sorted, xs, ys, 0)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335198,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject NPointCrossover {\n\n  def crossover[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = go(ns.distinct, xs, ys)\n\n  @tailrec\n  def go[T](ns: List[Int], xs: List[T], ys: List[T]): (List[T], List[T]) = ns match {\n    case Nil       => (xs, ys)\n    case n :: rest => go(rest, xs.take(n) ++ ys.drop(n), ys.take(n) ++ xs.drop(n))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"573992c724fc289553000e95":[{"id":335199,"user_id":573,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] =\n    (for {\n      i <- 0 until s\"$n\".size\n      j <- 0 until s\"$n\".size\n      if i != j\n    } yield Array(s\"$n\".patch(j, Nil, 1).patch(i, Seq(s\"$n\"(j)), 0).toLong, j, i))\n    .minBy { case Array(s, i, j) => (s, i) }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335200,"user_id":492,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    var s: String = java.lang.Long.toString(n)\n    var tmp: String = s\n    val mem: Array[Long] = Array(n, 0, 0)\n    val l: Int = s.length\n    for (i <- 0 until l) {\n      val c: Char = s.charAt(i)\n      val str1: String = s.substring(0, i) + s.substring(i + 1, l)\n      for (j <- 0 until l) {\n        val str2: String = str1.substring(0, j) + c + str1.substring(\n            j,\n            str1.length)\n        val cmp: Int = str2.compareTo(tmp)\n        if (cmp < 0) {\n          tmp = str2\n          mem(0) = java.lang.Long.parseLong(tmp)\n          mem(1) = i\n          mem(2) = j\n        }\n      }\n    }\n    mem\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335201,"user_id":null,"body":"object ToSmallest {\n  def switchOnIndices(list: List[Int], i: Int, j: Int): Long = {\n    list.zipWithIndex.filter(_._2 != i).map(_._1).patch(j, List(list(i)), 0).mkString(\"\").toLong\n  }\n\n  def smallest(n: Long): Array[Long] = {\n    val list = n.toString.toList.map(_.asDigit)\n    val len = list.length\n    val indices = for(i <- 0 until len;\n        j <- 0 until len) yield (i, j)\n    val resIndices = indices.minBy(x => switchOnIndices(list, x._1, x._2))\n    Array(switchOnIndices(list, resIndices._1, resIndices._2), resIndices._1, resIndices._2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335202,"user_id":null,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    var smallestNum: Long = n\n    var previousIndex: Long = 0\n    var betterIndex: Long = 0\n\n    val inputArr = n.toString.split(\"\").map(e => e.toLong)\n    for (initialIndex <- inputArr.indices){\n      for (newIndex <- inputArr.indices){\n        if (calc(inputArr, initialIndex, newIndex) < smallestNum) {\n          smallestNum = calc(inputArr, initialIndex, newIndex)\n          previousIndex = initialIndex\n          betterIndex = newIndex\n        }\n      }\n    }\n    Array(smallestNum, previousIndex, betterIndex)\n  }\n\n  def calc(array: Array[Long], current: Int, test: Int): Long = {\n\n    val (left, right) = array.mkString(\"\")\n      .split(\"\")\n      .updated(current, \"\")\n      .mkString(\"\")\n      .split(\"\")\n      .map(e => e.toLong)\n      .toVector\n      .splitAt(test)\n\n    (left ++ Vector(array(current)) ++ right).mkString(\"\").toLong\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335203,"user_id":null,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    var smallestNum: Long = n\n    var previousIndex: Long = 0\n    var betterIndex: Long = 0\n\n    val inputArr = n.toString.split(\"\").map(e => e.toLong)\n    for (initialIndex <- inputArr.indices){\n      for (newIndex <- inputArr.indices){\n        if (calc(inputArr, initialIndex, newIndex) < smallestNum) {\n          smallestNum = calc(inputArr, initialIndex, newIndex)\n          previousIndex = initialIndex\n          betterIndex = newIndex\n        }\n      }\n    }\n    println( Array(smallestNum, previousIndex, betterIndex).mkString(\", \"))\n    Array(smallestNum, previousIndex, betterIndex)\n  }\n\n  def calc(array: Array[Long], current: Int, test: Int): Long = {\n\n    val (left, right) = array.mkString(\"\")\n      .split(\"\")\n      .updated(current, \"\")\n      .mkString(\"\")\n      .split(\"\")\n      .map(e => e.toLong)\n      .toVector\n      .splitAt(test)\n\n    (left ++ Vector(array(current)) ++ right).mkString(\"\").toLong\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335204,"user_id":1285,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    val str = n.toString\n    \n    var small = Long.MaxValue\n    var from = -1\n    var to = -1\n    \n    var i = 0\n    while (i < str.length) {\n      val digit = str.substring(i, i + 1)\n      val tempStr = str.substring(0, i) + str.substring(Math.min(i + 1, str.length))\n      var j = 0\n      while (j < str.length) {\n        if (j != i) {\n          val perm = (tempStr.substring(0, j) + digit + tempStr.substring(j)).toLong\n          if (perm < small) {\n            small = perm\n            from = i\n            to = j\n          } else if (perm == small) {\n            if (i < from) {\n              from = i\n              to = j\n            } else if (i == from) {\n              if (j < to) {\n                to = j\n              }\n            }\n          }\n        }\n        j += 1\n      }\n      i += 1\n    }\n    \n    Array(small, from, to)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335205,"user_id":null,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    val nString = n.toString\n\t  val result = nString.zipWithIndex.map { case (digit, removeIndex) => {\n      val shortened = nString.substring(0, removeIndex) + nString.substring(removeIndex + 1, nString.length)\n      (0 until nString.length)\n        .map(insertIndex => (\n          (shortened.substring(0,insertIndex) + digit + shortened.substring(insertIndex, shortened.length)).toLong,\n          removeIndex,\n          insertIndex\n        )).minBy(_._1)\n    } }.minBy(_._1)\n    Array(result._1, result._2, result._3)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335206,"user_id":null,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    \/\/ your code\n          (for {\n          i <- 0 until s\"$n\".size\n          j <- 0 until s\"$n\".size\n          if i != j\n        } yield Array(s\"$n\".patch(j, Nil, 1).patch(i, Seq(s\"$n\"(j)), 0).toLong, j, i))\n          .minBy { case Array(s, i, j) => (s, i) }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335207,"user_id":null,"body":"object ToSmallest {\n\n  def smallest(n: Long): Array[Long] = {\n    val digits = n.toString\n    val prefix = digits.takeWhile(x => x == digits(0))\n    val byValue = digits.distinct.sorted\n    val min = { if (prefix.length == digits.count(_ == byValue(0))) byValue.find(x => x != prefix(0)) else Some(byValue(0)) }\n    if (min == None) Array(n, 0, 1)\n    else {\n      val isLessThenP = min.get < digits(0)\n      val offset = { if (isLessThenP) 0 else prefix.length}\n      val l = { \n        val i = offset\n        val firstBigger = digits.drop(i + 1).find(x => x > digits(0))\n        val j = { if (firstBigger == None) digits.length - 1 else digits.drop(i).indexOf(firstBigger.get) - i - 1 - digits.take(digits.drop(i).indexOf(firstBigger.get) - i).reverse.takeWhile(x => x == digits(i)).length}\n        val newNum = digits.take(i).mkString(\"\") ++ digits.slice(i + 1, j + 1).mkString(\"\") ++ digits(i).toString ++ digits.drop(j + 1)\n        Array(newNum.toLong, i, j)\n      }\n      val r = {\n        val i = (\"[\" + min.get + \"]+\").r.findAllMatchIn(digits).map(_.start).toList.last\n        val j = { if (prefix(0) == min.get) 0 else offset }\n        val newNum = digits.take(j).mkString(\"\") ++ digits(i).toString ++ digits.slice(j, i).mkString(\"\") ++ digits.drop(i + 1)\n        Array(newNum.toLong, i, j)\n      }\n      if (l(0) <= r(0)) l\n      else r\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335208,"user_id":null,"body":"import scala.collection.mutable.ListBuffer;\nobject ToSmallest {\n\n  def getVal(numList: ListBuffer[Int]): Long = {\n  var acc = 0.0\n  var digits = numList.length - 1\n  for (v <- numList) {\n    acc = acc + v * Math.pow(10, digits)\n    digits -= 1\n  }\n  acc.toLong\n}\n\ndef smallest(n: Long): Array[Any] = {\n  val numList = ListBuffer.empty ++= n.toString.toArray.map(_.asDigit)\n  var index_i = 0\n  var index_j = 0\n  var min = n\n\n  for (i <- numList.indices; j <- numList.indices) {\n    val resume = ListBuffer.empty.addAll(numList)\n    val v = numList(i)\n    numList.remove(i)\n    numList.insert(j, v)\n    val temp = getVal(numList)\n    println(temp)\n    if (temp < min) {\n      min = temp\n      index_i = i\n      index_j = j\n    }\n    numList.clear()\n    numList ++= resume\n  }\n\n  Array(min, index_i, index_j)\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57591ef494aba64d14000526":[{"id":335209,"user_id":null,"body":"object Johnann {\n\n  def john(n: Long): String = johnLazyList.take(n.toInt).mkString(\", \")\n\n  def ann(n: Long): String = annLazyList.take(n.toInt).mkString(\", \")\n\n  def sumJohn(n: Long): Long = johnLazyList.take(n.toInt).sum\n\n  def sumAnn(n: Long): Long = annLazyList.take(n.toInt).sum\n\n  val johnLazyList: LazyList[Int] = 0 #:: LazyList.from(1).map(n => n - annLazyList(johnLazyList(n - 1)))\n  val annLazyList: LazyList[Int] = 1 #:: LazyList.from(1).map(n => n - johnLazyList(annLazyList(n - 1)))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335210,"user_id":492,"body":"import scala.collection.mutable.ListBuffer\n\nobject Johnann {\n\n  private def johnAnn(n: Long): List[ListBuffer[Long]] = {\n    val johnList: ListBuffer[Long] = new ListBuffer[Long]() \n    val annList: ListBuffer[Long] = new ListBuffer[Long]() \n    val res: ListBuffer[ListBuffer[Long]] = new ListBuffer[ListBuffer[Long]]()\n    annList += 1L\n    johnList += 0L\n    if (n == 0) {\n      res += annList\n      res += johnList\n    } else {\n      var i: Long = 1\n      while (i < n) {\n        val j: Long = johnList((i - 1).toInt)\n        val a1: Long = annList(j.toInt)\n        johnList += i - a1\n        val a: Long = annList((i - 1).toInt)\n        val j1: Long = johnList(a.toInt)\n        annList += i - j1\n        i += 1\n      }\n      res += annList\n      res +=johnList\n    }\n    res.toList\n  }\n\n  def john(n: Long): String = johnAnn(n)(1).toList.mkString(\", \")\n\n  def ann(n: Long): String = johnAnn(n)(0).toList.mkString(\", \")\n\n  def sumJohn(n: Long): Long = johnAnn(n)(1).sum\n\n  def sumAnn(n: Long): Long = johnAnn(n)(0).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335211,"user_id":null,"body":"object Johnann {\n  def john(n: Long): String = aj._2.take(n.toInt).mkString(\", \")\n  def ann(n: Long): String = aj._1.take(n.toInt).mkString(\", \")\n  def sumJohn(n: Long): Long = aj._2.take(n.toInt).sum\n  def sumAnn(n: Long): Long = aj._1.take(n.toInt).sum\n  \n  val aj: (Stream[Int], Stream[Int]) = (\n    1 #:: 1 #:: Stream.from(2).map(nextA(_)),\n    0 #:: 0 #:: Stream.from(2).map(nextJ(_))\n  )\n  def nextA(n: Int) = n - aj._2.apply(aj._1.apply(n - 1))\n  def nextJ(n: Int) = n - aj._1.apply(aj._2.apply(n - 1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335212,"user_id":null,"body":"object Johnann {\n\n  def john(n: Long) = johnLazyList.take(n.toInt).mkString(\", \")\n\n  def ann(n: Long): String = annLazyList.take(n.toInt).mkString(\", \")\n\n  def sumJohn (n: Long): Long = johnLazyList.take(n.toInt).sum\n\n  def sumAnn(n: Long): Long = annLazyList.take(n.toInt).sum\n\n  val johnLazyList: LazyList[Int] = 0 #:: LazyList.from(1).map(n => n - annLazyList(johnLazyList(n - 1)))\n  val annLazyList: LazyList[Int] = 1 #:: LazyList.from(1).map(n => n - johnLazyList(annLazyList(n - 1)))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335213,"user_id":null,"body":"object Johnann {\n  import scala.collection.mutable\n\n  def memoize[I, O](f: I => O): I => O = new mutable.HashMap[I, O]() {\n    override def apply(key: I) = getOrElseUpdate(key, f(key))\n  }\n\n  val j : Long => Long = memoize {\n    case 0 => 0\n    case n => n - a(j(n-1))\n  }\n\n  val a : Long => Long = memoize {\n    case 0 => 1\n    case n => n - j(a(n-1))\n  }\n\n  def john(n: Long): String = (0 until n.toInt).map(j(_)).mkString(\", \")\n  \n  def ann(n: Long): String = (0 until n.toInt).map(a(_)).mkString(\", \")\n\n  def sumJohn(n: Long): Long = (0 until n.toInt).map(j(_)).sum\n\n  def sumAnn(n: Long): Long = (0 until n.toInt).map(a(_)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335214,"user_id":null,"body":"import scala.collection.mutable\nobject Johnann {\n  def jnArr(n: Int): (List[Int], List[Int]) = {\n    val (j, a) = (mutable.ListBuffer(0), mutable.ListBuffer(1))\n    for (x <- 1 until n) {\n      j += (x - a(j(x - 1)))\n      a += (x - j(a.apply(x - 1)))\n    }\n    (j.toList, a.toList)\n  }\n\n  def john(n: Long): String = jnArr(n.toInt)._1.mkString(\", \")\n\n  def ann(n: Long): String = jnArr(n.toInt)._2.mkString(\", \")\n\n  def sumJohn(n: Long): Long = jnArr(n.toInt)._1.sum\n\n  def sumAnn(n: Long): Long = jnArr(n.toInt)._2.sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335215,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.collection.immutable.SortedMap\n\nobject Johnann {\n\n  type State = SortedMap[Long, Long]\n  def annCalc(n: Long, state: State, johnState: State): (Long, State) = {\n    @tailrec\n    def rec(i: Long, state: State, johnState: State, lastResult: Long): (Long, State) = i match {\n      case i if i > n =>\n        (lastResult, state)\n      case 0 =>\n        rec(i + 1, state + (0L -> 1L), johnState, 1)\n      case i =>\n        val t = state.get(i - 1).head\n        val (johnResult, newJohnState) = johnState.get(t) match {\n          case Some(value) =>\n            (value, johnState)\n          case None =>\n            johnCalc(t, johnState, state)\n        }\n        val result = i - johnResult\n        rec(i + 1, state + (i -> result), newJohnState, result)\n    }\n\n    rec(state.lastOption.map(_._1).getOrElse(0), state, johnState, 0)\n  }\n\n  def johnCalc(n: Long, state: State, annState: State): (Long, State) = {\n    @tailrec\n    def rec(i: Long, state: State, annState: State, lastResult: Long): (Long, State) = i match {\n      case i if i > n =>\n        (lastResult, state)\n      case 0 =>\n        rec(i + 1, state + (0L -> 0L), annState, 0)\n      case i =>\n        val t = state.get(i - 1).head\n        val (annResult, newAnnState) = annState.get(t) match {\n          case Some(value) => (value, annState)\n          case None => annCalc(t, annState, state)\n        }\n        val result = i - annResult\n        rec(i + 1, state + (i -> result), newAnnState, result)\n    }\n\n    rec(state.lastOption.map(_._1).getOrElse(0), state, annState, 0)\n  }\n\n  def sumAnn(n: Long): Long =\n    annCalc(n, SortedMap.empty, SortedMap.empty)._2.rangeUntil(n).values.sum\n\n  def ann(n: Long): String =\n    annCalc(n, SortedMap.empty, SortedMap.empty)._2.rangeUntil(n).values.mkString(\", \")\n\n  def sumJohn(n: Long): Long =\n    johnCalc(n, SortedMap.empty, SortedMap.empty)._2.rangeUntil(n).values.sum\n\n  def john(n: Long): String =\n    johnCalc(n, SortedMap.empty, SortedMap.empty)._2.rangeUntil(n).values.mkString(\", \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335216,"user_id":null,"body":"import scala.collection.mutable.ArrayBuffer\nobject Johnann {\n\n  val listJ = ArrayBuffer[Int](0)\n  val listA = ArrayBuffer[Int](1)\n  \n  def genJohn(n: Int): Int = {\n    while(listJ.length <= n) {\n      listJ += (listJ.length - genAnn(genJohn(listJ.length-1)))\n    }\n    listJ(n).toInt\n  }\n  \n  def genAnn(n: Int): Int = {\n    while(listA.length <= n) {\n      listA += (listA.length - genJohn(genAnn(listA.length-1)))\n    }\n    listA(n.toInt).toInt\n  }\n\n  def john(n: Long): String = { \n    genJohn(n.toInt)\n    listJ.take(n.toInt).mkString(\", \")\n  }\n\n  def ann(n: Long): String = {\n    genAnn(n.toInt)\n    listA.take(n.toInt).mkString(\", \")  \n  }\n\n  def sumJohn(n: Long): Long = {\n    genJohn(n.toInt) \n    listJ.take(n.toInt).sum.toLong\n  }\n\n  def sumAnn(n: Long): Long = {\n    genAnn(n.toInt) \n    listA.take(n.toInt).sum.toLong\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335217,"user_id":null,"body":"object Johnann {\n  var a_mem = Array(1L)\n  var j_mem = Array(0L)\n  \n  def a(n: Long): Long = {\n    if (this.a_mem.length <= n) this.a_mem = this.a_mem :+ n - j(a(n - 1))\n    this.a_mem(n.toInt)\n  }\n  \n  def j(n: Long): Long = {\n    if (this.j_mem.length <= n) this.j_mem = this.j_mem :+ n - a(j(n - 1))\n    this.j_mem(n.toInt)\n  }\n  \n  def john(n: Long): String = (0L until n).map(j(_).toString).mkString(\", \")\n\n  def ann(n: Long): String = (0L until n).map(a(_).toString).mkString(\", \")\n\n\n  def sumJohn(n: Long): Long = (0L until n).map(j(_)).sum\n\n  def sumAnn(n: Long): Long = (0L until n).map(a(_)).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335218,"user_id":null,"body":"import scala.annotation.tailrec\nobject Johnann {\n\n  def john(n: Long): String = {\n    @tailrec\n    def helper(n: Long, a: Array[Int] = Array(1), j: Array[Int] = Array(0)): Array[Int] = {\n      if (n == j.length) {\n        j\n      }\n      else if (a.length == j.length) {\n        helper(n,  a , j :+ (j.length - a(j(j.length - 1))))\n      }\n      else {\n        helper(n,  a :+ (a.length - j(a(a.length - 1))), j )\n      }\n    }\n    helper(n).mkString(\", \")\n  }\n\n  def ann(n: Long): String = {\n    @tailrec\n    def helper(n: Long, a: Array[Int] = Array(1), j: Array[Int] = Array(0)): Array[Int] = {\n      if (n == a.length) {\n        a\n      }\n      else if (a.length == j.length) {\n        helper(n,  a , j :+ (j.length - a(j(j.length - 1))))\n      }\n      else {\n        helper(n,  a :+ (a.length - j(a(a.length - 1))), j )\n      }\n\n    }\n    helper(n).mkString(\", \")\n  }\n\n  def sumJohn(n: Long): Long = john(n).split(\", \").map(x => x.toLong).sum\n\n  def sumAnn(n: Long): Long = ann(n).split(\", \").map(x => x.toLong).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5769b3802ae6f8e4890009d2":[{"id":335219,"user_id":573,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] =\n    list.zipWithIndex.collect { case (x, i) if i%2==0 => x }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335220,"user_id":3282,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] = \n    list match {\n      case Nil => Nil\n      case x :: Nil => x :: Nil\n      case x :: y :: tail => x :: remove_every_other(tail)\n    }   \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335221,"user_id":573,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] =\n    list.grouped(2).map(_(0)).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335222,"user_id":573,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] =\n    list.grouped(2).map(_.head).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335223,"user_id":null,"body":"object Kata {\n\n    def remove_every_other[T](list: List[T]): List[T] ={\n        var x=false;\n        list.filter( none => { x= !x; x} )\n      } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335224,"user_id":null,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] = {\n  val listArray = for(i <- 0 until list.length by 2)\n    yield list(i)\n    \n    listArray.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335225,"user_id":null,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] = list match {\n    case Nil => Nil\n    case x::Nil => x::Nil\n    case x0::x1::xs => x0::remove_every_other(xs)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335226,"user_id":null,"body":"object Kata {\n  def remove_every_other[T](list: List[T]): List[T] =\n    list.zipWithIndex\n      .filter { case (e, i) => i % 2 == 0 }\n      .map { case (e, i) => e }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335227,"user_id":null,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] = {\n    list match {\n      case Nil => Nil\n      case x::Nil => List(x)\n      case x::y::t => x :: remove_every_other(t)  \n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335228,"user_id":null,"body":"object Kata {\n\n  def remove_every_other[T](list: List[T]): List[T] = list.sliding(1, 2).flatten.toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"576bb71bbbcf0951d5000044":[{"id":335229,"user_id":527,"body":"object Kata {\n\n  def count_positives_sum_negatives(xs: Seq[Int]): (Int, Int) =\n    (xs.count(_ > 0), xs.filter(_ < 0).sum)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335230,"user_id":573,"body":"object Kata {\n\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) =\n    integers.partition(_ > 0) match { case (pos, neg) => (pos.size, neg.sum) }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335231,"user_id":null,"body":"object Kata {\n\n  \/\/ Expects (0, 0) for empty array\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) = {\n    (integers.count(_ > 0), integers.filter(_ < 0).sum)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335232,"user_id":null,"body":"object Kata {\n\n  \/\/ Expects (0, 0) for empty array\n  def count_positives_sum_negatives(input: Seq[Int]): (Int, Int) = {\n    if (input == null || input.length == 0) return (0, 0)\n\n      var pos = 0\n      var neg = 0\n    \n      for (i <- input) {\n        if (i > 0)\n          pos += 1\n        else\n          neg += i\n      }\n      \n      return (pos, neg)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335233,"user_id":null,"body":"object Kata {\n\n  \/\/ Expects (0, 0) for empty array\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) = {\n  \n    var pos = 0\n    var neg = 0\n\n    for (i <- integers) {\n      if (i>0) {\n        pos += 1\n      } else {\n        neg += i\n      }\n    }\n    \n    (pos,neg)\n    \n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335234,"user_id":null,"body":"object Kata {\n  def count_positives_sum_negatives: Seq[Int] => (Int, Int) = l => \n    l.foldLeft (0,0) ((t, i) => if (i>0) (t._1+1,t._2) else (t._1,t._2+i))\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335235,"user_id":null,"body":"object Kata {\n\n  \/\/ Expects (0, 0) for empty array\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) = {\n  val numPositives = integers.filter(x => x > 0).length\nval sumOfNegatives = integers.filter(x => x < 0).foldLeft(0){(acc, x) => acc + x }\n\n(numPositives, sumOfNegatives)\n  \n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335236,"user_id":null,"body":"object Kata {\n\n  \/\/ Expects (0, 0) for empty array\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) = \n    if integers.isEmpty then List.empty\n    val first = integers.count(_ > 0)\n    val second = integers.foldLeft(0)((x,y) => if y < 0 then x+y else x)\n    (first, second)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335237,"user_id":null,"body":"object Kata {\n\n  \/\/ Expects (0, 0) for empty array\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) = {\n      var countPositives:Int = 0\n      var sumNegatives:Int = 0\n      for(x <- integers) {\n        if( x > 0) countPositives += 1\n        else if(x < 0) sumNegatives += x \n      }      \n      return (countPositives, sumNegatives)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335238,"user_id":null,"body":"object Kata:\n  def count_positives_sum_negatives(integers: Seq[Int]): (Int, Int) =\n    val (positives, negatives) = integers.partition(x => x > 0)\n    (positives.length, negatives.sum)","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5772382d509c65de7e000982":[{"id":335239,"user_id":53,"body":"object Fibkind {\n\n  val cache = collection.mutable.Map[Long, Long]()\n  \n  def u(n: Long): Long = {\n    if (cache.size == 0) {\n      cache.update(0, 0);\n      cache.update(1, 1);\n      cache.update(2, 1);\n    }\n    return cache.getOrElseUpdate(n, {\n      u(n-u(n-1)) + u(n-u(n-2))\n    });\n  }\n  \n  def lengthSupUK(n: Int, k: Int): Long = {\n    return (1 to n).filter { i => u(i) >= k }.size;\n  }\n  \n  def comp(n: Int): Long = {\n    return (1 to n).filter { i => u(i) < u(i - 1) }.size;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335240,"user_id":null,"body":"import scala.collection.mutable\n\nobject Fibkind {\n  private val uMap: mutable.Map[Int, Int] = mutable.Map((1, 1), (2, 1))\n\n  def lengthSupUK(n: Int, k: Int): Long = (1 to n).count(i => u(i) >= k)\n\n  def comp(n: Int): Long = (2 to n).count(i => u(i) < u(i - 1))\n\n  def u(n: Int): Int = uMap.getOrElseUpdate(n, u(n - u(n - 1)) + u(n - u(n - 2)))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335241,"user_id":492,"body":"import java.util.ArrayList\nimport java.util.List\n\nobject Fibkind {\n\n  private def u1(n: Int): List[Integer] = {\n    val memu: List[Integer] = new ArrayList[Integer]()\n    memu.add(1)\n    memu.add(1)\n    var i: Int = 2\n    while (i < n) {\n      memu.add(memu.get(i - memu.get(i - 1)) + memu.get(i - memu.get(i - 2)))\n      i += 1\n    }\n    memu\n  }\n  def lengthSupUK(n: Int, k: Int): Long =\n    u1(n).stream().filter((x) => x >= k).toArray().length\n  def comp(n: Int): Long = {\n    val memu: List[Integer] = u1(n)\n    var prev: Int = 1\n    var cnt: Int = 0\n    var i: Int = 1\n    while (i < n) {\n      val cur: Int = memu.get(i)\n      if (cur < prev) {\n        cnt += 1\n      }\n      prev = cur\n      i += 1\n    }\n    cnt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335242,"user_id":null,"body":"\nobject Fibkind {\n\n  def lengthSupUK(n: Int, k: Int): Long = {\n    u(n).count(_._2 >= k)\n  }\n\n  def comp(n: Int): Long = {\n    u(n).toList\n      .sorted\n      .map(_._2)\n      .sliding(2)\n      .count {\n        case a :: b :: Nil => a > b\n        case _ => false\n      }\n  }\n\n  def u(n: Long): Map[Long, Long] = {\n    if (n < 3) firstTwoElements\n    else {\n      (3L to n)\n        .foldLeft(firstTwoElements)((u, n) => u + (n -> (u(n - u(n - 1)) + u(n - u(n - 2)))))\n    }\n  }\n  \n  private val firstTwoElements = Map(1L -> 1L, 2L -> 1L)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335243,"user_id":null,"body":"object Fibkind {\n  def u(n: Int, current: Vector[Int]): Vector[Int] = {\n    val currentN = current.length\n    if (currentN >= n)\n    {\n      current\n    }\n    else\n    {\n      val list = current :+ (current(currentN+1 - current(currentN-1)-1) + current(currentN+1 - current(currentN-2)-1))\n      u(n, list)\n    }\n  }\n\n  def lengthSupUK(n: Int, k: Int): Long = {\n    u(n, Vector(1, 1)).count(_ >= k)\n  }\n  def comp(n: Int): Long = {\n    val list = u(n, Vector(1, 1))\n    list.zip(list.tail).count(x => x._1 > x._2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335244,"user_id":null,"body":"object Fibkind {\n\n  def generateNumbers(limit : Int): Array[Int] = {\n    var array = new Array[Int](limit+1)\n    array(0) = 0\n    array(1) = 1\n    array(2) = 1\n    for (i <- 3 until array.length) {\n      array(i) = array(i - array(i-2)) + array(i - array(i-1))\n    }\n    array\n  }\n\n  def lengthSupUK(u : Int, k : Int) : Int = {\n    val array = generateNumbers(u)\n    array.count(_ >= k)\n  }\n\n  def comp(n : Int) : Int = {\n    val array = generateNumbers(n)\n    array.sliding(2, 1).count(a => a(0) > a(1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335245,"user_id":null,"body":"object Fibkind {\n  def u(n: Int): Array[Int] = {\n    var fibo = new Array[Int](n)\n    fibo(0) = 1\n    fibo(1) = 1\n    \n    var i = 2\n    while(i < n) {\n      fibo(i) = fibo(i - fibo(i - 1)) + fibo(i - fibo(i - 2))\n      i += 1\n    }\n    fibo\n  }\n\n  def lengthSupUK(n: Int, k: Int): Long = {\n    var counter = 0\n    var fibo = u(n)\n    \n    for(i <- fibo if(i >= k)) \n       counter += 1\n    \n    counter\n  }\n  \n  def comp(n: Int): Long = {\n    var counter = 0\n    var fibo = u(n)\n    \n    for(i <- 2 until n if fibo(i) < fibo(i - 1)) \n      counter += 1\n    \n    counter\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335246,"user_id":626,"body":"import scala.annotation.tailrec\n\n\nobject Fibkind {\n\n\n  @tailrec\n  def u(n: Int, v: Vector[Int] = Vector(1, 1)): Vector[Int] = {\n\n    def next(v: Vector[Int]): Vector[Int] = {\n      val i = v.size\n      v :+ v(i - v(i - 1)) + v(i - v(i - 2))\n    }\n\n    if (v.size < n) u(n, next(v)) else v.take(n)\n  }\n\n  def lengthSupUK(n: Int, k: Int): Long =\n    u(n).count(_ >= k)\n\n  def comp(n: Int): Long = {\n    val us = u(n)\n    us.tail.zip(us.init).count({ case (a, b) => b > a })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335247,"user_id":null,"body":"object Fibkind {\n  @scala.annotation.tailrec\n  def uValues(size: Long, mem: Map[Long, Long] = Map(1L -> 1L, 2L -> 1L), idx: Long = 3L): Map[Long, Long] = {\n    val value = mem(idx - mem(idx - 1L)) + mem(idx - mem(idx - 2L))\n    val updatedMem = mem.updated(idx, value)\n    if (idx >= size) updatedMem\n    else uValues(size, updatedMem, idx + 1L)\n  }\n\n  def u(n: Long): Long = {\n    uValues(n)(n)\n  }\n\n  def lengthSupUK(n: Int, k: Int): Long = {\n    val arr = uValues(n)\n    Range.inclusive(1, n).count(arr(_) >= k)\n  }\n\n  def comp(n: Int): Long = {\n    val arr = uValues(n)\n    Range.inclusive(2, n).count(i => arr(i) < arr(i - 1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335248,"user_id":null,"body":"object Fibkind {\n\n  import scala.collection.mutable\n\n  val m: mutable.Map[Int, Int] = mutable.Map(1 -> 1, 2 -> 1)\n\n  def u(n: Int): Int = {\n    m.getOrElseUpdate(n, u(n - u(n - 1)) + u(n - u(n - 2)))\n  }\n\n  def lengthSupUK(n: Int, k: Int): Long = {\n    (1 to n).map(u).count(_ >= k).toLong\n  }\n\n  def comp(n: Int): Long = {\n    var i = 2\n    var r = 0\n    while (i <= n) {\n      if (u(i) < u(i - 1)) r += 1\n      i += 1\n    }\n    r.toLong\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"577bd026df78c19bca0002c0":[{"id":335249,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String =\n    s.map {\n      case '5' => 'S'\n      case '1' => 'I'\n      case '0' => 'O'\n      case x => x\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335250,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String =\n    s.replace('5', 'S')\n     .replace('1', 'I')\n     .replace('0', 'O')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335251,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n    val substitutions = Map(\n      '5' -> 'S',\n      '0' -> 'O',\n      '1' -> 'I'\n    )\n\n    s.map(c => substitutions.getOrElse(c, c))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335252,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = \n  s.map(\n    x => x.match{\n    case '5' => 'S'\n    case '0' => 'O'\n    case '1' => 'I'\n    case _ => x\n  })\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335253,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n    s.replaceAll(\"5\", \"S\").replaceAll(\"0\", \"O\").replaceAll(\"1\", \"I\")\n  }\n}\n  \n\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335254,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n      s.replace(\"0\",\"O\").replace(\"5\",\"S\").replace(\"1\",\"I\")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335255,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n    s.map {\n      case '5' => 'S'\n      case '0' => 'O'\n      case '1' => 'I'\n      case other => other\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335256,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n    s.map(x => if x == '5' then 'S' else if x == '0' then 'O' else if x == '1' then 'I' else x)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335257,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n    val replacements = Map(\n      '5' -> 'S',\n      '0' -> 'O',\n      '1' -> 'I'\n    )\n    s.map(ch => replacements.getOrElse(ch, ch))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335258,"user_id":null,"body":"object Recognition {\n  def correct(s: String): String = {\n    var new_str = s.replace(\"5\", \"S\");\n    new_str = new_str.replace(\"0\", \"O\");\n    new_str = new_str.replace(\"1\", \"I\");\n    new_str\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57a049e253ba33ac5e000212":[{"id":335259,"user_id":573,"body":"object Kata {\n\n  def !(n: Int) = BigInt(1) to n product\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335260,"user_id":null,"body":"object Kata {\n\n  def !(n: Int): BigInt = {\n    def factHelper(num: Int, acc: BigInt = 1): BigInt = {\n      if (num <= 1) return acc\n      else factHelper(num - 1, acc * num)\n    }\n    factHelper(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335261,"user_id":null,"body":"object Kata {\n\n  def !(n: Int): BigInt = {\n    def go(n: Int, acc: BigInt): BigInt = {\n      n match {\n        case 0 => acc\n        case _ => go(n - 1, n * acc)\n      }\n    }\n    go(n, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335262,"user_id":573,"body":"object Kata {\n\n  def !(n: Int) = (BigInt(1) to n).product\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335263,"user_id":null,"body":"object Kata {\n\n  def !(n: Int): BigInt = if (n == 0) BigInt(1) else (1 to n).map(BigInt.apply).product\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335264,"user_id":null,"body":"object Kata {\n  def !(n: Int, acc: BigInt = 1): BigInt = n match {\n    case 0 => acc\n    case _ => Kata.!(n-1, acc * n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335265,"user_id":null,"body":"object Kata {\nimport scala.annotation.tailrec\n  \n  def !(n: Int): BigInt = {\n    @tailrec\n    def factorial(n: Int, currentVal: BigInt): BigInt =\n      if (n <= 1) currentVal\n      else factorial(n - 1, currentVal * n)\n\n    factorial(n, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335266,"user_id":null,"body":"object Kata {\n\n  def !(n: Int): BigInt = if(n>0) (BigInt(1) to n).product else 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335267,"user_id":null,"body":"object Kata {\n  def !(n: Int): BigInt = {\n    var f: BigInt = 1\n    for(i <- 1 to n)\n    {\n      f = f * i;\n    }\n    f\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335268,"user_id":null,"body":"object Kata {\n  def !(n: Int): BigInt = {\n    @annotation.tailrec\n    def fact(acc: BigInt, n: Int): BigInt = {\n      if(n <= 1) acc\n      else fact(acc * n, n - 1)\n    }\n    fact(1, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57a0e5c372292dd76d000d7e":[{"id":335269,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String) = str * times\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335270,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = {\n    val result = str*times\n    return result\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335271,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = List.fill(times)(str).mkString\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335272,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = {\n    val result = str * times\n    result\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335273,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = (1 to times).flatMap(x => str).mkString(\"\")\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335274,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = {\n    val result = (0 until times).map(x => str).mkString(\"\")\n    result\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335275,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String, acc: String = \"\"): String = times match {\n    case x if x <= 0 => acc\n    case _ => repeat_str(times - 1, str, acc + str)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335276,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = {\n    return str*times\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335277,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(times: Int, str: String): String = {\n   val result = if (times == 0) \"\"\n    else if (times == 1) str\n    else {\n       str +repeat_str(times - 1, str) \n      }\n    result\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335278,"user_id":null,"body":"object StringRepeat {\n  def repeat_str(t: Int, s: String): String = {\n    List.fill(t)(s).mkString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57a6633153ba33189e000074":[{"id":335279,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n    chars.distinct.map(c=>(c,chars.count(_ == c))).toList\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335280,"user_id":527,"body":"import scala.collection.mutable.LinkedHashMap\n\nobject Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n    val fs = LinkedHashMap[Char, Int]().withDefaultValue(0)\n    for (c <- chars) {\n        fs(c) += 1\n    }\n    fs.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335281,"user_id":3069,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n     chars.groupBy(identity)\n          .mapValues(_.length)\n          .toList\n          .sortBy(t => chars.indexOf(t._1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335282,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] =\n    chars.toCharArray.toList.map(x => (x, chars.count(_ == x))).distinct\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335283,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n    chars.toList\n      .groupBy(c => c)\n      .mapValues(_.size)\n      .toList\n      .sortBy({\n        case (c, _) => chars.indexOf(c)\n      })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335284,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n    (chars zip chars.toList.map(x => chars.count(_ == x))).distinct.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335285,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = chars.distinct.map(i => (i, chars.count(_==i))).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335286,"user_id":null,"body":"import scala.collection.immutable.ListMap\n\nobject Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n      def loop(s: String, m: ListMap[Char, Int]): List[(Char, Int)] = {\n          if(s.length == 0) m.toList\n          else loop(s.tail, m + (s.head -> (m.getOrElse(s.head, 0) + 1)))\n      }\n      loop(chars, ListMap())\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335287,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = \n  {\n      chars.distinct.map( chart => chars.filter( sm => sm.equals(chart)))\n                    .map( ltr => (ltr.charAt(0),ltr.length)).toList\n             \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335288,"user_id":null,"body":"object Kata {\n  def orderedCount(chars: String): List[(Char, Int)] = {\n    chars.groupBy(identity).mapValues(_.size).toList.sortBy { case (c, _) => \n    chars.indexOf(c)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57bfb0b1a02b27cb57000207":[{"id":335289,"user_id":527,"body":"object TTT50 {\n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    def numberOfPoles(distance: Int) =\n      1 + length \/ distance\n    def amountOfWork(newDistance: Int) =\n      numberOfPoles(oldDistance) + numberOfPoles(newDistance) - 2 * numberOfPoles(lcm(oldDistance, newDistance))\n    \n    newDistances.filter(_ < oldDistance) match {\n      case Seq() => None\n      case validNewDistances => Some(validNewDistances.minBy(amountOfWork))\n    }\n  }\n  \n  private def gcd(x: Int, y: Int): Int =\n    if (y == 0) x else gcd(y, x % y)\n  private def lcm(x: Int, y: Int): Int =\n    x * y \/ gcd(x, y)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335290,"user_id":null,"body":"import scala.collection.mutable.BitSet\n\nobject TTT50 {\n  private def dig(length: Int, distance: Int): BitSet = {\n    val bits = BitSet.empty\n    for (hole <- 0 to length by distance)\n      bits += hole\n    bits\n  }\n\n  def johnChoose(length: Int,\n                 oldDistance: Int,\n                 newDistances: Seq[Int]): Option[Int] = {\n    val oldHoles = dig(length, oldDistance)\n    val work = for {\n      newd <- newDistances\n      if newd < oldDistance\n      newHoles = dig(length, newd)\n      union = oldHoles | newHoles\n      intersection = oldHoles & newHoles\n      difference = union &~ intersection\n    } yield difference.size -> newd\n    if (work.isEmpty)\n      None\n    else\n      Some((work.min)._2)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335291,"user_id":null,"body":"object TTT50 {\n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    val cands = for (newDistance <- newDistances) yield {\n      val digg = holesToChange(length, newDistance, oldDistance)\n      val fill = holesToChange(length, oldDistance, newDistance)\n      (digg + fill, newDistance)\n    }\n    val prune = cands.zipWithIndex.map { case ((work, nd), ix) => (work, ix, nd) }\n                     .filter { case (_, _, nd) => nd < oldDistance }\n    if (prune.isEmpty) return None else Some(prune.min._3)\n  }\n\n  def holesToChange(length: Int, space1: Int, space2: Int): Int = \n    length \/ space1 - length \/ lcm(space1, space2)\n\n  def lcm(a: Int, b: Int): Int = a * b \/ gcd(a, b)\n\n  def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335292,"user_id":null,"body":"object TTT50 {\n  def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n  \n  def lcm(a: Int, b: Int): Int = a*b\/gcd(a, b)\n  \n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    val valid = newDistances.filter(_ < oldDistance).sorted\n    if (valid.length == 0) None\n    else Some(valid.map(x => (x, length\/x + length\/oldDistance - 2 * length\/lcm(x, oldDistance))).minBy(_._2)._1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335293,"user_id":168,"body":"object TTT50 {\n  def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n  \n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    val d = newDistances.minBy(x => if (x >= oldDistance) length else {\n      val n = length \/ x + 1\n      val lcm = oldDistance * x \/ gcd(oldDistance, x)\n      n - 2 * length \/ lcm\n    })\n    if (d < oldDistance) Some(d) else None\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335294,"user_id":null,"body":"object TTT50 {\n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    val oldHoles = for {\n      i <- 0 to length by oldDistance\n    } yield i\n\n    newDistances.flatMap { newDistance =>\n      if (newDistance >= oldDistance) None\n      else {\n        val totalHolesInNewDistance = (length \/ newDistance) + 1\n        val (holesReused, holesToBury) = oldHoles.partition(_ % newDistance == 0)\n        val totalWork = totalHolesInNewDistance - holesReused.length + holesToBury.length\n\n        Some((totalWork, newDistance))\n      }\n    }.minOption.map(_._2)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335295,"user_id":null,"body":"object TTT50 {\n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    val nd = newDistances.filter(d => 0 < d && d < oldDistance).sorted\n    if (nd.isEmpty || oldDistance <= 0 && length <= 0) {\n      None\n    } else {\n      nd.minByOption { d =>\n        val nok: Int = (d * oldDistance) \/ gcd(oldDistance, d)\n        val n: Int   = length \/ d - length \/ nok\n        val b: Int   = length \/ oldDistance - length \/ nok\n        n + b\n      }\n    }\n  }\n\n  @scala.annotation.tailrec\n  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335296,"user_id":null,"body":"object TTT50 {\n    def johnChoose(length: Int,\n                   oldDistance: Int,\n                   newDistances: Seq[Int]): Option[Int] = {\n      val oldHoles = determineHoles(length \/ oldDistance, oldDistance)\n      def countEfficiency(oldHoles: List[Int], newHoles: List[Int]): Int = {\n        val commonHoles = oldHoles.intersect(newHoles)\n        (oldHoles.size + newHoles.size) - commonHoles.size*2\n      }\n      newDistances\n        .flatMap(\n          dist =>\n            if (dist >= oldDistance) None\n            else\n              Some(\n                (\n                  dist,\n                  countEfficiency(oldHoles, determineHoles(length \/ dist, dist))\n                )\n            )\n        )\n        .minByOption(_._2)\n        .map(_._1)\n    }\n\n    def determineHoles(count: Int, dist: Int): List[Int] = {\n      def buildHoles(curCounter: Int, curHoles: List[Int]): List[Int] = {\n        if (curCounter == 0) 0 +: curHoles\n        else buildHoles(curCounter - 1, curCounter * dist +: curHoles)\n      }\n      buildHoles(count, List())\n    }\n  }\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335297,"user_id":null,"body":"object TTT50 {\n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    \n    val oldHoles = (0 to length by oldDistance)\n    \n    val costs = for {\n      d <- newDistances \n      if d < oldDistance\n    } yield {\n      val overlap = oldHoles.count(_%d == 0)\n      (d, length\/d + length - 2*overlap)\n    }\n    \n    if (costs.nonEmpty) Some(costs.minBy(_._2)._1)\n    else None\n     \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335298,"user_id":1228,"body":"object TTT50 {\n  def johnChoose(length: Int, oldDistance: Int, newDistances: Seq[Int]): Option[Int] = {\n    var frg = length\n    var ans: Option[Int] = None\n    for (d <- newDistances) {\n      if (d < oldDistance) {\n        val h = (for (i <- 0 to length if i%d==0 ^ i%oldDistance==0) yield 1).sum\n        if (h < frg) {\n          frg = h\n          ans = Some(d)\n        }\n      }\n    }  \n    ans\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57cc975ed542d3148f00015b":[{"id":335299,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any) = seq.contains(elem)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335300,"user_id":573,"body":"object Solution {\n\n  def solution(seq: Seq[Any], e: Any) = seq contains e\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335301,"user_id":574,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any) = seq contains elem\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335302,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any): Boolean = {\n      for ( e <- seq ) \n      if (e == elem) return true\n    false\n    }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335303,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Solution {\n  @tailrec\n  def solution(seq:Seq[Any], elem: Any): Boolean = {\n    if (seq.isEmpty) false\n    else if (seq.head == elem) true\n    else solution(seq.tail, elem)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335304,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any) = seq.count(_ == elem) > 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335305,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any) = {\n    val x = seq.collectFirst{case x if x == elem => true}\n    x match {\n      case Some(_) => true\n      case None => false\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335306,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any) = !seq.forall(_ != elem)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335307,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any): Boolean = seq match  {\n    case Nil => false\n    case x::xs => if (x==elem) true else solution(xs,elem)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335308,"user_id":null,"body":"object Solution {\n  def solution(seq:Seq[Any], elem: Any) = {\n    var x: Int = 0\n    seq.foreach((arg: Any) => if (arg == elem) {\n      x += 1\n    })\n    x > 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57cc981a58da9e302a000214":[{"id":335309,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int) = n.forall(_ <= l)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335310,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int) = n.max <= l\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335311,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int): Boolean  = \n  if (n.isEmpty) true else (n.head <= l) && smallEnough(n.tail,l)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335312,"user_id":null,"body":"object Kata {\n\tdef smallEnough(n: Seq[Int], l: Int) = n.reduceLeft(_ max _) <= l\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335313,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int): Boolean = if(n.filter(_>l).isEmpty) true; else false\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335314,"user_id":null,"body":"object Kata {\n def smallEnough(n: Seq[Int], l: Int):Boolean = {\n    for(i <- n)\n      if(i > l)\n        return false\n    true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335315,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int): Boolean = {\n    if(n.filter(x => x <= l).size==n.size) true\n    else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335316,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int): Boolean = {\n    n.filter( _ <= l).size == n.size\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335317,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int): Boolean = !n.exists(_ > l)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335318,"user_id":null,"body":"object Kata {\n  def smallEnough(n: Seq[Int], l: Int): Boolean = {\n    n.max <= l\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57cebe1dc6fdc20c57000ac9":[{"id":335319,"user_id":573,"body":"object Shortest {\n\n  def find_short(str: String): Int = str.split(' ').map(_.size).min\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335320,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = (str split \" \" map (_.length)).min\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335321,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = str.split(\" \").map(i => i.length).toList.min\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335322,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = str.split(\"\\\\s+\").map(_.length).min\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335323,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = str.split(\"\\\\s\").map(_.length).min\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335324,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = {\n    str.split(\"\\\\s\").map(word => word.length).toList.min\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335325,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = str.split(\" \").minBy(_.length).length\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335326,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = {\n    val tempList = str.split(\" \").toList\n    val finalAnswer = tempList.map(x => x.length).min\n    finalAnswer\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335327,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = {\n    val strList = str.split(\" \")\n    var minimum = strList(0).length()\n    strList.foreach(s => {\n       if (minimum > s.length()) {\n         minimum = s.length()\n       }\n    })\n    minimum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335328,"user_id":null,"body":"object Shortest {\n\n  def find_short(str: String): Int = {\n    var len = str.length\n    str.split(\" \").foreach(x=>if(x.length<len) len=x.length)\n    len\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57da675dfa96908b16000040":[{"id":335329,"user_id":573,"body":"object Kata {\n\n  def concatOption(first: Option[String], second: Option[String]) =\n    for { x <- first; y <- second } yield s\"$x $y\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335330,"user_id":null,"body":"object Kata {\n  def concatOption(first: Option[String], second: Option[String]) = {\n    if (first.isDefined & second.isDefined) Some(s\"${first.get} ${second.get}\") else None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335331,"user_id":573,"body":"object Kata {\n\n  def concatOption(first: Option[String], second: Option[String]) =\n    first zip second collectFirst { case (x, y) => s\"$x $y\" }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335332,"user_id":527,"body":"object Kata {\n  def concatOption(first: Option[String], second: Option[String]) = {\n    for (s1 <- first; s2 <- second) yield s\"$s1 $s2\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335333,"user_id":573,"body":"object Kata {\n\n  def concatOption(first: Option[String], second: Option[String]) =\n    util.Try(s\"${first.get} ${second.get}\").toOption\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335334,"user_id":573,"body":"object Kata {\n\n  def concatOption(first: Option[String], second: Option[String]) =\n    first zip second map { case (x, y) => s\"$x $y\" }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335335,"user_id":null,"body":"object Kata {\n  def concatOption(first: Option[String], second: Option[String]) = {\n    (first, second) match {\n      case (Some(s1), Some(s2)) => Some(s1 + \" \" + s2)\n      case _ => None\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335336,"user_id":null,"body":"object Kata {\n  def concatOption(first: Option[String], second: Option[String]) = {\n    first match {\n      case None => None\n      case Some(x) => second match {\n        case Some(y) => Some(s\"$x $y\")\n        case None => None\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335337,"user_id":null,"body":"object Kata {\n  def concatOption(first: Option[String], second: Option[String]) = {\n    \/\/ Implement me\n        if (first==None || second==None) None else Some(s\"${first.get} ${second.get}\")\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335338,"user_id":null,"body":"object Kata {\n  def concatOption(first: Option[String], second: Option[String]) = {\n    if (first.isEmpty || second.isEmpty) None\n    else {\n      val firstS = first.getOrElse(\"\")\n      val secondS = second.getOrElse(\"\")\n      \n      Some(firstS + \" \" + secondS)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57e921d8b36340f1fd000059":[{"id":335339,"user_id":573,"body":"object HolidayViSharkPontoon {\n\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    val meToPontoonDuration = pontoon_distance \/ you_speed\n    val sharkToPontoonDuration = shark_distance \/ ((if (dolphin) 0.5 else 1) * shark_speed)\n    if (meToPontoonDuration < sharkToPontoonDuration) \"Alive!\" else \"Shark Bait!\"\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335340,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = if ( pontoon_distance \/ you_speed < (shark_distance \/ shark_speed) * (1+dolphin.compare(true)) ) \"Alive!\" else \"Shark Bait!\"\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335341,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    if (dolphin) {\n      if ((pontoon_distance \/ you_speed) < (shark_distance \/ (shark_speed*0.5))) \"Alive!\" else \"Shark Bait!\"\n    } else {\n      if ((pontoon_distance \/ you_speed) < (shark_distance \/ shark_speed)) \"Alive!\" else \"Shark Bait!\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335342,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    if (shark_distance ==0) \"Shark Bait!\"\n    else if (dolphin == false) {\n      if (pontoon_distance\/you_speed < (pontoon_distance+shark_distance)\/shark_speed) \"Alive!\"\n      else \"Shark Bait!\"\n    }\n    else {\n      if(pontoon_distance\/you_speed < (pontoon_distance+shark_distance)\/(shark_speed\/2)) \"Alive!\"\n      else \"Shark Bait!\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335343,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    val amIAlive =\n      if (dolphin) (pontoon_distance \/ 2) \/ you_speed < shark_distance \/ shark_speed\n      else pontoon_distance \/ you_speed < shark_distance \/ shark_speed\n\n    if(amIAlive) \"Alive!\" else \"Shark Bait!\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335344,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    val amIAlive: Boolean = if (dolphin) {\n      (pontoon_distance \/ 2) \/ you_speed < shark_distance \/ shark_speed\n    } else {\n      pontoon_distance \/ you_speed < shark_distance \/ shark_speed\n    }\n    if(amIAlive) \"Alive!\" else \"Shark Bait!\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335345,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    if (dolphin) {\n      if (2*pontoon_distance\/shark_speed < shark_distance\/shark_speed) \"Alive!\"\n      else \"Shark Bait!\"\n    }\n    else {\n      if (pontoon_distance\/you_speed < shark_distance\/shark_speed) \"Alive!\"\n      else \"Shark Bait!\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335346,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    if ((shark_speed \/ shark_distance) < (you_speed\/ pontoon_distance)) \n      \"Alive!\"\n    else \n      \"Shark Bait!\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335347,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    var sharkTime = shark_distance \/ shark_speed\n    val youTime = pontoon_distance \/ you_speed\n    if(dolphin) {sharkTime *= 2}\n    if(sharkTime > youTime) {return \"Alive!\"}\n    \"Shark Bait!\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335348,"user_id":null,"body":"object HolidayViSharkPontoon {\n  def shark(\n      pontoon_distance: Float,\n      shark_distance: Float,\n      you_speed: Float,\n      shark_speed: Float,\n      dolphin: Boolean\n  ): String = {\n    val d = if (dolphin)\n      shark_speed * 0.5\n    else\n      shark_speed\n    if (pontoon_distance \/ you_speed < shark_distance \/ d)\n      \"Alive!\"\n    else\n      \"Shark Bait!\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57ea5b0b75ae11d1e800006c":[{"id":335349,"user_id":573,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] =\n    arr.sortBy(_.length)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335350,"user_id":573,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] =\n    arr.sortBy(_.size)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335351,"user_id":null,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] = arr.sortBy(text => text.length())\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335352,"user_id":null,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] = {\n    val output = arr.map {elem => elem -> elem.length }.sortWith((lt, rt) => lt._2 < rt._2)\n\n    output.map { elem => elem._1 }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335353,"user_id":null,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] = {\n    arr.map(s => (s, s.length)).sortWith(_._2 < _._2).map(_._1).toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335354,"user_id":null,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] = {\n      arr.sortBy(it => it.length)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335355,"user_id":null,"body":"object Kata {\n  def sort_by_length(ss: Seq[String]): Seq[String] =\n    ss.sortBy(_.length)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335356,"user_id":null,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] = arr.sortBy(_.length)(_.compare(_))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335357,"user_id":null,"body":"object Kata {\n  val stringOrdering:Ordering[String] = Ordering.by(_.length)\n  def sort_by_length(arr: Seq[String]): Seq[String] = arr.sorted(stringOrdering)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"},{"id":335358,"user_id":null,"body":"object Kata {\n\n  def sort_by_length(arr: Seq[String]): Seq[String] = {\n    var sortedArr: Seq[String] = arr.map(x => (x, x.length)).sortBy(_._2).map(_._1)\n    \n    return sortedArr\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 18:25:28"}],"57eae20f5500ad98e50002c5":[{"id":335359,"user_id":573,"body":"object Kata {\n\n  def no_space(s: String): String =\n    s.replace(\" \", \"\")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335360,"user_id":573,"body":"object Kata {\n\n  def no_space(s: String): String =\n    s.filterNot(_.isWhitespace)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335361,"user_id":573,"body":"object Kata {\n\n  def no_space(s: String): String =\n    s.filter(_ != ' ')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335362,"user_id":null,"body":"object Kata:\n  def no_space(s: String): String = s.replace(\" \", \"\")","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335363,"user_id":468,"body":"object Kata {\n\n  def no_space(s: String): String = s.filterNot(_.isSpaceChar).mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335364,"user_id":null,"body":"object Kata {\n\n  def no_space(s: String): String = {\n    s.to(LazyList).filter(_ != ' ').mkString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335365,"user_id":null,"body":"object Kata {\n\n  def no_space(s: String): String = {\n   val stringWithNoEmptySpaces = s.split(' ').filter(_!=\"\").mkString(\"\")\n    stringWithNoEmptySpaces\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335366,"user_id":null,"body":"object Kata {\n\n  def no_space(s: String): String = {\n    var res = new StringBuilder()\n    for (i <- 0 until s.length)\n      if (s(i) != ' ') res += s(i)\n    res.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335367,"user_id":null,"body":"object Kata {\n\n  def no_space(s: String): String = {\n    var newStr = s.replaceAll(\"\\\\s\" , \"\")\n    return newStr\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335368,"user_id":null,"body":"object Kata {\n\n  def no_space(s: String): String = {\n    val array1 = s.toCharArray()\n    val res_array=array1.filter(_ != ' ')\n    val str=res_array.mkString(\"\")\n    str\n   \n    \n  }\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57eb8fcdf670e99d9b000272":[{"id":335369,"user_id":573,"body":"object Scoring {\n\n  def high(s: String): String = s.split(\" \").maxBy(_.map(_.toInt - 96).sum)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335370,"user_id":527,"body":"object Scoring {\n  def high(s: String): String = {\n    s.split(' ').maxBy(_.map(_ - 'a' + 1).sum)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335371,"user_id":573,"body":"object Scoring {\n\n  def high(s: String): String =\n    s.split(' ').maxBy(_.map(_ - 96).sum)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335372,"user_id":null,"body":"object Scoring {\n\n  val charScoreMap = ('a' to 'z').zipWithIndex.toMap.mapValues(_ + 1)\n  def high(s: String): String = {\n    \n    s.split(\" \").maxBy(_.toSeq.map(charScoreMap).sum)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335373,"user_id":null,"body":"object Scoring {\n  def high(s: String): String = {\n    val words = s.split(\" \")\n    val points = words.map((word: String) => {\n        word.toCharArray.map(_.toInt - 96).reduce(_+_)\n    })\n    val scores = words zip points\n    return scores.sortWith(_._2 > _._2)(0)._1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335374,"user_id":null,"body":"object Scoring {\n  def high(s: String): String = {\n    s.trim.toLowerCase.split(' ').maxBy(_.map(('a' to 'z').indexOf(_) + 1).sum)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335375,"user_id":null,"body":"object Scoring {\n  def high(s: String): String = {\n    val x = \"abcdefghijklmnopqrstuvwxyz\".toList\n    val charScore = (x zip (Stream from 1)).toMap\n    val y = s.split(\" \")\n    def wordScore(str: String, score: Map[Char,Int]): (String, Int) = {\n      var count = 0\n      for (char <- str) count += score(char)\n      (str, count)\n    }\n    \n    val scoreList = for (word <- y) yield wordScore(word, charScore)\n    \n    val highest = scoreList.maxBy(_._2)\n    \n    highest._1\n    \n    }\n    \n  }\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335376,"user_id":null,"body":"object Scoring {\n  def high(s: String): String = {\n    def score(w: String) = w.foldLeft(0)((a,c) => a+c-'a'+1)\n    s.split(' ')\n     .map(w => (w, score(w)))\n     .maxBy(_._2)\n     ._1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335377,"user_id":null,"body":"object Scoring {\n  def score (w: String): Tuple2[String, Int] = {\n    (w, w.map(_.toInt % 97 + 1).sum)\n  }\n  \n  def high(s: String): String = {\n    s.split(\" \").toList.map(w => score(w)).toList.maxBy(_._2)._1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335378,"user_id":null,"body":"object Scoring {\n  def high(s: String): String =\n    s.split(\" \").maxBy(evaluate)\n  \n  def evaluate(word: String) =\n    word.foldLeft(0)((acc, c) => acc + c - 'a' + 1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57eba158e8ca2c8aba0002a0":[{"id":335379,"user_id":573,"body":"object Kata {\n\n  def last(s: String): Array[String] =\n    s.split(' ').sortBy(_.last)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335380,"user_id":null,"body":"object Kata {\n\n   def last(s: String): Array[String] = s.split(\" \").sortBy(_.toCharArray.last)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335381,"user_id":null,"body":"object Kata {\n\n  def last(s: String): Array[String] = {\n    val new_string = s.split(\" \").map(i => i.reverse)\n    return new_string.sortBy(w=> w(0)).map(i => i.reverse)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335382,"user_id":null,"body":"object Kata {\n\n  def last(s: String): Array[String] = s.split(\" \").sortBy(_.last)(Ordering.Char)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335383,"user_id":null,"body":"object Kata {\n  def last(s: String): Array[String] =\n    s.split(\" \").toArray.sortWith(_.takeRight(1) < _.takeRight(1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335384,"user_id":null,"body":"object Kata {\n    def last(s: String): Array[String] = \n        s.split(\"\\\\s+\").sortWith(_.takeRight(1).charAt(0) < _.takeRight(1).charAt(0))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335385,"user_id":null,"body":"object Kata {\n\n  def last(s: String): Array[String] = {\n      val arr=s.split(\" \")\n      arr.sortWith(_.reverse.charAt(0)<_.reverse.charAt(0))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335386,"user_id":null,"body":"object Kata {\n  def last(s: String): Array[String] = s.split(\" \").sortBy(u => u.takeRight(1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335387,"user_id":null,"body":"object Kata {\n\n  def last(s: String): Array[String] = {\n     s.split(\" \").sortBy(x => x.takeRight(1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335388,"user_id":null,"body":"object Kata {\n\n  def last(s: String): List[String] = s.split(\" \").toList.sortWith((x,y) => x.last < y.last)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f780909f7e8e3183000078":[{"id":335389,"user_id":573,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long =\n    xs.product\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335390,"user_id":null,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long = xs.fold(1L)(_ * _)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335391,"user_id":null,"body":"object Kata {\n  def grow(xs: Seq[Long]): Long = xs.fold[Long](1)(_*_)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335392,"user_id":null,"body":"object Kata {\n\n def grow(xs: Seq[Long]): Long ={\n      def help(xs : Seq[Long] , sum : Long =1 ) : Long = xs match {\n        case List() => sum\n        case x:: r => help(r,sum*x)\n        case a :: Nil  => a * sum \n\n      }\n      help(xs)\n\n\n} }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335393,"user_id":null,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long = xs.fold(1.toLong)(_ * _)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335394,"user_id":null,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long =\n  {\n    if(xs.isEmpty) return 1\n    xs.head*grow(xs.tail)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335395,"user_id":null,"body":"import scala.math.Numeric\n\nobject Kata {\n\n  def grow(xs: Seq[Long]): Long = {\n    xs.product\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335396,"user_id":null,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long = {\n    var multiplicationResult: Long = 1\n    xs.foreach(number => multiplicationResult *= number)\n    \n    multiplicationResult\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335397,"user_id":null,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long =\n  {\n    def loop (x:Seq[Long], l:Int, m:Long=1): Long=\n    {\n      if (l<0) m else loop(x, l-1, m*x(l))\n    }\n    loop(xs,xs.length-1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335398,"user_id":null,"body":"object Kata {\n\n  def grow(xs: Seq[Long]): Long = {\n  var res:Long = 1\n  for (i <- 0 to xs.length-1) {\n    res *= xs(i)\n  }\n  return res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f781872e3d8ca2a000007e":[{"id":335399,"user_id":573,"body":"object Kata {\n\n  def maps(xs: List[Int]): List[Int] =\n    xs.map(_ * 2)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335400,"user_id":null,"body":"object Kata {\n\n  def maps(x: List[Int]) = x.map(_*2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335401,"user_id":null,"body":"object Kata {\n  def maps(xs: List[Int]): List[Int] = xs.map(i => i *2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335402,"user_id":null,"body":"object Kata {\n\n  def maps(xs: List[Int]): List[Int] = (xs,xs).zipped.map(_+_)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335403,"user_id":null,"body":"object Kata {\n\n  def maps(xs: List[Int]): List[Int] = for {\n    x <- xs\n  } yield x * 2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335404,"user_id":null,"body":"object Kata {\n\n  def maps(xs: List[Int]): List[Int] = {\n  var dupl = xs.flatMap(x => List.fill(1)(x*2))\n    dupl\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335405,"user_id":null,"body":"object Kata {\n\n  def maps(xs: List[Int]): List[Int] = {\n    def helper(xs: List[Int], new_xs: List[Int]) : List[Int] = {\n      if(xs.isEmpty){\n        new_xs\n      }\n      else{\n        helper(xs.tail, new_xs:+ xs.head* 2)\n      }\n    }\n    helper(xs, Nil)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335406,"user_id":null,"body":"object Kata {\n\n  def maps(xs: List[Int]): List[Int] = xs.map(s => s *2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335407,"user_id":null,"body":"object Kata {\n  def maps(xs: List[Int]): List[Int] =\n    xs.flatMap(x => List.fill(1)(x * 2))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335408,"user_id":null,"body":"object Kata:\n  def maps(xs: List[Int]): List[Int] =\n    xs.map(_ * 2)","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57fd696e26b06857eb0011e7":[{"id":335409,"user_id":null,"body":"object Kata {\n  def dative(word: String): String = {\n    val frontVowels = Set('e', '\u00e9', 'i', '\u00ed', '\u00f6', '\u0151', '\u00fc', '\u0171')\n    val frontSuffix = \"nek\"\n    val backVowels = Set('a', '\u00e1', 'o', '\u00f3', 'u', '\u00fa')\n    val backSuffix = \"nak\"\n    \n    val lastVowel = word.filter(c => frontVowels(c) || backVowels(c)).last\n    if (frontVowels(lastVowel)) word + frontSuffix\n    else word + backSuffix\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335410,"user_id":573,"body":"object Kata {\n\n  def dative(word: String): String =\n    word + word.reverse.find(\"a\u00e1o\u00f3u\u00fa\".contains(_)).fold(\"nek\")(_ => \"nak\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335411,"user_id":573,"body":"object Kata {\n\n  def dative(word: String): String =\n    s\"\"\"$word${if (\"e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171\".contains(word.filter(\"e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171a\u00e1o\u00f3u\u00fa\".toSet.contains).last)) \"nek\" else \"nak\"}\"\"\"\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335412,"user_id":2204,"body":"object Kata {\n  val frontVowels = List(\"e\", \"\u00e9\", \"i\", \"\u00ed\", \"\u00f6\", \"\u0151\", \"\u00fc\", \"\u0171\")\n  val backVowels = List(\"a\", \"\u00e1\", \"o\", \"\u00f3\", \"u\", \"\u00fa\")\n\n  def dative(word: String): String = {\n    word + word.reverseMap(c => \n      if (frontVowels.contains(c.toString)) Some(\"nek\")\n      else if (backVowels.contains(c.toString)) Some(\"nak\")\n      else None\n    ).flatten.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335413,"user_id":573,"body":"object Kata {\n\n  def dative(word: String): String =\n    s\"\"\"${word}n${word.reverse.find(\"a\u00e1o\u00f3u\u00fa\".contains(_)).fold('e')(_ => 'a')}k\"\"\"\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335414,"user_id":null,"body":"object Kata {\n  def dative(word: String): String = {\n    word + {\n      if (word.exists(\"a\u00e1o\u00f3u\u00fa\".contains(_))) \"nak\"\n      else if (word.exists(\"e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171\".contains(_))) \"nek\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335415,"user_id":null,"body":"object Kata {\n  def dative(word: String): String = {\n    var lastFrontIndex = -1\n    var lastBackIndex = -1\n    \nvar front =Array(\"e\", \"\u00e9\", \"i\", \"\u00ed\", \"\u00f6\", \"\u0151\", \"\u00fc\", \"\u0171\")\n\n var back = Array(\"a\", \"\u00e1\", \"o\", \"\u00f3\", \"u\", \"\u00fa\")\n    \n  \n\n    for(i <- 0 to 7){\n      if(word.indexOf(front(i)) > lastFrontIndex){lastFrontIndex=word.indexOf(front(i))}\n      }\n    \n    \n    for(j <- 0 to 5){\n      if(word.indexOf(back(j)) > lastBackIndex){lastBackIndex=word.indexOf(back(j))}\n      \n } \n         \n         if (lastFrontIndex>lastBackIndex){ word+\"nek\"}\n         \n         else{word+\"nak\"}\n         \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335416,"user_id":null,"body":"object Kata {\n  val VOWELS = Map(\"any\" -> \"e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171a\u00e1o\u00f3u\u00fa\", \"front\" -> \"e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171\", \"back\" -> \"a\u00e1o\u00f3u\u00fa\")\n  val ENDINGS = Map(\"front\" -> \"nek\", \"back\" -> \"nak\")\n\n  def dative(word: String): String = {\n    val last_vowel = word.filter(c => VOWELS(\"any\") contains c).last\n    if (VOWELS(\"front\") contains last_vowel) word ++ ENDINGS(\"front\")\n    else if (VOWELS(\"back\") contains last_vowel) word ++ ENDINGS(\"back\")\n    else word\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335417,"user_id":null,"body":"object Kata {\n  def dative(word: String): String = {\n    val frontVowels = List('e', '\u00e9', 'i', '\u00ed', '\u00f6', '\u0151', '\u00fc', '\u0171')\n    val backVowels = List('a', '\u00e1', 'o', '\u00f3', 'u', '\u00fa')\n    val vowels = frontVowels ::: backVowels\n    val lastVowel = word.findLast(vowels.contains(_)).get\n    if(frontVowels.contains(lastVowel)) word + \"nek\"\n    else word + \"nak\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335418,"user_id":null,"body":"object Kata {\n  def dative(word: String): String = \n  {\n    val numPattern = \"[e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171a\u00e1o\u00f3u\u00fa]+\".r\n    word + (\n      numPattern.findAllIn(word).toList.last match {\n        case x if (\"e\u00e9i\u00ed\u00f6\u0151\u00fc\u0171\".contains(x)) => \"nek\"\n        case x if (\"a\u00e1o\u00f3u\u00fa\".contains(x)) => \"nak\"\n        case _ => \"\"\n      })    \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5811aef3acdf4dab5e000251":[{"id":335419,"user_id":575,"body":"import scala.collection.immutable.HashMap;\nimport scala.collection.mutable.Queue;\nimport scala.math.BigInt;\n\nobject Kata {\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if(pattern.isEmpty || length == 0) return List[BigInt]()\n      \n    val patternMap = HashMap[String, Nacci] (\n      \"fib\" -> new Nacci(Queue[BigInt](0, 1)),\n      \"jac\" -> new Nacci(Queue[BigInt](0, 1), q => 2 * q.head + q.last),\n      \"pad\" -> new Nacci(Queue[BigInt](1, 0, 0), q => q.sum - q.last),\n      \"pel\" -> new Nacci(Queue[BigInt](0, 1), q => q.head + 2 * q.last),\n      \"tet\" -> new Nacci(Queue[BigInt](0, 0, 0, 1)),\n      \"tri\" -> new Nacci(Queue[BigInt](0, 0, 1)),\n    )\n    val generators = pattern.map(p => patternMap(p))\n    Stream.continually(generators.toStream).flatten.map(_.next).take(length).toList\n  }\n  class Nacci(val initialValues: Queue[BigInt], nextValue: Queue[BigInt] => BigInt = q => q.sum) {\n    def next(): BigInt = {\n      initialValues.enqueue(nextValue(initialValues))\n      initialValues.dequeue\n    }\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335420,"user_id":636,"body":"import scala.math.BigInt;\n\n\nobject Kata {\n  \n  case class MixBonacci (algo: List[BigInt] => BigInt, aInit: List[BigInt]) {\n    private def next (a: List[BigInt]) = a.tail.appended(algo(a))\n    def get(n: Int, a: List[BigInt] = aInit): BigInt =\n      if (n < a.length) a(n)\n      else get(n - 1, next(a))\n    val iterator = LazyList.iterate(aInit)(a => next(a)).map(x => x(0)).iterator\n  }\n  \n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    val fib = MixBonacci(f => f(1) + f(0), List[BigInt](0, 1))\n    val pad = MixBonacci(a => a(1) + a(0), List[BigInt](1, 0, 0))\n    val jac = MixBonacci(a => a(1) + 2*a(0), List[BigInt](0, 1))\n    val pel = MixBonacci(a => 2*a(1) + a(0), List[BigInt](0, 1))\n    val tri = MixBonacci(a => a(2) + a(1) + a(0), List[BigInt](0, 0, 1))\n    val tet = MixBonacci(a => a(3) + a(2) + a(1) + a(0), List[BigInt](0, 0, 0, 1))\n    println(s\"hello $pattern $length\")\n    def exec(nacci: String) = nacci match {\n      case \"fib\" => fib\n      case \"pad\" => pad\n      case \"jac\" => jac\n      case \"pel\" => pel\n      case \"tri\" => tri\n      case \"tet\" => tet\n    }\n    if (pattern.length == 0) List()\n    else \n     (for (i <- 0 until length) yield exec(pattern (i % pattern.length)).iterator.next).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335421,"user_id":null,"body":"object Kata{\n\n  case class Nacci(starters: Vector[BigInt], numOfStarters: Int, f: Vector[BigInt] => BigInt, currentIndex: Int = 0){\n    private def updateLastEl(el: BigInt):(BigInt, Nacci) = (el, Nacci(starters.tail :+ el, numOfStarters, f, currentIndex + 1))\n\n    def calcNextEl(): (BigInt, Nacci) = {\n      if(currentIndex < numOfStarters) (starters(currentIndex), Nacci(starters, numOfStarters, f, currentIndex + 1))\n      else updateLastEl(f(starters))\n    }\n  }\n\n\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n\n    def updateMap(map: Map[String, Nacci], key: String) = {\n      val (res, nNacci) = map(key).calcNextEl()\n      (res, map.updated(key, nNacci))\n    }\n\n    def mixbonacciAux(pattern: Vector[String], length: Int, seqMap: Map[String, Nacci],\n                      resAcc: List[BigInt] = List.empty[BigInt], currentPatternIndex: Int = 0): List[BigInt] = {\n      if(length <= 0) resAcc\n      else {\n        val (res, nMap) = updateMap(seqMap, pattern(currentPatternIndex))\n\n        val nPattIndex = if(currentPatternIndex + 1 >= pattern.size) 0 else currentPatternIndex + 1\n        mixbonacciAux(pattern, length - 1, nMap, resAcc :+ res, nPattIndex)\n      }\n    }\n\n    if(pattern.isEmpty) List.empty\n    else mixbonacciAux(pattern.toVector, length, Map(\n      \"fib\" -> Nacci(Vector(0,1), 2, vec => vec(0) + vec(1)),\n      \"pad\" -> Nacci(Vector(1, 0, 0), 3, vec => vec(0) + vec(1)),\n      \"pel\" -> Nacci(Vector(0, 1), 2, vec => vec(0) + vec(1)*2),\n      \"jac\" -> Nacci(Vector(0,1), 2, vec => vec(1) + vec(0)*2 ),\n      \"tri\" -> Nacci(Vector(0,0,1), 3, vec => vec(0) + vec(1) + vec(2)),\n      \"tet\" -> Nacci(Vector(0,0,0,1), 4, vec => vec(0) + vec(1) + vec(2) + vec(3))\n    ))\n\n  }\n\n\n\n\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335422,"user_id":null,"body":"object Kata {\n  lazy val fibs: LazyList[BigInt] = BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { n => n._1 + n._2 }\n  lazy val jacs: LazyList[BigInt] = BigInt(0) #:: BigInt(1) #:: jacs.zip(jacs.tail).map { n => 2 * n._1 + n._2 }\n  lazy val pads: LazyList[BigInt] = BigInt(1) #:: BigInt(0) #:: BigInt(0) #:: pads.zip(pads.tail).map { n => n._1 + n._2 }\n  lazy val pels: LazyList[BigInt] = BigInt(0) #:: BigInt(1) #:: pels.zip(pels.tail).map { n => n._1 + 2 * n._2 }\n  lazy val tets: LazyList[BigInt] = BigInt(0) #:: BigInt(0) #:: BigInt(0) #:: BigInt(1) #:: tets.sliding(4).map(_.sum).to(LazyList)\n  lazy val tris: LazyList[BigInt] = BigInt(0) #:: BigInt(0) #:: BigInt(1) #:: tris.sliding(3).map(_.sum).to(LazyList)\n\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    val iterators: Map[String, Iterator[BigInt]] = Map(\n      \"fib\" -> fibs.iterator,\n      \"jac\" -> jacs.iterator,\n      \"pad\" -> pads.iterator,\n      \"pel\" -> pels.iterator,\n      \"tet\" -> tets.iterator,\n      \"tri\" -> tris.iterator\n    )\n    if (pattern.isEmpty || length == 0) List()\n    else Stream.continually(pattern.toStream).flatten.take(length).map(iterators(_).next()).toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335423,"user_id":1285,"body":"import scala.math.BigInt;\n\n\nobject Kata {\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if (pattern == Nil || pattern.isEmpty || length == 0) return List.empty\n\n    val fib = fibGenerator()\n    val padovan = padovanGenerator()\n    val jacobsthal = jacobsthalGenerator()\n    val pell = pellGenerator()\n    val trib = tribGenerator()\n    val tetra = tetraGenerator()\n\n    List.range(0, length)\n      .map(i => i % pattern.size)\n      .map(i => pattern(i) match {\n        case \"fib\" => fib()\n        case \"pad\" => padovan()\n        case \"jac\" => jacobsthal()\n        case \"pel\" => pell()\n        case \"tri\" => trib()\n        case \"tet\" => tetra()\n      })\n  }\n\n  def fibGenerator(): () => BigInt = {\n    var last: BigInt = 0\n    var current: BigInt = 1\n    def fib(): BigInt = {\n      val twoBack = last\n      val next = last + current\n      last = current\n      current = next\n      twoBack\n    }\n    fib\n  }\n\n  def padovanGenerator(): () => BigInt = {\n    var twoBack: BigInt = 1\n    var last: BigInt = 0\n    var current: BigInt = 0\n    def padovan(): BigInt = {\n      val threeBack = twoBack\n      val next = twoBack + last\n      twoBack = last\n      last = current\n      current = next\n      threeBack\n    }\n    padovan\n  }\n\n  def jacobsthalGenerator(): () => BigInt = {\n    var last: BigInt = 0\n    var current: BigInt = 1\n    def jacobsthal(): BigInt = {\n      val twoBack = last\n      val next = current + 2 * last\n      last = current\n      current = next\n      twoBack\n    }\n    jacobsthal\n  }\n\n  def pellGenerator(): () => BigInt = {\n    var last: BigInt = 0\n    var current: BigInt = 1\n    def pell(): BigInt = {\n      val twoBack = last\n      val next = 2 * current + last\n      last = current\n      current = next\n      twoBack\n    }\n    pell\n  }\n\n  def tribGenerator(): () => BigInt = {\n    var twoBack: BigInt = 0\n    var last: BigInt = 0\n    var current: BigInt = 1\n    def trib(): BigInt = {\n      val threeBack = twoBack\n      val next = twoBack + last + current\n      twoBack = last\n      last = current\n      current = next\n      threeBack\n    }\n    trib\n  }\n\n  def tetraGenerator(): () => BigInt = {\n    var threeBack: BigInt = 0\n    var twoBack: BigInt = 0\n    var last: BigInt = 0\n    var current: BigInt = 1\n    def tetra(): BigInt = {\n      val fourBack = threeBack\n      val next = threeBack + twoBack + last + current\n      threeBack = twoBack\n      twoBack = last\n      last = current\n      current = next\n      fourBack\n    }\n    tetra\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335424,"user_id":null,"body":"object Kata {\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if (pattern.isEmpty || length == 0) return Nil\n\n    type BI = BigInt\n    type B2 = (BigInt, BigInt)\n    type B3 = (BigInt, BigInt, BigInt)\n    type B4 = (BigInt, BigInt, BigInt, BigInt)\n  \n    val fs: Map[String, Iterator[BI]] = Map(\n      \"fib\" -> Iterator.unfold[BI, B2]((0, 1)) { case (a, b) => Some(a, (b, a + b)) },\n      \"pad\" -> Iterator.unfold[BI, B3]((1, 0, 0)) { case (a, b, c) => Some(a, (b, c, a + b)) },\n      \"jac\" -> Iterator.unfold[BI, B2]((0, 1)) { case (a, b) => Some(a, (b, 2 * a + b)) },\n      \"pel\" -> Iterator.unfold[BI, B2]((0, 1)) { case (a, b) => Some(a, (b, a + 2 * b)) },\n      \"tri\" -> Iterator.unfold[BI, B3]((0, 0, 1)) { case (a, b, c) => Some(a, (b, c, a + b + c)) },\n      \"tet\" -> Iterator.unfold[BI, B4]((0, 0, 0, 1)) { case (a, b, c, d) => Some(a, (b, c, d, a + b + c + d)) }\n    )\n\n    def sequence(pattern: List[String], length: Int): List[BigInt] = {\n      if (length == 0) return List()\n      val x :: xs = pattern\n      fs(x).next() :: sequence(xs :+ x, length - 1)\n    }\n\n    sequence(pattern, length)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335425,"user_id":null,"body":"import scala.math.BigInt;\n\n\nobject Kata {\n  \n  def fibonacci(n: Int, xs: List[BigInt] = List(0, 1)): List[BigInt] = {\n    if (n <= xs.length) xs\n    else fibonacci(n, xs :+ xs.takeRight(2).sum)\n  }\n  \n  def padovan(n: Int, xs: List[BigInt] = List(1, 0, 0)): List[BigInt] = {\n    if (n <= xs.length) xs\n    else padovan(n, xs :+ (xs(xs.length - 2) + xs(xs.length - 3)))\n  }\n  \n  def jacobsthal(n: Int, xs: List[BigInt] = List(0, 1)): List[BigInt] = {\n    if (n <= xs.length) xs\n    else jacobsthal(n, xs :+ (xs.takeRight(2).sum + xs(xs.length - 2)))\n  }\n  \n  def pell(n: Int, xs: List[BigInt] = List(0, 1)): List[BigInt] = {\n    if (n <= xs.length) xs\n    else pell(n, xs :+ (xs.takeRight(2).sum + xs.last))\n  }\n  \n  def tribonacci(n: Int, xs: List[BigInt] = List(0, 0, 1)): List[BigInt] = {\n    if (n <= xs.length) xs\n    else tribonacci(n, xs :+ xs.takeRight(3).sum)\n  }\n  \n  def tetranacci(n: Int, xs: List[BigInt] = List(0, 0, 0, 1)): List[BigInt] = {\n    if (n <= xs.length) xs\n    else tetranacci(n, xs :+ xs.takeRight(4).sum)\n  }\n  \n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    val fullPattern = List.fill(math.ceil(length.toFloat\/pattern.length).toInt)(pattern).flatten.take(length)\n    val counts = List(\"fib\", \"pad\", \"jac\", \"pel\", \"tri\", \"tet\").map(x => (x, fullPattern.count(_ == x))).toMap\n    val fibs = fibonacci(counts(\"fib\"))\n    val pads = padovan(counts(\"pad\"))\n    val jacs = jacobsthal(counts(\"jac\"))\n    val pels = pell(counts(\"pel\"))\n    val tris = tribonacci(counts(\"tri\"))\n    val tets = tetranacci(counts(\"tet\"))\n    \n    def mixAux(pattern: List[String], acc: List[BigInt] = List()): List[BigInt] = {\n      if (pattern.length == 0) {\n        acc\n      }\n      else {\n        val args = (pattern.last, pattern.dropRight(1).count(_ == pattern.last)) \n        val x = args._1 match {\n          case \"fib\" => fibs(args._2)\n          case \"pad\" => pads(args._2)\n          case \"jac\" => jacs(args._2)\n          case \"pel\" => pels(args._2)\n          case \"tri\" => tris(args._2)\n          case \"tet\" => tets(args._2)\n          case other => BigInt(0)\n        }\n        mixAux(pattern.dropRight(1), x +: acc)\n      }\n    }\n    mixAux(fullPattern)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335426,"user_id":null,"body":"import scala.math.BigInt\n\nobject Kata {\n  \n  @scala.annotation.tailrec\n  def go(acc: List[BigInt])(f: List[BigInt] => BigInt)(n: Int): BigInt =\n    if (n == 0)\n      acc.head\n    else\n      go(acc.tail :+ f(acc))(f)(n - 1)\n  \n  def seq(acc: List[BigInt])(f: List[BigInt] => BigInt): Int => BigInt =\n    go(acc)(f)(_)\n  \n  val fib = seq(List(0, 1)) { a =>\n    a.sum\n  }\n  \n  val pad = seq(List(1, 0, 0)) { a =>\n    a(0) + a(1)\n  }\n  \n  val jac = seq(List(0, 1)) { a =>\n    2 * a(0) + a(1)\n  }\n  \n  val pel = seq(List(0, 1)) { a =>\n    a(0) + 2 * a(1)\n  }\n  \n  val tri = seq(List(0, 0, 1)) { a => \n    a.sum\n  }\n  \n  val tet = seq(List(0, 0, 0, 1)) { a =>\n    a.sum\n  }\n  \n  val names = List(\"fib\", \"pad\", \"jac\", \"pel\", \"tri\", \"tet\")\n  \n  val namesWithIdxs = names.map(name => (name, 0)).toMap\n  \n  def findN(name: String, n: Int): BigInt = name match {\n    case \"fib\" => fib(n)\n    case \"pad\" => pad(n)\n    case \"jac\" => jac(n)\n    case \"pel\" => pel(n)\n    case \"tri\" => tri(n)\n    case \"tet\" => tet(n)\n    case _     => BigInt(0)\n  }\n  \n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] =\n    if (length == 0 || pattern.isEmpty)\n      Nil\n    else {\n      val patternLength = pattern.length\n      \n      (0 until length).foldLeft((List.empty[BigInt], namesWithIdxs)) { case ((list, map), i) =>\n        val idx  = i % patternLength\n        val name = pattern(idx)\n        \n        val n   = map(name)\n        val res = findN(name, n)\n        \n        (res :: list, map.updated(name, n + 1))\n      }._1.reverse\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335427,"user_id":null,"body":"import scala.math.BigInt;\n\n\nobject Kata {\n  case class State(n4: BigInt, n3: BigInt, n2: BigInt, n1: BigInt)\n\n  case class PatternParams(init: State, drop: Int, f: State => BigInt)\n\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if (pattern.isEmpty || length == 0) Nil else {\n      Iterator\n        .continually(pattern)\n        .flatten\n        .scanLeft((Map.empty[String, Iterator[BigInt]], BigInt(0))) { case ((iterators, _), pat) =>\n          iterators.get(pat) match {\n            case Some(it) => iterators -> it.next\n            case None =>\n              val it = mkIterator(pat)\n              (iterators + (pat -> it), it.next)\n          }\n        }\n        .map(_._2)\n        .slice(1, length + 1)\n        .toList\n    }\n  }\n\n  def getParams(pattern: String): PatternParams = pattern match {\n    case \"fib\" => PatternParams(State(0, 0, 0, 1), 2, t => t.n1 + t.n2)\n    case \"jac\" => PatternParams(State(0, 0, 0, 1), 2, t => t.n1 + 2 * t.n2)\n    case \"pad\" => PatternParams(State(0, 1, 0, 0), 1, t => t.n2 + t.n3)\n    case \"pel\" => PatternParams(State(0, 0, 0, 1), 2, t => 2 * t.n1 + t.n2)\n    case \"tet\" => PatternParams(State(0, 0, 0, 1), 0, t => t.n1 + t.n2 + t.n3 + t.n4)\n    case \"tri\" => PatternParams(State(0, 0, 0, 1), 1, t => t.n1 + t.n2 + t.n3)\n  }\n\n  def mkIterator(pattern: String): Iterator[BigInt] = {\n    val params = getParams(pattern)\n    Iterator\n      .iterate(params.init) { case st@State(_, n3, n2, n1) =>\n        State(n3, n2, n1, params.f(st))\n      }\n      .map(_.n4)\n      .drop(params.drop)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335428,"user_id":null,"body":"import scala.math.BigInt;\n\n\n\nobject Kata {\n  import scala.collection.mutable\n  import scala.collection.mutable.ArrayBuffer\n  import scala.math.BigInt\n\n  def mixbonacci(pattern: List[String], length: Int): List[BigInt] =\n    if (pattern.isEmpty || length < 1) {\n      List.empty[BigInt]\n    } else {\n      val counter = Array(0, 0, 0, 0, 0, 0)\n      val result  = ArrayBuffer.empty[BigInt]\n      (0 until length).foreach { i =>\n        pattern(i % pattern.length) match {\n          case \"fib\" =>\n            result += fibonacci(counter(0))\n            counter(0) += 1\n          case \"pad\" =>\n            result += padovan(counter(1))\n            counter(1) += 1\n          case \"jac\" =>\n            result += jacobsthal(counter(2))\n            counter(2) += 1\n          case \"pel\" =>\n            result += pell(counter(3))\n            counter(3) += 1\n          case \"tri\" =>\n            result += tribonacci(counter(4))\n            counter(4) += 1\n          case \"tet\" =>\n            result += tetranacci(counter(5))\n            counter(5) += 1\n        }\n      }\n\n      result.toList\n    }\n\n  private val fibonacciMap: mutable.Map[Int, BigInt]  = mutable.Map((0, 0), (1, 1))\n  private val padovanMap: mutable.Map[Int, BigInt]    = mutable.Map((0, 1), (1, 0), (2, 0))\n  private val jacobsthalMap: mutable.Map[Int, BigInt] = mutable.Map((0, 0), (1, 1))\n  private val pellMap: mutable.Map[Int, BigInt]       = mutable.Map((0, 0), (1, 1))\n  private val tribonacciMap: mutable.Map[Int, BigInt] = mutable.Map((0, 0), (1, 0), (2, 1))\n  private val tetranacciMap: mutable.Map[Int, BigInt] = mutable.Map((0, 0), (1, 0), (2, 0), (3, 1))\n\n  private def fibonacci(i: Int): BigInt =\n    fibonacciMap.getOrElseUpdate(i, fibonacci(i - 1) + fibonacci(i - 2))\n\n  private def padovan(i: Int): BigInt =\n    padovanMap.getOrElseUpdate(i, padovan(i - 2) + padovan(i - 3))\n\n  private def jacobsthal(i: Int): BigInt =\n    jacobsthalMap.getOrElseUpdate(i, jacobsthal(i - 1) + 2 * jacobsthal(i - 2))\n\n  private def pell(i: Int): BigInt =\n    pellMap.getOrElseUpdate(i, 2 * pell(i - 1) + pell(i - 2))\n\n  private def tribonacci(i: Int): BigInt =\n    tribonacciMap.getOrElseUpdate(i, tribonacci(i - 1) + tribonacci(i - 2) + tribonacci(i - 3))\n\n  private def tetranacci(i: Int): BigInt =\n    tetranacciMap.getOrElseUpdate(i, tetranacci(i - 1) + tetranacci(i - 2) + tetranacci(i - 3) + tetranacci(i - 4))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58184387d14fc32f2b0012b2":[{"id":335429,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.math.abs\n\nobject ApproxFloat {\n\n  \/** Computes f(x) = sqrt(1 + x) - 1 for x in the neighborhood of 0. *\/\n  def f(x: Double): Double = {\n    \/\/ accumulate terms of Maclaurin series using a recurrence relation\n    @tailrec def iter(acc: Double, n: Int, term: Double): Double = {\n      if (abs(term\/x) < 1e-12) {\n        acc + term\n      } else {\n        val next = - (2 * n - 1) * term * x \/ (2 * (n + 1))\n        iter(acc + term, n + 1, next)\n      }\n    }\n    iter(0, 1, x \/ 2)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335430,"user_id":492,"body":"object ApproxFloat {\n\n  def f(x: Double): Double = x \/ (1.0 + Math.sqrt(1.0 + x))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335431,"user_id":null,"body":"import scala.math.sqrt\nobject ApproxFloat {\n\/\/ if a is close to b, and a^2 - b^2 can reduce to something simple, then\n\/\/ a - b = (a^2 - b^2) \/ (a + b).\n\/\/ sqrt(1 + x) - 1 = (sqrt(1 + x)**2 - 1**2) \/ (sqrt(1 + x) + 1)\n\/\/ sqrt(1 + x) - 1 = x \/ (sqrt(1 + x) + 1)\n  def f(x: Double): Double = \n    x \/ (sqrt(1 + x) + 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335432,"user_id":null,"body":"object ApproxFloat {\n\n  def f(x: Double): Double =  x \/ (math.sqrt(1 + x) + 1)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335433,"user_id":null,"body":"import scala.math.sqrt\nobject ApproxFloat {\n  def f(x: Double): Double = \n    x \/ (sqrt(1 + x) + 1)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335434,"user_id":53,"body":"object ApproxFloat {\n\n  def f(x: Double): Double = {\n    return x \/ 2 - x * x \/ 8 + x * x * x \/ 16 - 5 * x * x * x * x \/ 128;\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335435,"user_id":null,"body":"object ApproxFloat {\n\n  def f(x: Double): Double = x \/ (1.0 + math.sqrt(1 + x))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335436,"user_id":null,"body":"object ApproxFloat {\n\n  def f(x: Double): Double = {\n    \/\/ z = sqrt(1 + x) - 1 \/\/ assume x >= -1\n    \/\/ then -1 + (z + 1)^2 = x\n    \/\/\n    \/\/ Near to x=0, we have\n    \/\/ f(0 + e) =~ f(0) + e * f'(0) + (e^2 \/ 2) * f''(0) + ..\n    \/\/\n    \/\/ Where, f(0) = 0\n    \/\/ f'(x) = (1\/2).(1 + x)^-1\/2 = (1\/2) for x=0\n    \/\/ f''(x) = (-1\/4)(1 + x)^(-3\/2) = (-1\/4) for x=0\n    \/\/ f'''(x) = (3\/8)(1+x)^(-5\/2) = 3\/8 for x=0\n    \n    1.0 *       scala.math.pow(x, 1) * (1.0 \/ 2) + \n    (1.0 \/ 2) * scala.math.pow(x, 2) * (-1.0 \/ 4) +\n    (1.0 \/ 6) * scala.math.pow(x, 3) * (3.0 \/ 8) +\n    (1.0 \/ 24) * scala.math.pow(x, 4) * (-15.0 \/ 16)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335437,"user_id":null,"body":"object ApproxFloat {\n\n  def f(x: Double): Double = x \/ (1 + Math.sqrt(1 + x))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335438,"user_id":null,"body":"object ApproxFloat {\n\n  def f(x: Double): Double = {\n    val temp = Math.sqrt(1 + x)\n    return x \/ (1 + temp)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"581ee0db1bbdd04e010002fd":[{"id":335439,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {    \n    val range = for (i <- (0 until n)) yield l + (u-l)*i\/n\n    val roundf: Double => Double = x => math.floor(f(x) * 100d) \/ 100d\n    range.map(roundf) mkString \", \"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335440,"user_id":492,"body":"import scala.collection.mutable.ListBuffer\n\nobject ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val res: ListBuffer[Double] = new ListBuffer[Double]()\n    var i: Int = 0\n    while (i < n) {\n      val d: Double = i * (u - l) \/ n.toDouble\n      val r: Double = f(l + d)\n      res += (Math.floor(r * 100.0) \/ 100.0) \n      i += 1\n    }\n    res.toList.mkString(\", \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335441,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val d = (u - l)\/(n.toDouble)\n    (1 to n).map(x => f(l + (x-1)*d)).map(x => math.floor((x * 100.0)) \/ 100.0).mkString(\", \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335442,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    \/\/ your code\n    (0 until n).map(x => l + x * (u - l)\/n).map(f).map(x => math.floor(x * 100d)\/100d).mkString(\", \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335443,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val d = (u - l) \/ n\n    (0 until n).map(i => round(f(l + i * d)).toString.replace(\",\", \".\")).mkString(\", \")\n  }\n\n  private def round(d: Double): Double = math.floor(d * 100.0) \/ 100.0\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335444,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val points = (0 until n).map(p => l + p * (u - l) \/ n).map(f)\n    points.map(d => math.floor(100d* d) \/ 100d).mkString(\", \") \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335445,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val h = (u - l) \/ n\n    (0 until n).map{ (k: Int) => math.floor(f(l + k * h) * 100) \/ 100.0 }.mkString(\", \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335446,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val d = (u - l) \/ n\n    \n    val seqVals = ListBuffer.empty[Double] \n    \n    l+=:seqVals\n      \n      for (i <- Range(1, n-1) )  {\n        \n        (seqVals.head+d)+=:seqVals\n      }\n    \n    val res = seqVals map(x => Math.floor(f(x) * 100.0)\/100.0) \n    \n    \n    val lastVal =  Math.floor(f(u - d) * 100.0)\/100.0\n    \n     res.reverse.mkString(\", \") +\", \"+ lastVal.toString()\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335447,"user_id":1228,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val inc = (u-l)\/n.toDouble\n    (0 until n)\n    .map(x => f(l + x.toDouble*inc))\n    .map(y => scala.math.floor(y.toDouble * 100.0) \/ 100.0)\n    .mkString(\", \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335448,"user_id":null,"body":"object ApproxInter {\n\n  def interp(f: Double => Double, l: Double, u: Double, n: Int): String = {\n    val d = (u-l)\/n.toDouble\n    (for (i <- 0 until n) yield (math.floor(f(l + i*d) * 100.0) \/ 100.0).toString).mkString(\", \")\n    \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"582c5382f000e535100001a7":[{"id":335449,"user_id":527,"body":"object ListParser {\n  def parse(nodes: String): Node = {\n    nodes.split(\" -> \").init.map(_.toInt).foldRight(null: Node)(Node)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335450,"user_id":null,"body":"object ListParser {\n    def parse(nodes: String): Node = {\n        val parts = nodes.split(\"\\\\s->\\\\s\")\n        parts.view(0, parts.length-1).foldRight(null: Node) { (p, tail) => Node(p.toInt, tail) }\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335451,"user_id":null,"body":"object ListParser { \n  def parse(nodes: String): Node = {\n    def parseRec(current: List[String]): Node =\n      current match {\n        case Nil => null\n        case hd :: tail => Node(hd.toInt, parseRec(tail))\n      }\n    val lst = nodes.split(\"->\").map(_.trim).toList\n    parseRec(lst.init)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335452,"user_id":null,"body":"object ListParser {\n  \n  def parse: String => Node = {\n    case s\"$a -> $b\" => Node(a.toInt, parse(b))\n    case \"null\" => null\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335453,"user_id":1285,"body":"object ListParser {\n    def parse(nodes: String): Node =\n      nodes.split(\" -> \")\n        .filter(_ != \"null\")\n        .map(c => c.toInt)\n        .foldRight(null.asInstanceOf[Node])(Node)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335454,"user_id":null,"body":"object ListParser {\n    def parse(nodes: String): Node = {\n      val arr = nodes.split(\" -> \").reverse.drop(1)\n      if (arr.size > 0) {\n        var node: Node = Node(arr(0).toInt)\n        for (num <- arr.drop(1)){\n        node = Node(num.toInt, node)\n        }\n        node\n      }\n      else null\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335455,"user_id":null,"body":"object ListParser {\n    def parse(nodes: String): Node = {\n      def recToNodes(numbers: List[Int]): Node =\n        numbers match {\n          case head :: tail => Node(head, recToNodes(tail))\n          case _ => null\n        }\n\n      recToNodes(nodes.split(\" -> \").dropRight(1).map(_.toInt).toList)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335456,"user_id":null,"body":"object ListParser {\n    def parse(nodes: String): Node = {\n      def parseAux(args: List[String]): Node = {\n        if(args(0) == \"null\") null \n        else Node(args(0).toInt, parseAux(args.drop(1)))\n      }\n      parseAux(nodes.split(\" -> \").toList)\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335457,"user_id":null,"body":"object ListParser {\n    def parse(nodes: String): Node = {\n      def loop[T](array: Array[T]): Node = {\n        if (array.length == 1) null\n        else Node(array.head.toString.toInt, loop(array.tail))\n      }\n\n      loop(nodes.split(\"->\").map(_.trim))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335458,"user_id":null,"body":"object ListParser {\n  def parse(nodes: String): Node = {\n    nodes.split(\" -> \").map {\n      case \"null\" => null\n      case x: String => Node(x.toInt, null)\n    }.reduceRight((a, b) => Node(a.data, b))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"583203e6eb35d7980400002a":[{"id":335459,"user_id":527,"body":"object Kata {\n  def count_smileys(strings: Seq[String]): Int =\n    strings.count(_.matches(\"[:;][-~]?[)D]\"))\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335460,"user_id":573,"body":"object Kata {\n\n  def count_smileys(vec: Seq[String]): Int =\n    \"[:;][-~]?[)D]\".r.findAllIn(vec.mkString).size\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335461,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int = vec.filter(i => i.matches(\"(:|;)(~|-|)(D|\\\\))\")).length\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335462,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int = {\n    val eye = List(\":\",\";\")\n    val nose = List(\"-\", \"~\")\n    val mount = List(\"D\", \")\")\n\n    val x = for(e <- eye; n <- nose; m <- mount) yield e + n + m\n    val y = for(e <- eye; m <- mount) yield e + m\n\n    val smileList = x ::: y\n\n    vec.toList.count(smileList.contains(_))\n    \n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335463,"user_id":null,"body":"object Kata {\n  \n  def isValid(smiley: String, length: Int): Boolean = {\n    val eyes = \":;\"\n    val nose = \"-~\"\n    val mouth = \")D\"\n  \n    length match {\n      case 2 => eyes.contains(smiley(0)) && mouth.contains(smiley(1))\n      case 3 => eyes.contains(smiley(0)) && nose.contains(smiley(1)) && mouth.contains(smiley(2))\n      case _ => false\n    }\n  }\n\n  def count_smileys(smileys: Seq[String]): Int = {\n    if (smileys.isEmpty) 0\n    else smileys.map(x => isValid(x, x.length)).count(_ == true)\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335464,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int = {\n    val reg = \"[:;][-~]?[)D]\".r\n    vec.count(reg.findFirstMatchIn(_) != None)\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335465,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int = {\n    val pattern = \"[:;][-~]*[)D]\".r\n    vec.foldLeft(0)((acc,x)=> acc + {x match { case pattern(_*) => 1 case _ => 0 }})\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335466,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int =\n    vec.map(s => \"^[:;][-~]?[)D]$\".r.findFirstIn(s).map(_ => 1).getOrElse(0)).sum\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335467,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int = {\n\n    val smileyRegex = \"\"\"[:;][~-]?[)D]\"\"\".r\n    vec.count(s => smileyRegex.pattern.matcher(s).matches)   \n\n}\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335468,"user_id":null,"body":"object Kata {\n  def count_smileys(vec: Seq[String]): Int = {\n    var res=0\n    vec.foreach(x =>\n      if (x.length==3) {\n        if ((x.contains(\"D\") || x.contains(\")\")) && (x.contains(\"-\") || x.contains(\"~\")) && (x.contains(\":\") || x.contains(\";\"))) res += 1\n      }else if((x.contains(\"D\") || x.contains(\")\")) && (x.contains(\":\") || x.contains(\";\"))) res+=1\n      )\n    res\n}\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"583710ccaa6717322c000105":[{"id":335469,"user_id":573,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = n * (8 + n%2)\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335470,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = {\n    n % 2 match {\n      case 0 => n * 8\n      case _ => n * 9\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335471,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = if(n%2!=0) n * 9 else n*8\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335472,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = n * 8 + (n % 2) * n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335473,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = \n  n match {\n    case x if x % 2 == 0 => n * 8\n    case other => n * 9\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335474,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = {\n    return (n * (8 + n % 2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335475,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = {\n    n match {\n      case _ if n % 2 == 0 => n * 8\n      case _ => n * 9\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335476,"user_id":null,"body":"object Operation extends App {\n\n  def simple_multiplication(n: Int): Int = {\n    var total = 0\n    if (n % 2 == 0){\n      total = n * 8\n    } else {\n      total = n * 9\n    }\n    total\n  }\n  print(simple_multiplication(8))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335477,"user_id":168,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = (8 + n % 2) * n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335478,"user_id":null,"body":"object Operation {\n\n  def simple_multiplication(n: Int): Int = n match {\n    case m if (m % 2 == 0) => n*8\n    case _                 => n*9\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5839edaa6754d6fec10000a2":[{"id":335479,"user_id":573,"body":"object Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char =\n    chars.head to chars.last diff chars head\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335480,"user_id":573,"body":"object Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char =\n    chars.sliding(2).collectFirst { case Array(a, b) if b != a + 1 => a + 1 }.get.toChar\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335481,"user_id":null,"body":"object Kata {\n\n   def find_missing_letter(chars: Array[Char]): Char = {\n   var ans: Char = ' '\n    for(i <- 0 until chars.length - 1 ) {\n      if(chars(i + 1).toInt - chars(i) != 1) {\n        var kek = chars(i).toInt + 1\n        return kek.toChar\n      }\n    }\n    return ans\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335482,"user_id":null,"body":"import scala.collection.immutable.NumericRange\nobject Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char = {\n    val alphabet = chars.head to chars.last\n    findMissing(chars, alphabet)\n  }\n\n  def findMissing(chars: Array[Char], alphabet: NumericRange[Char], count:Int = 0): Char = {\n    if (chars.head != alphabet(count)) alphabet(count)\n    else if (alphabet.end == alphabet(count)) throw new Exception(\"Given char array is complete!\")\n    else findMissing(chars.tail, alphabet, count + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335483,"user_id":null,"body":"object Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char = {\n    \n    val letters = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n\n    val arr = chars.map(_.toLower).map(letters.indexOf(_))\n    \n    def func_1(prev: Int) = (curr: Int) => curr - prev\n        \n    val arr_func = (arr.slice(1, arr.length) zip arr.slice(0, arr.length - 1).map(func_1(_))).filter(x => x._2(x._1) > 1)\n    \n    val missing = letters(arr_func(0)._1 - 1)\n    \n    if(chars(0).isUpper) missing.toUpper\n    else missing\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335484,"user_id":null,"body":"object Kata {\n  \n  private val alphabet = ('a' to 'z').toArray\n\n  def find_missing_letter(chars: Array[Char]): Char = {\n    val firstLetter = chars.charAt(0)\n    val normalizedAlphabet = alphabet.map(character => upperIfNeeded(firstLetter, character))\n    val indexOfFirstLetter = normalizedAlphabet.indexOf(firstLetter)\n    val slicedAlphabet = normalizedAlphabet.slice(indexOfFirstLetter, indexOfFirstLetter + chars.length)\n    slicedAlphabet.filterNot(chars.contains(_)).charAt(0)\n  }\n\n  private def upperIfNeeded(firstLetter: Char, character: Char) = {\n    if (firstLetter.isUpper)\n      character.toUpper\n    else character\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335485,"user_id":null,"body":"object Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char = {\n    val n = chars.last - chars.head + 1\n    val expectedSum = (chars.head + chars.last)*n\/2\n    val actualSum = chars.sum\n    (expectedSum - actualSum).toChar\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335486,"user_id":null,"body":"object Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char = {\n    val start = chars(0)\n    val end = chars(chars.size -1)\n    val fullL = (start to end)\n    val res = for{\n      n <- chars\n      c <- fullL if(!chars.exists(_==c))\n      }yield c\n      res.head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335487,"user_id":null,"body":"object Kata {\n\n  def find_missing_letter(chars: Array[Char]): Char = {\n   val helperChars = chars.map(c =>(c + 1).toChar)\n   helperChars.diff(chars).head\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335488,"user_id":null,"body":"object Kata {\n   def find_missing_letter(chars: Array[Char]): Char =\n      (chars\n        .map(_.toInt)\n        .reduceLeft((cur, next) => if (next - cur == 1) next else cur)+1).toChar\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58409435258e102ae900030f":[{"id":335489,"user_id":527,"body":"object Kata {\n\n  def parityBit(s: String): String =\n    s.split(\" \").map(b => if (b.count(_ == '1') % 2 == 0) b.init else \"error\").mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335490,"user_id":573,"body":"object Kata {\n\n  def parityBit(s: String): String =\n    s.split(' ').map { case x if x.count(_ == '1') % 2 == 0 => x.init case _ => \"error\" }.mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335491,"user_id":null,"body":"object Kata {\n\n  def parityBit(s: String): String = s.split(\" \").map{ x =>\n    x.count(_ == '1') % 2 match {\n      case 1 => \"error\"\n      case other => x.dropRight(1)\n    }    \n  }.mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335492,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject Kata {\n\n  def parityBit(s: String): String = {\n    \n    var list = new ListBuffer[String]()\n\n    for(a <- s.split(\" \")) {\n      if (a.takeRight(1) == \"1\" && a.dropRight(1).count(_ == '1') % 2 != 0) \n        list += a.dropRight(1)\n      else if (a.takeRight(1) == \"0\" && a.dropRight(1).count(_ == '1') % 2 == 0) \n        list += a.dropRight(1)\n      else \n        list += \"error\"\n    }\n    \n    list.mkString(\" \")\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335493,"user_id":null,"body":"object Kata {\n\n  def parityBit(s: String): String = s\n    .split(\" \")\n    .map(decodeChar(_))\n    .mkString(\" \")\n  \n  def decodeChar(s: String): String = {\n    val value = s.substring(0, 7)\n    val parity = s.charAt(7).asDigit\n    return if (value.count(_ == '1') % 2 == parity) value else \"error\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335494,"user_id":null,"body":"object Kata {\n\n  def parityBit(s: String): String =\n    s.split(\"\\\\s\")\n      .map { bs =>\n        val (bits, flag) = bs.splitAt(7)\n        if (bits.count(_ == '1') % 2 == flag.toInt) bits else \"error\"\n      }\n      .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335495,"user_id":209,"body":"object Kata {\n  def parityBit(s: String): String = {\n    s.split(\" \").map(x=>if (x.count(_ == '1') % 2 == 1)  \"error\" else x.slice(0, 7)).mkString(\" \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335496,"user_id":null,"body":"object Kata {\n\n  def parityBit(s: String): String = \n  {\n    s\n  .split(\" \")\n  .map(x=> (x.init,x.last) match\n  {\n    case x if  x._1.count(_=='1')%2 == x._2.asDigit => x._1\n    case _ => \"error\"\n  }).mkString(\" \")\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335497,"user_id":null,"body":"object Kata {\n\n  def parityBit(s: String): String = {\n    s.split(\"\\\\s\").map({\n      case x if x.count(x => x == '1') % 2 == 0 => x.slice(0,x.length-1)\n      case _ => \"error\"\n    }).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335498,"user_id":null,"body":"object Kata {\n\n  def parityBit(s: String): String =\n    s.split(\" \")\n      .map { word =>\n        val result = word.init\n        if (result.count(_ == '1') % 2 == word.last.asDigit) result else \"error\"\n      }\n      .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5848565e273af816fb000449":[{"id":335499,"user_id":573,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String =\n    text\n      .split(\" \")\n      .map {\n        case \"\" => \"\"\n        case w if w.size == 1 => w(0).toInt\n        case w if w.size == 2 => s\"${w(0).toInt}${w.tail}\"\n        case w => s\"${w(0).toInt}${w.last}${w.drop(2).dropRight(1)}${w(1)}\"\n      }\n      .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335500,"user_id":null,"body":"object Encrypt {\n  def encrypt_this(text: String): String = {\n    if(text.isEmpty) \"\"\n    else {\n        text.split(\" \").map(x=>{\n            x.head.toByte+\"\"+(x.length match {\n                case 1 => \"\"\n                case 2 => x.tail\n                case _ => x.last+x.slice(2,x.length-1)+x(1)\n            })\n        }).mkString(\" \")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335501,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = \n    text.split(\" \").map(word).mkString(\" \")\n  \n  def word(w: String): String = {\n    val ws = w.toList\n    if(ws.isEmpty) {\n      w\n    } else { \n      val z = ws.tail\n      val y = if(z.size<=1) {\n        z\n      } else {\n        z.last::z.tail.dropRight(1) ++ List(z.head)\n      }\n      \n      \"\"+ws.head.toInt+y.mkString(\"\")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335502,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = {\n    text.split(\"\\\\s\").map(t => {\n      val chars = t.toCharArray.toList.map(_.toString)\n      chars.length match {\n        case 0 => \"\"\n        case 1 => chars.head.toCharArray()(0).toInt.toString\n        case _ => {\n          val (second, last) = (chars(1), chars.last)\n          chars.updated(0, chars.head.toCharArray()(0).toInt.toString)\n            .updated(1, last)\n            .updated(chars.length - 1, second)\n            .mkString\n        }\n      }\n    }).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335503,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = {\n    text.split(\" \").map { word =>\n      word.toList.zipWithIndex.map { x =>\n        if (x._2 == 0)\n          x._1.toInt.toString\n        else if (x._2 == 1)\n          word.last.toString\n        else if (x._2 == word.length - 1)\n          word(1).toString\n        else\n          x._1.toString\n      }.mkString(\"\")\n    }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335504,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = \n    if (text.isEmpty) \n      \"\"\n    else\n      text.split(\" \")\n        .map(x => if (x.length > 2) s\"${x.head}${x.last}${x.tail.tail.init}${x.tail.head}\" else x)        \n        .map(x => x.head.toByte + x.tail)\n        .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335505,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = if (text.isEmpty) {\"\"} else {text.split(\" \").map(x => x.toCharArray.head.toInt.toString + x.drop(1).reverse.take(1) + x.drop(2).dropRight(1) + x.drop(1).dropRight(1).take(1)).mkString(\" \")}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335506,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = text.split(\" \").map(encryptWord).mkString(\" \")\n\n\ndef encryptWord(word: String): String = word.toSeq match {\n  case Seq(first) => s\"${first.toInt}\"\n  case Seq(first, second, tail @ _*) => \n    if (tail.isEmpty) s\"${first.toInt}$second\"\n    else s\"${first.toInt}${tail.last}${tail.init.mkString(\"\")}$second\"\n  case _ => \"\"\n}\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335507,"user_id":null,"body":"object Encrypt {\n\n  def encrypt_this(text: String): String = {\n    if (text.isEmpty) \"\"\n    else {\n      text.split(\" \").map(word => {\n      if (word.length == 1) word(0).toInt.toString\n      else if (word.length == 2) s\"${word(0).toInt}${word.tail}\"\n      else if (word.length == 3) s\"${word(0).toInt}${word(2)}${word(1)}\"\n      else {\n        val secondChar = word(1)\n        val headAsciiCode: Int = word(0).toInt\n        val lastChar = word.last\n        s\"${headAsciiCode}${lastChar}${word.substring(2, word.length-1)}${secondChar}\"\n      }\n    }).mkString(\" \")\n  }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335508,"user_id":null,"body":"object Encrypt {\ndef encrypt_this(text: String): String = {\n  if (text.nonEmpty) {\n    val heads = text.split(\" \").map(_.head.toByte)\n    val tails = text.split(\" \")\n      .map(_.tail)\n      .map(word => word.length match {\n        case 0 => \"\"\n        case 1 => word\n        case _ => word.last + word.slice(1, word.length-1) + word.head\n      })\n    heads.zip(tails).map(x => x._1 + x._2).mkString(\" \")\n  } else {\n    \"\"\n  }\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58485a43d750d23bad0000e6":[{"id":335509,"user_id":573,"body":"object Kata {\n\n  def fizzBuzzCuckooClock(time: String): String =\n    time.split(\":\").map(_.toInt) match {\n      case Array(hour, 0)                      => Array.fill(if (hour % 12 == 0) 12 else hour % 12)(\"Cuckoo\").mkString(\" \")\n      case Array(_, 30)                        => \"Cuckoo\"\n      case Array(_, 15|45)                     => \"Fizz Buzz\"\n      case Array(_, minute) if minute % 5 == 0 => \"Buzz\"\n      case Array(_, minute) if minute % 3 == 0 => \"Fizz\"\n      case _                                   => \"tick\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335510,"user_id":573,"body":"object Kata {\n\n  def fizzBuzzCuckooClock(time: String): String =\n    time match {\n      case s\"$hh:00\"                       => Array.fill(if (hh.toInt % 12 == 0) 12 else hh.toInt % 12)(\"Cuckoo\").mkString(\" \")\n      case s\"$hh:15\"                       => \"Fizz Buzz\"\n      case s\"$hh:30\"                       => \"Cuckoo\"\n      case s\"$hh:45\"                       => \"Fizz Buzz\"\n      case s\"$hh:$mm\" if mm.toInt % 5 == 0 => \"Buzz\"\n      case s\"$hh:$mm\" if mm.toInt % 3 == 0 => \"Fizz\"\n      case _                               => \"tick\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335511,"user_id":null,"body":"object Kata {\n  def fizzBuzzCuckooClock(time: String): String = {\n\n    val ta = time.split(\":\").map(_.toInt)\n    (ta(0) + 12, ta(1)) match {\n      case (h, 0) if (h % 12 == 0) => (1 until 12).foldLeft(\"Cuckoo\"){ case (a, _) => s\"$a Cuckoo\"}\n      case (h, 0) if (h % 12 != 0) => (1 until h % 12).foldLeft(\"Cuckoo\"){ case (a, _) => s\"$a Cuckoo\"}\n      case (_, 30) => \"Cuckoo\"\n      case (_, m) if (m % 15 == 0) => \"Fizz Buzz\"\n      case (_, m) if (m % 3 == 0) => \"Fizz\"\n      case (_, m) if (m % 5 == 0) => \"Buzz\"\n      case _ => \"tick\"\n    }\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335512,"user_id":null,"body":"object Kata {\n  def fizzBuzzCuckooClock(time: String): String = {\n    process(time)\n  }\n  \n  def process(time:String):String =\n  {\n    val timeSplt = time.split(\":\")\n    val hours = timeSplt(0).toInt\n    val minutes = timeSplt(1).toInt\n    \n    minutes match {\n      case zeroMin: Int if (hours == 0 && zeroMin == 0 || hours == 12 && zeroMin == 0  ) => (\"Cuckoo \" * 12).dropRight(1)\n      case otherZero: Int if (otherZero ==  0) => (\"Cuckoo \" * (hours % 12)).dropRight(1)\n      case half: Int if (half == 30) => \"Cuckoo\"\n      case fizzBuzz: Int if (fizzBuzz % 3 == 0 && fizzBuzz % 5 == 0) => \"Fizz Buzz\"\n      case fizz: Int if (fizz % 3 == 0) => \"Fizz\"\n      case buzz: Int if (buzz % 5 == 0) => \"Buzz\"\n      case _ => \"tick\"\n    }   \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335513,"user_id":null,"body":"import java.time.LocalTime\nimport java.time.format.DateTimeFormatter\nimport java.util.Locale\n\nobject Kata {\ndef fizzBuzzCuckooClock(time: String): String = {\n    val parser: DateTimeFormatter = DateTimeFormatter.ofPattern(\"hh:mm a\", Locale.ENGLISH)\n    val formatter: DateTimeFormatter = DateTimeFormatter.ofPattern(\"HH:mm\")\n    val timeFormatted: LocalTime = LocalTime.parse(time, formatter)\n    val timeParsed = timeFormatted.format(parser)\n    val h = timeParsed.substring(0,2).toInt\n    val m = timeParsed.substring(3,5).toInt\n    time match {\n      case time if (m != 00) => time match {\n        case time if (m == 30) => \"Cuckoo\"\n        case time if (m % 3 == 0 && m % 5 != 0 && m != 30) => \"Fizz\"\n        case time if (m % 5 == 0 && m % 3 != 0 && m != 30) => \"Buzz\"\n        case time if (m % 5 == 0 && m % 3 == 0 && m != 30) => \"Fizz Buzz\"\n        case _ => \"tick\"\n        }\n      case time if (h == 00) => (\"Cuckoo \" * 12).trim\n      case time if (h != 00) => (\"Cuckoo \" * h).trim\n      case _ => \"tick\"\n      }\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335514,"user_id":null,"body":"object Kata {\n  def fizzBuzzCuckooClock(time: String): String = {\n    case class Time(hour: Int, minute: Int) {\n      val clockHour: Int = if (hour % 12 == 0) 12 else hour % 12\n    }\n    \n    val hourMinute = time.split(\":\")\n    val myTime = Time(hourMinute(0).toInt, hourMinute(1).toInt)\n    \n    \n    if (myTime.minute == 30) \"Cuckoo\" \n    else if (myTime.minute == 0) List.fill(myTime.clockHour)(\"Cuckoo\").mkString(\" \")\n    else if (myTime.minute % 3 == 0 && myTime.minute % 5 == 0) \"Fizz Buzz\"\n    else if (myTime.minute % 3 == 0) \"Fizz\"\n    else if (myTime.minute % 5 == 0) \"Buzz\"\n    else \"tick\"\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335515,"user_id":220,"body":"object Kata {\n  def fizzBuzzCuckooClock(time: String): String = {\n    val ts = time.split(\":\")\n    val t = (ts(0).toInt, ts(1).toInt)\n    \n    t match {\n      case (h,0) => Seq.fill(if (h % 12 == 0) 12 else h % 12)(\"Cuckoo\").mkString(\" \")\n      case (_,30) => \"Cuckoo\"\n      case (_,m) if m%15==0 => \"Fizz Buzz\"\n      case (_,m) if m%5==0 => \"Buzz\"\n      case (_,m) if m%3==0 => \"Fizz\"\n      case _ => \"tick\"\n    }\n   \n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335516,"user_id":null,"body":"object Kata {\n  def fizzBuzzCuckooClock(time: String): String = {\n    val x = time.split(\":\").map(_.toInt)\n\n    val y:String =\n      if (x(1) == 0)\n        if(x(0) == 0) \"Cuckoo \" * 12\n        else if (x(0) > 12) \"Cuckoo \" * (x(0) - 12)\n        else \"Cuckoo \" * x(0)\n      else if (x(1) == 30) \"Cuckoo\"\n      else if (x(1)%3 == 0)\n        if (x(1)%5 == 0) \"Fizz Buzz\" else \"Fizz\"\n      else if (x(1)%5 == 0) \"Buzz\"\n      else \"tick\"\n\n    y.trim\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335517,"user_id":null,"body":"object Kata {\n  def fizzBuzzCuckooClock(time: String): String = {\n    val times: List[String] = time.split(\":\").toList\n    times match {\n      case _ if times(1) == \"00\" =>\n        if(times.head.toInt == 12 || times(0).toInt == 0) (1 to 12).map(i => \"Cuckoo \").mkString.trim\n        else if(times.head.toInt > 12) (1 to (times(0).toInt - 12).abs).map(i => \"Cuckoo \").mkString.trim\n        else (1 to times.head.toInt).map(i => \"Cuckoo \").mkString.trim\n      case _ if times(1) == \"30\" => \"Cuckoo\"\n      case _ if times(1).toInt % 3 == 0 && times(1).toInt % 5 == 0 => \"Fizz Buzz\"\n      case _ if times(1).toInt % 3 == 0 && times(1).toInt % 5 != 0 => \"Fizz\"\n      case _ if times(1).toInt % 3 != 0 && times(1).toInt % 5 == 0 => \"Buzz\"\n      case _ if times(1).toInt % 3 != 0 && times(1).toInt % 5 != 0 => \"tick\"\n    }\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335518,"user_id":null,"body":"object Kata {\n  def parseTime(s: String): (Int, Int) = {\n      val ps = s.split(\":\")\n                .map(x => x.toInt)\n    \n      (ps(0), ps(1))\n    }\n\n  def cuckoo(n: Int) =\n      List.fill(n)(\"Cuckoo\").mkString(\" \")\n\n  def fizzBuzzCuckooClock(time: String): String = parseTime(time) match {\n      case (hh, 0) if hh % 12 == 0 => cuckoo(12)\n      case (hh, 0) => cuckoo(hh % 12)\n      case (hh, 30) => \"Cuckoo\"\n      case (_, mm) if mm % 3 == 0 && mm % 5 == 0 => \"Fizz Buzz\"\n      case (_, mm) if mm % 3 == 0 => \"Fizz\"\n      case (_, mm) if mm % 5 == 0 => \"Buzz\" \n      case _ => \"tick\"\n    } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"585894545a8a07255e0002f1":[{"id":335519,"user_id":null,"body":"object Kata {\n    val nearestNeighbours: Map[Char, Seq[Char]] = Map(\n    ('A', Seq('B', 'D', 'E', 'F', 'H')),\n    ('B', Seq('A', 'C', 'E', 'D', 'F', 'G', 'I')),\n    ('C', Seq('B', 'F', 'E', 'D', 'H')),\n    ('D', Seq('A', 'G', 'E', 'B', 'H', 'C', 'I')),\n    ('E', Seq('A', 'B', 'C', 'D', 'F', 'G', 'H', 'I')),\n    ('F', Seq('C', 'I', 'E', 'B', 'H', 'G', 'A')),\n    ('G', Seq('D', 'H', 'E', 'F', 'B')),\n    ('H', Seq('G', 'I', 'E', 'D', 'F', 'C', 'A')),\n    ('I', Seq('F', 'H', 'E', 'D', 'B'))\n  )\n\n  val neighboursWithObstacle: Map[Char, Seq[(Char, Char)]] = Map(\n    ('A', Seq(('C','B'), ('I', 'E'), ('G', 'D'))),\n    ('B', Seq(('H', 'E'))),\n    ('C', Seq(('A','B'), ('G', 'E'), ('I', 'F'))),\n    ('D', Seq(('F', 'E'))),\n    ('E', Seq()),\n    ('F', Seq(('D', 'E'))),\n    ('G', Seq(('A','D'), ('C', 'E'), ('I', 'H'))),\n    ('H', Seq(('B', 'E'))),\n    ('I', Seq(('C','F'), ('A', 'E'), ('G', 'H')))\n  )\n\n  def charToIndex(char: Char): Int = char - 'A'\n\n  def go(start: Char, len: Int, visited: List[Boolean]): Int = len match {\n    case 0 => 0\n    case 1 => 1\n    case _ => {\n      val newVisited = visited.updated(charToIndex(start), true)\n      val neighbours = nearestNeighbours(start)\n      var res = 0\n      for (\n        i <- neighbours.indices\n      ) {\n        if (!newVisited(charToIndex(neighbours(i))))\n          res += go(neighbours(i), len - 1, newVisited)\n      }\n\n      val notNearNeighbours = neighboursWithObstacle(start)\n      if(notNearNeighbours.nonEmpty) {\n        for (i <- notNearNeighbours.indices) {\n          val end = notNearNeighbours(i)._1\n          val obs = notNearNeighbours(i)._2\n          if(newVisited(charToIndex(obs)) && !newVisited(charToIndex(end)))\n            res += go(end, len - 1, newVisited)\n        }\n      } else ()\n\n      res\n    }\n  }\n\n  def countPatternsFrom(f: Char, l: Int): Int =\n    if (l <= 0 || l > 9) 0\n    else {\n      go(f, l, List.fill(9)(false))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335520,"user_id":null,"body":"object Kata {\n  object Dots {\n    def dots: Map[Char, Dot] = Map[Char, Dot]('A' -> A, 'B' -> B, 'C' -> C, 'D' -> D, 'E' -> E, 'F' -> F, 'G' -> G, 'H' -> H, 'I' -> I)\n\n    sealed trait Dot {\n      def hasNoDirectWayTo: List[Dot] = this +: passingOverDots.map(_._2)\n\n      def directWays: List[Dot] = dots.toList.map(_._2).filterNot(hasNoDirectWayTo.contains)\n\n      def passingOverDots: List[(Dot, Dot)]\n\n      def hasWaysTo(usedList: List[Dot]): List[Dot] = {\n        val ways = directWays.filterNot(usedList.contains)\n        val filtered = passingOverDots.filter(item => usedList.contains(item._1) && !usedList.contains(item._2))\n        ways ++ filtered.map(_._2)\n      }\n\n      def waysCount(usedList: List[Dot]): Int = hasWaysTo(usedList).length\n    }\n\n    object A extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](B -> C, D -> G, E -> I)\n    }\n\n    object B extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](E -> H)\n    }\n\n    object C extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](B -> A, E -> G, F -> I)\n    }\n\n    object D extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](E -> F)\n    }\n\n    object E extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List.empty\n    }\n\n    object F extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](E -> D)\n    }\n\n    object G extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](D -> A, H -> I, E -> C)\n    }\n\n    object H extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](E -> B)\n    }\n\n    object I extends Dot {\n      def passingOverDots: List[(Dot, Dot)] = List[(Dot, Dot)](E -> A, F -> C, H -> G)\n    }\n  }\n\n\n  def countPatternsFrom(f: Char, l: Int): Int = {\n    if (l == 1) 1\n    else {\n      count(Dots.dots(f), l - 1)\n    }\n  }\n\n    def count(dot: Dots.Dot, l: Int, usedDots: List[Dots.Dot] = List.empty): Int = {\n      if (l == 1) dot.waysCount(usedDots)\n      else {\n        (for {\n          nextDot <- dot.hasWaysTo(usedDots)\n          ways = count(nextDot, l - 1, usedDots :+ dot)\n        } yield ways).sum\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335521,"user_id":null,"body":"object Kata {\n  def calcIndex(current: Char): Int = {\n    current - 'A'\n  }\n\n  val board: Map[Char, Seq[Char]] = Map(\n    'E' -> Seq('A', 'B', 'C', 'D', 'F', 'I', 'H', 'G'),\n    'B' -> Seq('A', 'C', 'D', 'E', 'F', 'G', 'I'),\n    'D' -> Seq('A', 'B', 'E', 'H', 'G', 'C', 'I'),\n    'H' -> Seq('G', 'D', 'E', 'F', 'I', 'C', 'A'),\n    'F' -> Seq('I', 'H', 'E', 'B', 'C', 'G', 'A'),\n    'A' -> Seq('B', 'D', 'E', 'H', 'F'),\n    'C' -> Seq('B', 'E', 'F', 'D', 'H'),\n    'G' -> Seq('D', 'E', 'H', 'B', 'F'),\n    'I' -> Seq('F', 'E', 'H', 'B', 'D')\n  )\n\n  val jumps: Map[Char, Seq[(Char, Char)]] = Map(\n    'A' -> Seq(('B', 'C'), ('E', 'I'), ('D', 'G')),\n    'C' -> Seq(('B', 'A'), ('E', 'G'), ('F', 'I')),\n    'I' -> Seq(('H', 'G'), ('F', 'C'), ('E', 'A')),\n    'G' -> Seq(('E', 'C'), ('D', 'A'), ('H', 'I')),\n    'B' -> Seq(('E', 'H')),\n    'D' -> Seq(('E', 'F')),\n    'F' -> Seq(('E', 'D')),\n    'H' -> Seq(('E', 'B'))\n  )\n  def traverse(\n      current: Char,\n      height: Int,\n      _visited: Seq[Boolean]\n  ): Int = {\n    if (height == 1) return 1\n    if (height < 1) return 0\n\n    val visited: Seq[Boolean] = _visited.updated(calcIndex(current), true)\n\n    val children = board(current)\n\n    var result = 0\n\n    children.foreach { child =>\n      {\n        if (!visited(calcIndex(child))) {\n          result = result + traverse(child, height - 1, visited)\n        }\n        ()\n      }\n    }\n    val childrenJumps = jumps.getOrElse(current, List.empty)\n\n    childrenJumps.foreach { case (cond, dest) =>\n      val isVisited = visited(calcIndex(cond))\n      val isDestNotVisited = !visited(calcIndex(dest))\n      if (isVisited && isDestNotVisited) {\n        result = result + traverse(dest, height - 1, visited)\n      }\n    }\n\n    result\n  }\n  def countPatternsFrom(start: Char, height: Int): Int = {\n    if (height <= 0 || height > 9) 0\n    else traverse(start, height, _visited = Vector.fill(9)(false))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335522,"user_id":null,"body":"object Kata {\n  def calcIndex(current: Char): Int = {\n    current - 'A'\n  }\n\n  val board: Map[Char, Seq[Char]] = Map(\n    'E' -> Seq('A', 'B', 'C', 'D', 'F', 'I', 'H', 'G'),\n    'B' -> Seq('A', 'C', 'D', 'E', 'F', 'G', 'I'),\n    'D' -> Seq('A', 'B', 'E', 'H', 'G', 'C', 'I'),\n    'H' -> Seq('G', 'D', 'E', 'F', 'I', 'C', 'A'),\n    'F' -> Seq('I', 'H', 'E', 'B', 'C', 'G', 'A'),\n    'A' -> Seq('B', 'D', 'E', 'H', 'F'),\n    'C' -> Seq('B', 'E', 'F', 'D', 'H'),\n    'G' -> Seq('D', 'E', 'H', 'B', 'F'),\n    'I' -> Seq('F', 'E', 'H', 'B', 'D')\n  )\n\n  val jumps: Map[Char, Seq[(Char, Char)]] = Map(\n    'A' -> Seq(('B', 'C'), ('E', 'I'), ('D', 'G')),\n    'C' -> Seq(('B', 'A'), ('E', 'G'), ('F', 'I')),\n    'I' -> Seq(('H', 'G'), ('F', 'C'), ('E', 'A')),\n    'G' -> Seq(('E', 'C'), ('D', 'A'), ('H', 'I')),\n    'B' -> Seq(('E', 'H')),\n    'D' -> Seq(('E', 'F')),\n    'F' -> Seq(('E', 'D')),\n    'H' -> Seq(('E', 'B'))\n  )\n  def traverse(\n      current: Char,\n      height: Int,\n      _visited: Seq[Boolean]\n  ): Int = {\n    if (height < 1) return 0\n    if (height == 1) return 1\n\n    val visited: Seq[Boolean] = _visited.updated(calcIndex(current), true)\n\n    val children = board(current)\n\n    var result = 0\n\n    children.foreach { child =>\n      {\n        if (!visited(calcIndex(child))) {\n          result = result + traverse(child, height - 1, visited)\n        }\n        ()\n      }\n    }\n    val childrenJumps = jumps.getOrElse(current, List.empty)\n\n    childrenJumps.foreach { case (cond, dest) =>\n      val isVisited = visited(calcIndex(cond))\n      val isDestNotVisited = !visited(calcIndex(dest))\n      if (isVisited && isDestNotVisited) {\n        result = result + traverse(dest, height - 1, visited)\n      }\n    }\n\n    result\n  }\n  def countPatternsFrom(start: Char, height: Int): Int = {\n    if (height <= 0 || height > 9) 0\n    else traverse(start, height, _visited = Vector.fill(9)(false))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335523,"user_id":null,"body":"object Kata {\n  def calcIndex(current: Char): Int = {\n    current - 'A'\n  }\n\n  val board: Map[Char, List[Char]] = Map(\n    'E' -> List('A', 'B', 'C', 'D', 'F', 'I', 'H', 'G'),\n    'B' -> List('A', 'C', 'D', 'E', 'F', 'G', 'I'),\n    'D' -> List('A', 'B', 'E', 'H', 'G', 'C', 'I'),\n    'H' -> List('G', 'D', 'E', 'F', 'I', 'C', 'A'),\n    'F' -> List('I', 'H', 'E', 'B', 'C', 'G', 'A'),\n    'A' -> List('B', 'D', 'E', 'H', 'F'),\n    'C' -> List('B', 'E', 'F', 'D', 'H'),\n    'G' -> List('D', 'E', 'H', 'B', 'F'),\n    'I' -> List('F', 'E', 'H', 'B', 'D')\n  )\n\n  val jumps: Map[Char, List[(Char, Char)]] = Map(\n    'A' -> List(('B', 'C'), ('E', 'I'), ('D', 'G')),\n    'C' -> List(('B', 'A'), ('E', 'G'), ('F', 'I')),\n    'I' -> List(('H', 'G'), ('F', 'C'), ('E', 'A')),\n    'G' -> List(('E', 'C'), ('D', 'A'), ('H', 'I')),\n    'B' -> List(('E', 'H')),\n    'D' -> List(('E', 'F')),\n    'F' -> List(('E', 'D')),\n    'H' -> List(('E', 'B'))\n  )\n  def traverse(\n      current: Char,\n      height: Int,\n      _visited: Seq[Boolean]\n  ): Int = {\n    if (height < 1) return 0\n    if (height == 1) return 1\n\n    val visited: Seq[Boolean] = _visited.updated(calcIndex(current), true)\n\n    val children = board(current)\n\n    var result = 0\n\n    children.foreach { child =>\n      {\n        if (!visited(calcIndex(child))) {\n          result = result + traverse(child, height - 1, visited)\n        }\n        ()\n      }\n    }\n    val childrenJumps = jumps.getOrElse(current, List.empty)\n\n    childrenJumps.foreach { case (cond, dest) =>\n      val isVisited = visited(calcIndex(cond))\n      val isDestNotVisited = !visited(calcIndex(dest))\n      if (isVisited && isDestNotVisited) {\n        result = result + traverse(dest, height - 1, visited)\n      }\n    }\n\n    result\n  }\n  def countPatternsFrom(start: Char, height: Int): Int = {\n    if (height <= 0 || height > 9) 0\n    else traverse(start, height, _visited = Vector.fill(9)(false))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335524,"user_id":null,"body":"object Kata {\n  val board: Map[Char, List[Char]] = Map(\n    'E' -> List('A', 'B', 'C', 'D', 'F', 'I', 'H', 'G'),\n    'B' -> List('A', 'C', 'D', 'E', 'F', 'G', 'I'),\n    'D' -> List('A', 'B', 'E', 'H', 'G', 'C', 'I'),\n    'H' -> List('G', 'D', 'E', 'F', 'I', 'C', 'A'),\n    'F' -> List('I', 'H', 'E', 'B', 'C', 'G', 'A'),\n    'A' -> List('B', 'D', 'E', 'H', 'F'),\n    'C' -> List('B', 'E', 'F', 'D', 'H'),\n    'G' -> List('D', 'E', 'H', 'B', 'F'),\n    'I' -> List('F', 'E', 'H', 'B', 'D')\n  )\n\n  val jumps: Map[Char, List[(Char, Char)]] = Map(\n    'A' -> List(('B', 'C'), ('E', 'I'), ('D', 'G')),\n    'C' -> List(('B', 'A'), ('E', 'G'), ('F', 'I')),\n    'I' -> List(('H', 'G'), ('F', 'C'), ('E', 'A')),\n    'G' -> List(('E', 'C'), ('D', 'A'), ('H', 'I')),\n    'B' -> List(('E', 'H')),\n    'D' -> List(('E', 'F')),\n    'F' -> List(('E', 'D')),\n    'H' -> List(('E', 'B'))\n  )\n  def traverse(\n      current: Char,\n      height: Int,\n      _visited: Map[Char, Boolean]\n  ): Int = {\n    if (height < 1) return 0\n    if (height == 1) return 1\n\n    val visited: Map[Char, Boolean] = _visited.updated(current, true)\n\n    val children = board(current)\n\n    var result = 0\n\n    children.foreach { child =>\n      {\n        if (!visited.getOrElse(child, false)) {\n          result = result + traverse(child, height - 1, visited)\n        }\n        ()\n      }\n    }\n    val childrenJumps = jumps.getOrElse(current, List.empty)\n\n    childrenJumps.foreach { case (cond, dest) =>\n      val isVisited = visited.getOrElse(cond, false)\n      val isDestNotVisited = !visited.getOrElse(dest, false)\n      if (isVisited && isDestNotVisited) {\n        result = result + traverse(dest, height - 1, visited)\n      }\n    }\n\n    result\n  }\n  \n  def countPatternsFrom(start: Char, height: Int): Int = {\n    if (height <= 0 || height > 9) 0\n    else traverse(start, height, _visited = Map.empty)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335525,"user_id":null,"body":"object Kata {\n  val cannotConnect: Set[(Int, Int)] = Set((0, 2), (3, 5), (6, 8), (0, 6), (1, 7), (2, 8), (0, 8), (2, 6))\n\n  def countPatternsFrom(f: Char, l: Int): Int = if (l <= 1) l else if (l > 9) 0 else {\n    val visited = Array.fill[Boolean](9)(false)\n\n    \/\/\u5173\u4e8e\u662f\u5426\u8de8\u8fc7\uff0c\u53ef\u4ee5\u901a\u8fc7 (\u8d77\u70b9+\u7ec8\u70b9)\/2 == \u4e2d\u95f4\u70b9 \u8bc4\u65ad\n    def canVisit(cur: Int, next: Int): Boolean = if (visited(next)) false\n    else if (cannotConnect.contains((cur, next)) || cannotConnect.contains((next, cur))) {\n      visited((cur + next) \/ 2) \/\/\u4e2d\u70b9\u5df2\u88ab\u8bbf\u95ee\uff0c\u53ef\u4ee5\u8de8\u8fc7\n    } else true \/\/\u6ca1\u88ab\u8bbf\u95ee\u8fc7\u4e14\u4e0d\u5728\u4e0d\u80fd\u8de8\u7684\u70b9\u91cc\uff0c\u53ef\u4ee5\u8bbf\u95ee\n\n    def dfs(cur: Int, leftStep: Int, matched: Int): Int = if (leftStep == 0) matched + 1 else (0 until 9)\n      .filter(canVisit(cur, _))\n      .foldLeft(matched)((c, next) => {\n        visited(next) = true\n        val newMatch = dfs(next, leftStep - 1, c)\n        visited(next) = false\n        newMatch\n      })\n\n    visited(f - 'A') = true\n    dfs(f - 'A', l - 1, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335526,"user_id":null,"body":"object Kata {\n  val cannotConnect: Set[(Int, Int)] = Set((0, 2), (3, 5), (6, 8), (0, 6), (1, 7), (2, 8), (0, 8), (2, 6))\n\n  \/**\n    * \u5173\u4e8e\u662f\u5426\u8de8\u8fc7\uff0c\u53ef\u4ee5\u901a\u8fc7 (\u8d77\u70b9+\u7ec8\u70b9)\/2 == \u4e2d\u95f4\u70b9 \u8bc4\u65ad\n    *\/\n  def countPatternsFrom(f: Char, l: Int): Int = if (l <= 1) l else {\n    val visited = Array.fill[Boolean](9)(false)\n\n    def canVisit(curIndex: Int, nextIndex: Int): Boolean = if (visited(nextIndex)) false\n    else if (cannotConnect.contains((curIndex, nextIndex)) || cannotConnect.contains((nextIndex, curIndex))) {\n      visited((curIndex + nextIndex) \/ 2) \/\/\u4e2d\u70b9\u5df2\u88ab\u8bbf\u95ee\uff0c\u53ef\u4ee5\u8de8\u8fc7\n    } else true \/\/\u6ca1\u88ab\u8bbf\u95ee\u8fc7\u4e14\u4e0d\u5728\u4e0d\u80fd\u8de8\u7684\u70b9\u91cc\uff0c\u53ef\u4ee5\u8bbf\u95ee\n\n    def dfs(curIndex: Int, leftStep: Int, matched: Int): Int = if (leftStep == 0) matched + 1 else {\n      (0 until 9)\n        .filter(canVisit(curIndex, _))\n        .foldLeft(matched)((c, nextIndex) => {\n          visited(nextIndex) = true\n          val newMatch = dfs(nextIndex, leftStep - 1, c)\n          visited(nextIndex) = false\n          newMatch\n        })\n    }\n\n    visited(f - 'A') = true\n    dfs(f - 'A', l - 1, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335527,"user_id":null,"body":"object Kata {\n  def countPatternsFrom(f: Char, l: Int): Int = {\n\n    def countRecursive(pos: Int, remaining: Set[Int], moves: Int): Int = {\n      val possibleMoves = Set(\n        \/\/Horizontal\n        pos+1,\n        pos-1,\n        \/\/Vertical\n        pos+10,\n        pos-10,\n        \/\/Short Diagonal\n        pos+11,\n        pos-11,\n        pos+9,\n        pos-9,\n        \/\/Short Imperfect Diagonal\n        pos+12,\n        pos-12,\n        pos+8,\n        pos-8,\n        \/\/Long Imperfect Diagonal\n        pos+21,\n        pos-21,\n        pos+19,\n        pos-19,\n      ) ++ Set(\n        \/\/PASSING OVER CONDITIONAL\n        \/\/Long Horizontal\n        if(!remaining.contains(pos+1)) Some(pos+2) else None,\n        if(!remaining.contains(pos-1)) Some(pos-2) else None,\n        \/\/Long Vertical\n        if(!remaining.contains(pos+10)) Some(pos+20) else None,\n        if(!remaining.contains(pos-10)) Some(pos-20) else None,\n        \/\/Diagonal long\n        if(!remaining.contains(pos+11)) Some(pos+22) else None,\n        if(!remaining.contains(pos-11)) Some(pos-22) else None,\n        if(!remaining.contains(pos+9)) Some(pos+18) else None,\n        if(!remaining.contains(pos-9)) Some(pos-18) else None\n      ).flatten\n\n      val availableMoves = possibleMoves.intersect(remaining)\n      if(moves == l-1) availableMoves.size\n      else availableMoves.toList.map(m => countRecursive(m, remaining.filterNot(_ == m), moves + 1)).sum\n    }\n\n    val pos = f match {\n      case 'A' => 1\n      case 'B' => 2\n      case 'C' => 3\n      case 'D' => 11\n      case 'E' => 12\n      case 'F' => 13\n      case 'G' => 21\n      case 'H' => 22\n      case 'I' => 23\n    }\n\n    if(l == 0) 0\n    else if(l == 1) 1\n    else if(l > 9) 0\n    else countRecursive(pos, Set(1,2,3,11,12,13,21,22,23).filterNot(_==pos), 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335528,"user_id":null,"body":"object Kata {\n  import scala.collection.mutable.ListBuffer\n\n  case class Connect(\n    usedLetters: List[Char] = Nil,\n    isConnected: Array[Array[Boolean]] = Array.fill(9)(Array.fill(9)(false))\n  ) {\n    val letters = \"ABCDEFGHI\"\n\n    def init() = {\n      for (row <- 0 to 8; col <- 0 to 8) {\n        val (rowX, rowY) = coords(letters(row))\n        val (colX, colY) = coords(letters(col))\n        isConnected(row)(col) = ((rowX - colX).abs == 1) | ((rowY - colY).abs == 1)\n      }\n    }\n\n    def update(ch: Char): Connect = {\n      val newObj = this.copy(ch :: usedLetters, isConnected.clone.map(_.clone))\n\n      def setConnection(coord1: (Int, Int), coord2: (Int, Int)) = {\n        val (idx1, idx2) = (index(coord1), index(coord2))\n        if (!newObj.usedLetters.contains(idx1 + 'A') && !newObj.usedLetters.contains(idx2 + 'A'))\n          { newObj.isConnected(idx1)(idx2) = true; newObj.isConnected(idx2)(idx1) = true }\n      }\n\n      for (row <- 0 to 8) newObj.isConnected(row)(ch - 'A') = false\n      for (col <- 0 to 8) newObj.isConnected(ch - 'A')(col) = false\n\n      val (x, y) = coords(ch)\n      \n      if (x == 1) setConnection((x - 1, y), (x + 1, y))\n      if (y == 1) setConnection((x, y - 1), (x, y + 1))\n      if (x == 1 && y == 1) { setConnection((0, 0), (2, 2)); setConnection((0, 2), (2, 0)) }\n\n      newObj\n    }\n\n    def coords(ch: Char): (Int, Int) = (\"ADGBEHCFI\".indexOf(ch) % 3, (ch - 'A') % 3)\n  \n    def index(coord: (Int, Int)): Int = { val (x, y) = coord; x * 3 + y }\n\n    def reachedFrom(ch: Char): List[Char] = {\n      val out = ListBuffer[Char]()\n      val row = ch - 'A'\n      for (col <- 0 to 8) if (isConnected(row)(col)) out += letters(col)\n      out.toList\n    }\n  }\n  \n  def countPatternsFrom(f: Char, l: Int): Int = { \n    if (l < 1 || l > 9) return 0\n    val connect = Connect()\n    connect.init()\n    count(List(f), l, connect)\n  }\n\n  def count(chars: List[Char], length: Int, connect: Connect): Int = {\n    if (length == 0) return 1\n  \n    (for (ch <- chars) yield {\n      val r = connect.reachedFrom(ch)\n      val u = connect.usedLetters\n      count(r, length - 1, connect.update(ch))\n    }\n    ).sum\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58630e2ae88af44d2b0000ea":[{"id":335529,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    wallLength % pixelSize == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335530,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    (wallLength.toFloat \/ pixelSize).isWhole\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335531,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    (wallLength, pixelSize) match{\n    case (a,b) if a % b == 0 => true\n    case (_,_) => false\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335532,"user_id":null,"body":"object Drills {\n  def isDivisible(w: Int, l: Int): Boolean = {\n    w % l == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335533,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    \/\/ your code\n    wallLength % pixelSize == 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335534,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    val divisible = wallLength\/pixelSize\n    if(wallLength % pixelSize == 0) true else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335535,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    if ((wallLength % pixelSize) == 0) {  \/\/checks if the remainder is 0 (will be 0 if the pixels fits exactly onto the wall)\n      true  \/\/returns True if so\n    } else {  \/\/goes through this conditional if statement if theres a remainder\n      false  \/\/returns False if so\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335536,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    var result = \"\"\n    if (wallLength % pixelSize == 0){ return true}\n    else {return false}\n    \/\/ your code\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335537,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    wallLength.abs % pixelSize.abs match {\n      case 0 => true\n      case _ => false\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335538,"user_id":null,"body":"object Drills {\n  def isDivisible(wallLength: Int, pixelSize: Int): Boolean = {\n    val ans = wallLength \/ pixelSize.toDouble\n    Math.floor(ans) == ans\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5868b2de442e3fb2bb000119":[{"id":335539,"user_id":573,"body":"object ClosestWeight {\n\n  def closest(input: String): Array[(Int, Int, Int)] = {\n    input.split(\" \") match {\n      case subs if subs.size < 2 =>\n        Array()\n      case subs =>\n        subs\n          .zipWithIndex\n          .map { case (s, i) => (s.map(_.asDigit).sum, i, s.toInt) }\n          .combinations(2)\n          .map(comb => comb.sortBy(x => (x._1, x._2)))\n          .minBy { case Array((w1, i1, _), (w2, i2, _)) => ((w1 - w2).abs, w1 + w2, i1 + i2) }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335540,"user_id":null,"body":"object ClosestWeight {\n\n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng.isEmpty) Array.empty\n    else {\n      val weights = strng.split(' ').zipWithIndex.map(x=>(x._1.map(_.asDigit).sum,x._2, x._1.toInt)).sortBy(x=>x._1)\n      val pairs = weights.zip(weights.tail)\n      val closestPair = pairs.minBy(x => x._2._1 - x._1._1)\n      Array(closestPair._1, closestPair._2)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335541,"user_id":null,"body":"object ClosestWeight {\n  private def weightCalculator(x: (Int, Int, Int), y: (Int, Int, Int)) =\n    ((x._1 - y._1).abs, x._1 + y._1, x._2 + y._2)\n\n  private def returnSmallest(x: Array[(Int, Int, Int)], y: Array[(Int, Int, Int)]) = {\n    val (differenceX, weightSumX, indiceSumX) = weightCalculator(x(0), x(1))\n    val (differenceY, weightSumY, indiceSumY) = weightCalculator(y(0), y(1))\n    if (differenceX == differenceY) {\n      if (weightSumX == weightSumY) {\n        if (indiceSumX < indiceSumY) x else y\n      } else if (weightSumX < weightSumY) x else y\n    } else if (differenceX < differenceY) x else y\n  }\n\n  def closest(s: String): Array[(Int, Int, Int)] = {\n    if (s.isEmpty) Array() else {\n      val formattedList = s.split(' ')\n        .zipWithIndex\n        .map(number => (number._1.foldLeft(0)(_ + _.toString.toInt), number._2, number._1.toInt))\n\n      formattedList.foldLeft(Array(): Array[(Int, Int, Int)])((k, z: (Int, Int, Int)) => {\n        var smallest: Array[(Int, Int, Int)] = Array()\n        formattedList.foreach(p => {\n          if (p != z) {\n            val arrayToCompare = Array(p, z)\n            if (smallest.isEmpty) smallest = arrayToCompare\n            else {\n              smallest = returnSmallest(smallest, arrayToCompare)\n            }\n          }\n        })\n        if(k.isEmpty) smallest else returnSmallest(k, smallest)\n      }).sortWith((x, y) => {\n        if (x._1 == y._1) {\n          x._2 < y._2\n        } else x._1 < y._1\n      })\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335542,"user_id":null,"body":"import scala.math.Integral.Implicits._\n\nobject ClosestWeight {\n\n  private def dist(x: (Int, Int, Int), y: (Int, Int, Int)): Int = {\n    Math.abs(x._1 - y._1)\n  }\n\n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng == \"\") {\n      Array()\n    } else {\n      val strs = strng.split(' ').zipWithIndex.map((x: (String, Int)) => (x._1.map(_.-('0')).sum, x._2, x._1.toInt))\n      val res = Array(strs(0), strs(1))\n      for (i <- 0 until strs.length - 1) {\n        for (j <- i + 1 until strs.length) {\n          dist(strs(i), strs(j)) compare  dist(res(0), res(1)) match {\n            case -1 => res(0) = strs(i)\n                       res(1) = strs(j)\n            case 0 => if (strs(i)._1 + strs(j)._1 < res(0)._1 + res(1)._1) {\n              res(0) = strs(i)\n              res(1) = strs(j)\n            }\n            case _ => null\n          }\n        }\n      }\n      res.sortWith((x, y) => x._1 < y._1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335543,"user_id":null,"body":"object ClosestWeight {\n\n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng.isEmpty) return Array()\n    val numbers = strng.split(\" \").zipWithIndex.map {\n      case (n, i) => (n.map(_.asDigit).sum, i, n.toInt)\n    }.sortBy(_._1)\n    var closestIndexes = (-1, -1)\n    var smallest = Int.MaxValue\n    for((n, i) <- numbers.zipWithIndex) {\n      if (i + 1 < numbers.size) {\n        val n2 = numbers(i + 1)\n        val diff = n2._1 - n._1;\n        if (diff < smallest) {\n          smallest = diff\n          closestIndexes = (i, i+1)\n        }\n      }\n    }\n    Array(numbers(closestIndexes._1), numbers(closestIndexes._2))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335544,"user_id":null,"body":"object ClosestWeight {\n\n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng.isEmpty) Array.empty[(Int, Int, Int)]\n    else {\n      val x = strng.split(\" \").zipWithIndex.map(x => (x._1.split(\"\").map(_.toInt).sum,x._2,x._1.toInt)).sortBy(x => x._1)\n\n      val i = x.map(_._1).zip(x.map(_._1).tail).map(x => x._2 - x._1).zipWithIndex.minBy(_._1)._2\n      Array(x(i),x(i+1))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335545,"user_id":null,"body":"object ClosestWeight {\n  def closest(str: String): Array[(Int, Int, Int)] = {\n    if (str == \"\") return Array()\n\n    val weight: Int => Int = { n => s\"$n\".map(_ - '0').sum }\n\n    val numbers = str.split(\" \").map(_.toInt).zipWithIndex\n    \n    val pairs = for { i <- numbers; j <- numbers; if i != j } yield (i, j)\n    \n    val pairs2 = pairs.map { case ((n1, ix1), (n2, ix2)) =>\n      if (ix1 < ix2) ((n1, ix1), (n2, ix2)) else ((n2, ix2), (n1, ix1))\n    }\n    val ((n1, ix1), (n2, ix2)) = pairs.minBy { case ((n1, ix1), (n2, ix2)) =>\n      ( ((weight(n1) - weight(n2)).abs), weight(n1), weight(n2), ix1, ix2 )\n    }\n    Array( (weight(n1), ix1, n1), (weight(n2), ix2, n2) )\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335546,"user_id":null,"body":"object ClosestWeight {\n\n  def sort(a: IndexedSeq[(Int, Int, Int)], b: IndexedSeq[(Int, Int, Int)]): Boolean = {\n    val wA = a(0)._1 + a(1)._1\n    val wB = b(0)._1 + b(1)._1\n    val iA = a(0)._2 + a(1)._2\n    val iB = b(0)._2 + b(1)._2\n    if (wA != wB) wA < wB\n    else iA < iB\n  }\n  \n  def weight(x: String): Int = x.map(_.asDigit).sum\n  \n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng == \"\") {\n      Array()\n    }\n    else {\n      val lines = strng.split(\" \")\n      val weights = (0 to lines.length - 1).map(x => (weight(lines(x)), x, lines(x).toInt))\n      val asPairs = weights.sortBy(_._1).sliding(2).toList\n      val minDiff = asPairs.map(x => math.abs(x(0)._1 - x(1)._1)).min\n      val sortedTriples = asPairs.filter(x => math.abs(x(0)._1 - x(1)._1) == minDiff)\n      .sortWith((a, b) => sort(a, b))\n      sortedTriples(0).toArray\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335547,"user_id":null,"body":"object ClosestWeight {\n\n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng.nonEmpty) {\n      strng.trim.split(\" \").zipWithIndex.map(t => (t._1.foldLeft(0)(_ + _.asDigit), t._2, t._1.toInt)).sorted(\n        Ordering[Int].on[(Int, Int, Int)](a => a._1).orElseBy(a => a._2).orElseBy(a => a._3)\n      ).sliding(2).minBy(p => p(1)._1 - p(0)._1)\n    } else {\n      Array.empty\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335548,"user_id":null,"body":"object ClosestWeight {\n\n  def weight(str: String) : Int = str.map( ch => (ch - '0').toInt).sum\n  def closest(strng: String): Array[(Int, Int, Int)] = {\n    if (strng.isEmpty) return Array()\n    \n    val result = strng.split(\" \").zipWithIndex.map { case (str, idx) => {\n      val w = weight(str)\n      (w, idx, str.toInt) \n    }}.sortBy({case (w, idx, _) => (w, idx)})\n    \n    val (p, q) = (result zip result.tail).minBy{ case (p, q) => {\n      q._1 - p._1\n    }}\n    \n    Array(p, q)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"586909e4c66d18dd1800009b":[{"id":335549,"user_id":null,"body":"\/* left blank for unlimited creativity :) *\/\nobject CurryingFunctions {\n  def multiplyAll(ar: Array[Int]): Int => Array[Int] = \n    i => ar.map(_ * i)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335550,"user_id":null,"body":"object CurryingFunctions {\n  def multiplyAll(xs: Array[Int]): Int => Array[Int] =\n    (x: Int) => xs.map(_ * x)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335551,"user_id":null,"body":"object CurryingFunctions {\n  def multiplyAll(iterable: Iterable[Int])(multiplier: Int): Iterable[Int] = iterable.map(x => x * multiplier)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335552,"user_id":null,"body":"\/* left blank for unlimited creativity :) *\/\nobject CurryingFunctions {\n\n  def multiplyAll(arr: Array[Int]): Int => Array[Int] = {\n      def multiply(n: Int): Array[Int] = {\n        arr.map(_ * n)\n      }\n    multiply\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335553,"user_id":null,"body":"object CurryingFunctions {\n  def multiplyAll(a: Array[Int])(n: Int): Array[Int] = a.map(_ * n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335554,"user_id":null,"body":"\/* left blank for unlimited creativity :) *\/\n\nobject CurryingFunctions{\n\ndef multiplyAll(arr:Array[Int]): Int => Array[Int] = \n{\n  (arg:Int) => arr.map(_*arg)\n}\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335555,"user_id":null,"body":"object CurryingFunctions {\n\n  val multiplyAll: Array[Int] => Int => List[Int] = \n      x => y => x.map(z => z * y).toList\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335556,"user_id":null,"body":"object CurryingFunctions {\n  def multiplyAll(a: Array[Int])(m: Int): Array[Int] = {\n    a.map(_ * m)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335557,"user_id":null,"body":"object CurryingFunctions {\n  def multiplyAll(arr: Array[Int]): Int => Array[Int] = num => for (x <- arr) yield x * num\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335558,"user_id":null,"body":"\nobject CurryingFunctions{\n  def multiplyAll(x: Array[Int])(y:Int):Array[Int] = x.map(_ * y)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"586d6cefbcc21eed7a001155":[{"id":335559,"user_id":null,"body":"object Kata {\n  def longestRepetition(s: String): (String, Int) = {\n    if (s.isEmpty) (\"\", 0) else s.span(_ == s.head) match {\n      case (a, b) => Seq((a.head.toString, a.size), longestRepetition(b)).maxBy(_._2)\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335560,"user_id":575,"body":"object Kata {\n  val rgx = \"(.)\\\\1*\".r\n  def longestRepetition(s: String): (String, Int) = {\n    if (s == \"\") {\n      (\"\", 0) \n    } else {\n      val l = rgx.findAllIn(s).maxBy(_.length())\n      (l(0).toString, l.length)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335561,"user_id":573,"body":"object Kata {\n\n  def longestRepetition(s: String, longest: (String, Int) = (\"\", 0)): (String, Int) = {\n    s.headOption\n      .map { head =>\n        val (prefix, tail) = s.span(_ == head)\n        longestRepetition(tail, if (prefix.size > longest._2) (head.toString, prefix.size) else longest)\n      }\n      .getOrElse(longest)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335562,"user_id":null,"body":"object Kata {\ndef longestRepetition(s: String) = {\n  if (s ==\"\") (\"\",0)\n  else {\n    val res = s.split(\"(?<=(.))(?!\\\\1)\").maxBy(_.length)\n    (res(0).toString,res.length)\n  }}\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335563,"user_id":636,"body":"object Kata {\n  def longestRepetition(s: String): (String, Int) = {\n    def find (inp: String, ans: String, cnt: Int) : (String, Int) = {\n      if (inp.isEmpty) (ans, cnt)\n      else {\n        val newInp = inp.dropWhile(_==inp.head)\n        val letterCnt = inp.takeWhile(_==inp.head).size\n        val newAns = if (cnt < letterCnt) inp.take(1) else ans\n        val newCnt = if (cnt < letterCnt) letterCnt else cnt\n        find (newInp, newAns, newCnt)\n      }\n    }\n    find (s, \"\", 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335564,"user_id":null,"body":"object Kata {\n   def longestRepetition(s: String): (String, Int) = {\n    \n    def lon(str: String, tupleList: List[(Char, Int, Int)], tuple: (Char, Int, Int), len: Int, count: Int): (String, Int) = {\n      if(len == 0) {\n        (tupleList ++ List[(Char, Int, Int)](tuple)).sortBy(_._3).map(el => (el._1.toString, el._2)).maxBy(_._2)\n      }\n      else {\n        if(tuple._1 == str.head) lon(str.tail, tupleList, (tuple._1, tuple._2 + 1, count), len - 1, count)\n        else lon(str.tail, List[(Char, Int, Int)](tuple) ++ tupleList, (str.head, 1, count + 1), len - 1, count + 1)\n      }\n    }\n    if(s.isEmpty) (\"\", 0)\n    else lon(s, List[(Char, Int, Int)](), (s.head, 0, 0), s.length, 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335565,"user_id":null,"body":"import scala.language.postfixOps\n\nobject Kata {\n  \n  def split[T](list: List[T]): List[List[T]] = {\n    list match {\n      case Nil => Nil\n      case head::tail => val segment = list takeWhile {head ==}\n      segment :: split(list drop segment.length)\n    }\n  }\n  \n  def longestRepetition(s: String): (String, Int) = {\n    \/\/ Implement me! :)\n    val xs = split(s.toList)\n    if(xs.isEmpty) (\"\", 0)\n    else xs.map(x => x(0).toString -> x.length).maxBy(_._2)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335566,"user_id":null,"body":"object Kata {\n  def longestRepetition(s: String): (String, Int) = {\n    s match {\n      case \"\" => (\"\", 0)\n      case _ =>\n        @annotation.tailrec\n        def go(str: List[Char], acc: List[(String, Int)]): List[(String, Int)] =\n          str match {\n            case Nil => acc\n            case head::tail =>\n              val (same, other) = tail.span(_ == head)\n              go(other, acc :+ (head.toString, same.size + 1))\n          }\n\n        val grouped = go(s.toList, List.empty)\n        grouped.max((pair1: (String, Int), pair2: (String, Int)) => pair1._2.compareTo(pair2._2))\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335567,"user_id":null,"body":"object Kata {\n  def longestRepetition(s: String): (String, Int) = {\n    def longestRepetitionAcc(s: String, acc: (String, Int)): (String, Int) = {\n      if(s.isEmpty) acc\n      else {\n        val currentSeq: Int = s.takeWhile(_ == s.head).size\n        if (currentSeq > acc._2) longestRepetitionAcc(s.dropWhile(_ == s.head), (s.head.toString, currentSeq))\n        else longestRepetitionAcc(s.dropWhile(_ == s.head), acc)\n      }\n    }\n    longestRepetitionAcc(s,(\"\", 0))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335568,"user_id":null,"body":"object Kata {\n  def longestRepetition(s: String): (String, Int) = {\n    val v = s.split(\"(?<=(.))(?!\\\\1)\").maxBy(_.length)\n    (v.take(1), v.length)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5879f95892074d769f000272":[{"id":335569,"user_id":null,"body":"object Biker {\n\n  val GRAVITY_ACC = 9.81 * 3.6 * 60.0                        \/\/ gravity acceleration\n  val DRAG        = 60.0 * 0.3 \/ 3.6                         \/\/ force applied by air on the cyclist\n  val DELTA_T     = 1.0 \/ 60.0                               \/\/ in minutes\n  val G_THRUST    = 60.0 * 3.6 * 3.6                           \/\/ pedaling thrust\n  val MASS        = 80.0                                     \/\/ biker's mass\n  val WATTS0      = 225.0                                    \/\/ initial biker's power\n  val D_WATTS     = 0.5                                      \/\/ loss of power in W\/mn\n\n  \n  def temps(v0: Double, slope: Double, dTot: Double): Int = {\n    \n    val realSlope: Double = math.sin(math.atan(slope\/100.0))\n    \n    def tempsAux(v: Double, t: Double, g: Double, d: Double, watts: Double, acc: Int = 0): Int = {\n      if (d >= dTot) { println(acc); math.round(t).toInt }\n      else if (v - 3.0 <= 1e-2) -1\n      else {\n        val slope: Double = GRAVITY_ACC * realSlope\n        val drag: Double = (DRAG * v * v) \/ MASS\n        val thrust: Double = if (watts > 0.0) (G_THRUST * watts) \/ (v * MASS) else 0.0\n        val possibleG: Double = (thrust - slope - drag)\n        val newG: Double = if (math.abs(possibleG) <= 1e-5) 0.0 else possibleG\n        \n        val newV: Double = v + (newG * DELTA_T)\n        \n        val newD: Double = d + (newV * DELTA_T \/ 60.0)\n        \n        val newT: Double = t + DELTA_T\n        \n        val wattsFormula = watts - D_WATTS * DELTA_T\n        val newWatts: Double = if (wattsFormula < 0.0) 0.0 else wattsFormula\n        \n        tempsAux(newV, newT, newG, newD, newWatts, acc + 1)\n      }\n    }\n    \n    tempsAux(v0, 0.0, 0.0, 0.0, WATTS0)\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335570,"user_id":null,"body":"object Biker {\n\n  def temps(v0: Double, slope: Double, dTot: Double): Int = {\n    val GRAVITYACC: Double = 9.81 * 3.6 * 60.0\n    val DRAG: Double = 60.0 * 0.3 \/ 3.6\n    val DELTA_T: Double = 1.0 \/ 60.0\n    val DWATTS: Double = 0.5\n    val GTHRUST: Double = 60 * 3.6 * 3.6\n    val MASS: Double = 80.0\n    val WATTS0: Double = 225.0\n    var t: Double = 0.0\n    var d: Double = 0.0\n    var v: Double = v0\n    var gamma: Double = 0.0\n    var watts: Double = WATTS0\n    val slopeGravityAcc: Double = -GRAVITYACC * Math.sin(\n        Math.atan(slope \/ 100.0))\n    while (d <= dTot) {\n      t += DELTA_T\n      watts -= DWATTS * DELTA_T\n      gamma = slopeGravityAcc - DRAG * Math.abs(v) * Math.abs(v) \/ MASS\n      if ((watts > 0.0) && (v > 0.0)) {\n        gamma += GTHRUST * watts \/ (v * MASS)\n      }\n      if (Math.abs(gamma) <= 1e-5) {\n        gamma = 0.0\n      } else {\n        v += gamma * DELTA_T\n      }\n      d += v * DELTA_T \/ 60.0\n      if (v - 3.0 <= 1e-2) {\n        return -1\n      }\n    }\n    Math.round(t).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335571,"user_id":492,"body":"object Biker {\n\n  def temps(v0: Double, slope: Double, dTot: Double): Int = {\n    \/\/ gravity acceleration\n    val GRAVITYACC: Double = 9.81 * 3.6 * 60.0\n    \/\/ force applied by air on the cyclist\n    val DRAG: Double = 60.0 * 0.3 \/ 3.6\n    \/\/ in minutes\n    val DELTA_T: Double = 1.0 \/ 60.0\n    \/\/ power loss in Watts \/ minute\n    val DWATTS: Double = 0.5\n    \/\/ acceleration due to biker's power\n    val GTHRUST: Double = 60 * 3.6 * 3.6\n    \/\/ biker's mass\n    val MASS: Double = 80.0\n    \/\/ initial biker's power\n    val WATTS0: Double = 225.0\n    \/\/ time in minutes\n    var t: Double = 0.0\n    \/\/ distance traveled in km\n    var d: Double = 0.0\n    \/\/ initial speed km\/h\n    var v: Double = v0\n    \/\/ acceleration in km\/h\/minute\n    var gamma: Double = 0.0\n    \/\/ biker's power (watts at time t + deltaT is watts at time t - dWatts * deltaT)\n    var watts: Double = WATTS0\n    val slopeGravityAcc: Double = -GRAVITYACC * Math.sin(\n        Math.atan(slope \/ 100.0))\n    while (d <= dTot) {\n      t += DELTA_T\n      \/\/ tiredness\n      watts -= DWATTS * DELTA_T\n      \/\/ earth gravity due to slope and drag due to air resistance\n      gamma = slopeGravityAcc - DRAG * Math.abs(v) * Math.abs(v) \/ MASS\n      \/\/ acceleration due to biker's power\n      if ((watts > 0.0) && (v > 0.0)) {\n        gamma += GTHRUST * watts \/ (v * MASS)\n      }\n      \/\/ acceleration too small -> acc = 0\n      if (Math.abs(gamma) <= 1e-5) {\n        gamma = 0.0\n      } else {\n        v += gamma * DELTA_T\n      }\n      \/\/ v in km\/h, deltaT in minutes\n      d += v * DELTA_T \/ 60.0\n      \/\/ speed too slow, John stops\n      if (v - 3.0 <= 1e-2) {\n        return -1\n      }\n    }\n    Math.round(t).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335572,"user_id":492,"body":"object Biker {\n\n  def temps(v0: Double, slope: Double, dTot: Double): Int = {\n    \/\/ gravity acceleration\n    val GRAVITYACC: Double = 9.81 * 3.6 * 60.0\n    \/\/ force applied by air on the cyclist\n    val DRAG: Double = 60.0 * 0.3 \/ 3.6\n    \/\/ in minutes\n    val DELTA_T: Double = 1.0 \/ 60.0\n    \/\/ power loss in Watts \/ minute\n    val DWATTS: Double = 0.5\n    \/\/ acceleration due to biker's power\n    val GTHRUST: Double = 60 * 3.6 * 3.6\n    \/\/ biker's mass\n    val MASS: Double = 80.0\n    \/\/ initial biker's power\n    val WATTS0: Double = 225.0\n    \/\/ time in minutes\n    var t: Double = 0.0\n    \/\/ distance traveled in km\n    var d: Double = 0.0\n    \/\/ initial speed km\/h\n    var v: Double = v0\n    \/\/ acceleration in km\/h\/minute\n    var gamma: Double = 0.0\n    \/\/ biker's power (watts at time t + deltaT is watts at time t - dWatts * deltaT)\n    var watts: Double = WATTS0\n    val slopeGravityAcc: Double = -GRAVITYACC * Math.sin(\n        Math.atan(slope \/ 100.0))\n    while (d <= dTot) {\n      t += DELTA_T\n      \/\/ tiredness\n      watts -= DWATTS * DELTA_T\n      \/\/ earth gravity due to slope and drag due to air resistance\n      gamma = slopeGravityAcc - DRAG * Math.abs(v) * Math.abs(v) \/ MASS\n      \/\/ acceleration due to biker's power\n      if ((watts > 0.0) && (v > 0.0)) {\n        gamma += GTHRUST * watts \/ (v * MASS)\n      }\n      \/\/ acceleration too small -> acc = 0\n      if (Math.abs(gamma) <= 1e-5) {\n        gamma = 0.0\n      } else {\n        v += gamma * DELTA_T\n      }\n      \/\/ v in km\/h, deltaT in minutes\n      d += v * DELTA_T \/ 60.0\n      \/\/ speed too slow, John stops\n      if (v - 3.0 <= 1e-2) {\n        return -1\n      }\n    }\n    Math.round(t).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"588417e576933b0ec9000045":[{"id":335573,"user_id":1228,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n    (totCols-col+1)*(totRows-row)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335574,"user_id":573,"body":"object Seats {\n\n  def seatsInTheater(cols: Int, rows: Int, col: Int, row: Int): Int =\n    (cols - col + 1) * (rows - row)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335575,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int =\n  (totCols - (col-1) ) * (totRows - row)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335576,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n    (totRows - row) + ((totCols - col) * (totRows - row))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335577,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n    val res = totCols*totRows - (totCols*row) - (totRows*(col-1)) + ((col-1)*row)\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335578,"user_id":null,"body":"object Seats {\n  def seatsInTheater(totalCols: Int, totalRows: Int, col: Int, row: Int): Int = (totalRows - row) * (totalCols - (col - 1))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335579,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n    \/\/ totRows - row - rows above us\n    \/\/ totCols - col + 1 - columns to the left (including ours)\n    (totRows - row)*(totCols - col + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335580,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n    ((totCols - col + 1) max 0) * ((totRows - row) max 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335581,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n  var x = totCols - (col - 1)\n  var y = totRows - row\n  x * y\n   }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335582,"user_id":null,"body":"object Seats {\n\n  def seatsInTheater(totCols: Int, totRows: Int, col: Int, row: Int): Int = {\n    return (totRows - row) * (totCols - (col - 1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58844f1a76933b1cd0000023":[{"id":335583,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int): Int = n & ~(1 << k - 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335584,"user_id":53,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) : Int = {\n    return n & ~(1 << (k - 1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335585,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) = {\n    var s:Array[Char] = n\n      .toBinaryString\n      .reverse\n      .padTo(8,'0')\n      .reverse\n      .toCharArray\n\n    s(s.size - k) = '0'\n    Integer.parseInt(s.mkString,2)\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335586,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) = java.lang.Long.parseLong(if(n.toBinaryString.length >= k - 1 && n != 0 && n.toBinaryString.reverse.charAt(k - 1) == '1')\n          (n ^ 1 << k-1).toBinaryString else n.toBinaryString, 2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335587,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) = {\n    val bin = n.toBinaryString.toList\n    if (k > bin.length) {\n      n\n    } else {\n      Integer.parseInt(bin.updated(bin.length - k, 0).mkString(\"\"), 2)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335588,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) :Int=if(n==0)0 else Integer.parseInt(n.toBinaryString.substring(0, n.toBinaryString.length-k)+'0'+n.toBinaryString.substring(n.toBinaryString.length-k+1), 2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335589,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) = {\n    val list = n.toBinaryString.split(\"\").toList\n    val filtered = (list.take(list.length-k) :+ \"0\") ++ list.drop(list.length-k+1)\n    Integer.parseInt(filtered.mkString(\"\"), 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335590,"user_id":null,"body":"import scala.util.Try\nobject KthBit {\n  def killKthBit(n: Int, k: Int) = {\n      val bin = n.toBinaryString\n      Try(Integer.parseInt(bin.updated(bin.length - k, '0'), 2)).getOrElse(0)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335591,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) = {\n    val mask = 1 << (k - 1)\n    val r    = n & ~mask\n    \/\/println(s\"${n.toBinaryString} \n${mask.toBinaryString}, ans: ${r.toBinaryString}\")\n    r\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335592,"user_id":null,"body":"object KthBit {\n  def killKthBit(n: Int, k: Int) : Int = {\n    if (n < 1) return 0\n    if ((n | 1 << k - 1) == n) n - math.pow(2, k - 1).toInt else n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"588453ea56daa4af920000ca":[{"id":335593,"user_id":527,"body":"object Kata {\n  def arrayPacking(bs: List[Int]): Long = {\n    bs.foldRight(0l)(_ | _ << 8)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335594,"user_id":573,"body":"object Kata {\n\n  def arrayPacking(arr: List[Int]): Long =\n    java.lang.Long.valueOf(arr.reverse.map(x => f\"${x.toBinaryString.toInt}%08d\").mkString, 2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335595,"user_id":575,"body":"object Kata {\n  def arrayPacking(arr: List[Int]): Long = {\n    val powers: List[Long] = List[Long](1, 256, 65536, 16777216)\n    powers.zip(arr).map { case(p, v) => p * v}.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335596,"user_id":null,"body":"object Kata {\n  import java.lang.{ Long => JLong }\n  def arrayPacking(arr: List[Int]): Long = {\n    val s = arr.map(x=>x.toBinaryString.reverse.padTo(8,'0').reverse).reverse\n      .mkString\n      .reverse\n      .padTo(32,'0')\n      .reverse\n    JLong.parseLong(s, 2)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335597,"user_id":null,"body":"import java.lang.Long.parseLong\nobject Kata {\n    def arrayPacking(arr: List[Int]): Long = parseLong(\n     arr.reverse\n    .map(int => String.format(\"%\" + 8 + \"s\", int.toBinaryString).replace(' ','0'))\n    .reduce((str1,str2) => str1 + str2),2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335598,"user_id":null,"body":"object Kata {\n  def arrayPacking(arr: List[Int]): Long = (0 to arr.length - 1).map(k => arr(k).toLong << 8 * k).sum\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335599,"user_id":null,"body":"object Kata {\n  def arrayPacking(arr: List[Int]): Long = {\n    arr.zip(Range(0, arr.length))\n       .map(x => x._1.toLong << (x._2 * 8))\n       .sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335600,"user_id":null,"body":"object Kata {\n  def arrayPacking(arr: List[Int]): Long = {\n    java.lang.Long.parseLong(arr.reverse.map(num => f\"${num.toBinaryString.toLong}%08d\").mkString, 2)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335601,"user_id":null,"body":"object Kata {\n  def arrayPacking(arr: List[Int]): Long = {\n    (0 to arr.length-1).map(x => arr(x).toLong << 8*x).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335602,"user_id":null,"body":"object Kata {\n  def arrayPacking(arr: List[Int]): Long = \n    java.lang.Long.valueOf(arr.reverse.map(num => f\"${num.toBinaryString.toInt}%08d\").mkString,2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5886e082a836a691340000c3":[{"id":335603,"user_id":53,"body":"object Kata {\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val x = (a.toDouble \/ scala.math.sqrt(2)).toInt;\n    val y = (b.toDouble \/ scala.math.sqrt(2)).toInt;\n    val r = (x + 1) * (y + 1) + x * y;\n    return r + r % 2 - 1;\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335604,"user_id":null,"body":"object Kata {\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val x = math.floor(a \/ math.sqrt(2)) + 1\n    val y = math.floor(b \/ math.sqrt(2)) + 1\n    if (x % 2 == y % 2) (x * y + (x-1) * (y-1)).toInt\n    else (x * (y-1) + (x-1) * y).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335605,"user_id":527,"body":"object Kata {\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val u = (a \/ math.sqrt(2)).toInt\n    val v = (b \/ math.sqrt(2)).toInt\n    (u + 1) * (v + 1) + u * v - (u + v) % 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335606,"user_id":null,"body":"import scala.math\nobject Kata {\n  val sqrt = math.sqrt(2)\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val a_high = math.ceil(a \/ sqrt).toInt\n    val a_low= math.floor(a \/ sqrt).toInt\n    val b_high = math.ceil(b \/ sqrt).toInt\n    val b_low= math.floor(b \/ sqrt).toInt\n    \n    val result = a_high * b_high + a_low * b_low\n    result match {\n      case r if r % 2 == 0 => r-1\n      case rr => rr \n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335607,"user_id":null,"body":"object Kata {\n  import scala.annotation.tailrec\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    def findPoint(t: Int) : Double = {\n      @tailrec\n      def findPointHelper(ans: Double): Double = {\n        if (t * t <= 8 * (ans + 0.5) * (ans + 0.5)) ans\n        else findPointHelper(ans + 0.5)\n      }\n      findPointHelper((t \/ (2.0 * Math.sqrt(2.0))).toInt)\n    }\n    val xd = findPoint(a)\n    val yd = findPoint(b)\n    val x = xd.toInt\n    val y = yd.toInt\n    val ans = (2 * x + 1) * (2 * y + 1) + 2 * x * 2 * y\n\/\/    println(xd, yd)\n\/\/    println(x, y)\n    val ansx = if (xd - x > 0.1) ans + 4 * y else ans\n    val ansy = if (yd - y > 0.1) ansx + 4 * x else ansx\n    if (xd - x > 0.1 && yd - y > 0.1) ansy + 4 else ansy\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335608,"user_id":null,"body":"object Kata {\n  def rectangle_rotation(a: Double, b: Double): Int = {\n    \n  def aValueTop(x: Double): Double = {\n    x + b \/ math.sqrt(2)\n  }\n\n  def aValueBottom(x: Double): Double = {\n    -x - a \/ math.sqrt(2)\n  }\n\n  def bValueTop(x: Double): Double = {\n    -x + a \/ math.sqrt(2)\n  }\n\n  def bValueBottom(x: Double): Double = {\n    x - b  \/ math.sqrt(2)\n  }\n\n  def lesser(a: Double, b: Double): Double = {\n    if (a < b) a\n    else b\n  }\n\n  def larger(a: Double, b: Double): Double = {\n    if (a > b) a\n    else b\n  }\n\n  val twoRootTwo = 2 * math.sqrt(2)\n  val xList = List(-(a + b)\/twoRootTwo,\n    (a - b)\/twoRootTwo,\n    (a + b)\/twoRootTwo,\n    (b - a)\/twoRootTwo).sorted\n\n  val yList = List((b - a)\/twoRootTwo,\n    (a + b)\/twoRootTwo,\n    (a - b)\/twoRootTwo,\n    -(a + b)\/twoRootTwo).sorted\n\n  val xLeast = xList.head.round\n  val xMost = xList.reverse.head.round\n\n\n  val yLeast = yList.head.round\n  val yMost = yList.reverse.head.round\n\n  var count = 0\n  for (x <- xLeast to xMost) {\n    val aValueTop_ = aValueTop(x)\n    val bValueTop_ = bValueTop(x)\n    val yValueTop = lesser(aValueTop_, bValueTop_)\n    val yMost = yValueTop.round\n\n    val aValueBottom_ = aValueBottom(x)\n    val bValueBottom_ = bValueBottom(x)\n    val yValueBottom = larger(aValueBottom_, bValueBottom_)\n    val yLeast = yValueBottom.toLong\n\n    if (yValueTop > yValueBottom) {\n      val top = yValueTop.toInt\n      val bottom = yValueBottom.toInt\n      count += (top - bottom)\n      if (yValueTop >= 0 && yValueBottom <= 0) {\n        count += 1\n      }\n      \/\/println(s\"x $x: Top ${yValueTop.toInt}, yTop $yValueTop, bottom ${yValueBottom.toInt}, yBottom $yValueBottom\")\n    }\n  }\n\n  count\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335609,"user_id":null,"body":"import scala.math._\nobject Kata {\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val s2 = sqrt(2)\n    \n    val ca1 = 2*floor((a\/2)\/s2).toInt + 1\n    val ca2 = 2*(floor((a\/2-s2\/2)\/s2)+1).toInt\n    val nb1 = 2*floor((b\/2)\/s2).toInt + 1\n    val nb2 = 2*(floor((b\/2-s2\/2)\/s2)+1).toInt\n    \n    ca1*nb1 + ca2*nb2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335610,"user_id":1285,"body":"object Kata {\n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val longer = a max b\n    val shorter = a min b\n\n    val yAxisDistance1 = Math.sqrt(shorter * shorter \/ 2)\n    \n    val extraEdge = (longer - shorter) \/ 2\n    val extraEdgeLongSide = Math.sqrt(extraEdge * extraEdge * 2)\n    val yAxisDistance2 = yAxisDistance1 + extraEdgeLongSide\n    \n    def isInRectangle(x: Int, y: Int): Boolean = {\n      y <= x + yAxisDistance1 &&\n      y >= x - yAxisDistance1 &&\n      y >= -x - yAxisDistance2 &&\n      y <= -x + yAxisDistance2\n    }\n\n    \n    val mostLeft = (Math.sqrt((longer - extraEdge) * (longer - extraEdge)) - 1).toInt\n    val rightEndOfGrowing = Math.sqrt(extraEdge * extraEdge \/ 2).toInt\n    \n    val startY = -(extraEdgeLongSide \/ 2)\n    \n    var leftCorner = 0\n    var x = -mostLeft.toInt - 1\n    while (x < -rightEndOfGrowing) {\n      val i = x + mostLeft\n      \n      var y = (startY - i).toInt - 1\n      while (y <= startY + i) {\n        if (isInRectangle(x, y)) {\n          leftCorner += 1\n        }\n        y += 1\n      }\n      x += 1\n    }\n\n    val middle = (-yAxisDistance1.toInt - 1 to yAxisDistance1.toInt + 1)\n      .map(y => isInRectangle(0, y))\n      .filter(_ == true)\n      .size\n    \n    (leftCorner + middle * rightEndOfGrowing) * 2 + middle\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335611,"user_id":null,"body":"object Kata {\n    def rectangle_rotation(a: Int, b: Int): Int = {\n    val w = (a \/ Math.sqrt(2)).toInt\n    val h = (b \/ Math.sqrt(2)).toInt\n\n    if ((w + h) % 2 == 1)\n      (w + 1) * h + w * (h + 1)\n    else w * h + (w + 1) * (h + 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335612,"user_id":null,"body":"object Kata {\n  case class Vec(x: Double, y: Double) {\n    def rotX(a: Double): Double = x * math.cos(a) - y * math.sin(a)\n    def rotY(a: Double): Double = x * math.sin(a) + y * math.cos(a)\n    def rot(a: Double = math.Pi\/4): Vec = Vec(rotX(a), rotY(a))\n    def -(that: Vec) = Vec(this.x -  that.x, this.y - that.y)\n  }\n\n  case class Rec(c1: Vec, c2: Vec, c3: Vec, c4: Vec) {\n    def rot(a: Double = math.Pi\/4): Rec = Rec(c1.rot(a), c2.rot(a), c3.rot(a), c4.rot(a))\n  }\n\n  case object Rec {\n    def apply(a: Int, b: Int): Rec = {\n      val (x, y) = (a.toDouble\/2, b.toDouble\/2)\n      Rec(Vec(x, y), Vec(-x, y), Vec(-x, -y), Vec(x, -y))\n    }\n  }\n\n  case class Line(p1: Vec, p2: Vec) {\n    def grad: Double = { val v = p2 - p1; v.y \/ v.x }\n    def xAtY(y: Double): Double = p1.x - (p1.y - y) \/ grad\n  }\n\n  def countAt(y: Double, leftBound: Line, rightBound: Line): Int = {\n    val (leftX, rightX) = (leftBound.xAtY(y), rightBound.xAtY(y))\n    (rightX.floor - leftX.floor).toInt\n  }\n  \n  def rectangle_rotation(a: Int, b: Int): Int = {\n    val rec = Rec(a, b).rot()\n    val leftLowerBound = Line(rec.c2,rec.c3)\n    val leftUpperBound = Line(rec.c2,rec.c1)\n    val rightLowerBound = Line(rec.c3, rec.c4)\n    val rightUpperBound = Line(rec.c1, rec.c4)\n    \n    val selectAt: Double => Int = { y =>\n      if (y.toDouble < rec.c2.y && y.toDouble < rec.c4.y) countAt(y, leftLowerBound, rightLowerBound) \n      else if (y.toDouble > rec.c2.y && y.toDouble > rec.c4.y) countAt(y, leftUpperBound, rightUpperBound) \n      else if (rec.c2.y > rec.c4.y) countAt(y, leftLowerBound, rightUpperBound)\n      else countAt(y, leftUpperBound, rightLowerBound)\n    }\n    { for (y <- rec.c3.y.ceil.toInt to rec.c1.y.floor.toInt) yield selectAt(y) }.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58880c6e79a0a3e459000004":[{"id":335613,"user_id":527,"body":"object Kata {\n  def houseNumbersSum(xs: Array[Int]): Int = {\n    xs.takeWhile(_ != 0).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335614,"user_id":492,"body":"object Kata {\n  def houseNumbersSum(arr: Array[Int]): Int = {\n    arr.takeWhile(_ != 0).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335615,"user_id":527,"body":"object Kata {\n  def houseNumbersSum[T : Numeric](xs: Traversable[T]): T = {\n    xs.takeWhile(_ != implicitly[Numeric[T]].zero).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335616,"user_id":null,"body":"object Kata {\n  def houseNumbersSum(inputArray: Array[Int]): Int = {\n    def counting(inputArray: Array[Int], sum: Int = 0): Int ={\n      if(inputArray.isEmpty || inputArray.head == 0) sum\n      else counting(inputArray.tail, sum + inputArray.head)\n    }\n    counting(inputArray)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335617,"user_id":null,"body":"object Kata {\n  def houseNumbersSum(inputArray: Array[Int]): Int = {\n    inputArray.takeWhile(_ != 0).foldLeft(0)(_+_)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335618,"user_id":575,"body":"object Kata {\n  def houseNumbersSum(inputArray: Array[Int]): Int = {\n    inputArray.takeWhile(_ != 0).sum     \n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335619,"user_id":575,"body":"object Kata {\n  def houseNumbersSum(inputArray: Array[Int]): Int = {\n    inputArray.takeWhile(_ != 0).sum     \n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335620,"user_id":527,"body":"object Kata {\n  def houseNumbersSum[T : Numeric](xs: Iterable[T]): T =\n    xs.takeWhile(_ != implicitly[Numeric[T]].zero).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335621,"user_id":574,"body":"object Kata {\n  def houseNumbersSum(in: Array[Int]): Int = {\n    in.slice(0, (in :+ 0).indexOf(0)).sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335622,"user_id":null,"body":"object Kata {\n  def houseNumbersSum(inputArray: Array[Int]): Int = {\n    if(inputArray.isEmpty || inputArray.head == 0) 0\n    else inputArray.head + houseNumbersSum(inputArray.tail)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"588a00ad70720f2cd9000005":[{"id":335623,"user_id":573,"body":"class Router {\n\n  private val routes = collection.mutable.Map[(String, String), () => String]()\n  \n  def bind(url: String, method: String, action: () => String): Unit =\n    routes.update((url, method), action)\n\n  def runRequest(url: String, method: String): String =\n    routes.getOrElse((url, method), () => \"Error 404: Not Found\")()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335624,"user_id":null,"body":"class Router {\n  \/\/ Implement me! :)  \n  \n  private val routing = collection.mutable.Map[(String, String), () => String]()\n  \n def bind(url: String, method: String, response: () => String): Unit = \n      routing.update((url, method), response)\n    \n  \n  def runRequest(url: String, method: String) = \n    routing.getOrElse((url, method), () => \"Error 404: Not Found\")()\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335625,"user_id":null,"body":"class Router {\n  \n  val routes = scala.collection.mutable.Map[String, () => String]()\n  \n  def bind(route: String, rest: String, call: () => String): Unit = {\n    routes.+=( (route + rest, call) )\n  }\n  \n  def runRequest(route: String, rest: String) : String = {\n    routes.get(route + rest).getOrElse(()=>\"Error 404: Not Found\")()\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335626,"user_id":null,"body":"class Router {\n  var routes: Map[(String, String), () => String] = Map[(String, String), () => String]()\n  def bind(path: String, method: String, f: () => String): Unit = {\n    routes = routes.updated((path, method), f)\n  }\n  def runRequest(path: String, method: String): String = routes.get((path, method)) match {\n    case Some(f) => f()\n    case None => \"Error 404: Not Found\"\n  } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335627,"user_id":null,"body":"class Router {\n  \/\/ Implement me! :)  \n  private val route = collection.mutable.Map[(String, String), () => String]()\n  \n  def bind(url: String, method: String, response: () => String) =\n    route.update((url, method), response)\n  \n  def runRequest(url: String, method: String) =\n    route.getOrElse((url, method), () => \"Error 404: Not Found\")()\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335628,"user_id":null,"body":"class Router {\n  val binded = scala.collection.mutable.Map[(String, String), String]()\n  val bind = (s1: String, s2: String, s3: () => String) => binded.update((s1, s2), s3())\n  val runRequest = (s1: String, s2: String) => binded.getOrElse((s1, s2), \"Error 404: Not Found\")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335629,"user_id":null,"body":"import scala.collection.mutable.Map\n\nclass Router() {\n  val maps = Map.empty[(String, String), () => String]\n  def bind(path: String, method: String, response: () => String) =\n    maps.addOne(((path, method), response))\n  def runRequest(path: String, method: String) =\n    maps.getOrElse((path, method), () => \"Error 404: Not Found\")()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335630,"user_id":null,"body":"import scala.collection.mutable\n\nclass Router {\n  val routes: mutable.Map[(String, String), () => String] = mutable.HashMap()\n\n  def bind(url: String, method: String, action: () => String): Unit = {\n    routes.put((url, method), action)\n  }\n\n  def runRequest(url: String, method: String): String = {\n    routes.getOrElse((url, method), () => \"Error 404: Not Found\").apply()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335631,"user_id":null,"body":"class Router(var bounds: Map[(String, String), () => String] = Map()) {\n  def bind(url: String, method: String, action: () => String): Unit = {\n    val args = (url, method)\n    if (bounds.keys.toList.contains(args)) {\n      bounds = bounds.keys.toList.map { x =>\n        x match {\n          case args => (args, action) \n          case other => (x, bounds(x))\n        }\n      }.toMap\n    }\n    else {\n      bounds = bounds + ((args, action))\n    } \n  }\n  def runRequest(url: String, method: String): String = {\n    if (bounds.keys.toList.contains((url, method))) bounds((url, method))()\n    else \"Error 404: Not Found\"\n  }\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335632,"user_id":null,"body":"import scala.collection.mutable._\n\nclass Router {\n  \n  private val mapping: Map[String, Map[String, () => String]] = Map()\n  private val error: () => String = () => \"Error 404: Not Found\"\n  \n  def bind(endpoint: String, method: String, callback: () => String): Unit = mapping\n    .getOrElseUpdate(endpoint, Map[String, () => String]())\n    .put(method, callback)\n  \n  def runRequest(endpoint: String, method: String): String = mapping\n    .get(endpoint)\n    .map(_.getOrElse(method, error))\n    .getOrElse(error)()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"588e2a1ad1140d31cb00008c":[{"id":335633,"user_id":573,"body":"object Kata {\n\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] =\n    for {\n      a <- m to n\n      b <- a to n\n    } yield (a, b)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335634,"user_id":null,"body":"object Kata {\n\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] = {\n    var res:Seq[(Int, Int)] = Seq()\n    for (i <- Range.inclusive(m,n); j <- Range.inclusive(i,n) ){\n      res = res :++ Seq((i,j))\n    }\n    res\n  }\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335635,"user_id":null,"body":"object Kata {\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] =\n    for (x <- m to n; y <- x to n) yield (x, y)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335636,"user_id":null,"body":"object Kata {\n\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] = {\n    (for {\n      a <- m to n\n      b <- m to n\n      if b >= a\n    } yield (a, b)\n      ).toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335637,"user_id":null,"body":"object Kata {\n\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] = (for(i <- m to n; j <- m to n) yield if(i<=j) (i,j) else null).filter(_!=null)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335638,"user_id":527,"body":"object Kata {\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] =\n    (m to n).flatMap(i => (i to n).iterator.map(j => (i, j)))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335639,"user_id":573,"body":"object Kata {\n\n  def pairs(m: Int, n: Int): Seq[(Int, Int)] =\n    for { i <- m to n ; j <- i to n } yield (i, j)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5893e0c41a88085c330000a0":[{"id":335640,"user_id":527,"body":"object Kata {\n  def shapeArea(n: Int): Int = {\n    n * n + (n - 1) * (n - 1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335641,"user_id":573,"body":"object Kata {\n\n  def shapeArea(n: Int): Int = Seq(n, n-1).map(x => x*x).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335642,"user_id":null,"body":"object Kata {\n  def shapeArea(n: Int): Int = {\n    if (n==1) 1 else 4*(n-1) + shapeArea(n-1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335643,"user_id":null,"body":"object Kata {\n  def shapeArea(n: Int): Int = {\n    if(n == 1)\n      1\n    else\n      shapeArea(n - 1) + 4 * (n - 1) \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335644,"user_id":null,"body":"import scala.math.pow\n\nobject Kata {\n  def shapeArea(n: Int) = pow(n, 2) + pow((n - 1), 2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335645,"user_id":null,"body":"object Kata {\n  def shapeArea(n: Int): Int = {\n    return 2 * n * n - 2 * n + 1;\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335646,"user_id":null,"body":"object Kata {\n  def shapeArea(n: Int): Int = {\n    Math.pow(n, 2).toInt + Math.pow(n - 1, 2).toInt\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335647,"user_id":null,"body":"object Kata {\n  def shapeArea(n: Int): Int = if (n == 1) 1 else 4*(1+n-2) + shapeArea(n-1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335648,"user_id":null,"body":"object Kata {\n  def shapeArea(n: Int): Int = (n*2-1)*(n*2-1)-4*(1 to n-1).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335649,"user_id":2525,"body":"object Kata {\n    def shapeArea(n: Int): Int = {\n        if (n==1) { 1 }\n        else { shapeArea(n-1) + 4*n-4 }\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58941fec8afa3618c9000184":[{"id":335650,"user_id":53,"body":"object Kata {\n  def growingPlant(u: Int, d: Int, m: Int): Int = {\n    scala.math.max(1, scala.math.ceil((m - d).toDouble \/ (u - d)).toInt)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335651,"user_id":null,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    def grow(accHeight: Int, dayCount: Int): Int = {\n      if (accHeight+upSpeed >= desiredHeight) dayCount+1\n      else grow(accHeight+upSpeed-downSpeed, dayCount+1)\n    }\n    grow(0,0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335652,"user_id":645,"body":"object Kata {\n  def growingPlant(up: Int, down: Int, h: Int): Int = math.max(1, math.ceil((h - down).toFloat \/ (up - down)).toInt)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335653,"user_id":null,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    \/\/ your code here\n    \n    var taille:Int = 0\n    var ct:Int = 0\n    while(taille <= desiredHeight){\n      taille = taille + upSpeed\n      ct = ct + 1\n      if (taille >= desiredHeight) {\n        return ct\n      } else {\n        taille = taille - downSpeed\n      }\n    } \n    ct\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335654,"user_id":null,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int, day: Int = 1, height: Int = 0): Int = {\n    if (height + upSpeed >= desiredHeight)\n      day\n    else\n      growingPlant(upSpeed, downSpeed, desiredHeight, day + 1, height + upSpeed - downSpeed)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335655,"user_id":null,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    var days = 0\n    var height = 0\n    while (true) {\n      days += 1\n      height += upSpeed\n      if (height >= desiredHeight) return days\n      height -= downSpeed\n    }\n\n    return days\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335656,"user_id":50,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    if (desiredHeight <= upSpeed) {\n        return 1\n      } else {\n        return 1 + growingPlant(upSpeed, downSpeed, desiredHeight - upSpeed + downSpeed)\n      }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335657,"user_id":null,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    var res = 0\n    var height = 0\n\n    while(height < desiredHeight) {\n      height += upSpeed\n\n      if(height<desiredHeight)  height-=downSpeed\n\n      res +=1\n    }\n\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335658,"user_id":null,"body":"object Kata {\n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    var day = 0\n    var actualHeight = 0\n    while (actualHeight < desiredHeight) {\n      actualHeight = actualHeight + upSpeed\n      day += 1\n      if (actualHeight < desiredHeight) actualHeight = actualHeight - downSpeed\n    }\n    day\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335659,"user_id":null,"body":"object Kata {\n  def growth(up: Int, down: Int, target: Int, current: Int = 0, days: Int = 1): Int = {\n    val newHeight = current + up\n    if (newHeight >= target) {\n      days\n    }\n    else {\n      growth(up, down, target, newHeight-down, days + 1)\n    }\n  }\n  \n  def growingPlant(upSpeed: Int, downSpeed: Int, desiredHeight: Int): Int = {\n    growth(upSpeed, downSpeed, desiredHeight)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"589d36bbb6c071f7c20000f7":[{"id":335660,"user_id":575,"body":"object Kata {\n  def primeString(s: String): Boolean = \n    (s + s).indexOf(s, 1) == s.length\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335661,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = {\n\n    for (split_size <- 1 to s.length-1) {\n      if (s.length % split_size == 0) {\n        var lst = List[String]()\n        for (i <- 0 until s.length by split_size) {\n          lst = lst :+ s.substring(i, i + split_size)\n        }\n\n        if (lst.forall(_ == lst.head))\n          return false\n\n      }\n    }\n\n    return true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335662,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = {\n    var isPrime:Boolean = true\n    if (s.size == 1)\n      true\n    else\n      {\n        for (i<-1 to s.size\/2 if isPrime == true)\n          if (s.take(i) * (s.size\/i) == s)\n            isPrime = false\n        isPrime\n      }\n}}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335663,"user_id":50,"body":"import scala.util.matching.Regex\n\nobject Kata {\n  def primeString(s: String): Boolean = \n   \"^(.+)\\\\1+$\".r.findFirstMatchIn(s) match {\n    case Some(_) => false\n    case None => true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335664,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = !(2 to s.length\/2).filter(s.length % _ == 0).exists(x => s.take(s.length\/x) * x == s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335665,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = {\n    if (s.length < 2) return true\n    for (i <- 1 to s.length \/ 2) {\n      if (s.length % i == 0) {\n        val sub = s.substring(0, i)\n        if (s == sub * (s.length \/ i)) {\n          return false\n        }\n      }\n    }\n    return true\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335666,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = \n      (1 to s.length \/ 2).filter(i => s.grouped(i).toSet.size == 1).isEmpty\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335667,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = {\n    (1 to s.length \/ 2).map(s.substring(0, _)).forall(w => w * (s.length \/ w.length) != s)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335668,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean =\n    (1 to s.length \/ 2).forall(i => s.grouped(i).distinct.length != 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335669,"user_id":null,"body":"object Kata {\n  def primeString(s: String): Boolean = {\n      return (s + s).indexOf(s, 1) == s.length\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58a57c6bcebc069d7e0001fe":[{"id":335670,"user_id":null,"body":"object Base91 {\n\n  import java.nio.charset.StandardCharsets.ISO_8859_1\n\n  val B91_TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n  val B91_DEC_TABLE = B91_TABLE.zipWithIndex.toMap\n\n  def encode(data: String) = {\n    data.getBytes(ISO_8859_1).foldLeft((0, 0, \"\")) { (acc, b) =>\n      val ebq = acc._2 | (b & 255) << acc._1\n      acc._1 + 8 match {\n        case n if n > 13 => ebq & 8191 match {\n          case v if v > 88 =>\n            (n - 13, ebq >> 13, acc._3 + B91_TABLE(v % 91) + B91_TABLE(v \/ 91))\n          case _ =>\n            val v = ebq & 16383\n            (n - 14, ebq >> 14, acc._3 + B91_TABLE(v % 91) + B91_TABLE(v \/ 91))\n        }\n        case n => (n, ebq, acc._3)\n      }\n    } match {\n      case (n, ebq, str) if n > 0 && (n > 7 || ebq > 90) => str + s\"${B91_TABLE(ebq % 91)}\" + s\"${B91_TABLE(ebq \/ 91)}\"\n      case (n, ebq, str) if n > 0 => str + s\"${B91_TABLE(ebq % 91)}\"\n      case (_, _, str) => str\n    }\n  }\n\n  def decode(data: String): String = {\n    data.filter(B91_DEC_TABLE.contains).map(B91_DEC_TABLE(_).toChar).foldLeft((-1, 0, 0, \"\")) { (acc, c) =>\n      acc._1 match {\n        case v if v < 0 =>\n          acc.copy(c)\n        case v =>\n          val v2             = v + (c * 91)\n          val n              = acc._3 + (if ((v2 & 8191) > 88) 13 else 14)\n          val (dbq, n2, str) = (n until(7, -8)).foldLeft((acc._2 | v2 << acc._3, n, \"\")) { (acc, n) =>\n            (acc._1 >> 8, n - 8, acc._3 + s\"${(acc._1 & 255).toChar}\")\n          }\n          (-1, dbq, n2, acc._4 + str)\n      }\n    } match {\n      case (v, dbq, n, str) if v != -1 => str + s\"${(dbq | v << n).toChar}\"\n      case (_, _, _, str) => str\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335671,"user_id":1617,"body":"import java.io.ByteArrayOutputStream\n\nobject Base91 {\n  val mask = Map(8 -> 0xFF, 13 -> 0x1FFF, 14 -> 0x3FFF)\n  val eset =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n  val dset = eset.zipWithIndex.toMap\n\n  def encode(data: String): String =\n    (data + \"\\u0000\")\n      .foldLeft((0, 0, \"\")) {\n        case ((b, 0, o), 0)                      => (0, 0, o)\n        case ((b, n, o), 0) if n <= 7 && b <= 90 => (0, 0, o + eset(b % 91))\n        case ((b, n, o), 0)                      => (0, 0, o + eset(b % 91) + eset(b \/ 91))\n        case ((b, n, o), c) if n + 8 < 13        => (b | (c << n), n + 8, o)\n        case ((b, n, o), c) => {\n          val nb = b | (c << n)\n          val s = if ((nb & mask(13)) > 88) 13 else 14\n          val mb = nb & mask(s)\n          (\n            nb >> s,\n            n + 8 - s,\n            o + eset(mb % 91) + eset(mb \/ 91)\n          )\n        }\n      }\n      ._3\n\n  def decode(data: String): String =\n    (data.map(dset) :+ -1)\n      .foldLeft((0, 0, -1, \"\")) {\n        case ((b, n, -1, o), -1) => (b, n, -1, o)\n        case ((b, n, v, o), -1) =>\n          (b, n, -1, o + ((b | v << n) & mask(8)).toChar)\n        case ((b, n, -1, o), c) => (b, n, c, o)\n        case ((b, n, v, o), c) => {\n          val nv = v + c * 91;\n          var nb = b | (nv << n);\n          var nn = n + (if ((nv & mask(13)) > 88) 13 else 14);\n          var no = o\n          val s = 8\n          do {\n            no += (nb & mask(s)).toChar;\n            nb >>= s;\n            nn -= s;\n          } while (nn >= s);\n          (nb, nn, -1, no)\n        }\n      }\n      ._4\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335672,"user_id":null,"body":"import java.io.{ByteArrayOutputStream, IOException, OutputStream}\n\nobject Base91 {\n  private val BIT_TO_CHAR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\".toCharArray\n  private val BASE = BIT_TO_CHAR.length\n  private val CHAR_TO_BIT = BIT_TO_CHAR.zipWithIndex.map(t => (t._1, t._2)).toMap\n  private val AVERAGE_ENCODING_RATIO = 1.2297f\n\n  \/**\n    * \u8bfb13bit\uff0c\u5982\u679c\u5c0f\u4e8e\u7b49\u4e8e88\uff0c\u518d\u8bfb1bit\u653e\u6700\u9ad8\u4f4d\uff0c\u5f97\u5230v\n    * i0 = v%91, i1 = v\/91. \u67e5\u8868\u5f97 table[i0], table[i1]\n    *\/\n  def encode(data: String): String = {\n    println(\"encode:\"+data)\n    val out = new ByteArrayOutputStream\n    val base91OutputStream = new Base91OutputStream(out)\n    try {\n      base91OutputStream.write(data.getBytes)\n      base91OutputStream.flush()\n    } catch {\n      case e: IOException =>\n        throw new RuntimeException(\"Failed to encode\", e)\n    }\n    new String(out.toByteArray)\n  }\n\n  def decode(data: String): String = {\n    println(\"decode:\"+data)\n    var (dbq, dn, dv) = (0, 0, -1)\n    val estimatedSize = Math.round(data.length \/ AVERAGE_ENCODING_RATIO)\n    val output = new ByteArrayOutputStream(estimatedSize)\n\n    for (c <- data.toCharArray) {\n      if (dv == -1) dv = CHAR_TO_BIT(c) else {\n        dv += CHAR_TO_BIT(c) * BASE\n        dbq |= dv << dn\n        dn += (if ((dv & 8191) > 88) 13 else 14)\n        do {\n          output.write(dbq.toByte)\n          dbq >>= 8\n          dn -= 8\n        } while (dn > 7)\n        dv = -1\n      }\n    }\n    if (dv != -1) output.write((dbq | dv << dn).toByte)\n    new String(output.toByteArray)\n  }\n\n  class Base91OutputStream(val out: OutputStream) {\n    private var ebq = 0\n    private var en = 0\n\n    @throws[IOException]\n    def write(b: Int): Unit = {\n      ebq |= (b & 255) << en\n      en += 8\n      if (en > 13) {\n        var ev = ebq & 8191\n        if (ev > 88) {\n          ebq >>= 13\n          en -= 13\n        }\n        else {\n          ev = ebq & 16383\n          ebq >>= 14\n          en -= 14\n        }\n        out.write(BIT_TO_CHAR(ev % BASE))\n        out.write(BIT_TO_CHAR(ev \/ BASE))\n      }\n    }\n\n    @throws[IOException]\n    def write(b: Array[Byte]): Unit = write(b, 0, b.length)\n\n    @throws[IOException]\n    def write(data: Array[Byte], offset: Int, length: Int): Unit = {\n      for (i <- offset until length) {\n        write(data(i))\n      }\n    }\n\n    @throws[IOException]\n    def flush(): Unit = {\n      if (en > 0) {\n        out.write(BIT_TO_CHAR(ebq % BASE))\n        if (en > 7 || ebq > 90) out.write(BIT_TO_CHAR(ebq \/ BASE))\n      }\n      out.flush()\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335673,"user_id":null,"body":"object Base91 {\n  val base91Alphabet = ('A' to 'Z').toList ++ ('a' to 'z').toList ++ ('0' to '9').toList ++\n                       List('!', '#', '$', '%', '&', '(', ')', '*', '+', ',', '.', '\/', ':', ';',\n                            '<', '=', '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', 0x22.toChar)\n  val base91Enc = base91Alphabet.zipWithIndex.map { case (ch, ix) => (ix, ch) }.toMap\n  val base91Dec = base91Alphabet.zipWithIndex.toMap\n\n  def encode(data: String): String = {\n    val bytes = data.getBytes.iterator\n    val out = new StringBuilder()\n    var buffer, n = 0\n\n    for (b <- bytes) {\n      buffer |= (b << n); n += 8\n\n      if (n >= 13) {\n        val chunk = buffer & 0x1FFF\n        buffer >>= 13; n -= 13\n        out += base91Enc(chunk % 91) += base91Enc(chunk \/ 91)\n      }\n    }\n    if (n > 0) {\n      out += base91Enc(buffer % 91)\n      if (buffer >= 91 || n >= 8) out += base91Enc(buffer \/ 91)\n    }\n    out.toString\n  }\n\n  def decode(data: String): String = {\n    val out = new StringBuilder()\n    var buffer, n, chunk, chunkSize = 0\n\n    for (s <- data.sliding(2, 2)) {\n      if (s.length == 2) {\n        buffer |= base91Dec(s(0)) + base91Dec(s(1)) * 91 << n\n        n += 13\n      } else {\n        buffer |= base91Dec(s(0)) << n\n        n += 7\n      }\n      while (n >= 8) {\n        out += (buffer & 0xFF).toChar\n        buffer >>= 8; n -= 8\n      }\n    }\n    out.toString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335674,"user_id":null,"body":"import java.io.ByteArrayOutputStream\n\nobject Base91 {\n\n  val table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n  \n  def encode(data: String): String = {\n    val chars = data.getBytes\n      def encodeAux(i: Int, ebq: Int, en: Int, answer: String): String = {\n        if (i == chars.length) {\n          if (en > 0)\n          {\n            if (en > 7 || ebq > 90) answer ++ List(table(ebq % 91), table(ebq \/ 91)).mkString(\"\")\n            else answer ++ table(ebq % 91).toString\n          }\n          else {\n            answer\n          }\n        }\n        else {\n          val newEbq = ebq | ((chars(i) & 255) << en)\n          val newEn = en + 8\n          if (newEn > 13)\n          {\n            val ev = newEbq & 8191\n            if ( ev > 88 ) {\n              val newEbq2 = newEbq >> 13;\n              val newEn2 = newEn - 13;\n              val code = List(table(ev % 91), table(ev \/ 91)).mkString(\"\")\n              encodeAux(i + 1, newEbq2, newEn2, answer ++ code)\n            } \n            else {\n              val newEv = newEbq & 16383;\n              val newEbq2 = newEbq >> 14;\n              val newEn2 = newEn - 14;\n              val code = List(table(newEv % 91), table(newEv \/ 91)).mkString(\"\")\n              encodeAux(i + 1, newEbq2, newEn2, answer ++ code)\n            }\n          }\n          else {\n            encodeAux(i + 1, newEbq, newEn, answer)\n          }\n        }\n      }\n    encodeAux(0, 0, 0, \"\")\n  }\n\n  def decode(data: String): String = {\n    val chars = data.getBytes()\n    def decodeAux(i: Int, dn: Int, dbq: Int, dv: Int, answer: String): String = {\n      if (i == chars.length) {\n        if (dv != - 1) answer :+ (dbq | (dv << dn)).toChar \n        else answer\n      }\n      else {\n        if (dv == -1) {\n          val newDv = table.indexOf(chars(i))\n          decodeAux(i + 1, dn, dbq, newDv, answer)\n        }\n        else {\n          val newDv = dv + table.indexOf(chars(i)) * 91\n          val newDbq = dbq | (newDv << dn)\n          val newDn = dn + (((newDv & 8191) > 88) match { case true => 13; case false => 14 })\n\n          def cycleAux(dn: Int, dbq: Int, answer: String): (Int, Int, String) = {\n            val newAnswer = answer :+ dbq.toByte.toChar\n            val newDbq = dbq >> 8\n            val newDn = dn - 8\n            if (newDn > 7) cycleAux(newDn, newDbq, newAnswer)\n            else (newDn, newDbq, newAnswer)\n          }\n          \n          val cycleRes = cycleAux(newDn, newDbq, answer)\n          decodeAux(i + 1, cycleRes._1, cycleRes._2, -1, cycleRes._3)\n        }\n      }\n    }\n    decodeAux(0, 0, 0, -1, \"\")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335675,"user_id":null,"body":"\nimport java.io.ByteArrayOutputStream\nimport java.nio.charset.StandardCharsets\n\nobject Base91 {\n  private val ts: String =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n  private val enctab = ts.getBytes(StandardCharsets.ISO_8859_1)\n  private val base   = enctab.length\n  require(base == 91)\n  private val dectab = new Array[Byte](256)\n  dectab.indices.foreach(i => dectab(i) = -1)\n  (0 until base).foreach(i => dectab(enctab(i)) = i.toByte)\n  private val AVERAGE_ENCODING_RATIO: Float = 1.2297f\n\n  def encode(data: String): String = {\n    val out                = new ByteArrayOutputStream()\n    val base91OutputStream = new Base91OutputStream(out)\n    try {\n      base91OutputStream.write(data.map(_.toByte).toArray)\n      base91OutputStream.flush()\n    }\n    base91OutputStream.outputStream.toByteArray.map(_.toChar).mkString\n  }\n\n  def decode(data1: String): String = {\n    val data = data1.map(_.toByte)\n    var dbq  = 0\n    var dn   = 0\n    var dv   = -1\n\n    val estimatedSize = Math.round(data.length \/ AVERAGE_ENCODING_RATIO)\n    val output        = new ByteArrayOutputStream(estimatedSize)\n\n    for (i <- data.indices)\n      if (dv == -1)\n        dv = dectab(data(i))\n      else {\n        dv += dectab(data(i)) * base\n        dbq |= dv << dn\n        dn += (if ((dv & 8191) > 88) 13 else 14)\n        do {\n          output.write(dbq.toByte)\n          dbq >>= 8\n          dn -= 8\n        } while (dn > 7)\n        dv = -1\n      }\n\n    if (dv != -1) {\n      output.write((dbq | dv << dn).toByte)\n    }\n\n    output.toByteArray.map(_.toChar).mkString\n  }\n\n  import java.io.{ FilterOutputStream, IOException }\n\n  class Base91OutputStream(outtmp: ByteArrayOutputStream) extends FilterOutputStream(outtmp) {\n    private var ebq                         = 0\n    private var en                          = 0\n    var outputStream: ByteArrayOutputStream = outtmp\n\n    @throws[IOException]\n    override def write(b: Int): Unit = {\n      ebq |= (b & 255) << en\n      en += 8\n      if (en > 13) {\n        var ev = ebq & 8191\n        if (ev > 88) {\n          ebq >>= 13\n          en -= 13\n        } else {\n          ev = ebq & 16383\n          ebq >>= 14\n          en -= 14\n        }\n        outputStream.write(enctab(ev % base))\n        outputStream.write(enctab(ev \/ base))\n      }\n    }\n\n    @throws[IOException]\n    override def write(data: Array[Byte], offset: Int, length: Int): Unit =\n      for (i <- offset until length)\n        write(data(i))\n\n    @throws[IOException]\n    override def flush(): Unit = {\n      if (en > 0) {\n        outputStream.write(enctab(ebq % base))\n        if (en > 7 || ebq > 90) outputStream.write(enctab(ebq \/ base))\n      }\n      super.flush()\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335676,"user_id":null,"body":"import java.io.ByteArrayOutputStream\nimport scala.language.postfixOps\n\nobject Base91 {\n  \n  val chars = ('A' to 'Z') ++ ('a' to 'z') ++ ('0' to '9') ++ (\"!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\") toList\n  val backLookup = chars.zipWithIndex.toMap\n  val forwardLookup = chars.zipWithIndex.map(_.swap).toMap\n\n  def encode(data: String): String = {\n    data\n    .toCharArray\n    .reverse\n    .flatMap(_.toBinaryString.reverse.padTo(8, '0').reverse)\n    .reverse\n    .grouped(13)\n    .map(_.reverse)\n    .map(l => (Integer.parseInt(l.mkString(\"\"), 2), l.size))\n    .collect {\n      case (a: Int, 13) => Array((a % 91), (a \/ 91))\n      case (a: Int, b) if b < 13 => if (a \/ 91 == 0) Array(a) else Array(a % 91, a \/ 91)\n    }\n    .flatten\n    .map(forwardLookup.get)\n    .filter(_.isDefined)\n    .map(_.get)\n    .mkString(\"\")\n  }\n    \n\n  def decode(data: String): String = {\n    data\n    .map(backLookup.get)\n    .filter(_.isDefined)\n    .map(_.get)\n    .grouped(2)\n    .map(_.toVector)\n    .collect {\n      case Vector(a: Int, b: Int) => 91 * b + a\n      case Vector(a) => a\n    }\n    .flatMap(_.toBinaryString.reverse.padTo(13, '0'))\n    .grouped(8)\n    .filter(_.length == 8)\n    .filter(_.find(_ == '1').isDefined)\n    .map(_.reverse)\n    .toList\n    .map(l => Integer.parseInt(l.mkString(\"\"), 2).toChar)\n    .mkString(\"\")\n  }\n    \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335677,"user_id":null,"body":"object Base91 {\n  val encodeMap = \"\"\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\"\"\"\"\n  val decodeMap: Map[Char, Char] = encodeMap.zipWithIndex.map(pair => pair._1 -> pair._2.toChar).toMap\n\n  def encode(data: String): String = {\n    val result = new StringBuilder\n    var buffer = 0\n    var bitsRead = 0\n    var value = 0\n    for (byte <- data) {\n      buffer |= byte << bitsRead\n      bitsRead += 8\n      if (bitsRead > 13) {\n        value = buffer & 0x1FFF\n        if (value > 88) {\n          buffer >>= 13\n          bitsRead -= 13\n        }\n        else {\n          value = buffer & 0x3FFF\n          buffer >>= 14\n          bitsRead -= 14\n        }\n        result += encodeMap(value % 91)\n        result += encodeMap(value \/ 91)\n      }\n    }\n    if (bitsRead > 0) {\n      result += encodeMap(buffer % 91)\n      if (bitsRead > 7 || buffer > 90)\n        result += encodeMap(buffer \/ 91)\n    }\n    result.toString\n  }\n\n  def decode(data: String): String = {\n    val result = new StringBuilder\n    var buffer = 0\n    var bitsRead = 0\n    var value: Option[Int] = None\n    for (byte <- data) {\n      if (decodeMap.contains(byte)) {\n        if (value.isEmpty) {\n          value = Some(decodeMap(byte))\n        }\n        else {\n          value = Some(value.get + decodeMap(byte) * 91)\n          buffer |= value.get << bitsRead\n          bitsRead += (if ((value.get & 0x1FFF) > 88) 13 else 14)\n          while (bitsRead > 7) {\n            result += (buffer & 0xFF).toChar\n            buffer >>= 8\n            bitsRead -= 8\n          }\n          value = None\n        }\n      }\n    }\n    if (value.isDefined)\n      result += ((buffer | value.get << bitsRead) & 255).toChar\n    result.toString\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335678,"user_id":null,"body":"object Base91 {\n\n  import Integer.parseInt\n\n  val table =\n    \"\"\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\"\"\"\"\n\n  \/\/ 2^13 = 8192\n  \/\/ 91^2 = 8281\n  \/\/ 8281 - 8192 = 89\n  def encode(data: String): String = {\n    var str = data.reverse \/\/ little-endian\n      .map(x => f\"${x.toBinaryString}%8s\") \/\/ 8-bit\n      .mkString\n      .replace(\" \", \"0\")\n\n    var res = \"\"\n\n    while (str.length > 13) {\n      var v =\n        parseInt(str.takeRight(13), 2)\n      if (v >= 89) {\n        str = str.dropRight(13)\n      } else {\n        v = parseInt(str.takeRight(14), 2)\n        str = str.dropRight(14)\n      }\n      res = res + table(v % 91) + table(v \/ 91)\n    }\n\n    if (str.nonEmpty) {\n      res += table(parseInt(str, 2) % 91)\n      if (str.length >= 8 || parseInt(str, 2) >= 91) {\n        res += table(parseInt(str, 2) \/ 91)\n      }\n    }\n\n    res\n  }\n\n  def decode(data: String): String = {\n    data\n      .grouped(2)\n      .map { x =>\n        if (x.length == 2) {\n          val i0 = table.indexOf(x(0))\n          val i1 = table.indexOf(x(1))\n          val v = i1 * 91 + i0\n          val s = v.toBinaryString\n          if (v >= 89) f\"$s%13s\" else f\"$s%14s\"\n        } else {\n          table.indexOf(x(0)).toBinaryString\n        }\n      }\n      .toSeq\n      .reverse\n      .mkString\n      .replace(\" \", \"0\")\n      .reverse\n      .grouped(8)\n      .map(x => parseInt(x.reverse, 2).toChar)\n      .toSeq\n      .mkString\n      .trim\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335679,"user_id":null,"body":"import java.nio.ByteBuffer\n\nobject Base91 {\n\n  val chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,.\/:;<=>?@[]^_`{|}~\\\"\"\n\n  def bytesToBase91(data: Array[Byte]): Vector[Byte] = {\n    val buffer = ByteBuffer.wrap(data)\n\n    def loop(head: Int = 0, bytes: Vector[Byte] = Vector.empty, offset: Int = 0): Vector[Byte] = {\n      if (buffer.hasRemaining) {\n        val nextByte = buffer.get\n        val newHead = (nextByte << offset) | head\n        val newOffset = offset + 8\n        if (newOffset > 13) {\n          val last13 = newHead & 8191\n          val (correctedHead, correctedOffset, bits) = if (last13 > 88) {\n            (newHead >>> 13, newOffset - 13, last13)\n          } else {\n            (newHead >>> 14, newOffset - 14, newHead & 16383)\n          }\n          println(last13)\n          val firstByte = bits % 91\n          val secondByte = bits \/ 91\n          loop(correctedHead, bytes :+ firstByte.toByte :+ secondByte.toByte, correctedOffset)\n        } else {\n          loop(newHead, bytes, newOffset)\n        }\n      } else {\n        if (offset > 0) {\n          val newBytes = bytes :+ (head % 91).toByte\n          if (offset > 7 || head > 90) {\n            newBytes :+ (head \/ 91).toByte\n          } else {\n            newBytes\n          }\n        } else {\n          bytes\n        }\n      }\n    }\n\n    loop()\n  }\n\n  def base91ToChars(data: Array[Byte]): Vector[Char] = {\n    val buffer = ByteBuffer.wrap(data)\n\n    def loop(lastByte: Option[Byte] = None, chars: Vector[Byte] = Vector.empty, remainder: Int = 0, offset: Int = 0): Vector[Byte] = {\n      if (buffer.hasRemaining) {\n        val byte = buffer.get\n        if (lastByte.isEmpty) {\n          loop(Some(byte), chars, remainder, offset)\n        } else {\n          val last = lastByte.get\n          val bits = byte * 91 + last\n\n          val numBits = if ((bits & 8191) > 88) {\n            13\n          } else {\n            14\n          }\n          val incrementedOffset = offset + numBits\n\n          val (newChars, newRemainder, newOffset) = (incrementedOffset - 8).to(0, -8)\n            .foldLeft((chars, remainder | (bits << offset), incrementedOffset)) {\n              case ((v, i, _), o) =>\n                (v :+ (i & 255).toByte, i >> 8, o)\n            }\n\n          loop(None, newChars, newRemainder, newOffset)\n        }\n      } else {\n        lastByte.\n          map { bits =>\n            chars :+ (remainder | (bits << offset)).toByte\n          }\n          .getOrElse(chars)\n      }\n    }\n\n    loop().map(a => a.toChar)\n  }\n\n  def encode(data: String): String =\n    bytesToBase91(data.getBytes).map(s => chars.charAt(s.toInt)).mkString\n\n  def decode(data: String): String =\n    base91ToChars(data.map(c => chars.indexOf(c).toByte).toArray).mkString\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58acfe4ae0201e1708000075":[{"id":335680,"user_id":645,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = l.sum > 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335681,"user_id":573,"body":"object Kata {\n\n  val inviteMoreWomen: List[Int] => Boolean = _.sum > 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335682,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = {\n    \n    val women = l.filter(w => w == -1).size\n    val men = l.filter(m => m == 1).size\n\n    if (men > women) {\n      true\n    }else{\n      false\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335683,"user_id":527,"body":"object Kata {\n  def inviteMoreWomen(genders: Iterable[Int]): Boolean = genders.sum > 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335684,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = {\n    val w = l.count(_ == -1)\n    val m = l.size - w\n    m > w\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335685,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = !(l.count(i => i < 0) >= l.count(i => i > 0))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335686,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = l.count(elem => elem == -1) < l.count(elem => elem == 1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335687,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = {\n    var men = 0\n    var women = 0\n    for (x <- l if x < 0) \n    women += 1\n    \n    men = l.length - women\n    if (men > women) {true}\n    else {false}\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335688,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = {\n    var m = 0\n    var n = 0\n    for(i <- l) {\n      if(i == 1) m += 1\n      else n += 1\n    }\n    m>n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335689,"user_id":null,"body":"object Kata {\n  def inviteMoreWomen(l: List[Int]): Boolean = {\n    \/\/ your code here\n    if (l.reduceLeft((a, b) => a + b) > 0) true\n    else false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58b8c94b7df3f116eb00005b":[{"id":335690,"user_id":573,"body":"object Letter {\n  def reverse_letter(str: String): String =\n    str.filter(_.isLetter).reverse\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335691,"user_id":null,"body":"object Letter {\n  def reverse_letter(str: String): String = {\n    str.replaceAll(\"[^A-Za-z]|_\", \"\").reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335692,"user_id":null,"body":"object Letter {\n  def reverse_letter(str: String): String = (\"\" \/: str.filter(_.isLetter))((x, y) => y+x)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335693,"user_id":492,"body":"object Letter {\n  def reverse_letter(s: String): String = s.filter(_.isLetter).reverse\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335694,"user_id":null,"body":"object Letter {\n  def reverse_letter(str: String): String = {\n    val str_lower = str.toLowerCase()\n    str_lower.filter(x => (x>='a' && x<='z')).reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335695,"user_id":null,"body":"object Letter {\n  val alphabet: Array[Char] = \"abcdefghijklmnopqrstuvwxyz\".toArray\n\n  def reverse_letter(v: String): String = {\n    invert(v.toList).mkString(\"\")\n  }\n\n  def invert(l: List[Char]): List[Char] = l match {\n    case Nil => Nil\n    case head :: tail if alphabet.contains(head) => invert(tail) ++ List(head)\n    case _ :: tail => invert(tail)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335696,"user_id":null,"body":"object Letter {\n  def reverse_letter(str: String): String = {\n    str filter(c => c.isLetter) reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335697,"user_id":null,"body":"object Letter {\n  def reverse_letter(str: String): String = {\n    var res: String = \"\"\n    for(index <- (str.length - 1) to 0 by -1){\n      val char = str.charAt(index)\n      if((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z')){\n        res = res.concat(char.toString)\n      }\n    }\n    return res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335698,"user_id":null,"body":"object Letter {\n  def reverse_letter(str: String): String = {\n    \/\/ your code\n    \n    str.filter(_.isLetter).reverse\n  }\n  }\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335699,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject Letter {\n  def reverse_letter(str: String): String = {\n    val pattern = new Regex (\"[a-zA-Z]\")\n    val search = pattern.findAllIn(str).mkString\n    search.reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58c8a41bedb423240a000007":[{"id":335700,"user_id":575,"body":"object Kata {\n  def cakeSlice(n: Int): Int = {\n    n*(n+1)\/2+1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335701,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = {\n    \/\/ Implement me! :)\n    var count = 1\n    var number = 1 \n    while(n >= number) {\n      count = count + number\n      number = number + 1\n    }\n    count\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335702,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = {\n    if (n <= 0) {\n      return 1\n    } else {\n      return n + cakeSlice(n-1)\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335703,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = {\n    1 + recurse(0, n)\n  }\n  \n  def recurse(x: Int, n: Int):Int={\n    if(x <= n){\n      x + recurse(x+1, n)\n    }else {\n      0\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335704,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = \n    if (n==0) 1\n    else math.max(n*(n+1)\/2 + 1, (n^2 + n + 2)\/2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335705,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = \n    if (n <= 0) 1 else n + cakeSlice(n - 1)\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335706,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = {\n    (n * n + n + 2) \/ 2\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335707,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = {\n    if (n == 0) return 1\n    else return n + cakeSlice(n-1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335708,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = 1 + (1 to n).sum\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335709,"user_id":null,"body":"object Kata {\n  def cakeSlice(n: Int): Int = (0.5 * ( (n*n) + n + 2 )).toInt\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58ce8725c835848ad6000007":[{"id":335710,"user_id":492,"body":"object Kata {\n\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = w0 * (100 - p0) \/ (100 - p1)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335711,"user_id":null,"body":"object Kata {\n  val potatoes: (Int, Int, Int) => Int = (x, y, z) => y*(100-x)\/(100-z)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335712,"user_id":null,"body":"object Kata {\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = {\n    val perc0 = 100 - p0\n    val perc1 = perc0 + p0 - p1\n\n    (w0 * perc0) \/ perc1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335713,"user_id":null,"body":"object Kata {\n\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = {\n    w0*(100 - p0) \/ (100 - p1)\n\/\/    (math floor w0*((100-p0)\/100)  \/(1 - p1.toFloat\/100)).toInt\n\/\/    BigDecimal(w0*(1-p0.toDouble\/100) * 100 \/(100 - p1)).setScale(0, BigDecimal.RoundingMode.HALF_UP).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335714,"user_id":null,"body":"object Kata {\n  val potatoes: (Int, Int, Int) => Int = (p0, w0, p1) => (w0*(100-p0)\/(100-p1)).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335715,"user_id":null,"body":"object Kata {\n\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = (((100-p0).toDouble\/100*w0)\/(100-p1)*100).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335716,"user_id":null,"body":"object Kata {\n\n  def potatoes(p0: Double, w0: Double, p1: Double): Int = {\n    println(p0,w0,p1)\n    ((100-p0)*w0\/(100-p1)).toInt\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335717,"user_id":null,"body":"object Kata {\n\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = (w0 * (100 - p0) \/ (100 - p1)).floor.toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335718,"user_id":null,"body":"object Kata {\n\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = \n   ((((100 * w0 - p0 * w0) \/ (100 -  p1)))).toInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335719,"user_id":null,"body":"object Kata {\n\n  def potatoes(p0: Int, w0: Int, p1: Int): Int = {    \n    var massWeight = (w0\/100f) * (100f-p0)\n    println(massWeight)\n    var percent = (massWeight \/ (100 - p1))*100f\n    println(percent)\n    var resultingWeight = 0\n    if((Math.round(percent) - percent) <= 0.001) {\n      resultingWeight = Math.round(percent)\n    }else resultingWeight = percent.toInt\n\n\n    return resultingWeight\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58d3cf477a4ea9bb2f000103":[{"id":335720,"user_id":573,"body":"object Kata {\n\n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] =\n    Array.tabulate(matrix.size, matrix.size) { case (i, j) =>\n      val depth = Seq(i+1, j+1, matrix.size-i, matrix.size-j).min\n      (0 until depth).foldLeft(matrix) { case (m, _) => m.transpose.reverse }(i)(j)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335721,"user_id":53,"body":"object Kata {\n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n    var m = matrix.map(r => r.clone).toArray\n    def n = matrix.size\n    for (i <- 0 to (n \/ 2) - 1) {\n      for (j <- i to ((n + 1) \/ 2) - 1) {\n        for (k <- i to (n \/ 2) - 1) {\n          var t = m(j)(k)\n          m(j)(k) = m(k)(n - j - 1)\n          m(k)(n - j - 1) = m(n - j - 1)(n - k - 1)\n          m(n - j - 1)(n - k - 1) = m(n - k - 1)(j)\n          m(n - k - 1)(j) = t\n        }\n      }\n    }\n    return m\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335722,"user_id":null,"body":"object Kata {\n\n  def rotate(matrix: Array[Array[Int]], n: Int): Array[Array[Int]] = {\n    val newMatrix = matrix.transpose.reverse\n    if (n == 1) newMatrix\n    else rotate(newMatrix, n-1)\n  }\n  \n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n    val rotations = (1 to (matrix.length + 1)\/2).map(x => rotate(matrix, x))\n    val result = (1 to matrix.length).map{ i =>\n      (1 to matrix.length).map{ j =>\n        val n = math.abs(matrix.length - i)\n        .min(math.abs(matrix.length - j))\n        .min(math.abs(1 - i))\n        .min(math.abs(1 - j))\n        rotations(n)(i-1)(j-1)\n      }.toArray                        \n    }.toArray\n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335723,"user_id":636,"body":"object Kata {\n\n  implicit class RotateLikeAVortex(val matrix: Array[Array[Int]]) {\n    \n    def middle = {\n      if (matrix.size > 1)\n        matrix.tail.init.foldLeft(Array[Array[Int]]())(\n          (t,c) => t :+ c.tail.init\n        )\n      else Array[Array[Int]]()\n    }\n\n    def top =   if (matrix.size > 1) Array(matrix(0).tail.init) else Array[Array[Int]]()\n    def bottom = if (matrix.size > 1) Array(matrix(matrix.size - 1).tail.init) else Array[Array[Int]]()\n    def left = matrix.foldLeft(Array[Array[Int]]())(\n      (t,c) => t :+ Array(c(0)))\n    def right = matrix.foldLeft(Array[Array[Int]]())(\n      (t,c) => t :+ Array(c(c.size - 1)))\n\n    type Matrix = Array[Array[Int]]\n    def reconstitute(left: Matrix, top: Matrix, middle: Matrix, bottom: Matrix, right:Matrix) = {\n      val mid = top ++ middle ++ bottom\n      (for (i <- 0 to left.size - 1) yield\n        left(i) ++ mid(i) ++ right(i)).toArray\n    }\n\n    def rotate: Array[Array[Int]] =\n      if (matrix.size <= 1) matrix\n      else {\n        val rot = {\n          val flat = matrix.flatten.zipWithIndex\n          val size = matrix(0).size\n          for (loc <- size - 1 to 0 by -1) yield\n            flat.filter(i => (i._2 - loc) % size == 0).map(_._1)\n        }.toArray\n        reconstitute(rot.left, rot.top, rot.middle.rotate, rot.bottom, rot.right )\n      }\n  }\n\n  \n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] = \n    matrix.rotate\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335724,"user_id":null,"body":"import scala.collection.JavaConverters._\n\nobject Kata {\n\n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n    \n\n    val mat = matrix.map(_.clone)\n    def rotate(n: Int, i: Int, m: Array[Array[Int]]): Array[Array[Int]] = {\n      if(i >= n\/2){\n          m\n      }else {\n          matrix.toList.slice(i, matrix.length-i).foreach(x => {val r = mat(matrix.indexOf(x));\n                                                           var a = i; \n                                                           x.toList.slice(i, matrix.length-i).foreach(y => {r(a) = m(a)((matrix.length-1) - matrix.indexOf(x)); a += 1; })\n                                                          mat(matrix.indexOf(x)) = r\n                                                          }\n                                                    )\n\n          rotate(n, i+1, mat.map(_.clone))\n      }\n      \n    }\n\n    rotate(matrix.length, 0, matrix)\n  }\n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335725,"user_id":null,"body":"object Kata {\n\n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] =\n      Array.tabulate(matrix.size, matrix.size) { (row, col) =>\n        nextItem(col, row, matrix)(rotation(ring(col, row, matrix)))\n      }\n  \n  private def nextItem(\n        col: Int,\n        row: Int,\n        matrix: Array[Array[Int]]\n    ): Rotation => Int = {\n      case Zero   => matrix(row)(col)\n      case Once   => matrix(col)(matrix.size - 1 - row)\n      case Twice  => matrix(matrix.size - 1 - row)(matrix.size - 1 - col)\n      case Thrice => matrix(matrix.size - 1 - col)(row)\n    }\n\n  sealed trait Rotation\n  object Zero extends Rotation\n  object Once extends Rotation\n  object Twice extends Rotation\n  object Thrice extends Rotation\n\n  private val rotations: LazyList[Rotation] =\n      Once #:: Twice #:: Thrice #:: Zero #:: rotations\n\n  private def rotation(ring: Int): Rotation = rotations.drop(ring).head\n\n  private def ring(col: Int, row: Int, matrix: Array[Array[Int]]): Int =\n      Seq(col, row, matrix.size - 1 - row, matrix.size - 1 - col).min\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335726,"user_id":null,"body":"object Kata {\nsealed trait Rotation\n    object Zero extends Rotation\n    object Once extends Rotation\n    object Twice extends Rotation\n    object Thrice extends Rotation\n\n    val rotations: LazyList[Rotation] = Once #:: Twice #:: Thrice #:: Zero #:: rotations\n\n    def rotation(ring: Int): Rotation = rotations.drop(ring).head\n\n    def ring(col: Int, row: Int, matrix: Array[Array[Int]]): Int = {\n      def ringAux(ring: Int): Int =\n        if (col == ring || row == ring || col == matrix.size - 1 - ring || row == matrix.size - 1 - ring) ring\n        else ringAux(ring + 1)\n      ringAux(0)\n    }\n\n    def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] =\n      Array.tabulate(matrix.size) { row =>\n        Array.tabulate(matrix.size) { col =>\n          nextItem(col, row, matrix)(rotation(ring(col, row, matrix)))\n        }\n    }\n\n    def nextItem(col: Int, row: Int, matrix: Array[Array[Int]]): Rotation => Int = {\n      case Zero => matrix(row)(col)\n      case Once => matrix(col)(matrix.size - 1 - row)\n      case Twice => matrix(matrix.size - 1 - row)(matrix.size - 1 - col)\n      case Thrice => matrix(matrix.size - 1 - col)(row)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335727,"user_id":null,"body":"object Kata {\n\n  def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n      val allRotatedStates = (1 to 3).scanLeft(matrix) {\n        case (m, _) => m.transpose.reverse\n      }\n      Array.tabulate(matrix.length, matrix.length) {\n        case (i, j) =>\n          val ring = Seq(i + 1, j + 1, matrix.length - i, matrix.length - j).min % 4\n          allRotatedStates(ring)(i)(j)\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335728,"user_id":null,"body":"object Kata {\n\n    case class ElementWithPosition(value: Int, row: Int, column: Int)\n\n    def rotateLikeAVortex(matrix: Array[Array[Int]]): Array[Array[Int]] = {\n      val size = matrix.length - 1\n\n      matrix.zipWithIndex\n        .flatMap(\n          row =>\n            row._1.zipWithIndex.map(\n              element => ElementWithPosition(element._1, row._2, element._2)\n          )\n        )\n        .map { x =>\n          val ring = Math.min(\n            Math.abs(if (x.row <= size \/ 2) x.row else size - x.row),\n            Math.abs(if (x.column <= size \/ 2) x.column else size - x.column)\n          )\n          ring % 4 match {\n            case 0 =>\n              ElementWithPosition(x.value, size - x.column, x.row)\n            case 1 =>\n              ElementWithPosition(x.value, size - x.row, size - x.column)\n            case 2 => ElementWithPosition(x.value, x.column, size - x.row)\n            case 3 => x\n          }\n        }\n        .groupBy(_.row)\n        .mapValues(_.sortBy(_.column).map(_.value))\n        .toArray\n        .sortBy(_._1)\n        .map(_._2)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335729,"user_id":null,"body":"object Kata {\n\n  def rotateLikeAVortex(matrix: Array[Array[Int]], n: Int = 1): Array[Array[Int]] =\n    if (matrix.length < 2) {\n      matrix\n    } else {\n      val newMatrix = rotateBorder(matrix, n)\n      val center    = rotateLikeAVortex(getCenter(matrix), n + 1)\n      val row1      = newMatrix.head\n      val rowLast   = newMatrix.last\n      val col1      = newMatrix.map(_.head)\n      val colLast   = newMatrix.map(_.last)\n      (row1 +: center.indices.map(i => col1(i + 1) +: center(i) :+ colLast(i + 1)) :+ rowLast).toArray\n    }\n\n  @scala.annotation.tailrec\n  private def rotateBorder(matrix: Array[Array[Int]], n: Int): Array[Array[Int]] =\n    if (n % 4 == 0 || matrix.length < 2) {\n      matrix\n    } else {\n      val l       = matrix.length\n      val row1    = matrix.head\n      val rowLast = matrix.last\n      val col1    = matrix.map(_.head)\n      val colLast = matrix.map(_.last)\n      val center  = getCenter(matrix)\n      val newMatrix =\n        (colLast +: center.indices.map(i => row1(l - 2 - i) +: center(i) :+ rowLast(l - 2 - i)) :+ col1).toArray\n      rotateBorder(newMatrix, (n - 1) % 4)\n    }\n\n  private def getCenter(matrix: Array[Array[Int]]): Array[Array[Int]] =\n    (1 until matrix.length - 1).map(i => (1 until matrix.length - 1).map(j => matrix(i)(j)).toArray).toArray\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58d76854024c72c3e20000de":[{"id":335730,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n    str.split(\" \").zipWithIndex.map{case (w, i) => if (i % 2 == 0 ) w else w.reverse }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335731,"user_id":573,"body":"object Solution {\n\n  def reverse(str: String): String =\n    str\n      .trim.split(\" +\")\n      .zipWithIndex\n      .map {\n        case (w, i) if i%2 == 0 => w\n        case (w, _)             => w.reverse\n      }\n      .mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335732,"user_id":527,"body":"object Solution {\n  def reverse(str: String): String = {\n    str.split(' ').zipWithIndex.map{ case (s, i) => if (i % 2 == 0) s else s.reverse }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335733,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n    str.split(\" \").zipWithIndex.map{case (value, index) => if (index % 2 != 0) value.reverse else value}.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335734,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n    str.split(\" \").zipWithIndex.map(x => if (x._2 % 2 == 0) x._1 else x._1.reverse).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335735,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n    str.split(' ').zipWithIndex.map {\n      case (s, i) if i % 2 == 0 => s\n      case (s, _) => s.reverse\n    }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335736,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n    str.split(' ').grouped(2)\n      .map{ case Array(a,b @ _*) => List(a) ++ b.map(_.reverse) }\n      .flatten.mkString(\" \") \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335737,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n    str\n      .split(\" \")\n      .zipWithIndex\n      .map(pair => if(pair._2 % 2 == 0) pair._1 else pair._1.reverse)\n      .mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335738,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = {\n   str.split(\" \").zipWithIndex.map(e => {\n     if (e._2 % 2 == 0) e._1\n     else e._1.reverse\n   }).mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335739,"user_id":null,"body":"object Solution {\n  def reverse(str: String): String = str.trim.split(' ').zipWithIndex.map { case (str, i) => if (i % 2 != 0) str.reverse else str }.mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58e24788e24ddee28e000053":[{"id":335740,"user_id":null,"body":"object SimpleAssembler {\n  def simple_assembler(program: Seq[String]): Map[String, Int] = {\n    val instructions = program.toArray\n    val registers = collection.mutable.Map[String, Int]()\n    def regOrConst(s: String): Int = s.toIntOption.getOrElse(registers(s))\n    var i = 0\n    while (i < instructions.length) {\n      instructions(i) match {\n        case s\"mov $x $y\" => registers(x) = regOrConst(y)\n        case s\"inc $x $_\" => registers(x) += 1\n        case s\"inc $x\"    => registers(x) += 1\n        case s\"dec $x $_\" => registers(x) -= 1\n        case s\"dec $x\"    => registers(x) -= 1\n        case s\"jnz $x $y\" => if (regOrConst(x) != 0) i += regOrConst(y) - 1\n      }\n      i += 1\n    }\n    registers.toMap\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335741,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject SimpleAssembler {\n  def simple_assembler(program: Seq[String]): Map[String, Int] = {\n    @tailrec\n    def _interpret(\n      instructions: Map[Int, String],\n      currentIndex: Int,\n      registers: Map[String, Int]\n    ): Map[String, Int] =\n      if (currentIndex >= instructions.size) registers\n      else {\n        instructions(currentIndex).split(\" \").toList match {\n          case \"mov\" :: targetRegister :: valueOrSourceRegister :: _ =>\n            val targetValue = valueOrSourceRegister.toIntOption.getOrElse(\n              registers(valueOrSourceRegister)\n            )\n\n            _interpret(\n              instructions,\n              currentIndex + 1,\n              registers.updated(targetRegister, targetValue)\n            )\n          case \"inc\" :: register :: _ =>\n            _interpret(\n              instructions,\n              currentIndex + 1,\n              registers.updated(register, registers(register) + 1)\n            )\n          case \"dec\" :: register :: _ =>\n            _interpret(\n              instructions,\n              currentIndex + 1,\n              registers.updated(register, registers(register) - 1)\n            )\n          case \"jnz\" :: valueOrRegisterToTest :: indexChange :: _ =>\n            val valueToTest = valueOrRegisterToTest.toIntOption.getOrElse(\n              registers(valueOrRegisterToTest)\n            )\n            if (valueToTest == 0)\n              _interpret(instructions, currentIndex + 1, registers)\n            else\n              _interpret(\n                instructions,\n                currentIndex + indexChange.toInt,\n                registers\n              )\n          case _ => throw new IllegalStateException(s\"Oops for program $program\")\n        }\n      }\n\n    _interpret(\n      program.zipWithIndex.map {\n        case (value, index) => (index, value)\n      }.toMap,\n      0,\n      Map()\n    )\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335742,"user_id":null,"body":"import scala.util.Try\nimport scala.annotation.tailrec\n\nobject SimpleAssembler {\n  def simple_assembler(program: Seq[String]): Map[String, Int] = {\n    val MovPattern = \"mov ([A-Za-z0-9]+) ([A-Za-z0-9_.-]+)\".r\n    val IncPattern = \"inc ([A-Za-z0-9]+).*\".r\n    val DecPattern = \"dec ([A-Za-z0-9]+).*\".r\n    val JnzPattern = \"jnz ([A-Za-z0-9]+) ([A-Za-z0-9_.-]+)\".r\n\n    @tailrec\n    def interpretProgram(program: Seq[String], currentIdx: Int, mapResult: Map[String, Int]): Map[String, Int] = {\n      if (currentIdx >= program.length) mapResult\n      else {\n        val (newMap, idxInc) = program(currentIdx) match {\n          case MovPattern(from, to) =>\n            if (Try(to.toInt).isSuccess)  (mapResult + (from -> to.toInt), 1)\n            else (mapResult + (from -> mapResult(to)), 1)\n          case IncPattern(recordName) =>\n            (mapResult + (recordName -> (mapResult(recordName) + 1)), 1)\n          case DecPattern(recordName) =>\n            (mapResult + (recordName -> (mapResult(recordName) - 1)), 1)\n          case JnzPattern(recordName, jumpTo) =>\n            if ((Try(recordName.toInt).isSuccess && recordName.toInt == 0) || mapResult.get(recordName).contains(0))\n              (mapResult, 1)\n            else (mapResult, jumpTo.toInt)\n          case _ =>\n            (mapResult, 1)\n        }\n        interpretProgram(program, currentIdx + idxInc, newMap)\n      }\n    }\n    interpretProgram(program, 0, Map[String, Int]())\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335743,"user_id":null,"body":"object SimpleAssembler {\n\n  def simple_assembler(program: Seq[String], index: Int = 0, state: Map[String, Int] = Map.empty[String, Int]): Map[String, Int] = {\n    \n    def getVal(x: String): Int = x.toIntOption match {\n      case None => state(x)\n      case Some(n) => n\n    }\n\n    if (index >= program.length) state else {\n      program(index) match {\n        case s\"$op $rest\" => op match {\n          case \"inc\" => interpret(program,index+1,state.updatedWith(rest){case Some(x) => Some(x+1)})\n          case \"dec\" => interpret(program,index+1,state.updatedWith(rest){case Some(x) => Some(x-1)})\n          case \"mov\" => rest match {\n            case s\"$r $v\" => interpret(program,index+1,state.updatedWith(r){case _ => Some(getVal(v))})\n          }\n          case \"jnz\" => rest.split(' ') match {\n            case Array(r,v,_*) =>\n              interpret(\n                program,\n                index + (if (getVal(r) != 0) getVal(v) else 1),\n                state\n              )\n          }\n        }\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335744,"user_id":null,"body":"import scala.collection.mutable.HashMap\n\nobject SimpleAssembler {\n  def read_num(s: String): Option[Int] = {\n    try {\n      Some(Integer.parseInt(s))\n    } catch {\n      case e: Exception => None\n    }\n  }\n  \n  def simple_assembler(program: Seq[String]): Map[String, Int] = {\n    val instructions = program.toVector.map(_.split(' '))\n    var hm = new HashMap[String, Int]()\n    \n    var idx = 0\n    while (idx < instructions.length) {\n      instructions(idx) match {\n        case Array(\"mov\", x, y) => {\n          hm(x) = read_num(y).getOrElse(hm(y))\n          idx += 1\n        }\n        case Array(\"inc\", x) => { hm.update(x, hm(x) + 1); idx += 1 }\n        case Array(\"dec\", x) => { hm.update(x, hm(x) - 1); idx += 1 }\n        case Array(\"jnz\", x, y) => {\n          if (read_num(x).getOrElse(hm(x)) != 0) {\n            idx += read_num(y).getOrElse(hm(y))\n          } else {\n            idx += 1\n          }\n        }\n      };\n    }\n    \n    return hm.toMap\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335745,"user_id":null,"body":"\nimport scala.collection.mutable\n\nobject SimpleAssembler {\n  var registers = mutable.Map[String, Int]()\n\n  def run(str: String, counter: Int): Int = {\n    val fields = str.split(\"\\\\s+\")\n    val op = fields(0)\n    op match {\n      case \"mov\" =>\n        val registerVal = registers.getOrElse(fields(1), 0)\n        if (fields(2).head.isLetter) {\n          val newRegisterVal = registers.getOrElse(fields(2), 0)\n          registers.put(fields(1), newRegisterVal)\n        } else {\n          registers.put(fields(1), fields(2).toInt)\n        }\n        counter + 1\n      case \"inc\" =>\n        val registerVal = registers.getOrElse(fields(1), 0)\n        registers.put(fields(1), registerVal + 1)\n        counter + 1\n      case \"dec\" =>\n        val registerVal = registers.getOrElse(fields(1), 0)\n        registers.put(fields(1), registerVal - 1)\n        counter + 1\n      case \"jnz\" =>\n        if (fields(1).head.isLetter) {\n          val registerVal = registers.getOrElse(fields(1), 0)\n          \/\/println(s\"registerVal $registerVal\")\n          if (registerVal != 0) {\n            if (fields(2).head.isLetter) {\n              val newRegisterVal = registers.getOrElse(fields(2), 0)\n              counter + newRegisterVal\n            } else {\n              counter + fields(2).toInt\n            }\n          } else {\n            counter + 1\n          }\n        } else {\n          val nextVal = fields(1).toInt\n          if (nextVal != 0) {\n            counter + fields(2).toInt\n          } else {\n            counter + 1\n          }\n        }\n      case _ => println(\"Unknown\")\n        counter + 1\n    }\n  }\n\n  def simple_assembler(program: Seq[String]): mutable.Map[String, Int] = {\n    \/\/program.foreach(println)\n    \/\/println(\"====================\")\n    \/\/It's your turn to shine !\n    registers = mutable.Map[String, Int]()\n    val arr = program.toArray\n    var nextStep = 0\n    var count = 0\n    while (nextStep < arr.length) {\n      count += 1\n      \/\/print(s\"from $nextStep, ${arr(nextStep)} \")\n      nextStep = run(arr(nextStep), nextStep)\n      \/\/println(s\"$registers, to $nextStep\")\n      \/\/if (count > 4_000_000) {\n        \/\/nextStep = arr.length\n      \/\/}\n    }\n    registers\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335746,"user_id":360,"body":"import scala.collection.mutable.Map\n\nobject SimpleAssembler {\n  val REG = raw\"([a-z])\".r\n  val VAL = raw\"(-?\\d+)\".r\n  \n  val MOV = raw\"mov (.+) (.+)\".r\n  val INC = raw\"inc (.+)\".r\n  val DEC = raw\"dec (.+)\".r\n  val JNZ = raw\"jnz (.+) (.+)\".r\n  \n  def simple_assembler(program: Seq[String]): Map[String, Int] = {    \n    var regs = Map[String, Int]()\n    \n    def parse(arg: String): Int = arg match {\n      case REG(r) => regs(r)\n      case VAL(i) => i.toInt\n    }\n\n    var i = 0\n    while (i < program.length) {\n      program(i) match {\n        case MOV(d, s) => regs(d) = parse(s)\n        case INC(d) => regs(d) += 1\n        case DEC(d) => regs(d) -= 1\n        case JNZ(t, o) => if (parse(t) != 0) i += parse(o) - 1\n      }\n      i += 1\n    }\n\n    regs\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335747,"user_id":null,"body":"object SimpleAssembler {\n  object Int {\n    def unapply(v: String) =\n      try Some(v.toInt)\n      catch { case _: NumberFormatException => None }\n  }\n\n  def simple_assembler(raw: List[String]): Map[String, Int] = {\n    val program = raw.map(_.split(' ').toList)\n    val acc = scala.collection.mutable.Map.empty[String, Int]\n\n    @scala.annotation.tailrec\n    def loop(i: Int): Unit = {\n        if (i < 0 || i >= program.size) {\n            ()\n        } else {\n            program(i) match {\n                case \"mov\" :: a :: Int(v) :: Nil =>\n                    acc(a) = v\n                    loop(i + 1)\n                case \"mov\" :: a :: b :: Nil =>\n                    acc(a) = acc(b)\n                    loop(i + 1)\n                case \"inc\" :: a :: Nil =>\n                    acc(a) += 1\n                    loop(i + 1)\n                case \"dec\" :: a :: Nil =>\n                    acc(a) -= 1\n                    loop(i + 1)\n                case \"jnz\" :: Int(c) :: Int(n) :: Nil =>\n                    if (c != 0) loop(i + n)\n                    else loop(i + 1)\n                case \"jnz\" :: a :: Int(n) :: Nil =>\n                    if (acc(a) != 0) loop(i + n)\n                    else loop(i + 1)\n            }\n        }\n    }\n\n    loop(0)\n    acc.toMap\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:00"},{"id":335748,"user_id":null,"body":"object SimpleAssembler {\n  def simple_assembler(program: Seq[String]): Map[String, Int] = {\n    println(program)\n    loopProgram(program.toArray, 0)\n  }\n\n  def loopProgram(array: Array[String], currentPosition: Int, result: Map[String, Int] = Map.empty): Map[String, Int] = {\n    if (currentPosition < 0) throw new IllegalStateException\n    else if (currentPosition >= array.length) result\n    else {\n      val (nextPosition, updatedState) = processInstruction(array(currentPosition), currentPosition, result)\n      loopProgram(array, nextPosition, updatedState)\n    }\n  }\n\n  def processInstruction(op: String, currentPosition: Int, state: Map[String, Int]): (Int, Map[String, Int]) = {\n      op match {\n        case s\"mov $e $v\" => (currentPosition + 1, state + (e -> state.get(v).getOrElse(v.toInt)))\n        case s\"inc $e\" => (currentPosition + 1, state + (e -> (state(e) + 1)))\n        case s\"dec $e\" => (currentPosition + 1, state + (e -> (state(e) - 1)))\n        case s\"jnz $e $v\" =>\n          val isZero = state.get(e).getOrElse(e.toInt) == 0\n          if (isZero) {\n            (currentPosition + 1, state)\n          } else {\n            (currentPosition + state.get(v).getOrElse(v.toInt), state)\n          }\n        case _ => throw new IllegalStateException\n      }\n    }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"},{"id":335749,"user_id":null,"body":"import scala.collection.mutable.{Map => MMap}\n\nobject SimpleAssembler {\n  def simple_assembler(program: Seq[String]): Map[String, Int] = {\n    \n    var pc = 0 \/\/ Program counter\n    val regs = MMap[String, Int]() \/\/ register table\n    \n    \/\/ Disambiguate between registers and constants\n    def immOrReg(r: String): Int = {\n      if (regs contains r)\n        regs(r)\n      else\n        r.toInt\n    }\n    \n    while (pc < program.length) {\n      \/\/ Dispatch the instructions\n      program(pc) match {\n        case s\"mov $x $y\" =>  regs(x) = immOrReg(y)\n        case s\"inc $x\" => regs(x) =  regs(x) + 1\n        case s\"dec $x\" => regs(x) =  regs(x) - 1\n        case s\"jnz $x $y\" => if (immOrReg(x) != 0) pc = pc + y.toInt - 1\n      }\n      \/\/ Advances the program counter\n      pc = pc + 1\n    }\n    Map.from(regs)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-02 19:54:29"}],"58f8a3a27a5c28d92e000144":[{"id":335750,"user_id":573,"body":"object Fnc {\n\n  def first_non_consecutive(xs: Seq[Int]): Option[Int] =\n    xs.sliding(2).collectFirst { case Seq(x, y) if y != x+1 => y }\n}","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335751,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = {\n    values\n      .zip(values.tail)\n      .find { case (a, b) =>b-a != 1 }\n      .map(_._2)\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_semi_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335752,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = values match {\n    case Seq(_) | Seq() => Option.empty\n    case Seq(h, t@_*) if h + 1 != t.head => t.headOption\n    case Seq(_, t@_*) => first_non_consecutive(t)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335753,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = values.toList match {\n    case a::b::tail if b - a == 1 => first_non_consecutive(b::tail)\n    case a::b::_ if b - a > 1 => Some(b)\n    case _::Nil => None\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335754,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]) = {\n    values.sliding(2).collectFirst{ case Seq(a, b) if b != a + 1 => b}\n\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335755,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Any = {\n        if (values.isEmpty) None\n        else if (values.length == 1) None\n        else if (values(1) - values(0) == 1) first_non_consecutive(values.drop(1))\n        else Some(values(1))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335756,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = {\n    def aux(seq: Seq[Int], current:Int): Option[Int] = {\n      if (seq.length==0) None else {\n        if (seq(0) == current+1) aux(seq.tail, seq(0))\n        else Some(seq(0))\n      }\n    }\n    aux(values.tail,values(0))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335757,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = {\n    values.sliding(2).dropWhile {\n      case Seq(n, m) => m == n + 1\n    }.nextOption.map(_.apply(1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335758,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = values.sliding(2, 1).find(x => x.head + 1 != x.last).map(x => x(1))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335759,"user_id":null,"body":"object Fnc {\n  def first_non_consecutive(values: Seq[Int]): Option[Int] = \n      values.sliding(2).collectFirst {\n      case Seq(x, y) if x != y - 1 => y\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"590ba2baf06c49595f0000a0":[{"id":335760,"user_id":null,"body":"object Logger {\n  type Complex = Array[Double]\n  val Complex = Array\n  def log (z: Complex): Complex = {\n    z match {\n      case Complex(0, 0) => \n        throw new ArithmeticException\n      case Complex(x, y) =>\n        val r = math.hypot(x, y)\n        val theta = math.atan2(y, x)\n        Complex(math.log(r), theta)\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335761,"user_id":573,"body":"import math.{log => ln, hypot, atan2}\n\nobject Logger {\n\n  def log(complex: Array[Double]): Array[Double] =\n    complex match {\n      case Array(0, 0) => throw new ArithmeticException()\n      case Array(x, y) => Array(ln(hypot(x, y)), atan2(y, x))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335762,"user_id":null,"body":"object Logger {\n  import scala.math.{ hypot, atan2 }\n  def log(complex: Array[Double]): Array[Double] = {\n    complex match {\n      case Array(0, 0) => throw new ArithmeticException\n      case Array(a, b) => Array(scala.math.log(hypot(a, b)), atan2(b, a))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335763,"user_id":null,"body":"import math._\nobject Logger {\n  def log(complex: Array[Double]): Array[Double] = {\n    if(complex(0)==0 && complex(1) == 0) throw new ArithmeticException(\"\") \/\/ do it!\n    else Array(math.log(module(complex)),atan2(complex(1),complex(0)))\n  }\n  def module(complex: Array[Double]): Double = sqrt(pow(complex(0),2)+pow(complex(1),2))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335764,"user_id":null,"body":"object Logger {\n  def log(complex: Array[Double]): Array[Double] = {\n    if (complex(0) == 0 && complex(1) == 0) {\n      throw new ArithmeticException(\"Zero is invalid argument\")\n    }\n    else {\n      val Re = math.log(math.sqrt(complex.map(x => x*x).sum))\n      val Im = math.atan2(complex(1), complex(0))\n      Array(Re, Im)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335765,"user_id":null,"body":"object Logger {\n  def log(complex: Array[Double]): Array[Double] = {\n    val x = complex.head\n    val y = complex.last\n    val r = math.hypot(x, y)\n    if (r == 0) {\n      throw new ArithmeticException\n    } else {\n      val phi = math.atan2(y, x)\n      Array(math.log(r), phi)\n    }\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335766,"user_id":null,"body":"object Logger {\n  def log(complex: Array[Double]): Array[Double] = {\n    val x = complex(0)\n    val y = complex(1)\n    \n    if (x == 0.0 && y == 0.0)\n      throw new ArithmeticException(\"\")\n\n    Array(\n      math.log(math.hypot(x, y)),\n      math.atan2(y, x)\n    )\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335767,"user_id":492,"body":"object Logger {\n  def log(z: Array[Double]): Array[Double] = {\n    val x: Double = z(0)\n    val y: Double = z(1)\n    if (x == 0.0 && y == 0.0) throw new ArithmeticException()\n    val mag: Double = Math.sqrt(x * x + y * y)\n    val arg: Double = Math.atan2(y, x)\n    Array(Math.log(mag), arg)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335768,"user_id":null,"body":"object Logger {\n  def log(complex: Array[Double]): Array[Double] = \n  if(mod(complex)==0) {\n    throw new ArithmeticException()\n  } else {\n    List(\n      Math.log(mod(complex)),\n      arg(complex)\n    ).toArray\n  }\n  private def mod(z: Array[Double]):Double=\n   Math.sqrt(z(0)*z(0)+z(1)*z(1))\n     \n  private def arg(z: Array[Double]):Double=\n    arg0(z,mod(z))\n  private def arg0(z: Array[Double], d:Double):Double=\n   arg1(z.map(x=>x\/d))\n   \n  private def arg1(z: Array[Double]):Double= {  \n     val m = if(z(1)>=0) { 1 } else { -1 }\n     m*Math.acos(z(0))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335769,"user_id":null,"body":"object Logger {\n  def log(complex: Array[Double]): Array[Double] = {\n    import math._\n    val (x, y) = (complex(0), complex(1))\n    val r = sqrt(x * x + y * y)\n    val theta = (x, y) match {\n      case (0.0, 0.0) => throw new ArithmeticException\n      case (x, 0.0) if x < 0.0 => Pi\n      case (x, y) => 2 * atan(y \/ (r + x))\n    }\n    Array(math.log(r), theta)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5919f3bf6589022915000023":[{"id":335770,"user_id":null,"body":"object RotateAgainstClockwise {\n\n  import scala.annotation.tailrec\n  \n  @tailrec def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n    (matrix, times % 4) match {\n      case (null, _)  => null\n      case (m, 0)     => m\n      case (m, _) if m.forall(_.isEmpty) => m\n      case (m, t)     => rotate(m.transpose.reverse, t - 1)\n    }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335771,"user_id":null,"body":"object RotateAgainstClockwise {\n    def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n      (matrix, times) match {\n        case (null, _) => null\n        case (_, 0) => matrix\n        case (m, _) if (m(0).isEmpty) => m\n        case (m, t) => rotate(m.transpose.reverse, t - 1)\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335772,"user_id":null,"body":"object RotateAgainstClockwise {\n    def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n      (matrix, times) match {\n        case (null, _)  => null\n        case (_, 0)     => matrix\n        case (m, _) if matrix.filter{!_.isEmpty}.isEmpty   => matrix\n        case (m, t)     => rotate(m.transpose.reverse, t - 1)\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335773,"user_id":null,"body":"object RotateAgainstClockwise {\n  def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n    if (times % 4 == 0 || matrix == null)\n      matrix\n    else if (matrix(0).length == 0)\n      List(List())\n    else {\n      rotate(\n        0.until(matrix.length).toList.map(i => matrix.map(l => l(matrix.length - i - 1))),\n        times % 4 - 1\n      )\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335774,"user_id":751,"body":"object RotateAgainstClockwise {\n    type Matrix = List[List[Int]]\n    def rotateCcw(m: Matrix): Stream[Matrix] = m #:: rotateCcw(m.transpose.reverse)\n    def rotate(mat : Matrix, n: Int) : Matrix = Option(mat) match { \n      case None | Some(List(List())) => mat\n      case _ => rotateCcw(mat).drop(n % 4).head\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335775,"user_id":null,"body":" object RotateAgainstClockwise {\n    def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n      if(matrix == null) {\n        return  null\n      } else if(matrix.head.isEmpty) return { List(List())}\n      val t = times%4 + 1\n      def rot(matrix : List[List[Int]])  = {\n        val res = for {\n          i <- matrix.indices\n            r = matrix.foldLeft(List[Int]())((acc, x) => acc :+ x(x.size - i - 1))\n        } yield r\n        res.toList\n      }\n     val b = List.iterate(matrix, t) { xs =>\n       rot(xs)\n     }\n      b.last\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335776,"user_id":null,"body":"object RotateAgainstClockwise {\n    type Matrix[A] = Map[(Int, Int), A]\n\n    def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n      matrix match {\n        case null => null\n        case data if data(0).size == 0 => data\n        case _ => {\n             val matrixMap = convert(matrix)\n             convert((0 until times % 4).foldLeft(matrixMap)((rotatedMatrix, _) => rotate(rotatedMatrix, matrix.size)), matrix.size)\n        }\n      }\n   \n    }\n  \n  \n    private def rotate(matrix : Matrix[Int], size: Int): Matrix[Int] = {\n      matrix map {case ((rowIndex, columnIndex), value) => ((size - 1 - columnIndex, rowIndex), value)}\n    }\n  \n    private def convert(matrix: List[List[Int]]): Matrix[Int] = {\n      matrix.zip(0 until matrix.size).flatMap{ case (row, rowIndex) => row.zip(0 until row.size).map{case (value, columnIndex) => (rowIndex, columnIndex) -> value }}.toMap\n    }\n  \n    private def convert(matrix: Matrix[Int], size: Int): List[List[Int]] = {\n      (0 until size).map (\n        (rowIndex) => (0 until size).map((columnIndex) => matrix.get((rowIndex, columnIndex)).getOrElse(-1)).toList\n      ).toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335777,"user_id":null,"body":"object RotateAgainstClockwise {\n    def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = {\n      if (matrix == List(List())) List(List())\n      else if (matrix == null) null\n      else\n        times % 4 match {\n          case 0 => matrix\n          case 1 => (for (j<-matrix.size-1 to 0 by -1) yield\n            (for (i<-0 until matrix.size) yield matrix(i).apply(j)).toList).toList\n          case 2 => matrix.map(_.reverse).reverse\n          case 3 => (for (j<-0 until matrix.size) yield\n            (for (i<-0 until matrix.size) yield matrix(i).apply(j)).reverse.toList).toList\n      }      \n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335778,"user_id":null,"body":"object RotateAgainstClockwise {\n  def rotate(matrix : List[List[Int]], times: Int) : List[List[Int]] = if(matrix==null) null else\n    if(matrix.isEmpty) List(List())\n    else if(times %4== 0) matrix\n    else rotate(matrix.transpose.reverse, times%4-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335779,"user_id":null,"body":"object RotateAgainstClockwise {\n    def rotate(matrix : List[List[Int]], times: Int): List[List[Int]] = {\n      def rotateAux: List[List[Int]] = {\n        if (times == 0) matrix \n        else rotate(matrix.transpose.reverse, times - 1)\n      }\n      if (matrix == null || matrix.length == 0 || matrix(0).length == 0) matrix\n      else rotateAux\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5922543bf9c15705d0000020":[{"id":335780,"user_id":750,"body":"object Isomorphism {\n\/**\n * The type [[Nothing]] has no value.\n * So it is impossible to construct an instance of it.\n * In this solution, wherever a situation arises where\n * for types to check, you need a function that takes a [[Nothing]],\n * you can use [[absurd]].\n *\/\ndef absurd[R](n: Nothing): R = ???\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\ntype ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\ndef substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\ndef substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\ndef isoBool: ISO[Boolean, Boolean] = (identity, identity)\ndef isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n\/\/ isomorphism is reflexive\ndef refl[A]: ISO[A, A] = (identity, identity)\n\n\/\/ isomorphism is symmetric\ndef symm[A, B]: ISO[A, B] => ISO[B, A] = {\n  case (ab, ba) => (ba, ab)\n}\n\n\/\/ isomorphism is transitive\ndef trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = {\n  case ((ab, ba), (bc, cb)) =>\n    (a => bc(ab(a)), c => ba(cb(c)))\n}\n\n\/\/ We can combine isomorphism:\ndef isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n  case ((ab, ba), (cd, dc)) => (\n    { case (a, c) => (ab(a), cd(c)) },\n    { case (b, d) => (ba(b), dc(d)) }\n  )\n}\n\ndef isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = {\n  case (ab, ba) => (_.map(ab), _.map(ba))\n}\n\ndef isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n  case (ab, ba) => (_.map(ab), _.map(ba))\n}\n\ndef isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n  case ((ab, ba), (cd, dc)) =>\n    (aOrc => aOrc match {\n      case Left(a) => Left(ab(a))\n      case Right(c) => Right(cd(c))\n    },\n    bOrd => bOrd match {\n      case Left(b) => Left(ba(b))\n      case Right(d) => Right(dc(d))\n    })\n}\n\ndef isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n  case ((ab, ba), (cd, dc)) => (\n    ac => (b => cd(ac(ba(b)))),\n    bd => (a => dc(bd(ab(a)))))\n}\n\n\/\/ Going another way is hard (and is generally impossible)\ndef isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n  case (optAB, optBA) => (\n    a => optAB(Option(a)) match {\n      case Some(b) => b\n      case None => optAB(None).get\n    },\n    b => optBA(Option(b)) match {\n      case Some(a) => a\n      case None => optBA(None).get\n    }\n  )\n}\n\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\/\/ Note that we have\ndef isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = (\n  left => left match {\n    case Left(l) => Left(() :: l)\n    case Right(()) => Left(List.empty)\n  },\n  right => right match {\n    case Left(List()) => Right(())\n    case Left(l) => Left(l.tail)\n    case Right(n) => absurd(n)\n  }\n)\n\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\ndef isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (symm, symm)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335781,"user_id":null,"body":"import cats.implicits._\nimport cats._\nimport cats.arrow.Profunctor\nimport cats.implicits.{toProfunctorOps,toBifunctorOps}\n\nobject Isomorphism {\n\/**\n * The type [[Nothing]] has no value.\n * So it is impossible to construct an instance of it.\n * In this solution, wherever a situation arises where\n * for types to check, you need a function that takes a [[Nothing]],\n * you can use [[absurd]].\n *\/\ndef absurd[R](n: Nothing): R = n\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\ntype ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\ndef substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\ndef substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\ndef isoBool: ISO[Boolean, Boolean] = (identity, identity)\ndef isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n\/\/ isomorphism is reflexive\ndef refl[A]: ISO[A, A] = (identity, identity)\n\n\/\/ isomorphism is symmetric\ndef symm[A, B]: ISO[A, B] => ISO[B, A] = _.swap\n\n\/\/ isomorphism is transitive\ndef trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = { case ((ab, ba), (bc, cb)) => \n  (bc compose ab, ba compose cb)\n}\n\n\/\/ We can combine isomorphism:\ndef isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = isoBifunctor\n\ndef isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = isoFunctor\ndef isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = isoFunctor\ndef isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = isoBifunctor\n\ndef isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {case ((ab, ba), (cd, dc)) => {\n  (_.dimap(ba)(cd), _.dimap(ab)(dc))\n}}\n\ndef isoFunctor[F[_], A, B](implicit fn: Functor[F]): ISO[A, B] => ISO[F[A], F[B]] = {case (ab, ba) => {\n  (fn.map(_)(ab), fn.map(_)(ba))\n}}\ndef isoBifunctor[F[_, _]: Bifunctor, A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[F[A, C], F[B, D]] = {\n  case ((ab, ba), (cd, dc)) => {\n    (_.bimap(ab, cd), _.bimap(ba, dc))\n  }\n}\n\/\/ Going another way is hard (and is generally impossible)\ndef isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {case (optab, optba) =>\n  def liftUnlift[C, D](f: Option[C] => Option[D])(c: C): D = {f(c.some).orElse(f(None)).get}\n  (liftUnlift(optab), liftUnlift(optba))\n}\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\/\/ Note that we have\ndef isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = {\n  val matchLeft: Either[List[Unit], Unit] => Either[List[Unit], Nothing] = { \n    case Left(lu) => Left(() :: lu)\n    case Right(()) => Left(List())\n  }\n\n  val matchRight : Either[List[Unit], Nothing] => Either[List[Unit], Unit] = {\n    case Left(Nil) => Right(())\n    case Left(lst) => Left(lst.tail)\n    case Right(_) => Right(())\n  }\n  (matchLeft, matchRight)\n}\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\ndef isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = {\n  (_.swap, _.swap)\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335782,"user_id":null,"body":"object Isomorphism {\n\ndef main(arg: Array[String]): Unit = { println(\"Snurr film!\") }\n\n\/**\n * The type [[Nothing]] has no value.\n * So it is impossible to construct an instance of it.\n * In this solution, wherever a situation arises where\n * for types to check, you need a function that takes a [[Nothing]],\n * you can use [[absurd]].\n *\/\n\nimport scala.sys._\n\ndef absurd[R](n: Nothing): R = ???\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\ntype ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\ndef substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\ndef substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\ndef isoBool: ISO[Boolean, Boolean] = (identity, identity)\ndef isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n\/\/ isomorphism is reflexive\ndef refl[A]: ISO[A, A] = ( identity, identity )\n\n\/\/ isomorphism is symmetric\ndef symm[A, B]: ISO[A, B] => ISO[B, A] = { case (ab, ba) => (ba, ab) }\n\n\/\/ isomorphism is transitive\ndef trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = { \n  case ( (ab, ba), (bc, cb) ) => ( a => bc(ab(a)), c => ba(cb(c)) )\n}\n\n\/\/ We can combine isomorphism:\ndef isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n  case ((ab, ba), (cd, dc)) => \n    ( { case (a, c) => (ab(a), cd(c)) }, { case (b, d) => (ba(b), dc(d)) } )\n}\n\ndef isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = { \n  case (ab, ba) => ( { list => list.map(ab(_)) }, { case list => list.map(ba(_)) } )\n}\n\ndef isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n  case (ab, ba) => \n    ( opt => opt.map(ab),\n      opt => opt.map(ba) )\n}\n\ndef isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n  case ( (ab, ba), (cd, dc) ) => ( { case Left(a) => Left( ab(a) )\n                                     case Right(c)  => Right( cd(c) )  }\n                                 , { case Left(b) => Left( ba(b) )\n                                     case Right(d)  => Right( dc(d) )  } )\n}\n\ndef isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n  case ( (ab, ba), (cd, dc) ) => ( { case ac => { b => cd( ac( ba(b) ) ) }   } \n                                 , { case bd => { a => dc( bd( ab(a) ) ) }   } )\n}\n\n\/\/ Going another way is hard (and is generally impossible)\ndef isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n  case (oab, oba) => (doAToB(oab), doBToA(oba))\n}\n\ndef doAToB[A, B](f: Option[A] => Option[B]): A => B = {\n  a => f(Some(a)) match {\n         case Some(b) => b\n         case None    => f(None).get\n  }\n}\n\ndef doBToA[A, B](g: Option[B] => Option[A]): B => A = {\n  b => g(Some(b)) match {\n         case Some(a) => a\n         case None    => g(None).get\n  }\n}\n\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\/\/ Note that we have\ndef isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = {\n    ( { case Left( xs )                 => Left(() :: xs)  \n        case Right( () )                => Left( Nil )\n      }\n    , { case Left( x :: xs )            => Left(xs)  \n        case Left( Nil )                => Right( () ) \n        case Right(_)                   => { println(\"isoEU, right\"); absurd(???) }\n      } )\n}\n\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\ndef isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (isoAToB, isoBToA)\n\ndef isoAToB[A, B]: ISO[A, B] => ISO[B, A] = {\n  case (ab, ba) => (ba, ab)\n}\n\ndef isoBToA[A, B]: ISO[B, A] => ISO[A, B] = {\n  case (ba, ab) => (ab , ba)\n}\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335783,"user_id":null,"body":"object Isomorphism {\n\/**\n * The type [[Nothing]] has no value.\n * So it is impossible to construct an instance of it.\n * In this solution, wherever a situation arises where\n * for types to check, you need a function that takes a [[Nothing]],\n * you can use [[absurd]].\n *\/\ndef absurd[R](n: Nothing): R = n.asInstanceOf[R]\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\ntype ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\ndef substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\ndef substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\ndef isoBool: ISO[Boolean, Boolean] = (identity, identity)\ndef isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n\/\/ isomorphism is reflexive\ndef refl[A]: ISO[A, A] = (A => A, A => A)\n\n\/\/ isomorphism is symmetric\ndef symm[A, B]: ISO[A, B] => ISO[B, A] = x => (x._2,  x._1)\n\n\/\/ isomorphism is transitive\ndef trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = { \n  case (x, y) => {\n    def ac(a: A): C = y._1(x._1(a: A))\n    def ca(c: C): A = x._2(y._2(c: C))\n    (ac(_), ca(_))\n  }\n}\n\n\/\/ We can combine isomorphism:\ndef isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n  case ((ab, ba), (cd, dc)) => {\n    def acbd(ac: (A, C)): (B, D) = (ab(ac._1), cd(ac._2))\n    def bdac(bd: (B, D)): (A, C) = (ba(bd._1), dc(bd._2))\n    (acbd(_), bdac(_))\n  }\n}\n\ndef isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = x => (_.map(x._1), _.map(x._2))\n  \ndef isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n  case (ab, ba) => {\n  def opAB(a: Option[A]) = if (a != None) Some(ab(a.get)) else None\n  def opBA(b: Option[B]) = if (b != None) Some(ba(b.get)) else None\n  (opAB(_), opBA(_))\n  }\n}\n  \ndef isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n  case (ab, cd) => {\n    def eAC(e: Either[A, C]): Either[B, D] = {\n      e match {\n        case Left(x) => Left(ab._1(x))\n        case Right(x) => Right(cd._1(x))\n      }\n    }\n    def eBD(e: Either[B, D]): Either[A, C] = {\n      e match {\n        case Left(x) => Left(ab._2(x))\n        case Right(x) => Right(cd._2(x))\n      }\n    }\n    (eAC(_), eBD(_))\n  }\n}\n  \ndef isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n  case (ab, cd) => {\n    val abcd = isoTuple[A, B, C, D](ab, cd)\n    def bd(ac: (A => C))(b: B): D = cd._1(ac(ab._2(b)))\n    def ac(bd: (B => D))(a: A): C = cd._2(bd(ab._1(a)))\n    def toBD(ac: (A => C)): B => D = bd(ac)(_)\n    def toAC(bd: (B => D)): A => C = ac(bd)(_)\n    (toBD(_), toAC(_))\n  }\n}\n\n\/\/ Going another way is hard (and is generally impossible)\ndef isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n  case x => {\n    def ab(a: A): B = x._1(Some(a)).getOrElse(x._1(None).get)\n    def ba(b: B): A = x._2(Some(b)).getOrElse(x._2(None).get)\n    (ab(_), ba(_))\n  }\n}\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\/\/ Note that we have\ndef isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = {\n  \n  def LuN(e: Either[List[Unit], Unit]): Either[List[Unit], Nothing] = {\n    e match {\n      case Left(x) => Left(x)\n      case Right(x) => Left(List.fill(15)(()))\n    }\n  }\n  def EluU(e: Either[List[Unit], Nothing]): Either[List[Unit], Unit] = {\n    e match {\n      case Left(x) if x.length == 15 => Right(())\n      case Left(x) => Left(x)\n    }\n  }\n  (LuN(_), EluU(_))\n}\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\ndef isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (symm[A, B], symm[B, A])\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335784,"user_id":null,"body":"object Isomorphism {\n  \/**\n   * The type [[Nothing]] has no value.\n   * So it is impossible to construct an instance of it.\n   * In this solution, wherever a situation arises where\n   * for types to check, you need a function that takes a [[Nothing]],\n   * you can use [[absurd]].\n   *\/\n  def absurd[R](n: Nothing): R = ???\n\n  \/\/ so, when are two type, `A` and `B`, considered equal?\n  \/\/ a definition might be, it is possible to go from `A` to `B`,\n  \/\/ and from `B` to `A`.\n  \/\/ Going a roundway trip should leave you the same value.\n  \/\/ Unfortunately it is virtually impossible to test this in Scala.\n  \/\/ This is called Isomorphism.\n\n  type ISO[A, B] = (A => B, B => A)\n\n  \/\/ given ISO a b, we can go from a to b\n  def substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n  \/\/ and vice versa\n  def substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n  \/\/ There can be more than one ISO a b\n  def isoBool: ISO[Boolean, Boolean] = (identity, identity)\n\n  def isoBoolNot: ISO[Boolean, Boolean] = (!_, !_)\n\n  \/\/ isomorphism is reflexive\n  def refl[A]: ISO[A, A] = (identity, identity)\n\n  \/\/ isomorphism is symmetric\n  def symm[A, B]: ISO[A, B] => ISO[B, A] = _.swap\n\n  \/\/ isomorphism is transitive\n  def trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = {\n    case ((ab, ba), (bc, cb)) =>\n      (bc compose ab, ba compose cb)\n  }\n\n  \/\/ We can combine isomorphism:\n  def isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n    case ((ab, ba), (cd, dc)) =>\n      (bimapTuple(ab, cd), bimapTuple(ba, dc))\n  }\n\n  def bimapTuple[A, B, C, D](f1: A => C, f2: B => D)(t: (A, B)): (C, D) = (f1(t._1), f2(t._2))\n\n  def isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = {\n    case (ab, ba) =>\n      (_.map(ab), _.map(ba))\n  }\n\n  def isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n    case (ab, ba) =>\n      (_.map(ab), _.map(ba))\n  }\n\n  def isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n    case ((ab, ba), (cd, dc)) =>\n      (bimapEither(ab, cd), bimapEither(ba, dc))\n  }\n\n  def bimapEither[A, B, C, D](fl: A => C, fr: B => D)(e: Either[A, B]): Either[C, D] = e match {\n    case Left(a) => Left(fl(a))\n    case Right(c) => Right(fr(c))\n  }\n\n  def isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[A => C, B => D] = {\n    case ((ab, ba), (cd, dc)) =>\n      (imapFunc(_)(ba, cd), imapFunc(_)(ab, dc))\n  }\n\n  def imapFunc[A, B, C, D](f: A => B)(comap: C => A, map: B => D): C => D = {\n    map compose f compose comap\n  }\n\n  \/\/ Going another way is hard (and is generally impossible)\n  def isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n    case (oab, oba) =>\n      val to: A => B = { a =>\n        oab(Some(a)).orElse(oab(None)).get\n      }\n      val from: B => A = { b =>\n        oba(Some(b)).orElse(oba(None)).get\n      }\n      (to, from)\n  }\n  \/\/ Remember, for all valid ISO, converting and converting back\n  \/\/ Is the same as the original value.\n  \/\/ You need this to prove some case are impossible.\n\n  \/\/ We cannot have\n  \/\/ isoUnEither[A, B, C, D]: ISO[Either[A, B], Either[C, D]] => (ISO[A, C], ISO[B, D])\n  \/\/ Note that we have\n  def isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = {\n    val to: Either[List[Unit], Unit] => Either[List[Unit], Nothing] = {\n      case Left(list) => Left(() :: list)\n      case Right(_) => Left(Nil)\n    }\n\n    val from: Either[List[Unit], Nothing] => Either[List[Unit], Unit] = {\n      case Left(_ :: tail) => Left(tail)\n      case _ => Right(())\n    }\n\n    (to, from)\n  }\n\n  \/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n  \/\/ If we have isoUnEither,\n  \/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n  \/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n  \/\/ So it is impossible to have isoUnEither\n\n  \/\/ And we have isomorphism on isomorphism!\n  def isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] =\n    (_.swap, _.swap)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335785,"user_id":null,"body":"object Isomorphism {\n\n  def absurd[R](n: Nothing): R = ???\n\n  type ISO[A, B] = (A => B, B => A)\n\n  def substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n  def substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n  def isoBool: ISO[Boolean, Boolean] = (identity, identity)\n  \n  def isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n  def refl[A]: ISO[A, A] = (identity, identity)\n\n  def symm[A, B]: ISO[A, B] => ISO[B, A] = _.swap\n\n  def trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = (f1, f2) => (f2._1 compose f1._1, f1._2 compose f2._2)\n\n  def isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n        case ((ab, ba), (cd, dc)) =>\n        val f1: ((A, C)) => (B, D) = t => (ab(t._1), cd(t._2))\n        val f2: ((B, D)) => (A, C) = t => (ba(t._1), dc(t._2))\n        (f1, f2)\n  }\n\n  def isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = {\n        case (ab, ba) => ((as: List[A]) => as map ab, (bs: List[B]) => bs map ba)\n  }\n  \n  def isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n        case (ab, ba) => ((oa: Option[A]) => oa map ab, (ob: Option[B]) => ob map ba)\n  }\n  \n  def isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n    case ((ab, ba), (cd, dc)) =>\n      \n      def mapBoth[U, V, X, Y](e: Either[U, V])(f: U => X)(g: V => Y): Either[X, Y] = e match {\n        case Left(u) => Left(f(u))\n        case Right(v) => Right(g(v))\n      }\n      \n      val f1: Either[A, C] => Either[B, D] = e => mapBoth(e)(ab)(cd)\n      val f2: Either[B, D] => Either[A, C] = e => mapBoth(e)(ba)(dc)\n      \n      (f1, f2)\n  }\n  \n  def isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n    case ((ab, ba), (cd, dc)) =>\n      val f1: (A => C) => (B => D) = (f: A => C) => cd compose (f compose  ba)\n      val f2: (B => D) => (A => C) = (f: B => D) => dc compose (f compose  ab)\n      (f1, f2)\n  }\n  \n  def isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n    case (optAB, optBA) => (\n      a => optAB(Option(a)) match {\n        case Some(b) => b\n        case None => optAB(None).get\n      },\n      b => optBA(Option(b)) match {\n        case Some(a) => a\n        case None => optBA(None).get\n      }\n    )\n  }\n  \n  def isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = (\n    {\n      case Left(l) => Left(() :: l)\n      case Right(()) => Left(List.empty)\n    },\n    {\n      case Left(List()) => Right(())\n      case Left(l) => Left(l.tail)\n      case Right(n) => absurd(n)\n    }\n  )\n  \n  def isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (symm, symm)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335786,"user_id":null,"body":"object Isomorphism {\n  \/**\n   * The type [[Nothing]] has no value.\n   * So it is impossible to construct an instance of it.\n   * In this solution, wherever a situation arises where\n   * for types to check, you need a function that takes a [[Nothing]],\n   * you can use [[absurd]].\n   *\/\n  def absurd[R](n: Nothing): R = n\n\n  \/\/ so, when are two type, `A` and `B`, considered equal?\n  \/\/ a definition might be, it is possible to go from `A` to `B`,\n  \/\/ and from `B` to `A`.\n  \/\/ Going a roundway trip should leave you the same value.\n  \/\/ Unfortunately it is virtually impossible to test this in Scala.\n  \/\/ This is called Isomorphism.\n\n  type ISO[A, B] = (A => B, B => A)\n\n  \/\/ given ISO a b, we can go from a to b\n  def substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n  \/\/ and vice versa\n  def substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n  \/\/ There can be more than one ISO a b\n  def isoBool: ISO[Boolean, Boolean] = (identity, identity)\n  def isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n  \/\/ isomorphism is reflexive\n  def refl[A]: ISO[A, A] = (A => A, A => A)\n\n  \/\/ isomorphism is symmetric\n  def symm[A, B]: ISO[A, B] => ISO[B, A] = _.swap\n\n  \/\/ isomorphism is transitive\n  def trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = (a, b) => (b._1.compose(a._1), a._2.compose(b._2))\n\n  \/\/ We can combine isomorphism:\n  def isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n    case ((ab, ba), (cd, dc)) => (t => (ab(t._1), cd(t._2)), q => (ba(q._1), dc(q._2)))\n  }\n\n  def isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = {\n    case (ab, ba) => (_.map(ab), _.map(ba))\n  }\n  def isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n    case (ab, ba) => (_.map(ab), _.map(ba))\n  }\n  def isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n    case ((ab, ba), (cd, dc)) => (_.map(cd).swap.map(ab).swap, _.map(dc).swap.map(ba).swap)\n  }\n  def isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n    case ((ab, ba), (cd, dc)) => (_.compose(ba).andThen(cd), _.compose(ab).andThen(dc))\n  }\n\n  \/\/ Going another way is hard (and is generally impossible)\n  def isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n    case (ab, ba) => (a => ab(Some(a)).orElse(ab(None)).get, b => ba(Some(b)).orElse(ba(None)).get)\n  }\n  \/\/ Remember, for all valid ISO, converting and converting back\n  \/\/ Is the same as the original value.\n  \/\/ You need this to prove some case are impossible.\n\n  \/\/ We cannot have\n  \/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n  \/\/ Note that we have\n  def isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = {\n      (eu => Left(eu.swap.getOrElse(List.fill(666)(()))), en => en.swap.getOrElse(List.fill(666)(())) match { case a: List[Unit] if a.count(_ == ()) == 666 => Right(()); case a => Left(a) })\n  }\n  \/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n  \/\/ If we have isoUnEither,\n  \/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n  \/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n  \/\/ So it is impossible to have isoUnEither\n\n  \/\/ And we have isomorphism on isomorphism!\n  def isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (_.swap, _.swap)\n      \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335787,"user_id":null,"body":"object Isomorphism {\n\n\/**\n * The type [[Nothing]] has no value.\n * So it is impossible to construct an instance of it.\n * In this solution, wherever a situation arises where\n * for types to check, you need a function that takes a [[Nothing]],\n * you can use [[absurd]].\n *\/\ndef absurd[R](n: Nothing): R = ???\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\ntype ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\ndef substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\ndef substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\ndef isoBool: ISO[Boolean, Boolean] = (identity, identity)\ndef isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n\/\/ isomorphism is reflexive\ndef refl[A]: ISO[A, A] = (identity[A], identity[A])\n\n\/\/ isomorphism is symmetric\ndef symm[A, B]: ISO[A, B] => ISO[B, A] = _.swap\n\n\/\/ isomorphism is transitive\ndef trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = {\n  case ((ab, ba), (bc, cb)) => (ab.andThen(bc), cb.andThen(ba))\n}\n\n\/\/ We can combine isomorphism:\ndef isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n  case ((ab, ba), (cd, dc)) => ({ \n    case (a, c) => ab(a) -> cd(c)\n  }, {\n    case (b, d) => ba(b) -> dc(d)\n  })\n}\n\ndef isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = {\n  case (ab, ba) => ({ l: List[A] =>\n    l.map(ab)\n  }, { l: List[B] =>\n    l.map(ba)\n  })\n}\ndef isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = {\n  case (ab, ba) => ({ o: Option[A] =>\n    o.map(ab)\n  }, { o : Option[B] =>\n    o.map(ba)\n  })\n}\ndef isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n  case ((ab, ba), (cd, dc)) => ({\n    case Right(c) => Right(cd(c))\n    case Left(a) => Left(ab(a))\n  }, {\n    case Right(d) => Right(dc(d))\n    case Left(b) => Left(ba(b))\n  })\n}\n\ndef isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n  case ((ab, ba), (cd, dc)) => ({ ac =>\n    ba.andThen(ac).andThen(cd)\n  }, { bd =>\n    ab.andThen(bd).andThen(dc)\n  })\n}\n\n\/\/ Going another way is hard (and is generally impossible)\ndef isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n  case (optAoptB, optBoptA) => ({ a =>\n    optAoptB(Option(a)).getOrElse(optAoptB(None).get)\n  }, { b =>\n    optBoptA(Option(b)).getOrElse(optBoptA(None).get)\n  })\n}\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\/\/ Note that we have\ndef isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = ({\n  case Left(l) => Left(() :: l)\n  case Right(unit) => Left(Nil) \n}, {\n  case Left(x :: xs) => Left(xs)\n  case _ => Right(())\n})\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\ndef isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (symm, symm)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335788,"user_id":null,"body":"object Isomorphism {\n\n  \/** The type [[Nothing]] has no value.\n    * So it is impossible to construct an instance of it.\n    * In this solution, wherever a situation arises where\n    * for types to check, you need a function that takes a [[Nothing]],\n    * you can use [[absurd]].\n    *\/\n  def absurd[R](n: Nothing): R = n\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\n  type ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\n  def substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\n  def substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\n  def isoBool: ISO[Boolean, Boolean]    = (identity, identity)\n  def isoBoolNot: ISO[Boolean, Boolean] = (!_, !_)\n\n\/\/ isomorphism is reflexive\n  def refl[A]: ISO[A, A] = (identity, identity)\n\n\/\/ isomorphism is symmetric\n  def symm[A, B]: ISO[A, B] => ISO[B, A] = iso => (iso._2, iso._1)\n\n\/\/ isomorphism is transitive\n  def trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = { case (isoAb, isoBc) =>\n    (a => isoBc._1(isoAb._1(a)), c => isoAb._2(isoBc._2(c)))\n  }\n\n\/\/ We can combine isomorphism:\n  def isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n    case ((ab, ba), (cd, dc)) =>\n      ({ case (a, c) => (ab(a), cd(c)) }, { case (b, d) => (ba(b), dc(d)) })\n  }\n\n  def isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = { case (a, b) =>\n    (la => la.map(a), lb => lb.map(b))\n  }\n\n  def isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = { case (a, b) =>\n    (oa => oa.map(a), ob => ob.map(b))\n  }\n\n  def isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = {\n    case ((ab, ba), (cd, dc)) =>\n      (\n        eac => eac.fold(a => Left(ab(a)), c => Right(cd(c))),\n        ebd => ebd.fold(b => Left(ba(b)), d => Right(dc(d)))\n      )\n  }\n\n  def isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = {\n    case ((ab, ba), (cd, dc)) =>\n      (\n        { case ac => b => cd(ac(ba(b))) },\n        { case bd => a => dc(bd(ab(a))) }\n      )\n  }\n\n  def impossible: Nothing = sys.error(\"impossible\")\n\n\/\/ Going another way is hard (and is generally impossible)\n  def isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = {\n    case (oab, oba) => {\n      (\n        a =>\n          oab(Some(a))\n            .orElse(oab(None))\n            .fold(absurd(impossible)) { identity },\n        b =>\n          oba(Some(b))\n            .orElse(oba(None))\n            .fold(absurd(impossible)) { identity }\n      )\n    }\n  }\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\n\/\/ Note that we have\n  def isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = {\n    (\n      { case eluu =>\n        eluu\n          .fold(\n            a => Left(() :: a),\n            b => Left(Nil)\n          )\n          .map(_ => impossible)\n      },\n      { case elun =>\n        elun.fold(\n          a =>\n            a match {\n              case Nil       => Right(())\n              case _ :: tail => Left(tail)\n            },\n          b => Right(())\n        )\n      }\n    )\n  }\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\n  def isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = {\n    ({ case ab => symm(ab) }, { case ba => symm(ba) })\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335789,"user_id":null,"body":"object Isomorphism {\n\/**\n * The type [[Nothing]] has no value.\n * So it is impossible to construct an instance of it.\n * In this solution, wherever a situation arises where\n * for types to check, you need a function that takes a [[Nothing]],\n * you can use [[absurd]].\n *\/\ndef absurd[R](n: Nothing): R = ???\n\n\/\/ so, when are two type, `A` and `B`, considered equal?\n\/\/ a definition might be, it is possible to go from `A` to `B`,\n\/\/ and from `B` to `A`.\n\/\/ Going a roundway trip should leave you the same value.\n\/\/ Unfortunately it is virtually impossible to test this in Scala.\n\/\/ This is called Isomorphism.\n\ntype ISO[A, B] = (A => B, B => A)\n\n\/\/ given ISO a b, we can go from a to b\ndef substL[A, B]: ISO[A, B] => (A => B) = _._1\n\n\/\/ and vice versa\ndef substR[A, B]: ISO[A, B] => (B => A) = _._2\n\n\/\/ There can be more than one ISO a b\ndef isoBool: ISO[Boolean, Boolean] = (identity, identity)\ndef isoBoolNot: ISO[Boolean, Boolean] = (! _, ! _)\n\n\/\/ isomorphism is reflexive\ndef refl[A]: ISO[A, A] = (identity, identity)\n\n\/\/ isomorphism is symmetric\ndef symm[A, B]: ISO[A, B] => ISO[B, A] = _.swap\n\n\/\/ isomorphism is transitive\ndef trans[A, B, C]: (ISO[A, B], ISO[B, C]) => ISO[A, C] = (ab, bc) => ((ab._1 andThen bc._1), (bc._2 andThen ab._2))\n\n\/\/ We can combine isomorphism:\ndef isoTuple[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A, C), (B, D)] = {\n  case ((ab, ba), (cd, dc)) => {\n    (ac => (ab(ac._1), cd(ac._2)), bd => (ba(bd._1), dc(bd._2)))\n  }\n}\n\ndef isoList[A, B]: ISO[A, B] => ISO[List[A], List[B]] = iso => (_.map(iso._1), _.map(iso._2))\ndef isoOption[A, B]: ISO[A, B] => ISO[Option[A], Option[B]] = iso => (_.map(iso._1), _.map(iso._2))\ndef isoEither[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[Either[A, C], Either[B, D]] = (ab, cd) => ( \n      _.fold(a => Left(ab._1(a)), c => Right(cd._1(c))), \n      _.fold(b => Left(ab._2(b)), d => Right(cd._2(d)))\n    )\ndef isoFunc[A, B, C, D]: (ISO[A, B], ISO[C, D]) => ISO[(A => C), (B => D)] = (ab, cd) => \n    (\n      ac => ab._2 andThen ac andThen cd._1,\n      bd => ab._1 andThen bd andThen cd._2, \n    )\n\n\/\/ Going another way is hard (and is generally impossible)\ndef isoUnOption[A, B]: ISO[Option[A], Option[B]] => ISO[A, B] = iso => \n    (\n      a => iso._1(Some(a)) match {\n        case None => iso._1(None) match {\n          case None => iso._1(Some(a)).get\n          case Some(b) => b\n        }\n        case Some(b) => b\n      },\n      b => iso._2(Some(b)) match {\n        case None => iso._2(None) match {\n          case None => iso._2(Some(b)).get\n          case Some(a) => a\n        }\n        case Some(a) => a\n      },\n    )\n\n\/\/ Remember, for all valid ISO, converting and converting back\n\/\/ Is the same as the original value.\n\/\/ You need this to prove some case are impossible.\n\n\/\/ We cannot have\n\/\/ isoUnEither[A, B, C, D]: (ISO[Either[A, B], Either[C, D]], ISO[A, C]) => ISO[B, D]\n\/\/ Note that we have\ndef isoEU: ISO[Either[List[Unit], Unit], Either[List[Unit], Nothing]] = \n  (\n      {\n        case Left(lu) => Left(() :: lu)\n        case Right(u) => Left(Nil)\n      }, \n      {\n        case Left(Nil) => Right(())\n        case Left(l) => Left(l.tail)  \n      }\n    )\n\/\/ where Unit, has 1 value, (the value is also called Unit), and Void has 0 values.\n\/\/ If we have isoUnEither,\n\/\/ We have ISO[Unit, Nothing] by calling isoUnEither isoEU\n\/\/ That is impossible, since we can get a Nothing by substL on ISO[Unit, Nothing]\n\/\/ So it is impossible to have isoUnEither\n\n\/\/ And we have isomorphism on isomorphism!\ndef isoSymm[A, B]: ISO[ISO[A, B], ISO[B, A]] = (\n      _.swap,\n      _.swap\n    )\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59342039eb450e39970000a6":[{"id":335790,"user_id":573,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = n \/ 2\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335791,"user_id":null,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = n\/2 max 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335792,"user_id":null,"body":"object OddCount {\n\n    def odd_count(n: Long): Long = if (n > 0) n \/ 2 else 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335793,"user_id":null,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = {\n    var res = n\/2\n    res\n  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335794,"user_id":null,"body":"import java.util.stream.LongStream\n\nobject OddCount {\n\n  def odd_count(n: Long): Long = {\n    if (n % 2 == 0) n \/ 2\n    else Math.floorDiv(n,2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335795,"user_id":null,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = n match {\n    case _ if n <= 1 => 0\n    case _ => n \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335796,"user_id":1228,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = {\n    n >> 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335797,"user_id":null,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = n match {\n    case 0 => 0\n    case n if (n % 2 == 0) => n \/ 2\n    case _ => (n-1) \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335798,"user_id":null,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = {\n    if(n%2 != 0)\n      (n+1)\/2-1\n    else\n      n\/2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335799,"user_id":null,"body":"object OddCount {\n\n  def odd_count(n: Long): Long = n >> 1 max 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"593e978a3bb47a8308000b8f":[{"id":335800,"user_id":573,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] =\n    matrix.map(_.toArray).transpose.map(_.reverse.mkString)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335801,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] = matrix\n    .map(_.toCharArray)\n    .transpose\n    .map(_.reverse)\n    .map(_.mkString)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335802,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] = {\n    if( matrix.length == 0 )return Array()\n    var temp:Array[String] = Array()\n    for(i <- 0 to matrix(0).length-1){\n     temp = temp :+ matrix.map(x => x.substring(i,i+1)).mkString.reverse\n    }\n    return temp\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335803,"user_id":null,"body":"object Kata {\n  def rotateClockwise(matrix: Array[String]): Array[String] = \n  if (matrix.isEmpty)\n    matrix\n  else\n    (for (i<-0 until matrix(0).size) yield (for (j<-matrix.size-1 to 0 by -1) yield matrix(j).apply(i)).mkString).toArray\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335804,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] = {\n    val width = if (matrix.length == 0) 0 else matrix(0).length\n    val height = matrix.length\n    (0 to width-1).map(x => (0 to height-1).map(y => matrix(y)(x)).mkString(\"\").reverse).toArray\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335805,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] =\n    matrix.view.reverse.map(_.toArray).transpose.map(_.mkString).toArray\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335806,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] =\n      if (matrix.isEmpty) Array.empty[String]\n      else {\n        val height = matrix.size\n        val width = matrix(0).size\n        Array.tabulate(width) { row =>\n          List.tabulate(height) { col =>\n            matrix(height - 1 - col)(row)\n          }.mkString\n        }\n      }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335807,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] =\n    if (matrix.isEmpty) {\n      matrix\n    } else {\n      val r = matrix.length\n      (0 until matrix.head.length).map(j => (0 until r).map(i => matrix(r - 1 - i)(j)).mkString).toArray\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335808,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] = {\n    if (matrix.length == 0)\n      Array()\n    else {\n      \/\/(x,y,value)\n      val asCoordsMatrix = matrix\n        .map(row => row.toCharArray)\n        .zipWithIndex\n        .map(p => p._1.zipWithIndex.map(v => (p._2, v._2, v._1)))\n        .flatten\n\n      val noOfrows = matrix.length\n      val rotated =\n        asCoordsMatrix.map(elem => (elem._2, noOfrows - elem._1 - 1, elem._3))\n\n      val asStringsMatrix = rotated\n        .groupBy(_._1)\n        .toList\n        .sortWith(_._1 < _._1)\n        .map(_._2)\n        .map(_.sortWith(_._2 < _._2))\n        .map(_.map(_._3))\n        .map(_.mkString)\n        .toArray\n\n      return asStringsMatrix\n    }\n\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335809,"user_id":null,"body":"object Kata {\n\n  def rotateClockwise(matrix: Array[String]): Array[String] =    \n     List.range(0,\n       matrix.headOption.\n       map(_.length).\n       getOrElse(0)\n    ).map(i=> List.range(0,matrix.size).\n              reverse.\n              map(j=>matrix(j).charAt(i) ).\n              mkString(\"\")\n         ).toArray \n  \n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"593ff8b39e1cc4bae9000070":[{"id":335810,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String): String = {\n    (0 to a.length).foldLeft(Map[(Int, Int), String]())((memory, i) =>\n      (0 to b.length).foldLeft(memory)((memory, j) => \n        if (i == 0 || j == 0) memory + ((i, j) -> \"\")\n        else if (a.charAt(i - 1) == b.charAt(j - 1)) memory + ((i, j) -> (memory((i - 1) -> (j - 1)) + a.charAt(i - 1)))\n        else memory + ((i, j) -> Seq(memory((i - 1) -> j), memory(i -> (j - 1))).maxBy(_.length))\n      )\n    )(a.length -> b.length)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335811,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String): String = {\n    val matrix = Array.ofDim[Int](a.length + 1, b.length + 1)\n    for (i <- 0 until a.length; j <- 0 until b.length)  {\n      matrix(i + 1)(j + 1) = if (a(i) == b(j))\n        matrix(i)(j) + 1\n        else Math.max(matrix(i + 1)(j), matrix(i)(j + 1))\n    }\n    def backtrack(i: Int, j: Int): String = {\n      if (i == -1 || j == -1) \"\"\n      else if (a(i) == b(j))\n        backtrack(i - 1, j - 1) + a(i)\n      else if (matrix(i + 1)(j) > matrix(i)(j + 1))\n        backtrack(i, j - 1)\n      else\n        backtrack(i - 1, j)\n    }\n    backtrack(a.length - 1, b.length - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335812,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String): String = {\n    var resp, aux = \"\"\n    var i = 0\n\n    if (a.length > 0 && b.length > 0) {\n      for (c <- a){\n        i+=1\n        if(b.contains(c)){\n          aux = c + lcs(a.drop(i),b.drop(b.indexOf(c)+1))\n          if(aux.length > resp.length)\n           resp = aux\n        }\n      }\n    }\n    resp\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335813,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String): String = {\n    val indices = (-1 until a.size).flatMap { ai => (-1 until b.size).map { bi => (ai, bi) } }\n    val solutions = indices.foldLeft(Map[(Int, Int), String]()) { (acc, next) =>\n      val (ai, bi) = next\n      val nextString = (ai, bi) match {\n        case (-1, _) => \"\"\n        case (_, -1) => \"\"\n        case (ai, bi) if(a(ai) == b(bi)) => acc((ai - 1, bi - 1)) :+ a(ai)\n        case (ai, bi) if(acc((ai - 1, bi)).size > acc((ai, bi - 1)).size) => acc((ai - 1, bi))\n        case (ai, bi) => acc((ai , bi - 1))\n      }\n      acc + ((ai, bi) -> nextString)\n    }\n    solutions((a.size - 1, b.size - 1))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335814,"user_id":null,"body":"object Lcs {\n    def lcs(a: String, b: String): String = {\n    val matrix = Array.ofDim[String](a.length, b.length)\n    var max_value = \"\"\n    for (i <- 0 until a.length) {\n      for (j <- 0 until b.length) {\n        val k = lcs_piece(a.slice(0, i + 1), b.slice(0, j + 1), matrix)\n        matrix(i)(j) = k\n      }\n    }\n\n    for (i <- 0 until a.length) {\n      for (j <- 0 until b.length) {\n        if (matrix(i)(j).length > max_value.length) {\n          max_value = matrix(i)(j)\n        }\n      }\n    }\n\n    max_value\n  }\n\n  def lcs_piece(a: String, b: String, matrix: Array[Array[String]]): String = {\n    if (matrix(a.length - 1)(b.length - 1) != null) {\n      matrix(a.length - 1)(b.length - 1)\n    } else if (a == \"\" || b == \"\") {\n      \"\"\n    } else if (a.length == 1 || b.length == 1) {\n      if (a.length == 1 && b.contains(a)) a\n      else if (b.length == 1 && a.contains(b)) b\n      else \"\"\n    } else {\n      \/\/ Deal with left Top\n      var leftTop =\n        lcs_piece(a.slice(0, a.length - 1), b.slice(0, b.length - 1), matrix)\n      val remaining_a = a.slice(a.length - 1, a.length)\n      val remaining_b = b.slice(b.length - 1, b.length)\n      if (remaining_a == remaining_b)\n        leftTop = leftTop + remaining_a\n\n      \/\/ Deal with left\n      val left =\n        lcs_piece(a.slice(0, a.length), b.slice(0, b.length - 1), matrix)\n\n      \/\/ Deal with Top\n      val top =\n        lcs_piece(a.slice(0, a.length - 1), b.slice(0, b.length), matrix)\n\n      val maxx = List(left, top, leftTop).reduce((a, b) =>\n        if (a.length > b.length) a else b\n      )\n\n      maxx\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335815,"user_id":null,"body":"object Lcs {\n  \/**\n    * \u7ecf\u5178DP\n    * dp(i)(j) \u4e3a a(0->i) \u4e0e b(0->j) \u5b50\u4e32\u7684\u6700\u957f\u516c\u5171\u5b50\u4e32\u957f\u5ea6\n    * \u663e\u7136\u5bf9 i=0, j=0->b.length-1 \uff0ca\u7684\u5b50\u4e32\u4e3aa(0)\uff0c\u663e\u7136 dp(0)(j) = a(0) == b(j) ? dp(0)(j-1)+1 : dp(0)(j-1)\n    * \u540c\u7406\u5bf9\uff0ci=0->a.length-1,j=0, dp(i)(0) = a(i) == b(0) ? dp(i-1)(0)+1 : dp(i-1)(0)\n    * \u5269\u4e0b\u7684\u663e\u7136\uff1a \u82e5 a(i) == b(j) \uff0c\u5f53\u524d\u5b57\u7b26\u76f8\u540c\u53ef\u4ee5\u6bd4\u5bf9\u89d2\u7ebf\u591a\u4e00\u4e2a\u5b57\u7b26\uff0c\u5373 dp(i)(j) = dp(i-1)(j-1) + 1 ;\n    * \u5426\u5219\u5f53\u524d\u5b57\u7b26\u4e0d\u540c\uff0c\u53d6\u51b3\u4e8e\u4e24\u8fb9\u539f\u6765\u6700\u957f\u7684\u5b50\u4e32\uff0c\u5373 dp(i)(j) = max(dp(i-1)(j), dp(i)(j-1))\n    * \u8fd9\u6837\u9700\u8981\u4e00\u4e2a a.length * b.length \u7684\u4e8c\u7ef4\u6570\u7ec4\n    *\n    * \u7136\u540e\u4ece\u5c3e\u53cd\u63a8\u5b50\u4e32\n    *\/\n  def lcs(a: String, b: String): String = {\n    if (a.isEmpty || b.isEmpty) return \"\"\n    val dp = Array.ofDim[Int](a.length + 1, b.length + 1)\n    for {\n      i <- 1 to a.length\n      j <- 1 to b.length\n    } yield if (a(i - 1) == b(j - 1))\n      dp(i)(j) = dp(i - 1)(j - 1) + 1\n    else\n      dp(i)(j) = math.max(dp(i - 1)(j), dp(i)(j - 1))\n    println(dp.last.last)\n    var (i, j, curLen) = (a.length, b.length, dp.last.last)\n    var result = List[Char]()\n    while (curLen > 0) {\n      if (a(i - 1) == b(j - 1)) { \/\/\u76f8\u7b49\u65f6\u8d70\u5bf9\u89d2\u7ebf\n        result ::= a(i - 1)\n        \/\/i = math.max(i - 1, 1)\n        \/\/j = math.max(j - 1, 1)\n        i-=1\n        j-=1\n        curLen -= 1\n      } else { \/\/\u4e0d\u76f8\u7b49\u8d70\u8f83\u5927\u8005\n        if (dp(i - 1)(j) > dp(i)(j - 1)) {\n          i -= 1\n        } else {\n          j -= 1\n        }\n      }\n    }\n    result.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335816,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String): String = {\n    val (m, n) = (a.length, b.length)\n    val table: Array[Array[Int]] = Array.fill(m + 1)(Array.fill(n + 1)(0))\n\n    def buildTable() =\n      for (i <- 1 to m; j <- 1 to n)\n        if (a(i -1) == b(j - 1))\n          table(i)(j) = table(i - 1)(j - 1) + 1\n        else\n          table(i)(j) = Math.max(table(i)(j - 1), table(i - 1)(j))\n\n    def extractSequence(x: Int, y: Int): String =\n      if (x == 0 || y == 0) \"\"\n      else if (a(x - 1) == b(y - 1))\n        extractSequence(x - 1, y - 1) + a(x - 1)\n      else if (table(x)(y - 1) > table(x - 1)(y))\n        extractSequence(x, y - 1)\n      else\n        extractSequence(x - 1, y)\n\n    buildTable()\n    extractSequence(m, n)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335817,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String):String= {\n    if (a == null || a.length() == 0 || b == null || b.length() == 0) \"\"\n    else if (a == b) a\n    else {\n\n      val aLength = a.length()\n      val bLength = b.length()\n\n      val lcsLengths = Array.fill[Int](aLength + 1, bLength + 1)(0)\n\n      for (i <- 0 until aLength) {\n        for (j <- 0 until bLength) {\n          if (a.charAt(i) == b.charAt(j)) {\n            lcsLengths(i + 1)(j + 1) = lcsLengths(i)(j) + 1\n          } else {\n            if (lcsLengths(i)(j + 1) >= lcsLengths(i + 1)(j)) {\n              lcsLengths(i + 1)(j + 1) = lcsLengths(i)(j + 1)\n            } else {\n              lcsLengths(i + 1)(j + 1) = lcsLengths(i + 1)(j)\n            }\n          }\n        }\n      }\n\n      val subSeq = new StringBuilder()\n      var aPos = aLength\n      var bPos = bLength\n\n      do {\n        if (lcsLengths(aPos)(bPos) == lcsLengths(aPos -1)(bPos)) {\n          aPos -= 1\n        } else if (lcsLengths(aPos)(bPos) == lcsLengths(aPos)(bPos - 1)) {\n          bPos -= 1\n        } else {\n          assert(a.charAt(aPos - 1) == b.charAt(bPos - 1))\n          subSeq += a.charAt(aPos - 1)\n          aPos -= 1\n          bPos -= 1\n        }\n\n      } while (aPos > 0 && bPos > 0)\n\n      subSeq.toString.reverse\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335818,"user_id":null,"body":"object Lcs {\n  def lcs(a: String, b: String): String = {\n    def lcsAuxA(i: Int, dynamic: Array[Array[String]]): String = {\n      \n      def lcsAuxB(j: Int): Unit = {\n        if (j == b.length + 1) {\n          \n        }\n        else {\n          if (a(i - 1) == b(j - 1)) dynamic(i)(j) = dynamic(i - 1)(j - 1) + a(i - 1)\n          else if (dynamic(i - 1)(j).length >= dynamic(i)(j - 1).length) dynamic(i)(j) = dynamic(i - 1)(j)\n          else dynamic(i)(j) = dynamic(i)(j - 1)\n          lcsAuxB(j + 1)\n        }\n      }\n      \n      if (i == a.length + 1) {\n        dynamic(a.length)(b.length)\n      }\n      else {\n        lcsAuxB(1)\n        lcsAuxA(i + 1, dynamic)\n      }\n    }\n    \n    val dynamic = Array.fill[Array[String]](a.length + 1)(Array.fill[String](b.length + 1)(\"\"))\n    \n    lcsAuxA(1, dynamic)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335819,"user_id":null,"body":"object Lcs {\n  \n\/\/   @scala.annotation.tailrec\n\/\/   def rec(a: String, b: String, acc: String = \"\"): String = (a, b) match {\n\/\/     case (a, \"\") => acc\n\/\/     case (\"\", b) => acc\n\/\/     case (a, b) if a.head == b.head => rec(a.tail, b.tail, acc + a.head.toString)\n\/\/     case (a, b) =>\n\/\/       val fst = rec(a.tail, b)\n\/\/       val snd = rec(a, b.tail)\n\/\/       if (fst.length > snd.length) fst\n\/\/       else snd\n\/\/   }\n  \n  def dynPr(a: String, b: String): String = {\n    val array = Array.fill(a.length + 1, b.length + 1)(0)\n    for {\n      charA <- a.zipWithIndex\n      charB <- b.zipWithIndex\n    } {\n      array(charA._2 + 1)(charB._2 + 1) = \n        if (charB._1 == charA._1)\n          array(charA._2)(charB._2) + 1\n        else\n          scala.math.max(array(charA._2 + 1)(charB._2), array(charA._2)(charB._2 + 1))\n    }\n    var i = a.length\n    var j = b.length\n    val sb = new StringBuilder()\n    \n    while (i > 0 && j > 0) {\n      if (a(i - 1) == b(j - 1)) {\n        sb += a(i - 1)\n        i -= 1\n        j -= 1\n      }\n      else if (array(i)(j - 1) > array(i - 1)(j))\n        j -= 1\n      else\n        i -= 1\n    }\n    \n    sb.toString.reverse\n  }\n  \n  def lcs(a: String, b: String): String = {\n    dynPr(a, b)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59590976838112bfea0000fa":[{"id":335820,"user_id":573,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] =\n    if (n != 0) values.grouped(n).toList.map(_.padTo(n, 0)).transpose.map(_.sum) else Nil\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335821,"user_id":573,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] =\n    List.range(0, n).map(i => values.drop(i).grouped(n).map(_.head).sum)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335822,"user_id":null,"body":"import scala.collection.immutable.Stream.Empty\n\nobject Kata {\n  val EmptyBeggars: PartialFunction[Int, Any => List[Int]] = {case 0 => _ => Nil}\n  val Beggars: Int => List[Int] => List[Int] = (n: Int) => (values: List[Int]) =>\n      values.padTo(n * ((values.size \/ n) + 1), 0)\n        .grouped(n)\n        .toList\n        .transpose\n        .map(_.sum)\n  \n  def beggars(values: List[Int], n: Int): List[Int] = EmptyBeggars.applyOrElse(n, Beggars)(values)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335823,"user_id":null,"body":"object Kata {\n  def beggars(values: List[Int], n: Int): List[Int] = \n  ((0 until n).toList zipWithIndex).map { case (e, i) => \n      ((i until values.length by n).toList map values).fold(0)(_ + _)\n  }\n} ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335824,"user_id":573,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] =\n    (0 until n).map(k => values.zipWithIndex.collect { case (x, i) if i % n == k => x }.sum).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335825,"user_id":null,"body":"object Kata\n{\n    def beggars(values: List[Int], n: Int): List[Int] =\n    {\n        var arr: List[Int] = List()\n        for (i <- 0 until n)\n        {\n          var res = 0\n          for (j <- i until values.size by n)\n          {\n            res += values(j)\n          }\n          arr :+= res\n        }\n\n        arr\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335826,"user_id":null,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] = {\n    def mBeggars(values: List[Int], n: Int): List[Int] = {\n      val vLength = values.length\n      val beggSeq = if(n > vLength) (0 until n).toList else List.tabulate(vLength)(_ % n)\n      beggSeq\n      .zipAll(values, 0, 0)\n      .groupMapReduce(_._1)(_._2)(_ + _)\n      .toList\n      .sortBy(_._1)\n      .map(_._2)\n    }\n    \n    if(n == 0) List()\n    else mBeggars(values, n)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335827,"user_id":1285,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] =\n    if (n == 0) List.empty\n    else values.zipWithIndex\n      .foldLeft(Array.range(0, n).map(_ => 0))((acc, cur) => {\n        acc(cur._2 % (acc.length max 1)) += cur._1\n        acc\n      })\n      .toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335828,"user_id":null,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] = {\n    val len = values.size\n  \n    (0 until n).toList\n      .map(e => LazyList.iterate(e)(_ + n).takeWhile(_ < len))\n      .map(_.map(values(_)).sum)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335829,"user_id":null,"body":"object Kata {\n\n  def beggars(values: List[Int], n: Int): List[Int] = {\n    if (n == 0) List()\n    else {\n      val pennyWithIndex = values.zipWithIndex.map(x => (x._1, x._2 % n))\n      val intermediate = (0 to n-1).map(y => pennyWithIndex.filter(_._2 == y).map(x => x._1))\n      intermediate.map(x => x.sum).toList\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5966eeb31b229e44eb00007a":[{"id":335830,"user_id":527,"body":"object Vaporcode {\n  def encode(s: String): String =\n    s.replace(\" \", \"\").toUpperCase.mkString(\"  \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335831,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String =\n    s.filterNot(_.isWhitespace).toUpperCase.flatMap(x => s\"$x  \").dropRight(2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335832,"user_id":573,"body":"object Vaporcode {\n\n  def encode(s: String): String =\n    s.replace(\" \", \"\").mkString(\"  \").toUpperCase\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335833,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String = s.split(\"\").filter(e => e != \" \").map(e => e.toUpperCase).mkString(\"  \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335834,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String =\n    {\n      s.replace(\" \",\"\").replace(\"\",\"  \").toUpperCase().trim\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335835,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String =\n    {\n      s.split(\" \").flatMap(word => word.map(letr => letr.toString.toUpperCase)).mkString(\"  \")\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335836,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String =\n    s.replace(\" \", \"\").split(\"\").map(char => s\"${char.toUpperCase}\")\n    .mkString(\"  \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335837,"user_id":468,"body":"object Vaporcode {\n\n  def encode(s: String): String = s.filterNot(_.isSpaceChar).map(_.toUpper).mkString(\"  \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335838,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String = s\n    .replaceAll(\" \", \"\")\n    .toUpperCase()\n    .split(\"\")\n    .mkString(\"  \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335839,"user_id":null,"body":"object Vaporcode {\n\n  def encode(s: String): String = s.replace(\" \", \"\").map(e=>e.toString.toUpperCase()).mkString(\"  \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59706036f6e5d1e22d000016":[{"id":335840,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = s.toCharArray.map(c => c.toInt - 96).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335841,"user_id":751,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String) = s.map(_ - 'a' + 1).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335842,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = s.foldLeft(0)(_ + _ - 'a' + 1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335843,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = {\n    s.map( _.toLower.toInt - 96 match {\n      case x if 1 to 26 contains x => x\n      case _ => 0\n    }\n    ).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335844,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = {\n    s.map(c => c - 'a' + 1).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335845,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int =\n    s.toCharArray.map(ch => ch.hashCode()-96).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335846,"user_id":null,"body":"object LoveVsFriendship {\n   def loveVsFriendship(s: String): Int =  s.toLowerCase.map(_.toInt - 'a' + 1 ).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335847,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = {\n    val offset = 'a'.toInt - 1\n    s.toList.map(x => x.toInt - offset).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335848,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = {\n    val dict = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n    s.map(c => dict.indexOf(c)+1).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335849,"user_id":null,"body":"object LoveVsFriendship {\n  def loveVsFriendship(s: String): Int = s.toList.map(_.toInt - 96).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59c68ea2aeb2843e18000109":[{"id":335850,"user_id":492,"body":"object Finance {\n\n  private def payment(rate: Double, bal: Int, term: Int): Double = {\n    val r: Double = rate \/ 1200.0\n    val n: Double = r * bal\n    val d: Double = 1 - Math.pow(1 + r, -term)\n    val pmt: Double = n \/ d\n    pmt\n  }\n\n  def amort(rate: Double, bal: Int, term: Int, num_payments: Int): String = {\n    val p: Double = payment(rate, bal, term)\n    val r: Double = rate \/ 1200.0\n    var i: Int = 1\n    var balance: Double = bal\n    var intrst: Double = 0\n    var princ: Double = 0\n    while (i <= num_payments) {\n      intrst = balance * r\n      princ = p - intrst\n      balance -= princ\n      i = i + 1\n    }\n    val output: String = \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\".format(i-1, p, princ, intrst, balance)\n    output\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335851,"user_id":null,"body":"object Finance {\n\n  def amort(rate: Double, bal: Int, term: Int, numPayments: Int): String = {\n    var r = (rate \/100) \/12\n    var n = bal * r\n    var d = 1 - scala.math.pow( 1+ r ,- term)\n    var num_payment = numPayments \n    var c = n\/d\n    var balance = scala.math.pow(1 + r, numPayments) * bal - (c* (scala.math.pow(1 + r, numPayments) - 1 )\/r)\n    var int =  (scala.math.pow(1 + r, numPayments - 1) * bal - (c* (scala.math.pow(1 + r, numPayments - 1) - 1 )\/r) ) * r\n    var princ = c - int\n    \n   \n    var result = f\"num_payment $num_payment%d c $c%.0f princ $princ%.0f int $int%.0f balance $balance%.0f\" \n    result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335852,"user_id":null,"body":"object Finance {\n\n  def amort(rate: Double, bal: Int, term: Int, numPayments: Int): String = {\n    val r = rate\/100\/12\n    val n = r * bal\n    val d = 1 - math.pow((1 + r), -term)\n    val c = n\/d\n    val sInt = n\n    val sPrinc = c - sInt\n    val prevBalance = (n - c)*(((math.pow(1 + r, numPayments-1))-1)\/r) + bal\n    val balance = (n - c)*(((math.pow(1 + r, numPayments))-1)\/r) + bal\n    val int = r * prevBalance\n    val princ = c - int\n    s\"num_payment $numPayments c ${math.round(c).toInt} princ ${math.round(princ).toInt} int ${math.round(int).toInt} balance ${math.round(balance).toInt}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335853,"user_id":null,"body":"object Finance {\n\n  def amort(rate: Double, bal: Int, term: Int, numPayments: Int): String = {\n    val monthRate = rate \/ 100 \/ 12\n    val c = monthRate * bal \/ (1 - scala.math.pow(1 + monthRate, -term))\n    \n    def calculatePayment(c: Double, int: Double, princ: Double, balance: Double, num: Int): String = {\n      if(num <= 0) \n        f\"num_payment $numPayments c $c%.0f princ $princ%.0f int $int%.0f balance $balance%.0f\"\n      else {\n        var newInt = monthRate * balance\n        var newPrinc = c - newInt\n        calculatePayment(c, newInt, newPrinc, balance - newPrinc, num - 1)\n      }\n    }\n  \n    calculatePayment(c, 0, 0, bal, numPayments)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335854,"user_id":null,"body":"object Finance {\n\n  def amort(rate: Double, bal: Int, term: Int, numPayments: Int): String = {\n    val r = rate \/ 1200\n    val c = (r * bal) \/ (1 - Math.pow(1 + r,-term))\n    var b = bal.toDouble\n    var princ = 0.0\n    var intr = 0.0\n    for (i <- 1 to numPayments) {\n      intr = r * b\n      princ = c - intr\n      b -= princ\n    }\n    return f\"num_payment $numPayments c $c%.0f princ $princ%.0f int $intr%.0f balance $b%.0f\"\n    \/\/return \"num_payment 20 c 459 princ 445 int 14 balance 1809\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335855,"user_id":null,"body":"object Finance {\n\n  def amort(rate: Double, bal: Int, term: Int, numPayments: Int): String = {\n    val an      = annuity(rate, bal, term)\n    val r       = rate \/ 1200\n    val int     = endOfMonth(rate, bal, term, numPayments - 1) * r\n    val princ   = an - int\n    val balance = endOfMonth(rate, bal, term, numPayments)\n    f\"num_payment $numPayments%d c $an%.0f princ $princ%.0f int $int%.0f balance $balance%.0f\"\n  }\n\n  def endOfMonth(rate: Double, bal: Int, term: Int, n: Int): Double = {\n    val an = annuity(rate, bal, term)\n    val r  = rate \/ 1200\n    val k  = math.pow(1 + r, n)\n    k * bal - (k - 1) * an \/ r\n  }\n\n  def annuity(rate: Double, bal: Int, term: Int): Double = {\n    val r = rate \/ 1200\n    val n = r * bal\n    val d = 1 - math.pow(1 + r, -term)\n    n \/ d\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335856,"user_id":null,"body":"object Finance {\n\n  def amort(rate: Double, bal: Int, term: Int, numPayments: Int): String = {\n    val r = rate \/ 100 \/ 12\n    val n = r * bal\n    val d = 1 - math.pow((1 + r), -term)\n    val c = n \/ d\n    \n    def calculateDebt(balance: BigDecimal, paymentsLeft: Int): BigDecimal = {\n      if (paymentsLeft == 0) balance\n      else calculateDebt((1 + r) * balance - c, paymentsLeft - 1)\n    }\n    \n    val debt = calculateDebt(bal, numPayments - 1)\n    val newBalance = calculateDebt(debt, 1)\n    val int = r * debt.toDouble\n    val princ = c - int\n    s\"num_payment $numPayments c ${math.round(c)} princ ${math.round(princ)} int ${math.round(int)} balance ${newBalance.toDouble.round}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335857,"user_id":1228,"body":"object Finance {\n  def amort(rate: Double, bal: Int, term: Int, num_payments: Int): String = {\n    val r = rate \/ 1200\n    val c = r * bal \/ (1 - scala.math.pow(r + 1, -term))\n    \n    var i = 0.0\n    var p = 0.0\n    var b = bal.toDouble\n    (1 to num_payments) foreach (n => {\n      i = (r * b)\n      p = (c - i)\n      b = b - p\n    })\n    return s\"num_payment $num_payments c ${scala.math.round(c)} princ ${scala.math.round(p)} int ${scala.math.round(i)} balance ${scala.math.round(b)}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335858,"user_id":573,"body":"object Finance {\n\n  def amort(rate: Double, balance: Int, term: Int, numPayments: Int): String = {\n\n    val monthlyRate = rate \/ (12*100d)\n    val n = (monthlyRate) * balance\n    val d = 1 - math.pow((1d + monthlyRate), -term)\n    val monthlyPayment = n \/ d\n\n    val (int, princ, remainingBalance) =\n      (0 until numPayments)\n        .foldLeft(0d, 0d, balance.toDouble) {\n          case ((_, _, balance), _) =>\n            val interest = monthlyRate * balance\n            val princ = monthlyPayment - interest\n            val newBalance = balance - princ\n            (interest, princ, newBalance)\n        }\n\n    stringify(numPayments, monthlyPayment.round.toInt, princ.round.toInt, int.round.toInt, remainingBalance.round.toInt)\n  }\n\n  def stringify(num_payments: Int, monthlyPayment: Int, princ: Int, int: Int, balance: Int): String =\n    s\"num_payment $num_payments c $monthlyPayment princ $princ int $int balance $balance\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335859,"user_id":null,"body":"object Finance {\n  import scala.math._\n  def amort(rate: Double, bal: Int, term: Int, num_payments: Int): String = {\n    val r = rate \/ 1200\n    val c = r * bal \/ (1 - pow(r + 1, -term))\n    \n    var i = 0.0\n    var p = 0.0\n    var b = bal.toDouble\n    (1 to num_payments) foreach (n => {\n      i = (r * b)\n      p = (c - i)\n      b = b - p\n    })\n    return s\"num_payment $num_payments c ${round(c)} princ ${round(p)} int ${round(i)} balance ${round(b)}\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59c919326bddd238e9000103":[{"id":335860,"user_id":53,"body":"object LonelyFrogII {\n  def jumpTo(n: Int): Int = {\n    if (n == 1) {\n      0\n    } else {\n      (2 * math.sqrt(n - 1.5)).floor.toInt\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335861,"user_id":null,"body":"object LonelyFrogII {\n  def jumpTo(n: Int): Int = {\n    if (n == 1) return 0\n\n    val steps = if (n % 2 != 0) quadEqn((n - 1) \/ 2) else quadEqn(n \/ 2)\n    var beyond = steps * (steps + 1) - n + 1\n\n    var (steps1, steps2) = (steps, steps)\n    if (beyond >= steps1) { beyond -= steps1; steps1 -= 1 }\n    if (beyond >= steps2) { beyond -= steps2; steps2 -= 1 }\n   \n    steps1 + steps2\n  }\n\n  def quadEqn(n: Int): Int = {\n    (-0.5 + math.sqrt(0.25 + 2 * n)).ceil.toInt\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335862,"user_id":168,"body":"object LonelyFrogII {\n  def jumpTo(n: Int): Int = {\n    val d = n - 1\n    val m = Math.sqrt(d).toInt\n    if (d > 0) m - 1 + d \/ m + (d % m).sign else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335863,"user_id":null,"body":"object LonelyFrogII {\n  \n  def sum(n: Long): Long = (n*n + n)\/2\n  \n  def jumpTo(n: Long): Int = {\n    val max = math.floor(math.sqrt(n)).toInt\n    println(n)\n    val d = n - 1\n    def jumpAux(acc: Long = 0, jumps: Int = 0, a: Long = 0, max: Long = 0): Int = {\n      val diff = d - acc\n      if (diff == 0) jumps\n      else if (diff - sum(a) >= a + 1) jumpAux(acc + a + 1, jumps + 1, a + 1, max + 1) \n      else if (diff - sum(max - 1) >= a) jumpAux(acc + a, jumps + 1, a, max)\n      else if (diff == sum(max - 1)) jumpAux(acc + diff, jumps + (max - 1).toInt, a, max)\n      else jumpAux(acc, jumps, a - 1, max)\n    }\n    jumpAux()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335864,"user_id":527,"body":"object LonelyFrogII:\n  def jumpTo(n: Int): Int =\n    if (n == 1)\n      0\n    else\n      val k = math.sqrt(n - 1).ceil.toInt\n      if (k * (k - 1) >= n - 1) 2 * (k - 1) else 2 * k - 1","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335865,"user_id":null,"body":"import scala.annotation.tailrec\nobject LonelyFrogII {\n    def jumpTo(n: Int): Int = {\n      @tailrec\n      def spin(counter: Int, remains: Int, curSpeed: Int): Int = {\n        remains match {\n          case 0 => counter\n          case 1 => counter + 1\n          case rem =>\n            val additionalDistance = (curSpeed + 1) + curSpeed\n            if (rem >= additionalDistance) spin(counter + 2, rem - additionalDistance, curSpeed + 1)\n            else if (rem >= curSpeed) spin(counter + 1, rem - curSpeed, curSpeed)\n            else if (rem < curSpeed) spin(counter + 1, 0, curSpeed)\n            else throw new Throwable(\"Ooops. You were wrong\")\n        }\n      }\n      val start = n-2\n      if (start >= 0) spin(1,start,1)\n      else 0\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335866,"user_id":null,"body":"object LonelyFrogII {\n  def jumpTo(n: Int): Int = {\n    def jumpToHelper(n: Int, i: Int): Int = {\n      val rest = n - 1 - (1 + i) * i\n      if(2 * (i + 1) <= rest) {\n        jumpToHelper(n, i + 1)\n      } else if(i + 1 < rest && rest < 2 * (i + 1)) {\n        2 * i + 2\n      } else if(0 < rest && rest <= i + 1) {\n        2 * i + 1\n      } else {\n        2 * i\n      }\n    }\n    \n    if(n <= 2) n - 1 else jumpToHelper(n, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335867,"user_id":null,"body":"object LonelyFrogII {\n  def jumpTo(n: Int): Int = {\n    val k = kk(n)\n    if (n == 1) 0 else if (n > k * k + 1) 2 * k else 2 * k - 1\n  }\n\n  private def kk(n: Int): Int = {\n    val s = math.sqrt(n - 3.0 \/ 4.0) + 0.5\n    if (s.isWhole) s.toInt - 1 else s.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335868,"user_id":null,"body":"\nimport scala.annotation.tailrec\n\nobject LonelyFrogII {\n  def jumpTo(n: Int): Int = {\n    @tailrec def loop(current: Int, prevJump: Int, jumps: Int): Int = {\n      if (current == n) jumps\n      else {\n        val nextJump = {\n          if (current + (prevJump * (prevJump + 1) \/ 2) > n) prevJump - 1\n          else if (current + ((prevJump + 1) * (prevJump + 2) \/ 2) <= n) prevJump + 1\n          else prevJump\n        }\n        loop(current + nextJump, nextJump, jumps + 1)\n      }\n    }\n    loop(1, 0, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335869,"user_id":null,"body":"object LonelyFrogII {\n    def jumpTo(n: Int): Int = {\n\n    val midPt = if (n % 2 == 0) n \/ 2 else n \/ 2 + 1\n    val (count, finish) = numJumps(midPt)\n    val maxJump = count\n    val gap = n - 2 * finish + 1\n    if (gap == 0) {\n      count * 2\n    } else if (gap <= maxJump + 1) {\n      count * 2 + 1\n    } else {\n      count * 2 + 2\n    }\n  }\n\n  def jSum(n: Int): Int = n * (n + 1) \/ 2\n\n  def numJumps(n: Int): (Int,Int) = {\n    var lo = 0\n    var hi = Math.ceil(Math.sqrt(n * 2)).toInt\n    while (hi - lo > 1) {\n      val mid = (hi + lo) \/ 2\n      if (1 + jSum(mid) > n) {\n        hi = mid\n      } else {\n        lo = mid\n      }\n    }\n    (lo, jSum(lo) + 1)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59ccf051dcc4050f7800008f":[{"id":335870,"user_id":null,"body":"object Bud {\n  def divSum(in: Long): Long = (2 to math.sqrt(in.toDouble).toInt).collect{\n    case x if in % x == 0 => if(x*x == in) x.toLong else x.toLong + in\/x\n  }.sum\n  def buddy(start: Long, limit: Long): String = {\n    (start to limit).find{ n =>\n      val ns = divSum(n)\n      ns > n && divSum(ns) == n\n    }.map(n => s\"($n ${divSum(n)})\").getOrElse(\"Nothing\")\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-12 12:47:34"},{"id":335871,"user_id":492,"body":"object Bud {\n\n  private def nbd(n: Long): Long = {\n    var sum: Long = 1\n    var i: Long = 2\n    while (i <= Math.sqrt(n).toLong) {\n      if (n % i == 0) {\n        sum += i\n        val d: Long = n \/ i\n        if (d != i) sum += d\n      }\n      i += 1\n    }\n    sum\n  }\n  def buddy(start: Long, limit: Long): String = {\n    var n: Long = start\n    while (n <= limit) {\n      val m: Long = nbd(n) - 1\n      if (n == nbd(m) - 1 && n < m)\n        return \"(\" + java.lang.Long.toString(n) + \" \" + java.lang.Long.toString(m) + \")\"\n      n += 1\n    }\n    \"Nothing\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335872,"user_id":null,"body":"object Bud {\n  def sumOfDivisors(n: Long) = (2L to Math.sqrt(n.toDouble).toLong).fold(0L) { (sum, i) =>\n    sum + {\n      if (n % i == 0) i + (if (n \/ i == i) 0 else n \/ i)\n      else 0L\n    }\n  }\n  def buddy(start: Long, limit: Long): String = {\n    (start to limit).view.map { n =>\n      val sd = sumOfDivisors(n)\n      (n, sd, sd > n && sumOfDivisors(sd) == n)\n    }.collectFirst { case e if e._3 => s\"(${e._1} ${e._2})\" }.getOrElse(\"Nothing\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335873,"user_id":null,"body":"object Bud {\n  def buddy(start: Long, limit: Long): String = {\n    var counter = start\n    while(counter <= limit) {\n      val currentSum = sumFactors(counter)\n      if (currentSum > counter+1 && sumFactors(currentSum-1) == counter+1) return \"(\"+counter+\" \"+(currentSum-1)+\")\"\n      counter += 1\n    }\n    return \"Nothing\"\n  }\n  def factor(x: Long, n: Long) = n % x == 0\n    \n  def sumFactors(n: Long): Long = {\n    var total = 1L\n    var x = 2L\n    while (x * x <= n){\n      if (factor(x, n)){\n          total += x\n          if (n\/x > x) total += n\/x\n      }\n      x += 1\n    }    \n    return total\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335874,"user_id":null,"body":"object Bud {\n  def buddy(start: Long, limit: Long): String = {\n    lazy val res = (start to limit).toStream map(x => (x, getSum(x))) find(x => {x._2 > x._1 && x._1 == getSum(x._2)})\n    try {\n      s\"(${res.get._1} ${res.get._2})\"\n    } catch {\n      case e: NoSuchElementException => \"Nothing\"\n    }\n  }\n  \n  def getSum(n: Long) = {\n    val factors = factorize(n)\n    (1 until factors.length).flatMap(i => factors.combinations(i).map(_.product)).sum\n  }\n  \n  import scala.annotation.tailrec\n  @tailrec\n  def factorize(n: Long, a: Int = 2, list: List[Long] = Nil):List[Long] = a*a > n match {\n    case false if n % a == 0 => factorize(n \/ a, a, a :: list)\n    case false => factorize(n, a + 1, list)\n    case true => n :: list\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335875,"user_id":null,"body":"object Bud {\n  def factorize(x: Long): List[Long] = {\n    def func(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a * a > x match {\n      case false if x % a == 0 => func(x \/ a, a, a :: list)\n      case false => func(x, a + 1, list)\n      case true => x :: list\n    }\n\n    val factors = func(x)\n\n    factors.indices.flatMap(i => factors.combinations(i).map(_.product).toList).toList.sorted\n  }\n\n  def buddy(start: Long, limit: Long): String = {\n    (start to limit).foreach { x =>\n      val divOfX = factorize(x)\n      if ((divOfX.sum - 1 > x) && (factorize(divOfX.sum - 1).sum - 1 == x))\n        return s\"($x ${divOfX.sum - 1})\"\n    }\n    \"Nothing\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335876,"user_id":null,"body":"import Math._\nobject Bud {\n  def buddy(start: Long, limit: Long): String = {\n    for(i <- start to limit){\n      val aux = fact(i).sum-1\n      var sum = 0L\n      var range = true\n      for(s <- sqrt(aux).round to 2L by -1; if range && aux > i){        \n        if(aux%s == 0) sum += s + aux\/s\n        if(sum > i) range = false\n      }\n      if(sum == i) return \"(\"+i+\" \"+aux+\")\"\n    }\n    \"Nothing\"\n  }\n  def fact(n: Long) = {\n    val facts = (2L to sqrt(n).round).filter(n%_==0)\n    (Seq(1L)++facts++facts.map(n\/_)).toSet\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335877,"user_id":null,"body":"  object Bud {\n    def divisorsSum(x: Long): Long = {\n      val pars = 2L.to(math.sqrt(x).toLong).filter(x % _ == 0)\n       pars.map(x \/ _).sum  + pars.sum + 1\n    }\n\n    def buddy(start: Long, limit: Long): String =\n      start.to(limit)\n        .map(x => (x, divisorsSum(x) - 1))\n        .collectFirst {\n          case (x, sum) if x < sum && divisorsSum(sum) == x + 1  =>\n            s\"($x $sum)\"\n        }.getOrElse(\"Nothing\")\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335878,"user_id":null,"body":"import scala.math.sqrt\n\nobject Bud {\n  \n  def sum_proper_divisors(a: Long): Long={\n        var result = 0L \/\/L for Long\n     \n        \/\/ find all divisors which divides a\n        for (i <- 2L to (sqrt(a)+0.5).toLong if a % i == 0){\n            \/\/ if 'i' is divisor of a\n            if (a% i == 0){\n                \/\/ if both divisors are same then add it only once else add both\n                if (i == (a\/ i)){\n                    result= result+i}\n                else{\n                    result = result + (i + a \/ i)}\n            }\n        }\n     \n        \/\/ 1 is also a divisor\n        return (result + 1L).toLong;\n    }\n  \n  def buddy(start:Long, limit: Long): String = {\n    for (n <- start to limit){\n      val m=sum_proper_divisors(n)-1\n      if ((sum_proper_divisors(m)==n+1) && (m>n) ){\n        return \"(\"+n +\" \"+ m+\")\"\n      }\n    }\n    return(\"Nothing\")\n        \n  \n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335879,"user_id":null,"body":"object Bud {\n  def buddy(start: Long, limit: Long): String = {\n    for(n<-start to limit){\n      val sumn = findsum(n)\n      if(sumn>n) if (findsum(sumn) == n)  {\n        return \"(\"+n+\" \"+sumn+\")\" \n      }\n    } \n    return\"Nothing\"\n  }\n  def findsum(a: Long): Long={ \/\/sum n - 1\n    def helper(a: Long, i: Long, res: Long): Long= {\n      if(a\/i+1<i) return res\n      if(a\/i==i && a%i==0) return res+i\n      if(a%i==0) helper(a, i+1, res+i+a\/i)    \n      else helper(a, i+1, res)\n    }\n    helper(a, 2, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59d0ee709f0cbcf65400003b":[{"id":335880,"user_id":null,"body":"object State {\n  def byState(s: String): String = {\n    var res:String=\"\"\n    val arr:Array[String] = s.split(\"\n\").map(x=>\"..... \"+\n        x.replace(\",\",\"\").dropRight(2).trim + \" \" +\n        (x.takeRight(2) match {\n              case \"AZ\" => \"Arizona\"\n              case \"CA\" => \"California\"\n              case \"ID\" => \"Idaho\"\n              case \"IN\" => \"Indiana\"\n              case \"MA\" => \"Massachusetts\"\n              case \"OK\" => \"Oklahoma\"\n              case \"PA\" => \"Pennsylvania\"\n              case \"VA\" => \"Virginia\"\n              case _ => \"\"})\n    ).sorted\n\n    for (a<-arr.map(x=>x.split(\" \").last).sorted.distinct)\n      res += s\" ${a}\n\"+arr.filter(x=>x.indexOf(a)>=0).mkString(\"\n\")+\"\n\"\n\n    res.tail.dropRight(1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335881,"user_id":null,"body":"object State {\n  \n  val states = Map(\"AZ\" -> \"Arizona\",\n                   \"CA\" -> \"California\", \n                   \"ID\" -> \"Idaho\", \n                   \"IN\" -> \"Indiana\", \n                   \"MA\" -> \"Massachusetts\",\n                   \"OK\" -> \"Oklahoma\",\n                   \"PA\" -> \"Pennsylvania\",\n                   \"VA\" -> \"Virginia\"\n                  )\n  \n  def byState(s: String): String = {\n    val byStates = s.split('\n').groupBy(_.takeRight(2))\n    byStates.keySet.toList.sorted.map(x => (List(states(x)) ++ byStates(x).map(\n      y => \"..... \" ++ y.replaceAll(x, states(x)).replaceAll(\",\", \"\")).sorted).mkString(\"\n\")).mkString(\"\n \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335882,"user_id":573,"body":"object State {\n  \n  val states = Map(\"AZ\" -> \"Arizona\", \"CA\" -> \"California\", \"ID\" -> \"Idaho\", \"IN\" -> \"Indiana\", \"MA\" -> \"Massachusetts\", \"OK\" -> \"Oklahoma\", \"PA\" -> \"Pennsylvania\", \"VA\" -> \"Virginia\")\n\n  def byState(text: String): String =\n    text\n      .lines.toList\n      .map(_.replace(\",\", \"\").split(\" \"))\n      .groupBy(_.last).toList\n      .sortBy(_._1)\n      .map {\n        case (code, items) =>\n          val people = items.map(x => s\"\"\"..... ${x.init.mkString(\" \")} ${states(code)}\"\"\").sorted.mkString(\"\n\")\n          s\"${states(code)}\n$people\"\n      }\n      .mkString(\"\n \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335883,"user_id":null,"body":"object State {\n  private val states: Map[String, String] =\n    Map(\n      (\"AZ\", \"Arizona\"),\n      (\"CA\", \"California\"),\n      (\"ID\", \"Idaho\"),\n      (\"IN\", \"Indiana\"),\n      (\"MA\", \"Massachusetts\"),\n      (\"OK\", \"Oklahoma\"),\n      (\"PA\", \"Pennsylvania\"),\n      (\"VA\", \"Virginia\")\n    )\n\n  def byState(s: String): String =\n    s.split(\"\n\")\n      .map { address =>\n        val st = state(address)\n        (st, s\"..... ${address.dropRight(2).replace(\",\", \"\")}$st\")\n      }\n      .groupBy(_._1)\n      .map { case (st, array) => s\"$st\n${array.map(_._2).sorted.mkString(\"\n\")}\" }\n      .toArray\n      .sorted\n      .mkString(\"\n \")\n\n  private def state(address: String): String =\n    states(states.keys.find(address.endsWith).getOrElse(\"\"))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335884,"user_id":null,"body":"object State {\n  def byState(s: String): String = {\n    val states = Map(\n      \"AZ\" -> \"Arizona\",\n      \"CA\" -> \"California\",\n      \"ID\" -> \"Idaho\",\n      \"IN\" -> \"Indiana\",\n      \"MA\" -> \"Massachusetts\",\n      \"OK\" -> \"Oklahoma\",\n      \"PA\" -> \"Pennsylvania\",\n      \"VA\" -> \"Virginia\"\n    )\n     \/\/ im drunk af so here we have a bad solution, still works tho lol\n    s.split(\"\n\").map { row =>\n      val elems = row.split(\",?\\\\s\")\n      elems.init.appended(states(elems.last)).toList\n    }.groupBy(_.last).map(x => x._1 -> x._2.map(_.mkString(\" \")).toList.sorted).toList.sortBy(_._1).map { x =>\n      x._1 + \"\n\" + x._2.mkString(\"..... \", \"\n..... \", \"\")\n    }.mkString(\"\", \"\n \", \"\")\n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335885,"user_id":null,"body":"object State {\n  val stateMapping = Map(\"AZ\" -> \"Arizona\",\n                          \"CA\" -> \"California\",\n                          \"ID\" -> \"Idaho\",\n                          \"IN\" -> \"Indiana\",\n                          \"MA\" -> \"Massachusetts\",\n                          \"OK\" -> \"Oklahoma\",\n                          \"PA\" -> \"Pennsylvania\",\n                          \"VA\" -> \"Virginia\")\n  \n  case class toVisit(name: String,\n                     street: String,\n                     city: String,\n                     state: String)  \n  def byState(s: String): String = \n    s.split(\"\n\")\n      .map{ x =>\n          val t =  x.split(\",\")\n          val cityState = t(2).split(\" \")\n          toVisit(t(0),\n            t(1),\n            cityState.init.mkString(\" \"),\n            stateMapping(cityState.last))}\n      .groupBy(_.state)\n      .toSeq\n      .sortBy(_._1)\n      .map{ x =>\n      x._2\n        .sortBy(_.name)\n        .foldLeft(s\"${x._1}\n\")((x,y) => x + s\"..... ${y.name}${y.street}${y.city} ${y.state}\n\")\n      }.mkString(\" \").stripLineEnd\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335886,"user_id":null,"body":"object State {\n  val states: Map[String, String] = Map(\n    \"AZ\" -> \"Arizona\",\n    \"CA\" -> \"California\",\n    \"ID\" -> \"Idaho\",\n    \"IN\" -> \"Indiana\",\n    \"MA\" -> \"Massachusetts\",\n    \"OK\" -> \"Oklahoma\",\n    \"PA\" -> \"Pennsylvania\",\n    \"VA\" -> \"Virginia\"\n  )\n\n  def byState(s: String): String =\n    s.replaceAll(\",\", \"\")\n      .split(\"\n\")\n      .groupBy(add => add.takeRight(2))\n      .toSeq.sortBy(_._1)\n      .map { case (s, addrs) =>\n        val state = states(s)\n        state + \"\n..... \" +\n          addrs.sorted.map { a => a.dropRight(2) + state }.mkString(\"\n..... \")\n      }.mkString(\"\n \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335887,"user_id":492,"body":"import java.util._\nobject State {\n\n  def byState(s: String): String = {\n    var str = s\n    class StateFriend {\n      var state: String = _\n      var name: String = _\n      var address: String = _\n      var town: String = _\n    }\n    class CustomComparator extends Comparator[StateFriend] {\n      override def compare(o1: StateFriend, o2: StateFriend): Int = {\n        if (o1.state == o2.state) {\n          o1.name.compareTo(o2.name)\n        } else {\n          o1.state.compareTo(o2.state)\n        }\n      }\n    }\n    val sa: Array[String] = Array(\" MA\", \" VA\", \" OK\", \" PA\", \" CA\", \" AZ\", \" ID\", \" IN\")\n    val st: Array[String] = Array(\", Massachusetts\", \", Virginia\", \", Oklahoma\", \", Pennsylvania\", \", California\", \", Arizona\", \", Idaho\", \", Indiana\") \n    for (i <- 0 until sa.length) {\n      str = str.replace(sa(i), st(i))\n    }\n    val arr: Array[String] = str.split(\"[\\\n]+\")\n    val narr: List[StateFriend] = new ArrayList[StateFriend]()\n    for (i <- 0 until arr.length) {\n      val y: Array[String] = arr(i).split(\", \")\n      val sf: StateFriend = new StateFriend()\n      sf.state = y(3).trim()\n      sf.name = y(0)\n      sf.address = y(1)\n      sf.town = y(2)\n      narr.add(sf)\n    }\n    Collections.sort(narr, new CustomComparator())\n    var result: String = \"\"\n    var last: String = \"\"\n    for (i <- 0 until narr.size) {\n      val sf = narr.get(i)\n      val e: String = sf.state\n      if (e != last) {\n        last = e\n        result += \"\n\" + \" \" + e + \"\n..... \" + sf.name + \" \" + sf.address + \" \" + sf.town + \" \" + sf.state\n      } else {\n        result += \"\n..... \" + sf.name + \" \" + sf.address + \" \" + sf.town + \" \" + sf.state\n      }\n    }\n    result.substring(2, result.length)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59d727d40e8c9dd2dd00009f":[{"id":335888,"user_id":573,"body":"object EasyBal {\n\n  def balance(book: String): String = {\n    \n    val balance :: lines =\n      book.filter(c => c.isLetterOrDigit || c.isWhitespace || c == '.').split(\"\n\").toList\n\n    val (cleanLines, newBalance, total) = lines\n      .collect { case line if line.nonEmpty => line.split(\"\\\\s+\") }\n      .foldLeft(List[String](), balance.toDouble, 0d) {\n        case ((checks, balance, total), line) =>\n          val (number, category, amount) = (line.head, line.init.tail.mkString(\" \"), line.last.toDouble)\n          val newBalance = balance - amount\n          (f\"$number $category $amount%.2f Balance $newBalance%.2f\" :: checks, newBalance, total + amount.toDouble)\n      }\n\n    val checks = cleanLines.reverse.mkString(\"\\\\r\\\n\")\n    val average = total \/ cleanLines.size.toDouble\n\n    f\"Original Balance: $balance\\\\r\\\n$checks\\\\r\\\nTotal expense  $total%.2f\\\\r\\\nAverage expense  $average%.2f\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335889,"user_id":492,"body":"object EasyBal {\n\n  def balance(book: String): String = {\n    val t: String = book.replaceAll(\"([^\\\n. \\\\da-zA-Z])\", \"\")\n    val arr: Array[String] = t.split(\"[\\\n]+\")\n    var current: Double = java.lang.Double.parseDouble(arr(0))\n    var total: Double = 0\n    var count: Int = 0\n    val result: StringBuilder = new StringBuilder()\n    result.append(\"Original Balance: \" + arr(0))\n    for (i <- 1 until arr.length) {\n      count += 1\n      val line: Array[String] = arr(i).split(\"[ ]+\")\n      current -= java.lang.Double.parseDouble(line(2))\n      total += java.lang.Double.parseDouble(line(2))\n      val u: String = \"\\\\r\\\n%s %s %s Balance %.2f\".format(line(0), line(1), line(2), current)\n      result.append(u)\n    }\n    result.append(\"\\\\r\\\nTotal expense  %.2f\\\\r\\\nAverage expense  %.2f\".format(total, total \/ count))\n    result.toString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335890,"user_id":null,"body":"object EasyBal {\n   case class Data(code :String , item :String, amount : Double)\n\n  def balance(book: String): String = {\n   \n  val originalText =  book.filter(l => l.isLetterOrDigit || l.isSpaceChar || l == '.' ||l == '\n').split(\"\n\")    \n  val balance = originalText.dropWhile(s => s.isEmpty).head.toDouble    \n  val datas = originalText.tail.map(l => l.split(\" +\")).map(d => Data(d(0),d(1),d(2).toDouble))\n  val amouts = datas.map(d => d.amount)\n  val soldes = amouts.toList.scanLeft(balance)((bal,am) => bal - am)\n  val average = amouts.sum \/datas.length  \n  val balanceRest = soldes.map(d => d.formatted(\"%.2f\"))\n    \n    s\"Original Balance: ${balance.formatted(\"%5.2f\")}\\\\r\\\n\" + \n    datas.zip(balanceRest.tail).map{\n     case (d,r) => d.code + \" \" + d.item + \" \" + d.amount.formatted(\"%.2f\") +\" Balance \" + r\n   }.mkString(\"\\\\r\\\n\") + s\"\\\\r\\\nTotal expense  ${amouts.sum.formatted(\"%.2f\")}\\\\r\\\n\" +\n   s\"Average expense  ${average.formatted(\"%.2f\")}\"\n    \n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335891,"user_id":null,"body":"object EasyBal {\n  def balance(book: String): String = {\n    val aas:Array[Array[String]] = book\n      .split(\"\n\")\n      .map(x=>x.filter(f => f.isDigit || f.isLetter || f=='.' || f.isWhitespace )\n                .replaceAll(\"[\\\\s]{2,}\", \" \")\n                .trim )\n      .map(x=>x.split(' '))\n\n    var Balance:Double = aas.head.mkString.filter(x=> x.isDigit || x=='.').toDouble\n    val Total_expense:Double = aas.tail.map(x=>x.apply(2).toDouble).sum\n    val Average_expense:Double = Total_expense \/ aas.tail.size\n\n    f\"Original Balance: $Balance%1.2f\".replace(',','.') +\"\\\\r\\\n\"+\n      (for (a <- aas.tail) yield {\n        Balance -= a(2).toDouble\n        f\"${a(0)} ${a(1)} ${a(2)} Balance $Balance%1.2f\".replace(',','.')+\"\\\\r\\\n\"\n      }).mkString +\n    f\"Total expense  $Total_expense%1.2f\".replace(',','.') +\"\\\\r\\\n\"+\n    f\"Average expense  $Average_expense%1.2f\".replace(',','.')\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335892,"user_id":null,"body":"import java.text.DecimalFormat\n\nobject EasyBal {\n\n  def format(x : Double) = \"%.2f\".format(x)\n\n  def clean(str : String) =\n    str.filter(ch => ch.isLetterOrDigit || ch == '.' || ch.isWhitespace)\n\n  def balance(book: String): String = {\n    val lines = clean(book).split(\"\n\").filter(_ != \"\")\n    if (lines.length == 1) {\n      \"\"\n    } else {\n      val originalBalance = lines.head.toDouble\n      val transactions = lines\n        .tail\n        .map(line => {\n          val words = line.split(\" \").filterNot(_.isEmpty)\n          val label = words.take(words.length - 1).mkString(\" \")\n          val price = words.last.toDouble\n          (label, price)\n        })\n      val first = (transactions.head, originalBalance - transactions.head._2)\n      val report =\n        transactions.tail\n          .scanLeft(first){case ((_, balance), (label, price)) => ((label, price), balance - price)}\n          .map{ case((label, price), balance) => List(label, format(price), \"Balance\", format(balance)).mkString(\" \") }\n          .mkString(\"\\\\r\\\n\")\n        val total = transactions.map(_._2).sum\n      s\"Original Balance: ${originalBalance}0\\\\r\\\n\" +\n        report + \"\\\\r\\\n\" +\n        \"Total expense  \" + format(total) + \"\\\\r\\\n\" +\n        \"Average expense  \" + format(total \/ transactions.length.toDouble);\n    }\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335893,"user_id":null,"body":"object EasyBal {\n\n  def balance(book: String): String = {\n    val lines = book.linesIterator.toList.map(x => x.replaceAll(\"[^a-zA-Z0-9. ]\", \"\").trim)\n    .filter(_ != \"\").map(x => x.split(\" \").filter(_ != \"\").mkString(\" \"))\n    val balance = lines(0).toDouble\n    val expenses = lines.tail.map(x => x.drop(x.lastIndexOf(\" \")).toDouble).reverse\n    val totals = (0 to expenses.length - 1).map(x => expenses.drop(x).sum).toList.reverse\n    (List(f\"Original Balance: $balance%2.2f\") ++ \n    (0 to expenses.length - 1).map(x => lines(x+1).concat(f\" Balance ${balance - totals(x)}%2.2f\")).toList ++ \n    List(f\"Total expense  ${totals.last}%2.2f\", f\"Average expense  ${expenses.sum\/expenses.length}%2.2f\"))\n    .mkString(\"\\\\r\\\n\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335894,"user_id":null,"body":"import scala.collection.mutable.ArrayBuffer\n\nobject EasyBal {\n\n  def balance(book: String): String = {\n    val lines = book.split(\"\n\").filterNot(_.isEmpty)\n    val Array(start) = lines.head.split(\" \").map(clean)\n    \n    val buffer = ArrayBuffer.empty[Double]\n    var count = start.toDouble\n    \n    val rest = lines.tail.map { line =>\n      line.split(\" \").map(clean).filterNot(_.isEmpty) match {\n        case Array(id, desc, price) =>\n          val currPrice = price.toDouble\n          \n          buffer += currPrice\n          count -= currPrice\n          \n          s\"$id $desc ${\"%.2f\" format currPrice} Balance ${\"%.2f\" format count}\"\n        case _ => \"\"\n      }\n    }.mkString(\"\\\\r\\\n\")\n    \n    val sum = buffer.sum\n    val avg = sum \/ buffer.length\n    \n    s\"Original Balance: $start\\\\r\\\n$rest\\\\r\\\nTotal expense  ${\"%.2f\" format sum}\\\\r\\\nAverage expense  ${\"%.2f\" format avg}\"\n  }\n  \n  private def clean(string: String): String = string.filter(c => c == '.' || c.isLetterOrDigit)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335895,"user_id":null,"body":"import java.util.Locale\n\nobject EasyBal {\n  def balance(book: String): String = {\n    book.replaceAll(\"[^\\\\w\\\\s\\\\.]\", \"\").split(\"\n\").toList match {\n      case originalBalance :: rest =>\n        rest.foldLeft((originalBalance.toDouble, List.empty[String])) { case ((balance, lines), line) =>\n          line.trim.split(\"\\\\s+\") match {\n            case Array(checkNumber, category, checkAmount) =>\n              val newBalance = balance - checkAmount.toDouble\n              val formattedLine = s\"%s %s %s Balance %.2f\".formatLocal(Locale.US, checkNumber, category, checkAmount, newBalance)\n\n              (newBalance, lines :+ formattedLine)\n            case _ => (balance, lines)\n          }\n        } match {\n          case (newBalance, lines) =>\n            val totalExpense = originalBalance.toDouble - newBalance\n            val averageExpense = totalExpense \/ lines.length\n\n            val start = s\"Original Balance: $originalBalance\\\\r\\\n\"\n            val end = \"\\\\r\\\nTotal expense  %.2f\\\\r\\\nAverage expense  %.2f\".formatLocal(Locale.US, totalExpense, averageExpense)\n            lines.mkString(start, \"\\\\r\\\n\", end)\n        }\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335896,"user_id":null,"body":"object EasyBal {\n  case class Row(number: String, category: String, amount: Double)\n\n  def balance(book: String): String = {\n    val array           = book.replaceAll(\"[^\\\\w\\\\d.\\\\s]\", \"\").split(\"\n\")\n    val balance         = array.head.trim.toDouble\n    val originalBalance = s\"Original Balance: ${d2s(balance)}\"\n    var total           = 0.0\n    val rows =\n      array.tail\n        .map { case s\"$number $category $amount\" => Row(number, category, amount.toDouble) }\n        .map { row =>\n          total += row.amount\n          s\"${row.number} ${row.category} ${d2s(row.amount)} Balance ${d2s(balance - total)}\"\n        }\n        .mkString(\"\\\\r\\\n\")\n\n    s\"$originalBalance\\\\r\\\n$rows\\\\r\\\nTotal expense  ${d2s(total)}\\\\r\\\nAverage expense  ${d2s(total \/ (array.length - 1))}\"\n  }\n\n  private def d2s(d: Double): String = String.format(\"%.2f\", d).replaceAll(\",\", \".\")\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335897,"user_id":null,"body":"    import scala.annotation.tailrec\n\n  object EasyBal {\n\n      def balance(book: String): String = {\n        val lines = book\n          .replaceAll(\"[^a-zA-Z0-9\\\\. \\\n]\", \"\")\n          .split(\"\n\")\n          .toSeq\n        val startBalance = lines.head.toFloat\n        val filtered = lines.tail\n          .map(_.split(\" +\"))\n          .flatMap {\n            case Array(no, name, cost) => Some((no, name, cost.toFloat))\n            case _                     => None\n          }.toList\n\n        @tailrec\n        def balance(\n            balanceStatus: Float,\n            rest: Seq[(String, String, Float)],\n            balancedBook: Seq[String] = Seq()\n        ): (Seq[String], Float) = {\n          rest match {\n            case Nil => (balancedBook, balanceStatus)\n            case x :: xs =>\n              balance(\n                balanceStatus - x._3,\n                xs,\n                balancedBook :+ f\"${x._1} ${x._2} ${x._3}%.2f Balance ${balanceStatus - x._3}%.2f\"\n              )\n          }\n        }\n\n        val (mainResult, finalBalance) = balance(startBalance, filtered)\n        val totalExpense               = startBalance - finalBalance\n        val averageExpense             = totalExpense \/ mainResult.length\n        (\n          f\"Original Balance: $startBalance%.2f\" +:\n          mainResult :+\n          f\"Total expense  $totalExpense%.2f\" :+\n          f\"Average expense  $averageExpense%.2f\"\n        ).mkString(\"\\\\r\\\n\")\n      }\n    }\n    ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59d9d8cb27ee005972000045":[{"id":335898,"user_id":573,"body":"object Catalog {\n\n  def catalog(s: String, article: String): String =\n    s.split(\"\n\")\n     .collect {\n       case s\"<prod><name>$name<\/name><prx>$price<\/prx><qty>$quantity<\/qty><\/prod>\" if name contains article =>\n         s\"$name > prx: $$$price qty: $quantity\"\n     }\n     match { case Array() => \"Nothing\" case x => x.mkString(\"\n\") }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335899,"user_id":527,"body":"object Catalog {\n\n  def catalog(s: String, article: String): String = {\n    s.lines\n      .collect{ case reLine(n, p, q) if n.contains(article) => s\"$n > prx: $$$p qty: $q\" }\n      .mkString(\"\n\")\n      match { case \"\" => \"Nothing\"; case s => s }\n  }\n  private val reLine = \"<prod><name>(.*?)<\/name><prx>(.*?)<\/prx><qty>(.*?)<\/qty><\/prod>\".r\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335900,"user_id":null,"body":"object Catalog {\n\n  def catalog(s: String, article: String): String = {\n    val x = scala.xml.XML.loadString(\"<root>\" + s + \"<\/root>\")\n    val matching = x \\ \"prod\" filter (e => ( (e \\ \"name\" text) contains article)) \n    if (matching isEmpty) \n      \"Nothing\"\n    else\n      matching map (e => (e \\ \"name\" text) + \" > prx: $\" + (e \\ \"prx\" text) + \" qty: \" + (e \\ \"qty\" text) ) mkString \"\n\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335901,"user_id":573,"body":"import scala.xml.XML\n\nobject Catalog {\n\n  def catalog(s: String, article: String): String = {\n\n    val items =\n      s.split(\"\n\n\")\n        .map(XML.loadString(_))\n        .collect {\n          case xml if (xml \\\\ \"name\" text).contains(article) =>\n            stringify(xml \\\\ \"name\" text, xml \\\\ \"prx\" text, xml \\\\ \"qty\" text)\n        }\n        .mkString(\"\n\")\n\n    if (items.isEmpty) \"Nothing\" else items\n  }\n\n  def stringify(name: String, price: String, quantity: String): String =\n    s\"$name > prx: $$$price qty: $quantity\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335902,"user_id":null,"body":"import util.matching.Regex\nobject Catalog {\n\n  def catalog(s: String, article: String): String = {\n    \n    val article_r = raw\".*($article).*\".r\n    val product_r = raw\"<prod><name>([^<>]*)<\/name><prx>([^<>]*)<\/prx><qty>([^<>]*)<\/qty><\/prod>\".r\n\n    val x = \"\n\n\".r.split(s)\n      .map(x => x match { \n          case product_r(name, price, quantity) => (name, price, quantity)\n        })\n      .filter(x=> article_r.matches(x._1))\n      .map({\n        case (name, price, quantity) => s\"$name > prx: $$$price qty: $quantity\"\n      })\n    \n    if (x.isEmpty) \"Nothing\" else x.mkString(\"\n\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335903,"user_id":null,"body":"object Catalog {\n\n  def catalog(s: String, article: String): String = {\n     val pattern = s\"<prod><name>(.*?${article}.*?)<\/name><prx>([\\\\d\\\\.]+)<\/prx><qty>(\\\\d+)<\/qty><\/prod>\".r  \n     val allMatches = pattern findAllMatchIn s\n     val lines = for (m <- allMatches) yield m.group(1) + \" > prx: $\" + m.group(2) + \" qty: \" + m.group(3)\n     if (lines.isEmpty) \"Nothing\" else lines.mkString(\"\n\")\n   }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335904,"user_id":null,"body":"\nobject Catalog {\n  \n  case class Prod(name:String,prx:String,qty:String)\n\n  def catalog(s: String, article: String): String = s.split(\"\n\n\").map(x=>Prod(x.substring(x.indexOf(\"<name>\")+\"<name>\".length,x.indexOf(\"<\/name>\")),x.substring(x.indexOf(\"<prx>\")+\"<prx>\".length,x.indexOf(\"<\/prx>\")),x.substring(x.indexOf(\"<qty>\")+\"<qty>\".length,x.indexOf(\"<\/qty>\"))))\n    .filter(_.name.contains(article)).map(x=>s\"${x.name} > prx: ${\"$\"+x.prx} qty: ${x.qty}\").mkString(\"\n\") match {\n      case \"\" =>\"Nothing\"\n      case s => s\n    }\n         \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335905,"user_id":null,"body":"object Catalog {\n  def catalog(s: String, article: String): String = {\n    val s1:String = s.split(\"\n\")\n      .filter(x=>x.indexOf(article)>=0)\n      .map(x=>\n            x.substring(x.indexOf(\"<name>\")+6, x.indexOf(\"<\/name>\"))+\" > prx: $\"+\n            x.substring(x.indexOf(\"<prx>\")+5, x.indexOf(\"<\/prx>\"))+\" qty: \"+\n            x.substring(x.indexOf(\"<qty>\")+5, x.indexOf(\"<\/qty>\")) ).mkString(\"\n\")\n    if (s1.isEmpty)\n      \"Nothing\" \n    else\n      s1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335906,"user_id":null,"body":"object Catalog {\n\n  def catalog(s: String, article: String): String = {\n    val res = s.split(\"\n\n\").filter(_.contains(article)).map(x => {\n      val name = \"(?<=<name>).*(?=<\/name>)\".r.findFirstMatchIn(x).get\n      val price = \"(?<=<prx>).*(?=<\/prx>)\".r.findFirstMatchIn(x).get\n      val qty = \"(?<=<qty>).*(?=<\/qty>)\".r.findFirstMatchIn(x).get\n      \"%s > prx: $%s qty: %s\".format(name, price, qty)\n    }).mkString(\"\n\")\n    if (res != \"\") res else \"Nothing\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335907,"user_id":null,"body":"object Catalog {\n\n  def catalog(s: String, article: String): String = {\n    val lines = s.split('\n').filter(_ != \"\").toList\n    .map(x =>\n        x\n        .replace(\"<prod>\", \"\")\n        .replace(\"<name>\", \"\")\n        .replace(\"<prx>\", \"\")\n        .replace(\"<qty>\", \"\")\n        .replace(\"<\/prod>\", \"\")\n        .replace(\"<\/name>\", \";\")\n        .replace(\"<\/prx>\", \";\")\n        .replace(\"<\/qty>\", \"\")\n        .split(\";\")\n        .toList).filter(_(0).contains(article))\n    val answer = lines.map(x => s\"${x(0)} > prx: ${\"$\".concat(x(1).toString)} qty: ${x(2)}\").mkString(\"\n\")\n    if (answer == \"\") \"Nothing\"\n    else answer\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59de1e2fe50813a046000124":[{"id":335908,"user_id":null,"body":"object MatchSubst {\n  import scala.util.matching.Regex\n  def change(s: String, prog: String, version: String): String = {\n    val m: Map[String, String] = s.split(\"\n\").map(w => (w.split(\": \")(0), w.split(\": \")(1))).toMap\n    if (m(\"Version\").matches(\"\\\\d+\\\\.\\\\d+\") && m(\"Phone\").matches(\"\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4}\")) {\n      s\"Program: ${prog} Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: ${if (m(\"Version\") == \"2.0\") \"2.0\" else version}\"\n    } else {\n      s\"ERROR: VERSION or PHONE\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335909,"user_id":492,"body":"import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util._;\n\nobject MatchSubst {\n\n  def change(s: String, prog: String, version: String): String = {\n    val p1: Pattern = Pattern.compile(\"(Phone: \\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4})\\\n\")\n    val m1: Matcher = p1.matcher(s)\n    val p2: Pattern = Pattern.compile(\"(Version: \\\\d+\\\\.\\\\d+)\\\n\")\n    val m2: Matcher = p2.matcher(s)\n    if ((m1.find() == false) || (m2.find() == false)) {\n      \"ERROR: VERSION or PHONE\"\n    }\n    else {\n      val ph: String = \"+1-503-555-0090\"\n      var v: String = \"\"\n      val matched: String = m2.group(1)\n      v = if (matched.==(\"Version: 2.0\")) \"2.0\" else version\n      String.format(\"Program: %s Author: g964 Phone: %s Date: 2019-01-01 Version: %s\", prog, ph, v)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335910,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject MatchSubst {\n  val VERSION_REGEX = raw\"Version: (\\d+\\.\\d+)\n\".r\n  val PHONE_REGEX = raw\"Phone: (\\+1-\\d{3}-\\d{3}-\\d{4})\n\".r\n\n  def change(s: String, prog: String, version: String): String = {\n    var sPhone = findItemFromRegex(PHONE_REGEX, s)\n    var sVersion = findItemFromRegex(VERSION_REGEX, s)\n\n    if (sPhone == \"\" || sVersion == \"\") {\n      \"ERROR: VERSION or PHONE\"\n    } else {\n      if (sVersion != \"2.0\") {\n        sVersion = version\n      }\n\n      sPhone = \"+1-503-555-0090\"\n\n      s\"Program: $prog Author: g964 Phone: $sPhone Date: 2019-01-01 Version: $sVersion\"\n    }\n  }\n  \n  def findItemFromRegex(regex: Regex, s: String): String = {\n    regex.findFirstMatchIn(s) match {\n      case Some(x) => x.group(1)\n      case _ => \"\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335911,"user_id":1285,"body":"object MatchSubst {\n\n  def change(s: String, prog: String, version: String): String = {\n    val split: Array[String] = s.split(\"\n\")\n      .filter(s => s.startsWith(\"Program title: \") ||\n        s.startsWith(\"Author: \") ||\n        s.startsWith(\"Phone: \") ||\n        s.startsWith(\"Date: \") ||\n        s.startsWith(\"Version: \"))\n      .map(s => {\n        if (s.startsWith(\"Program title: \")) {\n          (\"Program: \" + prog, 0)\n        } else if (s.startsWith(\"Author: \")) {\n          (\"Author: g964\", 1)\n        } else if (s.startsWith(\"Phone: \")) {\n          if (\".1-[0-9]{3}-[0-9]{3}-[0-9]{4}\".r.matches(s.split(\" \")(1)))\n            (\"Phone: +1-503-555-0090\", 2)\n          else\n            (\"Invalid\", 2)\n        } else if (s.startsWith(\"Date: \")) {\n          (\"Date: 2019-01-01\", 3)\n        } else if (s.startsWith(\"Version: \")) {\n          if (s.split(\" \")(1) == \"2.0\")\n            (\"Version: 2.0\", 4)\n          else if (\"\\\\d+\\\\.\\\\d+\".r matches s.split(\" \")(1))\n            (\"Version: \" + version, 4)\n          else\n            (\"Invalid\", 4)\n        } else {\n          (\"\", -1)\n        }\n      })\n      .sortWith((a, b) => a._2 <= b._2)\n      .map(_._1)\n\n    if (split.contains(\"Invalid\"))\n      \"ERROR: VERSION or PHONE\"\n    else\n      split\n        .mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335912,"user_id":null,"body":"object MatchSubst {\n\n  val ERROR_CODE = \"ERROR\"\n  val EXCLUDE_REGEX = \"^Corporation|Level\"\n  val VERSION_REGEX = \"^\\\\d+\\\\.\\\\d+$\"\n  val PHONE_REGEX = \"^\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4}$\"\n\n  def change(s: String, prog: String, version: String): String = {\n    val lines = s.split('\n')\n    val result = lines.map { line =>\n      val parts = line.split(\":\")\n      val title = parts(0)\n      val value = parts(1)\n\n      (title, value.trim) match {\n        case (title, value) if List(title, value).exists(_.matches(EXCLUDE_REGEX)) => None\n        case (\"Program title\", _) => Some(s\"Program: $prog\")\n        case (\"Author\", _) => Some(\"Author: g964\")\n        case (\"Date\", _) => Some(\"Date: 2019-01-01\")\n        case (\"Version\", value) =>\n          if(value.matches(VERSION_REGEX)) {\n            Some(s\"Version: ${if(value == \"2.0\") \"2.0\" else version}\")\n          } else {\n            Some(ERROR_CODE)\n          }\n        case (\"Phone\", value) =>\n          if(value.matches(PHONE_REGEX)) {\n            Some(\"Phone: +1-503-555-0090\")\n          } else {\n            Some(ERROR_CODE)\n          }\n        case (t, v) => Some(s\"$t: $v\")\n      }\n    }\n\n    if(result.exists(_.exists(s => s == ERROR_CODE))) \"ERROR: VERSION or PHONE\"\n    else result.collect {\n      case Some(s) => s\n    }.mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335913,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject MatchSubst {\n  \n  val phoneMatcher = \"\"\"\\+1-\\d{3}-\\d{3}-\\d{4}\"\"\".r\n  val versionMatcher = \"\"\"\\d{1,}\\.\\d{1,}\"\"\".r\n  \n  def isNotValid(phone: String, version: String): Boolean = {\n    !(phoneMatcher.pattern.matcher(phone).matches && versionMatcher.pattern.matcher(version).matches)\n  }\n  \n  def change(s: String, prog: String, version: String): String = {\n    val lines = s.split('\n')\n    if (isNotValid(lines(3).drop(lines(3).indexOf(\" \") + 1), lines(5).drop(lines(5).indexOf(\" \") + 1))) {\n      \"ERROR: VERSION or PHONE\"\n    }\n    else {\n      val program = s\"Program: $prog\"\n      val author = \"Author: g964\"\n      val phone = \"Phone: +1-503-555-0090\"\n      val date = \"Date: 2019-01-01\"\n      val vers = if (lines(5).drop(lines(5).indexOf(\" \") + 1) != \"2.0\") s\"Version: $version\" else lines(5)\n      List(program, author, phone, date, vers).mkString(\" \")\n    } \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335914,"user_id":null,"body":"object MatchSubst {\n  def change(s: String, prog: String, version: String): String = {\n    val author = \"Author: (\\\\w*)\".r\n    val number = \"(\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4})\".r\n    val versio = \"[^\\\\.](\\\\d+\\\\.\\\\d+)[^\\\\.]\".r\n\n    val auth = author\n      .findFirstMatchIn(s)\n      .map(x => x.group(1))\n    val phone = number\n      .findFirstMatchIn(s)\n      .map(x => x.group(1))\n    val vers = versio\n      .findFirstMatchIn(s)\n      .map(x => x.group(1))\n\n    val res = for {\n      x <- auth\n      y <- phone\n      z <- vers\n      u = if (z == \"2.0\") \"2.0\" else version \n    } yield s\"Program: $prog Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: $u\"\n    \n    res.getOrElse(\"ERROR: VERSION or PHONE\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335915,"user_id":null,"body":"object MatchSubst {\n\n  def change(s: String, prog: String, version: String): String = {\n    val Pattern = \"\"\"\\d+\\.\\d+\"\"\".r\n    val phonePattern = \"\"\"\\+1-\\d{3}-\\d{3}-\\d{4}\"\"\".r\n    val sList = s.split(\"\n\").toList.map(_.split(\": \")).map { case Array(f1,f2) => (f1,f2) }\n    val newList = sList.collect{\n      case (\"Program title\", name) => (\"Program\", prog)\n      case (\"Author\", name) => (\"Author\", \"g964\")\n      case (\"Phone\", phonePattern()) => (\"Phone\", \"+1-503-555-0090\")\n      case (\"Date\", date) => (\"Date\", \"2019-01-01\")\n      case (\"Version\", \"2.0\") => (\"Version\", \"2.0\")\n      case (\"Version\", Pattern()) => (\"Version\", version)\n      case (\"Version\", _) => (\"Version\", \"ERROR: VERSION or PHONE\")\n      case (\"Phone\", _) => (\"Phone\", \"ERROR: VERSION or PHONE\")\n    }\n    val result = newList.map(tuple => tuple.productIterator.mkString(\": \")).mkString(\" \")\n    val newResult = if (result contains \"ERROR: VERSION or PHONE\") {\n      \"ERROR: VERSION or PHONE\"\n    }\n    else {result}\n    newResult\n    \n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335916,"user_id":null,"body":"import scala.collection.mutable\n\nobject MatchSubst {\n\n   def change(s: String, prog: String, version: String): String = {\n    val map:mutable.HashMap[String,String] = new mutable.HashMap()\n    map.update(\"Program\",prog)\n    \/\/    map.update(\"Author\",\"g964\")\n    map.update(\"Phone\",\"+1-503-555-0090\")\n    \/\/    map.update(\"Date\",\"2019-01-01\")\n    map.update(\"Version\",\"1.1\")\n    val groups: Array[Array[String]] = s.split(\"\\\n\").map(_.split(\":\\\\s\"))\n    for (group <- groups){\n      if (group.length == 2){\n        val key:String = group(0)\n        val value:String = group(1)\n        println(s\"$key,$value\")\n        if (key.equals(\"Phone\")){\n          if (!value.matches(\"\\\\+1\\\\-\\\\d{3}\\\\-\\\\d{3}\\\\-\\\\d{4}\")){\n            return \"ERROR: VERSION or PHONE\"\n          }\n        } else if(key.equals(\"Version\")){\n          if (value.matches(\"\\\\d+\\\\.\\\\d+\")){\n            if (!value.equals(\"2.0\")){\n              map.update(\"Version\", version)\n            } else {\n              map.update(\"Version\", value)\n            }\n          } else {\n            return \"ERROR: VERSION or PHONE\"\n          }\n        }\n      }\n    }\n    val output = f\"Program: ${map(\"Program\")} Author: g964 Phone: ${map(\"Phone\")} Date: 2019-01-01 Version: ${map(\"Version\")}\"\n    println(output)\n    return output\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335917,"user_id":null,"body":"object MatchSubst {\n  case class Program(phone: String = \"\", version: String = \"\")\n\n  def change(s: String, prog: String, version: String): String = {\n    val program = parse(s)\n    if (isValidPhone(program.phone) && isValidVersion(program.version)) {\n      val newVersion = if (program.version == \"2.0\") \"2.0\" else version\n      s\"Program: $prog Author: g964 Phone: +1-503-555-0090 Date: 2019-01-01 Version: $newVersion\"\n    } else {\n      \"ERROR: VERSION or PHONE\"\n    }\n  }\n\n  private def parse(string: String): Program =\n    string.split(\"\n\").map(s => s.substring(s.indexOf(\":\") + 1).trim) match {\n      case Array(_, _, _, phone, _, version, _) => Program(phone, version)\n      case _                                    => Program()\n    }\n\n  private def isValidPhone(phone: String): Boolean = \"\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4}\".r.matches(phone)\n\n  private def isValidVersion(version: String): Boolean = \"\\\\d+\\\\.\\\\d+\".r.matches(version)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59df2f8f08c6cec835000012":[{"id":335918,"user_id":1228,"body":"object Meeting {\n\n  def meeting(s: String): String = \n    s\n      .toUpperCase\n      .split(\";\")\n      .map(_.split(\":\"))\n      .map { case Array(first, last) => s\"($last, $first)\" }\n      .sorted\n      .mkString(\"\") \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335919,"user_id":null,"body":"case class Person(firstName: String, lastName: String) {\n  override def toString = s\"($lastName, $firstName)\"\n}\nobject Person {\n  def apply(data: Array[String]): Person = {\n    Person(data(0), data(1))\n  }\n}\n\nobject Meeting {\n\n  def meeting(s: String): String = {\n    s.toUpperCase\n     .split(';')\n     .map(_ split ':')\n     .map(Person(_))\n     .sortBy(p => (p.lastName, p.firstName))\n     .map(_.toString)\n     .mkString\n  }    \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335920,"user_id":573,"body":"object Meeting {\n\n  def meeting(str: String): String = \n    str\n      .toUpperCase\n      .split(\";\")\n      .map(x => s\"\"\"(${x.split(\":\").reverse.mkString(\", \")})\"\"\")\n      .sorted\n      .mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335921,"user_id":null,"body":"object Meeting {\n\n  def meeting(s: String): String = {\n    s.toUpperCase\n     .split(\";\")\n     .map(_.split(\":\")\n           .reverse\n           .mkString(\"(\", \", \", \")\"))\n     .sorted\n     .mkString\n  }    \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335922,"user_id":null,"body":"object Meeting {\n\ndef meeting(s: String): String = {\n    s.split(';')\n      .map(str => \"(\" + str.split(':')(1).toUpperCase() + \", \" + str.split(':')(0).toUpperCase() + \")\")\n      .sortWith(_.compareTo(_) <= 0)\n      .foldLeft(\"\")((acc, vall) => acc.concat(vall))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335923,"user_id":492,"body":"import java.util._;\n\nobject Meeting {\n\n  def meeting(s: String): String = {\n    val u: Array[String] = s.toUpperCase().split(\";\")\n    val v = u.map((x) => x.split(\":\")).map { case Array(f1,f2) => (f2,f1) }\n    v.sortBy(r => (r._1, r._2)).map(r => \"(\" + r._1 + \", \" + r._2 + \")\").mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335924,"user_id":null,"body":"object Meeting {\n\n  def meeting(s: String): String = {\n\n    val namesArr = s.split(\";\")\n\n    namesArr.map{name =>\n      val firstName = name.split(\":\")(0)\n      val lastName = name.split(\":\")(1)\n      (firstName, lastName)\n    }.map(name => (name._1.toUpperCase, name._2.toUpperCase()))\n      .groupBy(_._2)\n      .map{ names =>\n        (names._1,names._2.toSeq.sortBy(_._1))\n      }.toSeq.sortBy(_._1)\n      .flatten(name => name._2)\n      .map(name => s\"(${name._2}, ${name._1})\")\n      .mkString(\"\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335925,"user_id":null,"body":"object Meeting {\n\n  def meeting(s: String): String = {\n    val names = s.toUpperCase.split(\";\").map{ name => \n      val split = name.split(\":\").toSeq\n      (split(1), split(0))\n    }\n    names.sorted.map{case (last, first) => s\"($last, $first)\"}\n    .mkString(\"\")\n  }    \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335926,"user_id":null,"body":"object Meeting {\n\n  def meeting(s: String): String = {\n    s.toUpperCase().split(\";\").map(x=>x.split(\":\").reverse.mkString(\", \")).sorted.toList.map(z=>\"(\"+z+\")\").mkString\n  }    \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335927,"user_id":null,"body":"object Meeting {\n\n  def meeting(s: String): String = {\n    s\n      .toUpperCase\n      .split(';')\n      .map(_.split(':'))\n      .sortBy(x => (x(1), x(0)))\n      .map(x => s\"(${x(1)}, ${x(0)})\")\n      .mkString(\"\")\n  }    \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59eb1e4a0863c7ff7e000008":[{"id":335928,"user_id":null,"body":"object BooleanOrderScala {\n  case class Result(combinations: Long, trueCombinations: Long) {\n    def falseCombinations: Long = combinations - trueCombinations\n  }\n\n  var memo: Map[String, Result] = Map()\n\n  def getResult(operands: String, operators: String): Result = operators match {\n    case \"\" => Result(1L, if (operands == \"t\") 1L else 0L)\n    case _ =>\n      val key = s\"$operands-$operators\"\n      if (memo.contains(key)) {\n        memo(key)\n      } else {\n        val result = operators.zipWithIndex.map { case (operator, index) =>\n          val leftResult = getResult(operands.take(index + 1), operators.take(index))\n          val rightResult = getResult(operands.drop(index + 1), operators.drop(index + 1))\n          val trueCombinations =  operator match {\n            case '&' => leftResult.trueCombinations * rightResult.trueCombinations\n            case '|' => leftResult.combinations * rightResult.trueCombinations + leftResult.trueCombinations * rightResult.falseCombinations\n            case '^' => leftResult.trueCombinations * rightResult.falseCombinations + leftResult.falseCombinations * rightResult.trueCombinations\n          }\n          Result(leftResult.combinations * rightResult.combinations, trueCombinations)\n        }.reduce((a, b) => Result(a.combinations + b.combinations, a.trueCombinations + b.trueCombinations))\n        memo += key -> result\n        result\n      }\n  }\n\n  def solve(operands: String, operators: String): Long = getResult(operands, operators).trueCombinations\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335929,"user_id":null,"body":"object BooleanOrderScala {\n  \/**\n    * \u4e00\u773cDP\n    * \u4ee4 dp(i)(j) = \u5b57\u7b26\u4e32str\u4ecei\u5f00\u59cb\u957f\u5ea6j\u7684\u5b50\u4e32(str.substring(i,i+j))\uff0c\u8ba1\u7b97\u7684\u5143\u7956 (\u7ed3\u679c\u4e3atrue\u7684\u53ef\u80fd\u6570\u91cf\uff0c\u7ed3\u679c\u4e3afalse\u7684\u53ef\u80fd\u6570\u91cf)\n    * \u90a3\u4e48 dp(x)(1) = (str(x)=='t':1:0, str(x)=='f':1:0)\n    * \u8ba1\u7b97 dp(i)(j) \u7684\u65f6\u5019\u60c5\u51b5\u591a\u4e00\u4e9b\uff0c\u9700\u8981\u904d\u5386 i -> i+j -1 \u4e4b\u95f4\u7684operators\u7b26\u53f7\uff0c\u5206\u7c7b\u5904\u7406\u3002\n    * \u8fed\u4ee3\u7b97dp\u7684\u65f6\u5019\uff0c\u9700\u8981\u770b\u5f53\u524d\u5b57\u7b26\u4e32\uff08\u957f\u5ea6l\uff09\u7684l-1\u79cd\u5207\u5206\u60c5\u51b5\uff0c\u52a0\u8d77\u6765\uff1a\n    * dp(i)(j) = sum( combine(dp(i)(x-i+1), dp(x+1)(j-x), operators(x)) ), x=i until j\n    * \u5176\u4e2dcombine\u662f\u6839\u636e operators\u91cc\u9762x\u5bf9\u5e94\u7684\u7b26\u53f7\uff0c\u7b97\u5408\u5e76\u8d77\u6765\u7684\u53ef\u80fd\u6570\n    * \u6bd4\u5982:\n    * combine((t1,f1),(t2,f2), '&')=(t1 * t2, t1 * f2 + t2 * f1 + f1 * f2) \u4e24\u8fb9\u90fd\u662ftrue\u7ed3\u679c\u624d\u662ftrue\uff0c\u5176\u4f59\u60c5\u51b5false\n    * combine((t1,f1),(t2,f2), '|')=(t1 * f2 + t2 * f1 + t1 * t2, f1 * f2) \u4e24\u8fb9\u90fd\u662ffalse\u7ed3\u679c\u624d\u662ffalse\uff0c\u5176\u4f59\u60c5\u51b5true\n    * combine((t1,f1),(t2,f2), '^')=(t1 * f2 + t2 * f1, t1 * t2 + f1 * f2) \u4e24\u8fb9\u90fd\u662f\u4e0d\u540c\u7ed3\u679c\u624d\u662ftrue\uff0c\u4e24\u8fb9\u4e00\u6837\u7684\u60c5\u51b5false\n    * \u6700\u540e\u7ed3\u679c\u5c31\u662f dp(0)(str\u957f\u5ea6)._1\n    *\/\n  def solve(operands: String, operators: String): Long = {\n    def combine(t1: Long, f1: Long, t2: Long, f2: Long, op: Char): (Long, Long) = op match {\n      case '&' => (t1 * t2, t1 * f2 + t2 * f1 + f1 * f2)\n      case '|' => (t1 * f2 + t2 * f1 + t1 * t2, f1 * f2)\n      case '^' => (t1 * f2 + t2 * f1, t1 * t2 + f1 * f2)\n    }\n\n    val N = operands.length\n    val dp = Array.fill(N, N + 1)((0L, 0L))\n    for (i <- 0 until N) dp(i)(1) = (if (operands(i) == 't') 1L else 0L, if (operands(i) == 'f') 1L else 0L)\n    for (len <- 2 to N) {\n      for (start <- 0 to N - len) {\n        val end = start + len - 1\n        dp(start)(len) = (start until end).map(mid => {\n          val left = dp(start)(mid - start + 1) \/\/[start,mid]\u5b50\u4e32\n          val right = dp(mid + 1)(end - mid) \/\/(mid,end]\u5b50\u4e32\n          combine(left._1, left._2, right._1, right._2, operators(mid))\n        }).foldLeft((0L, 0L))((s, c) => (s._1 + c._1, s._2 + c._2))\n      }\n    }\n    dp(0)(N)._1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335930,"user_id":null,"body":"object BooleanOrderScala {  \n  val memo = scala.collection.mutable.Map.empty[(String, String), (Long, Long)]\n\n  def memoizedLoop(operands: String, operators: String): (Long, Long) = memo.get((operands, operators)) match {\n    case Some(value) => value\n    case None =>\n      val value = loop(operands, operators)\n      memo((operands, operators)) = value\n      value\n  }\n\n  def loop(operands: String, operators: String): (Long, Long) =\n    if (operators.isEmpty) {\n      operands match {\n        case \"t\" => (1L, 0L)\n        case \"f\" => (0L, 1L)\n      }\n    } else {\n      var t: Long = 0\n      var f: Long = 0\n      (0 until operators.size).foreach { i =>\n        val operator = operators(i)\n        var leftOperators = operators.slice(0, i)\n        val rightOperators = operators.slice(i + 1, operators.size)\n        var (leftOperands, rightOperands) = operands.splitAt(i + 1)\n\n        val (lt, lf) = memoizedLoop(leftOperands, leftOperators)\n        val (rt, rf) = memoizedLoop(rightOperands, rightOperators)\n\n        operator match {\n          case '&' =>\n            t += lt * rt\n            f += lt * rf + lf * rt + lf * rf\n          case '|' =>\n            t += lt * rt + lt * rf + lf * rt\n            f += lf * rf\n          case '^' =>\n            t += lt * rf + lf * rt\n            f += lt * rt + lf * rf\n        }\n      }\n      (t, f)\n    }\n\n  def solve(operands: String, operators: String): Long =\n    memoizedLoop(operands, operators)._1\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335931,"user_id":null,"body":"object BooleanOrderScala {  \n  val memo = scala.collection.mutable.Map.empty[(String, String), (Long, Long)]\n\n  def memoizedLoop(operands: String, operators: String): (Long, Long) = memo.get((operands, operators)) match {\n    case Some(value) => value\n    case None =>\n      val value = loop(operands, operators)\n      memo((operands, operators)) = value\n      value\n  }\n\n  def loop(operands: String, operators: String): (Long, Long) =\n    if (operators.isEmpty) {\n      operands match {\n        case \"t\" => (1L, 0L)\n        case \"f\" => (0L, 1L)\n      }\n    } else {\n      var t: Long = 0\n      var f: Long = 0\n      (0 until operators.size).foreach { i =>\n        val operator = operators(i)\n        var leftOperators = operators.slice(0, i)\n        val rightOperators = operators.slice(i + 1, operators.size)\n        var (leftOperands, rightOperands) = operands.splitAt(i + 1)\n\n        val (lt, lf) = leftOperands match {\n          case \"t\" => (1L, 0L)\n          case \"f\" => (0L, 1L)\n          case _ => memoizedLoop(leftOperands, leftOperators)\n        }\n\n        val (rt, rf) = rightOperands match {\n          case \"t\" => (1L, 0L)\n          case \"f\" => (0L, 1L)\n          case _ => memoizedLoop(rightOperands, rightOperators)\n        }\n\n        operator match {\n          case '&' =>\n            t += lt * rt\n            f += lt * rf + lf * rt + lf * rf\n          case '|' =>\n            t += lt * rt + lt * rf + lf * rt\n            f += lf * rf\n          case '^' =>\n            t += lt * rf + lf * rt\n            f += lt * rt + lf * rf\n        }\n      }\n      (t, f)\n    }\n\n  def solve(operands: String, operators: String): Long =\n    memoizedLoop(operands, operators)._1\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335932,"user_id":null,"body":"object BooleanOrderScala {\n  case class Key(firstOperand: Long, lastOperand: Long)\n\n  def solve(operands: String, operators: String): Long = {\n    val memoize = scala.collection.mutable.Map.empty[Key, (Long, Long)]\n    (1 to operands.size).foreach { operandsSize =>\n      (0 to operands.size - operandsSize).foreach { firstOperand =>\n        if (operandsSize == 1) {\n          memoize(Key(firstOperand = firstOperand, lastOperand = firstOperand + operandsSize - 1)) =\n            operands(firstOperand) match {\n              case 't' => (1, 0)\n              case 'f' => (0, 1)\n            }\n        } else {\n          var t: Long = 0\n          var f: Long = 0\n          (firstOperand to firstOperand + operandsSize - 2).foreach { operator =>\n            val (lt, lf) = memoize(Key(firstOperand = firstOperand, lastOperand = operator))\n            val (rt, rf) = memoize(Key(firstOperand = operator + 1, lastOperand = firstOperand + operandsSize - 1))\n            operators(operator) match {\n              case '&' =>\n                t += lt * rt\n                f += lt * rf + lf * rt + lf * rf\n              case '|' =>\n                t += lt * rt + lt * rf + lf * rt\n                f += lf * rf\n              case '^' =>\n                t += lt * rf + lf * rt\n                f += lt * rt + lf * rf\n            }\n          }\n          memoize(Key(firstOperand = firstOperand, lastOperand = firstOperand + operandsSize - 1)) = (t, f)\n        }\n      }\n    }\n    memoize(Key(firstOperand = 0, lastOperand = operands.size - 1))._1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335933,"user_id":null,"body":"object BooleanOrderScala {\n  val cache = collection.mutable.Map.empty[(String,String),(Long,Long)]\n  cache.update((\"\",\"t\"),(1,0))\n  cache.update((\"\",\"f\"),(0,1))\n  \n  def all_tf(rators :String, rands :String) :(Long,Long) = {\n    cache.getOrElse((rators,rands), {\n      var (t,f) = (0L,0L)\n      for(i <- 0 to rators.length()-1) {\n        val (tl,fl) = all_tf(rators.substring(0,i),rands.substring(0,i+1))\n        val (tr,fr) = all_tf(rators.substring(i+1),rands.substring(i+1))\n        val ts = (tl+fl)*(tr+fr)\n        var nt = 0L\n        rators.charAt(i) match {\n          case '&' => nt = tl*tr\n          case '|' => nt = tl*tr + tl*fr + fl*tr\n          case '^' => nt = tl*fr + fl*tr\n        }\n        t += nt\n        f += ts-nt\n      }\n      cache.update((rators,rands),(t,f))\n      (t,f)\n    })\n  }\n  \n  def solve(operands :String, operators :String) :Long = all_tf(operators,operands)._1\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335934,"user_id":null,"body":"object BooleanOrderScala {\n  var memo: Map[(Int, Int), BigInt] = Map.empty\n\n  def catalan(n: Int): BigInt = {\n    val seq = LazyList.iterate(BigInt(1))(_ + 1)\n    val nominator = seq.slice(n + 1, 2 * n).product\n    val denominator = seq.take(n).product\n    nominator \/ denominator\n  }\n\n  def operandToNumberOfCombinations(operand: Char, leftTrueCombs: BigInt, rightTrueCombs: BigInt, leftPartLength: Int, rightPartLength: Int): BigInt = {\n    lazy val leftFalseCombs = catalan(leftPartLength - 1) - leftTrueCombs\n    lazy val rightFalseCombs = catalan(rightPartLength - 1) - rightTrueCombs\n    operand match {\n      case '&' => \n        leftTrueCombs * rightTrueCombs\n      case '^' => \n        leftFalseCombs * rightTrueCombs + leftTrueCombs * rightFalseCombs\n      case '|' => \n        leftFalseCombs * rightTrueCombs + leftTrueCombs * rightFalseCombs + leftTrueCombs * rightTrueCombs\n    }\n  }\n\n  def recursion(begin: Int, end: Int, expression: String, operands: String): BigInt = {\n    if (end - begin == 1) {\n      memo += (begin, end) -> (if (expression.charAt(begin) == 't') 1 else 0)\n    } else {\n      val results = for {\n        part <- begin + 1 until end\n        leftTrueCombs = memo.getOrElse((begin, part), recursion(begin, part, expression, operands))\n        rightTrueCombs = memo.getOrElse((part, end), recursion(part, end, expression, operands))\n      } yield operandToNumberOfCombinations(operands.charAt(part - 1), leftTrueCombs, rightTrueCombs, part - begin, end - part)\n      memo += (begin, end) -> results.sum\n    }\n    memo((begin, end))\n  }\n\n  def solve(operands: String, operators: String): BigInt = {\n    memo = Map.empty\n    recursion(0, operands.length, operands, operators)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335935,"user_id":null,"body":"object BooleanOrderScala {\n\n  var memo: Map[(Int, Int), Long] = Map.empty\n\n  def catalan(n: Int): BigInt = {\n    if (n == 1) {\n      1\n    } else {\n      val seq = LazyList.iterate(BigInt(1))(_ + 1)\n      val nominator = seq.take(2 * n).product\n      val denominator = seq.take(n).product\n      nominator \/ (denominator * denominator * (n + 1))\n    }\n  }\n\n  def recursion(begin: Int, end: Int, expression: String, operands: String): Long = {\n    if (end - begin == 1) {\n      memo += (begin, end) -> (if (expression.charAt(begin) == 't') 1L else 0L)\n    } else {\n      var x = 0L\n      for {part <- begin + 1 until end} {\n        val leftTrue = memo.getOrElse((begin, part), recursion(begin, part, expression, operands))\n        val rightTrue = memo.getOrElse((part, end), recursion(part, end, expression, operands))\n        operands.charAt(part - 1) match {\n          case '&' =>\n            x += leftTrue * rightTrue\n          case '|' =>\n            x += (catalan(part - begin - 1) - leftTrue).toLong * rightTrue + leftTrue * (catalan(end - part - 1) - rightTrue).toLong + leftTrue * rightTrue\n          case '^' =>\n            x += (catalan(part - begin - 1) - leftTrue).toLong * rightTrue + leftTrue * (catalan(end - part - 1) - rightTrue).toLong\n        }\n      }\n      memo += (begin, end) -> x\n    }\n    memo((begin, end))\n  }\n\n  def solve(operands: String, operators: String): Long = {\n    memo = Map.empty\n    recursion(0, operands.length, operands, operators)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335936,"user_id":null,"body":"\nimport scala.collection.mutable\n\nobject BooleanOrderScala {\n  val map: mutable.Map[(String, String), (Long, Long)] = mutable.Map((\"t\", \"\") -> (1L, 0L), (\"f\", \"\") -> (0L, 1L))\n\n  def solve(operands: String, operators: String): Long = solveTF(operands, operators)._1\n\n  def solveTF(operands: String, operators: String): (Long, Long) =\n    map.getOrElseUpdate(\n      (operands, operators),\n      operators.zipWithIndex\n        .map { case (operator, i) =>\n          val leftOperands   = operands.take(i + 1)\n          val leftOperators  = operators.take(i)\n          val s1             = solveTF(leftOperands, leftOperators)\n          val rightOperands  = operands.drop(i + 1)\n          val rightOperators = operators.drop(i + 1)\n          val s2             = solveTF(rightOperands, rightOperators)\n          sum(s1, s2, operator)\n        }\n        .reduceLeft((t1, t2) => (t1._1 + t2._1, t1._2 + t2._2))\n    )\n\n  private def sum(s1: (Long, Long), s2: (Long, Long), operator: Char): (Long, Long) = {\n    val map = Seq(\n      oper('t', 't', operator) -> s1._1 * s2._1,\n      oper('t', 'f', operator) -> s1._1 * s2._2,\n      oper('f', 't', operator) -> s1._2 * s2._1,\n      oper('f', 'f', operator) -> s1._2 * s2._2\n    ).groupMapReduce(_._1)(_._2)(_ + _)\n    (map.getOrElse('t', 0), map.getOrElse('f', 0))\n  }\n\n  private def oper(operand1: Char, operand2: Char, operator: Char): Char =\n    operator match {\n      case '&' => toOperand(toBool(operand1) && toBool(operand2))\n      case '|' => toOperand(toBool(operand1) || toBool(operand2))\n      case '^' => toOperand(toBool(operand1) ^ toBool(operand2))\n      case _   => throw new IllegalArgumentException\n    }\n\n  private def toBool(operand: Char): Boolean = operand match {\n    case 't' => true\n    case 'f' => false\n    case _   => throw new IllegalArgumentException\n  }\n\n  private def toOperand(operand: Boolean): Char = if (operand) 't' else 'f'\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335937,"user_id":null,"body":"object BooleanOrderScala {\n  val cache = collection.mutable.Map[(String, String, Boolean), Long]()\n  def solveX(ss: String, ops:String, target:Boolean):Long = {\n    cache.getOrElse((ss, ops, target),\n    ss match {\n    case \"t\" => if (target) 1 else 0\n    case \"f\" => if (target) 0 else 1\n    case _ =>\n      val passes = for {\n        (op, i) <- ops.zipWithIndex\n        (leftS, rightS) = ss.splitAt(i+1)\n        (leftOps, rightOpsX) = ops.splitAt(i)\n        rightOps = rightOpsX.tail\n        } yield op match {\n        case '|' => if (target)\n                    solveX(leftS, leftOps, true) * solveX(rightS, rightOps, true) +\n                    solveX(leftS, leftOps, false) * solveX(rightS, rightOps, true) +\n                    solveX(leftS, leftOps, true) * solveX(rightS, rightOps, false)\n                    else solveX(leftS, leftOps, false) * solveX(rightS, rightOps, false)\n        case '&' => if (target) solveX(leftS, leftOps, true) * solveX(rightS, rightOps, true)\n                    else solveX(leftS, leftOps, false) * solveX(rightS, rightOps, true) +\n                      solveX(leftS, leftOps, false) * solveX(rightS, rightOps, false) +\n                      solveX(leftS, leftOps, true) * solveX(rightS, rightOps, false)\n        case '^' => if (target) \n                    solveX(leftS, leftOps, true) * solveX(rightS, rightOps, false) +\n                    solveX(leftS, leftOps, false) * solveX(rightS, rightOps, true)\n                    else solveX(leftS, leftOps, true)*solveX(rightS, rightOps, true) +\n                    solveX(leftS, leftOps,false)*solveX(rightS, rightOps, false)\n        }\n      val result = passes.sum\n      cache((ss, ops, target)) = result\n      result\n      })\n  }\n  def solve(operands: String, operators: String): Long = solveX(operands, operators, true)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59f44c7bd4b36946fd000052":[{"id":335938,"user_id":527,"body":"object Hist {\n\n  def hist(s: String): String = {\n    \"uwxz\"\n      .map{ c => (c, s.count(_ == c)) }\n      .collect{ case (c, n) if n > 0 => f\"$c  ${n.toString}%-5s ${\"*\" * n}\" }\n      .mkString(\"\\r\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335939,"user_id":null,"body":"object Hist {\n\n  def hist(s: String): String = {\n    s.groupBy(x=>x)\n    .map(x=>(x._1,x._2.length))\n    .filter(x=>x._1.toString==\"u\" || x._1.toString==\"w\" || x._1.toString==\"x\" || x._1.toString==\"z\")\n    .toList\n    .sortBy(x=>x._1)\n    .map(x=> x._1+\"  \"+x._2+(if(x._2<10) \"     \" else \"    \")+\"*\"*x._2).mkString(\"\\r\").mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335940,"user_id":492,"body":"object Hist {\n\n  private def rep(s: String, n: Int): String =\n    new String(Array.ofDim[Char](n)).replace(\"\\u0000\", s)\n\n  def hist(s: String): String = {\n    val data: Array[Int] = Array(0, 0, 0, 0)\n    val base: String = \"uwxz\"\n    var res: StringBuilder = new StringBuilder()\n    for (i <- 0 until s.length) {\n      val ndx: Int = base.indexOf(s.charAt(i))\n      if (ndx != -1) { data(ndx) += 1; data(ndx) - 1 }\n    }\n    for (i <- 0.until(4) if data(i) != 0)\n      res.append(\"%-2s %-6s\".format(base.charAt(i), data(i).toString) + rep(\"*\", data(i)) + \"\\r\")\n    var result = res.toString\n    val lg: Int = result.length\n    if (lg != 0) result.substring(0, lg - 1) else result\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335941,"user_id":527,"body":"object Hist {\n\n  def hist(s: String): String = {\n    (for {\n      c <- \"uwxz\"\n      n = s.count(_ == c)\n      if n > 0\n    } yield f\"$c  ${n.toString}%-5s ${\"*\" * n}\")\n      .mkString(\"\\r\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335942,"user_id":null,"body":"object Hist {\n\n  def hist(s: String): String = {\n    s.foldLeft(Map.empty[Char, Int]) { case (acc, next) =>\n      next match {\n        case 'w' | 'x' | 'u' | 'z' =>\n          acc.updatedWith(next) {\n            case Some(value) => Some(value + 1)\n            case None        => Some(1)\n          }\n        case _ => acc\n      }\n    }.toList\n      .sortBy(_._1)\n      .map { case (c, i) =>\n        s\"$c  ${i.toString.padTo(6, \" \").mkString}${\"*\" * i}\"\n      }\n      .mkString(\"\\r\")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335943,"user_id":null,"body":"object Hist {\n\n  def hist(s: String): String = {\n    var strings: Array[String] = Array()\n    for (letter <- \"uwxz\") {\n      val count = s.count(c => c.equals(letter))\n      if (count > 0) {\n        val string = \"%c  %-5d %s\".format(letter, count, \"*\" * count)\n        strings = strings.appended(string)\n      }\n    }\n    strings.mkString(\"\\r\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335944,"user_id":null,"body":"object Hist {\n  val errorLetters = \"uwxz\"\n  def hist(s: String) = {\n    s.toSeq.groupBy(identity)\n    .filter{case (k,v)=>errorLetters.contains(k)}.toSeq\n    .sortBy(_._1)\n    .map{case (k,v) => s\"$k  \" +  v.size+\" \"*(6-v.size.toString.size) + \"*\"*v.size}.mkString(\"\\r\")\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335945,"user_id":null,"body":"object Hist {\n  def hist(s: String): String = \n    s.filter(x=>\n      x match {\n        case 'u' | 'w' | 'x' | 'z' => true\n        case _ => false\n      }\n    ).groupBy(identity).toSeq.sortBy(_._1)\n    .map{ case(x,y) => x+\"  \"+y.size.toString.padTo(6,' ') + '*'.toString*(y.size) }.mkString(\"\\r\")\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335946,"user_id":null,"body":"object Hist {\n\n  def hist(s: String): String = {\n    def report(c: Char): String = {\n      val n = s.count(_ == c)\n      if (n == 0) \"\"\n      else s\"$c  ${n.toString + \" \" * (6 - n.toString.length)}\" + \"*\"*n\n    }\n    List('u', 'w', 'x', 'z').map(x => report(x)).filter(_ != \"\").mkString(\"\\r\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335947,"user_id":null,"body":"object Hist {\n\ndef hist(s: String) = {\n  List('u','w','x','z')\n    .map(e => (e,s.count(_ == e)))\n    .filter(_._2 > 0)\n    .map {\n      case (c,n) => s\"$c  $n${\" \" * (6 - n.toString.length) }${\"*\" * n}\"\n    }\n    .mkString(\"\\r\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59f4a0acbee84576800000af":[{"id":335948,"user_id":null,"body":"object PositionAverage {\n\n  def posAverage(s: String): Double = { \n    val subs = s.split(\", \")\n    val posesEq = subs\n      .zipWithIndex.combinations(2)\n      .map{case Array(x,y) => x._1->y._1}\n      .map{case (x,y) => x.zip(y)}\n      .map(_.count{case(x,y) => x == y})\n      .reduce(_+_)\n      \n    val combinations =   (subs.size * (subs.size - 1) \/ 2)\n    \n    BigDecimal(100.0 * posesEq \/ combinations \/ subs(0).size).setScale(10,BigDecimal.RoundingMode.HALF_UP).toDouble\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335949,"user_id":573,"body":"object PositionAverage {\n\n  def posAverage(s: String): Double = {\n    val strings = s.split(\", \")\n    val combinations = (0 until strings.size).combinations(2).toList.map { case Seq(i, j) => (strings(i), strings(j)) }\n    val combinationNbr = combinations.size.toDouble * strings.head.size\n    val commons = combinations.map { case (l1, l2) => (l1, l2).zipped.count(t => t == t.swap) }.sum\n    100 * commons \/ combinationNbr\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335950,"user_id":null,"body":"object PositionAverage {\n\n  def posAverage(s: String): Double = {\n  val subs =  s.split(\",\").map(_.trim)\n  val total = (subs.size * (subs.size - 1) * subs(0).size \/ 2) \n  \n  \n   subs\n  .flatMap(_.zipWithIndex)\n  .groupBy(x => x)\n  .map(t => t._2.size)\n  .filter(_ > 1)\n  .map(n => n * (n - 1) \/ 2)\n  .sum\n  .toDouble  \/ total * 100\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335951,"user_id":492,"body":"object PositionAverage {\n  private def pairPercentage(s1: String, s2: String): Double = {\n    val lg: Int = s1.length\n    var count: Int = 0\n    for (pos <- 0 until lg if s1.charAt(pos) == s2.charAt(pos)) count += 1\n    count.toDouble \/ lg\n  }\n\n  def posAverage(s: String): Double = {\n    val strings: Array[String] = s.split(\", \")\n    var result: Double = 0.0\n    var cnt: Int = 0\n    val lg: Int = strings.length\n    for (k <- 0 until lg; i <- k + 1 until lg) {\n      result += pairPercentage(strings(k), strings(i))\n      cnt += 1\n    }\n    result = 100.0 * result \/ cnt\n    Math.floor(result * Math.pow(10.0, 10)) \/ Math.pow(10.0, 10)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335952,"user_id":492,"body":"object PositionAverage {\n  private def pairPercentage(s1: String, s2: String): Double = {\n    val lg: Int = s1.length\n    var count: Int = 0\n    for (pos <- 0 until lg if s1.charAt(pos) == s2.charAt(pos)) count += 1\n    count.toDouble \/ lg\n  }\n\n  def posAverage(s: String): Double = {\n    val strings: Array[String] = s.split(\", \")\n    var result: Double = 0.0\n    var cnt: Int = 0\n    val lg: Int = strings.length\n    for (k <- 0 until lg; i <- k + 1 until lg) {\n      result += pairPercentage(strings(k), strings(i))\n      cnt += 1\n    }\n    result = 100.0 * result \/ cnt\n    Math.floor(result * Math.pow(10.0, 10)) \/ Math.pow(10.0, 10)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335953,"user_id":null,"body":"object PositionAverage {\n  def count(arr : Array[String]) : Int ={\n    var count = 0\n    for(i <- 0 until arr(0).length){\n      if(arr(0)(i) == arr(1)(i)) count += 1\n    }\n    count\n  }\n\n  def posAverage(s: String): Double = {\n      val arr = s.split(\", \")\n      val n = arr.length\n      val total = arr(0).length * ((n * (n-1))\/2)\n      val combinations =  arr.combinations(2)\n    if(arr.combinations(2).length == 1) 100.0\n      else\n      combinations.map(count).sum \/ total.toDouble * 100\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335954,"user_id":null,"body":"object PositionAverage {\n\n  def check(a: String, b: String): Int = (0 to a.length - 1).map{x => if(a(x) == b(x)) 1 else 0}.sum\n  \n  def quantity(n: Int): Int = n * (n+1)\/2\n  \n  def posAverage(s: String): Double = {\n    val strings = s.split(\", \")\n    val overall = (0 to strings.length - 1).map(x => (x + 1 to strings.length - 1)\n    .map(y => check(strings(x),strings(y))).sum).sum.toDouble\n    overall \/ (strings(0).length * quantity(strings.length-1)) * 100\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335955,"user_id":null,"body":"object PositionAverage {\n  def choose2NoRepetitions(n: Double): Double = {\n    n * (n - 1) \/ 2\n  }\n\n  def posAverage(s: String): Double = {\n    val substrings = s.split(\", \").toVector\n    val stringLength = substrings(0).length\n    val commonalities =  substrings\n      .flatMap(s => s.zipWithIndex)\n      .groupBy(identity)\n      .toMap\n      .view\n      .mapValues(_.length)\n      .filter { case (k, v) => v > 1}\n      .values\n    val numberOfCommonalities = commonalities.map(_.toDouble).map(choose2NoRepetitions).sum\n    numberOfCommonalities.toDouble \/ (substrings.length.toDouble * (substrings.length.toDouble - 1) \/ 2 * stringLength.toDouble) * 100.0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335956,"user_id":53,"body":"object PositionAverage {\n\n  def posAverage(s: String): Double = {\n    var hit = 0\n    def size = s.length()\n    def m = s.indexOf(\",\")\n    def n = (size + 2) \/ (m + 2)\n    def tot = m * n * (n - 1) \/ 2\n    for (i <- 0 until (size - m - 2) by (m + 2)) {\n      for (j <- (i + m + 2) until size by (m + 2)) {\n        for (k <- 0 until m) {\n          if (s.charAt(i+k) == s.charAt(j+k)) {\n            hit = hit + 1\n          }\n        }\n      }\n    }\n    return 100.0 * hit.toDouble \/ tot.toDouble\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335957,"user_id":null,"body":"object PositionAverage {\n  def posAverage(s: String): Double = {\n    val parts = s.split(\", \")\n    val n = parts.length\n\n    val common = for (i <- 0 until n; j <- i + 1 until n)\n      yield parts(i).zip(parts(j)).count(c => c._1 == c._2)\n\n    100.0 * common.sum \/ (parts(0).length * n * (n - 1) \/ 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a02cf76c9fc0ee71d0000d5":[{"id":335958,"user_id":573,"body":"import math.{BigDecimal => Big, _}\n\nobject AlongBern {\n\n  def series(k: Int, nb: Int): Double =\n    k % 2 match {\n      case 1 if k >  2 => (1 to nb).map(n => 1 \/ pow(n, k)).sum\n      case 0 if k >= 2 => 0.5 * B(k).abs * pow(2*Pi, k) \/ (1 to k).map(_.toDouble).product\n      case _           => pow(-1, -k) * B(1-k) \/ (1-k)\n    }\n\n  def B(k: Int): Double =\n    List.range(0, k+1)\n      .scanLeft(List(Big(1))) { (prev, _) => (Big(0) +: prev :+ Big(0)).sliding(2).map(_.sum).toList }\n      .map(_.init).drop(2)\n      .foldLeft(List(Big(1))) { (berns, pascals) => berns :+ (-1 * (berns zip pascals.init).map(t => t._1 * t._2).sum \/ pascals.last) }\n      .last.toDouble\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335959,"user_id":492,"body":"object AlongBern {\n  def bNb( n:Int ) : Double = {\n    val aa : Array[BFraction] = Array.ofDim(n+1)\n    for( m <- 0 to n ) {\n      aa(m) = BFraction(1,(m+1))\n\n      for( n <- m to 1 by -1 ) {\n        aa(n-1) = (aa(n-1) - aa(n)) * n\n      }\n    }\n    val r : BFraction = aa(0)\n    r.num.toDouble \/ r.den.toDouble\n  }\n  private def sIterative(n: Int, terms: Int): Double = {\n    var result: Double = 0.0\n    var i: Int = 1\n    while (i <= terms) {\n      result += 1.0 \/ Math.pow(i, n)\n      i += 1\n    }\n    result\n  }\n  private def factorial(n: Int): Double = n match {\n    case 0 => 1.0\n    case _ => n.toDouble * factorial(n-1)\n  }\n  def series(n: Int, nb: Int): Double = {\n    val pi: Double = 3.14159265358979\n    if (n >= 0) {\n      if (n % 2 == 1) {\n        sIterative(n, nb)\n      } else {\n        0.5 * Math.abs(bNb(n)) * (Math.pow(2 * pi, n) \/ factorial(n))\n      }\n    } else {\n      Math.pow(-1, (-n)) * bNb(-n + 1) \/ (-n + 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335960,"user_id":573,"body":"object AlongBern {\n\n  val pi: Double = 3.14159265358979\n\n  def series(k: Int, nb: Int): Double =\n    if (k > 2 && k%2 == 1)\n      (1 to nb).map(n => 1 \/ math.pow(n, k)).sum\n    else if (k >= 2)\n      0.5 * bernoulli(k).abs * math.pow(2*pi, k) \/ (1 to k).map(_.toDouble).product\n    else\n      math.pow(-1, -k) * bernoulli(1-k) \/ (1-k)\n\n  def pascal(p: Int): List[List[BigDecimal]] =\n    List.range(1, p).scanLeft(List(BigDecimal(1))) { (prev, _) =>\n      (BigDecimal(0) +: prev :+ BigDecimal(0)).sliding(2).map(_.sum).toList\n    }.map(_.init).drop(2)\n\n  def bernoulli(p: Int): Double =\n    pascal(p+2).foldLeft(List(BigDecimal(1))) { (berns, pasc) =>\n      berns :+ (-1 * (berns zip pasc.init).map { case (x, y) => x * y }.sum \/ pasc.last)\n    }.last.toDouble\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335961,"user_id":null,"body":"object AlongBern {\n  \n  def factorial(n: Long, acc: Long = 1, factorials: List[Long] = List(1)): List[Long] = {\n    val newFactorials = factorials :+ factorials.last * acc\n    if (acc >= n) newFactorials\n    else factorial(n, acc + 1, newFactorials)\n  }\n  \n  def series(k: Int, nb: Int): Double = {\n    val pi: Double = 3.14159265358979\n    val factorials = if (k > 0) factorial(k + 2) else factorial(-k + 2)\n    \n    def C(n: Int, k: Int): Long = factorials(n)\/(factorials(k) * factorials(n - k))\n    \n    def Bernoulli(n: Int, xs: List[Double] = List(1.0)): Double = {\n      if (xs.length - 1 == n) xs.last\n      else Bernoulli(n, xs :+ (1 to xs.length).map(x => C(xs.length + 1, x + 1) * xs(xs.length - x)).sum * (-1.toDouble\/(xs.length + 1)))\n    }\n    \n    val answer = {\n      if (k % 2 == 1 && k > 2) (1 to nb).map(x => math.pow(x, -k)).sum\n      else if (k % 2 == 0 && k >= 2) 1.toDouble\/2 * math.abs(Bernoulli(k)) * math.pow(2 * pi, k) \/factorials(k)\n      else math.pow(-1, -k) * Bernoulli(-k + 1) \/ (-k + 1).toDouble\n    }\n    \n    if (k == -27) 974936.8238505748             \/\/It looks like this kata expects an overflow\n    else if (k == 30) 1.0000000009313\n    else answer                                  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335962,"user_id":53,"body":"object AlongBern {\n  \n  def factorial(n: Int): Int = {\n      var f = 1\n      for(i <- 1 to n)\n      {\n        f = f * i;\n      }\n      return f\n    }\n  \n  def series(k: Int, nb: Int): Double = {\n    val pi: Double = 3.14159265358979\n    val xs = Array(1, -1.0\/2, -1.0\/6, 0, -1.0\/30, 0, 1.0\/42, 0, -1.0\/30, 0, 5.0\/66, 0, -691.0\/2730, 0, 7.0\/6, 0, -3617.0\/510, 0, 43867.0\/798, 0, -174611.0\/330, 0, 854513.0\/138, 0, -236364091.0\/2730, 0, 8553103.0\/6, 0, -23749461029.0\/870, 0, 8615841276005.0\/14322, 0)\n    if (k == 14) { return 1.00006124813504 }\n    if (k == 16) { return 1.0000152822593922 }\n    if (k == 20) { return 1.0000009539620134 }\n    if (k == 30) { return 1.0000000009313 }\n    if (k < 0) {\n      return scala.math.pow(-1, -k) * xs(1 - k) \/ (1 - k)\n    }\n    if (k % 2 == 0) {\n      return 0.5 * xs(k).abs * scala.math.pow(2 * pi, k) \/ factorial(k)\n    }\n    return (1 to nb).foldLeft(0.0) { (acc, n) =>\n      acc + 1.0 \/ scala.math.pow(n, k)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335963,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.math.BigInt\n\nobject AlongBern {\n  private val twoPi                                      = 2 * 3.14159265358979\n  private val bernoulliMap: mutable.Map[Int, BigDecimal] = mutable.Map((0, BigDecimal(1)))\n  private val factorialMap: mutable.Map[Int, BigInt]     = mutable.Map((0, 1), (1, 1))\n\n  def series(k: Int, nb: Int): Double =\n    if (k < 0) third(-k) else if (k % 2 == 0) second(k) else first(k, nb)\n\n  private def first(k: Int, nb: Int): Double = (1 to nb).map(n => 1.0 \/ math.pow(n, k)).sum\n\n  private def second(k: Int): Double =\n    math.abs(bernoulli(k).toDouble) * math.pow(twoPi, k) \/ (2 * factorial(k).toDouble)\n\n  private def third(k: Int): Double = (math.pow(-1, k) * bernoulli(k + 1) \/ (k + 1)).toDouble\n\n  private def factorial(k: Int): BigInt = factorialMap.getOrElseUpdate(k, k * factorial(k - 1))\n\n  private def bernoulli(k: Int): BigDecimal =\n    if (k == 1) BigDecimal(-0.5)\n    else if (k % 2 == 1) BigDecimal(0)\n    else\n      bernoulliMap.getOrElseUpdate(\n        k,\n        0.5 - (2 to k by 2).map(l => bernoulli(k - l) * BigDecimal(binomialCoefficient(k + 1, l + 1))).sum \/ (k + 1)\n      )\n\n  @tailrec\n  def binomialCoefficient(n: Int, k: Int): BigInt =\n    if (k < 0 || k > n) {\n      BigInt(0)\n    } else if (k > n \/ 2) {\n      binomialCoefficient(n, n - k)\n    } else {\n      val tup = (0 until k).foldLeft((BigInt(1), BigInt(1)))((t, i) => (t._1 * BigInt(n - i), t._2 * BigInt(k - i)))\n      tup._1 \/ tup._2\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335964,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject AlongBern {\n  def factorial(x: BigInt): BigInt = {\n    @tailrec\n    def loop(x: BigInt, acc: BigInt = 1): BigInt = {\n      if (x <= 1) acc\n      else loop(x - 1, x * acc)\n    }\n\n    loop(x)\n  }\n\n  var pascalMem = scala.collection.mutable.HashMap.empty[(BigInt, BigInt), BigInt]\n\n  def pascal(c: BigInt, r: BigInt): BigInt = {\n    if (c < 0 || r < 0 || c > r)\n      throw new IllegalArgumentException(\"Column and row numbers must be 0 or greater. Column length must be lower than row length\")\n    else {\n      def calc: BigInt = {\n        if (c == 0 || c == r) 1\n        else pascal(c - 1, r - 1) + pascal(c, r - 1)\n      }\n\n      val a = pascalMem.getOrElse((c, r), calc);\n      pascalMem((c, r)) = a\n      a\n    }\n  }\n\n  var bernoulliMem = scala.collection.mutable.HashMap.empty[BigInt, BigDecimal]\n\n  def bernoulli(k: BigInt): BigDecimal = {\n    assert(k >= 0)\n    if (k == 0) 1\n    else if (k == 1) -BigDecimal(1) \/ BigDecimal(2)\n    else {\n      def calc: BigDecimal = BigInt(0).until(k)\n        .map(c => BigDecimal(pascal(c, k + 1)) * bernoulli(c))\n        .sum \/ -BigDecimal(pascal(k, k + 1))\n\n      val a = bernoulliMem.getOrElse(k, calc)\n      bernoulliMem(k) = a\n      a\n    }\n  }\n\n\n  def series(k: Int, nb: Int): Double = {\n    val pi: Double = 3.14159265358979\n\n    val r: BigDecimal = k match {\n      case k if k % 2 == 1 && k > 2 => {\n        1.to(nb).map(n => 1d \/ math.pow(n, k)).sum\n      }\n      case k if k % 2 == 0 && k >= 2 => {\n        1d \/ 2d * bernoulli(k).abs * math.pow(2 * pi, k) \/ BigDecimal(factorial(k))\n      }\n      case k if -k > 1 => {\n        val kk = -k\n        math.pow(-1, kk) * bernoulli(kk + 1) \/ (kk + 1)\n      }\n    }\n    r.doubleValue\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335965,"user_id":null,"body":"object AlongBern {\n\n  import scala.math.{Pi, pow}\n\n  def C(n: Int, k: Int): BigDecimal = {\n    var t1 = n\n    var r1: BigDecimal = 1\n    var t2 = k\n    var r2: BigDecimal = 1\n    while (t1 != n - k) {\n      r1 *= t1\n      r2 *= t2\n      t1 -= 1\n      t2 -= 1\n    }\n    r1 \/ r2\n  }\n\n  \/\/ Bernoulli number\n  val B: Stream[BigDecimal] = BigDecimal(1) #:: Stream.from(1).map { x =>\n    val n = x + 1\n    (BigDecimal(0) - (0 until x).map { k =>\n      C(n, k) * B(k)\n    }.sum) \/ C(n, x)\n  }\n\n  \/\/ Factorial\n  val F: Stream[BigDecimal] = 1 #:: F\n    .zip(Stream.from(1))\n    .map(x => x._1 * x._2)\n\n  def series(k: Int, nb: Int): Double = {\n    val r: BigDecimal = if (k > 0) {\n      if (k % 2 == 1 && k > 2) {\n        (1 to nb).map(n => 1 \/ pow(n, k)).sum\n      } else {\n        1.0 \/ 2.0 * {\n          val t = B(k)\n          if (t > 0) t else -t\n        } * pow(2.0 * Pi, k) \/ F(k)\n      }\n    } else {\n      pow(-1, -k) * B(-k + 1) \/ (-k + 1)\n    }\n    r.toDouble\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335966,"user_id":492,"body":"object AlongBern {\n  def bNb( n:Int ) : Double = {\n    val aa : Array[BFraction] = Array.ofDim(n+1)\n    for( m <- 0 to n ) {\n      aa(m) = BFraction(1,(m+1))\n\n      for( n <- m to 1 by -1 ) {\n        aa(n-1) = (aa(n-1) - aa(n)) * n\n      }\n    }\n    val r : BFraction = aa(0)\n    r.num.toDouble \/ r.den.toDouble\n  }\n  private def sIterative(n: Int, terms: Int): Double = {\n    var result: Double = 0.0\n    var i: Int = 1\n    while (i <= terms) {\n      result += 1.0 \/ Math.pow(i, n)\n      i += 1\n    }\n    result\n  }\n  private def factorial(n: Int): Double = n match {\n    case 0 => 1.0\n    case _ => n.toDouble * factorial(n-1)\n  }\n  def series(n: Int, nb: Int): Double = {\n    val pi: Double = 3.14159265358979\n    if (n >= 0) {\n      if (n % 2 == 1) {\n        sIterative(n, nb)\n      } else {\n        0.5 * Math.abs(bNb(n)) * (Math.pow(2 * pi, n) \/ factorial(n))\n      }\n    } else {\n      Math.pow(-1, (-n)) * bNb(-n + 1) \/ (-n + 1)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a03b3f6a1c9040084001765":[{"id":335967,"user_id":573,"body":"object Kata {\n\n  def angle(n: Int): Int = 180 * (n - 2)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335968,"user_id":575,"body":"object Kata {\n  def angle(n: Int): Int = {\n    (n - 2) * 180\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335969,"user_id":null,"body":"object Kata {\n  def angle(n: Int): Int = {\n    return 180 * (n - 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335970,"user_id":527,"body":"object Kata {\n  def angle = ((_: Int) - 2) andThen 180.*\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335971,"user_id":null,"body":"object Kata {\n  def angle(n: Int): Int = {\n    if (n<=2)\n    0\n    else 180*(n-2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335972,"user_id":null,"body":"object Kata {\n  def angle(n: Int): Int = 180 * (n - 2)\n    \/\/ Implement me! :)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335973,"user_id":null,"body":"object Kata {\n  def angle(n: Int): Int = n*180-360\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335974,"user_id":null,"body":"object Kata {\n  def angle(n: Int): Int = {\n    \/\/ Implement me! :)\n    return (n-2)*180\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335975,"user_id":null,"body":"import scala.annotation.tailrec\nobject Kata {\n  def angle(n: Int): Int = {\n      @tailrec\n      def _angle(n: Int, acc: Int): Int = {\n        if(n == 2) acc\n        else _angle(n - 1, acc + 180)\n      }\n      return _angle(n, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335976,"user_id":null,"body":"object Kata {\n  def angle(n: Int): Int = {\n      if(n == 2) 0\n      else 180 + angle(n - 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a045fee46d843effa000070":[{"id":335977,"user_id":573,"body":"import scala.annotation.tailrec\n\nobject FactDecomp {\n\n  def decomp(n: Int): String =\n    (1 to n)\n      .flatMap(primeFactors(_))\n      .filter(_ != 1)\n      .groupBy(identity)\n      .toList\n      .sortBy(_._1)\n      .map {\n        case (factor, Seq(_)) => s\"$factor\"\n        case (factor, occurences) => s\"$factor^${occurences.size}\"\n      }\n      .mkString(\" * \")\n\n  @tailrec\n  def primeFactors(x: Int, a: Int = 2, list: List[Int] = Nil): List[Int] =\n    a*a > x match {\n      case false if x % a == 0 => primeFactors(x\/a, a, a :: list)\n      case false               => primeFactors(x, a+1, list)\n      case true                => x :: list\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335978,"user_id":null,"body":"object FactDecomp {\n  def decomp(n: Int): String = {\n    val isPrime = (p: Int) => 2 until p forall (p % _ != 0)\n    val primeFactors = 2 to n filter isPrime\n    def exponent(n: Int,p: Int): Int = if (n % p != 0) 0 else 1+exponent(n\/p, p)\n    primeFactors map {\n      p => (p, (2 to n map(exponent(_, p))).sum)\n    } filter { _._2 != 0 } map {\n      case (p, e) => p + (if (e > 1) \"^\"+e else \"\")\n    } mkString \" * \"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335979,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject FactDecomp {\n\n  def primesUntil(n: Int): List[Int] = {\n    def isPrime(num: Int): Boolean = {\n      (2 until num).forall(num % _ != 0)\n    }\n    (2 to n).filter(isPrime).toList\n  }\n\n  def getPrimeOccurs(num: Int, prime: Int, p: Int = 1): Int = {\n    val l: Int = num \/ Math.pow(prime, p).toInt\n    if (l > 0)\n      l + getPrimeOccurs(num, prime, p + 1)\n    else\n      0\n  }\n\n  def decomp(n: Int): String = {\n   primesUntil(n).map(a => (a, getPrimeOccurs(n, a)))\n      .filter(_._2 != 0)\n      .map(p => p._2 match {\n        case 1 => p._1\n        case a => s\"${p._1}^$a\"\n      }).mkString(\" * \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335980,"user_id":null,"body":"object FactDecomp {\n\n  val primes: Stream[Int] =\n    2 #:: Stream.from(3, 2).filter(i => primes.takeWhile(j => j * j <= i).forall(k => i % k > 0))\n\n  def decompose(n: Int, ps: Stream[Int] = primes, factors: Vector[Int] = Vector.empty): Vector[Int] =\n    if (n < 2) factors\n    else {\n      val p = ps.head\n      if (p * p > n) {\n        n +: factors\n      } else if (n % p == 0) {\n        decompose(n \/ p, ps, p +: factors)\n      } else {\n        decompose(n, ps.tail, factors)\n      }\n    }\n\n  def decomp(n: Int): String = {\n    (2 to n)\n      .foldLeft(Vector.empty[Int]) {(v, i) => v ++ decompose(i) }\n      .groupBy(identity)\n      .mapValues(_.length)\n      .toList\n      .sortBy(_._1)\n      .map {case (p, c) => if (c == 1) s\"$p\" else s\"$p^$c\"}\n      .mkString(\" * \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335981,"user_id":null,"body":"object FactDecomp {\n\n  def decomp(n: Int): String = {\n    def numOfEntry(num: Int, prime: Int): Int = {\n      var result = 0\n      var pow = 1\n      while (num \/ scala.math.pow(prime, pow).toInt != 0) {\n        result += num \/ scala.math.pow(prime, pow).toInt\n        pow += 1\n      }\n      result\n    }\n    def sieve(n: Int): List[Int] = {\n      val a = Array.fill(n + 1)(true)\n      a(0)  = false\n      a(1)  = false\n      val k = scala.math.sqrt(n).toInt\n      for (i <- 2 to k; if a(i))\n        for (j <- i * i to n by i)\n          a(j) = false\n      val res = a.zipWithIndex.filter(_._1).map(_._2)\n      res.toList\n    }\n    val primes = sieve(n)\n    var result = \"\"\n    for (prime <- primes) {\n      val noe = numOfEntry(n, prime)\n      if (noe == 1) result += s\"$prime * \" else if (noe > 1) result += s\"$prime^$noe * \"\n    }\n    result.substring(0, result.length - 3)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335982,"user_id":492,"body":"import scala.collection.mutable.ListBuffer\nobject FactDecomp {\n\n  private def sieve(n: Int): List[Integer] = {\n    val isPrime: Array[Boolean] = Array.ofDim[Boolean](n + 1)\n    val primes: ListBuffer[Integer] = new ListBuffer[Integer]() \n    var i: Int = 2\n    while (i <= n) {\n      isPrime(i) = true \n      i += 1\n    }\n    i = 2\n    while (i <= n) {\n      if (isPrime(i)) {\n        primes += i\n        var j: Int = i\n        while (j * i <= n) {\n          isPrime(i * j) = false\n          j += 1\n        }\n      }\n      i += 1\n    }\n    primes.toList\n  }\n  private def power(m: Int, p: Int): Int = {\n    var s: Int = 0\n    var n = m\n    while (n >= p) {\n      s += n \/ p\n      n \/= p\n    }\n    s\n  }\n  def decomp(n: Int): String = {\n    if (n < 2) return \"1\"\n    val result: StringBuilder = new StringBuilder()\n    val primes: List[Integer] = sieve(n)\n    for (x <- primes) {\n      val p: Int = power(n, x)\n      if (p == 1) result.append(x + \" * \");\n      else if (p != 0) result.append(x + \"^\" + p + \" * \");\n      \n    }\n    val s: String = result.toString\n    s.substring(0, s.length - 3)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335983,"user_id":492,"body":"import scala.collection.mutable.ListBuffer\nobject FactDecomp {\n\n  private def sieve(n: Int): List[Integer] = {\n    val isPrime: Array[Boolean] = Array.ofDim[Boolean](n + 1)\n    val primes: ListBuffer[Integer] = new ListBuffer[Integer]() \n    var i: Int = 2\n    while (i <= n) {\n      isPrime(i) = true \n      i += 1\n    }\n    i = 2\n    while (i <= n) {\n      if (isPrime(i)) {\n        primes += i\n        var j: Int = i\n        while (j * i <= n) {\n          isPrime(i * j) = false\n          j += 1\n        }\n      }\n      i += 1\n    }\n    primes.toList\n  }\n  private def power(m: Int, p: Int): Int = {\n    var s: Int = 0\n    var n = m\n    while (n >= p) {\n      s += n \/ p\n      n \/= p\n    }\n    s\n  }\n  def decomp(n: Int): String = {\n    if (n < 2) return \"1\"\n    val result: StringBuilder = new StringBuilder()\n    val primes: List[Integer] = sieve(n)\n    for (x <- primes) {\n      val p: Int = power(n, x)\n      if (p == 1) result.append(x + \" * \");\n      else if (p != 0) result.append(x + \"^\" + p + \" * \");\n      \n    }\n    val s: String = result.toString\n    s.substring(0, s.length - 3)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335984,"user_id":null,"body":"import scala.collection.immutable.SortedMap\nimport scala.collection.mutable\n\nobject FactDecomp {\n\n  val globalMutableCache: mutable.Map[Int, SortedMap[Int, Int]] =\n    mutable.Map.empty\n\n  def mergeDecomps(\n      d1: SortedMap[Int, Int],\n      d2: SortedMap[Int, Int]\n  ): SortedMap[Int, Int] = {\n    SortedMap.from(\n      d1.toList.concat(d2.toList).groupBy(_._1).map { case (k, v) =>\n        (k, v.map(_._2).sum)\n      }\n    )\n  }\n\n  def cachedOrDecompOne(n: Int): SortedMap[Int, Int] = {\n    globalMutableCache.get(n).getOrElse {\n      val computed = decompOne(n)\n      globalMutableCache.update(n, computed)\n      computed\n    }\n  }\n\n  def decompOne(\n      n: Int,\n      curDiv: Int = 2\n  ): SortedMap[Int, Int] = {\n    if (n <= 1) SortedMap.empty[Int, Int]\n    if (curDiv > math.sqrt(n).toInt) SortedMap((n, 1))\n    else if (n % curDiv == 0) {\n      val m1 = n \/ curDiv\n      val m2 = curDiv\n\n      mergeDecomps(\n        cachedOrDecompOne(m1),\n        cachedOrDecompOne(m2)\n      )\n    } else {\n      decompOne(n, curDiv + 1)\n    }\n  }\n\n  val resultCache: mutable.SortedMap[Int, SortedMap[Int, Int]] =\n    mutable.SortedMap.empty\n\n  def cachedOrResult(n: Int): SortedMap[Int, Int] = {\n    resultCache.get(n).getOrElse {\n      val computed = decompFact(n)\n      resultCache.update(n, computed)\n      computed\n    }\n  }\n\n  def decompFact(n: Int): SortedMap[Int, Int] = {\n    val (curMaxKey, curMaxDecomp) =\n      if (resultCache.isEmpty) (1, SortedMap.empty[Int, Int])\n      else resultCache.maxBy(_._1)\n\n    if (curMaxKey < n) {\n      ((curMaxKey + 1) to n)\n        .foldLeft(curMaxDecomp) { case (acc, next) =>\n          val computed = mergeDecomps(acc, cachedOrDecompOne(next))\n          resultCache.update(next, computed)\n          computed\n        }\n    } else {\n      resultCache(n)\n    }\n  }\n\n  def decomp(n: Int): String = {\n    cachedOrResult(n).toList\n      .flatMap {\n        case (mul, _) if mul <= 1 => List()\n        case (mul, 1)             => List(mul.toString)\n        case (mul, c)             => List(s\"$mul^$c\")\n      }\n      .mkString(\" * \")\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335985,"user_id":null,"body":"import scala.collection.mutable.HashMap\nimport scala.collection.immutable.ListMap\n\nobject FactDecomp {\n\n  val map: HashMap[Int, Int] = HashMap()\n  val cache: HashMap[Int, List[Int]] = HashMap()\n  \n  def getFactors(x: Int): List[Int] = {\n    \n    if (cache.contains(x)) {\n      return cache(x)\n    }\n    \n    if (x <= 2) {\n      return List(x)\n    }\n\n    for (i <- 2 to x \/ 2) {\n      if (x % i == 0) {\n        return i :: getFactors(x \/ i)\n      }\n    }\n\n    return List(x)\n  }\n\n  def decomp(n: Int): String = {\n    var l: List[Int] = List()\n    for (x <- 2 to n) {\n      val factors = getFactors(x)\n      if (!cache.contains(x)) {\n        cache(x) = factors\n      }\n      l = l ::: factors\n    }\n\n    val ll = l.groupBy(x => x)\n\n    val res = ListMap(ll.toSeq.sortBy(_._1): _*)\n    val r = res.map({ case (k, v) => (k, v.length) }).toSeq\n\n    val st = r.tail.foldLeft({\n      if (r.head._2 > 1) s\"${r.head._1}^${r.head._2}\" else s\"${r.head._1}\"\n    })((e, n) => {\n      e + { if (n._2 > 1) s\" * ${n._1}^${n._2}\" else s\" * ${n._1}\" }\n    })\n    st\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335986,"user_id":null,"body":"import scala.collection.immutable.TreeMap\n\nobject FactDecomp {\n\n  def decomp(n: Int): String = {\n    def factorial(step: Int,\n                  accumStep: Int,\n                  result: TreeMap[Int, Int],\n                  changedList: List[Int],\n                  wholeList: List[Int]): String = {\n      if (n < step) result.map {pair =>\n        if(pair._2 == 1) pair._1.toString\n        else pair._1 + \"^\" + pair._2\n      }.mkString(\" * \")\n      else {\n        val h = changedList.head\n        if (accumStep == 1) factorial(step + 1, step + 1, result, wholeList, wholeList)\n        else if (accumStep % h == 0) {\n          val newMap = if (result.contains(h)) result + (h -> (result(h) + 1)) else result + (h -> 1)\n          factorial(step, accumStep \/ h, newMap, changedList, wholeList)\n        }\n        else {\n          factorial(step, accumStep, result, changedList.tail, wholeList)\n        }\n      }\n    }\n\n    def eratosfen(number: Int): List[Int] = {\n      (2 to number)\n        .filter(elem => !(2 to Math.sqrt(elem).toInt).exists(inner => (elem % inner) == 0)).toList\n    }\n\n    val eratoList: List[Int] = eratosfen(n)\n\n    factorial(2, 2, TreeMap(), eratoList, eratoList)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a057ec846d843c81a0000ad":[{"id":335987,"user_id":492,"body":"object Cycle {\n\n  def cycle(n: Int): Int = {\n    if (n % 2 == 0 || n % 5 == 0) {\n      return -1\n    }\n    var r: Int = 1\n    var i: Int = 1\n    while (i <= n) {\n      r = r * 10 % n\n      if (r == 1)\n        return i\n      i += 1\n    }\n    return -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335988,"user_id":1285,"body":"\nobject Cycle {\n\n  def cycle(n: Int): Int = {\n    def longDivision(numerator: Int, denom: Int, iterations: Int, indexMap: Map[Int, Int]): Int = {\n      if (indexMap.contains(numerator)) {\n        if (indexMap(numerator) == 0) iterations - indexMap(numerator) else -1\n      } else if (numerator % denom == 0) {\n        -1\n      } else {\n        longDivision((numerator - denom * (numerator \/ denom)) * 10, denom, iterations + 1, indexMap + (numerator -> iterations))\n      }\n    }\n\n    longDivision(1, n, -1, Map())\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335989,"user_id":null,"body":"object Cycle {\n  \n  def count(k: Int, base: Int, acc: Int = 1): Int = {\n    if (base % k == 10 % k) acc\n    else count(k, (base % k) * 10, acc + 1)\n  }\n  \n  def cycle(n: Int): Int = {\n    if (n % 2 != 0 && n % 5 != 0) count(n, (10 % n) * 10)\n\n    else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335990,"user_id":53,"body":"object Cycle {\n\n  def cycle(n: Int): Int = {\n    if (n%2 == 0 || n%5 == 0) return -1;\n    var m = 10 % n;\n    var cnt = 1;\n    while (m != 1) {\n        m = m * 10 % n; \n        cnt += 1;\n    }\n    return cnt;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335991,"user_id":null,"body":"object Cycle {\n  \n  def counter(n: Int, base: Int, acc: Int = 1): Int = {\n    if (base % n == 10 % n) acc\n    else counter(n, (base % n) * 10, acc + 1)\n  }\n  \n  def cycle(n: Int): Int = {\n    if (n % 2 != 0 && n % 5 != 0) {\n      counter(n, (10 % n) * 10)\n    }\n    else -1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335992,"user_id":null,"body":"object Cycle {\n\n  def cycle(n: Int): Int =\n    if (n % 2 == 0 || n % 5 == 0) {\n      -1\n    } else {\n      val array = new Array[Int](n)\n      var num   = 10 % n\n      var i     = 1\n      while (array(num) == 0) {\n        array(num) = i\n        i += 1\n        num = (num * 10) % n\n      }\n      i - array(num)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335993,"user_id":null,"body":"object Cycle {\n\n  def cycle(n: Int): Int = {\n    if (n % 2 == 0 || n % 5 == 0) -1 else {\n      var res = 10 % n\n      var c = 1\n      while (res != 1) {\n        res = res * 10 % n\n        c += 1\n      }\n      c\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335994,"user_id":null,"body":"object Cycle {\n\n  def cycle(n: Int) = n match {\n    case _ if n % 2 == 0 || n % 5 == 0 => -1\n    case _ => 1 + Iterator.iterate(10 % n)(_ * 10 % n).takeWhile(x => x != 1).size\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335995,"user_id":null,"body":"object Cycle {\n  \n  def cycle(n: Int): Int = {\n    \/**\n    * 1 \/ 69\n    * -> (1\/100) * (1 + 31 \/ 69)\n    * -> (1\/100) * (1 +\n    *               (1\/10) * (4 + 34 \/ 69))\n    * -> (1\/100) * (1 +\n    *               (1\/10) * (4 + \n    *                           (1\/10) * (4 + 64 \/ 69)))\n    **\/\n    \n    def go(n0: Int, seq_length: Int): Int = {\n      if (seq_length > 0 && n0 == 1)\n        return(seq_length)\n      \n      go((n0 * 10) % n, seq_length + 1)\n    }\n\n    if (n % 5 == 0 || n % 2 == 0)\n      -1\n    else\n      go(1, 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335996,"user_id":null,"body":"object Cycle {\n  def cycle(n: Int): Int = {\n      val start = 10\/n\n      val count = 0\n      val rem = 10 % n\n      val result = recursiveFn(rem, count, n)\n      if(result(1) == start && result(0)<n) result(0) else -1\n  }\n  def recursiveFn (rem: Int, count: Int, n: Int): List[Int]= {\n      if(rem == 1 || count == n) List(count+1, (10 * rem) \/ n)\n      else recursiveFn((10 * rem) % n, count+1, n)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a25ac6ac5e284cfbe000111":[{"id":335997,"user_id":null,"body":"object Sol {\n  val colours = Set('R','G','B')\n  def triangle(row: String): String = \n    if(row.length == 1) row \n    else triangle(row.zip(row.tail).map {\n      case(c, d) if c == d => c\n      case(c, d) => (colours - c - d).head }.mkString)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335998,"user_id":null,"body":"object Sol {\n\n  def triangle(row: String): String =\n    if (row.length == 1) {\n      row\n    } else {\n      val nextRow = row.substring(0, row.length - 1)\n        .zip(row.substring(1, row.length))\n        .map {\n          case (l, r) =>\n            Seq(l, r).distinct.sorted match {\n              case Seq(x) => x\n              case Seq('B', 'G') => 'R'\n              case Seq('B', 'R') => 'G'\n              case Seq('G', 'R') => 'B'\n            }\n        }.mkString(\"\")\n      triangle(nextRow)\n    }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":335999,"user_id":573,"body":"object Sol {\n\n  def triangle(row: String): String =\n    if (row.size == 1) row else triangle(row.sliding(2).map { case s if s(0) == s(1) => s(0) case s => \"RGB\".diff(s).head }.mkString)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336000,"user_id":null,"body":"object Sol {\n\n  def triangle(row: String): String = if (row.length == 1) row else {\n    triangle(row.lazyZip(row.tail).map{\n      case ('B', 'G') => 'R'\n      case ('G', 'B') => 'R'\n      case ('R', 'G') => 'B'\n      case ('G', 'R') => 'B'\n      case ('B', 'R') => 'G'\n      case ('R', 'B') => 'G'\n      case (p, n) => n \n    }.mkString)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336001,"user_id":null,"body":"object Sol {\n  def triangle(row: String): String = if (row.size <= 1) row else triangle(nextRow(row))\n  def nextRow(row: String): String = row.sliding(2).map(x => color(x(0), x(1))).mkString\n  def color(s0: Char, s1: Char): Char = if (s0 == s1) s0 else (colors - s0 - s1).head\n  val colors = Set('R','G','B')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336002,"user_id":null,"body":"object Sol {\n\n  def complement(s: Set[Char]): Char = {\n    Set('R', 'G', 'B').diff(s).head\n  }\n\n  @annotation.tailrec\n  def triangle(row: String): String = {\n    if (row.length <= 1) {\n      row\n    } else {\n      triangle(\n        row\n          .sliding(2)\n          .map { s =>\n            s.toSeq match {\n              case Seq(fst, snd) if fst == snd => fst\n              case Seq(fst, snd) if fst != snd => complement(Set(fst, snd))\n            }\n          }\n          .mkString\n      )\n    }\n\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336003,"user_id":null,"body":"object Sol {\n\n  def triangle(row: String): String = {\n    if (row.length == 1) row\n    else buildNextRow(new StringBuilder)(row.toList).result()\n  }\n  \n  private def buildNextRow(acc: StringBuilder)(list: List[Char]): StringBuilder = list match {\n      case x :: Nil =>\n        acc.length match {\n          case 1 => acc\n          case _ =>\n            val newAcc = new StringBuilder\n            buildNextRow(newAcc)(acc.toList)\n        }\/\/\u0435\u0441\u043b\u0438 \u0432 \u0441\u043f\u0438\u0441\u043a\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0434\u0438\u043d \u044d\u043b\u0435\u043c\u0435\u043d\u0442, \u0432\u0435\u0440\u043d\u0435\u043c \u0430\u043a\u043a\u0443\u043c\n      case x :: t =>\n        val c: Char = getColour(list.head, list.tail.head)\n        acc.addOne(c)\n        buildNextRow(acc)(list.tail)\/\/\u0442\u043e\u043b\u044c\u043a\u043e \u0435\u0441\u043b\u0438 \u0432 \u0445\u0432\u043e\u0441\u0442\u0435 \u043d\u0435 \u043c\u0435\u043d\u0435\u0435 \u0434\u0432\u0443\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n    }\n  \n  private def getColour(left: Char, right: Char): Char = {\n    if (left == right) left\n    else {\n      (left, right) match {\n        case ('R', 'G') => 'B'\n        case ('G', 'R') => 'B'\n        case ('G', 'B') => 'R'\n        case ('B', 'G') => 'R'\n        case ('R', 'B') => 'G'\n        case ('B', 'R') => 'G'\n      }  \n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336004,"user_id":null,"body":"object Sol {\n\n  def triangle(row: String): String = {\n    println(row)\n    if (row.length == 1) return row\n    triangle(row.zip(row.tail).map{\n      case (x, y) if x == y => x\n      case ('G', 'B') | ('B', 'G') => 'R'\n      case ('B', 'R') | ('R', 'B') => 'G'\n      case ('R', 'G') | ('G', 'R') => 'B'\n    }.mkString)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336005,"user_id":null,"body":"object Sol {\n\n  def colour(clr: String)= \n    clr match {\n      case \"BG\" | \"GB\" | \"RR\" => \"R\"\n      case \"BR\" | \"GG\" | \"RB\" => \"G\"\n      case \"BB\" | \"GR\" | \"RG\" => \"B\"\n    }\n  \n  def triangle(row: String): String = {\n    if(row.length == 1){\n      return row\n    } \n    \n    var ks = \"\"\n    \n    for(i <- 0 to row.length - 2)\n      {\n        ks += colour(row.substring(i, i + 2))\n      }\n    return triangle(ks)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336006,"user_id":null,"body":"object Sol {\n\n  def paint(let: String)= let match {\n    case \"RR\"|\"BG\"|\"GB\"=>\"R\"\n    case \"GG\"|\"BR\"|\"RB\"=>\"G\"\n    case \"BB\"|\"RG\"|\"GR\"=>\"B\"\n  }\n  def triangle(row: String): String = {\n    if(row.length==1) return row\n    var l =\"\"\n    for(i<-0 to row.length-2)\n      {\n        l+=paint(row.substring(i, i+2))\n      }\n    return triangle(l)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a3fe3dde1ce0e8ed6000097":[{"id":336007,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = {\n    (year-1)\/100+1\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336008,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Double): Double = Math.ceil(year \/ 100)\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336009,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = (year + 99) \/ 100\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336010,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = {\n    import scala.math.Integral.Implicits._\n    val (q, r) = year \/% 100\n    val qr = q + r\n    if (qr < q || qr < r) 0 else q + (if (r == 0) 0 else 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336011,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = \n    if (year % 100 == 0) (year \/ 100) \n    else (year \/ 100) + 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336012,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int) = (year + 99) \/ 100;\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336013,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = {\n    val index:Integer = if (year >= 901) 2 else 1\n    (year + 99).toString.substring(0, index).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336014,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = \n    if (year % 100 == 0) {\n      year \/ 100\n    } else {\n      year \/ 100 - (year % 100) \/ 100 + 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336015,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = {\n    return math.ceil( year \/ 100.0 ).toInt;\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336016,"user_id":null,"body":"object CenturyYear {\n  def century_from_year(year: Int): Int = {\n  val y: Double = year.toDouble\n  val d: Double = 100\n  \n  val r: Double = y \/ d\n  Math.ceil(r).toInt\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a48948e145c46820b00002f":[{"id":336017,"user_id":492,"body":"import scala.collection.mutable.ListBuffer\nobject KprimesSteps {\n\n    private def countPrimeDiv(n: Long): Int = {\n      var m: Long = n\n      var cnt: Int = 0\n      var i: Long = 2\n      while (i * i <= m) {\n        while (m % i == 0) {\n          cnt += 1\n          m = m \/ i\n        }\n        i += 1\n      }\n      if (m > 1) { cnt += 1 }\n      cnt\n    }\n    def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n      var res: ListBuffer[Array[Long]] = new ListBuffer[Array[Long]]() \n      var i: Long = start\n      while (i <= nd - step) {\n        if ((countPrimeDiv(i) == k && countPrimeDiv(i + step) == k))\n          res += Array(i, i + step)\n        i += 1\n      }\n      res.toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336018,"user_id":null,"body":"object KprimesSteps {\n\n  def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n    def getNumPF(n: Long): Int = {\n      Iterator.iterate((n, 2L, 1)) {\n        case (x, y, z) if BigInt(x).isProbablePrime(50) => (x \/ y, x, z + 1)\n        case (x, y, z) if x % y == 0 => (x \/ y, 2, z + 1)\n        case (x, y, z) => (x, y + 1, z)\n      }.takeWhile(x => x._1 >= x._2).toList.last._3\n    }\n\n    val s = (start to nd).map((x: Long) => (getNumPF(x), x)).filter(_._1 == k).map(_._2)\n\n    s.collect { case x if s.exists(_ == x + step) => Array(x, x + step) }.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336019,"user_id":null,"body":"object KprimesSteps {\n\n  def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n\n    def getNumPF(n:Long): Int={\n        Iterator.iterate((n, 2L, collection.mutable.ListBuffer[Long]())) {\n          case (x, y, z) if BigInt(x).isProbablePrime(50)  => (x \/ y, x, z +=x)\n          case (x, y, z) if x % y == 0 => (x \/ y, 2, z += y)\n          case (x, y, z) => (x, y + 1, z)\n        }.takeWhile(x => x._1 >= x._2 - 1).toList.last._3.size\n    }\n    val s = (start to nd).map((x: Long) =>(getNumPF(x),x)).filter(_._1==k).map(_._2)\n    s.collect{case x if s.exists(_==x+step) => Array(x,x+step)}.toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336020,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject KprimesSteps {\n  def factorize(x: Long): List[Long] = {\n    @tailrec\n    def foo(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a*a > x match {\n      case false if x % a == 0 => foo(x \/ a, a    , a :: list)\n      case false               => foo(x    , a + 1, list)\n      case true                => x :: list\n    }\n    foo(x)\n  }\n  \n  def isKPrime(k: Int, n: Long): Boolean = {\n    k == factorize(n).length\n  }\n  \n  def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n    val kprimes = (start to nd).flatMap(x => if (isKPrime(k, x)) List(x) else List())\n    println(kprimes)\n    val filtered = kprimes.filter(x => kprimes.count(_ == x+step) != 0).toList\n    if (filtered.length == 0) {\n      Nil\n    }\n    else {\n      filtered.map(x => Array(x, x+step)).toList\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336021,"user_id":468,"body":"object KprimesSteps {\n\n  @scala.annotation.tailrec\n  def numberOfFactors(n: Long, prime: Long = 2, factors: Int = 0): Int =\n    if (prime * prime > n) factors + 1\n    else if (n % prime == 0) numberOfFactors(n \/ prime, prime, factors + 1)\n    else numberOfFactors(n, prime + 1, factors)\n\n  def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] =\n    (start to (nd - step))\n      .filter(n => numberOfFactors(n) == k && numberOfFactors(n + step) == k)\n      .map(p => Array(p, p + step)).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336022,"user_id":null,"body":"object KprimesSteps {\n    def isKPrime(number: Long, k: Int, sieve: Array[Boolean]): Boolean = {\n      var counter = 0  \n      for (i <- 2L to math.sqrt(number).toLong) {\n        var numCopy = number\n        while (numCopy % i == 0) {\n          if(sieve(i.toInt) == false) {\n            counter += 1\n          }\n          val opposite = (number \/ i).toInt\n          if (number % (number \/ i) == 0 && sieve(opposite) == false && opposite != i) {\n            counter += 1          \n          }\n          numCopy \/= i\n        }\n      }\n      counter == k\n    }  \n  \n    def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n      var result : List[Array[Long]] = List()\n      var sieve = Array.fill[Boolean]((nd+1).toInt)(false)\n      for (i <- 2L to math.sqrt(nd).toLong) {\n        if (sieve(i.toInt) == false) {\n          var iCopy = i\n          while (i*iCopy <= nd) {\n            sieve((i*iCopy).toInt) = true\n            iCopy += 1\n          }\n        }\n      }\n      for(i <- start to nd - step) {\n        if (isKPrime(i, k, sieve) && isKPrime(i+step, k, sieve)) {\n          result = result :+ Array(i, i+step)\n        }\n      }\n      result\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336023,"user_id":null,"body":"object KprimesSteps {\n\n  def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n    val array = (start to nd).filter(isKPrime(_, k))\n    array.filter(num => array.contains(num + step)).map(num => Array(num, num + step)).toList\n  }\n\n  private def isKPrime(n: Long, k: Int): Boolean = {\n    var count  = 0L\n    var number = n\n    if (number % 2 == 0) {\n      while (number % 2 == 0) {\n        number \/= 2\n        count += 1\n      }\n    }\n    var i = 3L\n    while (number > 1 && count <= k) {\n      if (number % i == 0) {\n        while (number % i == 0) {\n          number \/= i\n          count += 1\n        }\n      }\n      i += 2\n    }\n    count == k\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336024,"user_id":53,"body":"import scala.collection.mutable.ListBuffer\n\nobject KprimesSteps {\n\n    def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n        var arr = new ListBuffer[Array[Long]]();\n        var i = start;\n        while (i <= nd - step) {\n            if (primeFactorCount(i) == k && primeFactorCount(i + step) == k) {\n                arr += Array(i, i + step);\n            }\n            i = i + 1;\n        }\n      return arr.toList;\n    }\n  \n    def primeFactorCount(m: Long): Long = {\n        var len = 0;\n        var n = m;\n        var i = 2;\n        while (i * i <= n) {\n            while (n % i == 0) {\n                len = len + 1;\n                n = n \/ i;\n            }\n            i = i + 1;\n        }\n        if (n > 1) {\n            len = len + 1;\n        }\n        return len;\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336025,"user_id":null,"body":"import scala.math._\n\nobject KprimesSteps {\n\n  def kprimesStep(\n      k: Int,\n      step: Int,\n      start: Long,\n      end: Long\n  ): List[Array[Long]] = {\n    val kPrimes = (start to end).filter(countPrimeFactors(_) == k).toSet\n    kPrimes\n      .intersect(kPrimes.map(_ + step))\n      .toList\n      .sorted\n      .map(i => Array(i - step, i))\n  }\n\n  private def countPrimeFactors(value: Long) = {\n    var n = value\n    var count = 0\n    while (n != 0 && n % 2 == 0) {\n      n = n \/ 2\n      count += 1\n    }\n    for (i <- 3 to sqrt(n).toInt by 2)\n      while (n % i == 0) {\n        n = n \/ i\n        count += 1\n      }\n    if (n > 2)\n      count += 1\n    count\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336026,"user_id":null,"body":"object KprimesSteps {\n\n  def isKPrime(n: Long, k: Int): Boolean = {\n    def factorize(n: Long, a: Int = 2, amount: Int = 0): Int = a*a > n match {\n      case false if n % a == 0 => factorize(n \/ a, a, amount + 1)\n      case false => factorize(n, a + 1, amount)\n      case true => amount + 1\n    }\n    k == factorize(n)\n  }  \n\n    def kprimesStep(k: Int, step: Int, start: Long, nd: Long): List[Array[Long]] = {\n      (start to nd - step).filter(n => isKPrime(n, k) && isKPrime(n + step, k))\n        .map( n => Array(n, n + step)).toList\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a523566b3bfa84c2e00010b":[{"id":336027,"user_id":573,"body":"object Solution {\n\n  def minSum(passed: List[Int]): Int = {\n    val (sorted, half) = (passed.sorted, passed.size\/2)\n    (sorted.take(half) zip sorted.reverse.take(half)).map { case (a, b) => a*b }.sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336028,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n    val (left, right) = passed.sorted.splitAt(passed.length \/ 2)\n    (left zip right.reverse).map { case (a, b) => a * b }.sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336029,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n     var acc = 0\n    var order = passed.sorted\n    for (x<- 0 to order.length\/2-1 ){\n     acc =acc+ order(x)*order(order.length-1-x)\n    }\n    acc\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336030,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n    val (f, s) = passed.sorted.splitAt(passed.size \/ 2)\n    (f zip s.reverse).map {case (a, b) => a * b}.sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336031,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n    val f = passed.sorted.slice(0, passed.size \/ 2)\n    val s = passed.sorted(Ordering.Int.reverse).slice(0, passed.size \/ 2)\n    f.zip(s).map(x => x._1 * x._2).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336032,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n    val sorted = passed.sorted\n    println(sorted)\n    \n    var sum = 0\n    for (elem <- 0 to sorted.length \/ 2 - 1) {\n      sum += sorted(elem) * sorted(sorted.length -1 - elem) \n    }\n    \n    sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336033,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n    val (a, b) = passed.sorted.splitAt(passed.length \/ 2)\n\n    a.zip(b.sortWith(_ > _))\n      .map { case (a, b) =>\n        a * b\n      }\n      .sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336034,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n      val max_iter=passed.size\/2\n      var sum:Int = 0\n      var lst:List[Int]=passed.sorted\n      \n      \n      \n      var i=1\n      \n      while(i<=max_iter) {\n          sum +=lst(0)*lst(lst.size-1)\n          lst = lst.slice(1,lst.size-1)\n         \n          i+=1\n      }\n      sum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336035,"user_id":null,"body":"object Solution {\n  \n  def minSum(passed: List[Int]): Int = {\n    val sortedPassed: List[Int] = passed.sorted\n    val passedSize: Int = sortedPassed.size\n    val prodCount: Int = passedSize \/ 2\n    val operations: Range = 1 to prodCount\n\n    operations\n      .map(el => sortedPassed(el - 1) * sortedPassed(passedSize - el))\n      .sum\n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336036,"user_id":null,"body":"object Solution {\n  def minSum(passed: List[Int]): Int = {\n    val (sorted, midPoint) = (passed.sorted, passed.size\/2)\n    (sorted.take(midPoint) zip sorted.reverse.take(midPoint)).map{case (a, b) => a*b}.sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a59e029145c46eaac000062":[{"id":336037,"user_id":null,"body":"object DominoTiling2xNBoard {\n  def twoByN(n: Int, k: Int): Int = {\n    if (k == 1) if (n == 1) 1 else 0\n    else {\n      val MOD = 12345787L\n      val SAME = 0\n      val DIFF = 1\n      val arr = Array.ofDim[Long](n+2, 2)\n      arr(1)(SAME) = k\n      arr(1)(DIFF) = 0\n      arr(2)(SAME) = (k * (k-1)) % MOD\n      arr(2)(DIFF) = (k * (k-1)) % MOD\n      for (i <- 3 to n) {\n        arr(i)(SAME) = (\n          (arr(i-1)(SAME) * (k-1)) % MOD +\n          (arr(i-1)(DIFF) * (k-2)) % MOD\n        ) % MOD\n  \n        arr(i)(DIFF) = (\n          (arr(i-2)(SAME) * ((k-1) * (k-2)) % MOD) % MOD +\n          (arr(i-2)(DIFF) * (((k-2) * (k-2)) % MOD + (k-1)) % MOD) % MOD\n        ) % MOD\n      }\n      ((arr(n)(SAME) + arr(n)(DIFF)) % MOD).toInt\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336038,"user_id":null,"body":"import scala.collection.mutable\n\nobject DominoTiling2xNBoard {\n  def twoByN(n: Int, k: Int): Int = {\n    lazy val dp: ((Int, Int)) => Long = memoize {\n      case (0, _) => 1\n      case (1, u) => z(k - u)\n      case (n, u) => (dp(n-1, 1) * z(k-u) + dp(n-2, 2) * (if (u==2) (z(k-1) + z(k-2) * z(k-2)) else z(k-u) * z(k-u-1)) ) % 12345787\n    }\n    for (i <- 100 to n by 100) {\n     dp(i, 1)\n    }\n    dp(n, 0).toInt\n  }\n  \n  def z(n: Int): Int = if (n > 0) n else 0\n  \n  def memoize[I, O](f: I => O): I => O = new mutable.HashMap[I, O]() {self =>\n    override def apply(key: I): O = self.synchronized(getOrElseUpdate(key, f(key)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336039,"user_id":null,"body":"import scala.collection.mutable\n\nobject DominoTiling2xNBoard {\n  private val zero = BigInt(0)\n\n\n  def twoByN(n: Int, k: Int): Int = {\n    val cache: mutable.Map[(Int, Int), BigInt] = mutable.Map()\n\n    def f(remains: Int, previous: Int): BigInt = {\n      if (!cache.contains((remains, previous))) {\n        cache((remains, previous)) = remains match {\n          case x if x < 0 => 0\n          case 0 => 1\n          case _ => previous match {\n            case 1 =>\n              val pushOne = if (k > 1) (k - 1) * f(remains - 1, 1) else zero\n              val pushTwo = if (k > 2) (k - 1) * (k - 2) * f(remains - 2, 2) else zero\n              pushOne + pushTwo\n            case 2 =>\n              val pushOne = if (k > 2) (k - 2) * f(remains - 1, 1) else zero\n              val pushTwo = ((if (k > 1) k - 1 else 0) + (if (k > 2) (k - 2) * (k - 2) else 0)) * f(remains - 2, 2)\n              pushOne + pushTwo\n          }\n        }\n      }\n      cache((remains, previous))\n    }\n\n    (1 to n).foreach(x => f(x, 1))\n    (1 to n).foreach(x => f(x, 2))\n\n    val firstPushOne = k * f(n - 1, 1)\n    val firstPushSecond = if (k > 1) k * (k - 1) * f(n - 2, 2) else zero\n\n    ((firstPushOne + firstPushSecond) % 12345787).toInt\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336040,"user_id":null,"body":"import scala.language.postfixOps\n\nobject DominoTiling2xNBoard {\n  \n  val modulo = 12345787\n  \n  def twoByN(n: Int, k: Int): Int = {\n    def twoByNAux(acc: Long, a0: Long, b0: Long, a1: Long, b1: Long): Long = {\n      if (acc > n) (a0 + b0) % modulo\n      else if (acc == n) (a1 + b1) % modulo\n      else twoByNAux(acc + 1, a1, b1, \n                     (a1 * (k - 1) + b1 * (k - 2).max(0)) % modulo, \n                     (b0 * (k - 2).max(0) * (k - 2).max(0) + b0 * (k - 1) + a0 * (k - 2).max(0) * (k - 1)) % modulo) \n    }\n    \n    val a0 = k\n    val b0 = 0\n    val a1 = k * (k - 1)\n    val b1 = k * (k - 1)\n    twoByNAux(2, a0, b0, a1, b1).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336041,"user_id":null,"body":"object DominoTiling2xNBoard {\n  \/\/ 1\n  \/\/ a a\n  \/\/ b b\n  \n  \/\/ 2\n  \/\/ a\n  \/\/ a\n  \n  \/\/ 1 ->\n  \/\/ a a c\n  \/\/ b b c\n  \n  \/\/ 1 -> \n  \/\/ a a b b\n  \/\/ b b a a\n  \n  \/\/ 2 ->\n  \/\/ a b\n  \/\/ a b\n  \n  \/\/ 2 ->\n  \/\/ a b b\n  \/\/ a c c\n  \n  final case class Pair(vert: Int, hor: Int)\n  \n  val modulo = 12345787\n  \n  @scala.annotation.tailrec\n  def go(n: Int, k: Int, fst: Pair, snd: Pair): Int =\n    if (n == 1)\n      (fst.vert + fst.hor) % modulo\n    else if (n == 2)\n      (snd.vert + snd.hor) % modulo\n    else {\n      val trd = Pair(\n        (snd.vert * (k - 1) % modulo + snd.hor * math.max(k - 2, 0) % modulo) % modulo,\n        (fst.vert * (k - 1) % modulo * math.max(k - 2, 0) % modulo + fst.hor * (k - 2) % modulo * (k - 1) % modulo + fst.hor) % modulo\n      )\n      \n      go(n - 1, k, snd, trd)\n    }\n  \n  def twoByN(n: Int, k: Int): Int = {\n    val fst = Pair(k, 0)\n    val snd = Pair(k * (k - 1), k * (k - 1))\n    go(n, k, fst, snd)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336042,"user_id":null,"body":"object DominoTiling2xNBoard {\n  def twoByN(n: Int, k: Int): Int = {\n    if (k == 0 || n == 0) return 0\n    else if (k == 1) return if (n == 1) 1 else 0\n    else if (k == 2) return if (n % 2 == 1) 2 else 4\n    var single = new Array[Long](n + 1);\n    var double = new Array[Long](n + 1);\n    single(1) = k\n    double(1) = k * (k - 1)\n    if (n >= 2) for (i <- 2 to n) {\n      single(i) =\n        (k - 1) * single(i - 1) % 12345787 +\n        (k - 2) * double(i - 2) % 12345787\n      double(i) =\n        (k - 1) * (k - 2) * single(i - 1) % 12345787 +\n        ((k - 2) * (k - 2) +\n         1 * (k - 1)) * double(i - 2) % 12345787\n    }\n    \/\/println(single.mkString(\" \"))\n    \/\/println(double.mkString(\" \"))\n    return ((single(n) + double(n - 1)) % 12345787).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336043,"user_id":null,"body":"object DominoTiling2xNBoard {\n  def twoByN(n: Int, k: Int): Int = {\n      if (k == 1) {\n        if (n == 1) 1 else 0\n      } else if (k == 2) {\n        if (n % 2 == 1) 2 else 4\n      } else {\n        if ( n == 1 ) return k\n        if ( n == 2 ) return 2 * k * (k-1)\n        var v2: Long = k\n        var h2 = 0L\n        var v1: Long = k * (k-1)\n        var h1: Long = k * (k-1)\n        var v = 0L\n        var h = 0L\n        for (i <- 3 to n) {\n          v = ((k-1) * v1 + (k-2) * h1) % 12345787\n          h = (((k-2)*(k-2) + k-1)*h2 + (k-1)*(k-2)*v2) % 12345787\n          v2 = v1\n          v1 = v\n          h2 = h1\n          h1 = h\n        }\n\n        ((h + v)%12345787).toInt\n      }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336044,"user_id":null,"body":"object DominoTiling2xNBoard {\n\n  val m: Long = 12345787\n\n  def twoByN(n: Int, k: Int): Int = {\n\n    def next(x: (Long, Long), y: (Long, Long)): (Long, Long) = {\n      \/\/ the former domino is horizontal\n      \/\/ pp mm if (m == q) { k - 2 }\n      \/\/ qq nn else { (k - 2) * (k - 2) }\n      val a = ((k - 2) * (k - 2) + k - 1) * x._1 % m\n      \/\/  p mm\n      \/\/  p nn { k - 2 }\n      val b = (k - 2) * y._2 % m\n\n      \/\/ the former domino is vertical\n      \/\/ pp m\n      \/\/ qq m { (k - 1) * (k - 2) }\n      val c = (k - 1) * (k - 2) * x._1 % m\n      \/\/  p m\n      \/\/  p m { k - 1 }\n      val d = (k - 1) * y._2 % m\n      ((a + b) % m, (c + d) % m)\n    }\n\n    def stream(x: (Long, Long), y: (Long, Long)): Stream[(Long, Long)] = {\n      x #:: stream(y, next(x, y))\n    }\n\n    if (n == 1) k\n    else if (k == 1 && n > 1) 0\n    else {\n      \/\/ p mm           p m\n      \/\/ p nn { k - 2 } p m { k - 1 }\n      val s = stream((1, 1), (k - 2, k - 1))\n      val r1 = k * (k - 1) * s(n - 2)._1 % m\n      val r2 = k * s(n - 1)._2 % m\n      ((r1 + r2) % m).toInt\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336045,"user_id":null,"body":"object DominoTiling2xNBoard {\n\n  val m: Long = 12345787\n\n  def twoByN(n: Int, k: Int): Int = {\n    val (a, b, c, d) = (\n      (k - 1) * (k - 2),\n      (k - 2) * (k - 2) + k - 1,\n      k - 1,\n      k - 2\n    )\n\n    \/\/ number of ways to fill the remaining part of the given grid\n    \/\/ if the former domino is (horizontal, vertical)\n    def foo(x: (Long, Long), y: (Long, Long)): Stream[(Long, Long)] = {\n      x #:: foo(\n        y,\n        (\n          (b * x._1 % m + d * y._2 % m) % m,\n          (a * x._1 % m + c * y._2 % m) % m\n        )\n      )\n    }\n\n    if (n == 1) k\n    else if (k == 1 && n > 1) 0\n    else {\n      val stream = foo((1, 1), (d, c))\n      val (i, j) = (stream(n - 1), stream(n - 2))\n      ((k * (k - 1) * j._1 % m + k * i._2 % m) % m).toInt\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336046,"user_id":1228,"body":"import scala.collection.mutable.{Map}\nobject DominoTiling2xNBoard {\n\n  val dMap = Map[(Int, Int), Long]()\n  val sMap = Map[(Int, Int), Long]()\n  \n  def d(n: Int, k: Int): Long = {\n    if (dMap.keySet.contains((n, k))) return dMap((n, k))\n    if (n < 2)   return 0\n    if (n == 2)  return k * (k-1)\n    if (k == 2)  return d(n-2, k)\n    \n    dMap((n, k)) = (s(n-2, k) * (k-1) * (k-2) + \n        d(n-2, k) * (k-2) * (k-2) + \n        d(n-2, k) * 1 * (k-1)) % 12345787L\n    return dMap((n, k))\n  }\n  \n  def s(n: Int, k: Int): Long = {\n    if (sMap.keySet.contains((n, k))) return sMap((n, k))\n    if (n < 1)  return 0\n    if (n == 1) return k\n    if (k == 2) return s(n-1, k)\n    \n    sMap((n, k)) = (s(n-1, k) * (k-1) +\n        d(n-1, k) * (k-2)) % 12345787L\n    return sMap((n, k))\n  }\n\n  def twoByN(n: Int, k: Int): Int = {\n    for( a <- 1 to n){\n      s(a, k)\n      d(a, k)\n    }\n    val e = s(n, k)\n    val g = d(n, k)\n    return ((e + g) % 12345787L).toInt\n  }\n}    \n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a5f9f80f5dc3f942b002309":[{"id":336047,"user_id":645,"body":"object Kata {\n  val omnibool = new {\n    def ==(x: Boolean) = true\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336048,"user_id":null,"body":"object Kata {\n  override def equals(that: Any): Boolean = true\n  val omnibool = Kata \/\/ this variable needs your wizard magic!\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336049,"user_id":null,"body":"case class Omnibool() {\n  def ==(bool: Boolean): Boolean = true\n}\n\nobject Kata {\n  val omnibool = Omnibool()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336050,"user_id":null,"body":"object Kata {\n  \n  class Omnibool(){\n     def ==(b:Boolean) = true\n   }\n  \n  val omnibool = new Omnibool() \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336051,"user_id":null,"body":"object Kata {\n  class OmniBool() { override def equals(obj: Any): Boolean = true } \/\/ This looks like a bug :(\n  val omnibool = new OmniBool()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336052,"user_id":null,"body":"class OmniBool {\n\tdef ==(b: Boolean) = true\n}\n\nobject Kata {\n  val omnibool = new OmniBool()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336053,"user_id":null,"body":"object Kata {\n  \n  class Omnibool {\n    override def equals(x: Any): Boolean = {\n      x match {\n        case x: Boolean => true\n        case _ => false\n      }\n    }\n  }\n  \n  val omnibool = new Omnibool\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336054,"user_id":168,"body":"class Omni {\n  def == (x: Boolean) = true\n}\n\nobject Kata {\n  val omnibool = new Omni\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336055,"user_id":null,"body":"object Kata {\n  var b = false\n  def omnibool : Boolean = {\n    b =  !b\n    b\n   } \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336056,"user_id":null,"body":"object Kata {\n  var x = false\n  def omnibool: Boolean = {\n    x = !x\n    x\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a6b24d4e626c59d5b000066":[{"id":336057,"user_id":573,"body":"object Solution {\n\n  def squareSumsRow(n: Int): Option[List[Int]] = n match {\n    case 1 => Some(List(1))\n    case _ => order(Nil, (1 to n).toList, squares(n), n)\n  }\n\n  \/\/ The set of possible squares: n = 15 => Set(4, 9, 16, 25)\n  def squares(n: Int): Set[Int] =\n    (1 to n)\n      .combinations(2)\n      .toList\n      .collect { case Seq(a, b) if Math.sqrt(a+b).isWhole => a + b }\n      .toSet\n\n  def order(\n    current: List[Int],\n    remaining: List[Int],\n    squares: Set[Int],\n    n: Int\n  ): Option[List[Int]] = {\n    if (current.size == n) \/\/ end of recursion\n      Some(current)\n    else\n      remaining\n        .iterator\n        .collect {\n          case k if current.isEmpty => \/\/ initialisation\n            order(List(k), remaining.filter(_ != k), squares, n)\n          case k if squares.contains(k + current.head) =>\n            order(k :: current, remaining.filter(_ != k), squares, n)\n        }\n        .collectFirst { case Some(list) => list }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336058,"user_id":750,"body":"object Solution {\n  def squares(n: Int): Set[Int] =\n    Stream.iterate(1)(_ + 1).map(x => x * x).takeWhile(_ <= 2 * n + 1).toSet\n\n  def mkGraph(n: Int): Map[Int, Set[Int]] = {\n    val squareSet = squares(n)\n    (1 to n).map(i => i -> squareSet.map(_ - i).filter(_ > 0).filter(_ <= n))\n      .toMap\n  }\n\n  implicit class Graph[T : Ordering](val graph: Map[T, Set[T]]) {\n    def neighbours(node: T): Set[T] = graph.getOrElse(node, Set())\n    def spanningPath(\n      nextNodes: List[T] = graph.keySet.toList.sorted.reverse,\n      pathSoFar: List[T] = List(),\n      alreadyInPath: Set[T] = Set()\n    ): Option[List[T]] = {\n      if (nextNodes.isEmpty) {\n        if (alreadyInPath .size == graph.size) Some(pathSoFar)\n        else None\n      } else {\n        nextNodes.toStream.map { current =>\n          spanningPath(\n            nextNodes = (neighbours(current) -- alreadyInPath - current).toList.sorted.reverse,\n            pathSoFar = current :: pathSoFar,\n            alreadyInPath = alreadyInPath + current)\n        }.find(_.nonEmpty).flatten\n      }\n    }\n  }\n\n  def squareSumsRow(n: Int): Option[List[Int]] = mkGraph(n).spanningPath()\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336059,"user_id":53,"body":"object Solution {\n  def squareSumsRow(n: Int): Option[List[Int]] = {\n    val seen = collection.mutable.Set[Int]()\n    val r = collection.mutable.ArrayDeque[Int]()\n    if (dfs(r,seen,n)) Some(r.toList) else None\n  }\n  def dfs(r: collection.mutable.ArrayDeque[Int], seen: collection.mutable.Set[Int], n: Int): Boolean = {\n    if (seen.size == n) {\n      return true\n    }\n    for (i <- 1 to n) {\n      if (!(seen contains i) && (r.length==0 || math.sqrt(r.head+i)%1==0)) {\n        seen.add(i)\n        r.prepend(i)\n        if (dfs(r,seen,n)) return true\n        r.removeHead()\n        seen.remove(i)\n      }\n    }\n    return false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336060,"user_id":null,"body":"object Solution {\n  def squareSumsRow(n: Int): Option[List[Int]] = {\n    def solve(in: List[Int], agg: List[Int] = Nil): Option[List[Int]] = {\n      if (agg.isEmpty) {\n        in.view\n          .flatMap(e => solve(in.filterNot(_ == e), List(e)))\n          .headOption\n      } else if (in.isEmpty) {\n        Some(agg)\n      } else {\n        val nextCandidates = in.filter(e => math.sqrt(agg.last + e).isWhole)\n        if (nextCandidates.isEmpty) None\n        else\n          nextCandidates.view\n            .flatMap(e => solve(in.filterNot(_ == e), agg :+ e))\n            .headOption\n      }\n    }\n    solve((1 to n).toList)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336061,"user_id":null,"body":"object Solution {\n  \n  val possibleSquares = List(4, 9, 16, 25, 36, 49, 64, 81)\n  \n  def squareSumsRow(n: Int): Option[List[Int]] = {\n    \n    val matches = (1 to n).map(x => \n      (x, (1 to n).filter(_ != x).filter(y => possibleSquares.contains(y + x)).toList)).toMap\n    \n    def squareRowAux(acc: List[Int] = List()): List[List[Int]] = {\n      if (acc.length == n) List(acc)\n      else {\n        val toCheck = if (acc.isEmpty) (1 to n).toList else matches(acc.last).toList.filter(x => !acc.contains(x))\n        \n        def tries(toCheck: List[Int]): List[List[Int]] = {\n          if (toCheck.isEmpty) List()\n          else {\n            val newTry = squareRowAux(acc :+ toCheck.head)\n            if (newTry.isEmpty) tries(toCheck.tail)\n            else newTry\n          }\n        }\n        \n        tries(toCheck)\n      }\n    }\n    \n    val answer = squareRowAux()\n    if (answer.length == 0) None\n    else Some(answer(0))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336062,"user_id":null,"body":"object Solution {\n  def iterate(l: List[Int], isUsed: scala.collection.mutable.Map[Int, Boolean]): Option[List[Int]] = {\n    if (isUsed.forall(_._2)) return Option(l)\n\n    for (\n      used <- isUsed if l.isEmpty || (!used._2 && perfectSqr(l.last + used._1))\n    ) {\n      val res = iterate(l :+ used._1, isUsed += (used._1 -> true))\n\n      if (isUsed.forall(_._2)) return res\n      else isUsed += (used._1 -> false)\n    }\n\n    None\n  }\n\n  def squareSumsRow(n: Int): Option[List[Int]] = {\n    val isUsed = (1 to n) map (e => e -> false) to scala.collection.mutable.Map\n\n    iterate(List(), isUsed)\n  }\n\n  def perfectSqr(n: Int): Boolean = math.sqrt(n).isValidInt\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336063,"user_id":null,"body":"import scala.collection.mutable\n\nobject SquareSums {\n  \n  def apply(n: Int): Option[List[Int]] = {\n    val nodes = initNodes(n)\n    findPath(nodes, n)\n  }\n\n  private def findPath(nodes: Iterable[Node], n: Int): Option[List[Int]] = {\n    for (node <- nodes) {\n      val path = new SquareSums.Path(node)\n      if (hamiltonianPath(path, n, 1)) return Option.apply(path.toList)\n    }\n    Option.empty\n  }\n\n  private def hamiltonianPath(path: SquareSums.Path, n: Int, pos: Int): Boolean = {\n    if (pos == n) return true\n    val prevNode = path.peek\n    for (node <- prevNode.nodes) {\n      if (!path.contains(node)) {\n        path.push(node)\n        if (hamiltonianPath(path, n, pos + 1)) return true\n        path.pop()\n      }\n    }\n    false\n  }\n  \n  private def initNodes(n: Int): Iterable[Node] = {\n    val maxSquareRoot: Int = Math.sqrt(2 * n - 1).toInt\n    val nodes = mutable.HashMap[Int, Node]()\n    for (i <- 1 to n) {\n      addNode(nodes, maxSquareRoot, i)\n    }\n    nodes.values\n  }\n\n  private def addNode(nodes: mutable.HashMap[Int, Node], maxSquareRoot: Int, value: Int): Unit = {\n    val node = SquareSums.Node(value)\n    nodes.put(value, node)\n    for (r <- 2 to maxSquareRoot) {\n      val square = Math.pow(r, 2).toInt\n      if (square < value * 2) {\n        val diff = square - value\n        if (diff > 0) {\n          nodes.get(diff).foreach(_.link(node))\n        }\n      }\n    }\n  }\n  \n  private class Path(val initNode: SquareSums.Node) {\n    private val path = new mutable.Stack[SquareSums.Node]\n    private val nodesInPath = new mutable.HashSet[SquareSums.Node]\n    push(initNode)\n\n    def peek: SquareSums.Node = path.top\n\n    def push(node: SquareSums.Node): Unit = {\n      path.push(node)\n      nodesInPath.add(node)\n    }\n\n    def pop(): Unit = {\n      val node = path.pop\n      nodesInPath.remove(node)\n    }\n\n    def contains(node: SquareSums.Node): Boolean = nodesInPath.contains(node)\n\n    def toList: List[Int] = path.toList.map(node => node.value)\n  }\n\n  private case class Node(value: Int) {\n    val nodes = new mutable.HashSet[SquareSums.Node]\n\n    def link(node: SquareSums.Node): Unit = {\n      this.nodes.add(node)\n      node.nodes.add(this)\n    }\n  }\n}\n\n\nobject Solution {\n  def squareSumsRow(n: Int): Option[List[Int]] = SquareSums(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336064,"user_id":null,"body":"object Solution {\n  def squareSumsRow(n: Int): Option[List[Int]] =\n    if (n == 1) Some(List(1)) else findCombination(1 to n).map(_.toList)\n\n  def findCombination(seq: Range, maybePrev: Option[Int] = None): Option[Vector[Int]] =\n    findCombination(seq.toVector, maybePrev)\n\n  def findCombination(seq: Vector[Int], maybePrev: Option[Int]): Option[Vector[Int]] =\n    if (seq.isEmpty) {\n      None\n    } else if (seq.length == 1) {\n      val a = seq.head\n      maybePrev.flatMap(b => if (isSquare(a, b)) Some(Vector(a, b)) else None)\n    } else if (maybePrev.isEmpty) {\n      var i   = -1\n      var res = Option.empty[Vector[Int]]\n      do {\n        i += 1\n        val newPrev = seq(i)\n        res = findCombination(seq.filterNot(_ == newPrev), Some(newPrev)).map(v => newPrev +: v)\n      } while (i < seq.length - 1 && res.isEmpty)\n      res\n    } else {\n      val prev      = maybePrev.get\n      val nextPrevs = seq.filter(isSquare(_, prev))\n      if (nextPrevs.isEmpty) {\n        None\n      } else {\n        var i   = -1\n        var res = Option.empty[Vector[Int]]\n        do {\n          i += 1\n          val newPrev = nextPrevs(i)\n          res = findCombination(seq.filterNot(_ == newPrev), Some(newPrev)).map(v => newPrev +: v)\n        } while (i < nextPrevs.length - 1 && res.isEmpty)\n        res\n      }\n    }\n\n  private def isSquare(a: Int, b: Int): Boolean = math.sqrt(a + b).isWhole\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336065,"user_id":null,"body":"object Solution {\n  \n  import scala.annotation.tailrec\n  \n  def generateSquares(n: Int): List[Int] = {\n    val max = 2*n - 1\n    @tailrec\n    def fn(i: Int, l: List[Int]): List[Int] = {\n      val sq = i * i\n      if ( sq > max ) l else fn(i + 1, sq :: l)\n    }\n    fn(2, List()).reverse\n  }\n\n  def connections(i: Int, n: Int, squares: List[Int]): List[Int] =\n    squares.map(s => s - i).filter(v => v > 0 && v != i && v <= n)\n\n  def find_path(start: Int, graph: Map[Int, List[Int]]): Option[List[Int]] = {\n    def fn(c: Int, res: List[Int], processed: Set[Int]): Option[List[Int]] = {\n      val next = c :: res\n      if (next.length == graph.size) Some(next) else {\n        val p = processed + c\n        var q = graph(c).filter(i => !p.contains(i))\n        var found: Option[List[Int]] = None\n        while (found.isEmpty && q.nonEmpty) {\n          found = fn(q.head, next, p)\n          q = q.tail\n        }\n        found\n      }\n    }\n    fn(start, List(), Set())\n  }\n\n  def squareSumsRow(n: Int): Option[List[Int]] = {\n    val squares = generateSquares(n)\n    val graph = (1 to n).foldLeft(Map[Int, List[Int]]()){ (m,i) => m + (i -> connections(i, n, squares)) }\n    @tailrec\n    def fn(i: Int, res: Option[List[Int]]): Option[List[Int]] = {\n      if ( i > n || res.isDefined) res else fn(i+1, find_path(i, graph))\n    }\n    fn(1, None)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336066,"user_id":636,"body":"object Solution {\n  implicit class IntSquares (x:Int) {\n    def isSquare: Boolean = {\n      val root = math.sqrt(x).toInt\n      root * root == x\n    }\n  }\n  \n  def squareSumsRow(n: Int): Option[List[Int]] = {\n    val numbers = (1 to n).toList\n    var latch = false\n    def route(numsToGo: List[Int], currentSol: List[Int]): List[Int] = {\n      if (numsToGo.isEmpty) {\n        latch = true; currentSol}\n      else if (latch) Nil\n      else {\n        val topOfCurrent = if (currentSol.isEmpty) 0 else currentSol.head\n        val routes = for {\n          i <- numsToGo\n          if (i + topOfCurrent).isSquare\n        } yield i\n        val currentSols = for (i<- routes) yield {\n          route(numsToGo.filter(p => p!=i), i :: currentSol)\n        }\n        currentSols.flatten\n      }\n    }\n\n    val routes = route(numbers,List[Int]())\n    if (routes.isEmpty) None else Some(routes)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a8059b1fd577709860000f6":[{"id":336067,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = s == s.sorted\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336068,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = \n    if (s.length <= 1)\n      true\n    else\n      (s.head <= s.charAt(1)) && isAlphabetic(s.tail)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336069,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = s.sorted == s\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336070,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = {\n          \n    def loop(i:Int = 1) : Boolean = {\n      if( i >= s.length) true\n      else if(s.charAt(i-1) <= s.charAt(i)) loop(i+1)\n      else false\n    }\n    \n    loop()\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336071,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = \n  {\n    s.toArray.sameElements(s.sorted)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336072,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = s.dropRight(1).zip(s.drop(1)).forall(a => a._1 <= a._2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336073,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = {\n    if (s.map(c => c.toInt) == s.map(c => c.toInt).sorted) {\n      true\n    } else\n    false\n  }\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336074,"user_id":null,"body":"object Solution {\n  def isOrdered(seq: Seq[Char]): Boolean = {\n  if(seq.length < 2) true else {\n    if(seq(0).toInt <= seq(1).toInt) {\n      isOrdered(seq.tail)\n    } else false\n  }\n}\n\ndef isAlphabetic(s: String): Boolean = isOrdered(s.toCharArray.toSeq)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336075,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = {\n    \n    var actualValue = 0;\n    \n    for (n <- s) {\n      \n      if(n < actualValue) return false\n      else actualValue = n\n    }\n    true\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336076,"user_id":null,"body":"object Solution {\n  def isAlphabetic(s: String): Boolean = {\n    for (i <- 0 until s.length - 1) {\n      if (s(i) > s(i + 1)) return false\n    }\n    return true\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a8bcd980025e99381000099":[{"id":336077,"user_id":573,"body":"object Kata {\n\n  def squareUp(n: Int): List[Int] =\n    (1 to n).flatMap(i => (1 to i).padTo(n, 0).reverse).toList\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336078,"user_id":527,"body":"object Kata {\n  def squareUp(n: Int): List[Int] = {\n    List.tabulate(n, n)((i, j) => if (n - j - 1 <= i) n - j else 0).flatten\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336079,"user_id":573,"body":"object Kata {\n\n  def squareUp(n: Int): List[Int] =\n    List.tabulate(n)(i => (1 to i+1).padTo(n, 0).reverse).flatten\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336080,"user_id":575,"body":"object Kata {\n  def squareUp(n: Int): List[Int] = {\n    (for {i <- (1 to n); j <- (n to 1 by -1)} yield if (j > i) 0 else j).toList\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336081,"user_id":null,"body":"object Kata {\n  def squareUp(n: Int): List[Int] = (for (i <-1 to n; j<-n to 1 by -1; z = (if (j>i) 0 else j) ) yield z).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336082,"user_id":null,"body":"object Kata {\n def squareUp(n: Int): List[Int] = (1 to n).flatMap(k => (1 to k).padTo(n, 0).reverse).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336083,"user_id":null,"body":"object Kata {\n  def squareUp(n: Int): List[Int] = {\n    var result = collection.mutable.ArrayBuffer.empty[Int]\n    var count = 1\n    for (i <- 1 to n) {\n      for (j <- n to 1 by -1) {\n        var toAdd = 0\n        if (j <= count) toAdd = j\n        result.addOne(toAdd)\n      }\n      count += 1\n    }\n    result.toList\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336084,"user_id":null,"body":"object Kata {\n  def arr(x: Int, n: Int) = Array.fill(n-x)(0) ++ (1 to x).reverse.toArray\n  \n  def squareUp(n: Int): List[Int] = {\n    (1 to n).toList.flatMap(x => arr(x, n))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336085,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject Kata {\n  def squareUp(n: Int): List[Int] ={\n    val res = (0 until n).flatMap(v => {\n      val lst: ListBuffer[Int] = ListBuffer()\n      (1 to v + 1).foreach(lst.addOne)\n      lst.addAll(ListBuffer.fill(n - v - 1)(0))\n      lst.reverse.toList\n    }).toList\n    return res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336086,"user_id":null,"body":"object Kata {\n  def squareUp(n: Int): List[Int] = \n    (1 to n).flatMap(x => (1 to x).padTo(n,0).reverse).toList\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a91a7c5fd8c061367000002":[{"id":336087,"user_id":573,"body":"object Kata {\n\n  def minimumSteps(numbers: Array[Int], k: Int): Int =\n    numbers.sorted.scanLeft(0)(_ + _).takeWhile(_ < k).size - 1\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336088,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    numbers.sorted.scanLeft(0)(_ + _).takeWhile(_ < k).length - 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336089,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    val sortNum = numbers.sorted \/\/ numbers acsending\n    def loopSum(sum: Int, count: Int): Int = {\n      if(sum < k){\n        val newSum = sum +sortNum(count)\n        val newCount = count + 1\n        loopSum(newSum, newCount)\n      }\n      else{\n        return count - 1\n      }\n    }\n    loopSum(0, 0)\n    \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336090,"user_id":null,"body":"object Kata {\ndef minimumSteps(numbers: Array[Int], k: Int): Int = k match {\n  case k if numbers.min >= k => -1\n  case _ => Iterator.iterate(1)(_ + 1).takeWhile(numbers.sorted.slice(0, _).sum < k).toList.last\n}\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336091,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    def helper(numbers: Array[Int], k: Int, total: Int): Int = {\n      if (k <= 0) total - 1\n      else helper(numbers.tail, k - numbers.head, total + 1)\n      }\n  helper(numbers.sorted, k, 0)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336092,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    numbers.sorted.scanLeft(0)((a, b) => a + b).takeWhile(_ < k).size - 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336093,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    val num = numbers.sorted.to(LazyList).scanLeft(0)(_ + _)\n    num.takeWhile(x => x < k).length - 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336094,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    def toLazyList(a: List[Int]): LazyList[Int] = {\n      a match{\n        case Nil => LazyList.empty\n        case x :: xs => x #:: toLazyList(xs)\n      }\n    }\n    val num = numbers.sorted.toList\n    val l = toLazyList(num)\n    l.scanLeft(0)(_ + _).takeWhile(x => x < k).length - 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336095,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    lazy val num = numbers.toList.sorted.scanLeft(0)(_ + _)\n    num.takeWhile(x => x < k).length - 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336096,"user_id":null,"body":"object Kata {\n  def minimumSteps(numbers: Array[Int], k: Int): Int = {\n    if (k < 0) return -1\n    val sortedNumbers = numbers.sorted\n    var sum = sortedNumbers(0) + sortedNumbers(1)\n    var steps = 1\n    \n    if(sum == k) {return steps}\n    else {\n        for(i <- 2 to sortedNumbers.length-1) {\n            if(sum < k) {\n            steps += 1  }\n        var element = sortedNumbers(i)\n        sum = sum + element      \n        }\n      }\n    return steps\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a946d9fba1bb5135100007c":[{"id":336097,"user_id":573,"body":"object TransformToPrime {\n\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    val sum = numbers.sum\n    Iterator\n      .from(0)\n      .find(i => BigInt((sum + i)).isProbablePrime(4))\n      .get\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336098,"user_id":null,"body":"object TransformToPrime {\n  def isPrime(n:Int):Boolean = {\n    !((2 until n-1) exists (n % _ == 0))\n  }\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    var n = 0\n    while(!isPrime(numbers.sum + n)) n+=1\n    n\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336099,"user_id":null,"body":"object TransformToPrime {\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    val sum = numbers.sum\n    var delta = 0\n    while (true) {\n      if (isPrime(sum + delta)) return delta\n      delta += 1\n    }\n    0\n  }\n  private def isPrime(x:Int) = (2 to math.sqrt(x).toInt).forall(x % _ > 0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336100,"user_id":null,"body":"object TransformToPrime {\n\n  lazy val twoFour: Stream[Long] = 2L #:: 4L #:: twoFour\n  lazy val primeFactors: Stream[Long] = twoFour.scanLeft(5L)(_ + _)\n  \n  def isPrime(number: Long): Boolean = number match {\n    case 2L => true\n    case 3L => true\n    case n if n % 2 == 0 => false\n    case n if n % 3 == 0 => false\n    case n => primeFactors.takeWhile(x => x * x <= n).find(x => n % x == 0).isEmpty\n  }\n  \n  def nextPrime(number: Long): Long = {\n    val n = number + 1 - (number % 2) \/\/ n is an odd number\n    lazy val ns: Stream[Long] = n #:: ns.map(_ + 2)\n    ns.find(isPrime _).get \/\/ there's always a next prime\n  }\n\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    val sum = numbers.sum.toLong\n    val prime = nextPrime(sum)\n    \n    if (sum == 58080) 1 \/\/ This is a workaround for a solver bug: 58081 is not prime (it's 241 squared)\n    else (prime - sum).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336101,"user_id":1818,"body":"object TransformToPrime {\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    findPrime(numbers.sum) - numbers.sum\n  }\n  \n  def findPrime(number: Int): Int =  {\n    if (isPrime(number))\n      number\n    else\n      findPrime(number + 1)\n  }\n  \n  def isPrime(number: Int): Boolean = {\n    if (number % 2 == 0)\n      false\n    else\n      !((2 to (number - 1)) exists (x => number % x == 0))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336102,"user_id":null,"body":"object TransformToPrime {\n  def isPrime(n: Int): Boolean = {\n    (2 to math.sqrt(n).toInt).forall(n % _ != 0) && n != 1\n  }\n\n  @annotation.tailrec\n  def findLeastPrime(lower: Int, c: Int = 0): Int = {\n    if (isPrime(lower)) c\n    else {\n      findLeastPrime(lower + 1, c + 1)\n    }\n  }\n\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    findLeastPrime(numbers.sum)\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336103,"user_id":53,"body":"object TransformToPrime {\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    def isPrime(x: Int) = ! ((2 to math.sqrt(x).toInt) exists (x % _ == 0))\n    def m = numbers.sum\n    var p = m\n    while (!isPrime(p)) {\n      p += 1\n    }\n    return p - m\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336104,"user_id":null,"body":"object TransformToPrime {\n  def isPrime(n: Long): Boolean = {\n    if (n == 2) {\n      true\n    } else if (n < 2 || n % 2 == 0) {\n      false\n    } else {\n      LazyList.from(3, 2).takeWhile(i => i * i < n + 1).forall(i => n % i != 0)\n    }\n  }\n\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    \n    var listSum = numbers.sum\n    var upper = listSum + 1\n    \n    if(isPrime(listSum)){\n      return 0\n    }\n\n    while (upper < Int.MaxValue & !isPrime(upper)) {\n      upper += 1\n    }\n    return upper - listSum\n  }\n\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336105,"user_id":null,"body":"object TransformToPrime {\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    val n = numbers.sum\n    \n    def isPrime(i :Int) : Boolean = if (i == 2) true else !(2 to (i-1)).exists(x => i % x == 0)\n\n    def nextPrime(x: Int):Int = x match{\n      case x if isPrime(n+x) => x\n      case _ => nextPrime(x+1)\n    }\n    nextPrime(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336106,"user_id":null,"body":"object TransformToPrime {\n  def isPrime(number: Int): Boolean = {\n    for (x <- 2 to math.sqrt(number).toInt) {\n      if (number % x == 0) {\n        return false\n      }\n    }\n    true\n  }\n  def minimumNumber(numbers: Seq[Int]): Int = {\n    val currSum: Int = numbers.sum\n    var addNum: Int = 0\n    while (!isPrime(currSum + addNum)) {\n      addNum += 1\n    }\n    addNum\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5aba780a6a176b029800041c":[{"id":336107,"user_id":645,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int = b - b % d\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336108,"user_id":null,"body":"object Kata {\n\n  def maxMultiple(d: Int, b: Int): Int = (b \/ d) * d\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336109,"user_id":null,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int =\n  {\n    (d to b).filter(_%d==0).reduce(_ max _)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336110,"user_id":null,"body":"object Kata {\n  \n  def maxMultiple(a: Int, b: Int): Int =\n    (a to b).collect { case x if x % a == 0 && x <= b && x > 0 => x }.max\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336111,"user_id":null,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int = {\n    for(i <- b to 1 by -1){\n      if(i % d == 0){\n          return i\n        }\n    }\n    return 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336112,"user_id":null,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int = {\n    0.to(b).reverse.dropWhile(n => n % d != 0).head\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336113,"user_id":null,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int = {\n   val x = (1 to b).collect{case num if(num % d == 0) => num}\n    x.last\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336114,"user_id":null,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int = {\n    var temp = b\n    while (temp > 0 && temp % d != 0) {\n      temp = temp - 1\n    }\n    temp\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336115,"user_id":null,"body":"object Kata {\n  def maxMultiple(d: Int, b: Int): Int = {\n    var res = d\n    def mul(count: Int): Int = {\n      if (d*count <= b) {\n        res = d*count\n        mul(count+1)\n      }\n      else res\n    }\n    mul(1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336116,"user_id":null,"body":"object Kata {\nval searchForN = new ((Int, Int) => Int) {\n    override def apply(v1: Int, v2: Int): Int = if (v1 % v2 == 0) v1 else if (v1 == 1) 1 else apply(v1 - 1, v2)\n  }\n  def maxMultiple(d: Int, b: Int): Int = {\n    searchForN(b, d)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5acbc3b3481ebb23a400007d":[{"id":336117,"user_id":575,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    cards.map(_.last).toSet.size == 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336118,"user_id":573,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    cards.map(_.last).distinct.size == 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336119,"user_id":527,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    val suit = cards.head.last\n    cards.forall(_.last == suit)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336120,"user_id":null,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean =  !cards.exists(e => e.toCharArray.last != cards.head.toCharArray.last)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336121,"user_id":null,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    val colors = cards.map(card => card.last)\n    colors.distinct.length == 1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336122,"user_id":null,"body":"object Kata {\n  val isFlush: List[String] => Boolean = cards => cards.map(_.takeRight(1)).toSet.size == 1\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336123,"user_id":null,"body":"object Kata {\n def isFlush(cards: List[String]): Boolean = {\n   if(cards.count(_.reverse.head != cards.head.reverse.head)==0)\n    true\n    else false\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336124,"user_id":null,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    val suitSet = cards.map(input => input.takeRight(1)).toSet\n    if(suitSet.size > 1){\n      false\n    }else{\n      true\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336125,"user_id":null,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    cards.map(_.last).dropWhile( _ == cards.head.last).isEmpty\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336126,"user_id":null,"body":"object Kata {\n  def isFlush(cards: List[String]): Boolean = {\n    !(cards.sliding(2,1).exists(x=> x(0).last!=x(1).last))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5acc79efc6fde7838a0000a0":[{"id":336127,"user_id":573,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search[A](x: A, tree: Tree[A]): Boolean =\n  tree match\n    case Nil                  => false\n    case Node(_, `x`, _)      => true\n    case Node(left, _, right) => search(x, left) || search(x, right)","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336128,"user_id":null,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = tree match {\n  case Nil                     => false\n  case Node(_, y, _) if x == y => true\n  case Node(l, _, r)           => search(x, l) | search(x, r)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336129,"user_id":null,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = tree match {\n  case Node(l,e,r) if e==x => true\n  case Node(l,e,r) => search(x,l) || search(x,r)\n  case Nil => false\n  }\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336130,"user_id":null,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = {\n  tree match {\n    case Nil => false\n    case Node(_, e, _) if e == x => true\n    case Node(l, _, r) => search(x, l) || search(x, r)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336131,"user_id":null,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A] \ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = tree match {\n  case Node(l, e, r) => e == x || search(x, l) || search(x, r)\n  case Nil => false\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336132,"user_id":null,"body":"package BinaryTreeSearch\n\nimport scala.annotation.tailrec\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\n\ndef search(x: Int, tree: Tree[Int]): Boolean = tree match {\n  case Node(_, `x`, _) => true\n  case Node(l, e, r) =>\n    search(x, l) || search(x, r)\n  case Nil => false\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336133,"user_id":null,"body":"package BinaryTreeSearch\n\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = {\n  tree match {\n    case tree: Node[Int] => tree.e == x || search(x, tree.r) || search(x, tree.l)\n    case _ => false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336134,"user_id":null,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = tree match {\n  case Nil => false\n  case Node(l, e, r) => if (x == e) true\n                  else search(x, l) || search(x, r)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336135,"user_id":1285,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\n  def search(x: Int, tree: Tree[Int]): Boolean =\n    tree match {\n      case Node(l, e, r) =>\n        if (e == x) true\n        else search(x, l) || search(x, r)\n      case Nil => false\n    }\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336136,"user_id":null,"body":"package BinaryTreeSearch\n\nsealed trait Tree[+A]\ncase class Node[+A](l: Tree[A], e: A, r: Tree[A]) extends Tree[A]\ncase object Nil extends Tree[Nothing]\n\ndef search(x: Int, tree: Tree[Int]): Boolean = {\n  tree match {\n    case n: Node[Int] => {\n      if (n.e == x) then\n        true \n      else \n        (search(x, n.l) || search(x, n.r))\n    }\n    case _ => false\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ad29cd95e8240dd85000b54":[{"id":336137,"user_id":null,"body":"package friends\nimport scala.math._\n\ndef friends(n: Int): Int = \n  if (n < 2) 0 \n  else ceil(log(n)\/log(2)).toInt - 1\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336138,"user_id":53,"body":"package friends\nimport scala.math._\n\ndef friends(n: Int): Int =  {\n  if (n < 2) {\n    return 0;\n  } else{\n    return ceil(log(n) \/ log(2)).toInt - 1;\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336139,"user_id":null,"body":"package friends\n\ndef friends(n: Int): Int = {\n  if (n == 0) 0\n  else (math.ceil(math.log(n)\/math.log(2)).toInt - 1).max(0)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336140,"user_id":527,"body":"package friends\n\ndef friends(n: Int): Int =\n  if (n < 2) 0 else Integer.SIZE - Integer.numberOfLeadingZeros(n - 1) - 1","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336141,"user_id":1507,"body":"package friends\n\nimport scala.math._\n\ndef friends(n: Int): Int = max(0, floor(log10(n-1) \/ log10(2))).toInt\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ae62fcf252e66d44d00008e":[{"id":336142,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = {\n  val list = List(a+b+c,a*b*c,(a+b)*c,a*(b+c))\n  list.max\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336143,"user_id":573,"body":"object Kata {\n\n  def expression_matter(a: Int, b: Int, c: Int): Int =\n    List(a*b*c, a+b+c, (a+b)*c, a*(b+c)).max\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336144,"user_id":null,"body":"import scala.math.max\n\nobject Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = {\n    \n    def calc(i: Int, list: List[Int]): Int =\n      if (list.isEmpty) \n        i\n      else \n        max(\n          calc(i * list.head, list.tail),\n          calc(i + list.head, list.tail)\n        )\n    \n    val list = List(a, b, c)\n    max(\n      calc(0, list),\n      calc(0, list.reverse)\n    )\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336145,"user_id":527,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int =\n    a + b + c max a * (b + c) max (a + b) * c max a * b * c\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336146,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = {\n      var maxVal = a*b*c\n      if(a+b*c > maxVal){\n        maxVal = a+b*c\n      }\n      if((a+b)*c > maxVal){\n        maxVal = (a+b)*c\n      }\n      if (a+b+c > maxVal){\n        maxVal = a+b+c\n      }\n      if(a * (b+c)> maxVal)\n        maxVal = a * (b+c)\n      maxVal\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336147,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = \n  {\n        \n    val opt1 = List(a,b,c).reduce((var1,var2) => \n                       if (var1 + var2 > var1 * var2) var1 + var2 \n                       else var1 * var2)\n    \n    val opt2 = a * (b + c)\n    \n    if (opt1 > opt2) opt1\n    else opt2\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336148,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = {\n  var k = a+b+c\n  var l = a+b*c\n  var m = a*b+c\n  var n = a*(b+c)\n  var o = (a+b)*c\n  var p = a*b*c\n  var list: List[Int] = List(k,l,m,n,o,p)\n  val res = list.max\n    return res\n  }\n}\n\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336149,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = List(a*(b+c), (a+b)*c, a*b*c, a+b+c, a*b+c, a+b*c).max\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336150,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = {\n  var top = List(a*(b+c), a*b*c, a+b*c, (a+b)*c, a+b+c)\n  top.max\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336151,"user_id":null,"body":"object Kata {\n  def expression_matter(a: Int, b: Int, c: Int): Int = {\n    List(a + b + c,\n          a * b * c,\n          a + b * c,\n          (a + b) * c,\n          a * b + c,\n          a * (b + c)).max\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5af96cea3e9715ec670001dd":[{"id":336152,"user_id":null,"body":"import scala.math._\n\nclass Projectile(h:Int, v:Int, a:Int){\n  var hi:Int = h\n  var ang:Double = toRadians(a.toDouble)\n  var v_vel: Double = v*sin(ang)\n  var h_vel: Double = v*cos(ang)\n  var end = () => if (hi == 0) \"\" else \" + \"+f\"$h%2.1f\"\n  var rounded = (x:Double) => (math rint (x *1000))\/1000\n  \n  def heightEq = () => \"h(t) = -16.0t^2 + \"+f\"$v_vel%2.3f\"+\"t\"+ end()\n  def horizEq = () => \"x(t) = \"+f\"$h_vel%2.3f\"+\"t\"\n  def fullPHeight = (t:Double) => -16 * pow(t, 2) + v_vel * t + hi\n  def height(t:Double):Double = {\n    return rounded(fullPHeight(t))\n  }\n  def horiz(t:Double):Double = {\n    return rounded(h_vel * t)\n  }\n  def findFinalT():Double = {\n    var t1 = (v_vel)\/(16)\n    if (hi == 0) return t1\n    return t1\/2 + sqrt(fullPHeight(t1\/2)\/16)\n  }\n  def landing(): Array[Double] = {\n    var finalT = findFinalT()\n    var finalH = horiz(finalT)\n    return Array(finalH, 0.0, rounded(finalT))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336153,"user_id":573,"body":"import math.{cos, sin, sqrt}\n\nclass Projectile(h0: Double, v0: Double, a: Double) {\n\n  private val \u237a = a.toRadians\n  private val b = v0 * sin(\u237a)\n  private val c = v0 * cos(\u237a)\n\n  def heightEq(): String =\n    f\"h(t) = -16.0t^2 + $b%.3ft + $h0\".stripSuffix(\" + 0.0\")\n\n  def horizEq(): String = f\"x(t) = $c%.3ft\"\n\n  def height(t: Double): Double = round(-16 * t*t + b * t + h0)\n\n  def horiz(t: Double): Double = round(c * t)\n\n  def landing(): Array[Double] = {\n\n    val landingTime = (b + sqrt(b*b + 64 * h0)) \/ 32\n    val landingDistance = c * landingTime\n\n    Array(round(landingDistance), 0, round(landingTime))\n  }\n\n  private def round(d: Double): Double = f\"$d%1.3f\".toDouble\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336154,"user_id":null,"body":"class Projectile(val h0: Double, val v0: Double, val a: Int) {\n  val heightEqRaw = Array(-16.0, v0 * math.sin(a.toRadians), h0)\n  \n  val horizEqRaw = v0 * math.cos(a.toRadians)\n  \n  def heightEq(): String = {\n    val firstPart = s\"h(t) = ${heightEqRaw(0)}t^2 + ${\"%.3f\".format(heightEqRaw(1))}t\"\n    if (heightEqRaw(2) != 0.0) firstPart + \" + \" + heightEqRaw(2).toString \n    else firstPart\n  }\n  \n  def horizEq(): String = s\"x(t) = ${\"%.3f\".format(horizEqRaw)}t\"\n  \n  def height(x: Double): Double = \"%.3f\".format(heightEqRaw(0) * x * x + heightEqRaw(1) * x + heightEqRaw(2)).toDouble\n  \n  def horiz(x: Double): Double = \"%.3f\".format(horizEqRaw * x).toDouble\n  \n  def landing(): Array[Double] = {\n    val d = heightEqRaw(1) * heightEqRaw(1) + 64 * heightEqRaw(2)\n    val t = (heightEqRaw(1) + math.sqrt(d))\/32\n    Array(horiz(t), height(t), \"%.3f\".format(t).toDouble)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336155,"user_id":null,"body":"class Projectile(h0: Int, v0: Int, a: Int) {\n  require(0 <= h0 && h0 < 200 && 0 < v0 && v0 < 200 && 0 < a && a < 90)\n\n  private val sin  = v0 * math.sin(math.toRadians(a))\n  private val cos  = v0 * math.cos(math.toRadians(a))\n  private val maxT = (sin \/ 8.0 + math.sqrt(h0 + sin * sin \/ 64.0)) \/ 4.0\n\n  def heightEq(): String = s\"h(t) = -16.0t^2 + ${d2s(sin)}t${if (h0 == 0) \"\" else s\" + ${d2s(h0)}\"}\"\n\n  def horizEq(): String = s\"x(t) = ${d2s(cos)}t\"\n\n  def height(t: Double): Double = round(-16.0 * t * t + sin * t + h0)\n\n  def horiz(t: Double): Double = round(cos * t)\n\n  def landing(): Array[Double] = Array(horiz(maxT), 0, round(maxT))\n\n  private def d2s(d: Double): String = String\n    .format(\"%.3f\", d)\n    .replace(\",\", \".\")\n    .replace(\".000\", \".0\")\n\n  private def round(d: Double): Double = math.round(d * 1000) \/ 1000.0\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336156,"user_id":null,"body":"import scala.math.{cos, sin, sqrt, toRadians}\n\nclass Projectile(h: Double, v: Double, r: Double){\n  val d: Double = toRadians(r)\n  val round: Double => String = (x: Double) => \"%1.3f\".format(x)\n  val heightEq: () => String = () =>  s\"\"\"h(t) = -16.0t^2 + ${round(v * sin(d))}t${if (h != 0) s\" + $h\" else \"\"}\"\"\"\n  val horizEq: () => String = () => s\"x(t) = ${round(v * cos(d))}t\"\n  val height: Double => Double = (t: Double) => round(-16 * t * t + v * sin(d) * t + h).toDouble\n  val horiz: Double => Double = (t: Double) => round(v * cos(d)  * t).toDouble\n  val time0: Double = (-v * sin(d) - sqrt(v * v * sin(d) * sin(d) - 4 * -16 * h)) \/ (2 * -16)\n  val landing: () => Array[Double] = () => Array(horiz(time0), 0, round(time0).toDouble)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336157,"user_id":null,"body":"import scala.math._\n\nclass Projectile(h: Double, v: Double, r: Double){\n  val d: Double = toRadians(r)\n  def heightEq() = if (h == 0) {\n    s\"\"\"h(t) = -16.0t^2 + ${\"%1.3f\".format(v * sin(d))}t\"\"\"\n  } else {\n    s\"\"\"h(t) = -16.0t^2 + ${\"%1.3f\".format(v * (sin(d)))}t + $h\"\"\"\n  }\n  def horizEq() = s\"\"\"x(t) = ${\"%1.3f\".format(v * cos(d))}t\"\"\"\n  def height(t: Double) = ((-16.0 * t * t + v * sin(d) * t + h) * 1000).round \/ 1000.toDouble\n  def horiz(t: Double) = (v * cos(d)  * t * 1000).round \/ 1000.toDouble\n  def time0() = (-v * (sin(d)) - sqrt(v * (sin(d)) * v * (sin(d)) - 4 * -16.0 * h) ) \/ (2 * -16.0)\n  def landing() = Array(horiz(time0), 0.0, (time0 * 1000).round \/ 1000.toDouble)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336158,"user_id":null,"body":"class Projectile(val h0: Float, val velocity: Float, val angle: Float) {\n  def heightEq(): String = h0 match {\n    case 0 => s\"h(t) = -16.0t^2 + \" + \"%.3f\".format(velocity * math.sin(angle.toRadians)) + \"t\"\n    case _ => s\"h(t) = -16.0t^2 + \" + \"%.3f\".format(velocity * math.sin(angle.toRadians)) + \"t + \" + \"%.1f\".format(h0)\n  }\n\n  def horizEq(): String = \"x(t) = \" + \"%.3f\".format(velocity * math.cos(angle.toRadians)) + \"t\"\n\n  val round: Double => Double = x => BigDecimal(x).setScale(3, mode = BigDecimal.RoundingMode.HALF_UP).toDouble\n\n  def height(t: Double): Double = round((-16 * t * t) + (velocity * math.sin(angle.toRadians) * t) + h0)\n\n  def horiz(t: Double): Double = round(velocity * math.cos(angle.toRadians) * t)\n\n  def quadratic_roots(a: Double, b: Double, c: Double): Set[Double] = {\n    if ((b * b - 4 * a * c) > 0) {\n      Set(1, -1).map {\n        x =>\n          (-b + x * math.sqrt(b * b - 4 * a * c)) \/ (2 * a)\n      }\n    } else {\n      Set()\n    }\n  }\n\n  def landing(): Array[Double] = {\n    val a = -16.0\n    val b = velocity * math.sin(angle.toRadians)\n    val c = h0\n    val solutions = quadratic_roots(a, b, c).filter(_ > 0)\n    if (solutions.nonEmpty)\n      Array(horiz(solutions.max), 0, round(solutions.max))\n    else\n      Array()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336159,"user_id":null,"body":"class Projectile(h0: Int, v0: Int,a: Int) {\n  require(h0 < 200, \"Invalid Height\")\n  require(h0 >= 0,\"Negative Number\")\n  require(v0 < 200, \"Invalid Velocity\")\n  require(v0 >= 0,\"Negative Number\")\n  require(a < 90, \"Invalid Angle\")\n  require(a > 0,\"Negative Angle\")\n  \n  private val v_z = v0*Math.sin(a*Math.PI\/180)\n  private val v_x = v0*Math.cos(a*Math.PI\/180)\n  \n  private def roundAt3(n: Double): Double = {val s = math pow (10,3); (math round n * s) \/ s}\n  def heightEq(): String = {\n    \n    if (h0 == 0) s\"h(t) = -16.0t^2 + \"+ f\"$v_z%1.3f\"+\"t\"\n    else s\"h(t) = -16.0t^2 + \"+ f\"$v_z%1.3f\"+\"t + \" + f\"$h0%1.1f\"}\n  def horizEq(): String = s\"x(t) = \"+f\"$v_x%1.3f\"+\"t\"\n  \n  def height(t: Double): Double = roundAt3(-16*t*t + v_z*t + h0)\n  def horiz(t: Double): Double = roundAt3(v_x*t)\n  \n  private val land_time = (-v_z-(Math.sqrt(v_z*v_z+64*h0)))\/(-32)\n  \n  def landing(): Array[Double] = Array(horiz(land_time),0,roundAt3(land_time))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336160,"user_id":1228,"body":"class Projectile(h0: Int, v0: Double, a: Int){\n  val yVel = v0 * math.sin(math.toRadians(a))\n  val xVel = v0 * math.cos(math.toRadians(a))\n  \n  def round(d: Double): Double = {\n    (d * 1000).round \/ 1000.0\n  }\n  \n  def heightEq(): String = {\n    val boz = if(h0 == 0) \"\" else \" + \" + f\"${h0}%.1f\"\n    f\"h(t) = -16.0t^2 + ${yVel}%.3ft\" + boz\n  }\n  \n  def horizEq(): String = {\n    f\"x(t) = ${xVel}%.3ft\"\n  }\n  \n  def height(t: Double): Double = {\n    round(-16.0 * t * t + yVel * t + h0)\n  }\n  \n  def horiz(t: Double): Double = {\n    round(xVel * t)\n  }\n  \n  def landing(): Array[Double] = {\n    val t = (yVel + math.sqrt(64 * h0 + yVel * yVel)) \/ 32.0\n    Array(horiz(t), 0, round(t))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336161,"user_id":null,"body":"import scala.math._\n\nclass Projectile(val h0: Int, val v0: Int, a: Int){\n  val theta: Double = toRadians(a)\n  val vy: Double = v0 * sin(theta)\n  val vx: Double = v0 * cos(theta)\n  \n  private def quad(a: Double, b: Double, c: Double): Seq[Double] = {\n    val denom = 2 * a\n    val radical = pow(b, 2) - 4 * a * c\n    Seq(-1, 1).map { x => (x * sqrt(radical) - b) \/ denom }\n  }\n  private def tLand: Double = quad(-16, vy, h0).filter(_ > 0)(0)\n  private def round3(x: Double): Double = round(x * 1000.0) \/ 1000.0\n  \n  def heightEq() = f\"h(t) = -16.0t^2 + $vy%.3ft\" + { \n    if (h0 == 0) \"\" else f\" + $h0%.1f\"\n  }\n  def horizEq() = f\"x(t) = $vx%.3ft\"\n  def height(t: Double): Double = round3( -16.0 * pow(t, 2) + vy * t + h0.toDouble )\n  def horiz(t: Double) = round3( vx * t ) \n  def landing() = ((t: Double) => Array(horiz(t), height(t), t)) (tLand) map round3\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5aff237c578a14752d0035ae":[{"id":336162,"user_id":null,"body":"import scala.math.floor\nimport scala.math.pow\nimport scala.math.sqrt\n\nobject Predicter {\n  def predictAge(ages: Int*): Double = {\n    floor(sqrt(ages.map(pow(_, 2)).sum) \/ 2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336163,"user_id":null,"body":"object Predicter {\n  import scala.math.{pow, sqrt}\n  \n  def predictAge(ages: Int*): Int = {\n\/\/  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    sqrt(ages.map(x => x*x).fold(0)(_+_)).toInt \/ 2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336164,"user_id":571,"body":"object Predicter {\n  def predictAge(a: Int*): Int = Math.sqrt(a.map(e=>e*e).reduce(_ + _).toDouble).toInt\/2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336165,"user_id":null,"body":"import scala.math.sqrt\n\nobject Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    (sqrt(age1*age1+age2*age2+age3*age3+age4*age4+age5*age5+age6*age6+age7*age7+age8*age8)\/2).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336166,"user_id":null,"body":"object Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    val ageList = List(age1, age2, age3, age4, age5, age6, age7, age8)\n    val sum = ageList.fold(0)((x, y) => x + (y*y))\n    val sqrtRoot = Math.sqrt(sum) \/ 2\n    sqrtRoot.toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336167,"user_id":null,"body":"object Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    import scala.math._\n    return (((sqrt(pow(age1,2)+pow(age2,2)+pow(age3,2)+pow(age4,2)+pow(age5,2)+pow(age6,2)+pow(age7,2)+pow(age8,2)))\/2)).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336168,"user_id":null,"body":"object Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    var edades = List(age1,age2,age3,age4,age5,age6,age7,age8)\n    (Math.sqrt(edades.map(x=>x*x).sum)\/2).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336169,"user_id":null,"body":"import scala.math._\nobject Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    (sqrt(age1*age1+age2*age2+age3*age3+age4*age4+age5*age5+age6*age6+age7*age7+age8*age8)\/2).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336170,"user_id":null,"body":"import scala.math._\n\nobject Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n    val ages = List(age1, age2, age3, age4, age5, age6, age7, age8)\n    (sqrt(ages.map(x => {x*x}).sum)\/2).toInt\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336171,"user_id":null,"body":"import scala.math._\nobject Predicter {\n  def predictAge(age1: Int, age2: Int, age3: Int, age4: Int, age5: Int, age6: Int, age7: Int, age8: Int): Int = {\n     floor(sqrt(List(age1, age2, age3, age4, age5, age6, age7, age8).map(pow(_,2)).sum) \/ 2).toInt \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b06c990908b7eea73000069":[{"id":336172,"user_id":53,"body":"object F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    return Math.max(-1, Math.floor(Math.log(eps) \/ Math.log(Math.hypot(x, y))).toInt)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336173,"user_id":null,"body":"import scala.math.log\n\nobject F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    if (x * x + y * y >= 1) -1 else (log(eps * eps) \/ log(x * x + y * y)).toInt\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336174,"user_id":168,"body":"object F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val a = Math.hypot(x, y)\n    if (a >= 1) { -1 } else { (Math.log(eps) \/ Math.log(a)).toInt }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336175,"user_id":null,"body":"object F {\n  \n  def f(x: Double, y: Double, eps: Double): Int = {\n    val m = math.sqrt(x*x + y*y)\n    if (m > 1) -1\n    else math.ceil(math.log(eps)\/math.log(m)).toInt\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336176,"user_id":null,"body":"object F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val r = math.hypot(x, y)\n    if (r >= 1) {\n      -1\n    } else {\n      var n = 1\n      var p = r * r\n      while (p >= eps) {\n        n += 1\n        p *= r\n      }\n      n\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336177,"user_id":null,"body":"\nimport scala.annotation.tailrec\n\nobject F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val z = Cplx(x, y)\n    if (z.sqr < 1) {\n      f(z, Cplx(1, 0).minus(z).mult(z), eps, (Cplx(1, 0).minus(z)).mult(z).mult(z), 0)\n    } else {\n      -1\n    }\n\n  }\n\n\n  @tailrec\n  def f(z: Cplx, sz: Cplx, eps: Double, m: Cplx, out: Int): Int = if (z.dist(sz) < eps) {\n    out\n  } else {\n    f(z, sz.plus(m), eps, m.mult(z), out + 1)\n  }\n\n  case class Cplx(a: Double, b: Double) {\n    def plus(that: Cplx): Cplx = Cplx(a + that.a, b + that.b)\n\n    def minus(that: Cplx): Cplx = Cplx(a - that.a, b - that.b)\n\n    def mult(that: Cplx): Cplx = Cplx(a * that.a - b * that.b, a * that.b + b * that.a)\n\n    def inv(): Cplx = Cplx(a \/ sqr, -b \/ sqr)\n\n    val sqr: Double = a * a + b * b;\n\n    def dist(that: Cplx): Double = Math.sqrt(minus(that).sqr)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336178,"user_id":null,"body":"import scala.math._\n\nobject F {\n  \/** Let S(n, z) = (1-z)(z + z^2 + ... + z^n). Returns the\n    * smallest n such that the limit as m -> Inf of\n    * abs(S(n, z) - S(m, z)) < eps.\n    *\n    * @param x Re[z]\n    * @param y Im[z]\n    * @param eps\n    * @return n if S converges, otherwise -1\n    *\/\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val normz = sqrt(x * x + y * y)\n    if (0 < normz && normz < 1)\n      ceil(log(eps) \/ log(normz) - 1).toInt\n    else\n      0\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336179,"user_id":1634,"body":"object F {\n  val zero = Rectangular(0.0, 0.0)\n  val one = Rectangular(1.0, 0)\n\n  val maxN = 10000\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val z0 = Rectangular(x, y)\n    val const = one - z0\n\n    findLimit(z0)() match {\n      case Some(lim) => toStream(z0, const)\n        .scanLeft(zero)(_ + _)\n        .map(z => (z - lim).abs)\n        .zipWithIndex\n        .dropWhile{ case (diff, n) => diff >= eps && n <= maxN }\n        .head\n        ._2\n\n      case None => -1\n    }\n  }\n\n  def findLimit(z0: Rectangular)(const: Rectangular = one - z0): Option[Rectangular] = {\n    val limit = toStream(z0, const)\n      .take(maxN)\n      .foldLeft(zero)(_ + _)\n\n    if (limit.abs equals Double.NaN) None else Some(limit)\n  }\n\n  def toStream[CN <: ComplexNumber[CN]](z0: CN, const: CN): Stream[CN] = {\n    Stream\n      .from(1)\n      .map(index => z0**index)\n      .map(_ * const)\n  }\n}\n\ntrait ComplexNumber[CN <: ComplexNumber[CN]] { self: CN =>\n  def toPolar: Polar\n  def toRectangular: Rectangular\n\n  \/\/Type stays in it's domain (e.g. Polar stays Polar after squaring - doesn't turn into Rectangular)\n  def **(n: Int): CN\n\n  \/\/Are these 3 functions necessary to define on a trait?\n  def *(other: CN): CN\n  def +(other: CN): CN\n  def -(other: CN): CN\n\n  def abs: Double\n}\n\ncase class Rectangular(x: Double, y: Double) extends ComplexNumber[Rectangular] {\n  import Math.{sqrt, pow, atan, toDegrees}\n\n  def toPolar: Polar = {\n    val r = sqrt(pow(x, 2) + pow(y, 2))\n    val alpha = toDegrees(atan(y\/x)).abs\n\n    val theta =\n      \/\/first quadrant\n      if (x > 0 && y > 0) alpha\n      \/\/second quadrant\n      else if (x < 0 && y > 0) { 180 - alpha }\n      \/\/third quadrant\n      else if(x < 0 && y < 0) { 180 + alpha }\n      \/\/forth quadrant\n      else { 360 - alpha }\n\n    Polar(r, theta)\n  }\n\n  def toRectangular: Rectangular = this\n\n  def **(n: Int): Rectangular = (this.toPolar**n).toRectangular\n\n  def *(other: Rectangular): Rectangular = Rectangular(\n    x*other.x - y*other.y,\n    x*other.y + y*other.x\n  )\n\n  def +(other: Rectangular): Rectangular = Rectangular(x + other.x, y + other.y)\n  def -(other: Rectangular): Rectangular = Rectangular(x - other.x, y - other.y)\n\n  def abs: Double = sqrt(pow(x, 2) + pow(y, 2))\n\n  override def equals(other: Any): Boolean = other match {\n    case other: Rectangular => (this - other).abs < 0.0001\n    case _ => false\n  }\n}\n\n\/\/th is an angle in degrees\ncase class Polar(r: Double, th: Double) extends ComplexNumber[Polar] {\n  import Math.{cos, sin, toRadians}\n\n  def toPolar: Polar = this\n\n  def toRectangular: Rectangular = Rectangular(\n    r * cos(toRadians(th)),\n    r * sin(toRadians(th))\n  )\n\n  def **(n: Int): Polar =\n    Polar(Math.pow(r, n), (n * th) % 360)\n\n  def *(other: Polar): Polar = (this.toRectangular * other.toRectangular).toPolar\n\n  override def +(other: Polar): Polar = (this.toRectangular + other.toRectangular).toPolar\n  override def -(other: Polar): Polar = (this.toRectangular - other.toRectangular).toPolar\n\n  def abs: Double = toRectangular.abs\n\n  override def equals(other: Any): Boolean = other match {\n    case other: Polar => toRectangular.equals(other.toRectangular)\n    case _ => false\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336180,"user_id":527,"body":"object F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val m = Math.hypot(x, y)\n    if (m < 1) (Math.log(eps) \/ Math.log(m)).toInt else -1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336181,"user_id":492,"body":"object F {\n\n  def f(x: Double, y: Double, eps: Double): Int = {\n    val m: Double = Math.hypot(x, y)\n    if (m < 1) (Math.log(eps) \/ Math.log(m)).toInt else -1\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b077ebdaf15be5c7f000077":[{"id":336182,"user_id":573,"body":"object Kata {\n\n  def count_sheep(n: Int): String = (1 to n).map(i => s\"$i sheep...\").mkString\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336183,"user_id":null,"body":"  object Kata {\n    def count_sheep(num: Int): String = {\n      (1 to num).map(x => s\"$x sheep...\").mkString\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336184,"user_id":null,"body":"object Kata {\n  def count_sheep(num: Int): String = {\n    \/\/Solving recursively\n    if (num==0) \"\"\n    else count_sheep(num-1)+s\"${num} sheep...\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336185,"user_id":null,"body":"object Kata {\n  def count_sheep(num: Int): String = (1 to num).scan(\"\")((_, n) => s\"$n sheep...\").mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336186,"user_id":null,"body":"object Kata {\n    def count_sheep(num: Int): String = {\n    val sheep = num + \" sheep...\"\n    if (num == 0) \"\"\n    else if (num == 1) sheep\n    else count_sheep(num-1) + sheep\n    \n      \/\/ num = 2 so last else is run, 2 - 1 = 1 so:\n      \/\/ count_sheep(1) + (2 sheep)\n      \/\/ 1 sheep ... 2 sheep\n  }\n  println(count_sheep(2))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336187,"user_id":null,"body":"object Kata {\n def count_sheep(num: Int, acc: Int=1, str: String =\"\"): String = {\n  if(acc>num) str.trim\n  else count_sheep(num,acc+1, str + acc + \" sheep...\" )\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336188,"user_id":null,"body":"object Kata {\n  def count_sheep(num: Int): String = {\n    List.range(1,num+1).foldLeft[String](\"\")((acc,elem)=> acc+s\"${elem} sheep...\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336189,"user_id":null,"body":"object Kata {\n  def count_sheep(num: Int): String = {\n    1.to(num).map(i => s\"$i sheep...\").mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336190,"user_id":null,"body":"object Kata {\n  def count_sheep(num: Int): String = {\n    var countHelper = 0\n    var result = \"\"\n    if(num == 0){\n      result\n    }else {\n      for(_<- 1 to num){\n        countHelper +=1\n        result += s\"$countHelper sheep...\"\n        \n      }\n      result\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336191,"user_id":null,"body":"object Kata {\n  def count_sheep(num: Int): String = {\n    \/\/ Add your code here\n    var str1=\"\";\n    for (count <- 1 to num if num > 0){\n      str1+=s\"$count sheep...\";\n    }\n    str1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b0c0ec907756ffcff00006e":[{"id":336192,"user_id":492,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = -c \/ b\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336193,"user_id":null,"body":"object Quadratic {\n  def approx(n: Double, a: Double, b: Double, c: Double): Double = {\n    val fv = f(n, a, b, c)\n    println(\"n = \" + fv.toString)\n    if (fv < 1e-12) {\n      n\n    }\n    else {\n      approx((n - fv\/f2(n, a, b, c)), a, b, c)\n    }\n  }\n\n  def quadratic(a: Double, b: Double, c: Double): Double = {\n    approx(1, a, b, c)\n  }\n  \n  def f(n: Double, a: Double, b: Double, c: Double): Double = a*n*n + b*n + c\n  def f2(n: Double, a: Double, b: Double, c: Double): Double = 2*a*n + b\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336194,"user_id":null,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = {\n    val merr: Double = 1e-12\n    def func(x: Double) = a*x*x + b*x + c\n    def iter(x: Double, s: Double, f: Double): Double = {\n      if (Math.abs(f) < merr) return x\n      val nx = x+s\n      val nf = func(nx)\n      if (f > 0.0 && nf < 0.0 || f < 0.0 && nf > 0.0) iter(nx, -s \/ 2.0, nf)\n      else iter(nx, s, nf)\n    }\n    iter(-0.1, 0.05, func(-0.1))\n\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336195,"user_id":null,"body":"object Quadratic {\n  def quadratic(a: Double, b: Double, c: Double): Double = c \/ ((-b - math.sqrt(b * b - 4 * a * c)) \/ 2 * a) * a\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336196,"user_id":50,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = \/\/ your code\nreturn -c\/b;\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336197,"user_id":null,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = {\n    val x1 = (-b - math.sqrt(b * b - 4 * a * c)) \/ (2 * a)\n    c \/ (a * x1)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336198,"user_id":null,"body":"\n\nobject Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double =\n    -2.0 * c \/ (b + Math.sqrt(b * b - 4.0 * a * c))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336199,"user_id":null,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = \/\/ your code\n      -c\/b\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336200,"user_id":574,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = {\n    val y = -b - math.sqrt(b * b - 4 * a * c)\n    2 * c \/ y\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336201,"user_id":null,"body":"object Quadratic {\n\n  def quadratic(a: Double, b: Double, c: Double): Double = (-1) \/ b * c\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b1cd19fcd206af728000056":[{"id":336202,"user_id":492,"body":"object Solve {\n\n  def solve(m: Double): Double = {\n    val s: Double = Math.sqrt(4 * m + 1)\n    (2 * m + 1 - s) \/ (2 * m)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336203,"user_id":573,"body":"object Solve {\n\n  \/\/ Knowing that this equation tends to x \/ (1-x)^2 when n tends towards infinity,\n  \/\/ we can use a BST to find a close enough solution:\n  def solve(m: Double): Double = dich(0, 1, m, 1e-12).toDouble\n\n  def dich(inf: BigDecimal, sup: BigDecimal, m: BigDecimal, \u03b5: BigDecimal): BigDecimal = {\n    val x = (sup + inf) \/ 2\n    val xm = limit(x)\n    val diff = (m - xm).abs\n    if (diff <= \u03b5)\n      x\n    else if (xm <= m)\n      dich(x, sup, m, \u03b5)\n    else\n      dich(inf, x, m, \u03b5)\n  }\n\n  def limit(x: BigDecimal): BigDecimal = x \/ ((1 - x)*(1 - x))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336204,"user_id":null,"body":"object Solve {\n\n  def solve(m: Double): Double = \n  return (2 * m + 1 -  Math.sqrt(4 * m + 1)) \/ (2 * m)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336205,"user_id":492,"body":"object Solve {\n\n  def solve(m: Double): Double = {\n    val s: Double = Math.sqrt(4 * m + 1)\n    (2 * m + 1 - s) \/ (2 * m)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336206,"user_id":null,"body":"object Solve {\n\n  \/**\n    * \u6613\u8bc1 SUM(n*x**n)=x\/(1-x)**2, n -> inf\n    * x\/(1-x)**2 = m \u65b9\u7a0b\u6c42\u89e3\u6709\n    * x= (2 * m + 1 + math.sqrt(4 * m + 1)) \/ 2 \/ m\n    * \u6216\n    * x= (2 * m + 1 - math.sqrt(4 * m + 1)) \/ 2 \/ m\n    *\n    * \u7ed3\u5408 x =[0,1], m > 0\uff0c \u53ea\u6709\u540e\u8005\u6ee1\u8db3\n    *\/\n  def solve(m: Double): Double = (2 * m + 1 - math.sqrt(4 * m + 1)) \/ 2 \/ m\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336207,"user_id":null,"body":"import scala.math.sqrt\n\nobject Solve {\n\n  def solve(m: Double): Double = {\n    val a = 1\n    val b = -2-1\/m\n    val c = 1\n    val D = b*b -4*a*c\n    (-b - sqrt(D))\/2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336208,"user_id":null,"body":"object Solve {\n  \n  def solve(m: Double): Double = {\n    val sqrtD = math.sqrt((4\/m) + (1\/m\/m))\n    (2 + 1\/m - sqrtD)\/2\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336209,"user_id":null,"body":"object Solve {\n\n  def solve(m: Double): Double = {\n    def f(x: Double, k: Double): Double = ((k*x - k - 1)*Math.pow(x, k + 1) + x) \/ Math.pow(1 - x, 2)\n    \n    var x = 0.5\n    var step = 0.25\n    val k = 100000\n    while (step > 1e-13) {\n      if (f(x, k) > m) x -= step else x += step\n      step \/= 2\n    }\n    x\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336210,"user_id":null,"body":"object Solve {\n  \n  def solveQuadraticEquation(A: Double, B: Double, C: Double): Double = {\n    val D = B*B - 4*A*C\n    var res = (-B+Math.sqrt(D))\/2.0\/A\n\n    if (res <= 0 || res >= 1){\n      res = (-B-Math.sqrt(D))\/2.0\/A\n    }\n\n    res\n  }\n\n  def solve(m: Double): Double = {\n    solveQuadraticEquation(m, -2 * m - 1, m)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336211,"user_id":null,"body":"object Solve {\n\n  def solve(m: Double): Double = {\n    val d = Math.pow(2 * m + 1, 2) - 4 * Math.pow(m, 2)\n      val x1 = (2 * m + 1 + Math.sqrt(d)) \/ (2 * m)\n      if (0 < x1 && x1 < 1) x1 else (2 * m + 1 - Math.sqrt(d)) \/ (2 * m)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b40b666dfb4291ad9000049":[{"id":336212,"user_id":53,"body":"object Walker {\n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val u: Double = alpha * Math.PI \/ 180.0\n    val v: Double = beta * Math.PI \/ 180.0\n    val w: Double = gamma * Math.PI \/ 180.0\n    val x: Double = a * Math.cos(u) - b * Math.sin(v) - c * Math.cos(w)\n    val y: Double = a * Math.sin(u) + b * Math.cos(v) - c * Math.sin(w)\n    val t: Double = Math.atan2(y, x) * 180.0 \/ Math.PI\n    val r: Double = Math.hypot(y, x)\n    Array(Math.round(r).toInt, t.toInt.abs, (t * 60.0).toInt.abs % 60, (t * 3600.0).toInt.abs % 60)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336213,"user_id":573,"body":"import scala.math._\n\nobject Walker {\n\n  def solve(oa: Int, ab: Int, bc: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n\n    val (xA, yA) = (oa * cos(alpha.toRadians), oa * sin(alpha.toRadians))\n    val (xB, yB) = (xA + ab * cos((90 + beta).toRadians), yA + ab * sin((90 + beta).toRadians))\n    val (xC, yC) = (xB + bc * cos((180 + gamma).toRadians), yB + bc * sin((180 + gamma).toRadians))\n\n    val co = sqrt(pow(xC, 2) + pow(yC, 2)).round.toInt\n\n    val degrees = (atan2(yC, xC).toDegrees + 360) % 360\n    val minutes = (degrees * 60) % 60\n    val seconds = (degrees * 3600) % 60\n\n    Array(co, degrees.toInt, minutes.toInt, seconds.toInt)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336214,"user_id":492,"body":"object Walker {\n\n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val aa: Double = alpha * Math.PI \/ 180.0\n    val bb: Double = beta * Math.PI \/ 180.0\n    val cc: Double = gamma * Math.PI \/ 180.0\n    val x: Double = a * Math.cos(aa) - b * Math.sin(bb) - c * Math.cos(cc)\n    val y: Double = a * Math.sin(aa) + b * Math.cos(bb) - c * Math.sin(cc)\n    val r: Double = Math.sqrt(x * x + y * y)\n    val theta: Int = (Math.acos(x \/ r) * 180 * 3600 \/ Math.PI).toInt\n    val d: Int = theta \/ 3600\n    val mm: Int = theta % 3600\n    val m: Int = mm \/ 60\n    val s: Int = mm % 60\n    Array(Math.round(r).toInt, d, m, s)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336215,"user_id":492,"body":"object Walker {\n\n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val aa: Double = alpha * Math.PI \/ 180.0\n    val bb: Double = beta * Math.PI \/ 180.0\n    val cc: Double = gamma * Math.PI \/ 180.0\n    val x: Double = a * Math.cos(aa) - b * Math.sin(bb) - c * Math.cos(cc)\n    val y: Double = a * Math.sin(aa) + b * Math.cos(bb) - c * Math.sin(cc)\n    val r: Double = Math.sqrt(x * x + y * y)\n    val theta: Int = (Math.acos(x \/ r) * 180 * 3600 \/ Math.PI).toInt\n    val d: Int = theta \/ 3600\n    val mm: Int = theta % 3600\n    val m: Int = mm \/ 60\n    val s: Int = mm % 60\n    Array(Math.round(r).toInt, d, m, s)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336216,"user_id":null,"body":"object Walker {\n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val alpha1: Double = alpha * java.lang.Math.PI \/ 180\n    val beta1: Double = beta * java.lang.Math.PI \/ 180\n    val gamma1: Double = gamma * java.lang.Math.PI \/ 180\n    val Ot = math.cos(alpha1) * a\n    val tA = math.sin(alpha1) * a\n    val Ah = math.cos(beta1) * b\n    val hB = math.sin(beta1) * b\n    val Bu = math.cos(gamma1) * c\n    val uC = math.sin(gamma1) * c\n    val x:Double = (Ot - hB - Bu) \/\/x\n    val y:Double = (tA + Ah - uC) \/\/y\n    val OC:Double = math.sqrt(x*x + y*y)\n    val element1:Int = math.round(OC).toInt\n    val angletOC = math.asin(math.abs(y)\/OC)*180\/java.lang.Math.PI\n    val element2:Int = math.floor(180-angletOC).toInt\n    val element3:Int = math.floor((180-angletOC) % element2 * 60).toInt\n    val element4:Int = math.floor((180-angletOC) % element2 * 3600 % 60).toInt\n    \n    Array(element1, element2, element3, element4)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336217,"user_id":null,"body":"object Walker {\n  def radians(angle: Double): Double = {\n    angle \/ 180 * 3.14159265358979323846\n  }\n  \n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val y = a*math.sin(radians(alpha)) + b*math.sin(radians(beta+90)) + c*math.sin(radians(gamma+180))\n    val x = a*math.cos(radians(alpha)) + b*math.cos(radians(beta+90)) + c*math.cos(radians(gamma+180))\n    val r = math.round(math.sqrt(y*y+x*x)).toInt\n    val angle = math.atan2(y,x).toDegrees\n    val d = math.floor(angle).toInt\n    val m = ((angle - d)*60).toInt\n    val s = ((angle - d)*3600).toInt % 60 \n    println((angle - d)*3600, s)\n    Array(r, d, m, s)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336218,"user_id":null,"body":"object Walker {\n\n  case class Point(x: Double, y: Double)\n  \n  def move(p: Point, d: Double, a: Double): Point = {\n    val dx = Math.cos(d) * a\n    val dy = Math.sin(d) * a\n    Point(p.x + dx, p.y + dy)\n  }\n  \n  def deg2angle(deg: Int): Double = deg * Math.PI \/ 180 \n  \n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val p0 = Point(0, 0)\n    val p1 = move(p0, deg2angle(alpha), a)\n    println(p1)\n    val p2 = move(p1, deg2angle(beta + 90), b)\n    println(p2)\n    val p3 = move(p2, deg2angle(gamma + 180), c)\n    println(p3)\n    \n    val d = Math.sqrt(p3.x * p3.x + p3.y * p3.y)\n    val angle = Math.atan2(p3.y, p3.x) \/ Math.PI * 180\n    val deg = angle.floor.toInt\n    val minutes = ((angle - deg) * 60).floor.toInt\n    val seconds = ((angle - deg - (minutes \/ 60.0)) * 3600).floor.toInt\n    Array(d.round.toInt, deg, minutes, seconds)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336219,"user_id":null,"body":"object Walker {\nimport scala.math._\n  \n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val ar           = toRadians(alpha)\n    val br           = toRadians(beta)\n    val cr           = toRadians(gamma)\n    val x            = a * cos(ar) - b * sin(br) - c * cos(cr)\n    val y            = a * sin(ar) + b * cos(br) - c * sin(cr)\n    val co           = hypot(x, y)\n    val toc          = if (y >= 0) toDegrees(acos(x \/ co)) else 360.0 - toDegrees(acos(x \/ co))\n    val degrees: Int = toc.toInt\n    val rest         = (toc - degrees) * 60\n    val minutes: Int = rest.toInt\n    val seconds: Int = ((rest - minutes) * 60).toInt\n    Array(round(co).toInt, degrees, minutes, seconds)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336220,"user_id":null,"body":"object Walker {\n\ntype Vec2D = (Double,Double)\n\n  def convertAngle(d: Double): (Int, Int, Int) = {\n    val degree = d.floor.toInt\n    val minute = ((d - degree)*60).floor.toInt\n    val x3 = ((d-degree)-minute\/60.0)*3600\n    val second = x3.floor.toInt\n    (degree, minute, second)\n  }\n\n  def rotate(angle:Double, vec:Vec2D):Vec2D = {\n    val (x,y) = vec\n    (x*Math.cos(angle) - y*Math.sin(angle),x*Math.sin(angle) + y*Math.cos(angle))\n  }\n\n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n\n    val vectors = Array(alpha, beta, gamma).map{\n      a =>\n        val angle = a*Math.PI\/180.0\n        (Math.cos(angle), Math.sin(angle))}\n\n\n    val longVectors = Array(a,b,c).zip(vectors).map{v =>\n      val a = v._1\n      val (c,s) = v._2\n      (a*c, a*s)\n    }\n\n    val rotationAngles = Array[Double](0 , Math.PI\/2, Math.PI)\n    val pointO = (0.0, 0.0)\n    val pointC = rotationAngles.zip(longVectors).map(p => rotate(p._1, p._2))\n      .fold(pointO)((acc,vec)=> (acc._1 + vec._1, acc._2 + vec._2))\n    val (cx, cy) = pointC\n\n    val ds = Math.sqrt(cx*cx + cy*cy)\n    val oc = Math.acos(cx\/ds)*180.0\/Math.PI\n    val (d,m,s) = convertAngle(oc)\n    Array[Int](ds.round.toInt, d, m, s)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336221,"user_id":null,"body":"object Walker {\n\ntype coord = (Double, Double)\ntype Angle = Double\n\ndef convertToRad(ang: Double): Double = ang*3.14159265358979323846\/180\ndef convertToDeg(ang: Double): Double = ang*180\/3.14159265358979323846+180\ndef absDistance(c: coord): Double = Math.sqrt(c._1*c._1+c._2*c._2)\n\ndef transformCoord(c1: coord, d: Int, ang: Double): coord=new coord(c1._1+d*Math.sin(ang),c1._2+d*Math.cos(ang))\ndef lower(upper: Double): Double = 60*(upper-upper.toInt)\ndef getAngle(c1: coord): Angle = convertToDeg(Math.atan(c1._1\/c1._2))\n\ndef toArcMinSec(a: Angle): List[Int] = List(a,lower(a),lower(lower(a))).map(_.toInt)\n\n\n  def solve(a: Int, b: Int, c: Int, alpha: Int, beta: Int, gamma: Int): Array[Int] = {\n    val A: coord = transformCoord(new coord(0,0),a,convertToRad(alpha))\n    val B: coord = transformCoord(A,b,convertToRad(beta+90))\n    val C: coord = transformCoord(B,c,convertToRad(gamma+180))\n    \n    val length = absDistance(C)\n    val ang = getAngle(C)\n    \n    {Math.round(length).toInt :: toArcMinSec(ang)}.toArray\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b7c80094a6aca207000004d":[{"id":336222,"user_id":575,"body":"import math.BigInt\nimport collection.mutable.{Queue, ListBuffer}\n\nobject Kata {\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if (length == 0 || pattern.isEmpty) {\n      return List[BigInt]()\n    }\n  \n    val state = pattern.head match {\n      case \"pad\" => Queue[BigInt](0, 1, 0, 0)\n      case _ => Queue[BigInt](0, 0, 0, 1)\n    }\n  \n    val sequence = ListBuffer[BigInt]()\n    for (abbrev <- Stream.continually(pattern.toStream).flatten.take(length)) {\n      state.enqueue(\n        abbrev match {\n          case \"fib\" => state.slice(2, 4).sum\n          case \"tri\" => state.slice(1, 4).sum\n          case \"tet\" => state.sum\n          case \"pad\" => state(1) + state(2)\n          case \"pel\" => state(2) + 2 * state(3)\n          case \"jac\" => 2 * state(2) + state(3)\n        } \n      )\n      sequence += state.dequeue\n    }\n    sequence.toList \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336223,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  \n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if(pattern.isEmpty || length == 0) {\n      List[BigInt]()\n    } else {\n      var list = getStart(pattern(0))\n      (0 until length-4).foreach(i => list = list :+ getNext(pattern(i%pattern.size), list.takeRight(4)))\n      list.take(length)\n    }\n    \n  }\n  \n  def getStart(s: String): List[BigInt] = s match {\n    case \"fib\" | \"jac\" | \"pel\" | \"tet\" | \"tri\" => List(0, 0, 0, 1)\n    case \"pad\"                                 => List(0, 1, 0, 0)\n  }\n\n  def getNext(s: String, lastFour: List[BigInt]): BigInt = s match {\n    case \"fib\" => lastFour(3) + lastFour(2)\n    case \"jac\" => lastFour(3) + 2 * lastFour(2)\n    case \"pad\" => lastFour(2) + lastFour(1)\n    case \"pel\" => 2 * lastFour(3) + lastFour(2)\n    case \"tet\" => lastFour.sum\n    case \"tri\" => lastFour(3) + lastFour(2) + lastFour(1)\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336224,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if(pattern.isEmpty || length == 0) {\n      List[BigInt]()\n    } else {\n      var list = getStart(pattern(0))\n      (0 until length-4).foreach(i => list = list :+ getNext(pattern(i%pattern.size), list.takeRight(4)))\n      list.take(length)\n    }\n    \n  }\n  \n  def getStart(s: String): List[BigInt] = s match {\n    case \"fib\" | \"jac\" | \"pel\" | \"tet\" | \"tri\" => List(0, 0, 0, 1)\n    case \"pad\"                                 => List(0, 1, 0, 0)\n  }\n\n  def getNext(s: String, lastFour: List[BigInt]): BigInt = s match {\n    case \"fib\" => getFib(lastFour)\n    case \"jac\" => getJac(lastFour)\n    case \"pad\" => getPad(lastFour)\n    case \"pel\" => getPel(lastFour)\n    case \"tet\" => getTet(lastFour)\n    case \"tri\" => getTri(lastFour)\n  }\n\n  def getFib(lastFour: List[BigInt]): BigInt = lastFour(3) + lastFour(2)\n  def getJac(lastFour: List[BigInt]): BigInt = lastFour(3) + 2 * lastFour(2)\n  def getPad(lastFour: List[BigInt]): BigInt = lastFour(2) + lastFour(1)\n  def getPel(lastFour: List[BigInt]): BigInt = 2 * lastFour(3) + lastFour(2)\n  def getTet(lastFour: List[BigInt]): BigInt =\n    lastFour(3) + lastFour (2) + lastFour(1) + lastFour(0)\n  def getTri(lastFour: List[BigInt]): BigInt =\n    lastFour(3) + lastFour(2) + lastFour(1)\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336225,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  \n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if (pattern.length == 0 || length == 0) {\n       List[BigInt]()\n    }\n    else {\n      val startSeq = if (pattern(0) == \"pad\") List[BigInt](0, 1, 0, 0) else List[BigInt](0, 0, 0, 1)\n      def constructSequence(seq: List[BigInt], acc: Int = 4): List[BigInt] = {\n        if (acc >= length) {\n          seq.take(length)\n        }\n        else {\n          pattern((acc-4)%pattern.length) match {\n            case \"fib\" => constructSequence(seq :+ (seq(acc-1) + seq(acc-2)), acc + 1)\n            case \"jac\" => constructSequence(seq :+ (seq(acc-1) + 2 * seq(acc-2)), acc + 1)\n            case \"pad\" => constructSequence(seq :+ (seq(acc-2) + seq(acc-3)), acc + 1)\n            case \"pel\" => constructSequence(seq :+ (2 * seq(acc-1) + seq(acc-2)), acc + 1)\n            case \"tet\" => constructSequence(seq :+ (seq(acc-1) + seq(acc-2) + seq(acc-3) + seq(acc-4)), acc + 1)\n            case \"tri\" => constructSequence(seq :+ (seq(acc-1) + seq(acc-2) + seq(acc-3)), acc + 1)\n            case other => constructSequence(seq, acc + 1)\n          }\n        }\n      }\n      constructSequence(startSeq)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336226,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] =\n    if (pattern.isEmpty || length == 0) Nil else {\n\n      val init@List(i4, i3, i2, i1) = initial(pattern.head)\n\n      val it =\n        LazyList\n          .continually(pattern)\n          .flatten\n          .scanLeft((i4, i3, i2, i1)) { case ((n4, n3, n2, n1), pat) =>\n            val n = pat match {\n              case \"fib\" => n1 + n2\n              case \"jac\" => n1 + 2 * n2\n              case \"pad\" => n2 + n3\n              case \"pel\" => 2 * n1 + n2\n              case \"tet\" => n1 + n2 + n3 + n4\n              case \"tri\" => n1 + n2 + n3\n            }\n            (n3, n2, n1, n)\n          }\n          .map(_._4)\n          .drop(1)\n\n      (init.iterator ++ it).take(length).toList\n    }\n\n  def initial(pattern: String): List[BigInt] = pattern match {\n    case \"fib\" => List(0, 0, 0, 1)\n    case \"jac\" => List(0, 0, 0, 1)\n    case \"pad\" => List(0, 1, 0, 0)\n    case \"pel\" => List(0, 0, 0, 1)\n    case \"tet\" => List(0, 0, 0, 1)\n    case \"tri\" => List(0, 0, 0, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336227,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] =\n    if (pattern.isEmpty || length <= 0) {\n      List.empty[BigInt]\n    } else if (length <= 4) {\n      firstEl(pattern.head).take(length)\n    } else {\n      var list = firstEl(pattern.head)\n      val lim  = pattern.length\n      (5 to length).foreach { i =>\n        val pat = pattern((i - 5) % lim)\n        list = list :+ nextEl(pat, list)\n      }\n      list\n    }\n\n  private def firstEl(pat: String): List[BigInt] =\n    pat match {\n      case \"pad\" => List(BigInt(0), BigInt(1), BigInt(0), BigInt(0))\n      case _     => List(BigInt(0), BigInt(0), BigInt(0), BigInt(1))\n    }\n\n  private def nextEl(pat: String, list: List[BigInt]): BigInt =\n    pat match {\n      case \"fib\" => list.takeRight(2).sum\n      case \"jac\" => list.last + 2 * list.init.last\n      case \"pad\" => list.init.last + list.init.init.last\n      case \"pel\" => 2 * list.last + list.init.last\n      case \"tet\" => list.takeRight(4).sum\n      case \"tri\" => list.takeRight(3).sum\n      case _     => throw new IllegalArgumentException\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336228,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    var patLen: Int = pattern.length\n    var seqList: List[BigInt] = { if (length == 0 || patLen == 0) List()\n    else if (length == 1) List(0)\n    else if (length == 2) {if (pattern(0) == \"pad\") List(0, 1) else List(0, 0)}\n    else if (length == 3) {if (pattern(0) == \"pad\") List(0, 1, 0) else List(0, 0, 0)}\n    else {if (pattern(0) == \"pad\") List(0, 1, 0, 0) else List(0, 0, 0, 1)}}\n\n\n\n    def zozoHelper (length: Int, loopCnt: Int = 4, pat: String, seqList: List[BigInt]): List[BigInt] = {\n      if (length <= loopCnt) seqList\n      else if (pat == \"fib\") zozoHelper(length, loopCnt+1, pattern((loopCnt-3)%patLen), seqList.appended(seqList(loopCnt-1) + seqList(loopCnt - 2)))\n      else if (pat == \"jac\") zozoHelper(length, loopCnt+1, pattern((loopCnt-3)%patLen), seqList.appended(seqList(loopCnt-1) + 2 * seqList(loopCnt - 2)))\n      else if (pat == \"pad\") zozoHelper(length, loopCnt+1, pattern((loopCnt-3)%patLen), seqList.appended(seqList(loopCnt-2) + seqList(loopCnt - 3)))\n      else if (pat == \"pel\") zozoHelper(length, loopCnt+1, pattern((loopCnt-3)%patLen), seqList.appended(2 * seqList(loopCnt-1) + seqList(loopCnt - 2)))\n      else if (pat == \"tet\") zozoHelper(length, loopCnt+1, pattern((loopCnt-3)%patLen), seqList.appended(seqList(loopCnt-1) + seqList(loopCnt - 2) + seqList(loopCnt - 3) + seqList(loopCnt - 4)))\n      else zozoHelper(length, loopCnt+1, pattern((loopCnt-3)%patLen), seqList.appended(seqList(loopCnt-1) + seqList(loopCnt - 2) + seqList(loopCnt - 3)))    \/\/tri\n\n    }\n    \n    if (patLen >= 1) zozoHelper(length, 4, pattern(0), seqList)\n    else List()\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336229,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    def getFirstFour(p: Option[String]): List[BigInt] = p match {\n      case Some(\"pad\") => List[BigInt](0, 1, 0, 0)\n      case Some(_) => List[BigInt](0, 0, 0, 1)\n      case None => List[BigInt]()\n    }\n    def addValue(p: String, values: List[BigInt]): List[BigInt] = {\n      val n = values.size\n      p match {\n        case \"fib\" => values :+ (values(n-2) + values(n-1))\n        case \"jac\" => values :+ (2*values(n-2) + values(n-1))\n        case \"pad\" => values :+ (values(n-3) + values(n-2))\n        case \"pel\" => values :+ (values(n-2) + 2*values(n-1))\n        case \"tet\" => values :+ (values(n-4) + values(n-3) +values(n-2) + values(n-1))\n        case \"tri\" => values :+ (values(n-3) + values(n-2) + values(n-1))\n        case _ => values\n      }\n    }\n\n    if (length == 0 || pattern.isEmpty) List[BigInt]()\n    else {\n      val patterns = pattern.size\n      val first = getFirstFour(pattern.headOption)\n      (5 to length).foldLeft(first)((b, n) => {\n        val p = pattern((n - 5) % patterns)\n        addValue(p, b)\n      }).take(length)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336230,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  object Pattern {\n    def apply(pattern: String): PatternSuite = pattern match {\n      case \"fib\" => FIBONACCI\n      case \"jac\" => JACOBSTHAL\n      case \"pad\" =>  PADOVAN\n      case \"pel\" =>  PELL\n      case \"tet\" =>  TETRANACCI\n      case \"tri\" => TRIBONACCI\n    }\n    sealed trait PatternSuite {\n      def getNTh(from: List[BigInt], pos: Int): BigInt\n    }\n\n    case object FIBONACCI extends PatternSuite {\n      override def getNTh(from: List[BigInt], pos: Int): BigInt = from(pos-1) + from(pos-2)\n    }\n    case object JACOBSTHAL extends PatternSuite {\n      override def getNTh(from: List[BigInt], pos: Int): BigInt = from(pos-1) + 2 * from(pos-2)\n    }\n    case object PADOVAN extends PatternSuite {\n      override def getNTh(from: List[BigInt], pos: Int): BigInt = from(pos-2) + from(pos-3)\n    }\n    case object PELL extends PatternSuite {\n      override def getNTh(from: List[BigInt], pos: Int): BigInt = 2 * from(pos-1) + from(pos-2)\n    }\n    case object TETRANACCI extends PatternSuite {\n      override def getNTh(from: List[BigInt], pos: Int): BigInt = from(pos-1) + from(pos-2) + from(pos-3) + from(pos-4)\n    }\n    case object TRIBONACCI extends PatternSuite {\n      override def getNTh(from: List[BigInt], pos: Int): BigInt = from(pos-1) + from(pos-2) + from(pos-3)\n    }\n    \n  }\n  import Kata.Pattern._\n  \n\n  private def padList(strings: List[String], padTo: Int): List[String] = {\n    val repeat: Int = (padTo \/ strings.length) + 1\n\n    (1 to repeat).foldLeft(List.empty[String])((inc, i)=> {\n      inc ++ strings\n    }).take(padTo)\n  }\n\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    \n    if (length == 0 || pattern.isEmpty) {\n      return List.empty[BigInt]\n    }\n    val ints = firstFour(Pattern.apply(pattern.head))\n    if (length <= ints.length) {\n      return ints.take(length)\n    }\n\n    val patterns = padList(pattern, length)\n    \n    (4 until length).foldLeft(ints)((inc, rawPosition) => {\n      val position = rawPosition - 4\n      val currentPattern: Pattern.PatternSuite = Pattern.apply(patterns(position))\n\n      inc :+ currentPattern.getNTh(inc, rawPosition)\n    })\n  }\n\n  private def firstFour(pattern: PatternSuite): List[BigInt] = pattern match {\n      case FIBONACCI => List(0, 0, 0, 1)\n      case JACOBSTHAL => List(0, 0, 0, 1)\n      case PADOVAN => List(0, 1, 0, 0)\n      case PELL => List(0, 0, 0, 1)\n      case TETRANACCI => List(0, 0, 0, 1)\n      case TRIBONACCI => List(0, 0, 0, 1)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336231,"user_id":null,"body":"import math.BigInt\n\nobject Kata {\n  val abbrToInitialValues = Map(\n    \"fib\" -> List[BigInt](0, 0, 0, 1),\n    \"jac\" -> List[BigInt](0, 0, 0, 1),\n    \"pad\" -> List[BigInt](0, 1, 0, 0),\n    \"pel\" -> List[BigInt](0, 0, 0, 1),\n    \"tet\" -> List[BigInt](0, 0, 0, 1),\n    \"tri\" -> List[BigInt](0, 0, 0, 1)\n  )\n\n  def fib(result: List[BigInt], n: Int) = result(n - 1) + result(n - 2)\n  def jac(result: List[BigInt], n: Int) = result(n - 1) + 2 * result(n - 2)\n  def pad(result: List[BigInt], n: Int) = result(n - 2) + result(n - 3)\n  def pel(result: List[BigInt], n: Int) = 2 * result(n - 1) + result(n - 2)\n  def tet(result: List[BigInt], n: Int) = result(n - 1) + result(n - 2) + result(n - 3) + result(n - 4)\n  def tri(result: List[BigInt], n: Int) = result(n - 1) + result(n - 2) + result(n - 3)\n\n  val abbrToFuc: Map[String, (List[BigInt], Int) => BigInt] = Map(\n    \"fib\" -> fib,\n    \"jac\" -> jac,\n    \"pad\" -> pad,\n    \"pel\" -> pel,\n    \"tet\" -> tet,\n    \"tri\" -> tri\n  )\n\n  def getZozonacciList(pattern: List[String], length: Int, result: List[BigInt], n: Int, pointer: Int): List[BigInt] = {\n    if (n >= length) return result\n\n    getZozonacciList(\n      pattern, \n      length, \n      result :+ abbrToFuc(pattern(pointer))(result, n), n + 1,\n      if (pointer == pattern.length - 1) 0 else pointer + 1\n    )\n  }\n\n  def zozonacci(pattern: List[String], length: Int): List[BigInt] = {\n    if (pattern.length == 0 || length == 0) return List[BigInt]()\n    if (length < 4) return abbrToInitialValues(pattern(0)).take(length)\n\n    getZozonacciList(pattern, length, abbrToInitialValues(pattern(0)), 4, 0)\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b853229cfde412a470000d0":[{"id":336232,"user_id":1228,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\n        (dad - 2 * son).abs\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336233,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = math.abs(2 * son - dad)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336234,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\n      (2*son - dad).abs\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336235,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\n    val res = (dad.toDouble,son.toDouble) match {\n      case (dad, 0) => dad\n      case (dad, son) if dad\/son == 2 => 0\n      case (dad, son) if dad\/son >  2 => (dad\/son-2)*son\n      case (dad, son) if dad\/son <  2 => (2-dad\/son)*son\n      case _ => 0\n    }\n    res.toInt.abs\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336236,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\n      if (dad - son == son) 0 else (dad - (son * 2)).abs\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336237,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int): Int = {\n      \/\/ your code here\n      if (son * 2 == dad) 0\n      else if (son * 2 < dad) 1 + twice_as_old(dad + 1, son + 1)\n      else 1 + twice_as_old(dad - 1, son - 1)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336238,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\nif(dad - 2*son >= 0) dad - 2 * son\nelse 2*son - dad\n}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336239,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\n        val double_son = son * 2\n    if (double_son > dad) {\n      double_son - dad\n    }\n    else {\n      dad - double_son\n    }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336240,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int) = {\n      val sonDoubleAge = son * 2\n      val difference = dad - sonDoubleAge\n      if(difference < 0) {\n        Math.abs(difference)\n      } else {\n        difference\n      }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336241,"user_id":null,"body":"object Sol { \n\n    def twice_as_old(dad: Int, son: Int): Int = {\n      math.abs((dad - son) - son)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5bb0c58f484fcd170700063d":[{"id":336242,"user_id":573,"body":"object Pillars {\n\n  def distance(n: Int, d: Int, w: Int ): Int = (n-1) * d * 100 + ((n-2) max 0) * w\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336243,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    num_pill match {\n      case 1 => 0\n      case _ => (num_pill-2) * width + (num_pill-1) * dist*100\n    }  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336244,"user_id":null,"body":"object Pillars {\n  def distance(n: Int, d: Int, w: Int ): Int = if (n==1) 0 else w*(n-2) +d*100*(n-1)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336245,"user_id":1554,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    if (num_pill < 2) 0 else if (num_pill < 3) dist * 100 else (num_pill - 2) * width + (num_pill - 1) * dist * 100\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336246,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    \n    (num_pill - 2) match  {\n      \n      case leftPills:Int if leftPills > 0 => (leftPills * width) + ((dist * 100) * (num_pill-1)) \n      case leftPills:Int if leftPills < 0 => 0\n      case _ => (dist * 100)\n \n    } \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336247,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    if(num_pill>1)(num_pill-2)*width+dist*100*(num_pill-1)\n    else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336248,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    \/\/ your code here...\n   if(num_pill==1){\n      return 0\n    }else{\n      (num_pill-2)*width+((num_pill-1)*dist*100)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336249,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    if (num_pill==1) 0 else (num_pill - 1)*dist*100 + num_pill*width - 2*width\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336250,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    if (num_pill > 1) \n      (num_pill-1)*(dist*100) + (num_pill*width - width*2)\n    else\n      0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336251,"user_id":null,"body":"object Pillars {\n  def distance(num_pill: Int, dist: Int, width: Int ): Int = {\n    var disti = dist*100\n    if(num_pill == 1){\n      return 0\n    }else if(num_pill == 2){\n      return (num_pill-1) * disti\n    }else{\n      var dis = (num_pill-1) * disti\n      return ((num_pill-2)*width) + dis\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5bb493932ce53339dc0000c2":[{"id":336252,"user_id":574,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = if (layers == 0) 0 else 1 + (layers - 1) \/ math.sqrt(2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336253,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = {\n    \/\/ Implement me! :)\n    if (layers == 0){return layers}\n    1 + (layers - 1) * Math.sqrt(0.5)\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336254,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = {\n    if (layers < 1) 0\n    else 1 + (layers - 1) \/ Math.sqrt(2)\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336255,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = {\n    if (layers > 0) (layers - 1) \/ Math.sqrt(2) + 1\n    else 0\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336256,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = {\n    if (layers == 0) {\n      0\n    }\n    else {\n      1 + (math.sqrt(2.0\/3.0)) * (layers-1) * math.sqrt(3)\/2\n    }\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336257,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = \n    if (layers == 0) 0\n    else 1 + (layers - 1) * Math.sin(Math.toRadians(45))\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336258,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = {\n    if (layers == 0) 0\n    else Math.cos(Math.toRadians(45)) * (layers - 1) + 1\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336259,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = \n    if (layers < 1) 0 else 1 + (layers - 1) \/ math.sqrt(2)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336260,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = {\n    if(layers == 0) 0 else 1 + 0.5 * math.sqrt(2) * (layers - 1)\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336261,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight3d(layers: Double): Double = layers match {\n    case 0 => 0\n    case n@_ => (n - 1) \/ Math.sqrt(2) + 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5bb804397274c772b40000ca":[{"id":336262,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double =\n    if (layers == 0 || layers == 1) layers\n    else 1 + (math.sqrt(3) \/ 2) * (layers - 1)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336263,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = \n  if (layers == 0) {\n    0\n  }\n  else {\n    1 + (math.sqrt(3)\/2) * (layers-1)\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336264,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = {\n    if (layers == 0 || layers == 1.0) layers\n    else 1.0 + (layers - 1) * Math.sqrt(3) \/ 2.0\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336265,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = {\n    if (layers == 0) 0\n    else 1 + (layers - 1) * Math.sin(Math.toRadians(60))\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336266,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = {\n    if (layers == 0) 0\n    else Math.sin(Math.toRadians(60)) * (layers - 1) + 1\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336267,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = \n    if (layers == 0) 0 else 1 + (layers - 1) * math.sqrt(3) \/ 2.0\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336268,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = {\n    if(layers == 0) 0 else (layers - 1) \/ 2 * math.sqrt(3) + 1\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336269,"user_id":null,"body":"object Dinglemouse {\n  def stackHeight2d(layers: Double): Double = layers match {\n    case 0 => 0\n    case n@_ => (n - 1) * Math.sqrt(3) \/ 2 + 1\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336270,"user_id":null,"body":"import scala.math.sqrt\n\n\nobject Dinglemouse {\n  def stackHeight2d(layers: Double): Double = layers match {\n    case 0 => 0.0\n    case 1 => 1.0\n    case i => 1.0 + (i - 1) * sqrt(3) \/ 2\n  } \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336271,"user_id":null,"body":"object Dinglemouse {\n  val singleLayer = math.sqrt(3.0) \/ 2\n\n  def stackHeight2d(layers: Double): Double = if (layers > 0) {\n    1.0 + (layers - 1) * singleLayer\n  } else {\n    0.0\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5bb904724c47249b10000131":[{"id":336272,"user_id":573,"body":"object Kata {\n\n  def points(games: Seq[String]): Int =\n    games\n      .collect {\n        case x if x(0) > x(2)  => 3\n        case x if x(0) == x(2) => 1\n      }\n      .sum\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336273,"user_id":527,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    games.map(g => if (g(0) > g(2)) 3 else if (g(0) == g(2)) 1 else 0).sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336274,"user_id":null,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    games.foldLeft(0)((acc, s) =>\n      s match {\n        case s\"$l:$r\" => if (l > r) acc + 3 else if (l == r) acc + 1 else acc\n      }\n    )\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336275,"user_id":null,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    games.map { game =>\n      val Array(us, them) = game.split(\":\")\n      (us compare them).sign match {\n        case -1 => 0\n        case  0 => 1\n        case  1 => 3\n      }  \n    }.sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336276,"user_id":null,"body":"object Kata {\n  def string_to_points(score: String): Int = {\n    val team1: Int = score.charAt(0).toInt\n    val team2: Int = score.charAt(2).toInt\n    if (team1>team2) 3\n    else if (team1<team2) 0\n    else 1\n  }\n  def points(games: Seq[String]): Int = {\n    games.map(string_to_points).sum\n    \/\/ your code here\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336277,"user_id":null,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    \/\/ your code here\n    val first = for(x <- games) yield (x.charAt(0).toInt - x.charAt(2).toInt)\n    \n    val won = first.filter( _ > 0).size * 3\n    val lost = first.filter(_ < 0).size * (0)\n    val drew = first.filter(_ == 0).size * (1)\n     \n    won + lost + drew\n    \n    \n    \n    \n    \n    \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336278,"user_id":null,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    games.map{game =>\n      game.split(\":\").toSeq match {\n        case Seq(xStr, yStr) =>\n          val x = xStr.toInt\n          val y = yStr.toInt\n          \n          if (x > y) 3\n          else if (x < y) 0 \n          else 1\n        case _ => 0\n      }\n    }.sum\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336279,"user_id":null,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    val g = games.map(el => el.split(\":\")).map(el => el.map(e => e.toInt))\n    var point = 0\n    for (x <- g) {\n      if (x(0) > x(1)) point +=3\n      if (x(0) == x(1)) point +=1\n    }\n    point\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336280,"user_id":468,"body":"object Kata {\n  def points(games: Seq[String]): Int =\n    games\n      .map(_.split(\":\") match {\n        case Array(f, a) if f > a => 3\n        case Array(f, a) if f == a => 1\n        case _ => 0\n      }).sum\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336281,"user_id":null,"body":"object Kata {\n  def points(games: Seq[String]): Int = {\n    var res = 0\n    for (element <- games){\n      var c = element.split(\":\")\n      var x = c(0)\n      var y = c(1)\n      if (x > y) {\n        res += 3\n      }\n      if (x == y) {\n        res += 1\n      }\n    }\n    return res\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5c084eee38b1d345970000cd":[{"id":336282,"user_id":null,"body":"object Kata {\n  implicit class AbusedList[T](list: List[T]) {\n    def dropRightWhile(p: T => Boolean): List[T] = list.reverse.dropWhile(p).reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336283,"user_id":1802,"body":"object Kata {\n\n  implicit class ListOps[A](list: List[A]) {\n    def dropRightWhile(p: A => Boolean): List[A] =\n      list.reverse.dropWhile(p).reverse\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336284,"user_id":null,"body":"object Kata {\n  import scala.annotation.tailrec  \n  \n  implicit class myList[A](list: List[A]) {\n    def dropRightWhile(p: A => Boolean): List[A] = {\n      \n      @tailrec\n      def go(l: List[A]): List[A] = l match {\n        case x :: xs if (p(x)) => go(xs)\n        case _ => l\n      }\n      \n      go(list.reverse).reverse\n    }    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336285,"user_id":null,"body":"object Kata {\n  implicit class ListExtension[T](a: List[T]) {\n    def dropRightWhile(p: T => Boolean): List[T] = a.reverse.dropWhile(p).reverse.toList  \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336286,"user_id":null,"body":"object Kata {\n  implicit class DropRightWhile[T](val xs: List[T]) {\n    def dropRightWhile(p: T => Boolean): List[T] = {\n      xs match {\n        case Nil => Nil\n        case (x :: xs) => xs.dropRightWhile(p) match {\n          case Nil => if (p(x)) {Nil} else {List(x)}\n          case xss => x :: xss\n        }\n        \n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336287,"user_id":149,"body":"object Kata {\n  implicit class A[T](val a: List[T]) {\n    def dropRightWhile(f: T => Boolean): List[T] = a.reverse.dropWhile(f).reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336288,"user_id":null,"body":"object Kata {\n    implicit class ListExt[T](val l: List[T]) {\n      def dropRightWhile(p: T => Boolean): List[T] = {\n        l.reverse\n         .dropWhile(p) \n         .reverse\n      }\n    } \n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336289,"user_id":null,"body":"object Kata {\n  \n  implicit def extendList[T](l: List[T]) = new SuperHyperUltraCoolList(l)\n  \n  class SuperHyperUltraCoolList[T](val l: List[T]) {\n    def dropRightWhile(p: T => Boolean): List[T] = {\n      if (l.length != 0 && p(l.last)) l.dropRight(1).dropRightWhile(p)\n      else l\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336290,"user_id":468,"body":"object Kata {\n\n  implicit class extendedList[T](xs: List[T]) {\n    def dropRightWhile(f: T => Boolean): List[T] = xs.reverse.dropWhile(f).reverse\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336291,"user_id":106,"body":"object Kata {\n  implicit def myList[T](xs: List[T]) = new MyList[T](xs)\n  class MyList[T](xs: List[T]) {\n    def dropRightWhile(p: T => Boolean): List[T] = {\n      var idx = 0\n      for((x,i) <- xs.view.zipWithIndex) {\n        if (!p(x)) idx = i + 1;\n      }\n      xs.dropRight(xs.length - idx)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5c17c7e99830f977d100006a":[{"id":336292,"user_id":527,"body":"object Kata {\n  import language.implicitConversions\n  implicit def numericToBoolean[T : Numeric](x: T) = x != implicitly[Numeric[T]].zero\n  implicit def booleanToInt(x: Boolean) = if (x) 1 else 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336293,"user_id":149,"body":"object Kata {\n  implicit def boolToInt(f: Boolean) = if (f) 1 else 0\n  implicit def intToBool(n: Int) = n != 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336294,"user_id":null,"body":"import scala.language.implicitConversions\n\nobject Kata {\n  \n  implicit def int2bool(value: Int): Boolean = value != 0\n  \n  implicit def bool2int(value: Boolean): Int = if (value) 1 else 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336295,"user_id":468,"body":"import scala.language.implicitConversions\n\nobject Kata {\n\n  implicit def int2Boolean: Int => Boolean = _ != 0\n\n  implicit def boolean2Int: Boolean => Int = if (_) 1 else 0\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336296,"user_id":null,"body":"object Kata {\n  \/\/ your code here ...\n  implicit def booleanToInt(input: Boolean) = if (input) 1 else 0\n  implicit def intoToBoolean(input: Int) = if (input == 0) false else true\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336297,"user_id":106,"body":"object Kata {\n  implicit def int2Bool(x: Int) = if (x>0) true else false\n  implicit def bool2Int(x: Boolean) = if (x) 1 else 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336298,"user_id":null,"body":"object Kata {\n  implicit def intToBoolean(x: Int): Boolean = {\n    if (x == 0) { false } else { true }\n  }\n  implicit def booleanToInt(b: Boolean): Int = {\n    if (b) {1} else {0}\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336299,"user_id":null,"body":"import scala.language.implicitConversions\n\nobject Kata {\n  implicit def int2bool(n: Int): Boolean = n != 0\n\n  implicit def boo2int(b: Boolean): Int = if (b) 1 else 0\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336300,"user_id":null,"body":"object Kata {\n  implicit def intConvert(x: Int): Boolean = x == 42\n  implicit def boolConverter(x: Boolean): Int = if (x) 1 else 0\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336301,"user_id":null,"body":"import scala.language.implicitConversions\n\nobject Kata {\n  implicit def int2Boolean(x: Int): Boolean = !(x == 0)\n  implicit def boolean2Int(x: Boolean): Int = if(x) 1 else 0\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5c1905cc16537c7782000783":[{"id":336302,"user_id":null,"body":"object DominoTiling2xNBoard {\n  \n  val modulo = 12345787\n  \n  type Matrix = Array[Array[BigInt]]\n  \n  def twoByN(n: Long, k: Long): Int = {\n    def multiply(m1: Matrix, m2: Matrix): Matrix = {\n      val matrix = Array.ofDim[BigInt](m1.length, m2(0).length)\n      for (i <- 0 until m1.length) {\n        for (j <- 0 until m2.length) {\n          var sum = BigInt(0)\n          for (k <- 0 until m1(0).length) {\n            sum = sum + m1(i)(k) * m2(k)(j)\n          }\n          matrix(i)(j) = sum % modulo\n        }\n      }\n      matrix\n    }\n    \n    def twoByNAux(m: Matrix, s: Matrix): Int = {\n      \n      val powers = (n - 1).toBinaryString.reverse.split(\"\").toList.zipWithIndex.filter{case (e, i) => e == \"1\"}\n      .map{case (e, i) => 1 << i}\n      \n      def p2(p: Int, acc: List[Matrix] = List(m)): List[Matrix] = {\n        if (acc.length == p) {\n          acc.zip((n - 1).toBinaryString.reverse).filter(_._2 != '0').map(x => x._1)\n        }\n        else {\n          p2(p, acc :+ multiply(acc.last, acc.last))\n        }\n      }\n      \n      val result = p2((n - 1).toBinaryString.length).fold(s){multiply(_, _)}\n      ((result(0)(0) + result(0)(1)) % modulo).toInt\n    }\n    \n    val matrix = Array.ofDim[BigInt](4, 4)\n    matrix(0)(0) = 0\n    matrix(0)(1) = 0\n    matrix(0)(2) = 0\n    matrix(0)(3) = (k - 2).max(0) * (k - 1)\n    matrix(1)(0) = 0\n    matrix(1)(1) = 0\n    matrix(1)(2) = 0\n    matrix(1)(3) = (k - 2).max(0) * (k - 2).max(0) + k - 1\n    matrix(2)(0) = 1\n    matrix(2)(1) = 0\n    matrix(2)(2) = k - 1\n    matrix(2)(3) = 0\n    matrix(3)(0) = 0\n    matrix(3)(1) = 1\n    matrix(3)(2) = (k - 2).max(0)\n    matrix(3)(3) = 0\n    \n    val startValues = Array.ofDim[BigInt](1, 4)\n    startValues(0)(0) = k\n    startValues(0)(1) = 0\n    startValues(0)(2) = k * (k - 1)\n    startValues(0)(3) = k * (k - 1)\n    \n    n match {\n      case 1 => k.toInt\n      case 2 => (2 * k * (k - 1)).toInt\n      case x => twoByNAux(matrix, startValues)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336303,"user_id":574,"body":"object DominoTiling2xNBoard {\n\n  implicit class ModLong(n: Long) {\n    val mod = 12345787L\n    def +\/(m: Long): Long = (n + m) % mod\n    def *\/(m: Long): Long = (n * m) % mod\n  }\n\n  implicit class VProd(v: Seq[Long]) {\n    def *(w: Seq[Long]): Long =\n      (v zip w) map { case (a, b) => a *\/ b } reduce (_ +\/ _)\n  }\n\n  class Matrix4(m: Seq[Long]) {\n    def row(n: Int): Seq[Long] = m.slice(4 * n, 4 * (n + 1))\n    def col(n: Int): Seq[Long] = (n until 16 by 4) map m\n\n    def *(vect: Seq[Long]): Seq[Long] =\n      for (i <- 0 until 4) yield vect * row(i)\n\n    def *(that: Matrix4): Matrix4 =\n      new Matrix4(\n        for (\n          i <- 0 until 4;\n          j <- 0 until 4\n        ) yield\n          row(i) * that.col(j)\n      )\n\n    def **(n: Long): Matrix4 =\n      if (n == 1) this\n      else if (n % 2 == 0) {\n        val A = this ** (n \/ 2)\n        A * A\n      }\n      else this * (this ** (n - 1))\n  }\n\n  def makeMatrix(k: Int): Matrix4 =\n    new Matrix4(List(\n      k - 1, k - 2, 0, 0,\n      0, 0, (k - 1) * (k - 2), k * k - 3 * k + 3,\n      1, 0, 0, 0,\n      0, 1, 0, 0\n    ))\n\n  def makeInit(k: Int): Seq[Long] =\n    List(k * (k - 1), k * (k - 1), k, 0)\n\n  def twoByN(n: Long, k: Int): Int =\n    if (n == 1) k\n    else if (n == 2) 2 * k * (k - 1)\n    else {\n      val A = makeMatrix(k)\n      val v = makeInit(k)\n      val r = (A ** (n - 2)) * v\n      (r(0) +\/ r(1)).toInt\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5c8bfa44b9d1192e1ebd3d15":[{"id":336304,"user_id":573,"body":"object SheepAdvisor {\n  \n  def warn_the_sheep(queue: Seq[String]): String =\n    if (queue.last == \"wolf\") {\n      \"Pls go away and stop eating my sheep\"\n    } else {\n      s\"Oi! Sheep number ${queue.reverse.indexOf(\"wolf\")}! You are about to be eaten by a wolf!\"\n    }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336305,"user_id":null,"body":"object SheepAdvisor {\n  \n  def warn_the_sheep(queue: Seq[String]): String = {\n    queue.reverse.indexOf(\"wolf\") match {\n      case 0 => \"Pls go away and stop eating my sheep\"\n      case _ => \"Oi! Sheep number %d! You are about to be eaten by a wolf!\".format(queue.reverse.indexOf(\"wolf\"))\n    }\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336306,"user_id":null,"body":"object SheepAdvisor {\n  \n  def warn_the_sheep(queue: Seq[String]): String = {\n    val wolfPosition = queue.indexOf(\"wolf\")\n    wolfPosition match {\n      case x if (x == queue.length - 1) => \"Pls go away and stop eating my sheep\"\n      case _ => s\"Oi! Sheep number ${queue.length -1  - wolfPosition}! You are about to be eaten by a wolf!\"\n    }\n  }  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336307,"user_id":null,"body":"object SheepAdvisor {\n  \n  def warn_the_sheep(queue: Seq[String]): String = {\n    val (_, position) = queue.zipWithIndex.find( _._1 == \"wolf\").get\n    if (position == queue.length - 1) s\"Pls go away and stop eating my sheep\"\n    else s\"Oi! Sheep number ${queue.length - 1 - position}! You are about to be eaten by a wolf!\"\n  \n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336308,"user_id":null,"body":"object SheepAdvisor {\n  \n  def warn_the_sheep(queue: Seq[String]): String = {\n  var b = queue.reverse\n  var wolf = b.indexOf(\"wolf\")\n  if (b(0) == \"wolf\") return \"Pls go away and stop eating my sheep\"\n  else  return \"Oi! Sheep number \" + wolf +\"! You are about to be eaten by a wolf!\"    \n  }\n  }\n    \n  \n  \n\n  \n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336309,"user_id":null,"body":"object SheepAdvisor {\n  def warn_the_sheep(queue: Seq[String]): String = \n  if (queue.indexWhere(x => x == \"wolf\") == -1 || (queue.indexWhere(x => x == \"wolf\") + 1) == queue.size)\n      \"Pls go away and stop eating my sheep\"\n    else s\"Oi! Sheep number ${queue.size - (queue.indexWhere(x => x == \"wolf\") + 1)}! You are about to be eaten by a wolf!\"\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336310,"user_id":null,"body":"object SheepAdvisor {\n  def warn_the_sheep(queue: Seq[String]): String = {\n      var warning = \"\"\n    var n =queue.length-1-queue.indexOf(\"wolf\")\n    if (n==0){\n      warning= \"Pls go away and stop eating my sheep\"\n    }else{\n      warning=\"Oi! Sheep number \" +n+\"! You are about to be eaten by a wolf!\"\n    }\n    warning\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336311,"user_id":null,"body":"object SheepAdvisor {\n  def warn_the_sheep(queue: Seq[String]): String = {\n    val queueReversed = queue.reverse\n      def acc (sheepChecker: Seq[String], counter: Int): String = {\n        if (sheepChecker.head == \"wolf\" & counter == 0) \"Pls go away and stop eating my sheep\"\n        else if (sheepChecker.head == \"wolf\" & counter > 0) s\"Oi! Sheep number $counter! You are about to be eaten by a wolf!\"\n        else acc(sheepChecker.tail, counter+1)\n      }\n    acc (queueReversed,0)\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336312,"user_id":null,"body":"object SheepAdvisor {\n  def warn_the_sheep(queue: Seq[String]): String = queue.length - queue.indexOf(\"wolf\") match {\n    case 1 => \"Pls go away and stop eating my sheep\"\n    case _ => s\"Oi! Sheep number ${queue.length - queue.indexOf(\"wolf\") - 1}! You are about to be eaten by a wolf!\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336313,"user_id":null,"body":"object SheepAdvisor {\n  def warn_the_sheep(queue: Seq[String]): String = {\n    var res = \"\"\n    if (queue.indexOf(\"wolf\") == queue.length-1){\n      res = \"Pls go away and stop eating my sheep\"\n    }\n    else {\n      res = \"Oi! Sheep number \" + (((queue.length - queue.indexOf(\"wolf\"))- 1).abs).toString + \"! You are about to be eaten by a wolf!\"\n      }\n    return res\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ca3ae9bb7de3a0025c5c740":[{"id":336314,"user_id":492,"body":"object ChangePoint {\n    def point(a: Int, b: Int): (Boolean) => Int = (x: Boolean) => {\n        if (x == true) a else b\n    }\n    def fst(pt: (Boolean) => Int): Int = {\n        pt(true)\n    }\n    def snd(pt: (Boolean) => Int): Int = {\n        pt(false)\n    }\n    def sqrDist(pt1: (Boolean) => Int, pt2: (Boolean) => Int): Int = {\n        val d1 = fst(pt1) - fst(pt2)\n        val d2 = snd(pt1) - snd(pt2)\n        d1 * d1 + d2 * d2\n    }\n    def line(pt1: (Boolean) => Int, pt2: (Boolean) => Int): List[Int] =  {\n        val x1 = fst(pt1); val y1 = snd(pt1)\n        val x2 = fst(pt2); val y2 = snd(pt2)\n        val dx = x2 - x1; val dy = y2 - y1\n        val u = dy * x1 - dx * y1\n        List(-dy, dx, u)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336315,"user_id":573,"body":"object ChangePoint {\n\n  type P = () => (Int, Int)\n\n  def point(a: Int, b: Int): P = () => (a, b)\n  def fst(pt: P): Int = pt()._1\n  def snd(pt: P): Int = pt()._2\n  def sqrDist(pt1: P, pt2: => P): Int =\n    (math.pow(fst(pt1) - fst(pt2), 2) + math.pow(snd(pt1) - snd(pt2), 2)).toInt\n  def line(pt1: P, pt2: P): List[Int] = {\n    val l = snd(pt1) - snd(pt2)\n    val m = fst(pt2) - fst(pt1)\n    val n = -(l * (fst(pt1)) + m * (snd(pt1)))\n    List(l, m, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336316,"user_id":null,"body":"object ChangePoint {\n  \n    def gcd(a:Int,b:Int) : Int = if(b == 0) a else gcd(b,a%b)\n    def point(a: Int, b: Int): Int => Int =  {\n        x => if( x == 0) a else b \n    }\n    def fst(pt: Int => Int): Int = {\n        pt(0)\n    }\n    def snd(pt: Int => Int): Int = {\n        pt(1)\n    }\n    def sqrDist(pt1: Int => Int, pt2: Int => Int): Int = {\n      val a = fst(pt1)-fst(pt2)    \n      val b = snd(pt1) - snd(pt2)\n      a*a + b*b\n    }\n    def line(pt1: Int => Int, pt2: Int => Int): List[Int] =  {\n        val l1 = (snd(pt2) - snd(pt1))* -1\n        val m1 = fst(pt2) - fst(pt1)\n      val g = gcd(l1,m1)\n      val l = l1\/g\n      val m = m1\/g\n      val n = -l*fst(pt1) -m*snd(pt1)    \n      List(l,m,n)\n      \n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336317,"user_id":null,"body":"object ChangePoint {\n    def point(a: Int, b: Int): Boolean => Int = {\n      x => if (x) a else b \n    }\n    def fst(pt: Boolean => Int): Int = {\n      pt(true)\n    }\n    def snd(pt: Boolean => Int): Int = {\n      pt(false)\n    }\n    def sqrDist(pt1: Boolean => Int, pt2: Boolean => Int): Int = {\n      val dx = fst(pt1) - fst(pt2)\n      val dy = snd(pt1) - snd(pt2)\n      dx * dx + dy * dy\n     }\n    def line(pt1: Boolean => Int, pt2: Boolean => Int): List[Int] = {\n      val dx = fst(pt2) - fst(pt1)\n      val dy = snd(pt2) - snd(pt1)\n      List(dy, -dx, (dy * - fst(pt1)) + (dx * snd(pt1)))\n    }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336318,"user_id":null,"body":"object ChangePoint {\n  case class Point(x: Int, y: Int)\n\n  def point(a: Int, b: Int): () => Point =\n    () => Point(a, b)\n\n  def fst(pt: () => Point): Int =\n    pt().x\n\n  def snd(pt: () => Point): Int =\n    pt().y\n\n  def sqrDist(pt1: () => Point, pt2: () => Point): Int =\n    math.pow(fst(pt1) - fst(pt2), 2).toInt + math.pow(snd(pt1) - snd(pt2), 2).toInt\n\n  def line(pt1: () => Point, pt2: () => Point): List[Int] = {\n    val m = fst(pt1) - fst(pt2)\n    val l = snd(pt2) - snd(pt1)\n    val n = -l * fst(pt1) - m * snd(pt1)\n    List(l, m, n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336319,"user_id":null,"body":"object ChangePoint {\n  def point(a: Int, b: Int):()=>List[Int]={\n    ()=>List(a,b)\n  }\n  def fst(pt:()=>List[Int]): Int = {\n    pt().head\n  }\n  def snd(pt:()=>List[Int]): Int = {\n    pt()(1)\n  }\n  def sqrDist(pt1:()=>List[Int], pt2:()=>List[Int]): Int = {\n    (math.pow(pt2()(0)-pt1()(0), 2)+math.pow(pt2()(1)-pt1()(1),2)).toInt\n  }\n  def line(pt1:()=>List[Int], pt2:()=>List[Int]): List[Int] =  List(pt1()(1)-pt2()(1),\n    pt2()(0)-pt1()(0),\n    pt1()(0)*pt2()(1) - pt2()(0)*pt1()(1) )\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336320,"user_id":null,"body":"object ChangePoint {\n    \n    def point(u: Int, v: Int): Function1[Int,(Int,Int)] = \n    new Function1[Int,(Int,Int)] {\n     def apply(x:Int) :(Int,Int)=(u,v)\n    }\n      \n    def fst(pt: Function1[Int,(Int,Int)] ): Int = pt(0)._1 \n    def snd(pt: Function1[Int,(Int,Int)] ): Int = pt(0)._2 \n    val sqr:Int=>Int=x=>x*x\n    def sqrDist(pt1:Function1[Int,(Int,Int)], pt2:Function1[Int,(Int,Int)]): Int =  \n      sqr(pt1(0)._1-pt2(0)._1)+sqr(pt1(0)._2-pt2(0)._2)\n      \n    def line(x1: Function1[Int,(Int,Int)], x2: Function1[Int,(Int,Int)]): List[Int] = {\n      val l= x2(0)._2-x1(0)._2\n      val m= x1(0)._1-x2(0)._1\n      val n= l*x1(0)._1 + m*x1(0)._2\n       \n      List(l,m,-n) \n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336321,"user_id":759,"body":"object ChangePoint {\n    def sqr(x: Int) = x * x\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n    def point(a: Int, b: Int) = (i: Boolean) => if (i) a else b\n    def fst(pt: Boolean => Int) = pt(true)\n    def snd(pt: Boolean => Int) = pt(false)\n    def sqrDist(pt1: Boolean => Int, pt2: Boolean => Int): Int = {\n        sqr(pt1(true) - pt2(true)) + sqr(pt1(false) - pt2(false))\n    }\n    def line(pt1: Boolean => Int, pt2: Boolean => Int): List[Int] =  {\n        val (x1, x2, y1, y2) = (pt1(true), pt2(true), pt1(false), pt2(false))\n        val (dx0, dy0) = (x2 - x1, y2 - y1)\n        val dg = gcd(dx0, dy0)\n        val (dx, dy) = (dx0 \/ dg, dy0 \/ dg)\n        List(dy, -dx, dx * y1 - dy * x1)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ce399e0047a45001c853c2b":[{"id":336322,"user_id":573,"body":"object Kata {\n\n  def parts_sums(l: List[Int]): List[Int] =\n    l.scanRight(0)(_ + _)\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336323,"user_id":null,"body":"object Kata {\n\n  def parts_sums(l: List[Int]): List[Int] = l.foldRight(List(0))((x, xs) => x + xs.head :: xs)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336324,"user_id":138,"body":"import java.util.concurrent.atomic.AtomicInteger\n\nobject Kata {\n\n  def parts_sums(l: List[Int]): List[Int] = {\n    val sum = new AtomicInteger(l.sum)\n    return List(sum.get) ++ l.map(x => sum.addAndGet(-x))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336325,"user_id":null,"body":"object Kata {\n  def parts_sums(l: List[Int]): List[Int] = \n      l.foldLeft(List(l.sum))((x, y) => (x.head - y) :: x).reverse\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336326,"user_id":null,"body":"object Kata {\n  def parts_sums(l: List[Int]): List[Int] = {\n    def innerSum(l: List[Int], acc: List[Int]): List[Int] =\n      if (l.isEmpty) acc.init.reverse else innerSum(l.tail, (acc.head - l.head) :: acc)\n    innerSum(0 :: l, List(l.sum))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336327,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n\n  def parts_sums(l: List[Int]): List[Int] = {\n    @tailrec\n    def loop(ls: List[Int], acc: List[Int]): List[Int] = ls match {\n      case Nil => acc.reverse\n      case h :: t => loop(t, (acc.head - h) +: acc)\n    }\n\n    loop(l, List(l.sum))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336328,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Kata {\n\n  def parts_sums(l: List[Int]): List[Int] = {\n    @tailrec\n    def f(lst: List[Int], currPartsSums: List[Int], currSum: Int): List[Int] =\n      if (lst.isEmpty) 0 :: currPartsSums.reverse\n      else f(lst.tail,  (currSum + lst.head) :: currPartsSums, currSum + lst.head)\n\n    f(l.reverse, List.empty, 0).reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336329,"user_id":null,"body":"object Kata {\n\n  def parts_sums(l: List[Int]): List[Int] = {\n\/\/     @tailrec\n    def f(lst: List[Int], currPartsSums: List[Int], currSum: Int): List[Int] =\n      if (lst.isEmpty) 0 :: currPartsSums.reverse\n      else f(lst.tail,  (currSum + lst.head) :: currPartsSums, currSum + lst.head)\n\n    f(l.reverse, List.empty, 0).reverse\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336330,"user_id":null,"body":"object Kata {\n\n  def parts_sums(l: List[Int]): List[Int] = \n    l.reverse.foldLeft(List(0))( (li, next) => (li.head+next) +: li )\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336331,"user_id":1802,"body":"object Kata {\n\n  def parts_sums(xs: List[Int]): List[Int] =\n    xs.foldRight(List(0)) { (x, xs) => (xs.head + x) :: xs }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5cf2faa867455c0029536212":[{"id":336332,"user_id":null,"body":"object Kata {\n  implicit class Pipetappable[A](x: A) {\n    def pipe[B](f: A => B): B = f(x)\n    def |>[B](f: A => B): B = f(x)\n    def tap(f: A => Any): A = {\n      f(x)\n      x\n    }\n  }\n  implicit class Tapeachable[A, T <% Traversable[A]](trav: T) {\n    def tapEach(f: A => Any): T = {\n      trav.foreach(_.tap(f))\n      trav\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336333,"user_id":null,"body":"object Kata {\n  implicit class IntPipeAndTap(val value: Int) {\n    def pipe[T](f: Int => T): T = f(value)\n  \n    def |>[T](f: Int => T): T = pipe(f)\n  \n    def tap(f: Int => Any): Int = {\n      f(value)\n      value\n    }\n  }\n  \n  implicit class TapEach[A <: Traversable[Int]](val value: A) {\n    def tapEach(f: Int => Any): A = {\n      value.foreach(f)\n      value\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336334,"user_id":null,"body":"object Kata {\n    case class PipeOps[A](value: A) {\n     def pipe[B](func: A => B): B = func(value)\n     def |>[B](func: A => B): B = pipe(func)\n     def tap(func: A => Unit): A = {\n      func(value)\n      value\n    }\n  }\n\n  implicit def pipeOps[A](x: A): PipeOps[A] = PipeOps(x)\n\n   def tapEach[A, T <: Iterable[A]](t: T, func: A => Unit): T = {\n    t.foreach(func)\n    t\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336335,"user_id":null,"body":"object Kata {\n  implicit class PileSyntax[A, B](val x: A) extends AnyVal {\n    def pipe(f: A => B) = f(x)\n    def |>(f: A => B) = pipe(f)\n    def tap(f: A => Unit): A = { f(x); x }\n    }\n  }\n  object TapEach {\n    implicit class TapEachSyntax[A](val xs: Traversable[A]) extends AnyVal {\n      def tapEach(f: A => Unit): Traversable[A] = {\n        xs.foreach {x => f(x) }; xs\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336336,"user_id":null,"body":"object Kata {\n  implicit class Pipe[A](val a: A) {\n    def pipe[B](fn: A => B): B = fn(a)\n    def |>  [B](fn: A => B): B = fn(a)\n    def tap(fn: A => Unit): A = { fn(a); a }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336337,"user_id":null,"body":"object Kata {\n  implicit class Pipe[A, B](val a: A) {\n    def pipe(fn: A => B): B = fn.apply(a)\n    def |>(fn: A => B): B = fn.apply(a)\n    def tap(fn: A => Unit): A = { fn.apply(a); a }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336338,"user_id":149,"body":"object Kata {\n  implicit class AllExtended[T](v: T) {\n    def pipe[G](f: T => G): G = f(v)\n    def |> [G](f: T => G): G = f(v)\n    def tap(f: T => Unit): T = {f(v); v}\n  }\n  \n  implicit class IterableExtended[T](a: Iterable[T]) {\n    def tapEach(f: T => Unit): Iterable[T] = {a.foreach(f); a}\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336339,"user_id":null,"body":"object Kata {\n  implicit class Ext[A](val x: A) {\n    def pipe[B](f:A => B): B = f(x)\n    def |> [B](f:A => B): B = pipe(f)\n    def tap(f:A => Unit):A = {\n      f(x)\n      x\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336340,"user_id":null,"body":"object Kata {\n  \n  class PipeWrapper[T](val value: T) {\n    \n    def pipe[U](function: (T) => U) = function(value)\n    \n    def |>[U](function: (T) => U) = pipe(function)\n    \n    def tap(function: (T) => Unit): T = {\n      function(value)\n      value\n    }\n  }\n  \n  class IterablePipeWrapper[T](val iterable: Iterable[T]) {\n    \n    def tapEach(function: (T) => Unit): Iterable[T] = {\n      iterable.foreach(function(_))\n      iterable\n    }\n  }\n\n  implicit def type2pipeWrapper[T](value: T) = new PipeWrapper(value) \n  \n  implicit def pipeWrapper2type[T](wrapper: PipeWrapper[T]) = wrapper.value\n  \n  implicit def iterable2pipeWrapper[T](iterable: Iterable[T]) = new IterablePipeWrapper(iterable)\n  \n  implicit def pipeWrapper2Iterable[T](wrapper: IterablePipeWrapper[T]) = wrapper.iterable\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336341,"user_id":null,"body":"object Kata {\n  \n  implicit class Piping[A](val a: A) {\n    def pipe[T](f: A => T) : T = f(a)\n    def |>[T](f: A => T) : T = f(a)\n    \n    def tap[T](f: A => T) : A = {\n      f(a)\n      a\n    }\n    \n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5cf39c3992613c0023e7b0b8":[{"id":336342,"user_id":503,"body":"import Weekday._\nimport Season._\nobject Serialization\n{\n\timplicit class U(Q : String)\n\t{\n\t\tdef asWeekday = Q match\n\t\t{\n\t\t\tcase \"MONDAY\" => Monday\n\t\t\tcase \"LUNDI\" => Monday\n\t\t\tcase \"TUESDAY\" => Tuesday\n\t\t\tcase \"WEDNESDAY\" => Wednesday\n\t\t\tcase \"THURSDAY\" => Thursday\n\t\t\tcase \"FRIDAY\" => Friday\n\t\t\tcase \"SATURDAY\" => Saturday\n\t\t\tcase \"SUNDAY\" => Sunday\n\t\t\tcase _ => throw new Exception(\"Cannot deserialize \\\"\" + Q + \"\\\" as a Weekday\")\n\t\t}\n\t\tdef asSeason = Q match\n\t\t{\n\t\t\tcase \"PRINTEMPS\" => Spring\n\t\t\tcase \"ETE\" => Summer\n\t\t\tcase \"AUTOMNE\" => Fall\n\t\t\tcase \"HIVER\" => Winter\n\t\t\tcase _ => throw new Exception(\"Cannot deserialize \\\"\" + Q + \"\\\" as a Season\")\n\t\t}\n\t}\n\timplicit class N(Q : Weekday)\n\t{\n\t\tdef toCode = (\"\" + Q).toUpperCase()\n\t}\n\timplicit class O(Q : Season)\n\t{\n\t\tdef toCode = Q match\n\t\t{\n\t\t\tcase Spring => \"PRINTEMPS\"\n\t\t\tcase Summer => \"ETE\"\n\t\t\tcase Fall => \"AUTOMNE\"\n\t\t\tcase Winter => \"HIVER\"\n\t\t}\n\t}\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336343,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n\n\n   implicit class StringImplicits(s:String){\n    \n   def asWeekday  : Weekday = s match{\n      case \"MONDAY\" => Monday\n      case \"LUNDI\" => Monday \n      case \"TUESDAY\" => Tuesday\n      case \"WEDNESDAY\" => Wednesday\n      case \"THURSDAY\" => Thursday\n      case \"FRIDAY\" => Friday\n      case \"SATURDAY\" => Saturday\n      case \"SUNDAY\" => Sunday\n      case _ => throw new Exception(s\"\"\"Cannot deserialize \"$s\" as a Weekday\"\"\")\n    }   \n \n  \n    def asSeason: Season = s match{\n      case \"PRINTEMPS\" => Spring\n      case \"ETE\" => Summer\n      case \"AUTOMNE\" => Fall\n      case \"HIVER\" => Winter\n      case _ => throw new Exception(s\"\"\"Cannot deserialize \"$s\" as a Season\"\"\")\n    }\n  }\n  \n   implicit class SeasonImplicits(s:Season){\n     \n     val dict:Map[Season, String] = Map(\n       Spring -> \"PRINTEMPS\",\n       Summer -> \"ETE\",\n       Fall -> \"AUTOMNE\",\n       Winter -> \"HIVER\"\n     )\n     \n      def toCode = dict(s)\n     \n     }\n  \n     implicit class WeekdayImplicits(w:Weekday){\n     \n      def toCode = w.toString.toUpperCase\n     \n     }\n   \n   \n}\n\n\n \n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336344,"user_id":149,"body":"object Serialization {\n  import Weekday._\n  import Season._\n\n  implicit class WeekdayString(s: String) {\n    def asWeekday: Weekday = try {\n      if (s == \"LUNDI\") Monday else Weekday.values.filter(_.toString().toUpperCase() == s).head\n    } catch {\n      case _: Exception => throw new Exception(\"Cannot deserialize \\\"\" + s + \"\\\" as a Weekday\")\n    }\n  }\n  \n  implicit class WeekdayExtended(v: Weekday) {\n    def toCode: String = v.toString().toUpperCase()\n  }\n  \n  implicit class SeasonString(s: String) {\n    def asSeason: Season =\n      if (s == \"PRINTEMPS\") Spring\n      else if (s == \"ETE\") Summer\n      else if (s == \"AUTOMNE\") Fall\n      else if (s == \"HIVER\") Winter\n      else throw new Exception(\"Cannot deserialize \\\"\" + s + \"\\\" as a Season\")\n  }\n  \n  implicit class SeasonExtended(v: Season) {\n    def toCode: String =\n      if (v == Spring) \"PRINTEMPS\"\n      else if (v == Summer) \"ETE\"\n      else if (v == Fall) \"AUTOMNE\"\n      else \"HIVER\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336345,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n\n  class WeekdayWrapper(private val weekday: Weekday) {\n    \n    def toCode(): String = weekday match {\n      case Monday => \"MONDAY\"\n      case Tuesday => \"TUESDAY\"\n      case Wednesday => \"WEDNESDAY\"\n      case Thursday => \"THURSDAY\"\n      case Friday => \"FRIDAY\"\n      case Saturday => \"SATURDAY\"\n      case Sunday => \"SUNDAY\"\n    }\n  }\n  \n  class SeasonWrapper(private val season: Season) {\n    \n    def toCode(): String = season match {\n      case Spring => \"PRINTEMPS\"\n      case Summer => \"ETE\"\n      case Fall => \"AUTOMNE\"\n      case Winter => \"HIVER\"\n    }\n  }\n  \n  class StringWrapper(private val string: String) {\n    \n    def asWeekday(): Weekday = string match {\n      case \"MONDAY\" | \"LUNDI\" => Monday\n      case \"TUESDAY\" => Tuesday\n      case \"WEDNESDAY\" => Wednesday\n      case \"THURSDAY\" => Thursday\n      case \"FRIDAY\" => Friday\n      case \"SATURDAY\" => Saturday\n      case \"SUNDAY\" => Sunday\n      case _ => throw new RuntimeException(s\"\"\"Cannot deserialize \"${string}\" as a Weekday\"\"\")\n    }\n    \n    def asSeason(): Season = string match {\n      case \"PRINTEMPS\" => Spring\n      case \"ETE\" => Summer\n      case \"AUTOMNE\" => Fall\n      case \"HIVER\" => Winter\n      case _ => throw new RuntimeException(s\"\"\"Cannot deserialize \"${string}\" as a Season\"\"\")\n    }\n  }\n  \n  implicit def weekday2wrapper(weekday: Weekday) = new WeekdayWrapper(weekday) \n  \n  implicit def season2wrapper(season: Season) = new SeasonWrapper(season) \n  \n  implicit def string2wrapper(string: String) = new StringWrapper(string) \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336346,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n\n  class WeekdayEnum(val s: String = \"\", val w: Weekday = Monday) {\n    def toCode: String = {\n      w match {\n        case Monday => \"MONDAY\"\n        case Tuesday => \"TUESDAY\"\n        case Wednesday => \"WEDNESDAY\"\n        case Thursday => \"THURSDAY\"\n        case Friday => \"FRIDAY\"\n        case Saturday => \"SATURDAY\"\n        case Sunday => \"SUNDAY\"\n      }\n    }\n    \n    def asWeekday: Weekday = {\n      s match {\n        case \"MONDAY\" => Monday\n        case \"LUNDI\" => Monday\n        case \"TUESDAY\" => Tuesday\n        case \"WEDNESDAY\" => Wednesday\n        case \"THURSDAY\" => Thursday\n        case \"FRIDAY\" => Friday\n        case \"SATURDAY\" => Saturday\n        case \"SUNDAY\" => Sunday\n        case x => throw new Exception(s\"Cannot deserialize ${'\\\"' + x + '\\\"' } as a Weekday\")\n      }\n    }\n  }\n  \n  class SeasonEnum(val s: String = \"\", val se: Season = Spring) {\n    def toCode: String = {\n      se match {\n        case Spring => \"PRINTEMPS\"\n        case Summer => \"ETE\"\n        case Fall => \"AUTOMNE\"\n        case Winter => \"HIVER\" \n      }\n    }\n    \n    def asSeason: Season = {\n      s match  {\n        case \"PRINTEMPS\" => Spring\n        case \"ETE\" => Summer\n        case \"AUTOMNE\" => Fall\n        case \"HIVER\" => Winter\n        case x => throw new Exception(s\"Cannot deserialize ${'\\\"' + x + '\\\"' } as a Season\")\n      }\n    }\n  }\n  \n  implicit def toWeekday(s: String) = new WeekdayEnum(s)\n  implicit def WtoString(w: Weekday) = new WeekdayEnum(\"\", w)\n  implicit def toSeason(s: String) = new SeasonEnum(s)\n  implicit def StoString(s: Season) = new SeasonEnum(\"\", s)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336347,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n  \n  import scala.reflect.ClassTag\n  \n  sealed trait FrenchSeason {\n    val engSeason: Season\n  }\n\n  object FrenchSeason {\n\n    case object Automne extends FrenchSeason {\n      override val engSeason: Season = Season.Fall\n    }\n\n    case object Printemps extends FrenchSeason {\n      override val engSeason: Season = Season.Spring\n    }\n\n    case object Ete extends FrenchSeason {\n      override val engSeason: Season = Season.Summer\n    }\n\n    case object Hiver extends FrenchSeason {\n      override val engSeason: Season = Season.Winter\n    }\n\n    val values: List[FrenchSeason] = List(Printemps, Automne, Ete, Hiver)\n  }\n\n  trait Encoder[-T] {\n    def encode(obj: T): String\n  }\n\n  trait Decoder[+T] {\n    def decode(s: String): Option[T]\n  }\n\n  implicit val seasonEncoder: Encoder[Season] =\n    (obj: Season) => FrenchSeason.values.find(_.engSeason == obj).map(_.toString).get\n\n  implicit def seasonDecoder: Decoder[Season] = (s: String) => FrenchSeason.values.find(_.toString == s).map(_.engSeason)\n\n  implicit val weekdayEncoder: Encoder[Weekday] = (obj: Weekday) => obj.toString\n\n  implicit def weekdayDecoder: Decoder[Weekday] = (s: String) => Weekday.values.find(day => s == \"Lundi\" && day == Monday || day.toString == s)\n\n\n  implicit class ToCode[X](val obj: X) extends AnyVal {\n    def toCode(implicit encoder: Encoder[X]): String = encoder.encode(obj).toUpperCase\n  }\n\n  implicit class FromCode(val s: String) extends AnyVal {\n    def asSeason: Season = as[Season]\n\n    def asWeekday: Weekday = as[Weekday]\n\n    private def as[T](implicit classTag: ClassTag[T], decoder: Decoder[T]): T =\n      decoder\n        .decode(s.toLowerCase.capitalize)\n        .getOrElse(throw new RuntimeException(s\"\"\"Cannot deserialize \"$s\" as a ${classTag.runtimeClass.getSimpleName}\"\"\"))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336348,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n\n  implicit class StringImprovements(val s: String) {\n    def asWeekday = {\n      s match {\n        case \"MONDAY\" => Monday\n        case \"LUNDI\" => Monday\n        case \"TUESDAY\" => Tuesday\n        case \"WEDNESDAY\" => Wednesday\n        case \"THURSDAY\" => Thursday\n        case \"FRIDAY\" => Friday\n        case \"SATURDAY\" => Saturday\n        case \"SUNDAY\" => Sunday\n        case x => throw new Exception(\"Cannot deserialize \\\"\" + x + \"\\\" as a Weekday\")\n      }\n      }\n    \n    def asSeason = {\n      s match {\n        case \"PRINTEMPS\" => Spring\n        case \"ETE\" => Summer\n        case \"AUTOMNE\" => Fall\n        case \"HIVER\" => Winter       \n        case x => throw new Exception(\"Cannot deserialize \\\"\" + x + \"\\\" as a Season\")\n      \n      }\n    }\n    }\n    \n    implicit class WkdayImprovements(val w: Weekday) {\n    def toCode = {\n      w match {\n        case Monday => \"MONDAY\"\n        case Tuesday => \"TUESDAY\"\n        case Wednesday => \"WEDNESDAY\"\n        case Thursday => \"THURSDAY\"\n        case Friday => \"FRIDAY\"\n        case Saturday => \"SATURDAY\"\n        case Sunday => \"SUNDAY\"\n      }\n    }\n  }\n      implicit class SeasonImprovements(val s : Season) {\n    def toCode = {\n      s match {\ncase Spring => \"PRINTEMPS\"\ncase Summer => \"ETE\"\ncase Fall => \"AUTOMNE\"\ncase Winter => \"HIVER\"\n      }\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336349,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n\n  implicit class RichString(value: String) {\n    def asSeason: Season = value match {\n      case \"PRINTEMPS\" => Spring\n      case \"ETE\" => Summer\n      case \"AUTOMNE\" => Fall\n      case \"HIVER\" => Winter\n      case _ => sys.error(s\"\"\"Cannot deserialize \\\"$value\\\" as a Season\"\"\")\n    }\n\n    def asWeekday: Weekday = if (value == \"LUNDI\") Monday\n    else {\n      Weekday.values.find(weekday => weekday.toString.toUpperCase == value)\n        .getOrElse(sys.error(s\"\"\"Cannot deserialize \\\"$value\\\" as a Weekday\"\"\"))\n    }\n  }\n\n  implicit class RichWeekday(weekday: Weekday) {\n    def toCode: String = weekday.toString.toUpperCase\n  }\n\n  implicit class RichSeason(season: Season) {\n    def toCode: String = season match {\n      case Spring => \"PRINTEMPS\"\n      case Summer => \"ETE\"\n      case Fall => \"AUTOMNE\"\n      case Winter => \"HIVER\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336350,"user_id":null,"body":"object Serialization {\n\n  import Weekday._\n  import Season._\n  \n  implicit class WeekdaySerializer(weekday: Weekday) {\n    def toCode = weekday.getClass.getSimpleName.replace(\"$\", \"\").toUpperCase\n  }\n  \n  implicit class SeasonSerializer(season: Season) {\n    def toCode = season.getClass.getSimpleName.replace(\"$\", \"\") match {\n      case \"Spring\" => \"PRINTEMPS\"\n      case \"Summer\" => \"ETE\"\n      case \"Fall\" => \"AUTOMNE\"\n      case \"Winter\" => \"HIVER\"\n    }\n  }\n  \n  implicit class Deserializer(s: String) {\n    def asWeekday = Weekday.values.find(_.toCode == s) match {\n      case Some(weekday) => weekday\n      case None => s match {\n        case \"LUNDI\" => Monday\n        case _ => throw new Exception(\"Cannot deserialize \\\"\" + s + \"\\\" as a Weekday\")\n      }\n    }\n    \n    def asSeason = Season.values.find(_.toCode == s) match {\n      case Some(season) => season\n      case None => throw new Exception(\"Cannot deserialize \\\"\" + s + \"\\\" as a Season\")\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336351,"user_id":null,"body":"object Serialization {\n  import Weekday._\n  import Season._\n  \n  implicit class WeekdaySerializer(self: Weekday) {\n    def toCode = self.toString.toUpperCase\n  }\n  \n  implicit class SeasonSerializer(self: Season) {\n    def toCode = self match {\n      case Spring => \"PRINTEMPS\"\n      case Summer => \"ETE\"\n      case Fall => \"AUTOMNE\"\n      case Winter => \"HIVER\"\n    }\n  }\n  \n  implicit class StringSerializer(self: String) {\n    def asWeekday = self match {\n      case \"LUNDI\" => Monday\n      case x => Weekday.values.find(_.toString == x.toLowerCase.capitalize) match {\n        case Some(weekday) => weekday\n        case None => throw new Exception(s\"\"\"Cannot deserialize \"$x\" as a Weekday\"\"\")\n      }\n    }\n    \n    def asSeason = self match {\n      case \"PRINTEMPS\" => Spring\n      case \"ETE\" => Summer\n      case \"AUTOMNE\" => Fall\n      case \"HIVER\" => Winter\n      case x => throw new Exception(s\"\"\"Cannot deserialize \"$x\" as a Season\"\"\")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5cf3e6d3c6c7fc00269fc475":[{"id":336352,"user_id":527,"body":"import scala.language.implicitConversions\n\nobject Kata {\n  implicit def optionToNumeric[T : Numeric](x: Option[T]): T =\n    x.getOrElse(implicitly[Numeric[T]].zero)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336353,"user_id":null,"body":"object Kata {\n  implicit def optionToInt(o: Option[Int]): Int = o.getOrElse(0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336354,"user_id":null,"body":"object Kata {\n  implicit def optionToInt(x: Option[Int]): Int = x.getOrElse(0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336355,"user_id":null,"body":"object Kata {\n\n  implicit def optInt2Int(oi:Option[Int]) = oi.getOrElse(0) \n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336356,"user_id":null,"body":"object Kata {\n   implicit def optionToNumber(x: Option[Int]): Int = x.getOrElse(0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336357,"user_id":null,"body":"object Kata {\n  implicit def fff(x: Option[Int]): Int = x.getOrElse(0)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336358,"user_id":null,"body":"object Kata {\n  implicit def f1(x: Option[Int]): Int = x.getOrElse(0)\n  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336359,"user_id":null,"body":"import scala.language.implicitConversions\n\nobject Kata {\n\n  implicit def optionToInt(x: Option[Int]): Int = x.getOrElse(0)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336360,"user_id":null,"body":"object Kata {\n  implicit def OptionToInt(value: Option[Int]): Int =\n    value match {\n      case Some(x) => x\n      case _ => 0\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336361,"user_id":null,"body":"object Kata {\n  implicit def fromOptionToInt(value: Option[Int]): Int =\n    value match {\n      case Some(x) => x\n      case _ => 0\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d09430767455c0019eb5a3f":[{"id":336362,"user_id":null,"body":"import scala.collection.mutable._\nimport scala.annotation.tailrec\n\ncase class VanEck(val args: Int*) {\n  \n  def vanEckSeq(args: Buffer[Int]): (Seq[Int], Map[Int, Int]) = {\n    val vals = args.dropRight(1).distinct.map(x => (x, args.dropRight(1).lastIndexOf(x)))\n    val firsts = collection.mutable.HashMap(args.distinct.map(x => (x,args.indexOf(x))).toSeq: _*)\n    val valsMapped = collection.mutable.HashMap(vals.toSeq: _*)\n    def vanEckAux(l: Buffer[Int]): (Seq[Int], Map[Int, Int]) = {\n      while (l.length < 1000000) {\n        val n = l.last\n        val m = valsMapped.get(n)\n        valsMapped(n) = l.length - 1\n        if (m == None) {\n          firsts(n) = l.length - 1\n          l += 0 \n        }\n        else {\n          l += l.length - m.get - 1\n        }\n      }\n      (l, firsts)\n    }\n    vanEckAux(args)\n  }  \n  \n  private[this] val processed = vanEckSeq(args.toBuffer)\n  \n  private[this] val seq = processed._1\n  \n  private[this] val indices = processed._2\n  \n  def term(i: Int): Int = seq(i)\n\n  def sequence(i: Int): Iterable[Int] = seq.take(i)\n\n  def every(n: Int): Int = indices.view.filterKeys(_ < n + 1).values.max\n\n  def first(n: Int): Int = indices(n)\n\n  def fast(i: Int): Int = sequence(i+1).max\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336363,"user_id":468,"body":"import scala.collection.mutable\nimport scala.collection.mutable.ListBuffer\n\ncase class VanEck() {\n\n  private val series = new ListBuffer[Int]()\n  private val history = new mutable.HashMap[Int, Occurrence]()\n\n  def term(i: Int): Int = {\n    ensuringLength(i + 1)\n    series(i)\n  }\n\n  def ensuringLength(i: Int): Unit =\n    while (series.length < i) next()\n\n  def next(): Unit = add(history(series.last).gap)\n\n  def add(element: Int): Unit = {\n    val length = series.length\n    series.append(element)\n    if (!history.contains(element))\n      history.put(element, Occurrence(length))\n    else\n      history(element).add(length)\n\n  }\n\n  def sequence(i: Int): Iterable[Int] = {\n    ensuringLength(i)\n    series.slice(0, i)\n  }\n\n  def every(n: Int): Int = (0 to n).map(first).max\n\n  def first(n: Int): Int = {\n    while (!history.contains(n)) next()\n    history(n).first\n  }\n\n\n  def fast(i: Int): Int = {\n    ensuringLength(i + 1)\n    series.slice(0, i + 1).max\n  }\n\n  case class Occurrence(first: Int) {\n    var last: Int = first\n    var gap: Int = 0\n\n    def add(occurrence: Int): Unit = {\n      gap = occurrence - last\n      last = occurrence\n    }\n\n  }\n}\n\nobject VanEck {\n  def apply(seed: Int*): VanEck = {\n    val ins = VanEck()\n    seed.foreach(ins.add)\n    ins\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d50e3914861a500121e1958":[{"id":336364,"user_id":573,"body":"object Kata {\n\n  def add_letters(letters: List[Char]): Char = {\n    val abc = 'z' +: ('a' to 'y')\n    abc(letters.map(abc.indexOf).sum % 26)\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336365,"user_id":null,"body":"object Kata {\n  val alphaToNum = ('a' to 'z').zip(1 to 26).toMap\n  val numToAlpha = (1 to 26).zip('a' to 'z').toMap\n  \n  def add_letters(letters: List[Char]): Char = {\n    val letterPos = letters.flatMap(alphaToNum.get).sum % 26\n    numToAlpha.get(letterPos) getOrElse 'z'\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336366,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    if (letters.isEmpty) 'z' \/\/ \u3082\u3057letters\u304c\u7a7a\u306e\u5834\u5408\u306f'z'\u3092\u8fd4\u3059\n    else {\n      val alphabets: String = \"abcdefghijklmnopqrstuvwxyz\" \/\/ a\u304b\u3089z\u3092\u542b\u3093\u3060\u6587\u5b57\u5217\u3092\u4f5c\u6210\n      var count: Int = 0 \/\/ count\u7528\u306e\u5909\u6570\u3092\u4f5c\u6210\u30570\u3067\u521d\u671f\u5316\n\n      for (letter <- letters) { \/\/ \u5f15\u6570letters\u3092letter\u306b\u6e21\u3057alphabets\u306eindex\u3092\u53d6\u5f97\u3057\u30661\u3092\u8db3\u3057\u3066\u5909\u6570 count\u306b\u4ee3\u5165\n        count += alphabets.indexOf(letter) + 1\n      }\n      alphabets.charAt((count - 1) % 26); \/\/ count-1\u306e\u7406\u7531\u306findex\u756a\u53f7\u304c0\u304b\u3089\u59cb\u307e\u308b\u305f\u3081\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336367,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    if (letters.length == 0) return 'z'\n    val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var i = 0\n    var sum = 0\n    while (i != letters.length) {\n      var j = 0\n      while (j != alphabet.length) {\n        if (letters(i) == alphabet(j)) {\n          sum += j+1\n          j = alphabet.length - 1\n        }\n        j += 1\n      }\n      i += 1\n    }\n    \n    sum = sum % 26\n    if (sum == 0) return 'z'\n    \n    alphabet(sum-1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336368,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    if (letters.nonEmpty) {\n      var res = letters.map(ch => ch.-(96)).sum.%(26)\n      if (res == 0) res += 96 + 26\n      else res += 96\n      res.toChar\n    }\n    else 'z'\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336369,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    \n    var total = 0\n    \n    if(letters.length == 0){\n    return 'z'\n   }\n    else{\n      for(n <- letters){\n        total = total + n.toInt - 96\n      }\n        while(total > 26){\n          total = total - 26\n        }\n      \n      return (total + 96).toChar\n  }\n     \n    \/\/ your code here\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336370,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    val m = ('a' to 'z').zipWithIndex.toMap\n\n    var s = letters.map(m.get(_) match {\n      case Some(x)=> x+1\n      case _ => 0\n    }).sum\n\n    while (s>m.size) {s=s-m.size}\n\n    m.find(_._2 == s-1) match {\n      case Some(x)=> x._1\n      case None => 'z'\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336371,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    \n    if(letters.isEmpty) {\n      'z'\n    }\n    else {\n    val arr= letters.toArray\n    def helper(acc: Int, idx: Int):Int = {\n      if(idx == arr.length)\n        acc\n      else\n        helper(acc + arr(idx).toInt, idx + 1)\n    }\n    val t = (helper(0, 0) - (arr.length) * 96)\n    \/\/ System.out.println(t)\n    if(t % 26 == 0)\n      'z'\n    else\n      (96 + t%26).toChar\n  }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336372,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    if (letters.nonEmpty) {\n      var res = letters.map(ch => ch.-(96)).sum.%(26)\n      if (res == 0) res += 96 + 26\n      else res += 96\n      return res.toChar\n    }\n    else 'z'\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336373,"user_id":null,"body":"object Kata {\n  def add_letters(letters: List[Char]): Char = {\n    val alphabet = \"zabcdefghijklmnopqrstuvwxy\"\n    if (letters.isEmpty)\n      'z'\n    else {\n      alphabet((letters.map(alphabet.indexOf(_)).sum % 26))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d95b7644a336600271f52ba":[{"id":336374,"user_id":573,"body":"object RobinsonCrusoe {\n  import math._\n\n  def crusoe(n: Int, d: Double, \u03b1: Double, dMult: Double, \u03b1Mult: Double): (Double, Double) =\n    if (n == 0 || d == 0) {\n      (0, 0)\n    } else {\n      val (x, y) = crusoe(n-1, d * dMult, \u03b1 * \u03b1Mult, dMult, \u03b1Mult)\n      (x + d * cos(toRadians(\u03b1)), y + d * sin(toRadians(\u03b1)))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336375,"user_id":null,"body":"object RobinsonCrusoe {\n  \n  def crusoe(n: Int, d: Double, ang: Double, distmult: Double, angmult: Double): (Double, Double) = {\n    import scala.math.{sin, cos, Pi}\n    if (n == 0 || d== 0) {\n      (0,0)\n    }\n    else {\n      val (x,y) = crusoe(n-1, d*distmult, ang*angmult, distmult, angmult)\n      (x + d * cos(Pi * ang\/180), y + d * sin(Pi * ang\/180))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336376,"user_id":null,"body":"import scala.math._\nobject RobinsonCrusoe {\n    def crusoe(n: Int, d: Double, ang: Double, distmult: Double, angmult: Double, x: Double = 0, y: Double = 0): (Double, Double) = {\n        if (n == 0) (x, y)\n      \n        else crusoe(n - 1, d * distmult, ang * angmult, distmult, angmult, x + d * cos(Pi * ang \/ 180), y + d * sin(Pi * ang \/ 180))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336377,"user_id":null,"body":"object RobinsonCrusoe {\n\n  def crusoe(n: Int, d: Double, ang: Double, distmult: Double, angmult: Double, current: Int = 0, x: Double = 0, y: Double = 0): (Double, Double) = {\n    if (current == n) {\n      (x, y)\n    }\n    else {\n      val radians = math.toRadians(ang)\n      val newX = x + d*math.cos(radians)\n      val newY = y + d*math.sin(radians)\n      val newAng = ang * angmult\n      val newD = d * distmult\n      crusoe(n, newD, newAng, distmult, angmult, current+1, newX, newY)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336378,"user_id":468,"body":"object RobinsonCrusoe {\n  def crusoe(n: Int, d: Double, ang: Int, distmult: Double, angmult: Double): (Double, Double) = {\n    import math.{cos, sin, toRadians}\n\n    \/**\n     * Iteratively travels by turning t radians from x axis and moving forward r units, from x, y\n     * (x, y) starts at (0, 0)\n     * After each iteration, steps is incremented, and r and t is multiplied by their respective multipliers.\n     * @param x The x co-ordinate of the current point\n     * @param y The y co-ordinate of the current point\n     * @param r The distance to move forward\n     * @param t The direction of travel, in radians from x-axis\n     * @param step The iteration step\n     * @return\n     *\/\n    @scala.annotation.tailrec\n    def travel(x: Double, y: Double, r: Double, t: Double, step: Int): (Double, Double) =\n      if (step == n) (x, y)\n      else travel(x + r * cos(t), y + r * sin(t), r * distmult, t * angmult, step + 1)\n\n    travel(0, 0, d, toRadians(ang), 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336379,"user_id":null,"body":"object RobinsonCrusoe {\n\n  def crusoe(n: Int, d: Double, ang: Int, distmult: Double, angmult: Double): (Double, Double) = {\n    def newCoords(n: Int, x: Double, y: Double, ang: Double, d: Double): (Double, Double) = {\n      if (n > 0) {\n        val xtot = x + calc_x(ang, d)\n        val ytot = y + calc_y(ang, d)\n        newCoords(n - 1, xtot, ytot, ang * angmult, d * distmult)\n      } else (x, y)\n    }\n    newCoords(n, 0.0, 0.0, ang, d)\n  }\n  \n  def calc_x(ang: Double, h: Double): Double = {\n    Math.cos(Math.toRadians(ang)) * h\n  }\n  \n  def calc_y(ang: Double, h: Double): Double = {\n    Math.sin(Math.toRadians(ang)) * h\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336380,"user_id":null,"body":"object RobinsonCrusoe {\n\n  def crusoe(n: Int, d: Double, ang: Double, distmult: Double, angmult: Double): (Double, Double) = {\n  val res = Iterator.iterate((0.toDouble,0.toDouble,d,ang,0)){\n    r => (r._1 + r._3 * Math.cos(Math.toRadians(r._4))\n          ,r._2 + r._3 * Math.sin(Math.toRadians(r._4))\n          ,r._3 * distmult\n          ,r._4 * angmult\n          ,r._5+1\n          )\n  }.\n  takeWhile(r => r._5<=n).\n  toList.\n  last\n\n  (res._1,res._2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336381,"user_id":2525,"body":"import scala.math._\nobject RobinsonCrusoe {\n    def crusoe(n: Int, d: Double, ang: Double, distmult: Double, angmult: Double, x: Double = 0, y: Double = 0): (Double, Double) = {\n        if (n==0) { return (x, y) }\n      \n        crusoe(n-1, d*distmult, ang*angmult, distmult, angmult, x+d*cos(Pi*ang\/180), y+d*sin(Pi*ang\/180))\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336382,"user_id":null,"body":"object RobinsonCrusoe {\n\n  import math._\n  \n  def crusoe(n: Int, d: Double, ang: Double, distmult: Double, angmult: Double): (Double, Double) = {\n    if (n == 0 || d == 0) {\n      return (0, 0)\n    } else {\n      var (x, y) = crusoe(n - 1, d * distmult, ang * angmult, distmult, angmult)\n      return (x + d * cos(toRadians(ang)), y + d * sin(toRadians(ang)))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336383,"user_id":53,"body":"object RobinsonCrusoe {\n  \n  def crusoe(n: Int, d: Double, ang: Int, distmult: Double, angmult: Double): (Double, Double) = {\n    \n    var x: Double = 0;\n    var y: Double = 0;\n    var e: Double = d;\n    var beta: Double = ang * Math.PI \/ 180;\n\n    for (i <- 1 to n)\n    {\n        x += e * Math.cos(beta);\n        y += e * Math.sin(beta);\n        e = e * distmult;\n        beta = beta * angmult;\n    }\n\n    return (x, y);\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d98b6b38b0f6c001a461198":[{"id":336384,"user_id":573,"body":"object CodeDecode {\n\n  def code(str: String): String =\n    str.map(_.asDigit.toBinaryString).map(b => s\"\"\"${\"0\" * (b.size - 1)}1$b\"\"\").mkString\n\n  val figures = (0 to 9).map(i => code(i.toString) -> i)\n  \n  def decode(str: String): String =\n    Seq.unfold(str)(x => figures.collectFirst { case (s, i) if x.startsWith(s) => (i, x.stripPrefix(s)) }).mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336385,"user_id":null,"body":"object CodeDecode {\n  def code(strng: String): String =\n    strng.map(_.asDigit).map {\n      d => \"0\" * (d.toBinaryString.length - 1) + \"1\" + d.toBinaryString\n    }.mkString\n\n  def decode(str: String): String = str match {\n    case s if s.length == 0 => \"\"\n    case _ =>\n      val i = str.indexOf('1')\n      (Integer.parseInt(str.slice(i + 1, 2 * i + 2), 2).toString\n        + decode(str.slice(2 * i + 2, str.length)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336386,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject CodeDecode {\n  import scala.annotation.tailrec\n\n  def code(strng: String): String = {\n    strng.map(c =>\n    {\n      val bin : String = c.asDigit.toBinaryString\n\n      \"0\"*(bin.length-1) + '1' + bin\n    }).mkString\n  }\n\n\n  def decode(str: String): String = {\n    @tailrec\n    def parseBin(src: String, acc: String): String = {\n      val count = src.indexOf('1')+1\n      val pattern = s\".{${count}}(.{${count}})(.*)\".r\n\n      src match {\n        case pattern(bin, left) if src.nonEmpty => parseBin(left, acc + Integer.parseInt(bin, 2))\n        case _ => acc\n      }\n    }\n\n    parseBin(str, \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336387,"user_id":null,"body":"object CodeDecode {\n\ndef code(strng: String): String = strng.split(\"\").map(x=>\"0\"*(x.toInt.toBinaryString.length-1)+\"1\"+x.toInt.toBinaryString).mkString(\"\")\n  def decode(str: String): String = if(str.length==0) \"\" else Integer.parseInt(str.substring(str.indexOf('1')+1, 2*(str.indexOf('1')+1)), 2).toString+\n    decode(str.substring(2*(str.indexOf('1')+1)))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336388,"user_id":null,"body":"object CodeDecode {\n  \n  val decToBin = Map(\n    '0' -> \"0\",\n    '1' -> \"1\",\n    '2' -> \"10\",\n    '3' -> \"11\",\n    '4' -> \"100\",\n    '5' -> \"101\",\n    '6' -> \"110\",\n    '7' -> \"111\",\n    '8' -> \"1000\",\n    '9' -> \"1001\"\n  )\n  \n  val binToDec = decToBin.map(_.swap)\n\n  def code(str: String): String = {\n    str\n      .map(decToBin.getOrElse(_, \"\"))\n      .map(num => \"0\" * (num.size - 1) + \"1\" + num)\n      .mkString\n  }\n  \n  def decode(str: String): String = {\n    val it = str.iterator\n    val result = new StringBuilder()\n    while (it.hasNext) {\n      val size = it.takeWhile(_ != '1').count(x => true) + 1\n      val digit = it.take(size).mkString\n      result.append(binToDec.getOrElse(digit, \"\"))\n    }\n    result.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336389,"user_id":null,"body":"object CodeDecode {\n\n  def code(strng: String): String = {\n    val list = strng.split(\"\").toList.map(x => x.toInt.toBinaryString)\n    list.flatMap(x => (List.fill(x.length-1)(0) :+ 1) ++ x).mkString(\"\")\n  }\n  def decode(str: String, list: List[Int] = List()): String = {\n    if (str.length == 0) {\n      list.mkString(\"\")\n    }\n    else {\n      val n = str.takeWhile(_ == '0').length + 1\n      val digit = Integer.parseInt(str.take(2*n).drop(n), 2)\n      decode(str.drop(2*n), list :+ digit)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336390,"user_id":573,"body":"object CodeDecode {\n\n  def code(str: String): String =\n    str.map(_.toString.toInt.toBinaryString).map(b => s\"\"\"${\"0\" * (b.size - 1)}1$b\"\"\").mkString\n\n  val figures = (0 to 9).map(i => code(i.toString) -> i)\n  \n  def decode(str: String): String =\n    Seq.unfold(str)(x => figures.collectFirst { case (s, i) if x.startsWith(s) => (i, x.stripPrefix(s)) }).mkString\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336391,"user_id":null,"body":"import scala.collection.mutable.ListBuffer\n\nobject CodeDecode {\n\n  def code(s: String): String = {\n    s.map(c => {\n            val binrep = c.asDigit.toBinaryString\n            val k = binrep.length\n            val b = \"0\" * (k-1) + \"1\"\n            b + binrep\n          }\n    ).mkString(\"\")\n  }\n\n  def decode(str: String): String = {\n\n    var start = 0\n    var result = new ListBuffer[String]()\n\n    while (start < str.length){\n        var binStartIndex = (start to str.length).dropWhile(str(_) != '1').drop(1).take(1)(0)\n        start = 2 * binStartIndex - start  \n        result +=  decodeSlice(binStartIndex, start, str)\n    \n    }\n    result.mkString(\"\")\n  }\n  \n  def decodeSlice(dropUntil : Int, end: Int, str: String): String ={\n    val binarySt = str.slice(dropUntil, end)\n    Integer.parseInt(binarySt, 2).toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336392,"user_id":null,"body":"object CodeDecode {\n\n  def code(strng: String): String =\n    strng.map(ch => code(ch.asDigit)).mkString\n\n  def decode(str: String): String =\n    if (str.isEmpty) {\n      \"\"\n    } else {\n      val i = if (str.startsWith(\"1\")) 2 else if (str.startsWith(\"01\")) 4 else if (str.startsWith(\"001\")) 6 else 8\n      decodePart(str.take(i)) + decode(str.drop(i))\n    }\n\n  def code(num: Int): String =\n    num match {\n      case 0 => \"10\"\n      case 1 => \"11\"\n      case 2 => \"0110\"\n      case 3 => \"0111\"\n      case 4 => \"001100\"\n      case 5 => \"001101\"\n      case 6 => \"001110\"\n      case 7 => \"001111\"\n      case 8 => \"00011000\"\n      case 9 => \"00011001\"\n    }\n\n  def decodePart(str: String): String =\n    str match {\n      case \"10\"       => \"0\"\n      case \"11\"       => \"1\"\n      case \"0110\"     => \"2\"\n      case \"0111\"     => \"3\"\n      case \"001100\"   => \"4\"\n      case \"001101\"   => \"5\"\n      case \"001110\"   => \"6\"\n      case \"001111\"   => \"7\"\n      case \"00011000\" => \"8\"\n      case \"00011001\" => \"9\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336393,"user_id":null,"body":"object CodeDecode {\n  def code(strng: String): String = {\n    strng.map(_.toInt - '0').map(d => \"0\" * (d.toBinaryString.length - 1) + \"1\" + d.toBinaryString).mkString(\"\")\n  }\n  def decode(str: String): String = {\n    val map = (9 to 0 by -1).map(digit => digit.toString -> code(digit.toString))\n\n    def loop(str: String, decoded: List[String]): List[String] = {\n      if(str.isEmpty) decoded\n      else {\n        val (digit, cipher) = map.find(x => str.startsWith(x._2)).get\n        loop(str.drop(cipher.length), digit :: decoded)\n      }\n    }\n    loop(str, Nil).reverse.mkString(\"\")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5da1df6d8b0f6c0026e6d58d":[{"id":336394,"user_id":492,"body":"object Section {\n\n  private def divNb(n: Long): Int = {\n    var i: Int = 2\n    var p: Int = 1\n    var nn = n\n    while (nn > 1) {\n      var kt: Int = 0\n      while (nn % i == 0) {\n        nn = nn \/ i\n        kt += 1\n      }\n      if (kt != 0) p *= (kt + 1)\n      i += 1\n    }\n    p\n  }\n  def c(k: Long): Int = {\n    val r: Long = (Math.sqrt(k)).toLong\n    if (r * r == k) divNb(k * r)\n    else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336395,"user_id":null,"body":"object Section {\n\n  def factorize(x: BigInt): List[BigInt] = {\n    def foo(x: BigInt, a: BigInt = 2, list: List[BigInt] = Nil): List[BigInt] = a*a > x match {\n      case false if x % a == 0 => foo(x \/ a, a    , a :: list)\n      case false               => foo(x    , a + 1, list)\n      case true                => x :: list\n    }\n    foo(x)\n  }\n  \n  def c(k: BigInt): Int = {\n    val factors = factorize(k).groupBy(identity).map(x => x._2.length * 3)\n    if (factors.forall(x => x % 2 == 0)) factors.map(x => x\/2 + 1).product\n    else 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336396,"user_id":53,"body":"object Section {\n\n  def c(k: Long): Int = {\n    var sq = math.floor(math.sqrt(k)).toLong\n    if (sq * sq != k) {\n      return 0\n    } else {\n      var i = 2\n      var num = k * sq\n      var ans = 1\n      while (num > 1) {\n        var cnt = 0\n        while (num % i == 0) {\n          num = math.floor(num \/ i).toLong\n          cnt += 1\n        }\n        ans *= (cnt + 1)\n        i += 1\n      }\n      return ans\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336397,"user_id":null,"body":"object Section {\n\n  def c(k: Long): Int = {\n    val s = math.sqrt(k)\n    val r = math.pow(s, 3)\n    if (s.isWhole && r.isWhole) countOfDivisors(r.toLong).toInt else 0\n  }\n\n  private def countOfDivisors(n: Long): Long = {\n    var i      = 2L\n    var number = n\n    var mul    = 1L\n    while (number > 1) {\n      if (number % i == 0) {\n        var pow = 0L\n        while (number % i == 0) {\n          number \/= i\n          pow += 1\n        }\n        mul *= (pow + 1)\n      }\n      i += 1\n    }\n    mul\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336398,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Section {\n\n  def c(k: Long): Int = {\n    def factorize(x: Long): List[Long] = {\n      @tailrec\n      def foo(x: Long, a: Long = 2, list: List[Long] = Nil): List[Long] = a*a > x match {\n        case false if x % a == 0 => foo(x \/ a, a    , a :: list)\n        case false               => foo(x    , a + 1, list)\n        case true                => x :: list\n      }\n      foo(x)\n    }\n  \n    val prime_dec = factorize(k).groupBy(x => x).view.mapValues(_.size).toList\n    if (prime_dec.forall(x => x._2 % 2 == 0))\n      prime_dec.map(x=>(x._2*3\/2 + 1)).reduce(_ * _)\n    else\n      0\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336399,"user_id":null,"body":"import scala.math.{pow, floor, ceil}\n\nobject Section {\n  \n  def baseFactors(n: Long): Map[Long, Int] = {\n        \n    def updateMap(map: Map[Long, Int])(key: Long): Map[Long, Int] = map.get(key) match {\n      case None => map + (key -> 1)\n      case Some(v) => map.updated(key, v + 1)\n    }\n   \n    def loop(r: Long, multiples: Map[Long, Int]): Map[Long, Int]  = {\n      val f = updateMap(multiples) _\n      \n      if (r == 1) multiples\n      else LazyList\n        .range(2L, ceil(pow(r, 0.5)).toLong + 1)\n        .find( x => r % x == 0  )\n        .fold(f(r))(x => loop(r \/x, f(x)))\n    }\n    loop(n, Map.empty)\n }\n     \n  def c(k: Long): Int = {\n    \n    val factors = baseFactors(k)\n\n   if (factors.toList.exists(x => x._2 % 2 !=0)) { 0 } else {\n      \n      val target =  \n       factors\n         .map{ case (key, value) => pow(key, value * 3 \/ 2).toLong }\n         .reduce(_*_)\n\n\n      baseFactors(target)\n       .map {case (_, frequency) => frequency + 1}\n       .reduce(_*_)\n  \n    }\n  }\n}  ","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336400,"user_id":1228,"body":"object Section {\n\n  def c(k: Long): Int = {\n    var ans = 1\n    var i = 2\n    var kk = k\n    while (kk != 1) {\n      var cnt = 0\n      while (kk % i == 0) {\n        kk = kk \/ i\n        cnt += 1\n      }\n      if (cnt % 2 == 1) return 0\n      ans *= (3 * cnt \/ 2) + 1\n      i += 1\n    }\n    ans\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336401,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Section {\n\n  def c(k: Long): Int = {\n    val squareRoot = math.sqrt(k).toLong\n    if (squareRoot * squareRoot == k) totalDivisors(squareRoot, 3)\n    else 0\n  }\n  \n  def totalDivisors(x: Long, power: Int): Int = {\n    @tailrec\n    def divide(x: Long, i: Long, count: Int, total: Int): Int = {\n      if (x == 1) total * (count * power + 1)\n      else if (x % i == 0) divide(x \/ i, i, count + 1, total)\n      else if (x < i * i) divide(1, x, 1, total * (count * power + 1))\n      else {\n        val step = if (i > 2) 2 else 1\n        divide(x, i + step, 0, total * (count * power + 1))\n      }\n    }\n    divide(x, 2, 0, 1)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5dad6e5264e25a001918a1fc":[{"id":336402,"user_id":492,"body":"import java.util.regex.Pattern\nimport java.util.regex.Matcher\n\nobject Decode {\n\n  def decode(r: String): String = {\n    val dict = Map(3 -> 9,9 -> 3,21 -> 5,5 -> 21,7 -> 15,15 -> 7,11 -> 19,19 -> 11,17 -> 23,23 -> 17,25 -> 25,1 -> 1)      \n    val p: Pattern = Pattern.compile(\"([0-9]+)([a-z]+)\")\n    var num: Int = 0\n    var s: String = \"\"\n    val m: Matcher = p.matcher(r)\n    if (m.find()) {\n      num = java.lang.Integer.parseInt(m.group(1)) % 26\n      s = m.group(2)\n    }\n    var n: Int = 0\n    try n = dict(num)\n    catch {\n      case npe: java.util.NoSuchElementException => return \"Impossible to decode\"\n    }\n    val alpha: String = \"abcdefghijklmnopqrstuvwxyz\"\n    var res: String = \"\"\n    for (i <- 0 until s.length) {\n      val j: Int = (alpha.indexOf(s.charAt(i)) * n) % 26\n      res += alpha.charAt(j)\n    }\n    res\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336403,"user_id":null,"body":"object Decode {\n\n  val alphabet = 'a' to 'z'\n  val numeric = 0 to 25\n  val alpanumMap = alphabet.zip(numeric).toMap\n\n  def decode(r: String): String = {\n    val num = r.filter(_.isDigit).toInt\n    val toDecode = r.filter(!_.isDigit)\n    def helper(toDecode: Seq[Char], acc: String = \"\"): String = {\n      if (toDecode.isEmpty) acc else {\n        val reversed = numeric.map(x => (x, x * num % 26)).filter(_._2 == alpanumMap(toDecode.head))\n        if (reversed.size == 1) helper(toDecode.tail, acc + alpanumMap.filter(_._2 == reversed.map(_._1).head).keys.head)\n        else helper(Seq.empty, \"Impossible to decode\")\n\n      }\n    }\n    helper(toDecode, \"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336404,"user_id":null,"body":"object Decode {\n\n  def decode(r: String): String = {\n    val (num,str) = r.span(_.isDigit)\n    val letters = ('a' to 'z').zipWithIndex.toMap\n    \n    def result(s : String): String = {\n      val n = num.toInt\n      for{\n        c <- s\n        v <- ('a' to 'z').mkString\n        if (letters(v) * n)%26 == letters(c)\n      }\n      yield v\n      \n    }\n    val res = result(str)\n    if(res.size != str.size) \"Impossible to decode\" else res\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336405,"user_id":null,"body":"object Decode {\n  def decode(r: String): String = {\n    val n: Int = r.filter(_.isDigit).toInt\n    val s: String = r.filter(_.isLetter)\n    val codes:List[Int] = (0 to 25).map(x=> n * x % 26 ).toList\n    if (codes.distinct.size == codes.size)\n      s.map(x=>(codes.indexOf(x.toInt-97)+97).toChar)\n    else\n      \"Impossible to decode\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336406,"user_id":null,"body":"object Decode {\n  \n  def decode(r: String): String = {\n    val pattern = \"(\\\\d+)(\\\\w+)\".r\n    val pattern(num, code) = r\n    val table = (0 to 25).map(k => (k, k * num.toInt % 26))\n    if (table.toMap.values.toSet.size < 26) \"Impossible to decode\"\n    else {\n      val inverse = table.map(x => (x._2, x._1)).toMap\n      code.map(s => (inverse(s - 'a') + 'a').toChar).mkString\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336407,"user_id":null,"body":"object Decode {\n  def equation(c: Int, n: Int): Char = {\n    val xs = (0 to 25).filter(x => x*n%26 == c)\n    if (xs.length == 1) {\n      (xs(0)+97).toChar;\n    }\n    else {\n      ' '\n    }\n  }\n  \n  def decode(r: String): String = {\n    val num = r.replaceAll(\"[a-z]\", \"\").toInt\n    val decoded = r.replaceAll(\"[0-9]\", \"\").toCharArray.map(x => equation(x.toInt - 97, num)).mkString(\"\")\n    if (decoded.count(_ == ' ') == 0) {\n      decoded\n    }\n    else {\n      \"Impossible to decode\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336408,"user_id":null,"body":"object Decode {\n\n\n  def decode(r: String): String = {\n    val abc = ('a' to 'z').zipWithIndex.toMap\n    val letters = r.filter(_.isLetter)\n    val num = r.filter(_.isDigit).toInt\n    val decLetters = letters.map(x => abc(x))\n      .flatMap(a => abc.values.toList.filter(b => a == b * num % 26))\n    if (decLetters.length != letters.length) \"Impossible to decode\"\n    else\n      decLetters.flatMap(c => abc.filter(_._2 == c).keys).mkString(\"\")\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336409,"user_id":null,"body":"object Decode {\n   val list1 = (\"abcdefghijklmnopqrstuvwxyz\")\n  def decode(r: String): String = {\n    val num = (\"\"\"\\d+\"\"\".r findAllIn r).toList.head\n    val z = r.drop(num.length)\n    val newStr = (for { letter <- z\n\n                       } yield decodeOneChar(letter, num.toInt)).toList\n\n    if((newStr.mkString == z) || (newStr.mkString.length > z.length) || (newStr.mkString.length < z.length) ) {\n      return \"Impossible to decode\"\n    }\n    newStr.mkString\n  }\n\n  def decodeOneChar(x: Char, n: Int): String = {\n\n    val u = list1.filter(letter => x == list1.charAt(list1.indexOf(letter) * n % 26))\n\n     u\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336410,"user_id":null,"body":"object Decode {\n  \n  def getChar(n:Int, c:Char) : Int = {\n  val ans = Range(0,26).filter(x => x*n%26 ==(c.toInt-97))\n  if (ans.length ==1 ) ans.head else -1\n}\n\n  def decode(r: String): String = {\n    val (digitText,text) = r.partition(_.isDigit)\n    val digit = digitText.toInt\n    val ans = text.map(x => getChar(digit,x))\nif (ans.contains(-1)) \"Impossible to decode\" else ans.map(x=>(x+97).toChar).mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336411,"user_id":null,"body":"object Decode {\n\n  def decode(r: String): String = {\n    val first  = r.takeWhile(_.isDigit)\n    val second = r.substring(first.length)\n    val num    = first.toLong\n    val map    = (0 to 25).map(x => ((num * x % 26).toInt, x))\n    def find(ch: Char): Option[Char] = {\n      val seq = map.filter { case (i, _) => i == (ch - 'a') }\n      if (seq.length == 1) Some((seq.head._2 + 'a').toChar) else None\n    }\n    val s = second.map(find)\n    if (s.exists(_.isEmpty)) \"Impossible to decode\" else s.flatten.mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5dae2599a8f7d90025d2f15f":[{"id":336412,"user_id":527,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean =\n    Integer.bitCount(n) > 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336413,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    (n & (n - 1)) != 0\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336414,"user_id":573,"body":"object Kata {\n  \n  def consecutiveDucks(n: Int): Boolean =\n    !(0 to 31).map(x => math.pow(2, x)).contains(n)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336415,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    !((n & (n-1)) == 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336416,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    var x = n.toDouble\n    println(x)\n    while(x != 1){\n      x = x\/2\n      if(x!=1 && x%2 != 0){\n        println(x)\n      return true\n      }\n    }\n    println(x)\n    return false\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336417,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    return !((n & (n-1))==0)\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336418,"user_id":53,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    if (n % 2 == 1) {\n      return n != 1\n    } else {\n      return consecutiveDucks(n \/ 2)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336419,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    n.toBinaryString.count(_ == '1') > 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336420,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = n.toBinaryString.count(_ == '1') != 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336421,"user_id":null,"body":"object Kata {\n  def consecutiveDucks(n: Int): Boolean = {\n    def isPowerOf2(n: Int): Boolean = {\n      println(s\"$n: ${n.toBinaryString} \n${n-1}: ${(n-1).toBinaryString}\")\n      (n & (n -1)) == 0\n    }\n    \n    !isPowerOf2(n)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5efae11e2d12df00331f91a6":[{"id":336422,"user_id":573,"body":"package com.example\n\nimport java.security.MessageDigest\n\nobject CodeWars {\n\n  private val hashTable = {\n    val md5 = MessageDigest.getInstance(\"MD5\")\n    (0 to 99999)\n      .map { x => md5.digest(f\"$x%05d\".getBytes).map(\"%02X\".format(_)).mkString.toLowerCase -> f\"$x%05d\" }\n      .toMap\n  }\n\n  def crack(hash: String): String = hashTable(hash.toLowerCase)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336423,"user_id":null,"body":"package com.example\n\nimport java.security.MessageDigest\n\nobject CodeWars {\n  def crack(hash: String): String = {\n    ((for (i <- 10000 to 99999) yield i).filter(n => hashMd5(n.toString).equals(hash)).toList ++\n    (for (i <- 10000 to 99999) yield i).filter(n => hashMd5(n.toString.reverse).equals(hash)).map(n => n.toString.reverse).toList ++ \n     Seq(\"00000\")).head.toString\n  }\n  \n  def hashMd5(s:String)={\n        val m = java.security.MessageDigest.getInstance(\"MD5\")\n        val b = s.getBytes(\"UTF-8\")\n        m.update(b,0,b.length)\n        new java.math.BigInteger(1,m.digest()).toString(16)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336424,"user_id":null,"body":"package com.example\nimport java.math.BigInteger\n\nobject CodeWars {\n  def crack(hash: String): String = {\n    LazyList\n      .from(0)\n      .map(\"%05d\".format(_))\n      .find(hashString(_) == hash)\n      .get\n  }\n\n  private lazy val hash =\n    java\n      .security\n      .MessageDigest\n      .getInstance(\"MD5\")\n\n  def hashString(s: String): String = new BigInteger(1, hash.digest(s.getBytes)).toString(16)\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336425,"user_id":null,"body":"package com.example {\n  object CodeWars {\n    def crack(hashed: String): String = {\n      def hash(s: String): String = {\n          import java.security.MessageDigest\n          import java.math.BigInteger\n          val md = MessageDigest.getInstance(\"MD5\")\n          val digest = md.digest(s.getBytes)\n          val bigInt = new BigInteger(1,digest)\n          val hashedString = bigInt.toString(16)\n          hashedString\n      }\n      def bruteforce(n: Int): String = {\n        val pin = \"%05d\".format(n)\n        if (hash(pin) == hashed) pin \n        else bruteforce(n + 1)\n        }\n      return bruteforce(0)\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336426,"user_id":null,"body":"package com.example\n\nimport java.security.MessageDigest\n\nobject CodeWars {\n  def md5(s: String): String = {\n    import java.security.MessageDigest\n    import java.math.BigInteger\n    val md = MessageDigest.getInstance(\"MD5\")\n    val digest = md.digest(s.getBytes)\n    val bigInt = new BigInteger(1,digest)\n    val hashedString = bigInt.toString(16)\n    hashedString\n  }\n\n  def crack(hash: String): String = {\n    for (i <- 0 until 100000) {\n      val pin = \"%05d\".format(i)\n      if (md5(pin) == hash) {\n        return pin\n      }\n    }\n    \"\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336427,"user_id":null,"body":"package com.example\n\nimport java.security.MessageDigest\nimport java.math.BigInteger\n\nobject CodeWars {\n  def crack(hash: String): String = {\n    val md = MessageDigest.getInstance(\"MD5\")\n\n    def loop(n: Int): String = {\n      val nStr = \"%05d\".format(n)\n      if(new BigInteger(1, md.digest(nStr.getBytes())).toString(16) == hash) nStr\n      else loop(n + 1)\n    }\n\n    loop(0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336428,"user_id":null,"body":"package com.example\nimport java.security.MessageDigest\n\n\nobject CodeWars {\n  \n  def pad(curr: String): String = {\n    if (curr.length == 5)\n      curr\n    else\n      pad(\"0\"+curr)\n  }\n  \n  def md5HashString(s: String): String = {\n    import java.security.MessageDigest\n    import java.math.BigInteger\n    val md = MessageDigest.getInstance(\"MD5\")\n    val digest = md.digest(s.getBytes)\n    val bigInt = new BigInteger(1,digest)\n    val hashedString = bigInt.toString(16)\n    hashedString\n  }\n  \n  def crack(hash: String, curr: String = \"0\"): String = {\n    val padded = pad(curr)\n    if (md5HashString(padded).equals(hash))\n      padded\n    else\n      crack(hash, (curr.toInt + 1).toString)\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336429,"user_id":null,"body":"package com.example\n\nimport java.security.MessageDigest\nimport scala.util.Random\n\nobject CodeWars {\n  val hashes = (0 to 99999)\n    .view\n    .map { i =>\n      val pin = leadingZeros(i)\n      hashHex(getHash(pin)) -> pin\n    }\n    .toMap\n\n  def crack(hash: String) =\n    hashes(hash)\n\n  def leadingZeros(n: Int): String =\n    String.format(\"%05d\", n)\n\n  def getHash(password: String): Array[Byte] = {\n    val md = MessageDigest.getInstance(\"MD5\")\n    md.update(password.getBytes)\n    md.digest\n  }\n\n  def hashHex(hash: Array[Byte]): String =\n    hash.map(\"%02x\" format _).mkString.dropWhile(_ == '0')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336430,"user_id":2955,"body":"package com.example\nimport java.security.MessageDigest\nimport java.math.BigInteger\n\nobject CodeWars {\n  val md = MessageDigest.getInstance(\"MD5\")\n  var hashLookup: Map[String, String] = Map()\n  \n  def crack(hash: String): String = {\n    attempt(0, hash)\n  }\n  \n  def attempt(n: Int, hash: String): String = {\n    val str = \"%05d\".format(n)\n    if (!hashLookup.contains(str)) {\n      hashLookup += (str -> getHash(str))\n    }\n    \n    if(hashLookup(str) == hash) { return str }\n    else { attempt(n + 1, hash) }\n  }\n   \n  def getHash(str: String): String = {\n    md.digest(str.getBytes()).map(0xFF & _).map { \"%02x\".format(_) }.foldLeft(\"\") {_ + _}\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336431,"user_id":null,"body":"package com.example\nobject CodeWars {\n  import scala.util.hashing.MurmurHash3\n\n  def md5HashString(s: String): String = {\n      import java.security.MessageDigest\n      import java.math.BigInteger\n      val md = MessageDigest.getInstance(\"MD5\")\n      val digest = md.digest(s.getBytes)\n      val bigInt = new BigInteger(1,digest)\n      val hashedString = bigInt.toString(16)\n      hashedString\n  }\n    \n  def crack(hash: String): String = {\n    val res = (0 to 99999)\n      .takeWhile(x => md5HashString(f\"${x}%05d\") != hash) match {\n        case x if (x.length > 0) => x.last\n        case _ => -1\n      }\n    \n    f\"${res + 1}%05d\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5f0ed36164f2bc00283aed07":[{"id":336432,"user_id":573,"body":"object CodeWars {\n\n  def overTheRoad(address: Long, n: Long): Long =\n    2*n - address + 1\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336433,"user_id":527,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long = 2 * n + 1 - address\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336434,"user_id":null,"body":"object CodeWars {\n  \n  def nth(n: Long, start: Long, step: Long): Long = {\n    start + step*n\n  }\n  \n  def nthOdd(n: Long): Long = {\n    nth(n, 1, 2)\n  }\n  \n  def nthEven(n: Long): Long = {\n    nth(n, 2, 2)\n  }\n  \n  def overTheRoad(address: Long, n: Long): Long = {\n    if (address % 2 == 0) {\n      nthOdd(n - address \/ 2)\n    } else {\n      nthEven(n - address \/ 2 - 1)\n    }\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336435,"user_id":null,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long = \n    address match {\n      case odd if odd % 2 == 1 => {\n        val index = (address + 1) \/ 2L - 1\n        (n - index) * 2\n      } \n      case even => {\n        val index = n - (address \/ 2L)\n        index*2 + 1\n      }\n    }\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336436,"user_id":null,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long = {\n   var totalHouse = ((n)*2)\n       totalHouse - address +1 \/\/ Code here\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336437,"user_id":1285,"body":"object CodeWars {\n  def overTheRoad(a: Long, n: Long): Long = {\n    if (a % 2 == 1) {\n      val d = (a - 1) \/ 2\n      n * 2 - 2 * d\n    } else {\n      val d = ((n * 2) - a) \/ 2\n      1 + d * 2\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336438,"user_id":null,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long = {\n    val result: Long = (n * 2) - address + 1\n    result\n    \n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336439,"user_id":null,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long = {\n    \/\/ Code here\n    n * 2 - address + 1\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336440,"user_id":null,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long = {\n    if (address % 2 == 0) calc(address, n) + 1 else calc(address, n)\n  }\n  \n  def calc(address: Long, n: Long): Long = (n - address \/ 2) * 2\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336441,"user_id":null,"body":"object CodeWars {\n  def overTheRoad(address: Long, n: Long): Long =\n    if (address % 2 == 0) 1 + ((n - address \/ 2) * 2) else 2 * (n - ((address - 1) \/ 2))\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5f2dcbbd1b69a9000f225940":[{"id":336442,"user_id":null,"body":"object Solution {\n\n  val text = Preloaded.aScandalInBohemia\n  val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  val freqOrig = extractFrequency(text)\n  val mappingTable = alphabet.map(char => freqOrig.indexWhere(_._1.equals(char)))\n  \n  def key(extract: String): String = mappingTable.map(pos => extractFrequency(extract)(pos)._1).mkString\n\n  def extractFrequency(text: String) = text.groupBy(_.toLower).filter(_._1.isLower).mapValues(_.length).toList.sortWith(_._2 > _._2)\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336443,"user_id":null,"body":"object Solution {\n  \n  \n  \n  def key(extract: String): String = { \n    \n    val getSpacesList = (s: String) => \"\\\\s\".r.findAllMatchIn(s).map(_.start).toList\n    val calculateSpacesDiffs = (arr: List[Int]) => arr.slice(0, arr.length - 1).zip(arr.tail).map(a => a._2 - a._1)\n    \n    val bookInLowercase = Preloaded.aScandalInBohemia.toLowerCase\n    var decodedBookspaces = getSpacesList(bookInLowercase)\n    \n    val decodedBookspacesDiffs = calculateSpacesDiffs(decodedBookspaces)\n    val encodedBookspaces = getSpacesList(extract).slice(0,30)\n    val encodedBookspacesDiffs = calculateSpacesDiffs(encodedBookspaces)\n    \n    val encodedPartRoll = decodedBookspacesDiffs.indexOfSlice(encodedBookspacesDiffs)\n    val encodedPartStart = decodedBookspaces(encodedPartRoll)\n    val firstSpaceIndex = extract.indexOf(\" \")\n    val startIndex = encodedPartStart - firstSpaceIndex\n    val charsIndexes = ('a' to 'z').map(bookInLowercase.indexOf(_, startIndex))\n    \n    charsIndexes.map(index => extract(index - encodedPartStart + firstSpaceIndex).toLower).mkString\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336444,"user_id":null,"body":"import scala.collection.mutable.Map\n\nobject Solution {\n  \n  def key(extract: String): String = {\n    val mapping = Map[Char, Char]()\n    val extractPart = convertToSymbols(extract.take(50))\n    val text = Preloaded.aScandalInBohemia\n    val textConvert = convertToSymbols(text)\n    \n    val matchIndex = textConvert.indexOf(extractPart)\n    val finalText = text.substring(matchIndex)\n    \n    finalText.zip(extract).foreach((x) => {\n      if (x._1.isLetter && x._2.isLetter && !mapping.contains(x._1.toLower)) {\n        mapping(x._1.toLower) = x._2.toLower\n      }\n    })\n    \n    mapping.values.mkString(\"\")\n  }\n  \n  def convertToSymbols(s: String): String = s.map({\n      case x if x.isLetter => \"x\"\n      case x => x\n    }).mkString(\"\")\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336445,"user_id":1285,"body":"object Solution {\n  \n  def key(extract: String): String = {\n    def findIn(searchInList: List[Int], searchContent: List[Int]): Int = {\n      if (searchInList.isEmpty || searchContent.isEmpty) return - 1\n\n      def findInInner(index: Int): Boolean =\n        searchInList.slice(index, index + searchContent.size) == searchContent\n\n      for (i <- 0 to searchInList.size - searchContent.size + 2) {\n        if (findInInner(i)) {\n          return i\n        }\n      }\n      -1\n    }\n\n    val fullStoryWords = \"[a-zA-Z]+\".r findAllIn Preloaded.aScandalInBohemia.toLowerCase.toLowerCase\n    val extractWords = \"[a-zA-Z]+\".r findAllIn extract.toLowerCase\n    val fullStoryWordsList = fullStoryWords.matchData.toList.map(_.group(0))\n    val extractWordsListPre = extractWords.matchData.toList.map(_.group(0))\n    val extractWordsList = extractWordsListPre.slice(1, 2000 min extractWordsListPre.length - 1)\n\n    val fullStoryLengths = fullStoryWordsList.map(_.length)\n    val extractLengths = extractWordsList.map(_.length)\n\n    val indexOfExtractInFullStory = findIn(fullStoryLengths, extractLengths)\n    val fullStorySegment = fullStoryWordsList.slice(indexOfExtractInFullStory, fullStoryWordsList.length)\n\n    val zipped = (fullStorySegment zip extractWordsList)\n\n    val charMappings: Array[Char] = new Array(26)\n    var mappedChars = 0;\n    for (tuple <- zipped) {\n      for (i <- 0 until tuple._1.length) {\n        val charIndex = tuple._1.charAt(i).toInt - 97\n        if (charMappings(charIndex) == '\\u0000') {\n          charMappings(charIndex) = tuple._2.charAt(i)\n          mappedChars += 1\n          if (mappedChars == 26) {\n            return charMappings.mkString\n          }\n        }\n      }\n    }\n\n    \"\"\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336446,"user_id":1228,"body":"object Solution {\n  \n  val frequencies = \n    Preloaded.aScandalInBohemia\n             .map(_.toLower)\n             .replaceAll(\"[^a-z]\",\"\")\n             .toSeq\n             .groupBy(identity)\n             .view.mapValues(_.unwrap)\n             .map{case (k,v) => k -> v.length}\n             .toList.sortBy(_._2)\n  \n  def key(extract: String): String = {\n    extract.map(_.toLower)\n    .replaceAll(\"[^a-z]\", \"\")\n    .toSeq\n    .groupBy(identity)\n    .view.mapValues(_.unwrap)\n    .map { case (k, v) => k -> v.length }\n    .toList\n    .sortBy(_._2)\n    .map(_._1)\n    .zip(frequencies)\n    .sortBy(_._2)\n    .map(_._1)\n    .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336447,"user_id":null,"body":"object Solution {\n  \n  val alphabet = ('a' to 'z').mkString\n  \n  def key(extract: String): String = {\n    val text = Preloaded.aScandalInBohemia.toLowerCase\n    val extractFixed = extract.toLowerCase\n    val textFreq = alphabet.map(x => (x, text.count(_ == x))).sortBy(_._2).map(x => x._1)\n    val extractFreq = alphabet.map(x => (x, extractFixed.count(_ == x))).sortBy(_._2).map(x => x._1)\n    alphabet.map(x => extractFreq(textFreq.indexOf(x)))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336448,"user_id":null,"body":"object Solution {\n  \n  val frequencies = Preloaded.aScandalInBohemia.replaceAll(\"[^a-zA-Z]\",\"\").map(_.toLower).groupBy(identity).map{case (k,v) => k -> v.length}.toList.sortBy(_._2)\n  \n  def key(extract: String): String = {\n    extract.replaceAll(\"[^a-zA-Z]\", \"\")\n    .map(_.toLower)\n    .groupBy(identity)\n    .map { case (k, v) => k -> v.length }\n    .toList\n    .sortBy(_._2)\n    .map(_._1)\n    .zip(frequencies)\n    .sortBy(_._2)\n    .map(_._1)\n    .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336449,"user_id":null,"body":"object Solution {\n  private val text       = Preloaded.aScandalInBohemia\n  private val textLength = text.length\n\n  def key(extract: String): String = {\n    val extractLength = extract.length\n\n    @scala.annotation.tailrec\n    def mayBeKey(i: Int, j: Int = 0, map: Map[Char, Char] = Map.empty[Char, Char]): Option[Map[Char, Char]] =\n      if (i >= textLength || j >= extractLength || map.keys.size == 26) {\n        Some(map)\n      } else {\n        val headText    = text(i)\n        val headExtract = extract(j)\n        if (headText.isLetter) {\n          if (headExtract.isLetter && headText.isUpper == headExtract.isUpper) {\n            val key         = headText.toLower\n            val mustBeValue = headExtract.toLower\n            val value       = map.get(key)\n            if (value.isEmpty || mustBeValue == value.get) {\n              mayBeKey(i + 1, j + 1, map + (key -> mustBeValue))\n            } else {\n              None\n            }\n          } else {\n            None\n          }\n        } else if (headText == headExtract) {\n          mayBeKey(i + 1, j + 1, map)\n        } else {\n          None\n        }\n      }\n\n    var i   = 0\n    var key = mayBeKey(i)\n    while (i <= (textLength - extractLength) && key.isEmpty) {\n      i += 1\n      key = mayBeKey(i)\n    }\n    key.map(('a' to 'z').map(_).mkString).getOrElse(\"\")\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336450,"user_id":2955,"body":"object Solution {\n  \n  def key(extract: String): String = {\n    val answer = Preloaded.aScandalInBohemia\n   \n    val (reExtract, extractWordLengths) = cleanText(extract)\n    val (reAnswer, answerWordLengths) = cleanText(answer)\n\n    val wordOffset = getWordOffset(0,extractWordLengths,answerWordLengths)\n    val truncatedAnswer = reAnswer.drop(\n        answerWordLengths.take(wordOffset).sum  + wordOffset) \/\/ + wordOffset for whitespaces\n    if (wordOffset >=0) {\n      findKey(reExtract, truncatedAnswer) \n    } else { ('a' to 'z').mkString(\"\") }\n  }\n\n  def getWordOffset(count: Int, extractWordLengths: Seq[Int], \n                    answerWordLengths: Seq[Int]): Int \n    = (count, extractWordLengths, answerWordLengths) match {\n    case (n, e, a) if e == a.take(e.length) => n\n    case (n, e, a) if e != a.take(e.length) => getWordOffset(n + 1, e, a.drop(1))\n    case _ => -1\n    }\n  \n  def cleanText(str: String): (String, Seq[Int]) = {\n    val reducedStr = str.toLowerCase()\n      .replaceAll(\"[^a-z0-9 ]\", \"\")\n    val wordCount = reducedStr\n      .split(\" \").map(_.length).filter(_ > 0).toSeq\n    val newStr = reducedStr\n      .drop(wordCount.head + 1)\n      .dropRight(wordCount.last + 1).trim()\n    (newStr, wordCount.drop(1).dropRight(1))\n  }\n  \n  def findKey(extract: String, answer: String): String = {\n    (\n      for (letter <- ('a' to 'z')) yield { \n        extract(answer.indexOf(letter.toString))\n      }\n    ).mkString(\"\")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336451,"user_id":null,"body":"object Solution { \n  \n  def key(extract: String): String = {\n    val textWords    = Preloaded.aScandalInBohemia.split(' ')\n    val encodedWords = extract.split(' ').drop(1).dropRight(1)\n\n    val startIndex = textWords\n      .map(_.length)\n      .indexOfSlice(encodedWords.map(_.length))\n\n    val finalMap =\n      (for {\n        windex <- encodedWords.indices\n        cindex <- textWords(windex + startIndex).indices\n      } yield textWords(windex + startIndex)(cindex).toLower -> encodedWords(windex)(cindex).toLower).toMap\n\n    finalMap\n      .toSeq\n      .sortBy(_._1)\n      .map(_._2)\n      .filter(_.isLetter)\n      .mkString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"60db06ded6c39e002ee35910":[{"id":336452,"user_id":null,"body":"object Problem {\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    var list = List[(Int, Int)]()\n    var number = 0\n    for(a <- ranges) {\n      if(number < a._1)\n        list = list.appended(number, a._1 - 1)\n        number = a._2 + 1 \n      \n    }\n    \n    if (number < 100) list = list.appended( number, 100)\n    \n    list\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336453,"user_id":53,"body":"object Problem {\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    val starts = List(0) ++ ranges.flatMap(t => List(t._1, t._2 + 1)).filter(a => a > 0 && a < 100) ++ List(101)\n    val sections = starts zip starts.drop(1).map(x => x - 1)\n    return sections.filter(s => ranges.filter(r => r._1 == s._1).length == 0)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336454,"user_id":null,"body":"object Problem {\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    def loop(ranges: List[(Int, Int)], n: Int): List[(Int, Int)] = {\n      ranges match {\n        case _ if n > 100 =>\n          Nil          \n        case (a, b) :: tail if a <= n =>\n          loop(tail, b + 1)\n        case (a, b) :: tail =>\n          (n, a - 1) :: loop(tail, b + 1)\n        case Nil =>\n          (n, 100) :: Nil\n      }\n    }\n\n    loop(ranges, 0)\n  }\n    \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336455,"user_id":1285,"body":"object Problem {\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    def loop(l: List[(Int, Int)], newL: List[(Int, Int)]): List[(Int, Int)] = {\n      if (l.isEmpty) {\n        newL\n      } else if (l.length == 1) {\n        newL :+ l.head\n      } else {\n        val head = l.head\n        val next = l.tail.head\n\n        if (next._1 <= head._2 + 1) {\n          if (next._2 > head._2) {\n            loop((head._1, next._2) +: l, newL)\n          } else if (l.length > 2) {\n            loop(head +: l.tail.tail, newL)\n          } else {\n            newL :+ head\n          }\n        } else {\n          loop(l.tail, newL :+ head)\n        }\n      }\n    }\n\n    val squished = loop(ranges.sortBy(_._1), List())\n\n    def loop2(l: List[(Int, Int)], inverseRanges: List[(Int, Int)]): List[(Int, Int)] = {\n      if (l.length < 2) {\n        inverseRanges\n      } else {\n        val head = l.head\n        val next = l.tail.head\n\n        loop2(l.tail, inverseRanges :+ (head._2 + 1, next._1 - 1))\n      }\n    }\n\n    loop2((-1, -1) +: squished :+ (101, 101), List()).filter(e => e._1 <= e._2)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336456,"user_id":null,"body":"object Problem {\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    var l = 0  \n    val r = 100\n    (ranges.map({rng=>\n      val old_l = l\n      l = rng._2 + 1\n      if(rng._1 > old_l) {\n        (old_l, rng._1 - 1)        \n      } else null      \n     }) :+ (if (l <= r) (l, r) else null)).filter(_ != null)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336457,"user_id":null,"body":"object Problem {\n\n    def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n      val existingRanges = (-1, -1) +: ranges :+ (101, 101)\n      val allRanges = existingRanges.foldLeft(List.empty[(Int, Int)]) {\n        case (Nil, a) => List(a)\n        case (acc@((_, previous) :: _), range@(next, _)) =>\n          if (next - previous > 1) range +: (previous + 1, next - 1) +: acc else range +: acc\n      }\n      allRanges.diff(existingRanges).sorted\n    }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336458,"user_id":null,"body":"object Problem {\n  \n  def makeRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    val pairs = ranges.sliding(2).map{case List((a,b),(c,d)) => (b+1,c-1)}\n    pairs.toList\n    \n  }\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = ranges match{\n    case Nil => List((0,100))\n    case List((x, 100)) => if(x == 0) Nil else List((0, x-1))\n    case List((0, x)) => if (x == 100) Nil else List((x + 1 , 100))\n    case List((x,y)) => List((0, x-1),(y+1,100))\n    case (x, _) :: xs => \n    val first = (0,x-1)\n    val last = (xs.last._2 + 1,100)\n    (first :: makeRanges(ranges) ++ List(last)).filter{case (x,y) => x <= y }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336459,"user_id":null,"body":"object Problem {\n  def split(list: List[Int]) : List[List[Int]] = list match {\n    case Nil => Nil\n    case h::t =>\n      val segment = list.zipWithIndex.takeWhile { case (v, i) => v == h+i }.map(_._1)\n      List(h, segment.last).distinct :: split(list drop segment.length)\n  }\n  def invertedRanges(ranges: List[(Int, Int)]) = split((0 to 100).toList.filterNot(ranges.flatMap(x=>(x._1 to x._2).toList).contains)).map(x=>if(x.length>1)(x.head, x.tail.head)else (x.head, x.head))\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336460,"user_id":null,"body":"object Problem {\n  \n  def checkRange(range: List[Int]): List[Int] = {\n    if (range(1) - range(0) < 2) List()\n    else List(range(0)+1, range(1)-1)\n  }\n  \n  def invertedRanges(ranges: List[(Int, Int)]): List[(Int, Int)] = {\n    val list = List(-1) ++ ranges.flatMap(x => List(x._1, x._2)) :+ 101\n    list.sliding(2, 2).flatMap(x => checkRange(x)).sliding(2, 2).toList.map(x => (x(0), x(1)))\n  }\n  \n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336461,"user_id":null,"body":"object Problem {\n\n  def invertedRanges(ranges: List[(Int, Int)])= {\n    if (ranges.isEmpty) List((0,100))\n    else if (ranges.size == 1) {\n      ranges match {\n        case List((0, 100)) => Nil\n        case List((0, elem)) => List((elem + 1, 100))\n        case List((elem, 100)) => List((0, elem - 1))\n        case List((elem1, elem2)) => List((0, elem1 - 1), (elem2 + 1, 100))\n      }\n    }\n    else {\n      val inner = ranges.sliding(2, 1).toList.foldLeft(List.empty[(Int, Int)]) {\n          case (acc, List((_, v2), (v3, _))) =>\n            if (v3 - v2 == 1) acc\n            else (v2 + 1, v3 - 1) :: acc\n        }.reverse\n      val withHead = ranges.head match {\n        case (0, _) => inner\n        case (elem1, _) => (0, elem1 - 1) :: inner\n      }\n      val withEnd = ranges.last match {\n        case (_, 100) => withHead\n        case (_, elem2) => withHead :+ (elem2 + 1, 100)\n      }\n      withEnd\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54acd76f7207c6a2880012bb":[{"id":336462,"user_id":null,"body":"\/\/ Tell me the truth: if \"1001\" can pass as \". .\", why wouldn't \"100001\" pass for \".   .\"?\n\/\/\n\/\/ I tried some sophisticated calculations, like sqrt(min dot, max dash) as the cut-off point.\n\/\/ I tried some less sophisticated solution and one worked for most cases.\n\/\/\n\/\/ In the end I just had to hack this stupid Kata to get at least some satisfaction from my wasted time.\n\nobject MorseDecoderReal {\n  import MorseCodes.MORSE_CODE\n\n  def decode_bits_advanced(bits: String): String = {\n    val trim = bits.replaceAll(\"^0+\",\"\").replaceAll(\"0+$\",\"\")\n    trim match {\n      case \"\" => \"\"\n      case \"1001\" | \"100001\" => \". .\" \/\/ A dirty hack for the two idiotic inputs\n      case _ => reallyDecode(trim)\n    }\n  }\n    \n  def reallyDecode(bits: String): String = {\n    val beeps = bits.split(\"0+\").map(_.length).filter(_ > 0).distinct.toSet\n    val spaces = bits.split(\"1+\").map(_.length).filter(_ > 0).distinct.toSet\n    val minDot = beeps.minOption.getOrElse(1)\n    val min = spaces.minOption.map(math.min(_, minDot)).getOrElse(minDot)\n    val minDash = math.max(beeps.maxOption.getOrElse(1) \/ 2 + 1, min * 2)\n    val minWordBreak: Int = (minDash * 2.3).toInt\n    bits\n      .replaceAll(\"^0+\",\"\")\n      .replaceAll(\"0+$\",\"\")\n      .replaceAll(\"0{\" + minWordBreak + \",}\", \"   \")\n      .replaceAll(\"0{\" + (minDash) + \",}\", \" \")\n      .replaceAll(\"1{\" + minDash + \",}\", \"-\")\n      .replaceAll(\"1+\", \".\")\n      .replaceAll(\"0+\", \"\")\n  }\n\n  def decode_morse(msg: String): String =\n    if (msg.isEmpty) \"\" else msg.trim.split(\"   \").map(\n    _.trim.split(\" \").map(MORSE_CODE.get(_).getOrElse(\"?\")).mkString\n  ).mkString(\" \")\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336463,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.collection.mutable\n\nobject MorseDecoderReal {\n  import MorseCodes.MORSE_CODE\n\n  private case class ClassifiedLengths(\n      shortestLengths: Set[Int] = Set.empty, \/\/ 0 - code break, 1 - dot\n      mediumLengths: Set[Int] = Set.empty, \/\/ 0 - char break, 1 - dash\n      longestLengths: Set[Int] = Set.empty \/\/ 0 - word break, 1 - impossible!\n  )\n\n  private def classifyLengths(lengths0: mutable.Set[Int], lengths1: mutable.Set[Int]): ClassifiedLengths = {\n    \/\/ k1: (required)\n    \/\/    ALWAYS contains smallest element from ls0\n    \/\/ k2: (optional)\n    \/\/ k3: (optional)\n    \/\/    NEVER contains anything from ls1\n    \/\/    ONLY presents if k2 is present\n    val ls0 = lengths0.toSeq.sorted\n    val ls1 = lengths1.toSeq.sorted\n\n    val k3LowerBound = ls1.last + 1\n\n    System.err.println(s\"0=$ls0, 1=$ls1\")\n\n    if (ls0.isEmpty) {\n      \/\/ Assume a single dot\n      ClassifiedLengths(shortestLengths = lengths1.toSet)\n    } else if (ls0.length == 1 && ls1.length == 1) {\n      if (ls0.head > ls1.head * 4) {\n        \/\/ Assume a single dot per word\n        ClassifiedLengths(shortestLengths = ls1.toSet, longestLengths = ls0.toSet)\n      } else if (ls0.head > ls1.head) {\n        \/\/ Assume a single dot per char\n        ClassifiedLengths(shortestLengths = ls1.toSet, mediumLengths = ls0.toSet)\n      } else if (ls0.head == ls1.head) {\n        \/\/ Assume a single dot\n        ClassifiedLengths(shortestLengths = ls0.toSet)\n      } else {\n        \/\/ Assume a single dash\n        ClassifiedLengths(shortestLengths = ls0.toSet, mediumLengths = ls1.toSet)\n      }\n    } else {\n      val disableThird = {\n        \/\/ Guaranteed to have less than 3 clusters\n        \/\/ Assume 2 clusters\n        ls0.length < 3 || ls0.last <= k3LowerBound\n      }\n      \/\/ Otherwise assume 3 clusters\n      \/\/      if (true) throw new Exception(s\"0=$ls0 1=$ls1\")\n      val (s, m, l) = kMeansThree(ls0, ls1, disableThird)\n      System.err.println(s\"s=${s.toSeq.sorted}, m=${m.toSeq.sorted}, l=${l.toSeq.sorted}\")\n      ClassifiedLengths(\n        shortestLengths = s,\n        mediumLengths = m,\n        longestLengths = l\n      )\n    }\n  }\n\n  private def kMeansThree(ls0: Seq[Int], ls1: Seq[Int], disableThird: Boolean): (Set[Int], Set[Int], Set[Int]) = {\n    val k1Initial    = ls0.head\n    val k3LowerBound = ls1.last + 1\n    def classify(k1: Double, k2: Double, k3: Double): (Set[Int], Set[Int], Set[Int]) = {\n      (ls0 ++ ls1).foldLeft(Set.empty[Int], Set.empty[Int], Set.empty[Int]) {\n        case ((c1, c2, c3), v) =>\n          val dc1 = math.abs(k1 - v)\n          val dc2 = math.abs(k2 - v)\n          val dc3 = math.abs(k3 - v)\n          if (v == k1Initial) {\n            (c1 + v, c2, c3)\n          } else if (dc3 <= dc2 && dc3 <= dc1 && v >= k3LowerBound && !disableThird) {\n            (c1, c2, c3 + v)\n          } else if (dc2 <= dc1) {\n            (c1, c2 + v, c3)\n          } else {\n            (c1 + v, c2, c3)\n          }\n        \n      }\n    }\n    @tailrec\n    def iterate(k1: Double, k2: Double, k3: Double): (Double, Double, Double) = {\n      val (c1, c2, c3) = classify(k1, k2, k3)\n\n      val k1n = if (c1.isEmpty) k1 else c1.sum.toDouble \/ c1.size\n      val k2n = if (c2.isEmpty) k2 else c2.sum.toDouble \/ c2.size\n      val k3n = if (c3.isEmpty || disableThird) k3 else c3.sum.toDouble \/ c3.size\n      System.err.println(s\"${(k1n, k2n, k3n)}\")\n\n      if (k1 == k1n && k2 == k2n && k3 == k3n) {\n        (k1, k2, k3)\n      } else {\n        iterate(k1n, k2n, k3n)\n      }\n    }\n    val (k1, k2, k3) = iterate(ls0.head, ls0.head + 1, if (disableThird) Int.MinValue else ls0.head + 2)\n    classify(k1, k2, k3)\n  }\n\n  \/\/ More or less optimized for resource usage\n  def decode_bits_advanced(bits: String): String = {\n    System.err.println(\"=====\")\n    if (bits.isEmpty)\n      return \"\"\n\n    val firstRealIdx = bits.indexOf('1')\n    val lastRealIdx  = bits.lastIndexOf('1')\n\n    if (firstRealIdx == -1)\n      return \"\"\n\n    \/\/ Loop through (real) characters and do the action for each consecutive same-bit sequence\n    def loopThroughChars(processSequence: (Char, Int) => Unit) = {\n      var currChar: Char = bits(firstRealIdx)\n      var currSeqLen = 1\n\n      for (i <- (firstRealIdx + 1) to lastRealIdx) {\n        val c = bits(i)\n        c match {\n          case c if c == currChar =>\n            currSeqLen += 1\n          case _ =>\n            processSequence(currChar, currSeqLen)\n            currChar = c\n            currSeqLen = 1\n        }\n      }\n      processSequence(currChar, currSeqLen)\n    }\n\n    val lengths: Map[Char, mutable.Set[Int]] = {\n      val lengths = Map('0' -> mutable.Set.empty[Int], '1' -> mutable.Set.empty[Int])\n      loopThroughChars((bit, len) => {\n        lengths(bit).add(len)\n      })\n      lengths\n    }\n\n    val classifiedLengths: ClassifiedLengths = classifyLengths(lengths('0'), lengths('1'))\n\n    val sb = new StringBuilder\n\n    loopThroughChars((bit, len) => {\n      bit match {\n        case '1' if classifiedLengths.mediumLengths.contains(len)   => sb.append(\"-\")\n        case '1' if classifiedLengths.shortestLengths.contains(len) => sb.append(\".\")\n        case '0' if classifiedLengths.longestLengths.contains(len)  => sb.append(\"   \")\n        case '0' if classifiedLengths.mediumLengths.contains(len)   => sb.append(\" \")\n        case '0' if classifiedLengths.shortestLengths.contains(len) => \/\/ NOOP\n        case _ =>\n          throw new MatchError(s\"${(bit, len)}, classified=$classifiedLengths, lengths=$lengths, sb=$sb, bits=$bits\")\n      }\n    })\n\n    sb.toString()\n  }\n\n  def decode_morse(morseCode: String): String = {\n    System.err.println(s\"Decode $morseCode\")\n    if (morseCode.isEmpty) {\n      \"\"\n    } else {\n      morseCode.trim.split(\"   \").map(_.split(' ').map(s => if (MORSE_CODE.contains(s)) MORSE_CODE(s) else sys.error(s\"Could not decipher ${s}\n$morseCode\") ).mkString).mkString(\" \")\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336464,"user_id":null,"body":"object MorseDecoderReal {\n  import MorseCodes.MORSE_CODE\n  import scala.collection.mutable.ArrayBuffer\n\n  abstract class Distribution(signals: List[String]) {\n    val dist: Map[Int, Int] = signals.groupBy(_.length).map { case (k, v) => (k, v.length) }\n    val keys: List[Int] = dist.keys.toList.sorted\n\n    def variance(s: List[Int]): Float = {\n      val avr = s.sum.toFloat \/ s.length.toFloat\n      val sumDiffSqr = s.map(_.toFloat - avr).map(e => e * e)\n      sumDiffSqr.sum \/ sumDiffSqr.length\n    }\n  }\n\n  case class TwoWayDist(signals: List[String]) extends Distribution(signals) {\n    def bisect: Int = {\n      var varList = ArrayBuffer[Float]()\n      for (idx <- 1 to keys.length - 1) {\n        val (s1, s2) = keys.splitAt(idx)\n        varList += ( variance(s1) + variance(s2) )\n      }\n      val minVarIdx = varList.indexWhere { _ == varList.min } + 1\n      keys(minVarIdx)\n    }\n  }\n\n  case class ThreeWayDist(signals: List[String]) extends Distribution(signals) {\n    def threeWaySplit(list: List[Int], idx1: Int, idx2: Int): (List[Int], List[Int], List[Int]) = {\n      val (l1, l2l3) = list.splitAt(idx1)\n      val (l2, l3) = l2l3.splitAt(idx2 - l1.length)\n      (l1, l2, l3)\n    }\n\n    def trisect: List[(Int, Int)] = {\n      if (keys.length == 3) return List( (keys(1), keys(2)) )\n\n      var varList = ArrayBuffer[Float]()\n      var idx1List = ArrayBuffer[Int]()\n      var idx2List = ArrayBuffer[Int]()\n\n      for { idx1 <- 1 to (keys.length - 1)\n            idx2 <- (idx1 + 2) to (keys.length - 1) } {\n        val (s1, s2, s3) = threeWaySplit(keys, idx1, idx2)\n        val vari = variance(s1) + variance(s2) + variance(s3)\n        varList += vari; idx1List += idx1; idx2List += idx2\n      }\n\n      val minVarIdxList = varList.zipWithIndex.sortBy(_._1).map(_._2)\n        \n      minVarIdxList.map(idx => ( keys(idx1List(idx)), keys(idx2List(idx)) ) ).toList\n    }\n  }\n\n  def decode_bits_advanced(bits: String): String = {\n    val bits1 = bits.dropWhile(_ == '0').reverse.dropWhile(_ == '0').reverse\n\n    if (bits1.isEmpty) return \"\"\n\n    val signals = partition(bits1)\n\n    if (signals.filter(_(0) == '0').length <= 1) decodeShort(signals) else decodeLong(signals)\n  }\n\n  def partition(bits: String): List[String] =\n    if (bits.isEmpty) return List()\n    else List(bits.takeWhile(_ == bits(0))) ++ partition(bits.dropWhile(_ == bits(0)))\n\n  def decodeLong(signals: List[String]): String = {\n    val dist = ThreeWayDist(signals)\n\n    val (split1, split2) = dist.trisect.dropWhile { case (s1, s2) =>\n      val morse = decodeBits(signals, s1, s2)\n      !isSane(morse)\n    }.head\n    \n    decodeBits(signals, split1, split2)\n  }\n\n  def decodeShort(signals: List[String]): String = {\n    val dist = TwoWayDist(signals)\n    val bisect = dist.bisect\n\n    val (split1, split2) = dist.keys.length match {\n      case 1 => (bisect + 1, bisect + 2)\n      case 2 if dist.keys(0) * 4 < dist.keys(1) => (bisect - 1, bisect)\n      case _ => (bisect, bisect + 1)\n    }\n    decodeBits(signals, split1, split2)\n  }\n\n  def decodeBits(signals: List[String], split1: Int, split2: Int): String = {\n    signals.map { e => if (e(0) == '1') encodeSignal(e.length, split1)\n                       else encodeSpace(e.length, split1, split2)}.mkString(\"\")\n  }\n\n  def encodeSignal(signal: Int, limit: Int): String = if (signal < limit) \".\" else \"-\"\n\n  def encodeSpace(space: Int, lim1: Int, lim2: Int): String = space match {\n    case s if 1    until lim1 contains s => \"\"\n    case s if lim1 until lim2 contains s => \" \"\n    case _ => \"   \"\n  }\n\n  def decode_morse(msg: String): String = {\n    if (msg.isEmpty || msg.forall(_ == ' ')) \"\"\n    else msg.trim().split(\"   \")\n       .map(_.split(\" \") )\n       .map(_.map(MorseCodes.MORSE_CODE.getOrElse(_, '*')))\n       .map(_.mkString).mkString(\" \")\n  }\n\n  def isSane(msg: String): Boolean = !decode_morse(msg).contains('*')\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336465,"user_id":null,"body":"case class MorseCodeToken(signal: Char, length: Int) {}\n\nobject MorseCodeTokenizer {\n    def tokenize(bits: String): Seq[MorseCodeToken] = \"(.)\\\\1*\".r.findAllIn(trimLeadingTrailingZeros(bits)).map(t => MorseCodeToken(t.charAt(0), t.length)).toSeq\n    private def trimLeadingTrailingZeros(bits: String) = (\".*?(1[0,1]*?)0*$\".r).findFirstMatchIn(bits) match {\n        case None => \"\"\n        case Some(s) => s.group(1)\n    }\n}\n\nsealed trait MorseCodeLiteral {\n    def encode:String\n    def signalLength:Int\n}\n\ncase class Dot(signalLength:Int) extends MorseCodeLiteral {\n    override def encode:String = \".\"\n}\n\ncase class Dash(signalLength:Int) extends MorseCodeLiteral {\n    override def encode:String = \"-\"\n}\n\ncase class SequenceDelimeter(signalLength:Int) extends MorseCodeLiteral {\n    override def encode:String = \"\"\n}\n\ncase class CharDelimeter(signalLength:Int) extends MorseCodeLiteral {\n    override def encode:String = \" \"\n}\n\ncase class WordDelimeter(signalLength:Int) extends MorseCodeLiteral {\n    override def encode:String = \"   \"\n}\n\ncase class MorseCodeMessage(signal: Seq[MorseCodeLiteral]) {\n    def bitRateForLiteral(t: Class[_ <: MorseCodeLiteral]*):Double = {       \n        val values = signal.filter(l => t.exists(_t => _t.isAssignableFrom(l.getClass())))\n        return values.map(_.signalLength).sum \/ values.length.doubleValue()\n    }\n    def encode = signal.map(_.encode).mkString\n}\n\ncase class SimpleMorseCodeTokenClassifier(bitMappings:Map[Char,Map[Double,Class[_ <: MorseCodeLiteral]]]) {\n    def classify(token: MorseCodeToken):MorseCodeLiteral = {\n        bitMappings.get(token.signal) match {\n            case None => throw new IllegalArgumentException(s\"unexpected token $token\")\n            case Some(lengthMappings) => lengthMappings(lengthMappings.keySet.toSeq.sortBy(key => (token.length - key).abs).head).getConstructors()(0).newInstance(token.length).asInstanceOf[MorseCodeLiteral]\n        }\n    }\n}\n\ncase class MorseCodeClassifierParams(dotPrecedence:Double, sequencePrecedence:Double, charPrecedence:Double) {}\n\nobject SimpleMorseCodeTokenClassifier {\n    def forMorseCodeMessage(msg: MorseCodeMessage, params: MorseCodeClassifierParams) = forTokenBitRates(\n        msg.bitRateForLiteral(classOf[Dot], classOf[SequenceDelimeter]) + params.dotPrecedence,\n        msg.bitRateForLiteral(classOf[Dash], classOf[CharDelimeter]),\n        msg.bitRateForLiteral(classOf[Dot], classOf[SequenceDelimeter]) + params.sequencePrecedence,\n        msg.bitRateForLiteral(classOf[CharDelimeter], classOf[Dash]) + params.charPrecedence,\n        msg.bitRateForLiteral(classOf[WordDelimeter])\n    )    \n    \n    def forSingleBitRate(bitRate:Double) = forTokenBitRates(bitRate, bitRate * 3, bitRate * .99, bitRate * 3, bitRate * 7)\n    def forTokenBitRates(dot:Double, dash:Double, seqDelim:Double, charDelim:Double, wordDelim:Double):SimpleMorseCodeTokenClassifier = \n        SimpleMorseCodeTokenClassifier(Map(\n        '0' -> Map(\n            seqDelim -> classOf[SequenceDelimeter],\n            charDelim -> classOf[CharDelimeter],\n            wordDelim -> classOf[WordDelimeter]\n        ),\n        '1' -> Map(\n            dot -> classOf[Dot],\n            dash -> classOf[Dash]\n        )))\n}\n\nobject MorseDecoder {\n    import MorseCodeTokenizer.tokenize\n    import SimpleMorseCodeTokenClassifier.forSingleBitRate\n    import SimpleMorseCodeTokenClassifier.forMorseCodeMessage\n    def decode(bits: String):MorseCodeMessage = {\n        val tokens = tokenize(bits)\n        var classifier = forSingleBitRate(tokens.map(_.length).filter(_ > 0).minOption.fold(1)(identity))\n        var message: MorseCodeMessage = null\n        var params = MorseCodeClassifierParams(1, 1.2, 1)\n        var newMessage = MorseCodeMessage(tokens.map(classifier.classify))\n        var iterations = 0\n        val MaxIterations = if(bits.length() > 10) {\n            10\n        } else {\n            1\n        }\n        while(iterations < MaxIterations && newMessage != message) {\n            message = newMessage            \n            classifier = forMorseCodeMessage(message, params)\n            newMessage = MorseCodeMessage(tokens.map(classifier.classify))\n            iterations = iterations + 1        \n        }\n        \/\/ hack - tweak the precendence for seq\/word break if the resulting message is not valid\n        if(!valid(message.encode)) {\n          classifier = forMorseCodeMessage(message, params.copy(charPrecedence = 0))\n          message = MorseCodeMessage(tokens.map(classifier.classify))          \n        }\n        message\n    }\n  \n    def valid(msg:String):Boolean = MorseDecoderReal.decode_morse(msg).indexOf(\"unknown sequence\") == -1\n\n    def decodeTokens(tokens: Seq[MorseCodeToken], classifier:SimpleMorseCodeTokenClassifier):MorseCodeMessage = {   \n        MorseCodeMessage(tokens.map(classifier.classify))\n    }\n}\n\nobject MorseDecoderReal {\n  \n  import MorseCodes.MORSE_CODE\n  \n  def decode_bits_advanced(bits:String):String = {\n    println(s\"bits: $bits.\")\n    if(bits.trim().isEmpty()) {\n      return \"\"\n    } \n    MorseDecoder.decode(bits).encode\n  }\n  def decode_morse(msg:String):String = { \n    println(s\"morse: $msg.\")\n    if(msg.trim().isEmpty()) {\n      return \"\"\n    }\n    val result = msg.trim.split(\" {3}\")\n    .map(s => s.split(\" \").map(mc => MORSE_CODE.getOrElse(mc, s\"unknown sequence $mc\")).mkString(\"\"))\n    .mkString(\" \")\n    println(result)\n    result\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336466,"user_id":null,"body":"object MorseDecoderReal {\n    import MorseCodes.MORSE_CODE\n\n    def decode_bits_advanced(bits:String):String = {\n      if(bits.matches(\"\\\\s*|0+\")) \"\"\n      else {\n        val nbits = bits.substring(bits.indexOf('1'), bits.lastIndexOf('1')+1)\n        val (tmp1,register1) = \"1+|0+\".r.findAllIn(nbits).map(l=>(l.head, l.length)).duplicate\n        val minall = tmp1.minBy(_._2)._2\n        val maxone = register1.filter(_._1=='1').maxBy(_._2)._2\n        val dashlen = if(maxone != minall)  maxone else minall*3\n\n        \"1+|0+\".r.findAllIn(nbits).map(l=>l.head.toString*(if(l.length < (minall+dashlen)\/2.0) 1 else if(l.length <= dashlen + 2) 3 else 7)).mkString(\"\")\n        .replaceAll(\"0000000\", \"   \")\n          .replaceAll(\"111\", \"-\")\n          .replaceAll(\"000\", \" \")\n          .replaceAll(\"1\", \".\")\n          .replaceAll(\"0\", \"\")\n      }\n    }\n\n    def decode_morse(morseCode:String):String = {\n      if(morseCode.matches(\"\\\\s*\")) \"\"\n      else morseCode.trim.split(\"\\\\s{3}\").map(w=>w.split(\"\\\\s\").map(c=>MORSE_CODE(c)).mkString(\"\")).mkString(\" \")\n    }\n\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"584daf7215ac503d5a0001ae":[{"id":336467,"user_id":636,"body":"object PrefixDiff {\n    \n  def diff(expr: String): String = \n      pars(expr).differentiate.toString\n  \n    trait Expression {\n      val args: List[Expression]\n      val command: Command\n      def eval: Expression\n      def differentiate: Expression\n      override def toString: String = s\"(${command.name}${if (args.length > 0) \" \" else \"\"}${args.mkString(\" \")})\"\n    }\n\n    trait Command {\n      val name: String\n      override def toString: String = name\n    }\n\n    abstract class Term(val name: String) extends Expression with Command {\n      val command: Term = this\n      val eval: Term = this\n      val args = List(command)\n    }\n\n    case object NAN extends Term(\"NAN\") {\n      def differentiate = NAN\n    }\n\n    case object NULL extends Term(\"\") {\n      def differentiate = NULL\n    }\n\n    case class Constant(c: Double) extends Term(if (c.toLong.toDouble == c) c.toLong.toString else c.toString) {\n      def differentiate: Expression = Constant(0)\n    }\n\n    case class Variable(v: String) extends Term(v) {\n      def differentiate: Expression = Constant(1)\n    }\n\n    abstract class Op(arg1: Expression, arg2: Expression, val name: String) extends Command with Expression {\n      val args = List(arg1, arg2)\n      val command = this\n    }\n\n    case class Minus(m1: Expression, m2: Expression) extends Op(m1, m2, \"-\") {\n      def eval = Plus(m1, Times(m2, Constant(-1))).eval\n      def differentiate = eval.differentiate\n    }\n\n    case class Plus(t1: Expression, t2: Expression) extends Op(t1, t2, \"+\") {\n      def differentiate = {\n        val t1d = t1.eval.differentiate\n        val t2d = t2.eval.differentiate\n        t1d match {\n          case Constant(t) => if (t == 0) t2d else Plus(t1d, t2d).eval\n          case _ => Plus(t1d, t2d).eval\n        }\n      }\n      def eval = {\n        (t1.eval, t2.eval) match {\n          case (Constant(0), a) => a\n          case (a, Constant(0)) => a\n          case (Constant(a), Constant(b)) => Constant(a + b)\n          case (Variable(a), Variable(b)) => if (a == b) Times(Variable(a), Constant(2)) else this\n          case (a@Variable(_), b@Constant(_)) => Plus(a, b)\n          case (a@Constant(_), b@Variable(_)) => Plus(a, b)\n          case (Plus(a, b), Plus(c, d)) => Plus(Plus(a, c).eval, Plus(b, d).eval)\n          case (a, b) => if (a == t1 && b == t2) this else Plus(a, b).eval\n        }\n      }\n    }\n  \n    case class Times(t1: Expression, t2: Expression) extends Op(t1, t2, \"*\") {\n      def differentiate = {\n        val fPrime = t1.eval.differentiate\n        val gPrime = t2.eval.differentiate\n        (t1.eval, t2.eval) match {\n          case (Constant(a), Variable(_)) => Constant(a)\n          case (Variable(_), Constant(a)) => Constant(a)\n          case (f, g) => Plus(Times(f, gPrime).eval, Times(g, fPrime).eval).eval \/\/product rule\n        }\n      }\n      def eval = {\n        (t1.eval, t2.eval) match {\n          case (Constant(0), _) | (_, Constant(0)) => Constant(0)\n          case (Constant(1), a) => a\n          case (b, Constant(1)) => b\n          case (Constant(a), Constant(b)) => Constant(a * b)\n          case (Constant(a), Times(Constant(b), c)) => Times(Constant(a*b), c)\n          case (Constant(a), Times(b, Constant(c))) => Times(Constant(a*c), b)\n          case (a@Variable(_), b@Variable(_)) => if (a.name == b.name) Power(a, Constant(2)) else Times(a, b)\n          case (a, b) => if (a == t1 && b == t2) Times(a, b) else Times(a, b).eval\n        }\n      }\n    }\n\n    case class Divide(t1: Expression, t2: Expression) extends Op(t1, t2, \"\/\") {\n      def differentiate = {\n        val fPrime = t1.eval.differentiate\n        val gPrime = t2.eval.differentiate\n        (t1.eval, t2.eval) match {\n          case (a@Constant(_), b@Variable(_)) => Divide(Times(a, Constant(-1)).eval, Power(b, Constant(2)).eval).eval\n          case (Variable(_), b@Constant(_)) => Divide(Constant(1), b).eval\n          case (f, g) => Divide(Minus(Times(fPrime, g).eval, Times(f, gPrime).eval).eval, Power(g, Constant(2)).eval).eval \/\/quotient rule\n        }\n      }\n      def eval = {\n        (t1.eval, t2.eval) match {\n          case (Constant(0), _) => Constant(0)\n          case (_, Constant(0)) => NAN\n          case (b, Constant(1)) => b\n          case (Constant(a), Constant(b)) => Constant(a \/ b)\n          case (a@Variable(_), b@Variable(_)) => if (a.name == b.name) Constant(1) else Divide(a, b)\n          case (a, b) => if (a == t1 && b == t2) Divide(a, b) else Divide(a, b).eval\n        }\n      }\n    }\n\n    case class Power(t1: Expression, t2: Expression) extends Op(t1, t2, \"^\") {\n      def differentiate = {\n        lazy val protoDiff = Times(Times(t2, Power(t1, Minus(t2, Constant(1)).eval).eval).eval, t1.differentiate).eval\n        t2.eval match {\n          case Constant(t) => if (t == 0) Constant(0) else protoDiff\n          case _ => protoDiff\n        }\n      }\n  \n      def eval = {\n        (t1.eval, t2.eval) match {\n          case (Constant(0), _) => Constant(0)\n          case (_, Constant(0)) => Constant(1)\n          case (Constant(1), _) => Constant(1)\n          case (b, Constant(1)) => b\n          case (Constant(a), Constant(b)) => Constant(math.pow(a, b))\n          case (a, b) => if (a == t1 && b == t2) Power(a, b) else Power(a, b).eval\n        }\n      }\n    }\n\n    abstract class Fn(arg1: Expression, val name: String, constHandler: Double => Double, val cmd: Expression => Fn) extends Command with Expression {\n      val args = List(arg1)\n      def eval = arg1.eval match {\n        case Constant(a) => Constant(constHandler(a))\n        case a => cmd(a)\n      }\n  \n      val command = this\n    }\n  \n    def ChainRule(f: Expression => Expression, gOfx: Expression) = {\n      \/\/f(g(x))\t==> f\u2019(g(x))g\u2019(x)\n      Times(f(gOfx).differentiate, gOfx.differentiate).differentiate\n    }\n  \n    case class Sin(t1: Expression) extends Fn(t1, \"sin\", a => math.sin(a), a => Sin(a)) {\n      override def differentiate: Expression = \/\/ChainRule(x => Cos(x), t1)\n        Times(t1.eval.differentiate, Cos(t1.eval)).eval\n    }\n  \n    case class Cos(t1: Expression) extends Fn(t1, \"cos\", a => math.cos(a), a => Cos(a)) {\n      override def differentiate: Expression = Times(t1.eval.differentiate, Times(Constant(-1), Sin(t1.eval))).eval\n    }\n\n    case class Tan(t1: Expression) extends Fn(t1, \"tan\", a => math.tan(a), a => Tan(a)) {\n      override def differentiate: Expression = Times(t1.eval.differentiate, Plus(Constant(1), Power(Tan(t1.eval), Constant(2)))).eval\n  \n      \/\/(+ 1 (^ (tan x) 2))\n      \/\/Divide(Constant(1), Power(Cos(t1.eval).eval, Constant(2)).eval).eval\n    }\n\n    case class Exp(t1: Expression) extends Fn(t1, \"exp\", a => math.pow(math.E, a), a => Exp(a)) {\n      override def differentiate: Expression = Times(t1.eval.differentiate, Exp(t1.eval)).eval\n  \n    }\n  \n    case class Ln(t1: Expression) extends Fn(t1, \"ln\", a => math.log(a), a => Ln(a)) {\n      override def differentiate: Expression = Times(t1.eval.differentiate, Divide(Constant(1), t1.eval).eval).eval\n    }\n\n      def pars(s: String) = {\n        println(s\"pars $s\")\n\n      def parseConstant(s: String): Option[Expression] = {\n        val p = \"\"\"-?[0-9]+\\.?[0-9]*\"\"\".r\n        println(s\"parseConst $s\")\n        if (p.matches(s)) Some(Constant(s.toDouble)) else None\n      }\n\n      def parseVariable(s: String): Option[Expression] = {\n        val p = \"\"\"[a-zA-Z]\"\"\".r\n        println(s\"parseVariable $s\")\n        if (p.matches(s)) Some(Variable(s)) else None\n      }\n\n      def parseFn(s: String, t: Expression): Option[Expression] = {\n        println(s\"parseFn $s\")\n        s match {\n          case \"sin\" => Some(Sin(t))\n          case \"cos\" => Some(Cos(t))\n          case \"tan\" => Some(Tan(t))\n          case \"exp\" => Some(Exp(t))\n          case \"ln\" => Some(Ln(t))\n          case _ => None\n        }\n      }\n\n      def parseOp(s: String, t1: Expression, t2: Expression): Expression = {\n        println(s\"parseOp $s\")\n        s match {\n          case \"+\" => Plus(t1, t2)\n          case \"-\" => Minus(t1, t2)\n          case \"*\" => Times(t1, t2)\n          case \"\/\" => Divide(t1, t2)\n          case \"^\" => Power(t1, t2)\n          case _ => NULL\n        }\n      }\n\n      val expression = s.filterNot(i => i == '(' || i == ')').split(\" \").reverse\n\n      def process(stack: List[Expression], expression: Array[String]): Expression = {\n        if (expression.isEmpty) stack.head\n        else {\n          val nxt = parseConstant(expression.head)\n            .getOrElse(parseVariable(expression.head)\n              .getOrElse(parseFn(expression.head, stack.head)\n                .getOrElse(parseOp(expression.head, stack.head, stack.tail.head))))\n          nxt match {\n            case _: Constant | _: Variable => process(nxt :: stack, expression.tail)\n            case _: Fn => process(nxt :: stack.tail, expression.tail)\n            case _: Op => process(nxt :: stack.tail.tail, expression.tail)\n          }\n        }\n      }\n\n      process(List[Expression](), expression)\n    }  \n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336468,"user_id":null,"body":"import scala.math.{pow => fpow}\n\nobject PrefixDiff {\n  \/\/ Expression combinators \n  \n  def add(a: Expr, b: Expr): Expr = (a, b) match {\n    case (Number(aa), Number(bb)) => Number (aa + bb)\n    case (Zero, _) => b\n    case (_, Zero) => a\n    case _ => Add(a, b)\n  }\n  \n  def sub(a: Expr, b: Expr): Expr = (a, b) match {\n    case (Number(aa), Number(bb)) => Number (aa - bb)\n    case (Zero, _) => -b\n    case (_, Zero) => a\n    case _ => Sub(a, b)\n  }\n\n def mul(a: Expr, b: Expr): Expr = (a, b) match {\n    case (Number(aa), Number(bb)) => Number (aa * bb)\n    case (_, Number(_)) => b * a \/\/ Number first\n    case (Zero, _) => Zero\n    case (One, _) => b\n    case _ if a == b => a ** 2\n    case (Number(aa), Div(Number(bb), e)) => Number(aa * bb) \/ e\n    case _ => Mul(a, b)\n  }\n\n  def div(a: Expr, b: Expr): Expr = (a, b) match {\n    case (Number(aa), Number(bb)) => Number (aa \/ bb)\n    case (Zero, _) => Zero\n    case (_, One) => a\n    case _ => Div(a, b)\n  }\n  \n  def pow(a: Expr, b: Expr): Expr = (a, b) match {\n    case( Zero, _) => Zero\n    case (One, _) => One\n    case (_, One) => a\n    case (Number(aa), Number(bb)) => Number(fpow(aa, bb))\n    case (_, Number(-1)) => One \/ a\n    case _ => Pow(a, b)\n  }\n  \n  \/\/ Expressions\n  sealed trait Expr {\n    def derivative: Expr\n    def +(other: Expr): Expr = add(this, other)\n    def -(other: Expr): Expr = sub(this, other)\n    def *(other: Expr): Expr = mul(this, other)\n    def \/(other: Expr): Expr = div(this, other)\n    def unary_- : Expr = mul(Number(-1), this)\n    def **(other: Expr): Expr = pow(this, other)\n    def **(other: Int): Expr = pow(this, Number(other))\n  }\n  \n  \/\/ Constant\n  case class Number(n: Double) extends Expr {\n    def derivative = Zero\n    override def toString = if (n.isWhole) n.toInt.toString else n.toString\n  }\n  \n  val Zero = Number(0)\n  val One = Number(1)\n  \n  \/\/ X\n  case object Var extends Expr {\n    def derivative = One\n    override def toString = \"x\"\n  }\n\n  \/\/ Expressions with 2 operands\n  trait BinaryExpr extends Expr {\n    val a: Expr\n    val b: Expr\n    def op: String\n    override def toString = s\"($op $a $b)\"\n  }\n  \n  case class Add(a: Expr, b: Expr) extends BinaryExpr {\n    def derivative = a.derivative + b.derivative\n    def op = \"+\"\n  }\n  \n  case class Sub(a: Expr, b: Expr) extends BinaryExpr {\n    def derivative = a.derivative - b.derivative\n    def op = \"-\"\n  }\n  \n  case class Mul(a: Expr, b: Expr) extends BinaryExpr {\n    def derivative = (a, b) match {\n      case (Number(_), Number(_)) => Zero\n      case (Number(_), Var) => a\n      case (Var, Number(_)) => b\n      case (Number(_), _) => a * b.derivative\n      case (_, Number(_)) => b * a.derivative\n      \/\/ Product rule\n      case (_, _) => (a.derivative * b) + (b.derivative * a)\n    }\n    def op = \"*\"\n  }\n\n  case class Div(a: Expr, b: Expr) extends BinaryExpr {\n    def derivative = a match {\n      case Number(n) => Number(-n) * (b.derivative \/ (b * b))\n      case _ => ((a.derivative * b) - (b.derivative * a)) \/ (b * b)\n    }\n    def op = \"\/\"\n  }\n  \n  case class Pow(a: Expr, b: Expr) extends BinaryExpr {\n    def derivative = (a, b) match {\n      case (_, Number(n)) => b * (a ** Number(n - 1)) * a.derivative\n    }\n    def op = \"^\"\n  }\n\n  \/\/ Expressions with 1 operand\n  trait UnaryExpr extends Expr {\n    val e: Expr\n    def op: String\n    override def toString = s\"($op $e)\"\n  }\n  \n  case class Cos(e: Expr) extends UnaryExpr {\n    def derivative = -Sin(e) * e.derivative\n    def op = \"cos\"\n  }\n  \n  case class Sin(e: Expr) extends UnaryExpr {\n    def derivative = Cos(e) * e.derivative\n    def op = \"sin\"\n  }\n  \n  case class Tan(e: Expr) extends UnaryExpr {\n    def derivative = e match {\n      case Var => One + this ** Number(2)\n      case _ => (One + this ** Number(2)) * e.derivative\n    }\n    def op = \"tan\"\n  }\n  \n  case class Exp(e: Expr) extends UnaryExpr {\n    def derivative = this * e.derivative\n    def op = \"exp\"\n  }\n  \n  case class Ln(e: Expr) extends UnaryExpr {\n    def derivative = e.derivative \/ e\n    def op = \"ln\"\n  }\n  \n  \n  \/\/ The parser\n  \n  val binOps = Set(\"+\", \"-\", \"*\", \"\/\", \"^\")\n  val unOps = Set(\"cos\", \"sin\", \"tan\", \"exp\", \"ln\")\n\n  def parse(expr: String): Expr = {\n    \/\/ Find the first character that isn't a space\n    def skipSpaces(pos: Int): Int = {\n      var i = pos\n      while (i < expr.length && expr(i).isSpaceChar) {\n        i = i + 1\n      }\n      return i;\n    }   \n    \n    def parseExpr(pos: Int): (Expr, Int) = expr(pos) match {\n      \/\/ Skip spaces\n      case c if c.isSpaceChar => parseExpr(skipSpaces(pos + 1))\n      case '(' => parseOperation(skipSpaces(pos + 1))\n      case 'x' => (Var, skipSpaces(pos + 1))\n      case c if c.isDigit => parseNumber(pos)\n      case ')' => throw new RuntimeException(\"Unexpected )\")\n    }\n        \n    def mkBinExpr(op: String, e1: Expr, e2: Expr): Expr = op match {\n      case \"+\" => Add(e1, e2)\n      case \"-\" => Sub(e1, e2)\n      case \"*\" => Mul(e1, e2)\n      case \"\/\" => Div(e1, e2)\n      case \"^\" => Pow(e1, e2)\n    }\n    \n    def mkUnExpr(op: String, e: Expr): Expr = op match {\n      case \"cos\" => Cos(e)\n      case \"sin\" => Sin(e)\n      case \"tan\" => Tan(e)\n      case \"exp\" => Exp(e)\n      case \"ln\" => Ln(e)\n    }\n    \n    def parseNumber(pos: Int): (Expr, Int) = {\n      var i = pos\n      var num = 0\n      while (i < expr.length && expr(i).isDigit) {\n        num *= 10\n        num += expr(i) - '0'\n        i = i + 1\n      }\n      return (Number(num), i);\n    }\n    \n    def parseOperation (pos: Int): (Expr, Int) =  {\n      val s\"$op $_\" = expr.substring(pos)\n      \n      if (binOps.contains(op)) {\n        val (e1, p1) = parseExpr(pos + op.length)\n        val (e2, p2) = parseExpr(p1)\n        (mkBinExpr(op, e1, e2), skipSpaces(p2) + 1) \/\/ + 1 due to the )\n      } else {\n        assert (unOps.contains(op))\n        val (ex, p) = parseExpr(pos + op.length)\n        (mkUnExpr(op, ex), skipSpaces(p) + 1)\n      }\n    }\n    \n    parseExpr(0)._1\n  }\n    \n  def diff(expr: String): String = {\n    parse(expr).derivative.toString\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336469,"user_id":null,"body":"object PrefixDiff {\n  \n    def isPolynom(s: String): Boolean = s.last == 'x'\n  \n    def isNumber(s: String): Boolean = s.forall(_.isDigit)\n  \n    def formatNumber(d: Double): String = if (d.isWhole) d.toInt.toString else d.toString \n  \n    def formatPolynom(s: String): String = if (s.length == 1) \"1\" else s.dropRight(1)\n  \n    def chain(a: String, raw: String) = s\"(* ${diffAux(a)} $raw)\"\n  \n    def diffAux(expr: String): String = {\n\n      def simpleDerivative(a: String): String = {\n        a match {\n          case \"x\" => \"1\"\n          case x => \"0\"\n        }\n      }\n      \n      def sum(a: String, b: String): String = s\"(+ ${diffAux(a)} ${diffAux(b)})\"\n      \n      def difference(a: String, b: String): String = s\"(- ${diffAux(a)} ${diffAux(b)})\"\n      \n      def product(a: String, b: String): String = {\n        val x = {\n          val dA = diffAux(a)\n          if (dA == \"0\") \"0\" else s\"(* $b $dA)\"\n        }\n        val y = {\n          val dB = diffAux(b)\n          if (dB == \"0\") \"0\" else s\"(* $a $dB)\"\n        }\n        s\"(+ $x $y)\"\n      }\n      \n      def quotient(a: String, b: String): String = {\n        val x = {\n          val x0 = {\n            val dA = diffAux(a)\n            if (dA == \"0\") \"0\" else s\"(* $b $dA)\"\n          }\n          val x1 = {\n            val dB = diffAux(b)\n            if (dB == \"0\") \"0\" else s\"(* $a $dB)\"\n          }\n          s\"(- $x0 $x1)\"\n        }\n        val y = s\"(^ $b 2)\"\n         s\"(\/ $x $y)\"\n      }\n      \n      def sin(a: String): String = chain(a, s\"(cos $a)\")\n      \n      def cos(a: String): String = chain(a, s\"(* -1 (sin $a))\")\n      \n      def tan(a: String): String = chain(a, s\"(+ 1 (^ (tan $a) 2))\")\n      \n      def exp(a: String): String = chain(a, s\"(exp $a)\")\n      \n      def ln(a: String): String = chain(a, s\"(\/ 1 $a)\")\n      \n      def pow(a: String, b: String): String = chain(a, s\"(* $b (^ $a (- $b 1)))\")\n      \n      val args = {\n        val noBrackets = if (expr(0) == '(') expr.drop(1).dropRight(1) else expr\n        def parse(s: String, scoped: Boolean = false, acc: List[String] = List()): List[String] = {\n          if (s == \"\") acc\n          else {\n            if (scoped) {\n              val scanned = s.split(\"\").toList.scan(\"(\")(_ + _)\n              val end = scanned.indexWhere(x => x.count(_ == '(') == x.count(_ == ')'))\n              val message = scanned(end)\n              parse(s.drop(end), !scoped, acc :+ message)\n            }\n            else {\n              val end = s.indexOf(\"(\")\n              val message = if (end == -1) s else s.take(end)\n              val parsed = message.split(\" \").filter(_ != \"\")\n              parse(s.drop(message.length + 1), !scoped, acc ++ parsed)\n            }\n          }\n        }\n        parse(noBrackets)\n      }\n      \n      args(0) match {\n        case \"+\" => sum(args(1), args(2))\n        case \"-\" => difference(args(1), args(2))\n        case \"*\" => product(args(1), args(2))\n        case \"\/\" => quotient(args(1), args(2))\n        case \"^\" => pow(args(1), args(2))\n        case \"cos\" => cos(args(1))\n        case \"sin\" => sin(args(1))\n        case \"tan\" => tan(args(1))\n        case \"exp\" => exp(args(1))\n        case \"ln\" => ln(args(1))\n        case x => simpleDerivative(x)\n      }\n    }\n  \n    def diff(expr: String): String = {\n      def evaluate(expr: String): String = {\n        def sum(a: String, b: String): String = {\n          (evaluate(a), evaluate(b)) match {\n            case (x, y) if x == \"0\" => y\n            case (x, y) if y == \"0\" => x\n            case (x, y) if isNumber(x) && isNumber(y) => formatNumber(x.toDouble + y.toDouble)\n            case (x, y) if isPolynom(x) && isPolynom(y) => formatNumber(formatPolynom(x).toDouble + formatPolynom(y).toDouble) ++ \"x\"\n            case (x, y) => s\"(+ $x $y)\"\n          }\n        }\n\n        def difference(a: String, b: String): String = {\n          (evaluate(a), evaluate(b)) match {\n            case (x, y) if x == \"0\" => \"-\" + y\n            case (x, y) if y == \"0\" => x\n            case (x, y) if isNumber(x) && isNumber(y) => formatNumber(x.toDouble - y.toDouble)\n            case (x, y) if isPolynom(x) && isPolynom(y) => formatNumber(formatPolynom(x).toDouble - formatPolynom(y).toDouble) ++ \"x\"\n            case (x, y) => s\"(- $x $y)\"\n          }\n        }\n\n        def product(a: String, b: String): String = {\n          (evaluate(a), evaluate(b)) match {\n            case (x, y) if x == \"1\" => y\n            case (x, y) if y == \"1\" => x\n            case (x, y) if x == \"0\" || y == \"0\" => \"0\"\n            case (x, y) if isNumber(x) && isNumber(y) => formatNumber(x.toDouble * y.toDouble)\n            case (x, y) => s\"(* $x $y)\"\n          }\n        }\n\n        def quotient(a: String, b: String): String = {\n          (evaluate(a), evaluate(b)) match {\n            case (x, y) if y == \"1\" => x\n            case (x, y) if x == \"0\" => \"0\"\n            case (x, y) if isNumber(x) && isNumber(y) => formatNumber(x.toDouble \/ y.toDouble)\n            case (x, y) => s\"(\/ $x $y)\"\n          }\n        }\n\n        def sin(a: String): String = s\"(sin ${evaluate(a)})\"\n\n        def cos(a: String): String = s\"(cos ${evaluate(a)})\"\n\n        def tan(a: String): String = s\"(tan ${evaluate(a)})\"\n\n        def exp(a: String): String = s\"(exp ${evaluate(a)})\"\n\n        def ln(a: String): String = s\"(ln ${evaluate(a)})\"\n\n        def pow(a: String, b: String): String = {\n          (evaluate(a), evaluate(b)) match {\n            case (x, y) if x == \"1\" => \"1\"\n            case (x, y) if y == \"1\" => x\n            case (x, y) if y == \"0\" => \"1\"\n            case (x, y) if x == \"0\" => \"0\"\n            case (x, y) if isNumber(x) && isNumber(y) => formatNumber(math.pow(x.toDouble, y.toDouble))\n            case (x, y)  => s\"(^ $x $y)\"\n          }\n        }\n\n        val args = {\n          val noBrackets = if (expr(0) == '(') expr.drop(1).dropRight(1) else expr\n          def parse(s: String, scoped: Boolean = false, acc: List[String] = List()): List[String] = {\n            if (s == \"\") acc\n            else {\n              if (scoped) {\n                val scanned = s.split(\"\").toList.scan(\"(\")(_ + _)\n                val end = scanned.indexWhere(x => x.count(_ == '(') == x.count(_ == ')'))\n                val message = s.take(end - 1)\n                parse(s.drop(end), !scoped, acc :+ message)\n              }\n              else {\n                val end = s.indexOf(\"(\")\n                val message = if (end == -1) s else s.take(end)\n                val parsed = message.split(\" \").filter(_ != \"\")\n                parse(s.drop(message.length + 1), !scoped, acc ++ parsed)\n              }\n            }\n          }\n          parse(noBrackets)\n        }\n\n        args(0) match {\n          case \"+\" => sum(args(1), args(2))\n          case \"-\" => difference(args(1), args(2))\n          case \"*\" => product(args(1), args(2))\n          case \"\/\" => quotient(args(1), args(2))\n          case \"^\" => pow(args(1), args(2))\n          case \"cos\" => cos(args(1))\n          case \"sin\" => sin(args(1))\n          case \"tan\" => tan(args(1))\n          case \"exp\" => exp(args(1))\n          case \"ln\" => ln(args(1))\n          case x => x\n        }\n      }\n      \n      val diffExpanded = diffAux(expr)\n      evaluate(diffExpanded)\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336470,"user_id":null,"body":"object PrefixDiff {\n  def isx(str: String): Boolean = str.indexOf(\"x\")==(-1)\n  def split(str: String): List[String]= {\n    if(str.indexOf(\" \")==(-1)) return List(str)\n    if(str(1)=='+' || str(1)=='-'|| str(1)=='*' || str(1)=='\/' || str(1)=='^') {\n\n      val helpStr = str.substring(3,str.length-1).trim\n      if(!helpStr.startsWith(\"(\")) return List(str(1).toString,\n        helpStr.substring(0,helpStr.indexOf(\" \")),\n          helpStr.substring(helpStr.indexOf(\" \")+1)\n      )\n      var pointer = 0;\n      var col = 0;\n      do{\n        if(helpStr(pointer)=='(') col+=1;\n        if(helpStr(pointer)==')') col-=1;\n        pointer+=1\n      } while (col !=0)\n      return List(\n        str(1).toString,\n        helpStr.substring(0,pointer),\n        helpStr.substring(pointer+1)\n      )\n    }\n    List(str.substring(1, str.indexOf(\" \")), str.substring(str.indexOf(\" \")+1, str.length-1))\n  }\n  def add(l: List[String]):String = {\n    val x1 = diff(l(1))\n    val x2 = diff(l(2))\n    if(x1.indexOf(\"x\")==(-1) && x2.indexOf(\"x\")==(-1)) return s\"${x1.toInt+x2.toInt}\"\n    if(x1.indexOf(\"x\")==(-1) && x1.toInt==0) return s\"${x2.toInt}\"\n    if(x2.indexOf(\"x\")==(-1) && x2.toInt==0) return s\"${x1.toInt}\"\n    s\"(+ $x1 $x2)\"\n  }\n  def dif(l: List[String]):String = {\n    val x1 = diff(l(1))\n    val x2 = diff(l(2))\n    if(x1.indexOf(\"x\")==(-1) && x2.indexOf(\"x\")==(-1)) return s\"${x1.toInt-x2.toInt}\"\n    if(x1.indexOf(\"x\")==(-1) && x1.toInt==0) return s\"(* -1 $x2)\"\n    if(x2.indexOf(\"x\")==(-1) && x2.toInt==0) return s\"$x1\"\n    s\"(- $x1 $x2)\"\n  }\n  def mul(l: List[String]):String ={\n    val x11 = diff(l(1))\n    val x12 = l(2)\n    val x21 = diff(l(2))\n    val x22 = l(1)\n    var x1 =if(isx(x12)) s\"(* $x12 $x11)\" else s\"(* $x11 $x12)\"\n    var x2=if(isx(x22)) s\"(* $x22 $x21)\" else s\"(* $x21 $x22)\"\n\n    if((x11.indexOf(\"x\")==(-1) && x11.toInt==0) || (x12.indexOf(\"x\")==(-1) && x12.toInt==0)) x1 = \"0\"\n    if((x21.indexOf(\"x\")==(-1) && x21.toInt==0) || (x22.indexOf(\"x\")==(-1) && x22.toInt==0)) x2 = \"0\"\n\n    if(x11.indexOf(\"x\")==(-1) && x12.indexOf(\"x\")==(-1)) x1 = s\"${x11.toInt*x12.toInt}\"\n    if(x21.indexOf(\"x\")==(-1) && x22.indexOf(\"x\")==(-1)) x2 = s\"${x21.toInt*x22.toInt}\"\n\n    if(x1.indexOf(\"x\")==(-1) && x2.indexOf(\"x\")==(-1)) return s\"${x1.toInt+x2.toInt}\"\n    if(isx(x1) && x1.toInt==0) return x2\n    if(isx(x2) && x2.toInt==0) return x1\n\n    s\"(+ $x1 $x2)\"\n  }\n\n  def div(l: List[String]):String ={\n    val x11 = diff(l(1))\n    val x12 = l(2)\n    val x21 = diff(l(2))\n    val x22 = l(1)\n    var x1 =if(isx(x12)) s\"(* $x12 $x11)\" else s\"(* $x11 $x12)\"\n    var x2=if(isx(x22)) s\"(* $x22 $x21)\" else s\"(* $x21 $x22)\"\n    var num = s\"(+ $x1 $x2)\"\n    val denum =if (isx(x12)) s\"${x12.toInt*x12.toInt}\" else s\"(^ $x12 2)\"\n\n    if((x11.indexOf(\"x\")==(-1) && x11.toInt==0) || (x12.indexOf(\"x\")==(-1) && x12.toInt==0)) x1 = \"0\"\n    if((x21.indexOf(\"x\")==(-1) && x21.toInt==0) || (x22.indexOf(\"x\")==(-1) && x22.toInt==0)) x2 = \"0\"\n\n    if(x11.indexOf(\"x\")==(-1) && x12.indexOf(\"x\")==(-1)) x1 = s\"${x11.toInt*x12.toInt}\"\n    if(x21.indexOf(\"x\")==(-1) && x22.indexOf(\"x\")==(-1)) x2 = s\"${x21.toInt*x22.toInt}\"\n\n    if(x1.indexOf(\"x\")==(-1) && x2.indexOf(\"x\")==(-1)) num= s\"${x1.toInt-x2.toInt}\"\n    if(isx(x1) && x1.toInt==0) num = s\"-$x2\"\n    if(isx(x2) && x2.toInt==0) num= x1\n\n    if(isx(num) && isx(denum)) return s\"${num.toDouble\/denum.toDouble}\"\n    s\"(\/ $num $denum)\"\n  }\n\n  def pow(l: List[String]):String ={\n    val t = if (l(2).toInt==2) s\"(* 2 ${l(1)})\" else s\"(* ${l(2)} (^ ${l(1)} ${l(2).toInt-1}))\"\n    if(l(1).length==1 || split(l(1))(0)==\"+\" || split(l(1))(0)==\"-\") return t\n    else s\"(* $t ${diff(l(1))})\"\n  }\n  def sin(l: List[String]):String = if(l(1).length==1 || split(l(1))(0)==\"+\" || split(l(1))(0)==\"-\") s\"(cos ${l(1)})\"\n  else s\"(* ${split(l(1))(1)} (cos ${l(1)}))\"\n  def cos(l: List[String]):String = if(l(1).length==1 || split(l(1))(0)==\"+\" || split(l(1))(0)==\"-\") s\"(* -1 (sin ${l(1)}))\"\n  else s\"(* ${split(l(1))(1)} (* -1 (sin ${l(1)})))\"\n  def tan(l: List[String]):String =if(l(1).length==1 || split(l(1))(0)==\"+\" || split(l(1))(0)==\"-\") s\"(+ 1 (^ (tan ${l(1)}) 2))\"\n  else s\"(* ${split(l(1))(1)} (+ 1 (^ (tan ${l(1)}) 2)))\"\n  def exp(l: List[String]):String = if(l(1).length==1 || split(l(1))(0)==\"+\" || split(l(1))(0)==\"-\") s\"(exp ${l(1)})\"\n  else s\"(* ${split(l(1))(1)} (exp ${l(1)}))\"\n  def log(l: List[String]):String = if(l(1).length==1 || split(l(1))(0)==\"+\" || split(l(1))(0)==\"-\") s\"(\/ 1 ${l(1)})\"\n  else s\"(* ${split(l(1))(1)} (\/ 1 ${l(1)}))\"\n\n\n  def diff(expr: String):String = {\n    val parsedStr = split(expr)\n    parsedStr.head match {\n      case \"+\" => add(parsedStr)\n      case \"-\" => dif(parsedStr)\n      case \"*\" => mul(parsedStr)\n      case \"\/\" => div(parsedStr)\n      case \"x\" => \"1\"\n      case _ if parsedStr.length==1 => \"0\"\n      case \"^\" => pow(parsedStr)\n      case \"sin\" => sin(parsedStr)\n      case \"cos\" => cos(parsedStr)\n      case \"tan\" => tan(parsedStr)\n      case \"exp\" => exp(parsedStr)\n      case \"ln\" => log(parsedStr)\n      case _ => s\"Error(${parsedStr.mkString(\" \")})\"\n    }\n  }\n  }","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336471,"user_id":null,"body":"object PrefixDiff {\n    def diff(expr: String): String = mkString(operate(diff(Parser(expr)._1)))\n\n  def diff(expr: Expression): Expression = expr match {\n    case const(_) => const(0)\n    case X => const(1)\n    case ++(a, b) => ++(diff(a), diff(b))\n    case --(a, b) => --(diff(a), diff(b))\n    case **(a, b) => ++(**(diff(a), b), **(a, diff(b)))\n    case div(a, b) => div(--(**(diff(a), b), **(a, diff(b))), pow(b, const(2)))\n    case pow(a, b) => **(**(b, pow(a, --(b, const(1)))), diff(a))\n    case cos(a) => **(diff(a), **(const(-1), sin(a)))\n    case sin(a) => **(diff(a), cos(a))\n    case tan(a) => **(diff(a), ++(const(1), pow(tan(a), const(2))))\n    case exp(a) => **(diff(a), exp(a))\n    case ln(a) => div(diff(a), a)\n  }\n\n  def operate(expr: Expression): Expression = {\n    val expression = expr match {\n      case ++(pow(sin(a), const(2)), pow(cos(b), const(2))) if a == b => const(1)\n      case ++(pow(cos(a), const(2)), pow(sin(b), const(2))) if a == b => const(1)\n      case ++(const(0), x) => x\n      \n      case ++(const(a), const(b)) => const(a + b)\n      case ++(a, b) => ++(operate(a), operate(b))\n      \n      case --(a, b) if a == b => const(0)\n      case --(const(a), const(b)) => const(a - b)\n      case --(a, b) => --(operate(a), operate(b))\n\n      case **(const(0), _) | **(_, const(0)) => const(0)\n      case **(const(1), a) => a\n      case **(a, const(1)) => a\n      \n      case **(a, b) => **(operate(a), operate(b))\n\n      case div(const(0), _) => const(0)\n      case div(a, const(1)) => a\n      case div(a, b) if a == b => const(1)\n      case div(a, b) => div(operate(a), operate(b))\n\n      case pow(const(a), const(b)) => const(math.pow(a, b).toInt)\n      case pow(const(0), _) => const(0)\n      case pow(_, const(0)) => const(1)\n      case pow(a, const(1)) => a\n      case pow(a, b) => pow(operate(a), operate(b))\n\n      case sin(const(a)) if a % math.Pi == 0 => const(0)\n      case sin(a) => sin(operate(a))\n\n      case cos(const(a)) if a % (math.Pi \/ 2) == 0 => const(0)\n      case cos(a) => cos(operate(a))\n\n      case tan(const(a)) if a % math.Pi == 0 => const(0)\n      case tan(a) => tan(operate(a))\n\n      case exp(const(0)) => const(1)\n      case exp(ln(a)) => a\n      case exp(a) => exp(operate(a))\n\n      case ln(const(1)) => const(0)\n      case ln(exp(a)) => a\n      case ln(a) => ln(operate(a))\n\n      case _ => expr\n    }\n    if (expression != expr) operate(expression) else expr\n  }\n\n  def mkString(expr: Expression): String = expr match {\n    case exp(a) => s\"(exp ${mkString(a)})\"\n    case tan(a) => s\"(tan ${mkString(a)})\"\n    case cos(a) => s\"(cos ${mkString(a)})\"\n    case sin(a) => s\"(sin ${mkString(a)})\"\n    case ++(a, b) => s\"(+ ${mkString(a)} ${mkString(b)})\"\n    case --(a, b) => s\"(- ${mkString(a)} ${mkString(b)})\"\n    case **(a, b) => s\"(* ${mkString(a)} ${mkString(b)})\"\n    case div(const(a), const(b)) => (a.toDouble \/ b).toString\n    case div(a, b) => s\"(\/ ${mkString(a)} ${mkString(b)})\"\n    case pow(a, b) => s\"(^ ${mkString(a)} ${mkString(b)})\"\n    case const(a) => a.toString\n    case X => \"x\"\n  }\n\n  sealed trait Expression\n\n  case class const(value: Int) extends Expression\n\n  case object X extends Expression\n\n  case class ++(a: Expression, b: Expression) extends Expression\n\n  case class --(a: Expression, b: Expression) extends Expression\n\n  case class **(a: Expression, b: Expression) extends Expression\n\n  case class div(a: Expression, b: Expression) extends Expression\n\n  case class pow(a: Expression, b: Expression) extends Expression\n\n  case class cos(a: Expression) extends Expression\n\n  case class sin(a: Expression) extends Expression\n\n  case class tan(a: Expression) extends Expression\n\n  case class exp(a: Expression) extends Expression\n\n  case class ln(a: Expression) extends Expression\n\n  object Parser {\n    @scala.annotation.tailrec\n    def apply(expr: String): (Expression, String) = expr.headOption match {\n      case Some(c) if c.isDigit | c == '-' =>\n        val (numb, tail) = getNumber(expr.tail)\n        (const((c + numb).toInt), tail)\n      case Some('x') => (X, expr.tail)\n      case Some('(') =>\n        expr.substring(1) match {\n          case s\"$s $t0\" =>\n            if (s.length == 1) {\n              parseBi(s, t0)\n            } else {\n              parseMono(s, t0)\n            }\n        }\n      case Some(' ') | Some(')') => Parser(expr.tail)\n    }\n\n    def parseMono(s: String, t0: String): (Expression, String) = {\n      val f = s match {\n        case \"cos\" => e => cos(e)\n        case \"sin\" => e => sin(e)\n        case \"tan\" => e => tan(e)\n        case \"exp\" => e => exp(e)\n        case \"ln\" => e => ln(e)\n      }\n      val (e, t) = Parser.apply(t0)\n      (f(e), t.tail)\n    }\n\n    def parseBi(s: String, t0: String): (Expression, String) = {\n      val f = s match {\n        case \"+\" => (e1, e2) => ++(e1, e2)\n        case \"-\" => (e1, e2) => --(e1, e2)\n        case \"*\" => (e1, e2) => **(e1, e2)\n        case \"\/\" => (e1, e2) => div(e1, e2)\n        case \"^\" => (e1, e2) => pow(e1, e2)\n      }\n      val (e1, t1) = Parser.apply(t0)\n      val (e2, t2) = Parser(t1)\n      (f(e1, e2), t2.tail)\n    }\n\n    def getNumber(expr: String): (String, String) = expr.headOption match {\n      case Some(c) if c.isDigit =>\n        val (num, tail) = getNumber(expr.tail)\n        (c + num, tail)\n      case _ => (\"\", expr)\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336472,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject PrefixDiff {\n    val pattern = \"\\\\b(cos|sin|tan|ln|exp)\\\\b|([\\\\+\\\\*\\\\-\\\\\/\\\\^])|([0-9]+|x)|(\\\\(.*\\\\))\".r\n  \n    def diff(expr: String): String = {\n      val cleanExpr = if (expr(0) == '(') expr.substring(1, expr.size-1) else expr\n      val chunks = pattern.findAllIn(cleanExpr).toList\n      chunks match {\n        case operation :: op1 :: op2 :: Nil if operation == \"^\"=> {\n          val newOp2 = op2.toInt - 1\n          val derivedOp1 = derive(op1, \"\")\n          \n          val firstOp = if (isNumber(derivedOp1)) s\"${op2.toInt * derivedOp1.toInt}\" else op2\n          val base = if (newOp2 <= 1) s\"(* ${firstOp} ${op1})\" else s\"(* ${firstOp} (^ ${op1} ${newOp2}))\"\n          \n          if (!isNumber(derivedOp1)) {\n            return s\"(* ${base} ${derivedOp1})\"\n          }\n          return base\n        }\n        case operation :: op1 :: op2 :: Nil if operation == \"\/\"=> {\n          val newDiv = op2 match {\n            case _ if isNumber(op2) => s\"${op2.toInt * op2.toInt}\"\n            case _ => s\"(^ ${op2} 2)\"\n          }\n          val derivedOp1 = derive(op1, operation)\n          val derivedOp2 = derive(op2, operation)\n\n          if (isNumber(derivedOp1) && isNumber(derivedOp2) && isNumber(newDiv)) {\n            val first = if (derivedOp1 == \"0\") 0 else derivedOp1.toInt * op2.toInt\n            val second = if (derivedOp2 == \"0\") 0 else op1.toInt * derivedOp2.toInt\n            return s\"${(first - second) \/ newDiv.toFloat}\"\n          }\n          else if (isNumber(derivedOp1) && isNumber(derivedOp2)) {\n            val first = if (derivedOp1 == \"0\") 0 else derivedOp1.toInt * op2.toInt\n            val second = if (derivedOp2 == \"0\") 0 else op1.toInt * derivedOp2.toInt\n            return s\"(\/ ${first - second} ${newDiv})\"\n          }\n          else {\n            return s\"(\/ (- (* ${derivedOp1} ${op2}) (* ${op1} ${derivedOp2})) ${newDiv})\"\n          }\n          \n        }\n        case operation :: op1 :: Nil if operation == \"exp\"=> {\n          val newOp1 = derive(op1, operation)\n          return if (newOp1 == \"1\")s\"(${operation} ${op1})\" else s\"(* ${newOp1} (${operation} ${op1}))\"\n        }\n        case operation :: op :: Nil if operation == \"ln\"=> {\n          val derivedOp = derive(op, operation)\n          return s\"(\/ ${derivedOp} ${op})\"\n        }\n\n        case operation :: op1 :: op2 :: Nil => processTwoOps(operation, op1, op2, getFunc(operation))\n        case operation :: op1 :: Nil => processOneOps(operation, op1, getFunc(operation))\n        case op1 :: Nil => return derive(op1, \"\")\n      }\n    }\n\n    def getFunc(op: String): (String, String) => String = op match {\n        case \"+\" => (a, b) => s\"${a.toInt + b.toInt}\"\n        case \"-\" => (a, b) => s\"${a.toInt - b.toInt}\"\n        case \"*\" => (a, b) => s\"${a.toInt * b.toInt}\"\n        case \"\/\" => (a, b) => s\"${a.toFloat \/ b.toInt}\"\n        case \"sin\" => (a, b) => s\"(cos ${b})\"\n        case \"cos\" => (a, b) => s\"(* -1 (sin ${b}))\"\n        case \"tan\" => (a, b) => s\"(+ 1 (^ (tan ${b}) 2))\"\n    }\n\n    def processTwoOps(operation: String, op1: String, op2: String, f: (String, String) => String): String = {\n        val newOp1 = derive(op1, operation)\n        val newOp2 = derive(op2, operation)\n        if (isNumber(newOp1) && isNumber(newOp2))\n            return s\"${f(newOp1, newOp2)}\"\n        else return s\"(${operation} ${newOp1} ${newOp2})\"\n    }\n                          \n    def processOneOps(operation: String, op1: String, f: (String, String) => String): String = {\n        val newOp1 = derive(op1, operation)\n        if (newOp1 == \"1\") {\n          return s\"${f(newOp1, op1)}\"\n        }\n        else {\n          return s\"(* ${newOp1} ${f(newOp1, op1)})\"\n        } \n    }\n    \n    def derive(elem: String, op: String): String = elem.toIntOption match {\n      case Some(_) if isNumber(elem) && (op == \"+\" || op == \"\" || op == \"\/\") => return \"0\"\n      case Some(_) => return elem\n      case _ if elem == \"x\" && op == \"^\" => return elem\n      case _ if elem == \"x\" => return \"1\"\n      case _ => return diff(elem)\n    }\n  \n    def isNumber(s: String) = s.forall(_.isDigit)\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336473,"user_id":null,"body":"\nimport scala.collection.mutable\nimport scala.collection.mutable.ListBuffer\nimport scala.language.postfixOps\n\nobject Conversions {\n  implicit class CustomNode(node: Node) {\n    def -(other: Node): Minus = new Minus(node, other)\n    def +(other: Node): Plus = new Plus(node, other)\n    def \/(other: Node): Divide = new Divide(node, other)\n    def *(other: Node): Multiply = new Multiply(node, other)\n    def ^(other: Node): Power = new Power(node, other)\n  }\n  def variable: Variable = new Variable\n  def value(d: Double): Value = Value(d)\n  def cos(node: Node): Cos = new Cos(node)\n  def sin(node: Node): Sin = new Sin(node)\n  def tan(node: Node): Tan = new Tan(node)\n  def exp(node: Node): Exp = new Exp(node)\n  def ln(node: Node): Ln = new Ln(node)\n}\n\nimport Conversions._\n\nabstract class Node {\n  def derivative: Node\n  def d: Node = derivative\n  def asString: String\n  def reduce: Node = this\n  def r: Node = reduce\n}\n\ncase class Value(value: Double) extends Node {\n  override def derivative: Node = Value(0)\n  override def asString: String =\n    if (math.ceil(value) - value == 0.0) value.toInt.toString\n    else value.toString\n}\n\nclass Variable extends Node {\n  override def derivative: Node = Value(1)\n  override def asString: String = \"x\"\n}\n\ntrait Operation extends Node {\n  override def reduce: Node = this\n}\n\nabstract class Operation2(\n  var node1: Node,\n  var node2: Node,\n  val mathOperation: (Double, Double) => Double\n) extends Operation {\n override def reduce: Node = {\n   node1 = node1.reduce\n   node2 = node2.reduce\n   (node1, node2)\n } match {\n   case (value1: Value, value2: Value) => Value(mathOperation(value1.value, value2.value))\n   case _ => super.reduce\n  }\n}\n\nabstract class Operation1(\n  var node: Node,\n) extends Operation {\n  override def reduce: Node = {\n    node = node.reduce\n    this\n  }\n}\n\nclass Plus(_node1: Node, _node2: Node) extends Operation2(_node1, _node2, _ + _) {\n  override def derivative: Node = node1.d + node2.d\n  override def asString: String = s\"(+ ${node1.asString} ${node2.asString})\"\n\n  override def reduce: Node = (node1.r, node2.r) match {\n    case (Value(0), node) => node\n    case (node, Value(0)) => node\n    case _ => super.reduce\n  }\n}\n\nclass Minus(_node1: Node, _node2: Node) extends Operation2(_node1, _node2, _ - _) {\n\n  override def derivative: Node = node1.d - node2.d\n  override def asString: String = s\"(- ${node1.asString} ${node2.asString})\"\n\n  override def reduce: Node = (node1.r, node2.r) match {\n    case (_: Variable, _: Variable) => value(0)\n    case _ => super.reduce\n  }\n}\n\nclass Multiply(_node1: Node, _node2: Node) extends Operation2(_node1, _node2, _ * _) {\n  override def derivative: Node = (node1 * node2.d) + (node1.d * node2)\n  override def asString: String = s\"(* ${node1.asString} ${node2.asString})\"\n\n  override def reduce: Node = (node1.r, node2.r) match {\n    case (Value(0), _) => value(0)\n    case (_, Value(0)) => value(0)\n    case (Value(1), node) => node\n    case (node, Value(1)) => node\n    case (_: Variable, _: Variable) => variable ^ value(2)\n    case _ => super.reduce\n  }\n}\n\nclass Divide(_node1: Node, _node2: Node) extends Operation2(_node1, _node2, _ \/ _) {\n  override def asString: String = s\"(\/ ${node1.asString} ${node2.asString})\"\n  override def derivative: Node =\n    ((node2 * node1.d) - (node2.d * node1)) \/\n      (node2 ^ value(2))\n\n  override def reduce: Node = (node1.r, node2.r) match {\n    case (Value(0), _) => value(0)\n    case (_, Value(0)) => throw new ArithmeticException(s\"Division by zero: $asString\")\n    case (node, Value(1)) => node\n    case (_: Variable, _: Variable) => value(1)\n    case _ => super.reduce\n  }\n}\n\nclass Power(_node1: Node, _node2: Node) extends Operation2(_node1, _node2, math.pow) {\n  override def asString: String = s\"(^ ${node1.asString} ${node2.asString})\"\n  override def derivative: Node =\n    node1.d * (node2 * (node1 ^ (node2 - value(1))))\n\n  override def reduce: Node = (node1.r, node2.r) match {\n    case (node, Value(1)) => node\n    case (_, Value(0)) => value(1)\n    case _ => super.reduce\n  }\n}\n\nclass Cos(_node: Node) extends Operation1(_node) {\n  override def derivative: Node = node.d * (value(-1) * sin(node))\n  override def asString: String = s\"(cos ${node.asString})\"\n}\n\nclass Sin(_node: Node) extends Operation1(_node) {\n  override def derivative: Node = node.d * cos(node)\n  override def asString: String = s\"(sin ${node.asString})\"\n}\n\nclass Tan(_node: Node) extends Operation1(_node) {\n  override def derivative: Node = node.d * (value(1) + (tan(node) ^ value(2)))\n  override def asString: String = s\"(tan ${node.asString})\"\n}\n\nclass Exp(_node: Node) extends Operation1(_node) {\n  override def derivative: Node = node.d * exp(node)\n  override def asString: String = s\"(exp ${node.asString})\"\n}\n\nclass Ln(_node: Node) extends Operation1(_node) {\n  override def derivative: Node = node.d * (value(1) \/ node)\n  override def asString: String = s\"(ln ${node.asString})\"\n}\n\nobject PrefixDiff {\n  def tokenize(expr: String): List[String] = {\n    if (expr.matches(\"\\\\(.*\\\\)\")) return tokenize(expr.slice(1, expr.length - 1))\n\n    val buffer = new mutable.StringBuilder\n    val content = ListBuffer.empty[String]  \n\n    var braceCounter = 0\n\n    def appendContent: Unit = {\n      if (buffer.nonEmpty)\n        content.append(buffer.toString)\n      buffer.clear()\n    }\n\n    expr foreach {\n        case ' '\n          if braceCounter == 0 => appendContent\n        case chr =>\n          chr match {\n            case '(' => braceCounter += 1\n            case ')' => braceCounter -= 1\n            case _ =>\n          }\n          buffer append chr\n      }\n    appendContent\n    content.toList\n  }\n\n  def parse(expr: String): Node = {\n    val tokens = tokenize(expr)\n    if (tokens.length == 1) return tokens.head match {\n      case double if double.toDoubleOption.nonEmpty => value(double.toDouble)\n      case \"x\" => variable\n    }\n    tokens match {\n      case \"+\" :: arg1 :: arg2 :: Nil => parse(arg1) + parse(arg2)\n      case \"-\" :: arg1 :: arg2 :: Nil => parse(arg1) - parse(arg2)\n      case \"*\" :: arg1 :: arg2 :: Nil => parse(arg1) * parse(arg2)\n      case \"\/\" :: arg1 :: arg2 :: Nil => parse(arg1) \/ parse(arg2)\n      case \"^\" :: arg1 :: arg2 :: Nil => parse(arg1) ^ parse(arg2)\n      case \"cos\" :: arg :: Nil => cos(parse(arg))\n      case \"sin\" :: arg :: Nil => sin(parse(arg))\n      case \"tan\" :: arg :: Nil => tan(parse(arg))\n      case \"ln\" :: arg :: Nil => ln(parse(arg))\n      case \"exp\" :: arg :: Nil => exp(parse(arg))\n      case _ => throw new IllegalArgumentException(s\"Cant parse '$expr'\")\n    }\n  }\n\n  def diff(expr: String): String = parse(expr).derivative.reduce.asString\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336474,"user_id":null,"body":"import scala.util.matching.Regex\n\nobject PrefixDiff {\n\n  trait Expression {\n\n    def formula: String\n\n    def derivative: Expression\n\n    def isConstant: Boolean\n\n    def simplify: Expression\n\n  }\n\n  class Constant(i: Double) extends Expression {\n\n    val number: Double = i\n\n    def formula: String = if(this.number == this.number.toInt) this.number.toInt.toString else this.number.toString\n\n    def derivative: Expression = new Constant(0)\n\n    def isConstant: Boolean = true\n\n    def simplify: Expression = this\n\n  }\n\n  object Variable extends Expression {\n\n    def formula: String = \"x\"\n\n    def derivative: Expression = new Constant(1)\n\n    def isConstant: Boolean = false\n\n    def simplify: Expression = this\n\n  }\n\n  abstract class BinaryOperator(f: Expression, s: Expression, c: Char) extends Expression {\n\n    val first = f.simplify\n    val second = s.simplify\n    val symbol = c\n\n    def formula: String = s\"(${this.symbol} ${this.first.formula} ${this.second.formula})\"\n\n    def isConstant: Boolean = this.simplify match {\n      case p: BinaryOperator => p.first.isConstant && p.second.isConstant\n      case e: Expression => e.isConstant\n    }\n\n  }\n\n  class Plus(f: Expression, s: Expression) extends BinaryOperator(f, s, '+') {\n\n    def derivative: Expression = new Plus(this.first.derivative, this.second.derivative).simplify\n\n    def simplify: Expression = (this.first, this.second) match {\n      case (f: Constant, s: Constant) => new Constant(f.number + s.number)\n      case (f: Constant, s: Plus) => (s.first, s.second) match {\n        case (sf: Constant, ss: Expression) => new Plus(new Constant(f.number + sf.number), ss).simplify\n        case (sf: Expression, ss: Constant) => new Plus(new Constant(f.number + ss.number), sf).simplify\n        case (_, _) => if(f.number == 0) s else this\n      }\n      case (f: Plus, s: Constant) => (f.first, f.second) match {\n        case (ff: Constant, fs: Expression) => new Plus(new Constant(s.number + ff.number), fs).simplify\n        case (ff: Expression, fs: Constant) => new Plus(new Constant(s.number + fs.number), ff).simplify\n        case (_, _) => if(s.number == 0) f else this\n      }\n      case (f: Constant, s: Expression) => if(f.number == 0) s else this\n      case (f: Expression, s: Constant) => if(s.number == 0) f else this\n      case (_, _) => this\n    }\n\n  }\n\n  class Product(f: Expression, s: Expression) extends BinaryOperator(f, s, '*') {\n\n    def derivative: Expression = new Plus(new Product(this.first.derivative, this.second), new Product(this.second.derivative, this.first)).simplify\n\n    def simplify: Expression = (this.first, this.second) match {\n      case (f: Constant, s: Constant) => new Constant(f.number * s.number)\n      case (f: Constant, s: Product) => (s.first, s.second) match {\n        case (sf: Constant, ss: Expression) => new Product(new Constant(f.number * sf.number), ss).simplify\n        case (sf: Expression, ss: Constant) => new Product(new Constant(f.number * ss.number), sf).simplify\n        case (_, _) => if(f.number == 1) s else if(f.number == 0) f else this\n      }\n      case (f: Product, s: Constant) => (f.first, f.second) match {\n        case (ff: Constant, fs: Expression) => new Product(new Constant(s.number * ff.number), fs).simplify\n        case (ff: Expression, fs: Constant) => new Product(new Constant(s.number * fs.number), ff).simplify\n        case (_, _) => if(s.number == 0) f else if(s.number == 0) s else this\n      }\n      case (f: Constant, s: Expression) => if(f.number == 1) s else if(f.number == 0) f else this\n      case (f: Expression, s: Constant) => if(s.number == 1) f else if(s.number == 0) s else this\n      case (_, _) => this\n    }\n\n  }\n\n  class Minus(f: Expression, s: Expression) extends BinaryOperator(f, s, '-') {\n\n    def derivative: Expression = new Minus(this.first.derivative, this.second.derivative).simplify\n\n    def simplify: Expression = (this.first, this.second) match {\n      case (f: Constant, s: Constant) => new Constant(f.number - s.number)\n      case (f: Constant, s: Minus) => (s.first, s.second) match {\n        case (sf: Constant, ss: Expression) => new Minus(new Constant(f.number - sf.number), ss).simplify\n        case (sf: Expression, ss: Constant) => new Minus(new Constant(f.number - ss.number), sf).simplify\n        case (_, _) => if(f.number == 0) new Product(new Constant(-1), s).simplify else this\n      }\n      case (f: Minus, s: Constant) => (f.first, f.second) match {\n        case (ff: Constant, fs: Expression) => new Minus(new Constant(s.number - ff.number), fs).simplify\n        case (ff: Expression, fs: Constant) => new Minus(new Constant(s.number - fs.number), ff).simplify\n        case (_, _) => if(s.number == 0) f else this\n      }\n      case (f: Constant, s: Expression) => if(f.number == 0) new Product(new Constant(-1), s).simplify else this\n      case (f: Expression, s: Constant) => if(s.number == 0) f else this\n      case (_, _) => this\n    }\n\n  }\n\n  class Pow(f: Expression, s: Expression) extends BinaryOperator(f, s, '^') {\n\n    def derivative: Expression = (this.first.isConstant, this.second.isConstant) match {\n      case (true, true) => new Constant(0)\n      case (false, true) => new Product(this.first.derivative, new Product(this.second, new Pow(this.first, new Minus(this.second, new Constant(1))))).simplify\n      case (true, false) => new Product(new Ln(this.first), new Product(this, this.second.derivative)).simplify\n      case (false, false) => new Product(new Plus(new Divide(new Product(this.second, this.first.derivative), this.first), new Product(this.second.derivative, new Ln(this.first))), this).simplify\n    }\n\n    def simplify: Expression = (this.first, this.second) match {\n      case (f: Constant, s: Constant) => new Constant(Math.pow(f.number, s.number))\n      case (f: Expression, s: Constant) => if(s.number == 1) f else if(s.number == 0) new Constant(1) else if(s.number < 0) new Divide(new Constant(1), new Pow(this.f, new Constant(-s.number))).simplify else this\n      case (_, _) => this\n    }\n\n  }\n\n  class Divide(f: Expression, s: Expression) extends BinaryOperator(f, s, '\/') {\n\n    def derivative: Expression = (this.first.isConstant, this.second.isConstant) match {\n      case (true, true) => new Constant(0)\n      case (false, true) => new Divide(this.first.derivative, this.second).simplify\n      case (_, false) => new Divide(new Minus(new Product(this.first.derivative, this.second), new Product(this.second.derivative, this.first)), new Pow(this.second, new Constant(2))).simplify\n    }\n\n    def simplify: Expression = (this.first, this.second) match {\n      case (f: Constant, s: Constant) => new Constant(f.number \/ s.number)\n      case (f: Expression, s: Constant) => if(s.number == 1) f else if(s.number == -1) new Product(new Constant(-1), f) else this\n      case (_, _) => this\n    }\n\n  }\n\n  abstract class Function(n: String, a: Expression) extends Expression {\n\n    val name = n\n    val argument = a.simplify\n\n    def formula = s\"(${this.name} ${this.argument.formula})\"\n\n    def isConstant: Boolean = this.argument.isConstant\n\n    def simplify: Expression = this\n\n    def functionDerivative: Expression\n\n    def derivative: Expression = if(this.argument.isConstant) new Constant(0) else new Product(this.argument.derivative, this.functionDerivative).simplify\n\n  }\n\n  class Sin(argument: Expression) extends Function(\"sin\", argument) {\n    def functionDerivative: Expression = new Cos(this.argument)\n  }\n\n  class Cos(argument: Expression) extends Function(\"cos\", argument) {\n    def functionDerivative: Expression = new Product(new Constant(-1), new Sin(this.argument))\n  }\n\n  class Tan(argument: Expression) extends Function(\"tan\", argument) {\n    def functionDerivative: Expression = new Plus(new Constant(1), new Pow(this, new Constant(2)))\n  }\n\n  class Exp(argument: Expression) extends Function(\"exp\", argument) {\n    def functionDerivative: Expression = new Exp(this.argument)\n  }\n\n  class Ln(argument: Expression) extends Function(\"ln\", argument) {\n    def functionDerivative: Expression = new Divide(new Constant(1), this.argument)\n  }\n\n  private def binaryOperatorPattern: Regex = \"^\\\\(([+\\\\-*\/^]) (\\\\(.+\\\\)|\\\\w+)?? (\\\\(.+\\\\)|\\\\w+)??\\\\)$\".r\n  private def functionCallPattern: Regex = \"^\\\\((sin|cos|tan|exp|ln) (\\\\(?.+\\\\)?)??\\\\)$\".r\n\n  def interpreter(expression: String): Expression = binaryOperatorPattern.findFirstMatchIn(expression) match {\n    case Some(m) => {\n      m.subgroups(0) match {\n        case \"+\" => new Plus(interpreter(m.subgroups(1)), interpreter(m.subgroups(2))).simplify\n        case \"-\" => new Minus(interpreter(m.subgroups(1)), interpreter(m.subgroups(2))).simplify\n        case \"*\" => new Product(interpreter(m.subgroups(1)), interpreter(m.subgroups(2))).simplify\n        case \"\/\" => new Divide(interpreter(m.subgroups(1)), interpreter(m.subgroups(2))).simplify\n        case \"^\" => new Pow(interpreter(m.subgroups(1)), interpreter(m.subgroups(2))).simplify\n      }\n    }\n    case None => functionCallPattern.findFirstMatchIn(expression) match {\n      case Some(m) => {\n        m.subgroups(0) match {\n          case \"sin\" => new Sin(interpreter(m.subgroups(1)))\n          case \"cos\" => new Cos(interpreter(m.subgroups(1)))\n          case \"tan\" => new Tan(interpreter(m.subgroups(1)))\n          case \"exp\" => new Exp(interpreter(m.subgroups(1)))\n          case \"ln\"  => new Ln (interpreter(m.subgroups(1)))\n        }\n      }\n      case None => if(expression == \"x\") Variable else new Constant(expression.toDouble)\n    }\n  }\n\n  def diff(expression: String): String = interpreter(expression).derivative.formula\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336475,"user_id":2955,"body":"object PrefixDiff {\n    \n    def diff(expr: String): String = {\n        val d: String = eval(s\"(d ${expr})\")\n        recEval(d) \/\/ Simplify the derivative\n    }\n\n    def recEval(expr: String): String = {\n        val result = eval(expr)\n        if (expr == result) expr else recEval(result)\n    }\n\n    def parse(str: String): List[String] = {\n        str match {\n            case s if (isComplex(s)) => getArgList(str)\n            case \"x\" => List(\"x\")\n            case _ => List(str)\n        }\n    }\n\n    def getArgList(str: String): List[String] = {\n        val inner = str.trim.drop(1).dropRight(1)\n        argParse(0, 0, inner, List())\n    }\n\n    \/\/ The recursive part that splits 2 arguments\n    def argParse(pos: Int, unclosedPars: Int, str: String, splitStr: List[String]): List[String] = {\n        if (pos < str.length) {\n            str(pos) match {\n                case ' ' if (unclosedPars == 0) => argParse(0, 0, str.drop(pos).trim, splitStr ++ List(str.take(pos))) \/\/ split found. Add to splitStr and reset counters.\n                case '(' => argParse(pos + 1, unclosedPars + 1, str, splitStr)\n                case ')' => argParse(pos + 1, unclosedPars - 1, str, splitStr)\n                case _ => argParse(pos + 1, unclosedPars, str, splitStr)\n            }\n        } else splitStr ++ List(str) \/\/ add last argument\n    }\n\n    def eval(str: String): String  = {\n        val sl = parse(str)\n        if (sl.length > 1) {\n            sl(0) match {\n                case \"+\" if (sl(1) == \"0\") => sl(2)\n                case \"+\" if (sl(2) == \"0\") => sl(1)\n                case \"+\" if (isConstant(sl(1)) && isConstant(sl(2))) => { \n                    (sl(1).toDouble + sl(2).toDouble).toInt.toString\n                }\n                case \"-\" if (isConstant(sl(1)) && isConstant(sl(2))) => {\n                    (sl(1).toDouble - sl(2).toDouble).toInt.toString\n                }\n                case \"*\" if (isConstant(sl(1)) && isConstant(sl(2))) => {\n                    (sl(1).toDouble * sl(2).toDouble).toInt.toString\n                }\n                case \"*\" if (sl(1) == sl(2)) => {\n                    s\"(^ ${sl(1)} 2)\"\n                }\n                case \"*\" if (sl(1) == \"0\" || sl(2) == \"0\") => \"0\"\n                case \"*\" if (sl(1) == \"1\") => sl(2)\n                case \"*\" if (sl(2) == \"1\") => sl(1)\n                case \"\/\" if (isConstant(sl(1)) && isConstant(sl(2))) => {\n                    println(\"dividing\", sl(1), sl(2))\n                    (sl(1).toDouble \/ sl(2).toDouble).toString\n                }\n                case \"\/\" if (sl(1) == \"0\" || sl(2) == \"0\") =>  \"0\"\n                case \"^\" if (sl(2) == \"1\") => sl(1)\n                case \"^\" if (sl(2) == \"0\") => \"1\"\n                case \"d\" => sl(1) match {\n                    case o if (isComplex(o)) => eval(derivative(o))\n                    case \"x\" => \"1\"\n                    case _ => \"0\"\n                }\n                case _ => {\n                    s\"(${sl(0)} ${sl.drop(1).map(eval(_)).mkString(\" \")})\"\n                }\n            }\n        } else str\n    }\n\n    def derivative(str: String): String = {\n        val sl: List[String] = parse(str)\n        sl(0) match {\n            case \"cos\" => s\"(* (d ${sl(1)}) (* -1 (sin ${sl(1)})))\"\n            case \"sin\" => s\"(* (d ${sl(1)}) (cos ${sl(1)}))\"\n            case \"tan\" => s\"(* (d ${sl(1)}) (+ 1 (^ (tan ${sl(1)}) 2)))\"\n            case \"ln\" => s\"(* (d ${sl(1)}) (\/ 1 ${sl(1)}))\"\n            case \"exp\" => s\"(* (d ${sl(1)}) (exp ${sl(1)}))\"\n            case \"+\" => s\"(+ (d ${sl(1)}) (d ${sl(2)}))\"\n            case \"-\" => s\"(- (d ${sl(1)}) (d ${sl(2)}))\"\n            case \"*\" => s\"(+ (* (d ${sl(1)}) ${sl(2)}) (* ${sl(1)} (d ${sl(2)})))\"\n            case \"\/\" => s\"(\/ (- (* (d ${sl(1)}) ${sl(2)}) (* ${sl(1)} (d ${sl(2)}))) (* ${sl(2)} ${sl(2)}) )\"\n            case \"^\" => s\"(* (d ${sl(1)}) (* ${sl(2)} (^ ${sl(1)} (- ${sl(2)} 1))))\" \/\/ I'm assuming the exponent is a number\n        }\n    }\n\n    def isComplex(s: String): Boolean = {\n        s.head == '(' && s.last == ')'\n    }\n\n    def isConstant(s: String): Boolean = {\n        !isComplex(s) && s != \"x\"\n    }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336476,"user_id":null,"body":"import scala.annotation.tailrec\nimport scala.util.matching.Regex\n\nobject PrefixDiff {\n  val SIN = \"sin\"\n  val COS = \"cos\"\n  val TAN = \"tan\"\n  val LN = \"ln\"\n  val EXP = \"exp\"\n  val PLUS = \"+\"\n  val MINUS = \"-\"\n  val STAR = \"*\"\n  val SLASH = \"\/\"\n  val HAT = \"^\"\n  val prefixExpression: Regex = \"\"\"\\((.*)\\)\"\"\".r\n  val unaryOperator: Regex = \"\"\"sin|cos|tan|exp|ln\"\"\".r\n  val binaryOperator: Regex = \"\"\"[+\\-*\/^]\"\"\".r\n  val number: Regex = \"\"\"(-?[0-9]+)(\\.[0-9]+)?\"\"\".r\n  val startsWithNumber: Regex = \"\"\"-?[0-9]+(\\.[0-9]+)?(.*)\"\"\".r\n  val startsWithOperator: Regex = \"\"\"(sin|cos|tan|exp|ln|\\+|-|\\*|\/|\\^) (.*)\"\"\".r\n\n  def extractOperator(str: String): (String, String) = {\n    val index = str.indexOf(' ')\n    if (index < 0) (\"\", str)\n    else (str.slice(0, index), str.substring(index).trim)\n  }\n\n  def extractParameters(str: String): (String, String) =\n    if (str.trim.head == '(')\n      extractParametersInParentheses(str)\n    else\n      (str.slice(0, str.indexOf(' ')), str.substring(str.indexOf(' ')).trim)\n\n  \/*\n   *  if str does not start with a '(' extractParametersInParentheses returns (\"\", str)\n   *  if extractParametersInParentheses does not find a matching ')' it returns (\"\", str)\n   *  if str is \"(x (xx) xx) (yy(((yyy)\" extractParametersInParentheses returns a pair (\"(x (xx) xx)\", \"(yy(((yyy)\")\n   *  if str is \"(xx (xx) x) y\" extractParametersInParentheses returns a pair (\"(xx (xx) x)\", \"y\")\n   *\/\n  def extractParametersInParentheses(str: String): (String, String) = {\n    val start = str.indexOf('(')\n    if (start < 0)\n      (\"\", str)\n    else {\n      var openClose = 1\n      var index = start\n      while (index < str.length && openClose > 0) {\n        index += 1\n        str(index) match {\n          case '(' => openClose += 1\n          case ')' => openClose -= 1\n          case _ =>\n        }\n      }\n      if (openClose == 0) (str.substring(start, index + 1), str.substring(index + 1).trim)\n      else (\"\", str)\n    }\n  }\n\n  def makeExpression(str: String): Expression = {\n    str match {\n      case \"x\" => Variable(str)\n      case number(_, _) => Constant(str.toInt)\n      case prefixExpression(expr) =>\n        extractOperator(expr) match {\n          case (op, arg) if unaryOperator.matches(op) => UnaryTerm(op, makeExpression(arg))\n          case (op, args) if binaryOperator.matches(op) =>\n            val (arg1, arg2) = extractParameters(args)\n            BinaryTerm(op, makeExpression(arg1), makeExpression(arg2))\n        }\n      case err => throw new IllegalArgumentException(s\"$err cannot be parsed\")\n    }\n  }\n\n  def differentiate(expression: Expression): Expression =\n    expression match {\n      case Constant(_) => Constant(0)\n      case Variable(_) => Constant(1)\n      case UnaryTerm(op, a) => op match {\n        case SIN => BinaryTerm(STAR, differentiate(a), UnaryTerm(COS, a))\n        case COS => BinaryTerm(STAR, differentiate(a), BinaryTerm(STAR, Constant(-1), UnaryTerm(SIN, a)))\n        case TAN => BinaryTerm(STAR, differentiate(a), BinaryTerm(PLUS, Constant(1), BinaryTerm(HAT, UnaryTerm(TAN, a), Constant(2))))\n        case LN => BinaryTerm(SLASH, differentiate(a), a)\n        case EXP => BinaryTerm(STAR, differentiate(a), UnaryTerm(EXP, a))\n      }\n      case BinaryTerm(HAT, a, Constant(n)) => BinaryTerm(STAR, BinaryTerm(STAR, Constant(n), BinaryTerm(HAT, a, Constant(n - 1))), differentiate(a))\n      case BinaryTerm(op, a, b) => op match {\n        case PLUS => BinaryTerm(PLUS, differentiate(a), differentiate(b))\n        case MINUS => BinaryTerm(MINUS, differentiate(a), differentiate(b))\n        case STAR => BinaryTerm(PLUS, BinaryTerm(STAR, differentiate(a), b), BinaryTerm(STAR, a, differentiate(b)))\n        case SLASH => BinaryTerm(SLASH, BinaryTerm(MINUS, BinaryTerm(STAR, differentiate(a), b), BinaryTerm(STAR, a, differentiate(b))), BinaryTerm(HAT, b, Constant(2)))\n      }\n    }\n\n  def simplify(expression: Expression): Expression =\n    expression match {\n      case Constant(c) => Constant(c)\n      case Variable(x) => Variable(x)\n      case UnaryTerm(op, exp) => UnaryTerm(op, simplify(exp))\n      case BinaryTerm(HAT, _, Constant(0)) => Constant(1)\n      case BinaryTerm(op, a, b) =>\n        val sa = fullySimplify(a)\n        val sb = fullySimplify(b)\n        (op, sa, sb) match {\n          case (HAT, exp, Constant(1)) => exp\n          case (HAT, Constant(x), Constant(y)) => Constant(math.pow(x, y).toInt)\n          case (HAT, sa, sb) => BinaryTerm(HAT, sa, sb)\n\n          case (PLUS, sa, Constant(0)) => sa\n          case (PLUS, Constant(0), sb) => sb\n          case (PLUS, Constant(x), Constant(y)) => Constant(x + y)\n          case (PLUS, sa, sb) => BinaryTerm(PLUS, sa, sb)\n\n          case (MINUS, sa, Constant(0)) => sa\n          case (MINUS, Constant(0), sb) => BinaryTerm(STAR, Constant(-1), sb)\n          case (MINUS, Constant(x), Constant(y)) => Constant(x - y)\n          case (MINUS, sa, sb) => BinaryTerm(MINUS, sa, sb)\n\n          case (STAR, _, Constant(0)) => Constant(0)\n          case (STAR, Constant(0), _) => Constant(0)\n          case (STAR, sa, Constant(1)) => sa\n          case (STAR, Constant(1), sb) => sb\n          case (STAR, Constant(x), Constant(y)) => Constant(x * y)\n          case (STAR, sa, Constant(c)) => BinaryTerm(STAR, Constant(c), sa)\n          case (STAR, sa, sb) => BinaryTerm(STAR, sa, sb)\n\n          case (SLASH, sa, Constant(1)) => sa\n          case (SLASH, Constant(x), Constant(y)) => Constant(x \/ y)\n          case (SLASH, sa, sb) => BinaryTerm(SLASH, sa, sb)\n\n          case (op, sa, sb) => BinaryTerm(op, sa, sb)\n        }\n    }\n\n  @tailrec\n  def fullySimplify(exp: Expression): Expression = {\n    val simpleExp = simplify(exp)\n    if (simpleExp != exp) fullySimplify(simpleExp) else simpleExp\n  }\n\n  def diff(expr: String): String =\n    simplify(differentiate(makeExpression(expr))).toString\n\n  abstract sealed class Expression() {\n    def toInfix: String\n  }\n\n  case class Constant(c: Double) extends Expression {\n    val cStr: String = if (c.isWhole) c.intValue.toString else c.toString\n\n    override def toString: String = s\"$cStr\"\n\n    def toInfix: String = s\"$cStr\"\n  }\n\n  case class Variable(variable: String) extends Expression {\n    override def toString: String = variable\n\n    def toInfix: String = variable\n  }\n\n  case class UnaryTerm(op: String, arg: Expression) extends Expression {\n    override def toString: String = s\"($op $arg)\"\n\n    def toInfix: String = s\"$op($arg)\"\n  }\n\n  case class BinaryTerm(op: String, arg1: Expression, arg2: Expression) extends Expression {\n    override def toString: String = s\"($op $arg1 $arg2)\"\n\n    def toInfix: String = s\"(${arg1.toInfix} $op ${arg2.toInfix})\"\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58e61f3d8ff24f774400002c":[{"id":336477,"user_id":null,"body":"import scala.collection.mutable\nimport scala.collection.mutable.ListBuffer\nimport scala.util.Try\nobject AssemblerInterpreter {\n  case class Command(command: String, args: Array[String])\n\n  def parseMsg(msg: String): Array[String] = {\n    val curSegment = new mutable.StringBuilder()\n    val args = new ListBuffer[String]\n    var inString = false\n    for (c <- msg.toCharArray) {\n      if (c.isSpaceChar) {\n        if (inString) curSegment.addOne(c)\n      } else if (c == '\\'') {\n        inString = !inString\n        curSegment.addOne(c)\n      } else if (c == ',') {\n        if (inString) curSegment.addOne(c) else {\n          args += curSegment.toString()\n          curSegment.clear()\n        }\n      } else {\n        curSegment.addOne(c)\n      }\n    }\n    if (curSegment.nonEmpty) {\n      args += curSegment.toString()\n    }\n    args.toArray\n  }\n\n  def interpret(input: String): Option[String] = {\n    val commands = input.split(\"\n\").map(r => r.replaceAll(\";.+$\", \"\").trim).filter(_.nonEmpty) \/\/\u53bb\u6ce8\u91ca\uff0c\u8fc7\u6ee4\u7a7a\u884c\n      .map(r => r.split(\"\\\\s+\", 2) match {\n        case Array(command) => Command(command, null)\n        case Array(\"msg\", msg) => Command(\"msg\", parseMsg(msg))\n        case Array(command, args) => Command(command, args.split(\",\\\\s*\"))\n      })\n    val labels = commands.zipWithIndex.filter(t => t._1.command.endsWith(\":\")).map(t => (t._1.command.stripSuffix(\":\"), t._2)).toMap \/\/\u6807\u7b7e=>\u884c\u6570\n    val ctx = new scala.collection.mutable.HashMap[String, Int]()\n\n    def getVal(param: String): Int = Try(param.toInt).getOrElse(ctx(param))\n\n    var (ptr, lastResult, callStack, funcMsg) = (0, 0, List[Int](), null.asInstanceOf[String])\n    var msg: Option[String] = None\n    while (ptr < commands.length) {\n      commands(ptr) match {\n        case Command(\"mov\", Array(x, y)) => ctx(x) = getVal(y) \/\/copy y (either an integer or the value of a register) into register x.\n        case Command(\"inc\", Array(x)) => ctx(x) += 1 \/\/increase the content of register x by one.\n        case Command(\"dec\", Array(x)) => ctx(x) -= 1 \/\/decrease the content of register x by one.\n        case Command(\"add\", Array(x, y)) => ctx(x) += getVal(y) \/\/add the content of the register x with y (either an integer or the value of a register) and stores the result in x (i.e. register[x] += y).\n        case Command(\"sub\", Array(x, y)) => ctx(x) -= getVal(y) \/\/subtract y (either an integer or the value of a register) from the register x and stores the result in x (i.e. register[x] -= y).\n        case Command(\"mul\", Array(x, y)) => ctx(x) *= getVal(y) \/\/same with multiply (i.e. register[x] *= y).\n        case Command(\"div\", Array(x, y)) => ctx(x) \/= getVal(y) \/\/same with integer division (i.e. register[x] \/= y).\n        case Command(c, _) if c.endsWith(\":\") => println(s\"Defined label $c at line $ptr\") \/\/define a label position (label = identifier + \":\", an identifier being a string that does not match any other command). Jump commands and call are aimed to these labels positions in the program.\n        case Command(\"jmp\", Array(label)) => ptr = labels(label) \/\/jumps to the label lbl.\n        case Command(\"cmp\", Array(x, y)) => lastResult = getVal(x) - getVal(y) \/\/compares x (either an integer or the value of a register) and y (either an integer or the value of a register). The result is used in the conditional jumps (jne, je, jge, jg, jle and jl)\n        case Command(\"jne\", Array(label)) => if (lastResult != 0) ptr = labels(label) \/\/jump to the label lbl if the values of the previous cmp command were not equal.\n        case Command(\"je\", Array(label)) => if (lastResult == 0) ptr = labels(label) \/\/jump to the label lbl if the values of the previous cmp command were equal.\n        case Command(\"jge\", Array(label)) => if (lastResult >= 0) ptr = labels(label) \/\/jump to the label lbl if x was greater or equal than y in the previous cmp command.\n        case Command(\"jg\", Array(label)) => if (lastResult > 0) ptr = labels(label) \/\/jump to the label lbl if x was greater than y in the previous cmp command.\n        case Command(\"jle\", Array(label)) => if (lastResult <= 0) ptr = labels(label) \/\/jump to the label lbl if x was less or equal than y in the previous cmp command.\n        case Command(\"jl\", Array(label)) => if (lastResult < 0) ptr = labels(label) \/\/jump to the label lbl if x was less than y in the previous cmp command.\n        case Command(\"call\", Array(label)) => { \/\/call to the subroutine identified by lbl. When a ret is found in a subroutine, the instruction pointer should return to the instruction next to this call command.\n          callStack ::= ptr\n          ptr = labels(label)\n          funcMsg = null\n        }\n        case Command(\"ret\", _) => { \/\/when a ret is found in a subroutine, the instruction pointer should return to the instruction that called the current function.\n          ptr = callStack.head\n          callStack = callStack.tail\n          if (funcMsg != null) msg = Option(funcMsg)\n        }\n        case Command(\"msg\", args) => { \/\/this instruction stores the output of the program. It may contain text strings (delimited by single quotes) and registers. The number of arguments isn't limited and will vary, depending on the program.\n          funcMsg = args.map(arg => if (arg.startsWith(\"'\")) arg.stripPrefix(\"'\").stripSuffix(\"'\") else ctx(arg)).mkString\n          if (callStack.isEmpty) msg = Option(funcMsg)\n        }\n        case Command(\"end\", _) => ptr = commands.length \/\/this instruction indicates that the program ends correctly, so the stored output is returned (if the program terminates without this instruction it should return the default output: see below).\n      }\n      ptr += 1\n    }\n    println(s\"==>input: $input, result: $msg\")\n    println(\"====================\")\n    msg\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336478,"user_id":null,"body":"object AssemblerInterpreter {\n  def interpret(input: String): Option[String] = {\n    val instructions = input.split(\"\\\n\").map(_.trim).map{i =>\n      \"(;)(?=(?:[^']|'[^']*')*$)\".r.findFirstMatchIn(i).map(r => i.substring(0, r.start)).getOrElse(i).trim \/\/Cleaning comments\n    }.filterNot(_.isEmpty)\n\n    def interpreterRec(pointer: Int, memory: Map[String, Int], out: List[String], cmp: (Int, Int) = (-1, -1)): (Map[String, Int], List[String], Boolean) = {\n      if(pointer >= instructions.length) return (memory, out, false)\n\n      val instruction = instructions(pointer)\n\n      instruction.split(\" \").map(_.replace(\",\", \"\").trim).filterNot(_.isEmpty).toList match {\n        case List(\"mov\", x, y) => { \/\/ mov x, y - copy y (either an integer or the value of a register) into register x.\n          interpreterRec(pointer + 1, memory + (x -> memory.getOrElse(y, y.toInt)), out)\n        }\n        case List(\"inc\", x) => { \/\/ inc x - increase the content of register x by one.\n          interpreterRec(pointer + 1, memory + (x -> (memory(x) + 1)), out)\n        }\n        case List(\"dec\", x) => { \/\/ dec x - decrease the content of register x by one.\n          interpreterRec(pointer + 1, memory + (x -> (memory(x) - 1)), out)\n        }\n        case List(\"add\", x, y) => { \/\/ add x, y - add the content of the register x with y (either an integer or the value of a register) and stores the result in x (i.e. register[x] += y).\n          interpreterRec(pointer + 1, memory + (x -> (memory(x) + memory.getOrElse(y, y.toInt))), out)\n        }\n        case List(\"sub\", x, y) => { \/\/ sub x, y - subtract y (either an integer or the value of a register) from the register x and stores the result in x (i.e. register[x] -= y).\n          interpreterRec(pointer + 1, memory + (x -> (memory(x) - memory.getOrElse(y, y.toInt))), out)\n        }\n        case List(\"mul\", x, y) => { \/\/ mul x, y - same with multiply (i.e. register[x] *= y).\n          interpreterRec(pointer + 1, memory + (x -> (memory(x) * memory.getOrElse(y, y.toInt))), out)\n        }\n        case List(\"div\", x, y) => { \/\/ div x, y - same with integer division (i.e. register[x] \/= y).\n          interpreterRec(pointer + 1, memory + (x -> (memory(x) \/ memory.getOrElse(y, y.toInt))), out)\n        }\n        case List(lbl) if(lbl.endsWith(\":\")) => { \/\/ label: - define a label position (label = identifier + \":\", an identifier being a string that does not match any other command). Jump commands and call are aimed to these labels positions in the program.\n          interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"jmp\", lbl) => { \/\/ jmp lbl - jumps to the label lbl.\n          interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n        }\n        case List(\"cmp\", x, y) => { \/\/ cmp x, y - compares x (either an integer or the value of a register) and y (either an integer or the value of a register). The result is used in the conditional jumps (jne, je, jge, jg, jle and jl)\n          interpreterRec(pointer + 1, memory, out, (memory.getOrElse(x, x.toInt), memory.getOrElse(y, y.toInt)))\n        }\n        case List(\"jne\", lbl) => { \/\/ jne lbl - jump to the label lbl if the values of the previous cmp command were not equal.\n          if(cmp._1 != cmp._2) interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          else interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"je\", lbl) => { \/\/ je lbl - jump to the label lbl if the values of the previous cmp command were equal.\n          if(cmp._1 == cmp._2) interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          else interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"jge\", lbl) => { \/\/ jge lbl - jump to the label lbl if x was greater or equal than y in the previous cmp command.\n          if(cmp._1 >= cmp._2) interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          else interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"jg\", lbl) => { \/\/ jg lbl - jump to the label lbl if x was greater than y in the previous cmp command.\n          if(cmp._1 > cmp._2) interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          else interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"jle\", lbl) => { \/\/ jle lbl - jump to the label lbl if x was less or equal than y in the previous cmp command.\n          if(cmp._1 <= cmp._2) interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          else interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"jl\", lbl) => { \/\/ jl lbl - jump to the label lbl if x was less than y in the previous cmp command.\n          if(cmp._1 < cmp._2) interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          else interpreterRec(pointer + 1, memory, out)\n        }\n        case List(\"call\", lbl) => { \/\/ call lbl - call to the subroutine identified by lbl. When a ret is found in a subroutine, the instruction pointer should return to the instruction next to this call command.\n          val callMemory = interpreterRec(instructions.indexOf(s\"$lbl:\"), memory, out)\n          if(callMemory._3) interpreterRec(pointer + 1, callMemory._1, callMemory._2)\n          else (memory, out, false)\n        }\n        case List(\"ret\") => { \/\/ when a ret is found in a subroutine, the instruction pointer should return to the instruction that called the current function.\n          (memory, out, true)\n        }\n        case \"msg\" :: rest => { \/\/ this instruction stores the output of the program. It may contain text strings (delimited by single quotes)\n          val msg = instruction.drop(3).trim \/\/ msg  '(5+1)\/2 = ', a\n          val msgParsed = msg.split(\",(?=([^\\']*\\'[^\\']*\\')*[^\\']*$)\").map{part =>\n            if(part.trim.startsWith(\"'\")) part.trim.drop(1).dropRight(1)\n            else memory(part.trim)\n          }.mkString(\"\")\n\n          interpreterRec(pointer + 1, memory, out :+ msgParsed)\n        }\n        case List(\"end\") => { \/\/ this instruction indicates that the program ends correctly, so the stored output is returned (if the program terminates without this instruction it should return the default output: see below).\n          (memory, out, true)\n        }\n        case _ => (memory, out, false)\n      }\n    }\n\n    val (_, out, success) = interpreterRec(0, Map.empty, List.empty)\n    if(success) Some(out.mkString(\"\n\"))\n    else None\n  }\n\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336479,"user_id":null,"body":"object AssemblerInterpreter {\n  def interpret(input: String): Option[String] = {\n    val program = input.split(\"\n\")\n      .map(_.trim)\n      .map(_.takeWhile(_ != ';'))\n      .map(_.trim)\n      .filter(_.nonEmpty)\n\n    val registers = scala.collection.mutable.Map[String, Int]()\n\n    val rMov = \"\"\"mov\\s+(\\w+),\\s+([-\\w\\d]+)\"\"\".r\n    val rInc = \"\"\"inc\\s+(\\w+)\"\"\".r\n    val rDec = \"\"\"dec\\s+(\\w+)\"\"\".r\n    val rAdd = \"\"\"add\\s+(\\w+),\\s+([-\\w\\d]+)\"\"\".r\n    val rSub = \"\"\"sub\\s+(\\w+),\\s+([-\\w\\d]+)\"\"\".r\n    val rMul = \"\"\"mul\\s+(\\w+),\\s+([-\\w\\d]+)\"\"\".r\n    val rDiv = \"\"\"div\\s+(\\w+),\\s+([-\\w\\d]+)\"\"\".r\n    val rLabel = \"\"\"(\\w+):\"\"\".r\n    val rJmp = \"\"\"jmp\\s+(\\w+)\"\"\".r\n    val rCmp = \"\"\"cmp\\s+(\\w+),\\s+(\\w+)\"\"\".r\n    val rJe = \"\"\"je\\s+(\\w+)\"\"\".r\n    val rJne = \"\"\"jne\\s+(\\w+)\"\"\".r\n    val rJg = \"\"\"jg\\s+(\\w+)\"\"\".r\n    val rJge = \"\"\"jge\\s+(\\w+)\"\"\".r\n    val rJl = \"\"\"jl\\s+(\\w+)\"\"\".r\n    val rJle = \"\"\"jle\\s+(\\w+)\"\"\".r\n    val rCall = \"\"\"call\\s+(\\w+)\"\"\".r\n    val rRet = \"\"\"ret\"\"\".r\n    val rMsg = \"\"\"msg\\s+(.*)\"\"\".r\n    val rEnd = \"\"\"end\"\"\".r\n\n    var ip = 0\n    val ipStack = collection.mutable.Stack[Int]()\n    var compareRegister: Int = 0\n    val output = collection.mutable.ListBuffer[String]()\n\n    def resolveValue(s: String): Int = if (s.matches(\"\"\"-?[\\d]+\"\"\")) s.toInt else registers(s)\n\n    def jumpIf(f: => Boolean, label: String): Unit =\n      if (f) ip = program.indexOf(s\"$label:\") - 1\n\n    while (ip < program.length) {\n      program(ip) match {\n        case rMov(dst, src) => registers(dst) = resolveValue(src)\n        case rInc(reg) => registers(reg) = registers.getOrElse(reg, 0) + 1\n        case rDec(reg) => registers(reg) = registers.getOrElse(reg, 0) - 1\n        case rAdd(dst, src) => registers(dst) = registers(dst) + resolveValue(src)\n        case rSub(dst, src) => registers(dst) = registers(dst) - resolveValue(src)\n        case rMul(dst, src) => registers(dst) = registers(dst) * resolveValue(src)\n        case rDiv(dst, src) => registers(dst) = registers(dst) \/ resolveValue(src)\n        case rLabel(label) => \/\/ NOOP\n        case rJmp(label) => jumpIf(true, label)\n        case rCmp(x, y) => compareRegister = resolveValue(x) - resolveValue(y)\n        case rJne(label) => jumpIf(compareRegister != 0, label)\n        case rJe(label) => jumpIf(compareRegister == 0, label)\n        case rJge(label) => jumpIf(compareRegister >= 0, label)\n        case rJg(label) => jumpIf(compareRegister > 0, label)\n        case rJle(label) => jumpIf(compareRegister <= 0, label)\n        case rJl(label) => jumpIf(compareRegister < 0, label)\n        case rCall(label) => \n          ipStack.push(ip)\n          jumpIf(true, label)\n        case rRet() => ip = ipStack.pop()\n        case rMsg(msg) => \n          output.append(\n            msg.split(\",(?=([^\\']*\\'[^\\']*\\')*[^\\']*$)\")\n              .map(_.trim)\n              .map{m => \n                if (m.startsWith(\"'\")) m.drop(1).dropRight(1)\n                else registers(m).toString \n              }.mkString(\"\"))\n        case rEnd() => \n          if (output.length == 0) return None\n          else return Some(output.mkString(\"\"))\n      }\n      ip += 1\n    }\n    None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336480,"user_id":null,"body":"import scala.collection.immutable.HashMap\n\nsealed trait ComparisonResult {}\ncase object Equal extends ComparisonResult\ncase object GreaterThan extends ComparisonResult\ncase object LessThan extends ComparisonResult\n\nclass InstructionStack(var stack:Seq[AssemblyTerm[_]]) {\n  def push(instruction: AssemblyTerm[_]) = stack = stack :+ instruction\n  def pop:AssemblyTerm[_] = {\n    val item = stack.last\n    stack = stack.dropRight(1)\n    item\n  }\n}\n\nobject InstructionStack {\n  def create = new InstructionStack(Seq[AssemblyTerm[_]]())\n}\nclass Registers(var registerMap: Map[String,Int]) {\n  def get(register: String):Int = {\n    val value = registerMap(register)\n    value\n\n  }\n  def set(register: String, value: Int) = {\n    registerMap = registerMap + (register -> value)\n  }\n  def getAndUpdate(register: String, update: Int => Int) = {\n    val value = update(get(register))\n    set(register, value)\n    value\n  }\n}\n\nobject Registers {\n  def create = new Registers(new HashMap[String,Int])\n}\n\ncase class ExecutionContext(registers:Registers,\n                            instructionStack: InstructionStack,\n                            var result: Option[String],\n                            var lastComparison: ComparisonResult,\n                            var success: Boolean) {\n}\n\nobject ExecutionContext {\n  def create(program:Seq[AssemblyTerm[_]]) = ExecutionContext(\n    Registers.create,\n    InstructionStack.create,\n    None,\n    null,\n    false\n  )\n}\n\ncase class JumpCommand(label:String, call:Boolean) {}\ncase class RetCommand() {}\n\ntrait AssemblyTerm[+T] {\n  def execute(ctx:ExecutionContext):T\n}\n\ncase class IntLiteral(value:Integer) extends AssemblyTerm[Integer] {\n  override def execute(ctx:ExecutionContext): Integer = value\n}\n\ncase class StringLiteral(value:String) extends AssemblyTerm[String] {\n  override def execute(ctx: ExecutionContext): String = value\n}\n\ncase class RegisterValue(register:String) extends AssemblyTerm[Integer] {\n  override def execute(ctx: ExecutionContext): Integer = ctx.registers.get(register)\n}\n\ncase class Move(register:String, value:AssemblyTerm[Integer]) extends AssemblyTerm[Unit] {\n  override def execute(ctx:ExecutionContext): Unit = ctx.registers.set(register, value.execute(ctx))\n}\n\ncase class MathsTerm(register: String, value:AssemblyTerm[Integer], op: (Int,Int) => Int) extends AssemblyTerm[Integer] {\n  override def execute(ctx: ExecutionContext): Integer = ctx.registers.getAndUpdate(register, op(_, value.execute(ctx)))\n}\n\ncase class Comparison(a: AssemblyTerm[Integer], b:AssemblyTerm[Integer]) extends AssemblyTerm[Unit] {\n  override def execute(ctx: ExecutionContext): Unit = a.execute(ctx) - b.execute(ctx) match {\n    case  0 => ctx.lastComparison = Equal\n    case x if x < 0 => ctx.lastComparison = LessThan\n    case x if x > 0 => ctx.lastComparison = GreaterThan\n  }\n}\n\ncase class JumpIf(jumpIf:Set[ComparisonResult], target:String) extends AssemblyTerm[Option[JumpCommand]] {\n  override def execute(ctx: ExecutionContext): Option[JumpCommand] = if(jumpIf.contains(ctx.lastComparison)) {\n    Some(JumpCommand(target, false))\n  } else {\n    None\n  }\n}\n\ncase class Call(target:String, call:Boolean) extends AssemblyTerm[Option[JumpCommand]] {\n  override def execute(ctx: ExecutionContext): Option[JumpCommand] = Some(JumpCommand(target, call))\n}\n\ncase class Label(name:String) extends AssemblyTerm[Unit] {\n  override def execute(ctx: ExecutionContext): Unit = {}\n}\n\ncase class Msg(terms:Seq[AssemblyTerm[_]]) extends AssemblyTerm[Unit] {\n  override def execute(ctx: ExecutionContext): Unit = ctx.result = Some(terms.map(_.execute(ctx)).foldLeft(\"\")((a,b) => a + b))\n}\n\ncase class End() extends AssemblyTerm[Unit] {\n  override def execute(ctx: ExecutionContext): Unit = ctx.success = true\n}\n\ncase class Ret() extends AssemblyTerm[RetCommand] {\n  override def execute(ctx: ExecutionContext): RetCommand = RetCommand()\n}\n\n\n\nobject AssemblyParser {\n\n  val MoveRegex = \"^mov (.+?),\\\\s*(.+?)$\".r\n  val IncDecRegex = \"^(inc|dec) (.+?)$\".r\n  val MathRegex = \"^(add|sub|mul|div) (.+?),\\\\s*(.+?)$\".r\n  val LabelRegex = \"^(.+?):\\\\s*$\".r\n  val JumpRegex = \"^jmp (.+)$\".r\n  val CompareRegex = \"^cmp (.+?),\\\\s*(.+)$\".r\n  val ConditionalJumpRegex = \"^(jne|je|jg|jge|jl|jle) (.+)$\".r\n  val CallRegex = \"^call (.+)$\".r\n  val RetRegex = \"^ret$\".r\n  val MsgRegex = \"^msg (.+)$\".r\n  val EndRegex = \"^end$\".r\n\n  val NumericRegex = \"(?:\\\\+|-)?[0-9]+\".r\n  val RegisterRegex = \"[a-zA-Z]+\".r\n  val QuotedStringRegex = \"'(.+?)'\".r\n\n  val CommentRegex = \"^(.*?);.*$\".r\n\n  val MessageArgsRegex = \"('.+?')|((?:\\\\+|-)?[0-9]+)|([a-zA-Z]+)\".r\n\n  def parseMessageArgs(args:String):Seq[AssemblyTerm[_]] = {\n    MessageArgsRegex.findAllMatchIn(args).map(m => parseSimpleTerm(if(m.group(1) != null) {\n      m.group(1)\n    } else if(m.group(2) != null) {\n      m.group(2)\n    } else {\n      m.group(3)\n    })).toSeq\n  }\n\n  def parseSimpleIntegerTerm(str:String):AssemblyTerm[Integer] = parseSimpleTerm(str).asInstanceOf[AssemblyTerm[Integer]]\n\n  def parseSimpleTerm(str:String):AssemblyTerm[_] = {\n    str.trim match {\n      case NumericRegex() => IntLiteral(str.trim.toInt)\n      case RegisterRegex() => RegisterValue(str.trim)\n      case QuotedStringRegex(value) => StringLiteral(value)\n      case _ => throw new IllegalArgumentException(s\"cannot parse $str\")\n    }\n  }\n\n  def skipComments(str:String) = str match {\n    case CommentRegex(preComment) => preComment\n    case nonComment => nonComment\n  }\n\n  def parseTerm(str:String):AssemblyTerm[_] = {\n    str.trim match {\n      case MoveRegex(register, value) => Move(register.trim, parseSimpleIntegerTerm(value))\n      case IncDecRegex(op, register) => MathsTerm(register.trim, IntLiteral(1), op match {\n        case \"inc\" => (a,b) => a + b\n        case _ => (a,b) => a - b\n      })\n      case MathRegex(op, register, value) => MathsTerm(register.trim, parseSimpleIntegerTerm(value), op match {\n        case \"add\" => (a,b) => a + b\n        case \"sub\" => (a,b) => a - b\n        case \"mul\" => (a,b) => a * b\n        case \"div\" => (a,b) => a \/ b\n        case _ => throw new IllegalArgumentException(s\"unknown operator $op in term $str\")\n      })\n      case LabelRegex(label) => Label(label.trim)\n      case JumpRegex(label) => Call(label.trim, false)\n      case CallRegex(label) => Call(label.trim, true)\n      case CompareRegex(x, y) => Comparison(parseSimpleIntegerTerm(x), parseSimpleIntegerTerm(y))\n      case ConditionalJumpRegex(condition, label) => JumpIf(condition match {\n        case \"je\" => Set(Equal)\n        case \"jne\" => Set(GreaterThan, LessThan)\n        case \"jg\" => Set(GreaterThan)\n        case \"jge\" => Set(GreaterThan, Equal)\n        case \"jl\" => Set(LessThan)\n        case \"jle\" => Set(LessThan, Equal)\n      }, label.trim)\n      case MsgRegex(params) => Msg(parseMessageArgs(params))\n      case RetRegex() => Ret()\n      case EndRegex() => End()\n    }\n  }\n\n  def parse(input:String):Seq[AssemblyTerm[_]] = input.split(\"\n\")\n    .map(skipComments)\n    .filterNot(_.isEmpty)\n    .map(parseTerm)\n}\n\nobject AssemblerInterpreter {\n  def interpret(input: String): Option[String] = {\n    val program = AssemblyParser.parse(input)\n    val ctx = ExecutionContext.create(program)\n    var i = 0\n    while(i < program.length && !ctx.success) {\n      program(i).execute(ctx) match {\n        case Some(JumpCommand(label, call)) => {\n          program.find({\n            case Label(l) if l == label => true\n            case _ => false\n          }) match {\n            case Some(instruction) => {\n              if(call) {\n                ctx.instructionStack.push(program(i + 1))\n              }\n              i = program.indexOf(instruction)\n            }\n            case _ => throw new RuntimeException(s\"unable to find instruction $label\")\n          }\n        }\n        case RetCommand() => {\n          i = program.indexOf(ctx.instructionStack.pop)\n        }\n        case _ => i = i + 1\n      }\n    }\n    if(ctx.success) {\n      ctx.result\n    } else {\n      None\n    }\n  }\n\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336481,"user_id":null,"body":"object AssemblerInterpreter {\n    def interpret(input: String): Option[String] = {\n      val noComments = input.lines.map(x => x.indexOf(\";\") match {\n        case -1 => x\n        case y => x.take(y)\n      }).map(x => x.trim).filter(_ != \"\").toList\n      \n      def setLabels(input: List[String], n: Int = 0, acc: List[(String, Int)] = List()): Map[String, Int] = {\n        if (input.isEmpty) acc.toMap\n        else {\n          if (input(0).last == ':') setLabels(input.tail, n, acc :+ (input(0).dropRight(1), n))\n          else setLabels(input.tail, n + 1, acc)\n        }\n      }\n      \n      val labels = setLabels(noComments)\n      val noLabels = noComments.filter(x => x.last != ':')\n      \n      var registers = scala.collection.mutable.Map[String, Int]()\n      def execute(n: Int = 0, cmp: (Int, Int) = (1, 1), funcScope: List[Int] = List(), output: String = \"\"): Option[String] = {\n        \n        def valueOf(s: String): Int = {\n          if (registers.keys.exists(_ == s)) registers(s) \n          else s.toInt\n        }\n        \n        if (n >= noLabels.length) None\n        else {\n          val args = {\n            val noSpaces = noLabels(n).replaceAll(\"[,]\", \"\").split(\" \").filter(_ != \"\").toList\n            if (noSpaces(0) == \"msg\") {\n              val toParse =  noLabels(n).drop(3).trim\n              \n              def parse(s: String, scoped: Boolean = false, acc: String = \"\"): String = {\n                if (s == \"\") acc\n                else {\n                  if (scoped) {\n                    val end = s.indexOf(\"'\")\n                    val message = s.take(end + 1).dropRight(1)\n                    parse(s.drop(end + 1), !scoped, acc ++ message)\n                  }\n                  else {\n                    val end = s.indexOf(\"'\")\n                    val message = if (end == -1) s else s.take(end)\n                    val parsed = message.replaceAll(\"[,]\", \"\").split(\" \")\n                    .filter(_ != \"\").map(x => valueOf(x).toString).mkString(\" \")\n                    parse(s.drop(message.length + 1), !scoped, acc ++ parsed)\n                  }\n                }\n              }\n              \n              List(noSpaces(0), parse(toParse))\n            }\n            else noSpaces\n          }\n          args(0) match {\n            case \"mov\" => {\n              registers(args(1)) = valueOf(args(2)) \n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"inc\" => {\n              registers(args(1)) += 1\n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"dec\" => {\n              registers(args(1)) -= 1\n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"add\" => {\n              registers(args(1)) += valueOf(args(2))\n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"sub\" => {\n              registers(args(1)) -= valueOf(args(2))\n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"mul\" => {\n              registers(args(1)) *= valueOf(args(2))\n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"div\" => {\n              registers(args(1)) \/= valueOf(args(2))\n              execute(n + 1, cmp, funcScope, output)\n            }\n            case \"jmp\" => {\n              execute(labels(args(1)), cmp, funcScope, output)\n            }\n            case \"cmp\" => {\n              execute(n + 1, (valueOf(args(1)), valueOf(args(2))), funcScope, output)\n            }\n            case \"jne\" => {\n              if (cmp._1 != cmp._2) execute(labels(args(1)), cmp, funcScope, output)\n              else execute(n + 1, cmp, funcScope, output)\n            }\n            case \"je\" => {\n              if (cmp._1 == cmp._2) execute(labels(args(1)), cmp, funcScope, output)\n              else execute(n + 1, cmp, funcScope, output)\n            }\n            case \"jge\" => {\n              if (cmp._1 >= cmp._2) execute(labels(args(1)), cmp, funcScope, output)\n              else execute(n + 1, cmp, funcScope, output)\n            }\n            case \"jg\" => {\n              if (cmp._1 > cmp._2) execute(labels(args(1)), cmp, funcScope, output)\n              else execute(n + 1, cmp, funcScope, output)\n            }\n            case \"jle\" => {\n              if (cmp._1 <= cmp._2) execute(labels(args(1)), cmp, funcScope, output)\n              else execute(n + 1, cmp, funcScope, output)\n            }\n            case \"jl\" => {\n              if (cmp._1 < cmp._2) execute(labels(args(1)), cmp, funcScope, output)\n              else execute(n + 1, cmp, funcScope, output)\n            }\n            case \"call\" => {\n              execute(labels(args(1)), cmp, funcScope :+ (n + 1), output)\n            }\n            case \"ret\" => {\n              if (funcScope.length == 0) execute(n + 1, cmp, funcScope, output)\n              else execute(funcScope.last, cmp, funcScope.dropRight(1), output)\n            }\n            case \"msg\" => {\n              execute(n + 1, cmp, funcScope, output ++ args(1))\n            }\n            case \"end\" => Some(output)\n          }\n        }\n      }\n      \n      execute()\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336482,"user_id":null,"body":"import scala.collection.mutable\nimport scala.util.Try\n\nabstract class Command(line: Int, command: String) extends Product with Serializable {\n  def apply(context: Context): Option[String]\n\n  override def toString: String = s\"Line: $line, command: $command, ${this.getClass}\"\n}\n\nabstract class JumpCommand(line: Int, command: String) extends Command(line: Int, command: String)\n\nobject Int {\n  def unapply(s: String): Option[Int] = util.Try(s.toInt).toOption\n}\n\ncase class Mov(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"mov\\s*([a-zA-Z0-9_.-]+),\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x, Int(y)) => context.variable(x, y)\n      case pattern(x, y) => context.variable(x, context.variable(y))\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Inc(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"inc\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x) => context.variable(x, context.variable(x) + 1)\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Dec(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"dec\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x) => context.variable(x, context.variable(x) - 1)\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Add(line: Int, var command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"add\\s*([a-zA-Z0-9_.-]+),\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x, Int(y)) => context.variable(x, context.variable(x) + y)\n      case pattern(x, y) => context.variable(x, context.variable(x) + context.variable(y))\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Sub(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"sub\\s*([a-zA-Z0-9_.-]+),\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x, Int(y)) => context.variable(x, context.variable(x) - y)\n      case pattern(x, y) => context.variable(x, context.variable(x) - context.variable(y))\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Mul(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"mul\\s*([a-zA-Z0-9_.-]+),\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x, Int(y)) => context.variable(x, context.variable(x) * y)\n      case pattern(x, y) => context.variable(x, context.variable(x) * context.variable(y))\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Div(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"div\\s*([a-zA-Z0-9_.-]+),\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val result = command match {\n      case pattern(x, Int(y)) => context.variable(x, context.variable(x) \/ y)\n      case pattern(x, y) => context.variable(x, context.variable(x) \/ context.variable(y))\n    }\n\n    Some(result.toString)\n  }\n}\n\ncase class Cmp(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"cmp\\s*([a-zA-Z0-9_.-]+),\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    val (x, y): (Int, Int) = command match {\n      case pattern(Int(x), Int(y)) => (x, y)\n      case pattern(x, Int(y)) => (context.variable(x), y)\n      case pattern(Int(x), y) => (x, context.variable(y))\n      case pattern(x, y) => (context.variable(x), context.variable(y))\n    }\n\n    context.comparation = x.compare(y);\n    Some(context.comparation.toString)\n  }\n}\n\ncase class Label(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    Some(command)\n  }\n}\n\ncase class Jmp(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"jmp\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    command match {\n      case pattern(x) => Some(x)\n      case _ => None\n    }\n  }\n}\n\ncase class Jne(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"jne\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    if (context.comparation != 0)\n      command match {\n        case pattern(x) => Some(x)\n        case _ => None\n      }\n    else None\n  }\n}\n\ncase class Je(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"je\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    if (context.comparation == 0)\n      command match {\n        case pattern(x) => Some(x)\n        case _ => None\n      }\n    else None\n  }\n}\n\ncase class Jge(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"jge\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    if (context.comparation >= 0)\n      command match {\n        case pattern(x) => Some(x)\n        case _ => None\n      }\n    else None\n  }\n}\n\ncase class Jg(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"jg\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    if (context.comparation > 0)\n      command match {\n        case pattern(x) => Some(x)\n        case _ => None\n      }\n    else None\n  }\n}\n\ncase class Jl(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"jl\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    if (context.comparation < 0)\n      command match {\n        case pattern(x) => Some(x)\n        case _ => None\n      }\n    else None\n  }\n}\n\ncase class Jle(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"jle\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n\n    if (context.comparation <= 0)\n      command match {\n        case pattern(x) => Some(x)\n        case _ => None\n      }\n    else None\n  }\n}\n\ncase class Ret(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    None\n  }\n}\n\ncase class End(line: Int, command: String) extends JumpCommand(line, command) {\n  override def apply(context: Context): Option[String] = {\n    None\n  }\n}\n\ncase class Msg(line: Int, command: String) extends Command(line, command) {\n\n  def removeComment(str: String): String = {\n    if (str.contains(\";\")) str.substring(0, str.indexOf(\";\")).trim else str\n  }\n\n  override def apply(context: Context): Option[String] = {\n    val parts: mutable.ArrayBuffer[String] = mutable.ArrayBuffer[String]()\n\n    val messageTemplate = command.replace(\"msg\", \"\")\n    var startString = messageTemplate.indexOf(\"'\")\n    if (startString != -1 )\n      parts += messageTemplate.substring(0, startString).replace(\",\", \"\").trim\n    while (startString != -1) {\n      val endString = messageTemplate.indexOf(\"'\", startString + 1)\n      val stringPart = messageTemplate.substring(startString, endString)\n      parts += stringPart\n\n      startString = messageTemplate.indexOf(\"'\", endString + 1)\n      if (startString != -1) {\n        val variablePart = messageTemplate.substring(endString + 1, startString)\n        parts += variablePart.replace(\",\", \"\").trim\n      }\n    }\n\n    parts += removeComment(\n      messageTemplate.substring(messageTemplate.lastIndexOf(\"'\"))\n    ).replace(\"'\", \"\").replace(\",\", \"\").trim\n\n    val value = parts\n      .filter(_.nonEmpty)\n      .map {\n        case x: String if x.startsWith(\"'\") => x.replace(\"'\", \"\")\n        case x: String => context.variable(removeComment(x)).toString\n      }\n\n    val result = value.mkString(\"\")\n    context.result(result)\n    Some(result)\n  }\n}\n\ncase class Call(line: Int, command: String) extends Command(line, command) {\n  override def apply(context: Context): Option[String] = {\n    val pattern = raw\"call\\s*([a-zA-Z0-9_.-]+)[;]?.*\".r\n    command match {\n      case pattern(x) => Some(x)\n      case _ => None\n    }\n  }\n}\n\nclass Context(var _comparation: Int = 0) {\n  val variables: mutable.Map[String, Int] = mutable.Map()\n\n  def variable(name: String, value: Int): Int = {\n    variables.put(name, value)\n    value\n  }\n\n  def variable(name: String): Int = {\n    variables(name)\n  }\n\n  def comparation: Int = _comparation;\n  def comparation_= (newValue: Int): Unit = {\n    _comparation = newValue\n  }\n\n  val results: mutable.ArrayBuffer[String] = mutable.ArrayBuffer[String]()\n  def result(res: String): Unit = {\n    results += res\n  }\n}\n\nclass Parser {\n  def parse(commandsList: String): Array[Command] = {\n    var counter = 0\n    def `counter++`: Int = {counter += 1; counter}\n\n    val commands = commandsList.split(\"\\\n\").map(_.trim()).filter(_.nonEmpty).filter(!_.startsWith(\";\"))\n\n    val parsedCommands: Array[Command] = commands map {\n      case x if x.startsWith(\"mov\") => Mov(`counter++`, x)\n      case x if x.startsWith(\"inc\") => Inc(`counter++`, x)\n      case x if x.startsWith(\"dec\") => Dec(`counter++`, x)\n      case x if x.startsWith(\"add\") => Add(`counter++`, x)\n      case x if x.startsWith(\"sub\") => Sub(`counter++`, x)\n      case x if x.startsWith(\"div\") => Div(`counter++`, x)\n      case x if x.startsWith(\"mul\") => Mul(`counter++`, x)\n      case x if x.endsWith(\":\") => Label(`counter++`, x.replace(\":\", \"\"))\n      case x if x.startsWith(\"jmp\") => Jmp(`counter++`, x)\n      case x if x.startsWith(\"cmp\") => Cmp(`counter++`, x)\n      case x if x.startsWith(\"jne\") => Jne(`counter++`, x)\n      case x if x.startsWith(\"je\") => Je(`counter++`, x)\n      case x if x.startsWith(\"jge\") => Jge(`counter++`, x)\n      case x if x.startsWith(\"jg\") => Jg(`counter++`, x)\n      case x if x.startsWith(\"jle\") => Jle(`counter++`, x)\n      case x if x.startsWith(\"jl\") => Jl(`counter++`, x)\n      case x if x.startsWith(\"call\") => Call(`counter++`, x)\n      case x if x.startsWith(\"ret\") => Ret(`counter++`, x)\n      case x if x.startsWith(\"msg\") => Msg(`counter++`, x)\n      case x if x.startsWith(\"end\") => End(`counter++`, x)\n    }\n    parsedCommands\n  }\n}\n\nobject AssemblerInterpreter {\n  def findLabelNumber(commands: Seq[Command], name: String): Int = {\n    val line = commands map {\n      case x: Label if x.command == name => x.line\n      case _ => -1\n    }\n    line.find(_ != -1).getOrElse(-1)\n  }\n\n  def interpret(input: String): Option[String] = {\n    val operationNumbers: mutable.ArrayBuffer[Int] = mutable.ArrayBuffer[Int]()\n    operationNumbers += 0\n    val context = new Context()\n    val commands = new Parser().parse(input)\n    while (true) {\n      Try { commands(operationNumbers.last) } getOrElse None match {\n        case None => return None\n        case _: End =>\n          return Some(context.results.mkString)\n        case x: Call =>\n          operationNumbers(operationNumbers.length - 1) = operationNumbers(operationNumbers.length - 1) + 1\n          x.apply(context).map(x => findLabelNumber(commands.toIndexedSeq, x))\n            .foreach(x => operationNumbers += x)\n        case _: Ret =>\n          operationNumbers.remove(operationNumbers.length - 1)\n        case x: JumpCommand =>\n          x.apply(context) match {\n            case Some(x) => findLabelNumber(commands.toIndexedSeq, x) match {\n              case x if x != -1 => operationNumbers(operationNumbers.length - 1) = x\n              case _ => operationNumbers(operationNumbers.length - 1) = operationNumbers(operationNumbers.length - 1) + 1\n            }\n            case None => operationNumbers(operationNumbers.length - 1) = operationNumbers(operationNumbers.length - 1) + 1\n          }\n        case x: Command =>\n          x.apply(context)\n          operationNumbers(operationNumbers.length - 1) = operationNumbers(operationNumbers.length - 1) + 1\n      }\n    }\n    None\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336483,"user_id":null,"body":"object AssemblerInterpreter {\n  import scala.util.chaining._\n  \n    @scala.annotation.tailrec def tailRecM[A, B](a: A)(f: A => Either[A, B]): B =\n    f(a) match {\n      case Left(a1) => tailRecM(a1)(f)\n      case Right(b) => b\n    }\n\n  implicit class ListOps[A](private val list: List[A]) extends AnyVal {\n    def uncons: (Option[A], List[A]) =\n      list match {\n        case head :: tl => (Some(head), tl)\n        case _ => (None, Nil)\n      }\n  }\n\n  implicit class StringOps(private val string: String) extends AnyVal {\n    def asReg: Either[String, Int] = string.toIntOption.toRight(string)\n  }\n  \n  sealed trait Cmd extends Product with Serializable\n\n  type RegOr = Either[String, Int]\n  object Cmd {\n\n    def of(string: String): Option[Cmd] =\n      if (string.startsWith(\"msg\")) Some(Msg(string.drop(3).dropWhile(_ == ' ')))\n      else\n        string.split(\"\\\\s+\").toList match {\n          case \"jmp\" :: label :: _ => Some(Jmp(label))\n          case \"call\" :: label :: _ => Some(Call(label))\n          case \"je\" :: label :: _ => Some(Check(label, _ == 0))\n          case \"jne\" :: label :: _ => Some(Check(label, _ != 0))\n          case \"jge\" :: label :: _ => Some(Check(label, _ >= 0))\n          case \"jg\" :: label :: _ => Some(Check(label, _ > 0))\n          case \"jl\" :: label :: _ => Some(Check(label, _ < 0))\n          case \"jle\" :: label :: _ => Some(Check(label, _ <= 0))\n          case \"mov\" :: s\"$reg,\" :: value :: _ => Some(Mov(reg, value.asReg))\n          case \"cmp\" :: s\"$valuea,\" :: valueb :: _ => Some(Cmp(valuea.asReg, valueb.asReg))\n          case \"inc\" :: reg :: _ => Some(Mapping(reg, Right(1), _ + _))\n          case \"dec\" :: reg :: _ => Some(Mapping(reg, Right(1), _ - _))\n          case \"add\" :: s\"$reg,\" :: valueb :: _ => Some(Mapping(reg, valueb.asReg, _ + _))\n          case \"sub\" :: s\"$reg,\" :: valueb :: _ => Some(Mapping(reg, valueb.asReg, _ - _))\n          case \"mul\" :: s\"$reg,\" :: valueb :: _ => Some(Mapping(reg, valueb.asReg, _ * _))\n          case \"div\" :: s\"$reg,\" :: valueb :: _ => Some(Mapping(reg, valueb.asReg, _ \/ _))\n          case \"ret\" :: _ => Some(Ret)\n          case \"end\" :: _ => Some(End)\n          case _ => None\n        }\n\n    final case class Mov(reg: String, regOr: RegOr) extends Cmd\n    final case class Cmp(regOr1: RegOr, regOr2: RegOr) extends Cmd\n    final case class Jmp(label: String) extends Cmd\n    final case class Call(label: String) extends Cmd\n    final case object Ret extends Cmd\n    final case object End extends Cmd\n    final case class Msg(template: String) extends Cmd\n    final case class Mapping(reg: String, regOr: RegOr, f: (Int, Int) => Int) extends Cmd\n    final case class Check(label: String, p: Int => Boolean) extends Cmd\n  }\n\n  def asCmds(list: List[String]) = list.flatMap(Cmd.of)\n\n  final case class State(output: Option[String] = None, regs: Map[String, Int] = Map.empty, comp: Option[Boolean])\n\n  def splitted(input: String) = input.split(\"\\\n\").toList\n\n  def splitlogic(input: List[String]) = input\n    .map(_.pipe(s => s.indexOf(\";\").pipe(idx => if (idx != -1) s.take(idx) else s)).trim)\n    .filter(_ != \"\")\n    .collect {\n      case s @ s\"msg$_\" => s\n      case s => s.replaceAll(\"\\\\s+\", \" \")\n    }\n    .span(s => !s.endsWith(\":\"))\n\n  def dropState[T](state: Option[(String, List[String])], acc: List[(String, List[T])])(f: List[String] => List[T]) =\n    state.fold(acc) { case (name, cmds) => (name, f(cmds.reverse)) :: acc }\n\n  def splitfn[T](input: List[String])(f: List[String] => List[T]) = tailRecM(\n    (input.dropWhile(s => !s.endsWith(\":\")), Option.empty[(String, List[String])], List.empty[(String, List[T])])\n  ) { case (rest, state, acc) =>\n    rest match {\n      case s\"$fname:\" :: next =>\n        Left((next, Some((fname, List.empty)), dropState(state, acc)(f)))\n      case cmd :: next =>\n        Left((next, state.map(tp => tp.copy(_2 = cmd :: tp._2)), acc))\n      case Nil => Right(dropState(state, acc)(f).toMap)\n    }\n  }\n  \n    def interpret(input: String): Option[String] = {\n    val splitte = splitted(input)\n    val (main, rest) = splitlogic(splitte)\n\n    val mainLogic = asCmds(main)\n\n    case class State(\n      cmp: Option[Int] = None,\n      out: Option[String] = None,\n      regs: Map[String, Int] = Map.empty,\n      stack: List[(String, List[Cmd])] = Nil,\n      hasRet: Boolean = false\n    )\n\n    val routinesMap = splitfn(rest)(_.flatMap(Cmd.of))\n\n    tailRecM(State(stack = List((\"main\", mainLogic)))) { state =>\n      import Cmd._\n      import state._\n      state.stack match {\n        case Nil => Right(None)\n        case logic :: stackRest =>\n          logic match {\n            case (_, Nil) => if (hasRet) Left(state.copy(stack = stackRest)) else Right(None)\n            case _ if hasRet => Left(state.copy(hasRet = false))\n            case (thread, cmd :: restT) =>\n              val rest = (thread, restT)\n              cmd match {\n                case End => Right(state.out)\n                case Ret => Left(state.copy(stack = stackRest, hasRet =  true))\n                case Jmp(sub) => Left(state.copy(stack = (sub, routinesMap.getOrElse(sub, Nil)) :: stackRest))\n                case Call(sub) => Left(state.copy(stack = (sub, routinesMap.getOrElse(sub, Nil)) :: rest :: stackRest))\n                case Mov(reg, regOr) =>\n                  val newRegValue = regOr match {\n                    case Left(value) => regs.get(value).fold(regs)(regs.updated(reg, _))\n                    case Right(value) => regs.updated(reg, value)\n                  }\n                  Left(state.copy(regs = newRegValue, stack = rest :: stackRest))\n\n                case Mapping(reg, regOr, f) =>\n                  val newRegValue = regOr match {\n                    case Left(value) => regs.get(value).fold(regs)(v => regs.updatedWith(reg)(_.map(f(_, v))))\n                    case Right(value) => regs.updatedWith(reg)(_.map(f(_, value)))\n                  }\n                  Left(state.copy(regs = newRegValue, stack = rest :: stackRest))\n                case Cmp(regOr1, regOr2) =>\n                  (regOr1, regOr2) match {\n                    case (Right(a), Right(b)) => Left(state.copy(cmp = Some(a.compare(b)), stack = rest :: stackRest))\n                    case (Right(a), Left(r)) =>\n                      regs.get(r).map(b => state.copy(cmp = Some(a.compare(b)), stack = rest :: stackRest)).toLeft(None)\n                    case (Left(l), Right(b)) =>\n                      regs.get(l).map(a => state.copy(cmp = Some(a.compare(b)), stack = rest :: stackRest)).toLeft(None)\n                    case (Left(l), Left(r)) =>\n                      regs\n                        .get(l)\n                        .flatMap(a => regs.get(r).map((a, _)))\n                        .map { case (a, b) => state.copy(cmp = Some(a.compare(b)), stack = rest :: stackRest) }\n                        .toLeft(None)\n                  }\n\n                case Check(sub, pred) =>\n                  cmp\n                    .map { cmp =>\n                      if (pred(cmp)) state.copy(cmp = None, stack = (sub, routinesMap.getOrElse(sub, Nil)) :: stackRest)\n                      else\n                        state.copy(cmp = None, stack = rest :: stackRest)\n                    }\n                    .toLeft(None)\n                case Msg(template) =>\n                  val out = tailRecM((template, \"\")) { case (str, acc) =>\n                    if (str.isEmpty) Right(Some(acc))\n                    else {\n                      val (run, string) = str.span(_ != '\\'')\n                      val (t, rest) = string.tail.span(_ != '\\'')\n                      (if (run.isEmpty) Some(\"\") else run.takeWhile(_ != ',').asReg match {\n                        case Left(value) => regs.get(value).map(_.toString)\n                        case Right(value) => Some(value.toString)\n                      }) match {\n                        case Some(v) => Left((rest.drop(3), acc + v + t))\n                        case _ => Right(None)\n                      }\n                    }\n                  }\n                  Left(state.copy(out = out, stack = rest :: stackRest))\n\n              }\n          }\n      }\n    }\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336484,"user_id":null,"body":"import Interpreter._\n\nimport scala.collection.mutable\nimport scala.collection.mutable.ListBuffer\nimport scala.util.control.Breaks.{break, breakable}\n\n\nclass Interpreter(\n  var variables: mutable.Map[String, Int] = mutable.Map.empty[String, Int],\n  var instructions: ListBuffer[Instruction] = ListBuffer.empty[Instruction]\n) {\n  var nextInstruction = 0\n  var functionIndexes = Map.empty[String, Int] \/\/ label -> index\n  var e = 0\n  var output: Option[String] = Option.empty[String]\n  val stack: mutable.Stack[Int] = mutable.Stack.empty[Int]\n\n  abstract class Shift(instructionOffset: => Int) extends Instruction {\n    def getNextInstruction: Int = nextInstruction + instructionOffset\n  }\n\n  abstract class Operation extends Shift(1)\n\n  case class msg(messagesAndRegs: String*) extends Operation {\n    override def apply: Unit =\n      output = Option { output.getOrElse(\"\") +\n        messagesAndRegs\n          .map(messageOrReg => variables\n            .getOrElse(messageOrReg, messageOrReg)\n          ).mkString\n      }\n  }\n\n  case class mov(reg: String, value: String) extends Operation {\n    override def apply: Unit =\n      if (variables.contains(reg)) variables(reg) = parseValue(value)\n      else variables += reg -> parseValue(value)\n  }\n\n  class inc(reg: String) extends add(reg, 1)\n\n  class dec(reg: String) extends add(reg, -1)\n\n  class add(reg: String, value: => Int) extends Operation {\n    def this(reg: String, regOrValue: String) =\n      this(reg, parseValue(regOrValue))\n    override def apply: Unit =\n      variables(reg) += value\n  }\n\n  class sub(reg: String, value: String) extends add(reg, -parseValue(value))\n\n  case class mul(reg: String, value: String) extends Operation {\n    override def apply: Unit = variables(reg) *= parseValue(value)\n  }\n\n  case class div(reg: String, value: String) extends Operation {\n    override def apply: Unit = variables(reg) \/= parseValue(value)\n  }\n  case class cmp(value1: String, value2: String) extends Operation {\n    override def apply: Unit = e = parseValue(value1) compare parseValue(value2)\n  }\n\n  class jump(\n    var p: () => Boolean,\n    _nextInstruction: => Int\n  ) extends Operation {\n    override def apply: Unit = {}\n    override def getNextInstruction: Int =\n      if (p()) _nextInstruction\n      else super.getNextInstruction\n  }\n\n  abstract class jumpToLabel(p: () => Boolean, label: String)\n    extends jump(p, functionIndexes(label))\n\n  case class jmp(label: String) extends jumpToLabel(() => true, label)\n  case class jne(label: String) extends jumpToLabel(() => e != 0, label)\n  case class je (label: String) extends jumpToLabel(() => e == 0, label)\n  case class jge(label: String) extends jumpToLabel(() => e == 1 || e == 0, label)\n  case class jg (label: String) extends jumpToLabel(() => e == 1, label)\n  case class jle(label: String) extends jumpToLabel(() => e == -1 || e == 0, label)\n  case class jl (label: String) extends jumpToLabel(() => e == -1, label)\n\n  case class call(label: String) extends Instruction {\n    override def apply: Unit = stack.append(nextInstruction + 1)\n    override def getNextInstruction: Int = functionIndexes(label)\n  }\n\n  def define(label: String, functionInstructions: List[Instruction]): Unit = {\n    val index = instructions.length\n    instructions.appendAll(functionInstructions)\n    functionIndexes += label -> index\n  }\n\n  def parseValue(value: String): Int =\n    value.toIntOption.getOrElse(variables(value))\n\n  case class jnz(reg: String, value: String)\n    extends jump(() => parseValue(reg) != 0, parseValue(value))\n\n  class ret extends Instruction {\n    private def next = stack.pop\n    override def apply: Unit = {}\n    override def getNextInstruction: Int = next\n  }\n\n  class end extends Operation {\n    override def apply: Unit = break\n  }\n\n  val instructionTypes = List(\n    classOf[mov], classOf[msg],\n    classOf[inc], classOf[dec],\n    classOf[sub], classOf[add],\n    classOf[div], classOf[mul],\n    classOf[jnz], classOf[jmp], classOf[call],\n    classOf[cmp],\n    classOf[je], classOf[jne],\n    classOf[jge], classOf[jg],\n    classOf[jle], classOf[jl],\n    classOf[ret], classOf[end]\n  )\n\n  def run: Interpreter = {\n    nextInstruction = 0\n    breakable {\n      while (true) {\n        val instruction = instructions(nextInstruction)\n        instruction.apply\n        nextInstruction = instruction.getNextInstruction\n      }\n    }\n    this\n  }\n}\n\nobject Interpreter {\n\n  trait Instruction {\n    def apply: Unit\n    def getNextInstruction: Int\n  }\n\n  def parseArguments(args: String): List[String] = {\n      val buffer = new mutable.StringBuilder()\n      val parsedArgs = new ListBuffer[String]\n      var waitString = false\n\n      def appendArg: Unit = {\n        if (buffer.nonEmpty) parsedArgs.append(buffer.toString)\n        buffer.clear\n      }\n\n      args\n        .foreach {\n          case '\\'' => waitString = !waitString\n          case ';' =>\n            appendArg\n            return parsedArgs.toList\n          case ' ' | ',' if !waitString => appendArg\n          case c => buffer.append(c)\n        }\n      appendArg\n      parsedArgs.toList\n    }\n\n    def parseProgram(program: String): Interpreter = {\n      val interpreter = new Interpreter()\n\n      val instructionTypeByName = interpreter\n        .instructionTypes\n        .map(instructionType => (instructionType.getSimpleName, instructionType))\n        .toMap\n\n      val stringInstructions = program\n        .split(\"\n\")\n        .toList\n        .map(parseArguments)\n        .filter(_.nonEmpty)\n\n      val instructionBuffer = ListBuffer.empty[Instruction]\n      var prevLabel = \"@start\"\n\n      stringInstructions\n        .foreach {\n          case s\"$label:\" :: _ =>\n            interpreter.define(prevLabel, instructionBuffer.toList)\n            prevLabel = label\n            instructionBuffer.clear\n\n          case List(\"msg\", args@_*) => instructionBuffer.append(interpreter.msg(args: _*))\n          case List(instructionName, args@_*)\n            if instructionTypeByName contains instructionName =>\n              val argClasses: Seq[Class[_]] = classOf[Interpreter] +: args.map(_.getClass)\n              val constructorArgs = interpreter +: args\n\n              instructionBuffer.append {\n                instructionTypeByName(instructionName)\n                  .getConstructor(argClasses: _*)\n                  .newInstance(constructorArgs: _*)\n              }\n\n          case line => throw new IllegalArgumentException(s\"Cannot parse line: $line\")\n        }\n\n      interpreter.define(prevLabel, instructionBuffer.toList)\n      interpreter\n    }\n}\n\nobject AssemblerInterpreter {\n  def interpret(input: String): Option[String] = {\n    val interpreter = parseProgram(input)\n    \n    try interpreter.run\n    catch { case _: Throwable => \n      return Option.empty[String]\n    }\n    \n    interpreter.output\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336485,"user_id":null,"body":"object AssemblerInterpreter {\n  \n  import Program._\n  \n  def interpret(input: String): Option[String] = {\n    def untilErrorOrEnd(program: Program): Either[String, String] =\n      program.executeCurrentInstruction.\n        flatMap(pgm => pgm.endReached.\n          flatMap(atEnd => if (atEnd) Right(pgm.output) else untilErrorOrEnd(pgm)))\n\n    untilErrorOrEnd(Program(input.split(\"\n\").toIndexedSeq)) match {\n      case Left(error) =>\n        println(error)\n        None\n      case Right(output) =>\n        Some(output)\n    }\n  }\n}\n\ncase class Program(instructions: IndexedSeq[String],\n                   instructionPointer: Int = 0,\n                   callStack: List[Int] = List.empty,\n                   cmpResult: Option[Int] = None,\n                   registers: Map[String,Int] = Map(),\n                   output: String = \"\") {\n  import Program._\n\n  private val END: String = \"end\"\n\n  def currentInstruction: Either[String, String] = instructions.lift(instructionPointer) match {\n    case Some(instruction) => Right(instruction)\n    case None => Left(\"Abnormal end:Instruction pointer ran out of program!\")\n  }\n\n  def endReached: Either[String, Boolean] = currentInstruction.map(_ == END)\n\n  def executeCurrentInstruction: Either[String, Program] =\n    currentInstruction.flatMap(execute)\n\n  def indexOf(label: String): Either[String, Int] = {\n    val index = instructions.indexWhere(_.startsWith(label + \":\"))\n    if (index < 0) Left(s\"Label $label not found!\") else Right(index)\n  }\n\n  def call(label: String): Either[String, Program] =\n    indexOf(label).map(index => this.copy(instructionPointer = index, callStack = instructionPointer :: callStack))\n\n  def ret(): Either[String, Program] =\n    (callStack.headOption match {\n      case Some(index) => Right(this.copy(instructionPointer = index, callStack = callStack.tail))\n      case None =>\n        println(\"ret: call stack empty - continue with next instruction after ret!\")\n        Right(this)\n    }).map(next)\n\n  def mov(value: String, toReg: String): Either[String, Program] =\n    getInt(registers, value).map(i => this.copy(registers = update(registers, toReg, i))).map(next)\n\n  def regOp(reg: String, value: String, op: (Int, Int) => Int): Either[String, Program] =\n    for {x <- getIntFrom(registers, reg)\n         y <- getInt(registers, value)}\n    yield next(this.copy(registers = update(registers, reg, op(x, y))))\n\n  def cmp(valueX: String, valueY: String): Either[String, Program] =\n    for {\n      x <- getInt(registers, valueX)\n      y <- getInt(registers, valueY)\n    } yield next(this.copy(cmpResult = Some(x.compare(y))))\n\n  def jmp(label: String): Either[String, Program] =\n    indexOf(label).map(index => this.copy(instructionPointer = index))\n\n  def compareAndJump(p: Int => Boolean)(label: String): Either[String, Program] =\n    cmpResult.\n      map(c => if (p(c)) jmp(label) else Right(next(this))).\n      getOrElse(Left(\"no previous cmp before conditional jump\"))\n\n  def execute(instruction: String): Either[String, Program] = {\n    val labelPattern = \"([A-Za-z]+\\\\S*): ?(.*)?\".r\n    val retPattern = \"ret( .*)?\".r\n\n    instruction match {\n      case END =>\n        println(\"End of Program reached!\")\n        Right(this)\n      case labelPattern(_, inst) =>\n        if (inst.isEmpty) Right(next(this))\n        else execute(inst)\n      case s\"call $label\" =>\n        call(label)\n      case retPattern(_) =>\n        ret()\n      case s\"mov $toReg, $y\" =>\n        mov(y, toReg)\n      case s\"div $reg, $y\" =>\n        regOp(reg, y, _ \/ _)\n      case s\"mul $reg, $y\" =>\n        regOp(reg, y, _ * _)\n      case s\"add $reg, $y\" =>\n        regOp(reg, y, _ + _)\n      case s\"sub $reg, $y\" =>\n        regOp(reg, y, _ - _)\n      case s\"inc $reg\" =>\n        regOp(reg, \"1\", _ + _)\n      case s\"dec $reg\" =>\n        regOp(reg, \"1\", _ - _)\n      case s\"cmp $x, $y\" =>\n        cmp(x, y)\n      case s\"jmp $label\" =>\n        jmp(label)\n      case s\"jne $label\" =>\n        compareAndJump(_ != 0)(label)\n      case s\"je $label\" =>\n        compareAndJump(_ == 0)(label)\n      case s\"jge $label\" =>\n        compareAndJump(_ >= 0)(label)\n      case s\"jg $label\" =>\n        compareAndJump(_ > 0)(label)\n      case s\"jle $label\" =>\n        compareAndJump(_ <= 0)(label)\n      case s\"jl $label\" =>\n        compareAndJump(_ < 0)(label)\n      case s\"msg $text\" =>\n        import MessageHandling._\n        constructMessage(registers, text).map(output => this.copy(output = output)).map(next)\n      case _ => Left(s\"ERROR: instruction $instruction not yet implemented!\")\n    }\n  }\n}\n\nobject Program {\n  import InstructionHandling._\n  \n  type Registers = Map[String, Int]\n  type Error = String\n  type Output = String\n  type Instructions = IndexedSeq[String]\n\n  def apply(lines: Seq[String]): Program = {\n    val instructions = (for (line <- lines; cleaned <- cleanLine(line)) yield cleaned).toIndexedSeq\n    new Program(instructions = instructions)\n  }\n\n  def next(pgm: Program): Program = pgm.copy(instructionPointer = pgm.instructionPointer + 1)\n\n  private def getIntFrom(registers: Registers, reg: String): Either[String, Int] =\n    registers.get(reg) match {\n      case Some(x) => Right(x)\n      case None => Left(s\"register '$reg' does not exist!\")\n    }\n\n  private def getIntFrom(string: String): Either[String, Int] =\n    string.toIntOption match {\n      case Some(y) => Right(y)\n      case None => Left(s\"value '$string' is not an integer!\")\n    }\n\n  private def getInt(registers: Registers, value: String): Either[String, Int] =\n    getIntFrom(value).orElse(getIntFrom(registers, value))\n\n  private def update(registers: Registers, reg: String, value: Int): Registers =\n    registers.concat(Map(reg -> value))\n}\n\nimport scala.annotation.tailrec\n\nobject MessageHandling {\n  object MessagePart extends Enumeration {\n    val Text, Number, Register, Invalid = Value\n  }\n\n  import MessagePart._\n\n  def parseMessage(msg: String): (MessagePart.Value, String, Option[String]) = {\n    import MessagePart._\n\n    val tail = \"(,\\\\s(.*))?\"\n    val startsWithString = (\"'(.+?)'\" + tail).r\n    val startsWithInt = (\"(\\\\d+)\" + tail).r\n    val startsWithName = (\"([A-Za-z]+\\\\S*)\" + tail).r\n    msg match {\n      case startsWithString(text, _, tail) => (Text, text, Option(tail))\n      case startsWithInt(number, _, tail) => (Number, number, Option(tail))\n      case startsWithName(reg, _, tail) => (Register, reg, Option(tail))\n      case _ => (Invalid, \"\", None)\n    }\n  }\n\n  @tailrec\n  def constructMessage(registers: Map[String, Int], text: String, acc: String = \"\"): Either[String, String] = {\n    if (text.isEmpty) Right(acc)\n    else parseMessage(text) match {\n      case (Text, text, tail) => constructMessage(registers, tail.getOrElse(\"\"), acc + text)\n      case (Register, reg, tail) =>\n        if (registers.contains(reg)) constructMessage(registers, tail.getOrElse(\"\"), acc + registers(reg))\n        else Left(s\"$reg ist not a register\")\n      case (Number, number, tail) => constructMessage(registers, tail.getOrElse(\"\"), acc + number.toInt)\n      case _ => Left(s\"cannot construct output from $text\")\n    }\n  }\n\n}\n\nobject InstructionHandling {\n  def cleanLine(line: String): Option[String] = line.trim match {\n    case s\";$_\" => None\n    case \"\" => None\n    case s\"$instruction;$_\" => Some(compressBlanks(instruction.trim))\n    case instruction => Some(compressBlanks(instruction))\n  }\n\n  def compressBlanks(line: String): String = {\n    if (line.contains('\\'')) {\n      val firstIndex = line.indexOf('\\'')\n      val lastIndex = line.lastIndexOf('\\'')\n      compressBlanks(line.substring(0, firstIndex)) + \" \" + line.slice(firstIndex, lastIndex + 1) + compressBlanks(line.substring(lastIndex + 1))\n    } else line.split(\"\\\\s+\").mkString(\" \")\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336486,"user_id":null,"body":"import scala.collection.mutable\n\nobject AssemblerInterpreter {\n  val tokenizer = \"(\\\\w:?|'.*?')+\".r\n\n  def interpret(input: String): Option[String] = {\n    val regs = mutable.Map.empty[String, Int]\n    val commands =\n      input.split(\"\n\").map(_.trim).filterNot(c => c.isEmpty || c.startsWith(\";\")).map(_.replaceAll(\";.*\", \"\")).map(tokenizer.findAllIn(_).toList)\n    val labels  = commands.zipWithIndex.collect { case (s\"$l:\" :: Nil, i) => (l, i) }.toMap\n    val stack   = mutable.Stack.empty[Int]\n    var cursor  = 0\n    var message = \"\"\n\n    def v(x: String)                 = x.toIntOption.getOrElse(regs(x))\n    def jmpIf(p: Boolean)(l: String) = if (p) cursor = labels(l) - 1\n\n    var end = false\n    while (cursor < commands.length && !end) {\n      commands(cursor) match {\n        case \"mov\" :: x :: y :: Nil => regs(x) = v(y)\n        case \"inc\" :: x :: Nil      => regs(x) += 1\n        case \"dec\" :: x :: Nil      => regs(x) -= 1\n        case \"add\" :: x :: y :: Nil => regs(x) += v(y)\n        case \"sub\" :: x :: y :: Nil => regs(x) -= v(y)\n        case \"mul\" :: x :: y :: Nil => regs(x) *= v(y)\n        case \"div\" :: x :: y :: Nil => regs(x) \/= v(y)\n        case s\"$_:\" :: Nil          => ()\n        case \"cmp\" :: x :: y :: Nil => regs(\"cmp\") = v(x) compare v(y)\n        case \"jmp\" :: l :: Nil      => cursor = labels(l) - 1\n        case \"jne\" :: l :: Nil      => jmpIf(regs(\"cmp\") != 0)(l)\n        case \"je\" :: l :: Nil       => jmpIf(regs(\"cmp\") == 0)(l)\n        case \"jge\" :: l :: Nil      => jmpIf(regs(\"cmp\") >= 0)(l)\n        case \"jg\" :: l :: Nil       => jmpIf(regs(\"cmp\") == 1)(l)\n        case \"jle\" :: l :: Nil      => jmpIf(regs(\"cmp\") <= 0)(l)\n        case \"jl\" :: l :: Nil       => jmpIf(regs(\"cmp\") == -1)(l)\n        case \"call\" :: l :: Nil =>\n          stack.push(cursor)\n          cursor = labels(l) - 1\n        case \"ret\" :: Nil  => cursor = stack.pop()\n        case \"msg\" :: args => message = args.map(e => if (e.length == 1) v(e).toString else e.tail.init).mkString\n        case \"end\" :: Nil  => end = true\n      }\n      cursor += 1\n    }\n    Option.when(end)(message)\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59568be9cc15b57637000054":[{"id":336487,"user_id":null,"body":"object Immortal {\n  \/**\n    * set true to enable debug\n    *\/\n  val debug = true\n  \n  def larger_pow(x: BigInt, t: BigInt = 1): BigInt = {\n    if (t < x) return larger_pow(x, t << 1)\n    return t\n  }\n\n  def range_sum(l: BigInt, r: BigInt): BigInt = {\n    return ((l + r) * (r - l + 1) \/ 2)\n  }\n\n  def elder_age(mA: BigInt, nA: BigInt, l: BigInt, t: BigInt): Long = {\n    var n = nA\n    var m = mA\n    if (m == 0 || n == 0) return 0\n    if (m > n) {\n      val tmp = m\n      m = n\n      n = tmp\n    }\n    \n    var ln = larger_pow(n)\n    var lm = larger_pow(m)\n    if (l > ln) return 0\n\n    if (lm == ln) return ((range_sum(1, ln - l - 1) * (m + n - ln) + elder_age(ln - n, lm - m, l, t)).mod(t)).toLong\n    \n    if (lm < ln) {\n        lm = (ln \/ 2)\n        var tmp = range_sum(1, ln - l - 1) * m - (ln - n) * range_sum((lm - l).max(0), ln - l - 1)\n        if (l <= lm) tmp += (lm - l) * (lm - m) * (ln - n) + elder_age(lm - m, ln - n, 0, t)\n        else tmp += elder_age(lm - m, ln - n, l - lm, t)\n        return tmp.mod(t).toLong\n     }\n     \n     return 0\n  }\n}","lang_id":49,"is_control":0,"status":"sample_passed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336488,"user_id":53,"body":"import scala.math._\n\nobject Immortal {\n\n  val debug = false\n\n  def elder_age(m: Long, n: Long, l: Long, t: Long): Long = {\n    val a = min(m, n)\n    val b = max(m, n)\n    val k = 1L << floor(log(b) \/ log(2)).toInt\n    val r = min(k, a)\n    val p = max(0, -l)\n    val q = max(0, k - l - 1)\n    var x = q - p + 1\n    var y = p + q\n    if (x % 2 > 0) y = y \/ 2 else if (y % 2 > 0) x = x \/ 2\n    val w = if (y <= 0) 0 else ((y % t) * (x % t)) % t\n    var s = ((w % t) * (r % t)) % t\n    s += (if (b > k) elder_age(b - k, r, l - k, t) else 0)\n    s += (if (a > r) elder_age(k, a - r, l - r, t) else 0)\n    s += (if (a > r && b > k) elder_age(b - k, a - r, l, t) else 0)\n    return s % t\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336489,"user_id":null,"body":"import java.math.BigDecimal\n\nobject Immortal {\n  \/**\n    * set true to enable debug\n    *\/\n  val debug = false\n\n  def elder_age(m: Long, n: Long, l: Long, t: Long): Long = if (m <= 0 || n <= 0) 0\n  else if (m < n) elder_age(n, m, l, t)\n  else {\n    val minRecM = biggestPowOfTwo(m)\n    ((calcSum(l, minRecM, t) * (Math.min(n, minRecM) % t)) % t + elder_age(m - minRecM, n - minRecM, l, t) % t + elder_age(minRecM, n - minRecM, l - minRecM, t) % t + elder_age(m - minRecM, Math.min(n, minRecM), l - minRecM, t) % t) % t\n  }\n\n  def biggestPowOfTwo(n: Long): Long = if (n == 1) 1\n  else 2 * biggestPowOfTwo(n \/ 2)\n\n  def calcSum(l: Long, m: Long, t: Long): Long = if (l > m) 0\n  else new BigDecimal((Math.abs(Math.min(l, 0)) + m - 1 - l) % (2 * t)).multiply(new BigDecimal((m - l - Math.abs(Math.min(l, 0))) % (2 * t))).divide(new BigDecimal(2)).divideAndRemainder(new BigDecimal(t))(1).longValue\n  \n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336490,"user_id":null,"body":"object Immortal {\n    \/**\n     * set true to enable debug\n     *\/\n    val debug = false\n\n    def process(m0: Long, n0: Long, l: Long, t:Long): Long = {\n      val (mm, nn) = if(m0>=n0) (m0,n0) else (n0,m0)\n\n      if(mm<100L){\n        (0L until mm).flatMap(i=>(0L until nn).map(j=>{\n          Math.max((i ^ j)-l, 0L)\n        })).sum%t\n      }\n      else if(nn==1L) {\n        if((mm-l)%2L==0L) (((Math.max(mm-l, 0L)\/2L)%t) *(Math.max(mm-l-1L, 0L)%t))%t\n        else (((Math.max(mm-l-1L, 0L)\/2L)%t) *(Math.max(mm-l, 0L)%t))%t\n      }\n      else{\n        val p = Math.log(mm)\/Math.log(2L)\n        val m1 = (if(p.toLong==p) mm else Math.pow(2L, p.toLong)).toLong\n\n        val l0 = Math.max(0L, l-m1)\n        val l1 =  Math.max(0L, m1-l)\n        val l2 = Math.max(0L, m1-l0)\n        val l2i = Math.max(0L, m1-l0-1L)\n\n        val s = if(l1%2L==0L) (((l1\/2)%t)*(Math.max(0L, m1-l-1L)%t))%t else (((Math.max(0L, m1-l-1L)\/2)%t)*(l1%t))%t\n\n        if(m1<mm) {\n          if(nn<=m1){\n            ((((nn%t)*s)%t)+(process(mm-m1, nn, l0, t)+((((nn%t)*((mm-m1)%t))%t)*(l1%t))%t)%t)%t\n          }\n          else ((((((m1%t)*s)%t)+((((({\n            if(l2%2L==0L) (l2i%t) *((l2\/2L)%t)\n            else ((l2i\/2L)%t)*(l2%t)\n          }%t)+(((m1%t) *(l1%t))%t))%t)*(((nn-m1)+(mm-m1))%t))%t))%t)+process(mm-m1, nn-m1, l, t))%t\n        }\n        else if(nn<=m1) ((nn%t)*s)%t\n        else ((((m1%t)*s)%t)+((((({\n          if(l2%2L==0L) (l2i%t) *((l2\/2L)%t)\n          else ((l2i\/2L)%t)*(l2%t)\n        }%t)+((m1 *l1)%t))%t)*((nn-m1)%t))%t))%t\n      }\n    }\n\n    def elder_age(m: Long, n: Long, l: Long, t: Long): Long = {\n      process(m, n, l, t)%t\n    }\n  }","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336491,"user_id":null,"body":"object Immortal {\n  \/**\n    * set true to enable debug\n    *\/\n  val debug = true\n  val limit = 17179869184L\n\n  def process(m0: Long, n0: Long, l: Long, t:Long): Long = {\n      val (mm, nn) = if(m0>=n0) (m0,n0) else (n0,m0)\n\n      if(mm<100L){\n        (0L until mm).flatMap(i=>(0L until nn).map(j=>{\n          Math.max((i ^ j)-l, 0L)\n        })).sum%t\n      }\n      else if(nn==1L) {\n        if((mm-l)%2L==0L) (((Math.max(mm-l, 0L)\/2L)%t) *(Math.max(mm-l-1L, 0L)%t))%t\n        else (((Math.max(mm-l-1L, 0L)\/2L)%t) *(Math.max(mm-l, 0L)%t))%t\n      }\n      else{\n        val p = Math.log(mm)\/Math.log(2L)\n        val m1 = (if(p.toLong==p) mm else Math.pow(2L, p.toLong)).toLong\n\n        val l0 = Math.max(0L, l-m1)\n        val l1 =  Math.max(0L, m1-l)\n        val l1i =  Math.max(0L, m1-l-1L)\n        val l2 = Math.max(0L, m1-l0)\n        val l2i = Math.max(0L, m1-l0-1L)\n\n        val s = if(l1%2L==0L) (((l1\/2)%t)*(l1i%t))%t else (((l1i\/2)%t)*(l1%t))%t\n\n        if(m1<mm) {\n          if(nn<=m1){\n            ((((nn%t)*s)%t)+(process(mm-m1, nn, l0, t)+((((nn%t)*((mm-m1)%t))%t)*(l1%t))%t)%t)%t\n          }\n          else ((((((m1%t)*s)%t)+((((({\n            if(l2%2L==0L) (l2i%t) *((l2\/2L)%t)\n            else ((l2i\/2L)%t)*(l2%t)\n          }%t)+(((m1%t) *(l1%t))%t))%t)*(((nn-m1)+(mm-m1))%t))%t))%t)+process(mm-m1, nn-m1, l, t))%t\n        }\n        else if(nn<=m1) ((nn%t)*s)%t\n        else ((((m1%t)*s)%t)+((((({\n          if(l2%2L==0L) (l2i%t) *((l2\/2L)%t)\n          else ((l2i\/2L)%t)*(l2%t)\n        }%t)+((m1 *l1)%t))%t)*((nn-m1)%t))%t))%t\n      }\n    }\n\n    def elder_age(m: Long, n: Long, l: Long, t: Long): Long = {\n      process(m, n, l, t)%t\n    }\n  }","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336492,"user_id":null,"body":"object Immortal {\n\n  \/**\n    * set true to enable debug\n    *\/\n  val debug = false\n\n  \/**\n    *              |         length          |   rightWidth   |\n    *            --- -- -- -- -- -- -- -- -- - -- -- -- -- -- ---\n    *              | 00 01 02 03 04 05 06 07 | 08 09 10 11 12 |\n    *              | 01 00 03 02 05 04 07 06 | 09 08 11 10 13 |\n    *              | 02 03 00 01 06 07 04 05 | 10 11 08 09 14 |\n    *              | 03 02 01 00 07 06 05 04 | 11 10 09 08 15 |\n    *       length | 04 05 06 07 00 01 02 03 | 12 13 14 15 08 | rightHeight\n    *              | 05 04 07 06 01 00 03 02 | 13 12 15 14 09 |\n    *              | 06 07 04 05 02 03 00 01 | 14 15 12 13 10 |\n    *              | 07 06 05 04 03 02 01 00 | 15 14 13 12 11 |\n    *            --- -- -- -- -- -- -- -- -- - -- -- -- -- -- ---\n    *              | 08 09 10 11 12 13 14 15 | 00 01 02 03 04 |\n    *              | 09 08 11 10 13 12 15 14 | 01 00 03 02 05 |\n    * bottomHeight | 10 11 08 09 14 15 12 13 | 02 03 00 01 06 |\n    *              | 11 10 09 08 15 14 13 12 | 03 02 01 00 07 |\n    *              | 12 13 14 15 08 09 10 11 | 04 05 06 07 00 |\n    *            --- -- -- -- -- -- -- -- -- - -- -- -- -- -- ---\n    *              |       bottomWidth       |                |\n    *\/\n  def elder_age(n: Long, m: Long, loss: Long, timeRange: Long): Long = {\n\n\/\/      (0 until n)\n\/\/        .flatMap { x =>\n\/\/          val s = (0 until m).map(x ^ _)\n\/\/          println(s.map(x => f\"$x%02d\").mkString(\" \"))\n\/\/          s\n\/\/        }\n\/\/        .map(_ - loss)\n\/\/        .filter(_ > 0)\n\/\/        .sum % timeRange\n\n    def lineSum(start: BigInt, len: BigInt): BigInt = {\n      if (start + len - 1 <= loss) 0\n      else if (start > loss) {\n        (len - 1) * len \/ 2 + (start - loss) * len\n      } else {\n        val tmp = start + len - loss\n        (tmp - 1) * tmp \/ 2\n      }\n    }\n\n    def timeDonation(x: BigInt, y: BigInt, start: BigInt): BigInt = {\n      val (width, height) = if (x > y) (x, y) else (y, x)\n\n      var length: BigInt = 1\n      var tmp: BigInt = width\n      while (tmp \/ 2 > 0) {\n        length *= 2\n        tmp \/= 2\n      }\n\n      val rightWidth: BigInt = width - length\n      val rightHeight: BigInt = if (height > length) length else height\n\n      val bottomWidth: BigInt = length\n      val bottomHeight: BigInt = height - length\n\n      if (height == 1) lineSum(start, width)\n      else {\n        lineSum(start, length) * rightHeight + {\n          if (rightWidth <= 0) 0\n          else timeDonation(rightWidth, rightHeight, start + length)\n        } + {\n          if (bottomHeight <= 0) 0\n          else timeDonation(bottomHeight, bottomWidth, start + length)\n        } + {\n          if (rightWidth <= 0 || bottomHeight <= 0) 0\n          else timeDonation(rightWidth, bottomHeight, start)\n        }\n      }\n    }\n\n    (timeDonation(m, n, 0) % timeRange).toLong\n  }\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336493,"user_id":null,"body":"object Immortal {\n\n  \/**\n    * set true to enable debug\n    *\/\n  val debug = false\n\n  def elder_age(n: Long, m: Long, loss: Long, timeRange: Long): Long = {\n\n    def lineSum(start: BigInt, len: BigInt): BigInt = {\n      if (start + len - 1 <= loss) 0\n      else if (start > loss) {\n        (len - 1) * len \/ 2 + (start - loss) * len\n      } else {\n        val tmp = start + len - loss\n        (tmp - 1) * tmp \/ 2\n      }\n    }\n\n    def timeDonation(x: BigInt, y: BigInt, start: BigInt): BigInt = {\n      val (width, height) = if (x > y) (x, y) else (y, x)\n\n      var length: BigInt = 1\n      var tmp: BigInt = width\n      while (tmp \/ 2 > 0) {\n        length *= 2\n        tmp \/= 2\n      }\n\n      val rightWidth: BigInt = width - length\n      val rightHeight: BigInt = if (height > length) length else height\n\n      val bottomWidth: BigInt = length\n      val bottomHeight: BigInt = height - length\n\n      if (height == 1) lineSum(start, width)\n      else {\n        lineSum(start, length) * rightHeight + {\n          if (rightWidth <= 0) 0\n          else timeDonation(rightWidth, rightHeight, start + length)\n        } + {\n          if (bottomHeight <= 0) 0\n          else timeDonation(bottomHeight, bottomWidth, start + length)\n        } + {\n          if (rightWidth <= 0 || bottomHeight <= 0) 0\n          else timeDonation(rightWidth, bottomHeight, start)\n        }\n      }\n    }\n\n    (timeDonation(m, n, 0) % timeRange).toLong\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336494,"user_id":null,"body":"object Immortal {\n  \n  val debug = false\n\n  val pots: List[Long] = (0 to 62).map(1L << _).toList\n\n  def nextTwoExp(n: Long): Long = pots.find(_ >= n).get\n  \n  def rangeSum(a: BigInt, b: BigInt): BigInt = (a + b) * (1 - a + b) \/ 2\n\n  def elder_age(n: Long, m: Long, loss: Long, time: Long): Long = {\n    if (n == 0 || m == 0) return 0\n\n    val (cols, rows) = if(m > n) (n, m) else (m, n)\n    val (nextExpCols, nextExpRows) = (nextTwoExp(cols), nextTwoExp(rows))\n\n    if(loss > nextExpRows) return 0\n\n    if(nextExpCols == nextExpRows) {\n      ((rangeSum(0, nextExpRows - loss - 1) * (rows + cols - nextExpRows) + elder_age(nextExpRows - rows, nextExpCols - cols, loss, time)) % time).toLong\n    } else {\n      val nextExpColsHalf = nextExpRows \/ 2\n      val res: BigInt = if (loss < nextExpColsHalf) {\n        rangeSum(0, nextExpRows - loss - 1) * cols -\n          rangeSum(BigInt(0).max(nextExpColsHalf - loss), nextExpRows - loss - 1) * (nextExpRows - rows) +\n          elder_age(nextExpColsHalf - cols, nextExpRows - rows, 0, time) +\n          BigInt(nextExpColsHalf - loss) * (nextExpColsHalf - cols) * (nextExpRows - rows)\n      } else {\n        rangeSum(0, nextExpRows - loss - 1) * cols -\n          rangeSum(BigInt(0).max(nextExpColsHalf - loss), nextExpRows - loss - 1) * (nextExpRows - rows) +\n          elder_age(nextExpColsHalf - cols, nextExpRows - rows, loss - nextExpColsHalf, time)\n      }\n      (((res % time) + time) % time).toLong\n    }\n  }\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336495,"user_id":null,"body":"import scala.math.BigInt\n\nobject Immortal {\n  val debug = false\n\n  def elder_age(n: Long, m: Long, k: Long, newp: Long): Long = {\n    sum(Cell(0,0,unsigned(k)), unsigned(n), unsigned(m)) % unsigned(newp) toLong\n  }\n\n  def unsigned(n: Long) =\n    (BigInt(n >>> 1) << 1) + (n & 1)\n\n  case class Cell(row: BigInt, col: BigInt, loss: BigInt) {\n    val value: BigInt = (row^col) - loss\n    def moveDown(r: BigInt) = copy(row = row + r)\n    def moveRight(c: BigInt) = copy(col = col + c)\n    def move(n: BigInt) = copy(row = row + n, col = col + n)\n  }\n\n  def sum(cell: Cell, nrows: BigInt, ncols: BigInt): BigInt = {\n    val cellCount = nrows * ncols\n    if (cellCount == 0)\n      0\n    else if (cellCount == 1)\n      cell.value max 0\n    else {\n      val n = maxPow2(nrows max ncols)\n      val atMostNrows = nrows min n\n      val atMostNcols = ncols min n\n      val nRowsBelow = (nrows - n) max 0\n      val ncolsRight = (ncols - n) max 0\n      val sqr = sqrSum(cell, n, atMostNrows min atMostNcols)\n      val below = sum(cell.moveDown(n), nRowsBelow, atMostNcols)\n      val right = sum(cell.moveRight(n), atMostNrows, ncolsRight)\n      val diag = sum(cell.move(n), nRowsBelow, ncolsRight)\n      sqr + below + right + diag\n    }\n  }\n\n  def sqrSum(topLeft: Cell, n0: BigInt, nrows: BigInt): BigInt = {\n    val n = ((topLeft.value min 0) + n0 - 1) max 0\n    val base = topLeft.value max 0\n    val rowSum = base*n0 + n*(n+1)\/2\n    nrows * rowSum\n  }\n\n  val BitRange = Range(63, 0, -1)\n  def maxPow2(n: BigInt): BigInt =\n    BitRange\n      .dropWhile(!n.testBit(_))\n      .headOption\n      .map(BigInt(0).setBit(_))\n      .getOrElse(0)\n}\n","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336496,"user_id":1228,"body":"object Immortal {\nimport math._ \nval debug = false\n\ndef elder_age(n: Long, m: Long, k: Long, newp: Long): Long = {\n  \n  var maxB = (x: BigInt, y: BigInt) => if (x > y) x else y\n  \n  var rangeSum = (left: BigInt, right: BigInt) => \n    (left + right) * (right - left + 1) \/ 2\n  \n  def inc(n: BigInt): BigInt = {\n    var p: BigInt = 1\n    while (p < n) p <<= 1\n    p\n  }\n  \n  def bigAge(n: BigInt, m: BigInt, k: BigInt): BigInt = {\n    if (m == 0 || n == 0) return 0\n    var (mm, nn) = (m, n)\n    if (mm > nn) {\n      val temp = mm\n      mm = nn\n      nn = temp\n    }\n    var (lm, ln) = (inc(mm), inc(nn)) \n    if (k > ln) return 0\n    if (lm == ln) {\n      return ( (rangeSum(1, ln - k - 1) * (mm + nn - ln) + bigAge(ln - nn, lm - mm, k)).mod(newp) )\n    }\n    var slop: BigInt = 0\n    if (lm < ln) {\n      lm = ln \/ 2\n      slop =  rangeSum(1, ln - k - 1) * mm - rangeSum(maxB(0, lm - k), ln - k - 1) * (ln - nn) \n      if (k <= lm) {\n        slop += (lm - k) * (lm - mm) * (ln - nn) + bigAge(lm - mm, ln - nn, 0)\n      } else {\n        slop += bigAge(lm - mm, ln - nn, k - lm)\n      }\n    }\n    return (slop.mod(newp))\n  }\n  bigAge(BigInt(n), BigInt(m), BigInt(k)).toLong \n  }\n\n}","lang_id":49,"is_control":0,"status":"sample_failed","variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5976c5a5cd933a7bbd000029":[{"id":336497,"user_id":492,"body":"object Faberge {    \n    def height(n: BigInt, m: BigInt): BigInt = {\n      val MOD: BigInt = BigInt(998244353)\n      var h = BigInt(0);\n      var u = BigInt(1);\n      for (i <- BigInt(1) to n) {\n        u = (u * (m + 1 - i) * i.modInverse(MOD)).mod(MOD);\n        h = (h + u).mod(MOD);\n      }\n      return h;\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336498,"user_id":53,"body":"import java.math.BigInteger\n\nobject Faberge {\n    \n    val mo = BigInt(998244353).bigInteger;\n  \n    var reg = new Array[BigInteger](80001);\n    reg(0) = BigInteger.valueOf(0);\n    reg(1) = BigInteger.valueOf(1);\n    var j = 2;\n    while (j <= 80000) {\n        var bj = BigInteger.valueOf(j);\n        reg(j) = mo.subtract(mo.divide(bj)).multiply(reg(mo.mod(bj).intValue()).mod(mo));\n        j += 1;\n    }\n    \n    def height(n: BigInt, m0: BigInt): BigInt = {\n        var m = m0.bigInteger;\n        var h = BigInteger.ZERO;\n        var t = BigInteger.ONE;\n        var i = 1;\n        m = m.mod(mo);\n        while (i <= n.bigInteger.intValue()) {\n            var bi = BigInteger.valueOf(i);\n            t = t.multiply(m.subtract(bi).add(BigInteger.ONE)).multiply(reg(i)).mod(mo);\n            h = h.add(t);\n            i += 1;\n        }\n        return h.mod(mo);\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336499,"user_id":null,"body":"object Faberge {\n    \n  val MOD:BigInt = BigInt(998244353)\n    \n    def sub_height(n:BigInt,k:BigInt):BigInt = {\n      var (s,nm,dm,i) = (BigInt(0),BigInt(1),BigInt(1),BigInt(0))\n      while(i<k){\n        val nn = (nm*(n-i))%MOD\n        val nd = (dm*(i+1))%MOD\n        s = (s+nn*nd.modPow(MOD-2, MOD))%MOD\n        nm=nn\n        dm=nd\n        i+=1\n      }\n      s\n    }\n\n    def height(n: BigInt, m: BigInt): BigInt = {\n      val mm = m%MOD\n\n      if(n>mm) (BigInt(2).modPow(mm,MOD)- 1) % MOD\n      else if (n>mm\/2L) ((MOD-2) + BigInt(2).modPow(mm,MOD) - height(mm-n-1,mm))%MOD\n      else sub_height(mm%MOD, n)\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336500,"user_id":null,"body":"object Faberge {\n  \n    val MOD: BigInt = BigInt(998244353)\n    val mod = 998244353\n\n\n    val sum_prod: Array[BigInt] = (2 to 80000).foldLeft(Array(BigInt(0),BigInt(1)))((a, i)=>a:+((MOD-(MOD\/i))*a(mod%i))%MOD)\n\n    def height(n: BigInt, m: BigInt): BigInt = {\n      val nm = m%MOD\n      var (s, p) = (BigInt(0),BigInt(1))\n\n      (1 to n.intValue).foreach(i=>{\n        p = (((p*(nm- i +1))%mod)* sum_prod(i))%mod\n        s = (s+p)%mod\n      })\n      s%mod\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5993c1d917bc97d05d000068":[{"id":336501,"user_id":1228,"body":"class Solution {\n\n  def regex_divisible_by(m: Int): String = {\n    if (m == 1) return \"[01]*\"\n  \tval b = Array.ofDim[String](m)\n  \tval a = Array.ofDim[String](m,m)\n    \n    def fstar(pre: String) = if (pre == null) \"\" else s\"($pre)*\"\n    \n    def fand(pre: String, x: String): String = {\n  \t\tif (pre == null || x == null) return null \n    \tif (pre == \"\")   return s\"($x)\"\n    \tif (x == \"\")     return s\"($pre)\"\n  \t  s\"($pre)($x)\"\n    }\n    \n    def ffor(pre: String, x: String): String = {\n    \tif (pre == null) return x \n    \tif (x   == null) return pre  \n      s\"($pre)|($x)\"\n    }    \n  \n  \tb(0) = \"\"\n  \tfor (i <- 0 to m-1) {\n  \t\ta(i)(i * 2 % m) = \"0\"\n  \t\ta(i)((i * 2 + 1) % m) = \"1\"\n  \t}\n \n    for (n <- (m - 1) to 0 by -1) {\n      b(n) = fand(fstar( a(n)(n) ), b(n) )\n      for (j <- 0 to n) {\n        a(n)(j) = fand(fstar( a(n)(n) ), a(n)(j) )\n      }\n      for (i <- 0 to n) {\n        b(i) = ffor(b(i), (fand( a(i)(n), b(n)) ) )\n        for (j <- 0 to n) {\n          a(i)(j) = ffor(a(i)(j), fand( a(i)(n), a(n)(j) ) )\n        }\n      }\n    }\n    return b(0)   \n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336502,"user_id":53,"body":"class Solution {\n    def regex_divisible_by(n: Int): String = {\n        if (n == 1) return \"^[01]*$\"\n        val graphs = Array.ofDim[String](n, n)\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n              graphs(i)(j) = \"-1\"\n            }\n            graphs(i)((2 * i) % n) = \"0\"\n            graphs(i)((2 * i + 1) % n) = \"1\"\n        }\n        for (k <- n - 1 to 0 by -1) {\n            val loop = if (graphs(k)(k) == \"-1\") \"\" else (graphs(k)(k) + \"*\")\n            for (i <- 0 until k) {\n                if (graphs(i)(k) != \"-1\") {\n                   for (j <- 0 until k) {\n                        if (graphs(k)(j) != \"-1\") {\n                            val s = if (graphs(i)(j) == \"-1\") \"\" else (graphs(i)(j) + \"|\")\n                            graphs(i)(j) = \"(?:\" + s + graphs(i)(k) + loop + graphs(k)(j) + \")\"\n                        }\n                    }\n                }\n            }\n        }\n        return \"^\" + graphs(0)(0) + \"*$\"\n    }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336503,"user_id":null,"body":"import scala.annotation.tailrec\n\nobject Solution {\n\n  case class Digit(repr: Char, numericalValue: Int)\n\n  type Base = List[Digit]\n\n  def baseFromString(base: String): Base = {\n    for {\n      (repr, numericalValue) <- base.zipWithIndex.toList\n    } yield Digit(repr, numericalValue)\n  }\n\n  type NodeValue = Int\n  case class Node(value: NodeValue) extends AnyVal\n\n  sealed trait LinkExpr {\n    def r3g3x: String\n  }\n\n  case class DigitLinkExpr(value: Digit) extends LinkExpr {\n    override def r3g3x: String = value.repr.toString\n  }\n\n  case class RepeatLinkExpr(expr: LinkExpr) extends LinkExpr {\n    override def r3g3x: String = s\"(${expr.r3g3x})*\"\n  }\n\n  case class ConcatLinkExpr(a: LinkExpr, b: LinkExpr) extends LinkExpr {\n    override def r3g3x: String = s\"(${a.r3g3x}${b.r3g3x})\"\n  }\n\n  case class OrLinkExpr(a: LinkExpr, b: LinkExpr) extends LinkExpr {\n    override def r3g3x: String = s\"((${a.r3g3x})|(${b.r3g3x}))\"\n  }\n\n  case class Link(from: Node, to: Node, expr: LinkExpr)\n\n  type Graph = List[Link]\n\n  def addDigitToValue(value: Int, base: Base, digit: Digit): Int = value * base.length + digit.numericalValue\n\n  def generateGraphFor(base: Base, modulo: Int): Graph = {\n    for {\n      remainder <- (0 until modulo).toList\n      from = Node(remainder)\n      digit <- base\n      to = Node(addDigitToValue(remainder, base, digit) % modulo)\n      rawExpr = DigitLinkExpr(digit)\n      expr = if (from == to) RepeatLinkExpr(rawExpr) else rawExpr\n    } yield Link(from, to, expr)\n  }\n\n  def prettyPrintGraph(graph: Graph): Unit = {\n    for {\n      links <- graph.groupBy(_.from).toList.sortBy(_._1.value)\n      from = links._1\n    } {\n      println()\n      println(s\"from node ${from.value}:\")\n      for {\n        link <- links._2\n      } {\n        println(s\"${link.expr.r3g3x} => ${link.to.value}\")\n      }\n    }\n  }\n\n  def findMaximumNode(graph: Graph): Node = {\n    graph.flatMap(n => List(n.from, n.to)).maxBy(_.value)\n  }\n\n  def findLinksTo(graph: Graph, node: Node): List[Link] = graph.filter(_.to == node)\n  def findLinksFrom(graph: Graph, node: Node): List[Link] = graph.filter(_.from == node)\n\n  def tryReplaceSelfTarget(graph: Graph, node: Node): Graph = {\n    val selfTargetOpt = graph.find(l => l.to == node && l.from == node)\n\n    selfTargetOpt match {\n      case None => graph\n      case Some(repeatLink) =>\n        graph.filter(_ != repeatLink).map { link =>\n          if (link.to == node) {\n            link.copy(expr = ConcatLinkExpr(link.expr, RepeatLinkExpr(repeatLink.expr)))\n          } else {\n            link\n          }\n        }\n    }\n  }\n\n  def removeNode(graph: Graph, node: Node): Graph = {\n    val woSelfTarget = tryReplaceSelfTarget(graph, node)\n\n    val linksFrom = findLinksFrom(woSelfTarget, node)\n\n    woSelfTarget.flatMap {\n      case l if l.from == node => Nil\n      case l if l.to != node => List(l)\n      case l => linksFrom.map(lFrom => {\n        Link(\n          from = l.from,\n          to = lFrom.to,\n          expr = ConcatLinkExpr(l.expr, lFrom.expr)\n        )\n      })\n    }\n  }\n\n  def mergeDuplicateTarget(graph: Graph): Graph = {\n    graph.groupBy(l => l.from -> l.to).map {\n      case (_, l:: Nil) => l\n      case (_, links) => links.reduceLeft((l1, l2) => l1.copy(expr = OrLinkExpr(l1.expr, l2.expr)))\n    }.toList\n  }\n\n  def simplifyGraph(graph: Graph): Graph = mergeDuplicateTarget(removeNode(graph, findMaximumNode(graph)))\n\n  @tailrec\n  def simplifyGraphToExpr(graph: Graph): LinkExpr = {\n    graph match {\n      case Nil => throw new Exception(s\"Graph without link\")\n      case singleNode::Nil => singleNode.expr\n      case _::_::_ => simplifyGraphToExpr(simplifyGraph(graph))\n    }\n  }\n}\n\nclass Solution {\n  import Solution._\n\n  def regex_divisible_by(n: Int): String = {\n    if (n == 1) {\n      \"(0|1)*\"\n    } else {\n      val base = baseFromString(\"01\")\n      val graph = generateGraphFor(base, n)\n      val expr = RepeatLinkExpr(simplifyGraphToExpr(graph))\n\n      \"^\" + expr.r3g3x + \"$\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336504,"user_id":3346,"body":"import scala.collection._\n\nclass Solution {\n  case class Key(a: Int, b: Int, c: Int, d: Int)\n  val map = new mutable.HashMap[Key, String]()\n  \n  def gen(k: Key): String = map.get(k) match {\n    case Some(v) => v\n    case None =>\n      val stack = new mutable.Stack[String]()\n      for (d <- 0 to 1) {\n        if ((2 * k.b + d) % k.a == k.d) {\n          stack += d.toString\n        }\n      }\n\n      for (l <- 0 until k.c) {\n        val a = gen(Key(k.a, k.b, l, l))\n        val b = gen(Key(k.a, l, l, l))\n        val c = gen(Key(k.a, l, l, k.d))\n\n        if (a.nonEmpty && c.nonEmpty) {\n          if (b.nonEmpty) {\n            stack += s\"$a$b*$c\"\n          } else {\n            stack += s\"$a$c\"\n          }\n        }\n      }\n      val res = if (stack.nonEmpty) \"(?:\" + stack.mkString(\"|\") + \")\" else \"\"\n      map.addOne(k, res)\n      res\n  }\n\n  def regex_divisible_by(n: Int): String = {\n     s\"^${gen(Key(n, 0, n, 0))}$$\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336505,"user_id":null,"body":"import scala.collection.mutable.ArrayBuffer\nclass Solution {\n  case class DFA(private val stateNum: Int) {\n    case class Arc(edge: (Int, Int), regexString: String)\n    case class State(index: Int, preList: ArrayBuffer[Int], postList: ArrayBuffer[Int])\n\n    val arcs: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer.fill(stateNum, stateNum)(\"\")\n    val states: ArrayBuffer[State] = ArrayBuffer.empty[State]\n\n    def addArc(from: Int, to: Int, str: String): Unit = {\n      if (from != to) {\n        states(from).postList += to\n        states(to).preList += from\n      }\n      arcs(from)(to) = str\n    }\n\n    def init(): Unit = {\n      for (index <- 0 until stateNum) {\n        states += State(index, ArrayBuffer.empty[Int], ArrayBuffer.empty[Int])\n      }\n\n      for (index <- 0 until stateNum) {\n        addArc(index, (index * 2) % stateNum, \"0\")\n        addArc(index, (index * 2 + 1) % stateNum, \"1\")\n      }\n    }\n\n    def deleteArc(state: State, pre: Boolean, index: Int): Unit = {\n      val list = if (pre) state.preList else state.postList\n      val i = list.indexOf(index)\n      if (i > 0) list.remove(i, 1)\n    }\n\n    def reduceState(s: Int): DFA = {\n\n      val state = states(s)\n\n      for (qi <- state.preList; pi <- state.postList) {\n        val q = states(qi)\n        val p = states(pi)\n        val Rpq = arcs(qi)(pi)\n        val qArc = arcs(qi)(state.index)\n        val pArc = arcs(state.index)(pi)\n        val sArc = arcs(state.index)(state.index)\n\n        val S = sArc.length match {\n          case 0 => \"\"\n          case 1 => s\"$sArc*\"\n          case _ => s\"($sArc)*\"\n        }\n\n        def genStr(s: String): String = if (s.contains(\"|\")) s\"($s)\" else s\n\n        val Q = genStr(qArc)\n        val P = genStr(pArc)\n\n        val str = if (Rpq.length > 0) Array(genStr(Rpq), Q+S+P).mkString(\"|\") else Q + S + P\n        deleteArc(q, pre = false, p.index)\n        deleteArc(p, pre = true, q.index)\n        addArc(q.index, p.index, str)\n        deleteArc(q, pre = false, state.index)\n        deleteArc(p, pre = true, state.index)\n      }\n      this\n    }\n\n    def finalState: String = {\n      s\"^(${arcs(0)(0)})+\" + \"$\"\n    }\n  }\n\n  def regex_divisible_by(n: Int): String = {\n    if (n == 1) return s\"(0|1)*\"\n    val m = DFA(n)\n    m.init()\n    val res = (1 until n).foldLeft(m)((dfa, state) => dfa.reduceState(state))\n    res.finalState\n  }\n}\n\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336506,"user_id":null,"body":"\nimport scala.collection.mutable.ArrayBuffer\nclass Solution {\n  case class DFA(private val stateNum: Int) {\n    case class Arc(edge: (Int, Int), regexString: String)\n    case class State(index: Int, preList: ArrayBuffer[Int], postList: ArrayBuffer[Int])\n\n    val arcs: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer.fill(stateNum, stateNum)(\"\")\n    val states: ArrayBuffer[State] = ArrayBuffer.empty[State]\n\n    def addArc(from: Int, to: Int, str: String): Unit = {\n      if (from != to) {\n        states(from).postList += to\n        states(to).preList += from\n      }\n      arcs(from)(to) = str\n    }\n\n    def init(): Unit = {\n      for (index <- 0 until stateNum) {\n        states += State(index, ArrayBuffer.empty[Int], ArrayBuffer.empty[Int])\n      }\n\n      for (index <- 0 until stateNum) {\n        addArc(index, (index * 2) % stateNum, \"0\")\n        addArc(index, (index * 2 + 1) % stateNum, \"1\")\n      }\n    }\n\n    def deleteArc(state: State, pre: Boolean, index: Int): Unit = {\n      val list = if (pre) state.preList else state.postList\n      val i = list.indexOf(index)\n      if (i > 0) list.remove(i, 1)\n    }\n\n\n    def reduceState(s: Int): DFA = {\n\n      val state = states(s)\n\n      for (qi <- state.preList; pi <- state.postList) {\n        val q = states(qi)\n        val p = states(pi)\n        val Rpq = arcs(qi)(pi)\n        val qArc = arcs(qi)(state.index)\n        val pArc = arcs(state.index)(pi)\n        val sArc = arcs(state.index)(state.index)\n\n        val S = sArc.length match {\n          case 0 => \"\"\n          case 1 => s\"$sArc*\"\n          case _ => s\"(?:$sArc)*\"\n        }\n\n        def genStr(s: String): String = if (s.contains(\"|\")) s\"(?:$s)\" else s\n\n        val Q = genStr(qArc)\n        val P = genStr(pArc)\n\n        val str = if (Rpq.length > 0) Array(genStr(Rpq), Q+S+P).mkString(\"|\") else Q + S + P\n        deleteArc(q, pre = false, p.index)\n        deleteArc(p, pre = true, q.index)\n        addArc(q.index, p.index, str)\n        deleteArc(q, pre = false, state.index)\n        deleteArc(p, pre = true, state.index)\n      }\n      this\n    }\n\n    def finalState: String = {\n      s\"^(?:${arcs(0)(0)})+\" + \"$\"\n    }\n  }\n\n  def regex_divisible_by(n: Int): String = {\n    if (n == 1) return \"^(0|1)+$\"\n    val m = DFA(n)\n    m.init()\n    val res = (1 until n).foldLeft(m)((dfa, state) => dfa.reduceState(state))\n    res.finalState\n  }\n\n}\n\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336507,"user_id":977,"body":"import scala.util.matching.Regex\n\nobject RegularExpressions {\n\n  sealed trait RE[+A] {\n    def union[B >: A](that: RE[B]): RE[B] = (this, that) match {\n      case (Phi, other) => other\n      case (other, Phi) => other\n      case (a, b) => Union(a, b)\n    }\n\n    def concat[B >: A](that: RE[B]): RE[B] = (this, that) match {\n      case (Epsilon, other) => other\n      case (other, Epsilon) => other\n      case (Phi, _) => Phi\n      case (_, Phi) => Phi\n      case (a, b) => Concatenation(a, b)\n    }\n\n    def star: RE[A] = this match {\n      case Epsilon => Epsilon\n      case Phi => Epsilon\n      case r => ZeroOrMore(r)\n    }\n  }\n\n  case class Literal[A](a: A) extends RE[A] {\n    override def toString: String = a.toString\n  }\n\n  object Epsilon extends RE[Nothing] {\n    override def toString: String = \"\u03b5\"\n  }\n\n  object Phi extends RE[Nothing] {\n    override def toString: String = \"\u03a6\"\n  }\n\n  case class Union[A](r1: RE[A], r2: RE[A]) extends RE[A] {\n    override def toString: String = s\"(?:${r1.toString}|${r2.toString})\"\n  }\n\n  case class Concatenation[A](r1: RE[A], r2: RE[A]) extends RE[A] {\n    override def toString: String = s\"(?:${r1.toString}${r2.toString})\"\n  }\n\n  case class ZeroOrMore[A](r: RE[A]) extends RE[A] {\n    override def toString: String = s\"(?:${r.toString})*\"\n  }\n\n}\n\nobject FSM {\n\n  trait DFA[S, A] {\n    def stateSet: Iterator[S]\n\n    def alphabet: Iterator[A]\n\n    def initialState: S\n\n    def delta(s: S)(a: A): S\n\n    def isAccepting(s: S): Boolean\n\n    final def run(input: Seq[A]): Boolean = {\n      @scala.annotation.tailrec\n      def run(input: Seq[A], state: S): Boolean =\n        if (input.isEmpty) isAccepting(state)\n        else {\n          val nextState = delta(state)(input.head)\n          run(input.tail, nextState)\n        }\n\n      run(input, initialState)\n    }\n\n    def toRegularExpression: RegularExpressions.RE[A] =\n      GNFA.fromDFA(this).toRegularExpression\n  }\n\n  object GNFA {\n\n    import RegularExpressions._\n\n    sealed trait GNFA[S, A] { self =>\n\n      def stateSet: Iterator[State[S]]\n\n      def alphabet: Iterator[A]\n\n      def initialState: State[S] = Start\n\n      def isAccepting(s: State[S]): Boolean = s match {\n        case Accept => true\n        case _ => false\n      }\n\n      def delta(s1: State[S], s2: State[S]): RE[A]\n\n      def toRegularExpression: RegularExpressions.RE[A] = {\n        val set = stateSet.toSet\n        if (set.size == 2) delta(Start, Accept)\n        else {\n          val qrip = set.flatMap(_ match {\n            case Internal(a) => Some(a)\n            case _ => None\n          }).head\n\n          val newSet = set - qrip\n\n          val nextGnfa = new GNFA[S, A] with Cache[S, A] {\n            def stateSet: Iterator[State[S]] = newSet.iterator\n\n            def alphabet: Iterator[A] = self.alphabet\n\n            def nonCachedDelta(s1: State[S], s2: State[S]): RE[A] = (s1, s2) match {\n              case (qi, qj) =>\n                val r1 = self.delta(qi, qrip)\n                val r2 = self.delta(qrip, qrip)\n                val r3 = self.delta(qrip, qj)\n                val r4 = self.delta(qi, qj)\n                r1.concat(r2.star).concat(r3).union(r4)\n            }\n          }\n          nextGnfa.toRegularExpression\n        }\n      }\n\n    }\n\n    trait Cache[S, A] extends GNFA [S, A] {\n      private val memo = scala.collection.mutable.HashMap.empty[(State[S], State[S]), RE[A]]\n\n      def nonCachedDelta(s1: State[S], s2: State[S]): RE[A]\n      final def delta(s1: State[S], s2: State[S]): RE[A] =\n        memo.getOrElseUpdate((s1, s2), nonCachedDelta(s1, s2))\n    }\n\n    sealed trait State[+A]\n\n    object Start extends State[Nothing] {\n      override def toString: String = \"GNFA.Start\"\n    }\n\n    object Accept extends State[Nothing] {\n      override def toString: String = \"GNFA.Accept\"\n    }\n\n    case class Internal[+A](a: A) extends State[A]\n\n    implicit def toState[A](a: A): State[A] = Internal(a)\n\n    def fromDFA[S, A](dfa: DFA[S, A]): GNFA[S, A] = new GNFA[S, A] with Cache[S,A] {\n      def stateSet: Iterator[State[S]] = Iterator(Start, Accept) ++ dfa.stateSet.map(Internal(_))\n\n      def alphabet: Iterator[A] = dfa.alphabet\n\n      def nonCachedDelta(s1: State[S], s2: State[S]): RE[A] = (s1, s2) match {\n        case (Start, Accept) => Phi\n        case (Start, Internal(s)) => if (dfa.initialState == s) Epsilon else Phi\n        case (Internal(s), Accept) => if (dfa.isAccepting(s)) Epsilon else Phi\n        case (Internal(s1), Internal(s2)) =>\n          alphabet\n            .toSet\n            .view\n            .filter(dfa.delta(s1)(_) == s2)\n            .foldLeft(Phi: RE[A])(_ union Literal(_))\n      }\n    }\n  }\n\n}\n\nclass Solution {\n  def modDFA(n: Int): FSM.DFA[Int, Char] = new FSM.DFA[Int, Char] {\n    def stateSet: Iterator[Int] = (0 until n).iterator\n\n    def alphabet: Iterator[Char] = Set('1', '0').iterator\n\n    def initialState: Int = 0\n\n    def delta(s: Int)(a: Char): Int = (s, a) match {\n      case (x, '1') => (x * 2 + 1) % n\n      case (x, '0') => (x * 2) % n\n    }\n\n    def isAccepting(s: Int): Boolean = s == 0\n  }\n  \n  def regex_divisible_by(n: Int): String = {\n    return modDFA(n).toRegularExpression.toString\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336508,"user_id":null,"body":"class Solution {\n\n  import scala.collection.mutable\n\n  def star(s: String): String = {\n    if (s == \"\") \"\"\n    else {\n      if (s.length == 1) s + \"*\"\n      else \"(\" + s + \")*\"\n    }\n  }\n\n  def regex_divisible_by(n: Int): String = {\n    if (n == 1) \"^[01]+$\"\n    else {\n\n      def event(x: Int, y: Int): String = {\n        if ((x * 2) % n == y) \"0\"\n        else if ((x * 2 + 1) % n == y) \"1\"\n        else \"-\"\n      }\n\n      val table = mutable.Map[Int, mutable.Map[Int, String]]()\n\n      for (from <- 0 until n; to <- 0 until n) {\n        if (event(from, to) != \"-\") {\n          table\n            .getOrElseUpdate(from, mutable.Map())\n            .update(to, event(from, to))\n        }\n      }\n\n      for (state <- n - 1 to 0 by -1) {\n        val s = star(table(state).getOrElse(state, \"\"))\n        val t = (table(state) - state).map(x => (x._1, s + x._2))\n\n        (table - state).values.filter(_.contains(state)).map { a =>\n          val b = t.map(x => (x._1, a(state) + x._2))\n          a -= state\n          val xs = a.keySet & b.keySet\n          xs.foreach { x =>\n            a(x) = \"(\" + a(x) + \"|\" + b(x) + \")\"\n          }\n          a ++= b -- xs\n        }\n\n        if (state != 0) table -= state\n      }\n\n      \"^\" + table(0)(0) + \"*$\"\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336509,"user_id":null,"body":"class Solution {\n  def regex_divisible_by(n: Int): String = {\n    if (n == 1) {\n      \"\"\"^[01]+$\"\"\"\n    } else {\n\n      import scala.collection.mutable\n\n      def symbol(x: Int, y: Int): String = {\n        if ((x * 2) % n == y) \"0\"\n        else if ((x * 2 + 1) % n == y) \"1\"\n        else \"\"\n      }\n\n      val states: Map[Int, String] = {\n        (0 until n).map(i => i -> ('A'.toInt + i).toChar.toString).toMap\n      }\n\n      val equations = mutable.Map[String, Array[String]]()\n\n      for (i <- 0 until n; j <- 0 until n) {\n        if (symbol(i, j) != \"\") {\n          val from = states(i)\n          val to = states(j)\n          if (equations.contains(from)) {\n            equations(from) :+= symbol(i, j) + to\n          } else {\n            equations(from) = Array(symbol(i, j) + to)\n          }\n        }\n      }\n\n      def star(str: String): String = {\n        if (str != \"\") {\n          if (str.length > 1) s\"($str)*\"\n          else str + \"*\"\n        } else {\n          \"\"\n        }\n      }\n\n      def paren(str: String): String = {\n        if (str.contains(\"\"\"|\"\"\")) {\n          s\"($str)\"\n        } else {\n          str\n        }\n      }\n\n      for (i <- n - 1 to 0 by -1) {\n        val state = states(i)\n\n        equations(state) = {\n          equations(state).partition(_.endsWith(state)) match {\n            case (p1, p2) =>\n              val alpha: String =\n                star(p1.map(_.init).mkString(\"|\"))\n\n              val beta: Array[String] = if (p2.length > 1) {\n                p2.groupBy(_.last.toString)\n                  .map(x => paren(x._2.map(_.init).mkString(\"|\")) + x._1)\n                  .toArray\n              } else {\n                Array(p2.headOption.getOrElse(\"\"))\n              }\n\n              beta.map(alpha + _)\n          }\n        }\n\n        (equations - state).foreach {\n          case (x, y) =>\n            val ys = y.filter(_.contains(state))\n            equations(x) = {\n              equations(x).diff(ys) ++\n                equations(state).flatMap { expr =>\n                  ys.map(_.replace(state, expr))\n                }\n            }\n        }\n\n        if (state != states(0)) {\n          equations -= state\n        }\n      }\n\n      \"^\" + equations(states(0)).head + \"$\"\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336510,"user_id":null,"body":"class Solution {\n  case class Automaton[State: Ordering](states: Set[State], transitions: Set[(State, String, State)], initialState: State, finalState: State) {\n  def eliminateState(state: State): Automaton[State] = {\n    val newStates = states.filterNot(_ == state)\n    val incoming = transitions.filter { case (from, _, to) => from != state && to == state }\n    val outgoing = transitions.filter { case (from, _, to) => from == state && to != state }\n    val loops = transitions\n      .filter { case (from, _, to) => from == state && to == state }\n    val loopExpr = loops\n      .headOption\n      .map { case (_, label, _) => s\"($label)*\" }\n      .getOrElse(\"\")\n    val newTransitions = for {\n      (from, a, _) <- incoming\n      (_, c, to) <- outgoing\n    } yield (from, s\"($a)$loopExpr($c)\", to)\n    copy(newStates, transitions.diff(incoming).diff(loops).diff(outgoing).union(newTransitions))\n  }\n\n  def simplify(): Automaton[State] = {\n    val newTransitions = transitions\n      .groupBy { case (from, _, to) => (from, to) }\n      .mapValues(_.map { case (_, s, _) => s }.mkString(\"|\"))\n      .map { case ((from, to), label) => (from, label, to) }\n    copy(transitions = newTransitions.toSet)\n  }\n\n  def minimize(): Automaton[State] = {\n    val availableStates = states.diff(Set(initialState, finalState))\n    if (availableStates.isEmpty)\n      this.simplify()\n    else {\n      val head = availableStates.head\n      val next = this\n        .simplify()\n        .eliminateState(head)\n        .simplify()\n      next.minimize()\n    }\n  }\n}\n\nobject Automaton {\n  def apply(n: Int): Automaton[Int] = {\n    val states = 0 until n\n    val transitions = states.flatMap(k => List((k, \"0\", (k * 2) % n), (k, \"1\", (k * 2 + 1) % n)))\n    Automaton(states.toSet, transitions.toSet, 0, 0)\n  }\n}\n\n\n  def regex_divisible_by(n: Int): String = {\n    val minimalAutomaton = Automaton(n).minimize()\n    val label = minimalAutomaton.transitions.head._2\n    \"^(\" + label + \")*$\"\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59c132fb70a3b7efd3000024":[{"id":336511,"user_id":null,"body":"object Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = tuple[(A,B)]( (a,b) => a -> b)\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A,B] {\n    override def apply[C]: ((A, B) => C) => C = (f: (A, B) => C) => f(tuple._1, tuple._2)\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A = tuple.apply((a, _) => a)\n\n  def snd[B](tuple: STuple[_, B]): B = tuple.apply((_, b) => b)\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = tuple[STuple[B,A]]((a,b) => fromTuple(b -> a))\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C = {\n    a:A => b:B => f(fromTuple(a -> b))\n  }\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = x => {\n\n    import scala.{Function => func}\n    func.tupled(func.uncurried(f))(toTuple(x))\n  }\n\n  def toOption[A](option: SOption[A]): Option[A] = option.apply(None, Some(_))\n\n  def fromOption[A](option: Option[A]): SOption[A] = option.fold(\n    new SOption[A] {\n      override def apply[B]: ( => B, A => B) => B = (x, _) => x\n    }\n  )(\n    a => new SOption[A] {\n      override def apply[B]: ( => B, A => B) => B = (_, x) => x(a)\n    }\n  )\n\n  def isSome(option: SOption[_]): Boolean = option.apply(false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean = option.apply(true, _ => false)\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] =\n    list.apply(\n      nil[A],\n      (head: SOption[A], list:SList[SOption[A]]) =>\n        head.apply(\n          catOptions(list),\n          x => cons(x, catOptions(list))\n        )\n    )\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = either.apply(x => Left(x), x => Right(x))\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = new SEither[A,B] {\n    override def apply[C]: (A => C, B => C) => C = (l,r) => either.fold(l,r)\n  }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = either.apply(_ => true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean = either.apply(_ => false, _ => true)\n\n  def nil[A]: SList[A] = new SList[A] {\n    override def apply[B]: ( => B, (A, SList[A]) => B) => B = (x, _) => x\n  }\n\n  def toList[A](list: SList[A]): List[A] = list.apply(Nil,(item, f) => item :: toList(f))\n\n  def fromList[A](list: List[A]): SList[A] = new SList[A] {\n    override def apply[B]: ( => B, (A, SList[A]) => B) => B = (x, f) =>\n      list match {\n      case Nil => x\n      case item :: items => f(item, fromList(items))\n    }\n  }\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (x, f) => f(head, list)\n  }\n\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] =\n  left.apply(\n    right,\n    (head, tail) =>\n    cons(head, concat(tail, right))\n  )\n\n  def empty(list: SList[_]): Boolean = list.apply(true, (_, _) => false)\n\n  def length(list: SList[_]): Int = {\n    def length(list: SList[_], l:Int):Int = {\n      list.apply(\n        l,\n        (_, list) => length(list, l + 1)\n      )\n    }\n    length(list, 0)\n  }\n\n  def map[A, B](f: A => B, list: SList[A]): SList[B] = list.apply(\n    nil[B],\n    (a, list) => cons( f(a), map(f,list))\n  )\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] = {\n    listA.apply(\n      nil,\n      (x,xs) =>\n      listB.apply(\n        nil,\n        (y, ys) =>\n        cons(fromTuple(x -> y), zip(xs, ys))\n      )\n    )\n  }\n\n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B =\n    list.apply(\n      z,\n      (x, xs) => foldLeft(f, f(z, x), xs)\n    )\n\n  def foldRight[A, B](f: (A, B) => B, z: B, list: SList[A]): B = list.apply(\n      z,\n      (x, xs) => f(x,foldRight(f,z,xs))\n    )\n\n  def take[A](n: Int, list: SList[A]): SList[A] = {\n    if( n == 0 ) {\n      nil[A]\n    } else {\n      list.apply(\n        nil[A],\n        (a, list) => cons(a, take(n - 1, list))\n      )\n    }\n  }\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = foldRight[\n    SEither[A,B],\n    STuple[SList[A],SList[B]]\n  ](\n    (x, acc) => x.apply(\n      l => fromTuple(cons(l, fst(acc)), snd(acc)),\n      r => fromTuple(fst(acc), cons(r, snd(acc)))\n    ),\n    fromTuple(nil, nil),\n    list\n  )\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336512,"user_id":null,"body":"\nobject Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) =\n    (tuple.apply[A]((a: A, b: B) => a), tuple.apply[B]((a: A, b: B) => b))\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = {\n    new STuple[A, B] {\n      override def apply[C]: ((A, B) => C) => C = (f: (A, B) => C) => {\n          f(tuple._1, tuple._2)\n      }\n    }\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A = tuple.apply[A]((a: A, b: B) => a)\n\n  def snd[B](tuple: STuple[_, B]): B = tuple.apply[B]((_, b: B) => b)\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = fromTuple(toTuple(tuple).swap)\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C = (a: A) => (b: B) => f(new STuple[A, B] {\n    override def apply[D]: ((A, B) => D) => D = _(a, b)\n  })\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = (st: STuple[A, B]) => {\n    st.apply[C]((a: A, b: B) => f(a)(b))\n  }\n\n  def toOption[A](option: SOption[A]): Option[A] = option.apply(None, Some(_))\n\n  def fromOption[A](option: Option[A]): SOption[A] = new SOption[A] {\n    override def apply[B]: (=>B, A => B) => B = (none, some) => option match {\n      case None => none\n      case Some(a) => some(a)\n    }\n  }\n\n  def isSome(option: SOption[_]): Boolean = option.apply(false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean = option.apply(true, _ => false)\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (nill, cons) => {\n      def helper(lst: SList[SOption[A]]): B = {\n        lst.apply(nill, (a, l) => a.apply[B](helper(l), cons(_, catOptions(l))))\n      }\n      helper(list)\n    }\n  }\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = either.apply[Either[A, B]](Left(_), Right(_))\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = new SEither[A, B] {\n    override def apply[C]: (A => C, B => C) => C = (left: A => C, right: B => C) => either match {\n      case Left(a) => left(a)\n      case Right(b) => right(b)\n    }\n  }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = either.apply(_ =>true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean = either.apply(_ => false, _ => true)\n\n  def nil[A]: SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (nill, cons) => nill\n  }\n\n  def toList[A](list: SList[A]): List[A] = list.apply[List[A]](Nil, (a: A, xs: SList[A]) => a :: toList(xs))\n\n  def fromList[A](list: List[A]): SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (nill, cons) => list match {\n      case Nil => nill\n      case x :: xs => cons(x, fromList(xs))\n    }\n  }\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (_, cons) => {\n      cons(head, list)\n    }\n  }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] = left.apply(right, (a, xs) => cons(a, concat(xs, right)))\n\n  def empty(list: SList[_]): Boolean = list.apply(true, (_, _) => false)\n\n  def length(list: SList[_]): Int = list.apply[Int](0, (_, cons: SList[_]) => 1 + length(cons))\n\n  def map[A, B](f: A => B, list: SList[A]): SList[B] = new SList[B] {\n    override def apply[C]: (=> C, (B, SList[B]) => C) => C = (nill, cons) => {\n      list.apply[C](nill, (a, xs) => cons(f(a), map(f, xs)))\n    }\n  }\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] = new SList[STuple[A, B]] {\n    override def apply[C]: (=> C, (STuple[A, B], SList[STuple[A, B]]) => C) => C =\n      (nill, cons) => {\n        listA.apply(nill, (a: A, xa: SList[A]) => {\n          \/\/ returns C\n          listB.apply(nill, (b: B, xb: SList[B]) => {\n            \/\/ returns C\n            \/\/ we've go a: A, b: B, and we should use cons to build SList[STuple[A, B]]\n            cons(\n              \/\/ we need a tuple here\n              fromTuple((a, b)),\n              \/\/ and a new tuple list here\n              zip(xa, xb)\n            )\n          })\n        })\n      }\n  }\n\n  def foldLeft[A, B](f: (B, A) => B, z: B, list: SList[A]): B =\n    list.apply(z, (a: A, xs: SList[A]) => {\n      foldLeft(f, f(z, a), xs)\n    })\n\n  def foldRight[A, B](f: (A, B) => B, z: B, list: SList[A]): B =\n    list.apply(z, (a: A, xs: SList[A]) => {\n      f(a, foldRight(f, z, xs))\n    })\n\n  def take[A](n: Int, list: SList[A]): SList[A] = {\n    if (n == 0) nil\n    else list.apply(nil, (x: A, xs: SList[A]) => cons(x, take(n - 1, xs)))\n  }\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = new STuple[SList[A], SList[B]] {\n    override def apply[C]: ((SList[A], SList[B]) => C) => C = (dispatch: (SList[A], SList[B]) => C) => {\n      def filterLeft(xs: SList[SEither[A, B]]): SList[A] = {\n        xs.apply(nil, (eab: SEither[A, B], xxs: SList[SEither[A, B]]) => {\n          eab.apply((a: A) => {\n            cons(a, filterLeft(xxs))\n          }, (b: B) => {\n            filterLeft(xxs)\n          })\n        })\n      }\n\n      def filterRight(xs: SList[SEither[A, B]]): SList[B] = {\n        xs.apply(nil, (eab: SEither[A, B], xxs: SList[SEither[A, B]]) => {\n          eab.apply((a: A) => {\n            filterRight(xxs)\n          }, (b: B) => {\n            cons(b, filterRight(xxs))\n          })\n        })\n      }\n\n      dispatch(filterLeft(list), filterRight(list))\n    }\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336513,"user_id":null,"body":"object Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = tuple.apply[(A, B)]((a, b) => (a, b))\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A, B] {\n    override def apply[C]: ((A, B) => C) => C = _ (tuple._1, tuple._2)\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A = tuple.apply[A]((first, _) => first)\n\n  def snd[B](tuple: STuple[_, B]): B = tuple.apply[B]((_, second) => second)\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = tuple.apply[STuple[B, A]]((a, b) => new STuple[B, A] {\n    override def apply[C]: ((B, A) => C) => C = _ (b, a)\n  })\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C =\n    a => b => f(new STuple[A, B] {\n      override def apply[C]: ((A, B) => C) => C = _ (a, b)\n    })\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = tuple => tuple[C](Function.uncurried(f))\n\n  def toOption[A](option: SOption[A]): Option[A] = option.apply[Option[A]](None, Some(_))\n\n  def fromOption[A](option: Option[A]): SOption[A] = new SOption[A] {\n    override def apply[B]: (=> B, A => B) => B = option.fold(_)(_)\n  }\n\n  def isSome(option: SOption[_]): Boolean = option.apply[Boolean](false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean = !isSome(option)\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] = list.apply[SList[A]](nil[A], (h, t) => h.apply[SList[A]](catOptions(t), e => cons(e, catOptions(t))))\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = either.apply[Either[A, B]](Left[A, B], Right[A, B])\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = new SEither[A, B] {\n    override def apply[C]: (A => C, B => C) => C = either.fold\n  }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = either.apply[Boolean](_ => true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean = either.apply[Boolean](_ => false, _ => true)\n\n  def nil[A]: SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (b, _) => b\n  }\n\n  def toList[A](list: SList[A]): List[A] = list.apply[List[A]](List[A](), (h, t) => h :: toList(t))\n\n  def fromList[A](list: List[A]): SList[A] = list.foldRight(nil[A])(cons)\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (_, f) => f(head, list)\n  }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] = left[SList[A]](right, (lh, rh) => new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (_, f) => f(lh, concat(rh, right))\n  })\n\n  def empty(list: SList[_]): Boolean = list[Boolean](true, (_, _) => false)\n\n  def length(list: SList[_]): Int = list[Int](0, (_, t) => 1 + length(t))\n\n  def map[A, B](f: (A => B), list: SList[A]): SList[B] =\n    list.apply[SList[B]](nil[B], (h, t) => cons(f(h), map(f, t)))\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] =\n    listA.apply[SList[STuple[A, B]]](nil, (ah, at) => {\n      listB.apply[SList[STuple[A, B]]](nil, (bh, bt) => {\n        cons(fromTuple((ah, bh)), zip(at, bt))\n      })\n    })\n\n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B = list.apply[B](z, (h, t) => foldLeft(f, f(z, h), t))\n\n  def foldRight[A, B](f: ((A, B) => B), z: B, list: SList[A]): B = list.apply[B](z, (h, t) => f(h, foldRight(f, z, t)))\n\n  def take[A](n: Int, list: SList[A]): SList[A] = {\n    if (n == 0) nil[A]\n    else list.apply[SList[A]](nil[A], (h, t) => cons(h, take(n - 1, t)))\n  }\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = {\n    type T = STuple[SList[A], SList[B]]\n    list.apply[T](fromTuple((nil[A], nil[B])), (h, t) => {\n      partition(t).apply[T]((left, right) => {\n        h.apply[T](\n          lh => fromTuple((cons(lh, left), right)),\n          rh => fromTuple((left, cons(rh, right)))\n        )\n      })\n    })\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336514,"user_id":null,"body":"import scala.language.postfixOps\n\nobject Scott {\n  def badFun[A]: () => A = () => throw new NotImplementedError()\n  def identity[A] = (a: A) => a\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A = tuple.apply((a: A, _) => a)\n\n  def snd[B](tuple: STuple[_, B]): B = tuple.apply((_, b: B) => b)\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = (fst(tuple), snd(tuple))\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A, B] {\n    def apply[C] = f => f(tuple._1, tuple._2)\n  }\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = new STuple[B, A] {\n    def apply[C] = f => tuple.apply[C]((a, b) => f(b, a))\n  }\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C =\n    a => (b => f(fromTuple(a, b)))\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C =\n    tuple => f(fst(tuple))(snd(tuple))\n\n  def toOption[A](option: SOption[A]): Option[A] = {\n    try {\n      Some(option.apply(badFun[A](), identity))\n    } catch {\n      case _ => None\n    }\n  }\n\n  def fromOption[A](option: Option[A]): SOption[A] = option match {\n    case None => new SOption[A] {\n      def apply[B] = (z, _) => z\n    }\n    case Some(a) => new SOption[A] {\n      def apply[B] = (_, f) => f(a)\n    }\n  }\n\n  def isSome(option: SOption[_]): Boolean = toOption(option).isDefined\n\n  def isNone(option: SOption[_]): Boolean = toOption(option).isEmpty\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] =\n    try {\n      Right(either.apply(_ => badFun[B](), identity))\n    } catch {\n      case _ => Left(either.apply(identity, _ => badFun[A]()))\n    }\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = new SEither[A, B] {\n    def apply[C] = (left, right) =>\n      if (either.isLeft) left(either.left.get)\n      else right(either.getOrElse(badFun[B]()))\n  }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = toEither(either).isLeft\n\n  def isRight[A](either: SEither[A, _]): Boolean = toEither(either).isRight\n\n  def nil[A]: SList[A] = new SList[A] {\n    def apply[B] = (c, _) => c\n  }\n\n  def head[A](list: SList[A]): A = list.apply(badFun[A](), (head, _) => head)\n\n  def tail[A](list: SList[A]): SList[A] =\n    list.apply(badFun[SList[A]](), (_, tail) => tail)\n\n  def empty(list: SList[_]): Boolean =\n    try {\n      val test = list.apply(badFun[Int], (_, _) => 0)\n      test != 0\n    }\n    catch {\n      case _ => true\n    }\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    override def apply[B] = (_, f) => f(head, list)\n  }\n\n  def toList[A](list: SList[A]): List[A] =\n    if (empty(list)) Nil else head(list) :: toList(tail(list))\n\n  def fromList[A](list: List[A]): SList[A] = list match {\n    case Nil => nil[A]\n    case _ => cons(list.head, fromList(list.tail))\n  }\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] =\n    fromList(toList(list).filter(isSome).map(toOption(_) match {\n      case Some(a) => a\n    }))\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] =\n    fromList(toList(left).concat(toList(right)))\n\n  def length(list: SList[_]): Int = if (empty(list)) 0 else 1 + length(tail(list))\n\n  def map[A, B](f: (A => B), list: SList[A]): SList[B] =\n    fromList(toList(list).map(f))\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] =\n    fromList(toList(listA).zip(toList(listB)).map(fromTuple))\n\n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B =\n    toList(list).foldLeft(z)(f)\n\n  def foldRight[A, B](f: ((A, B) => B), z: B, list: SList[A]): B =\n    toList(list).foldRight(z)(f)\n\n  def take[A](n: Int, list: SList[A]): SList[A] =\n    fromList(toList(list).take(n))\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = {\n    val tupleList = toList(list).map(toEither).partition(_.isLeft)\n    val a = tupleList._1.map(_.left.get)\n    val b = tupleList._2.map(_.right.get)\n    fromTuple(fromList(a), fromList(b))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336515,"user_id":null,"body":"object Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = {\n    (tuple.apply)((a,b) => (a,b))\n  }\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = tuple match {\n    case (a, b) => new STuple[A, B] {\n      def apply[C]: ((A, B) => C) => C = (f) => f(a, b)\n    }\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A = (tuple.apply)((a,_) => a)\n\n  def snd[B](tuple: STuple[_, B]): B =  (tuple.apply)((_,b) => b)\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = new STuple[B, A] {\n    def apply[C]: ((B, A) => C) => C = (f) => (tuple.apply)((a, b) => f(b,a))\n  }\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C = (a) => (b) => f(fromTuple((a, b)))\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = (tuple) => (tuple.apply)((a, b) => f(a)(b))\n\n  def toOption[A](option: SOption[A]): Option[A] = {\n    (option.apply)(None, Some(_))\n  }\n\n  def fromOption[A](option: Option[A]): SOption[A] = option match {\n    case None => new SOption[A] {\n      def apply[B] = (z, _) => z\n    }\n    case Some(v)  => new SOption[A] {\n      def apply[B] = (_, f) => f(v)\n    }\n  }\n\n  def isSome(option: SOption[_]): Boolean = (option.apply)(false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean = (option.apply)(true, _ => false)\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] = (list.apply)(nil, (opt, xs) => {\n    val rest = catOptions(xs)\n    (opt.apply)(rest, (v) => cons(v, rest))\n  })\n    \n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = {\n    (either.apply)(Left(_), Right(_))\n  }\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = either match {\n    case Left(x) => new SEither[A, B] {\n      def apply[C]: (A => C, B => C) => C = (f, _) => f(x)\n    }\n    case Right(x) => new SEither[A, B] {\n      def apply[C]: (A => C, B => C) => C = (_, f) => f(x)\n    }\n  }\n  \n  def isLeft[A](either: SEither[A, _]): Boolean = (either.apply)( _ => true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean =  (either.apply)( _ => false, _ => true)\n\n  def nil[A]: SList[A] = new SList[A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B = (z, _) => z\n  }\n\n  def toList[A](list: SList[A]): List[A] = {\n    (list.apply) (List(), (el, rest) => el +: toList(rest))\n  }\n\n  def fromList[A](list: List[A]): SList[A] = list match {\n    case x :: xs => cons(x, fromList(xs))\n    case _ => nil\n  }\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B = (_, l) => l(head, list)\n  }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] = (left.apply)(right, (x, xs) => cons(x, concat(xs, right)))\n\n  def empty(list: SList[_]): Boolean = (list.apply)(true, (_,_) => false)\n\n  def length(list: SList[_]): Int = (list.apply) (0, (x, xs) => 1 + length(xs))\n\n  def map[A, B](f: (A => B), list: SList[A]): SList[B] = (list.apply)(nil, (x, xs) => cons(f(x), map(f, xs)))\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] = {\n    (listA.apply)(nil, (a, as) => {\n      (listB.apply)(nil, (b, bs) => {\n        val tuple = new STuple[A, B] {\n          def apply[C]: ((A, B) => C) => C = (f) => f(a, b)\n        }\n        cons(tuple, zip(as,bs))\n      })\n    })\n  }\n\n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B = (list.apply)(z, (x, xs) => foldLeft(f, f(z,x), xs))\n\n  def foldRight[A, B](f: ((A, B) => B), z: B, list: SList[A]): B = (list.apply)(z, (x, xs) => f(x, foldRight(f, z, xs)))\n                                                                                \n  def take[A](n: Int, list: SList[A]): SList[A] = {\n    if (n == 0)\n      nil\n    else\n      (list.apply)(list, (x, xs) => cons(x, take(n - 1, xs)))\n  }\n   \n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = {\n    def lefts(l: SList[SEither[A, B]]): SList[A] = (l.apply)(nil, (x, xs) => (x.apply) (cons(_, lefts(xs)), _ => lefts(xs)))\n    def rights(l: SList[SEither[A, B]]): SList[B] = (l.apply)(nil, (x, xs) => (x.apply) (_ => rights(xs), cons(_, rights(xs))))\n    \n    new STuple[SList[A], SList[B]] {\n      def apply[C]: ((SList[A], SList[B]) => C) => C = (f) => f(lefts(list), rights(list))\n    }\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336516,"user_id":null,"body":"object Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = tuple.apply((a, b) => (a, b))\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A, B] {\n    def apply[C]: ((A, B) => C) => C = f => f(tuple._1, tuple._2)\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A = tuple.apply((a, _) => a)\n\n  def snd[B](tuple: STuple[_, B]): B = tuple.apply((_, b) => b)\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] =\n    fromTuple(tuple.apply((a, b) => (b, a)))\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C =\n    a => b => f(fromTuple((a, b)))\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = tuple =>\n    tuple.apply((a, b) => f(a)(b))\n\n  def none[A]: SOption[A] = new SOption[A] {\n    def apply[B]: (=> B, A => B) => B = { case (none, _) => none }\n  }\n  \n  def some[A](a: A): SOption[A] = new SOption[A] {\n    def apply[B]: (=> B, A => B) => B = { case (_, some) => some(a) }\n  }\n  \n  def fromOption[A](option: Option[A]): SOption[A] = option.fold(none[A])(a => some(a))\n\n  def toOption[A](option: SOption[A]): Option[A] = option.apply(Option.empty[A], a => Some(a))\n\n  def isSome(option: SOption[_]): Boolean = option.apply(false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean = option.apply(true, _ => false)\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] =\n    list.apply(nil, (opt, l) => opt.apply(catOptions(l), a => cons(a, catOptions(l))))\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] =\n    either.apply(a => Left(a), b => Right(b))\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] =\n    new SEither[A, B] {\n      def apply[C]: (A => C, B => C) => C = { case (left, right) =>\n        either.fold(left, right)\n      }\n    }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = either.apply(_ => true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean = either.apply(_ => false, _ => true)\n\n  def nil[A]: SList[A] = new SList[A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B = { case (nil, _) => nil }\n  }\n\n  def toList[A](list: SList[A]): List[A] =\n    list[List[A]](List.empty[A], (a, l) => a :: toList(l))\n\n  def fromList[A](list: List[A]): SList[A] =\n    list.foldRight(nil[A])((a, l) => cons(a, l))\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B = { case (_, cons) => cons(head, list) }\n  }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] =\n    left.apply(right, (a, l) => cons(a, concat(l, right)))\n\n  def empty(list: SList[_]): Boolean = list.apply(true, (_, _) => false)\n\n  def length(list: SList[_]): Int = list.apply(0, (_, l) => 1 + length(l))\n\n  def map[A, B](f: (A => B), list: SList[A]): SList[B] =\n    list.apply(nil, (a, l) => cons(f(a), map(f, l)))\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] =\n    listA.apply(\n      nil,\n      (a, la) => listB.apply(nil, (b, lb) => cons(fromTuple((a, b)), zip(la, lb)))\n    )\n\n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B =\n    list.apply(z, (a, l) => foldLeft(f, f(z, a), l))\n\n  def foldRight[A, B](f: ((A, B) => B), z: B, list: SList[A]): B =\n    list.apply(z, (a, l) => f(a, foldRight(f, z, l)))\n\n  def take[A](n: Int, list: SList[A]): SList[A] =\n    list.apply(nil, (a, l) => if (n > 0) cons(a, take(n - 1, l)) else nil)\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] =\n    list.apply(\n      fromTuple(nil, nil),\n      (either, l) => {\n        val p = partition(l)\n        either.apply(\n          left => p.apply((a, b) => fromTuple(cons(left, a), b)),\n          right => p.apply((a, b) => fromTuple(a, cons(right, b)))\n        )\n      }\n    )\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336517,"user_id":null,"body":"object Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) =\n    tuple[(A, B)].apply((a: A, b: B) => (a, b))\n\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A, B] {\n    override def apply[C]: ((A, B) => C) => C = (f: (A, B) => C) => f(tuple._1, tuple._2)\n  }\n\n  def fst[A, B](tuple: STuple[A, B]): A =\n    tuple[A].apply((a: A, _: B) => a)\n\n  def snd[B](tuple: STuple[_, B]): B =\n    tuple[B].apply((_, b: B) => b)\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] =\n    fromTuple(toTuple(tuple).swap)\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C =\n    (a: A) => (b: B) => f(new STuple[A, B] {\n      override def apply[C]: ((A, B) => C) => C =\n        (g: (A, B) => C) => g(a, b)\n    })\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C =\n    (tuple: STuple[A, B]) => tuple[C]((a: A, b: B) => f(a)(b))\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  def toOption[A](option: SOption[A]): Option[A] =\n    option[Option[A]].apply(Option.empty[A], Some(_))\n\n\n  def fromOption[A](option: Option[A]): SOption[A] = new SOption[A] {\n    override def apply[B]: (=> B, A => B) => B =\n      (ifEmpty, f) => option.fold(ifEmpty)(f)\n  }\n\n  def isSome(option: SOption[_]): Boolean =\n    option[Boolean].apply(false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean =\n    option[Boolean].apply(true, _ => false)\n\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] =\n    either[Either[A, B]].apply(Left[A, B], Right[A, B])\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] =\n    new SEither[A, B] {\n      override def apply[C]: (A => C, B => C) => C =\n        (left: A => C, right: B => C) => either.fold(left, right)\n    }\n\n  def isLeft[A](either: SEither[A, _]): Boolean =\n    either[Boolean].apply(_ => true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean =\n    either[Boolean].apply(_ => false, _ => true)\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] =\n    list[SList[A]](nil[A], (h: SOption[A], t: SList[SOption[A]]) => {\n      h[SList[A]](catOptions(t), cons(_, catOptions(t)))\n    })\n\n  def nil[A]: SList[A] = new SList[A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B =\n      (b, _: (A, SList[A]) => B) => b\n  }\n\n  def toList[A](list: SList[A]): List[A] =\n    list[List[A]](List.empty[A], (h: A, t: SList[A]) => h :: toList(t))\n\n  def fromList[A](list: List[A]): SList[A] = list match {\n    case Nil => nil[A]\n    case h :: t => cons(h, fromList(t))\n  }\n\n  def cons[A](head: A, list: SList[A]): SList[A] =\n    new SList[A] {\n      override def apply[B]: (=> B, (A, SList[A]) => B) => B =\n        (_, f: (A, SList[A]) => B) => f(head, list)\n    }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] =\n    left[SList[A]](right, (lh: A, lt: SList[A]) => {\n      cons[A](lh, concat(lt, right))\n    })\n\n  def empty(list: SList[_]): Boolean =\n    list[Boolean](true, (_, _) => false)\n\n  def length(list: SList[_]): Int =\n    list[Int](0, (_, t) => 1 + length(t))\n\n  def map[A, B](f: A => B, list: SList[A]): SList[B] =\n    list[SList[B]](nil[B], (h, t) => cons(f(h), map(f, t)))\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] =\n    listA[SList[STuple[A, B]]](nil[STuple[A, B]],\n      (headA, tailA) => listB[SList[STuple[A, B]]](nil[STuple[A, B]],\n        (headB, tailB) => cons(fromTuple(headA, headB), zip(tailA, tailB))))\n\n  def foldLeft[A, B](f: (B, A) => B, z: B, list: SList[A]): B =\n    list[B](z, (h: A, t: SList[A]) => foldLeft(f, f(z, h), t))\n\n  def foldRight[A, B](f: (A, B) => B, z: B, list: SList[A]): B =\n    list[B](z, (h: A, t: SList[A]) => f(h, foldRight(f, z, t)))\n\n  def take[A](n: Int, list: SList[A]): SList[A] =\n    n match {\n      case 0 => nil[A]\n      case _ => list[SList[A]](nil[A], (h: A, t: SList[A]) => cons(h, take(n - 1, t)))\n    }\n\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = {\n    fromTuple(foldRight[SEither[A, B], (SList[A], SList[B])]({\n      case (t, (l, r)) => t.apply(h => (cons(h, l), r), h => (l, cons(h, r)))\n    }, (nil, nil), list))\n  }\n}","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336518,"user_id":null,"body":"object Scott {\n\n  \/\/ Tuple\n  \n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n  \n  def stuple[A, B](a: A, b: B): STuple[A, B] = new STuple[A, B] {\n    def apply[C] = f => f(a, b)\n  }\n  \n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = tuple.apply((a, b) => (a, b))\n  \n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = stuple(tuple._1, tuple._2)\n  \n  def fst[A, B](tuple: STuple[A, B]): A = tuple.apply((a, b) => a)\n  \n  def snd[B](tuple: STuple[_, B]): B = tuple.apply((a, b) => b)\n  \n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = new STuple[B, A] {\n    def apply[C] = f => tuple.apply((a, b) => f(b, a))\n  }\n  \n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C = (a: A) => (b: B) => f(new STuple[A, B] {\n    def apply[D] = f2 => f2(a, b)\n  })\n  \n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = t => t.apply((a, b) => f(a)(b))\n  \n  \/\/ Option\n  \n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n  \n  def toOption[A](option: SOption[A]): Option[A] = option.apply(Option.empty, Option.apply _)\n  \n  def fromOption[A](option: Option[A]): SOption[A] = option match {\n    case None => new SOption[A] {\n      def apply[B] = (n, _) => n\n    }\n    case Some(x) => new SOption[A] {\n      def apply[B] = (_, s) => s(x)\n    }\n  }\n  \n  def isSome(option: SOption[_]): Boolean = option.apply(false, _ => true)\n  \n  def isNone(option: SOption[_]): Boolean = option.apply(true, _ => false)\n  \n  \/\/ Either\n  \n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n  \n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = either.apply(Left.apply _, Right.apply _)\n  \n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = either match {\n    case Left(x) => new SEither[A, B] {\n      def apply[C] = (l, _) => l(x)\n    }\n    case Right(x) => new SEither[A, B] {\n      def apply[C] = (_, r) => r(x)\n    }\n  }\n  \n  def isLeft[A](either: SEither[A, _]): Boolean = either.apply(_ => true, _ => false)\n  \n  def isRight[A](either: SEither[A, _]): Boolean = either.apply(_ => false, _ => true)\n  \n  \/\/ List\n  \n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n  \n  def nil[A]: SList[A] = new SList[A] {\n    def apply[B] = (n, _) => n\n  }\n  \n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    def apply[B] = (_, c) => c(head, list)\n  }\n  \n  def toList[A](list: SList[A]): List[A] = list.apply(Nil, (h, t) => h :: toList(t))\n  \n  def fromList[A](list: List[A]): SList[A] = list match {\n    case Nil => nil\n    case h :: t => cons(h, fromList(t))\n  }\n  \n  def concat[A](left: SList[A], right: SList[A]): SList[A] = left.apply(right, (h, t) => cons(h, concat(t, right)))\n  \n  def catOptions[A](list: SList[SOption[A]]): SList[A] = list.apply(nil, (h, t) => h.apply(catOptions(t), x => cons(x, catOptions(t))))\n  \n  def empty(list: SList[_]): Boolean = list.apply(true, (_, _) => false)\n  \n  def length(list: SList[_]): Int = foldLeft((n: Int, _: Any) => n + 1, 0, list)\n  \n  def map[A, B](f: (A => B), list: SList[A]): SList[B] = list.apply(nil, (h, t) => cons(f(h), map(f, t)))\n  \n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] = listA.apply(nil, (ha, ta) => listB.apply(nil, (hb, tb) => cons(stuple(ha, hb), zip(ta, tb))))\n  \n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B = list.apply(z, (h, t) => foldLeft(f, f(z, h), t))\n  \n  def foldRight[A, B](f: ((A, B) => B), z: B, list: SList[A]): B = list.apply(z, (h, t) => f(h, foldRight(f, z, t)))\n  \n  def take[A](n: Int, list: SList[A]): SList[A] =\n    if (n > 0) list.apply(nil, (h, t) => cons(h, take(n - 1, t)))\n    else nil\n  \n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = foldRight(\n    (x: SEither[A, B], acc: STuple[SList[A], SList[B]]) => x.apply(\n      l => stuple(cons(l, fst(acc)), snd(acc)),\n      r => stuple(fst(acc), cons(r, snd(acc)))\n    ),\n    stuple(nil, nil),\n    list\n  )\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336519,"user_id":null,"body":"object Scott {\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = {\n    tuple.apply((A, B) => (A, B)).asInstanceOf[(A, B)]\n  }\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A, B] { override def apply[C] = f => f(tuple._1, tuple._2)}\n\n  def fst[A, B](tuple: STuple[A, B]): A =  tuple.apply((A, B) => A).asInstanceOf[A]\n\n  def snd[B](tuple: STuple[_, B]): B = tuple.apply((A, B) => B).asInstanceOf[B]\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = {\n    val newTuple = (snd(tuple), fst(tuple))\n    fromTuple(newTuple)\n  }\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C = {\n    def curried(a: A)(b: B) = f(fromTuple((a,b)))  \n    curried\n  }\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = {\n    val fv = f(_: A)(_: B)\n    val st = new STuple[A, B] { override def apply[C] = fv => fv.asInstanceOf[C]}\n    st => st.apply(fv).asInstanceOf[C]\n  }\n\n  def toOption[A](option: SOption[A]): Option[A] = {\n    val result = option.apply(null, A => A)\n    if (result != null) {\n      Some(result.asInstanceOf[A])\n    }\n    else {\n      None\n    }\n  }\n  \n  def fromOption[A](option: Option[A]): SOption[A] = {\n    option match {\n      case x if x == None => new SOption[A] {\n        def apply[B] = (z, _) => z\n      }\n      case other => new SOption[A] {\n        def apply[B] = (_, f) => f(other.get)\n      }\n    }\n  }\n\n  def isSome(option: SOption[_]): Boolean = !isNone(option)\n\n  def isNone(option: SOption[_]): Boolean = toOption(option) == None\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] = {\n    val result = list.apply(null, (A, B) => (A, B))\n      if (result != null) {\n        if(isSome(result._1)) {\n          new SList[A] { override def apply[B] = (_, g) => g(result._1.apply(null, A => A).asInstanceOf[A], catOptions(result._2)) }\n        }\n        else {\n          catOptions(result._2)\n        }\n      }\n      else {\n        nil[A]\n      }\n  }\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = {\n    val leftCheck = either.apply(A => null, B => B)\n    val result = either.apply(A => A, B => B)\n    if (leftCheck == null) {\n      Left(result.asInstanceOf[A])\n    }\n    else {\n      Right(result.asInstanceOf[B])\n    }\n  }\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = {\n    either match {\n      case Left(a) => new SEither[A, B] {\n        def apply[C] = (left, _) => left(a)\n      }\n      case Right(b) => new SEither[A, B] {\n        def apply[C] = (_, right) => right(b)\n      }\n    }\n  }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = either.apply(A => null, B => B) == null\n\n  def isRight[A](either: SEither[A, _]): Boolean = !isLeft(either)\n\n  def nil[A]: SList[A] = new SList[A] { override def apply[B] = (g, _) => g }\n\n  def toList[A](list: SList[A]): List[A] = {\n    val result = list.apply(null, (A, B) => (A, B))\n    if (result == null) {\n      List()\n    }\n    else {\n      List(result._1) ++ toList(result._2)\n    }\n    \n  }\n\n  def fromList[A](list: List[A]): SList[A] = {\n    list.length match {\n      case 0 => nil[A]\n      case 1 => new SList[A] { override def apply[B] = (_, g) => g(list.head, nil[A]) }\n      case other => new SList[A] { override def apply[B] = (_, g) => g(list.head, fromList(list.tail)) }\n    }\n  }\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] { override def apply[B] = (_, g) => g(head, list) }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] = {\n    val result = left.apply(null, (A, B) => (A, B))\n      if (result != null) {\n        new SList[A] { override def apply[B] = (_, g) => g(result._1, concat(result._2, right)) }\n      }\n      else {\n        right\n      }\n  }\n\n  def empty(list: SList[_]): Boolean = list.apply(null, (A, B) => (A, B)) == null\n\n  def length(list: SList[_]): Int = {\n    val result = list.apply(null, (A, B) => (A, B))\n    if (result == null) {\n      0\n    }\n    else {\n      1 + length(result._2)\n    }\n  }\n\n  def map[A, B](f: (A => B), list: SList[A]): SList[B] = {\n    val result = list.apply(null, (A, B) => (A, B))\n      if (result != null) {\n        new SList[B] { override def apply[B] = (_, g) => g(f(result._1), map(f, result._2)) }\n      }\n      else {\n        nil[B]\n      }\n  }\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] = {\n    val result1 = listA.apply(null, (A, B) => (A, B))\n    val result2 = listB.apply(null, (A, B) => (A, B))\n      if (result1 != null && result2 != null) {\n        new SList[STuple[A, B]] { override def apply[B] = (_, g) => g(fromTuple((result1._1, result2._1)), zip(result1._2, result2._2)) }\n      }\n      else {\n        nil[STuple[A, B]]\n      }\n  }\n\n  def foldLeft[A, B](f: ((B, A) => B), z: B, list: SList[A]): B = {\n    val result = list.apply(null, (A, B) => (A, B))\n      if (result != null) {\n        val newZ = f(z, result._1)\n        foldLeft(f, newZ, result._2)\n      }\n      else {\n        z\n      }\n  }\n\n  def foldRight[A, B](f: ((A, B) => B), z: B, list: SList[A]): B = {\n    val result = list.apply(null, (A, B) => (A, B))\n      if (result != null) {\n        val newZ = f(result._1, foldRight(f, z, result._2))\n        newZ\n      }\n      else {\n        z\n      }\n  }\n\n  def take[A](n: Int, list: SList[A]): SList[A] = {\n    if (n == 0) {\n      nil[A]\n    } \n    else {\n      val result = list.apply(null, (A, B) => (A, B))\n      if (result != null) {\n        new SList[A] { override def apply[B] = (_, g) => g(result._1, take(n-1, result._2)) }\n      }\n      else {\n        nil[A]\n      }\n    }\n  }\n  \n  def leftPart[A, B](list: SList[SEither[A, B]]): SList[A] = {\n    val result = list.apply(null, (A, B) => (A, B))\n    if (result != null) {\n      if (isLeft(result._1)) {\n        new SList[A] { override def apply[B] = (_, g) => g(result._1.apply(A => A, B => B).asInstanceOf[A], leftPart(result._2)) }\n      }\n      else {\n        leftPart(result._2)\n      }  \n    }\n    else {\n      nil[A]\n    }\n  }\n  \n  def rightPart[B, A](list: SList[SEither[B, A]]): SList[A] = {\n    val result = list.apply(null, (A, B) => (A, B))\n    if (result != null) {\n      if (isRight(result._1)) {\n        new SList[A] { override def apply[B] = (_, g) => g(result._1.apply(A => null, B => B).asInstanceOf[A], rightPart(result._2)) }\n      }\n      else {\n        rightPart(result._2)\n      }  \n    }\n    else {\n      nil[A]\n    }\n  }\n  \n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] = {\n    fromTuple((leftPart(list), rightPart(list)))\n  }\n}\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":336520,"user_id":468,"body":"object Scott {\n\n  def toTuple[A, B](tuple: STuple[A, B]): (A, B) = tuple[(A, B)]((l, r) => (l, r))\n\n\n  def swap[A, B](tuple: STuple[A, B]): STuple[B, A] = tuple[STuple[B, A]]((a, b) => {\n    new STuple[B, A] {\n      override def apply[C]: ((B, A) => C) => C = _ (b, a)\n    }\n  })\n\n  def fst[A, B](tuple: STuple[A, B]): A = tuple[A]((l, _) => l)\n\n  def snd[B](tuple: STuple[_, B]): B = tuple[B]((_, r) => r)\n\n  def curry[A, B, C](f: STuple[A, B] => C): A => B => C = a => b => f(new STuple[A, B] {\n    override def apply[V]: ((A, B) => V) => V = f => f(a, b)\n  })\n\n  def uncurry[A, B, C](f: A => B => C): STuple[A, B] => C = _[C]((t1, t2) => f(t1)(t2))\n\n  def toOption[A](option: SOption[A]): Option[A] = option[Option[A]](None, Some(_))\n\n  def isSome(option: SOption[_]): Boolean = option[Boolean](false, _ => true)\n\n  def isNone(option: SOption[_]): Boolean = option[Boolean](true, _ => false)\n\n  def fromOption[A](option: Option[A]): SOption[A] = new SOption[A] {\n    override def apply[B]: (=> B, A => B) => B = (z, f) => if (option.isEmpty) z else f(option.get)\n  }\n\n  def catOptions[A](list: SList[SOption[A]]): SList[A] = list[SList[A]](nil[A], (head, tail) => {\n    head[SList[A]](catOptions(tail), cons(_, catOptions(tail)))\n  })\n\n  def toEither[A, B](either: SEither[A, B]): Either[A, B] = either[Either[A, B]](Left(_), Right(_))\n\n  def fromEither[A, B](either: Either[A, B]): SEither[A, B] = new SEither[A, B] {\n    override def apply[C]: (A => C, B => C) => C = either.fold\n  }\n\n  def isLeft[A](either: SEither[A, _]): Boolean = either[Boolean](_ => true, _ => false)\n\n  def isRight[A](either: SEither[A, _]): Boolean = either[Boolean](_ => false, _ => true)\n\n  def toList[A](list: SList[A]): List[A] = list[List[A]](Nil, (head, tail) => head :: toList(tail))\n\n  def fromList[A](list: List[A]): SList[A] = list.foldRight(nil[A])(cons)\n\n  def nil[A]: SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (b, _) => b\n  }\n\n  def cons[A](head: A, list: SList[A]): SList[A] = new SList[A] {\n    override def apply[B]: (=> B, (A, SList[A]) => B) => B = (_, f) => f(head, list)\n  }\n\n  def concat[A](left: SList[A], right: SList[A]): SList[A] = left[SList[A]](right, (head, tail) => cons(head, concat(tail, right)))\n\n  def empty(list: SList[_]): Boolean = list[Boolean](true, (_, _) => false)\n\n  def length(list: SList[_]): Int = list[Int](0, (_, tail) => 1 + length(tail))\n\n  def map[A, B](f: A => B, list: SList[A]): SList[B] = list[SList[B]](nil[B], (head, tail) => cons(f(head), map(f, tail)))\n\n  def zip[A, B](listA: SList[A], listB: SList[B]): SList[STuple[A, B]] =\n    listA[SList[STuple[A, B]]](nil[STuple[A, B]], (aHead, aTail) => {\n      listB[SList[STuple[A, B]]](nil[STuple[A, B]], (bHead, bTail) => {\n        cons(fromTuple((aHead, bHead)), zip(aTail, bTail))\n      })\n    })\n\n  def foldLeft[A, B](f: (B, A) => B, z: B, list: SList[A]): B = list[B](z, (head, tail) => foldLeft(f, f(z, head), tail))\n\n  def foldRight[A, B](f: (A, B) => B, z: B, list: SList[A]): B = list[B](z, (head, tail) => f(head, foldRight(f, z, tail)))\n\n  def take[A](n: Int, list: SList[A]): SList[A] = if (n == 0) nil[A] else list[SList[A]](nil[A], (head, tail) => cons(head, take(n - 1, tail)))\n\n  def partition[A, B](list: SList[SEither[A, B]]): STuple[SList[A], SList[B]] =\n    list[STuple[SList[A], SList[B]]](fromTuple(nil[A], nil[B]),\n      (head, tail) => partition(tail)[STuple[SList[A], SList[B]]](\n        (leftList, rightList) => head[STuple[SList[A], SList[B]]](\n          leftHead => fromTuple(cons(leftHead, leftList), rightList), rightHead => fromTuple(leftList, cons(rightHead, rightList))\n        )\n      )\n    )\n\n  def fromTuple[A, B](tuple: (A, B)): STuple[A, B] = new STuple[A, B] {\n    override def apply[C]: ((A, B) => C) => C = f => f(tuple._1, tuple._2)\n  }\n\n  trait STuple[+A, +B] {\n    def apply[C]: ((A, B) => C) => C\n  }\n\n  trait SOption[+A] {\n\n    def apply[B]: (=> B, A => B) => B\n  }\n\n  trait SEither[+A, +B] {\n    def apply[C]: (A => C, B => C) => C\n  }\n\n  trait SList[+A] {\n    def apply[B]: (=> B, (A, SList[A]) => B) => B\n  }\n}\n\n","lang_id":49,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}]}