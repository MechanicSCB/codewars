{"50654ddff44f800200000004":[{"id":339698,"user_id":3046,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    return a * b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339699,"user_id":null,"body":"let multiply: (Double, Double) -> Double = { $0 * $1 }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339700,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    a * b\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339701,"user_id":null,"body":"func multiply(_ x: Double...) -> Double {\n    return x.reduce(1, *)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339702,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    return a *\u00a0b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339703,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n  var mult =  a * b\n  return mult\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339704,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    a \/ b\n  var answer = a*b\n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339705,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    a.truncatingRemainder(dividingBy: b) * 3\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339706,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n     return a * b\n  print(6,6)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339707,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    a \/ (1 \/ b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"513e08acc600c94f01000001":[{"id":339708,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n    func norm(_ n: Int) -> Int {\n      return min(255, max(0, n))\n    }\n    return String(format: \"%02X%02X%02X\", norm(r), norm(g), norm(b))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339709,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n    return [r,g,b].map { max(min($0,255),0) }.map { String.init(format: \"%02X\", $0) }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339710,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n  return String(format: \"%02X%02X%02X\", UInt8(clamping: r), UInt8(clamping: g), UInt8(clamping: b))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339711,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n  return String(format:\"%02X%02X%02X\",\n                r < 0 ? 0 : r > 255 ? 255 : r,\n                g < 0 ? 0 : g > 255 ? 255 : g,\n                b < 0 ? 0 : b > 255 ? 255 : b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339712,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n  return [r, g, b].map { String(format: \"%02X\", min(max($0, 0), 255)) }.joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339713,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n    func toHex(_ v: Int) -> String {\n        let s = String(format: \"%02X\", max(0, min(v, 255)))\n        return (s.count == 1 ? \"0\" : \"\") + s\n    }\n    return toHex(r) + toHex(g) + toHex(b) \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339714,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n    let convert = { (number: Int) -> String in\n        let number = String(UInt8(clamping: number), radix: 16)\n        return number.count == 1 ? \"0\\(number)\" : number\n    }\n    return \"\\(convert(r))\\(convert(g))\\(convert(b))\".uppercased()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339715,"user_id":null,"body":"func rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n    return [r, g, b].map {\n        String((\"0\" + String(UInt8(clamping: $0), radix: 16)).suffix(2)) \n    }.joined().uppercased()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339716,"user_id":null,"body":"\/** returns an rgb string\nr g and b are clamped to 0-255\n*\/\nfunc rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n    let red = String(format:\"%02X\", min(255, max(0, r)))\n    let gre = String(format:\"%02X\", min(255, max(0, g)))\n    let blu = String(format:\"%02X\", min(255, max(0, b)))\n    return red+gre+blu\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339717,"user_id":null,"body":"private func tohex(_ r: Int) -> String{\n    let re = r > 255 ? 255 : (r < 0 ? 0 : r)\n    let hex_r = String(re, radix: 16)\n    return hex_r.count == 1 ? \"0\"+hex_r.uppercased() : hex_r.uppercased()\n}\n\nfunc rgb(_ r: Int, _ g: Int, _ b: Int) -> String {\n\n    return (tohex(r)+tohex(g)+tohex(b))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"514b92a657cdc65150000006":[{"id":339718,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n  var sum = 0\n  for i in 0..<num {\n    if (i % 3 == 0 || i % 5 == 0) {\n      sum += i\n    }\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339719,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n  return (0..<num).filter { ($0 % 3 * $0 % 5) == 0 }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339720,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n  return (0..<num).filter { $0.isMultiple(of: 3) || $0.isMultiple(of: 5) }.reduce(.zero, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339721,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n  var n = (num - 1) \/ 3\n  let sumOf3 = 3 * n * (n + 1) \/ 2\n  n = (num - 1) \/ 5\n  let sumOf5 = 5 * n * (n + 1) \/ 2\n  n = (num - 1) \/ 15\n  let sumOf15 = 15 * n * (n + 1) \/ 2\n  let answer = sumOf3 + sumOf5 - sumOf15\n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339722,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n    return num < 3 ? 0 : (3..<num).filter({($0 % 3) * ($0 % 5) == 0}).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339723,"user_id":null,"body":"func solution(_ n: Int) -> Int {\n  return (((n - 1) \/ 3) * (3 + ((n - 1) \/ 3) * 3) \/ 2) + (((n - 1) \/ 5) * (5 + ((n - 1) \/ 5) * 5) \/ 2) - (((n - 1) \/ 15) * (15 + ((n - 1) \/ 15) * 15) \/ 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339724,"user_id":null,"body":"func solution(_ num: Int) -> Int {\nreturn (0 ..< num).filter({\n        int -> Bool in\n        int % 5 == 0 || int % 3 == 0\n    }).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339725,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n return (0..<num).filter{$0.isMultiple(of:3)||$0.isMultiple(of:5)}.reduce(0,+)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339726,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n  func f(_ n: Int, _ m: Int) -> Int {\n    let o = (n - 1) \/ m\n    return m * o * (o + 1) \/ 2\n  }\n  \n  return f(num, 3) + f(num, 5) - f(num, 15)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339727,"user_id":null,"body":"func solution(_ num: Int) -> Int {\n  guard num > 3 else {\n    return 0\n  }\n  \n  return (3..<num).reduce(0) {\n    $1 % 3 == 0 || $1 % 5 == 0 ? $0 + $1 : $0\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"515e188a311df01cba000003":[{"id":339728,"user_id":156,"body":"func get_planet_name(_ id: Int) -> String {\n  switch id {\n    case 1: return \"Mercury\"\n    case 2: return \"Venus\"\n    case 3: return \"Earth\"\n    case 4: return \"Mars\"\n    case 5: return \"Jupiter\"\n    case 6: return \"Saturn\"\n    case 7: return \"Uranus\"\n    case 8: return \"Neptune\"\n    default: return \"\"\n  } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339729,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  var name:String\n  switch id {\n    case 1: \n      name = \"Mercury\"\n    case 2: \n      name = \"Venus\"\n    case 3: \n      name = \"Earth\"\n    case 4: \n      name = \"Mars\"\n    case 5: \n      name = \"Jupiter\"\n    case 6: \n      name = \"Saturn\"\n    case 7: \n      name = \"Uranus\"\n    case 8: \n      name = \"Neptune\"\n    default:\n      name = \"\"\n  } \n  return name\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339730,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  return [\"Sun\", \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"][id]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339731,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n    var name: String\n    switch id {\n    case 1:\n        name = \"Mercury\"\n    case 2:\n        name = \"Venus\"\n    case 3:\n        name = \"Earth\"\n    case 4:\n        name = \"Mars\"\n    case 5:\n        name = \"Jupiter\"\n    case 6:\n        name = \"Saturn\"\n    case 7:\n        name = \"Uranus\"\n    case 8:\n        name = \"Neptune\"\n    default:\n        name = \"\"\n        return name\n    }\n    return name \/\/ <- Boom!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339732,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  let planets: [Int: String] = [\n    1: \"Mercury\", 2: \"Venus\",   3: \"Earth\",\n    4: \"Mars\",    5: \"Jupiter\", 6: \"Saturn\",\n    7: \"Uranus\",  8: \"Neptune\"\n  ]\n  if let ret = planets[id] {\n    return ret\n  } else {\n    return \"\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339733,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  return [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"\"][id-1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339734,"user_id":null,"body":"func get_planet_name(_ numberOfPlanet:Int) -> String {\n    return [\"Mercury\", \"Venus\", \"Earth\",\n            \"Mars\", \"Jupiter\", \"Saturn\",\n            \"Uranus\", \"Neptune\"][numberOfPlanet - 1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339735,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  var name = \"\"\n  switch id {\n    case 1: \n      name = \"Mercury\"\n    case 2: \n      name = \"Venus\"\n    case 3: \n      name = \"Earth\"\n    case 4: \n      name = \"Mars\"\n    case 5: \n      name = \"Jupiter\"\n    case 6: \n      name = \"Saturn\"\n    case 7: \n      name = \"Uranus\"\n    case 8: \n      name = \"Neptune\"\n    default:\n      name = \"\"\n  } \n  return name\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339736,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  \/\/var name:String\n  switch id {\n    case 1: return \"Mercury\"\n    case 2: return \"Venus\"\n    case 3: return \"Earth\"\n    case 4: return \"Mars\"\n    case 5: return \"Jupiter\"\n    case 6: return \"Saturn\"\n    case 7: return \"Uranus\"\n    case 8: return \"Neptune\"\n    default: return \"\"\n  } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339737,"user_id":null,"body":"func get_planet_name(_ id: Int) -> String {\n  switch id {\n    case 1: \n      return \"Mercury\"\n    case 2: \n      return \"Venus\"\n    case 3: \n      return \"Earth\"\n    case 4: \n      return \"Mars\"\n    case 5: \n      return \"Jupiter\"\n    case 6: \n      return \"Saturn\"\n    case 7: \n      return \"Uranus\"\n    case 8: \n      return \"Neptune\"\n    default:\n      return \"Not a planet\"\n  } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"515e271a311df0350d00000f":[{"id":339738,"user_id":53,"body":"func square_sum(_ vals: [Int]) -> Int {\n  return vals.reduce(0) { $0 + $1 * $1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339739,"user_id":527,"body":"func square_sum(_ vals:[Int]) -> Int {\n  vals.map{ $0 * $0 }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339740,"user_id":null,"body":"func square_sum(_ vals: [Int]) -> Int {\n  \n  var result = 0\n  \n  for x in vals {\n    result += x*x \n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339741,"user_id":null,"body":"func square_sum(_ vals: [Int]) -> Int {\n  var a = 0\n  for i in 0..<vals.count {\n    a += (vals[i] * vals[i])\n  }\n  return a\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339742,"user_id":null,"body":"func square_sum(_ vals: [Int]) -> Int {\n  var total = 0\n  for val in vals {\n    total += (val * val)\n  }\n  return total\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339743,"user_id":null,"body":"func square_sum(_ vals:[Int]) -> Int {\n    return vals.map{$0*$0}.reduce(0,+) \/\/ :)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339744,"user_id":null,"body":"func square_sum(_ vals: [Int]) -> Int {\n  return vals.map{$0*$0}.reduce(0, {x,y in x+y})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339745,"user_id":null,"body":"func square_sum(_ vals: [Int]) -> Int {\n  var sum = 0\n  for v in vals {\n    sum += (v*v)\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339746,"user_id":null,"body":"func square_sum(_ vals: [Int]) -> Int { vals.reduce(0) { $0 + Int(pow(Double($1), 2)) } }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339747,"user_id":168,"body":"func square_sum(_ vals: [Int]) -> Int {\n  vals.reduce(0, {s, x in s + x * x})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"515f51d438015969f7000013":[{"id":339748,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n  return (0..<n).map { Array(repeating: 1, count: $0+1) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339749,"user_id":564,"body":"func pyramid(_ n: Int) -> [[Int]] {\n  return n <= 0\n    ? []\n    : (1...n).map { Array(repeating: 1, count: $0) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339750,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n  guard n > 0 else { return [] }\n\t\n\tvar result: [[Int]] = []\n\tfor count in 1...n {\n\t\tresult.append([Int](repeating: 1, count: count))\n\t}\n\t\n\treturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339751,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n    var pyramid = [[Int]]()\n    \n    for level in 0..<n {\n        let arrayLevel = Array(repeating: 1, count: level + 1)\n        pyramid.append(arrayLevel)\n    }\n\n    return  pyramid\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339752,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n    return Array(0..<n).map({Array(repeating: 1, count: $0+1)})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339753,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n    if n == 0 { return [] }\n    if n == 1 { return [[1]] }\n    return pyramid(n-1) + [Array(repeating: 1, count: n)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339754,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n  return (0..<n).map{ (0...$0).map{ _ in 1 } }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339755,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n    \n    var result: [[Int]] = []\n    \n    for i in 0..<n {\n        result.append(Array(repeating: 1, count: i+1))\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339756,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n   let element = 1\n    var i = 1\n    var finalArray = [Int]()\n    var secondArray = [[Int]]()\n    while i < n + 1 {\n        finalArray.append(element)\n        secondArray.append(finalArray)\n        i += 1\n    }\n    return secondArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339757,"user_id":null,"body":"func pyramid(_ n: Int) -> [[Int]] {\n  guard n > 0 else { return [[Int]]() }\n  var pyramid = [[Int]]()\n  \n  for i in 1...n {\n    var row = Array(repeating: 1, count: i)\n    pyramid.append(row)\n  }\n  \n  return pyramid\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5168bb5dfe9a00b126000018":[{"id":339758,"user_id":null,"body":"func reverse(_ str: String) -> String {\n    return String(str.reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339759,"user_id":null,"body":"func reverse(_ str: String) -> String {\nvar reverse = \"\"\n for s in str {\n   reverse = String(s) + reverse\n }\n    return reverse\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339760,"user_id":null,"body":"func reverse(_ str: String) -> String {\n    return str.reduce(\"\") { \"\\($1)\" + $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339761,"user_id":null,"body":"func reverse(_ str: String) -> String {\n  String(str.reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339762,"user_id":null,"body":"func reverse(_ str: String) -> String {\n    \n    var buffArray:[Character] = []\n    var result = String()\n    \n    for i in str {\n        buffArray.append(i)\n    }\n    buffArray.reverse()\n    \n    for i in buffArray {\n        result.append(i)\n    }\n   \n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339763,"user_id":null,"body":"func reverse(_ str: String) -> String {\n    let final = String(str.reversed())\n    return final\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339764,"user_id":null,"body":"func reverse(_ str: String) -> String {\n\n    let reversedString = String(str.reversed())\n    return reversedString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339765,"user_id":null,"body":"func reverse(_ str: String) -> String {\n    var ret = \"\";\n    for ch in str {\n      ret = \"\\(ch)\" + ret;\n    }\n    return ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339766,"user_id":null,"body":"func reverse(_ str: String) -> String {\n  var originalStr: String = str\n  var reversedStr: String = \"\"\n  while originalStr.count > 0 {\n    reversedStr.append(originalStr.popLast()!)}\n  return reversedStr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339767,"user_id":null,"body":"func reverse(_ str: String) -> String {\n  let array: [String] = Array(str).map{String( $0 )}.reversed()\n    return array.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"51b6249c4612257ac0000005":[{"id":339768,"user_id":null,"body":"func value(of numeral: Character) -> Int? {\n    switch numeral {\n    case \"I\": return 1\n    case \"V\": return 5\n    case \"X\": return 10\n    case \"L\": return 50\n    case \"C\": return 100\n    case \"D\": return 500\n    case \"M\": return 1000\n    default: return nil\n    }\n}\n\nfunc solution(_ string: String) -> Int {\n    let numerals = string.characters.flatMap(value)\n    let sum = numerals.reduce(0, +)\n    \n    let difference = zip(numerals, numerals.dropFirst())\n        .filter(<)\n        .map { $0.0 }\n        .reduce(0, +)\n    \n    return sum - difference * 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339769,"user_id":null,"body":"import Foundation\n\nfunc solution(_ string:String) -> Int {\n    let table: [Character: Int] = [\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000]\n    var p = 0\n    let transform: (Character) -> Int = {\n        let result = table[$0]!\n        if result > p { p = result }\n        return result < p ? -result : result\n    }\n    return string.characters.reversed().map(transform).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339770,"user_id":null,"body":"import Foundation\n\n\/\/ My first task is to understand how roman numerals work\n\/\/ Each symbol has an associated value\n\/\/ Combining a smaller symbol A before a larger symbol B\n\/\/ subtracts A from B to get that digit\n\/\/ Combining two symbols of the same value adds them for a digit\n\/\/ Reading left to right, if we encounter a larger symbol after a smaller\n\/\/ symbol, we can subtract the smaller symbol from the larger before adding\n\n\/\/ Make a dictionary with the each symbol and it's decimal value\nlet symbolValues: [Character: Int] = [\"I\": 1,\n                                      \"V\": 5,\n                                      \"X\": 10,\n                                      \"L\": 50,\n                                      \"C\": 100,\n                                      \"D\": 500,\n                                      \"M\": 1000,]\n\nfunc solution(_ string:String) -> Int {\n    var result = 0\n    \n    let charArray = Array(string) \/\/ convert string to array of characters for ease of use\n    \n    var i = 0\n    \n    while i < charArray.count {\n        \/\/ Grab value of current symbol\n        guard let value = symbolValues[charArray[i]] else { continue }\n        \n        \/\/ Check to see if the next symbol is of larger value than the current one\n        if i + 1 < charArray.count, let nextValue = symbolValues[charArray[i + 1]], nextValue > value {\n            result += nextValue - value \/\/ If so, subtract current from next and add to result\n            i += 2\n        } else {\n            result += value \/\/ Otherwise, just add the current value\n            i += 1\n        }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339771,"user_id":null,"body":"import Foundation\n\nfunc solution(_ string:String) -> Int {\n  return string\n    .replacingOccurrences(of: \"CM\", with: \"DCD\")\n    .replacingOccurrences(of: \"M\", with: \"DD\")\n    .replacingOccurrences(of: \"CD\", with: \"CCCC\")\n    .replacingOccurrences(of: \"D\", with: \"CCCCC\")\n    .replacingOccurrences(of: \"XC\", with: \"LXL\")\n    .replacingOccurrences(of: \"C\", with: \"LL\")\n    .replacingOccurrences(of: \"XL\", with: \"XXXX\")\n    .replacingOccurrences(of: \"L\", with: \"XXXXX\")\n    .replacingOccurrences(of: \"IX\", with: \"VIV\")\n    .replacingOccurrences(of: \"X\", with: \"VV\")\n    .replacingOccurrences(of: \"IV\", with: \"IIII\")\n    .replacingOccurrences(of: \"V\", with: \"IIIII\")\n    .characters.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339772,"user_id":null,"body":"import Foundation\n\nenum RomanNumeral: String {\n\tcase m, d, c, l, x, v, i\n\n\tvar value: Int {\n\t\tswitch self {\n\t\tcase .m: return 1000\n\t\tcase .d: return 500\n\t\tcase .c: return 100\n\t\tcase .l: return 50\n\t\tcase .x: return 10\n\t\tcase .v: return 5\n\t\tcase .i: return 1\n\t\t}\n\t}\n}\n\nextension String {\n\tvar decodeRomanNumerals: Int {\n\t\treturn lowercased()\n\t\t\t.characters\n\t\t\t.reversed()\n\t\t\t.map { RomanNumeral(rawValue: String($0))?.value ?? 0 }\n\t\t\t.reduce((total: 0, max: 0)) { result, value in\n\t\t\t\tlet newTotal = result.total + (value < result.max ? -value : value)\n\t\t\t\treturn (newTotal, max(result.max, value))\n\t\t\t}\n\t\t\t.total\n\t}\n}\n\nfunc solution(_ string:String) -> Int {\n  return string.decodeRomanNumerals\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339773,"user_id":null,"body":"import Foundation\n\nfunc solution(_ string:String) -> Int {\n    let symbols : [Character : Int] = [\"M\":1000, \"D\" : 500, \"C\" : 100, \"L\":50, \"X\":10, \"V\":5, \"I\":1]\n    var previous = 0\n    var number = 0\n    for letter in string {\n        number +=  symbols[letter]! - (previous < symbols[letter]! ? 2*previous : 0)\n        previous = symbols[letter]!\n    }\n    return number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339774,"user_id":null,"body":"let romanSybol: [Character: Int] = [ \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000]\nfunc solution(_ string:String) -> Int {\n    let arr = string.map{ romanSybol[$0]! }\n    var ret = arr.last!\n    (0..<(arr.count - 1)).map{\n        ret += (arr[$0] >= arr[$0 + 1]) ? arr[$0] : -arr[$0]\n    }\n    return ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339775,"user_id":null,"body":"import Foundation\n\nfunc solution(_ string:String) -> Int {\n\tlet symbol = [\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, \"\": 0]\n\tvar result = 0\n\tvar maxValue = 0\n\tstring.uppercased().reversed().forEach {\n\t\tlet value = symbol[String($0)] ?? 0\n\t\tmaxValue = max(value, maxValue)\n\t\tresult += value == maxValue ? value : -value\n\t}\n\treturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339776,"user_id":null,"body":"import Foundation\n\nfunc solution(_ string:String) -> Int {\n    let value: (Character) -> Int = {\n        return [\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000][$0]!\n    }\n    var sum = value(string.last!)\n    string.sorted {\n        sum += value($1) >= value($0) ? value($1) : -value($1)\n        return false\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339777,"user_id":null,"body":"import Foundation\n\nlet valuesDict: [Character: Int] = [\n    \"I\": 1,\n    \"V\": 5,\n    \"X\": 10,\n    \"L\": 50,\n    \"C\": 100,\n    \"D\": 500,\n    \"M\": 1000\n]\n\nfunc solution(_ string: String) -> Int {\n    var previousValue = 0\n    return Array(string)\n        .reduce(0) { partialResult, character in\n            let currentValue = (valuesDict[character] ?? 0)\n            let correctionValue = previousValue < currentValue ? 2 * previousValue : 0\n            previousValue = currentValue\n            return partialResult + currentValue - correctionValue\n        }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"51b62bf6a9c58071c600001b":[{"id":339778,"user_id":2387,"body":"func solution(_ number:Int) -> String {\n    var num = number, result = \"\"\n    _ = [(1000,\"M\"),(900,\"CM\"),(500,\"D\"),(400,\"CD\"),(100,\"C\"),(90,\"XC\"),\n         (50,\"L\"),(40,\"XL\"),(10,\"X\"),(9,\"IX\"),(5,\"V\"),(4,\"IV\"),(1,\"I\")\n        ].map({val,symbol in while num - val >= 0 {num -= val; result += symbol}})\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339779,"user_id":null,"body":"func solution(_ number:Int) -> String {\n  let roman = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\n  , arabic = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n  var number = number, r = \"\"\n  while number > 0 {\n    for (i,v) in arabic.enumerated(){\n      if v <= number { r += roman[i]; number -= v; break }\n    }\n  }\n  return r\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339780,"user_id":null,"body":"func solution(_ number:Int) -> String {\n    var n = number\n    var result = \"\"\n    let romanNumerals = [( 1000,    \"M\"),\n                         (  900,   \"CM\"),\n                         (  500,    \"D\"),\n                         (  400,   \"CD\"),\n                         (  100,    \"C\"),\n                         (   90,   \"XC\"),\n                         (   50,    \"L\"),\n                         (   40,   \"XL\"),\n                         (   10,    \"X\"),\n                         (    9,   \"IX\"),\n                         (    5,    \"V\"),\n                         (    4,   \"IV\"),\n                         (    1,    \"I\")]\n    \n    for (v, l) in romanNumerals {\n        while n >= v {\n            result += l\n            n -= v\n        }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339781,"user_id":null,"body":"func solution(_ number: Int) -> String {\n  var tempNumber: Int = number\n  var resultString: String = \"\"\n  while tempNumber > 0 {\n    if tempNumber >= 1000 {\n      resultString += \"M\"\n      tempNumber -= 1000\n    } else if tempNumber >= 900 {\n      resultString += \"CM\"\n      tempNumber -= 900\n    } else if tempNumber >= 500 {\n      resultString += \"D\"\n      tempNumber -= 500\n    } else if tempNumber >= 400 {\n      resultString += \"CD\"\n      tempNumber -= 400\n    } else if tempNumber >= 100 {\n      resultString += \"C\"\n      tempNumber -= 100\n    } else if tempNumber >= 90 {\n      resultString += \"XC\"\n      tempNumber -= 90\n    } else if tempNumber >= 50 {\n      resultString += \"L\"\n      tempNumber -= 50\n    } else if tempNumber >= 40 {\n      resultString += \"XL\"\n      tempNumber -= 40\n    } else if tempNumber >= 10 {\n      resultString += \"X\"\n      tempNumber -= 10\n    } else if tempNumber == 9 {\n      resultString += \"IX\"\n      tempNumber -= 9\n    } else if tempNumber >= 5 {\n      resultString += \"V\"\n      tempNumber -= 5\n    } else if tempNumber == 4 {\n      resultString += \"IV\"\n      tempNumber -= 4\n    } else if tempNumber >= 1 {\n      resultString += \"I\"\n      tempNumber -= 1\n    }\n  }\n\n  return resultString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339782,"user_id":null,"body":"func solution(_ number:Int) -> String {\n    let arabik = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let Roman = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    var temp: Int = number\n    var result = \"\"\n    for i in 0...arabik.count - 1 {\n                \n            while temp\/arabik[i] >= 1 {\n                temp = temp - arabik[i]\n                result += Roman[i]\n             }\n        }\n    return result \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339783,"user_id":null,"body":"var romanLetters = [\n  1000: \"M\",\n  900: \"CM\",\n  500: \"D\",\n  400: \"CD\",\n  100: \"C\",\n  90: \"XC\",\n  50: \"L\",\n  40: \"XL\",\n  10: \"X\",\n  9: \"IX\",\n  5: \"V\",\n  4: \"IV\",\n  1: \"I\"\n]\n\nfunc solution(_ number: Int) -> String {\n  var n = number\n  var result = \"\"\n \n  while(n > 0) {\n    for roman in romanLetters.sorted( by: { $0.0 > $1.0 }) {\n      if n >= roman.key {\n        n -= roman.key\n        result += roman.value\n        break\n      }\n    }\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339784,"user_id":null,"body":"func solution(_ number:Int) -> String {\n    var num = number, res = \"\"\n    _ = [(1000,\"M\"),(900,\"CM\"),(500,\"D\"),(400,\"CD\"),(100,\"C\"),(90,\"XC\"),(50,\"L\"),(40,\"XL\"),(10,\"X\"),(9,\"IX\"),(5,\"V\"),(4,\"IV\"),(1,\"I\")].map({v,s in while num - v >= 0 {num -= v; res += s}})\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339785,"user_id":null,"body":"func solution(_ number:Int) -> String {\n  let numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  let symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n  \n  func recursion(_ number: Int, result: String, index: Int) -> String {\n    guard number > 0, index < numbers.count else { return result }\n    \n    if number - numbers[index] >= 0 {\n      return recursion(number - numbers[index], result: result + symbols[index], index: index)\n    } else {\n      return recursion(number, result: result, index: index + 1)\n    }\n  }\n  \n  return recursion(number, result: \"\", index: 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339786,"user_id":null,"body":"func solution(_ number:Int) -> String {\n var str = \"\"\n\tvar ratus = 0\n\tvar puluh = 0\n\tvar satuan = 0\n\t\n\tif(number >= 1000 && number < 4000){\n\t\tlet rb = number \/ 1000\n\t\tfor _ in 0...(rb - 1){\n\t\t\tstr = str + \"M\"\n\t\t}\n\t\t\n\t\tratus = number - ( rb  * 1000)\n\t}\n\t\n\tif (number >= 100 && number < 1000){\n\t\tratus = number\n\t}\n\t\n\tif( ratus > 0){\n\t\tlet rt = ratus \/ 100\n\t\t\n\t\tif(rt == 1){\n\t\t\tstr = str + \"C\"\n\t\t}\n\t\t\n\t\tif(rt == 4){\n\t\t\tstr = str + \"CD\"\n\t\t}\n\t\t\n\t\tif(rt == 5){\n\t\t\tstr = str + \"D\"\n\t\t}\n\t\t\n\t\tif(rt == 9){\n\t\t\tstr = str + \"CM\"\n\t\t}\n\t\t\n\t\tif(rt > 1 && rt < 4){\n\t\t\tfor _ in 0...(rt - 1){\n\t\t\t\tstr = str + \"C\"\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(rt > 5 && rt < 9){\n\t\t\tstr = str + \"D\"\n\t\t\tfor _ in 0...((rt - 5) - 1){\n\t\t\t\tstr = str + \"C\"\n\t\t\t}\n\t\t}\n\t\t\n\t\tpuluh = ratus - ( rt * 100)\n\t}\n\t\n\tif( number >= 10 && number < 100){\n\t\tpuluh = number\n\t}\n\t\n\tif(puluh > 0){\n\t\tlet pl = puluh \/ 10\n\t\tif( pl == 1){\n\t\t\tstr = str + \"X\"\n\t\t}\n\t\t\n\t\tif(pl == 4){\n\t\t\tstr = str + \"XL\"\n\t\t}\n\t\t\n\t\tif(pl == 5){\n\t\t\tstr = str + \"L\"\n\t\t}\n\t\t\n\t\tif(pl == 9){\n\t\t\tstr = str + \"XC\"\n\t\t}\n\t\t\n\t\tif(pl > 1 && pl < 4){\n\t\t\tfor _ in 0...(pl - 1){\n\t\t\t\tstr = str + \"X\"\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pl > 5 && pl < 9){\n\t\t\tstr = str + \"L\"\n\t\t\tfor _ in 0...((pl - 5) - 1){\n\t\t\t\tstr = str + \"X\"\n\t\t\t}\n\t\t}\n\t\t\n\t\tsatuan = puluh - ( pl * 10)\n\t}\n\t\n\tif(number > 0 && number < 10){\n\t\tsatuan = number\n\t}\n\t\n\tif(satuan > 0){\n\t\tif(satuan == 1){\n\t\t\tstr = str + \"I\"\n\t\t}\n\t\t\n\t\tif(satuan == 4){\n\t\t\tstr = str + \"IV\"\n\t\t}\n\t\t\n\t\tif(satuan == 5){\n\t\t\tstr = str + \"V\"\n\t\t}\n\t\t\n\t\tif(satuan == 9){\n\t\t\tstr = str + \"IX\"\n\t\t}\n\t\t\n\t\tif(satuan > 1 && satuan < 4){\n\t\t\tfor _ in 0...(satuan - 1){\n\t\t\t\tstr = str + \"I\"\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(satuan > 5 && satuan < 9){\n\t\t\tstr = str + \"V\"\n\t\t\t\n\t\t\tfor _ in 0...((satuan - 5) - 1){\n\t\t\t\tstr = str + \"I\"\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339787,"user_id":null,"body":"func solution(_ number:Int) -> String {\n    var int = number\n    var numeralString = \"\"\n    let mappingList: [(arabic: Int, roman: String)] = [(arabic: 1000, roman: \"M\"), (arabic: 900, roman: \"CM\"), (arabic: 500, roman: \"D\"), (arabic: 400, roman: \"CD\"), (arabic: 100, roman: \"C\"), (arabic: 90, roman: \"XC\"), (arabic: 50, roman: \"L\"), (arabic: 40, roman: \"XL\"), (arabic: 10, roman: \"X\"), (arabic: 9, roman: \"IX\"), (arabic: 5, roman: \"V\"), (arabic: 4, roman: \"IV\"), (arabic: 1, roman: \"I\")]\n    for i in mappingList {\n        while (int >= i.arabic) {\n            int -= i.arabic\n            numeralString.append(i.roman)\n        }\n    }\n    return numeralString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"51b66044bce5799a7f000003":[{"id":339788,"user_id":null,"body":"class RomanNumerals {\n    static func to_roman(_ number: Int) -> String {\n        var result = \"\"\n        let items = [(1000,\"M\"), (900,\"CM\"), (500,\"D\"), (400,\"CD\"), (100,\"C\"), (90,\"XC\"), (50,\"L\"), (40,\"XL\"), (10,\"X\"), (9,\"IX\"), (5,\"V\"), (4,\"IV\"), (1,\"I\")]\n        var number = number\n        \n        items.forEach {\n            while number - $0.0 >= 0 {\n                number -= $0.0\n                result += $0.1\n            }\n        }\n\n        return result\n    }\n    \n    static func from_roman(_ roman: String) -> Int {\n        var result = 0\n        var index = 0\n        let items = [\"M\": 1000, \"CM\": 900, \"D\": 500, \"CD\": 400, \"C\": 100, \"XC\": 90, \"L\": 50, \"XL\": 40, \"X\": 10, \"IX\": 9, \"V\": 5, \"IV\": 4, \"I\": 1]\n        let roman = roman.compactMap { $0 }\n        \n        while index < roman.count {\n            if index < roman.count - 1 {\n                let double = \"\\(roman[index])\\(roman[index + 1])\"\n                \n                if items[double] != nil {\n                    result += items[double]!\n                    index += 2\n                    continue\n                }\n            }\n            \n            result += items[\"\\(roman[index])\"]!\n            index += 1\n        }\n        \n        return result\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339789,"user_id":null,"body":"class RomanNumerals {\n\n  static func to_roman(_ num: Int) -> String {\n    var num = num\n    var result = \"\"\n    var numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var romanNumbers = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    for el in 0..<13 {\n        if num \/ numbers[el] > 0 {\n            for j in 1...num \/ numbers[el] {\n                result += romanNumbers[el]\n            }\n            num %= numbers[el]\n        }\n    }\n    return result  \n}\n  \n  static func from_roman(_ string: String) -> Int {\n    var val = 0, arr = [Character]()\n    string.forEach {arr.append($0)}\n    for (ind, el) in arr.enumerated() {\n        switch el {\n            case \"I\": val += 1\n            case \"V\": if ind != 0, arr[ind - 1] == \"I\" {val += 3 } else { val += 5 }\n            case \"X\": if ind != 0, arr[ind - 1] == \"I\" {val += 8} else {val += 10 }\n            case \"L\": if ind != 0, arr[ind - 1] == \"X\" {val += 30} else {val += 50 }\n            case \"C\": if ind != 0, arr[ind - 1] == \"X\" {val += 80} else {val += 100}\n            case \"D\": if ind != 0, arr[ind - 1] == \"C\" {val += 300} else {val += 500}\n            case \"M\": if ind != 0, arr[ind - 1] == \"C\" {val += 800} else {val += 1000}\n            default: val += 0\n        }\n    }\n    return val\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339790,"user_id":null,"body":"class RomanNumerals {\n    static func to_roman(_ number: Int) -> String {\n        let romanDigits = [1:\"I\", 4:\"IV\", 5:\"V\", 9:\"IX\", 10:\"X\", 40:\"XL\", 50:\"L\", 90:\"XC\", 100:\"C\", 400:\"CD\", 500:\"D\", 900:\"CM\", 1000:\"M\"]\n        var left = number\n        var ans = String()\n        while left > 0 {\n            let curr = romanDigits.sorted{$0.key < $1.key}.last{$0.key <= left}!\n            left -= curr.key\n            ans += curr.value\n        }\n        return ans\n    }\n    static func from_roman(_ roman: String) -> Int {\n        return (1..<4000).first{to_roman($0) == roman}!\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339791,"user_id":null,"body":"class RomanNumerals {\n    \n    private static let romans = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\n    private static let arabics = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n    \n    static func to_roman(_ number: Int) -> String {\n        var n = number\n        var result = \"\"\n        while n > 0 {\n            let digitEntry = arabics.enumerated().filter { $0.element <= n }.max { $0.element < $1.element }!\n            let index = digitEntry.offset\n            let digit = digitEntry.element\n            result += romans[index]\n            n -= digit\n        }\n        return result\n    }\n    \n    static func from_roman(_ roman: String) -> Int {\n        let digits = roman.map { String($0) }.map { character -> Int in\n            let index = romans.enumerated().first { $0.element == character }.map { $0.offset }!\n            return arabics[index]\n        }\n        \n        var arabic = digits.first!\n        (1..<digits.count).forEach { index in\n            let previous = digits[index - 1]\n            let current = digits[index]\n            if previous < current {\n                arabic += current - 2 * previous\n            } else {\n                arabic += current\n            }\n        }\n        \n        return arabic\n    }\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339792,"user_id":null,"body":"class RomanNumerals {\n\n    static func to_roman(_ number: Int) -> String {\n        var n = (arabic: number, roman: \"\")\n        let _ = [(1000,\"M\"), (900,\"CM\"), (500,\"D\"), (400,\"CD\"), (100,\"C\"), (90,\"XC\"),\n                 (50,\"L\"), (40,\"XL\"), (10,\"X\"), (9,\"IX\"), (5,\"V\"), (4,\"IV\"), (1,\"I\")]\n            .forEach {\n                while n.arabic - $0.0 >= 0 {\n                    n = (n.arabic - $0.0, n.roman + $0.1)\n                }\n            }\n        \n        return n.roman\n    }\n    \n    static func from_roman(_ roman: String) -> Int {\n        return (1..<4000).first{to_roman($0) == roman}!\n    }\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339793,"user_id":null,"body":"class RomanNumerals {\n\n  static func to_roman(_ number: Int) -> String {\n    let decimals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    let numerals = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    \n    var result = \"\"\n    var number = number\n    \n    while number > 0\n    {\n        for (index, decimal) in decimals.enumerated()\n        {\n            if number - decimal >= 0 {\n                number -= decimal\n                result += numerals[index]\n                break\n            }\n        }\n    }\n    \n    return result\n  }\n  \n  static func from_roman(_ roman: String) -> Int {\n    let romanToInt: [Character: Int] = [\n        \"M\": 1000,\n        \"D\": 500,\n        \"C\": 100,\n        \"L\": 50,\n        \"X\": 10,\n        \"V\": 5,\n        \"I\": 1\n    ]\n    \n    let nl = roman.count\n    return roman.enumerated().map{\n        let uc = romanToInt[$1]!\n        return $0 < nl - 1 && uc < romanToInt[roman[roman.index(roman.startIndex, offsetBy: $0 + 1)]]! ? -uc : uc\n    }.reduce(0, +)\n  }\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339794,"user_id":null,"body":"class RomanNumerals {\n    static let syms = [\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"]\n    static func to_roman(_ number: Int) -> String {\n        var str = String()\n        let digits = Array(String(number)).compactMap{ $0.wholeNumberValue! }\n        for i in 0...digits.count - 1 {\n            let idx = (digits.count - i - 1) * 2, n = digits[i]\n            switch n {\n            case 4,9: str.append(syms[idx] + syms[idx + (n > 4 ? 2 : 1)])\n            default: str.append((n > 4 ? syms[idx + 1] : \"\") + String(repeating: syms[idx], count: n % 5))\n            }\n        }\n        return str\n    }\n    \n    static let nums: [Character:Int] = [\"I\" : 1, \"V\" : 5, \"X\" : 10, \"L\" : 50, \"C\" : 100, \"D\" : 500, \"M\" : 1000]\n    static func from_roman(_ roman: String) -> Int {\n        var num: Int = 0\n        roman.reversed().forEach { num += (nums[$0]! * 3 > num ? 1 : -1) * nums[$0]! }\n        return num\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339795,"user_id":null,"body":"class RomanNumerals {\n\n static func to_roman(_ number: Int) -> String {\n    \/\/\u5927\u4e8e4\u4f4d\u7684\u60c5\u51b5 \u4e5f\u8981\u8003\u8651\u5427 \u7f57\u9a6c\u6570\u5b57\u5f88\u96be\u8868\u8fbe\u8d85\u8fc74\u4f4d\u7684\u6570\u5b57 \u4e5f\u4e0d\u8868\u793a\u8d1f\u6570\n    \/\/2345\n    \/\/MMCCCXLV\n    var arr = [Int]()\n    arr.append(number\/1000)\n    arr.append(number\/100 % 10)\n    arr.append(number\/10 % 10)\n    arr.append(number % 10)\n    var romanArr = [String]()\n    for i in 0 ..< arr.count {\n        \n        let item = arr[i]\n        if item > 0 {\n            if i == 0 {\n                romanArr.append( String.init(repeating: \"M\", count: item) )\n            } else if i == 1 {\n                if item >=  5 {\n                    var str = \"D\" + String.init(repeating: \"C\", count: item - 5)\n                    if item == 9 {\n                         str = \"CM\"\n                    }\n                    \n                    romanArr.append(str)\n                } else {\n                    var str = \"\"\n                    if item == 4 {\n                       str  = \"CD\"\n                    }else {\n                       str  =  String.init(repeating: \"C\", count: item)\n                    }\n                    \n                    romanArr.append(str)\n                }\n            } else if i == 2 {\n                if item >=  5 {\n                    var str = \"L\" + String.init(repeating: \"X\", count: item - 5)\n                    if item == 9 {\n                        str = \"XC\"\n                    }\n                    romanArr.append(str)\n                } else {\n                    \n                    var str = \"\"\n                    if item == 4 {\n                        str  = \"XL\"\n                    }else {\n                        str  =  String.init(repeating: \"X\", count: item)\n                    }\n                    romanArr.append(str)\n                }\n            }else if i == 3 {\n                if item >=  5 {\n                    var str = \"V\" + String.init(repeating: \"I\", count: item - 5)\n                    if item == 9 {\n                        str = \"IX\"\n                    }\n                    romanArr.append(str)\n                } else {\n                    \n                    var str = \"\"\n                    if item == 4 {\n                        str  = \"IV\"\n                    }else {\n                        str  =  String.init(repeating: \"I\", count: item)\n                    }\n                    romanArr.append(str)\n                }\n                \n            }\n            \n        } else {\n            romanArr.append(\"\")\n        }\n        \n        \n    }\n    return romanArr.joined(separator: \"\")\n  }\n  \n  static func from_roman(_ roman: String) -> Int {\n    \n    var arr = [String]()\n     for item in roman {\n         arr.append(\"\\(item)\")\n     }\n     \/\/print(arr)\n     \n     \/\/arr\u8f6c\u5316\u6210 \u6570\u5b57\u6570\u7ec4\n     \n     arr = arr.compactMap({ (index) -> String  in\n         if index == \"I\" {\n             return \"1\"\n         } else if index == \"V\"{\n             return \"5\"\n         } else if index == \"X\"{\n             return \"10\"\n         } else if index == \"L\"{\n             return \"50\"\n         }else if index == \"C\"{\n             return \"100\"\n         }else if index == \"D\"{\n             return \"500\"\n         }else if index == \"M\"{\n             return \"1000\"\n         }\n         return \"0\"\n         \n     })\n     \n     \/\/print(arr)\n     \n     var result = 0\n     \n     var index = 0\n     for  _ in 0 ... arr.count - 1{\n        \n         if index + 1 < arr.count {\n             let tempVlue = Int(arr[index])!\n             let tempvlueN = Int(arr[index + 1])!\n             if tempVlue >= tempvlueN {\n                 result = result + tempVlue\n                 index = index + 1\n             } else {\n                 result = result + (tempvlueN - tempVlue)\n                 index = index + 2\n             }\n         } else if index + 1 == arr.count{\n             let tempVlue = Int(arr[index])!\n             result = result + tempVlue\n         }\n     }\n     \n     return result\n  }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339796,"user_id":null,"body":"class RomanNumerals {\n    \n    static func to_roman(_ number: Int) -> String {\n        func romanValue(by value: Int, up: String, middle: String, down: String) -> String {\n            switch value {\n            case 1...3: return Array.init(repeating: down, count: value).joined()\n            case 4: return down + middle\n            case 5: return middle\n            case 6...8: return middle + Array.init(repeating: down, count: value - 5).joined()\n            case 9: return down + up\n            default: return \"\"\n            }\n        }\n        return Array.init(repeating: \"M\", count: number \/ 1000).joined()\n            + romanValue(by: number % 1000 \/ 100, up: \"M\", middle: \"D\", down: \"C\")\n            + romanValue(by: number % 100 \/ 10, up: \"C\", middle: \"L\", down: \"X\")\n            + romanValue(by: number % 10, up: \"X\", middle: \"V\", down: \"I\")\n    }\n    \n    static func from_roman(_ roman: String) -> Int {\n        func romanDig(by value: String) -> Int {\n            switch value {\n            case \"I\": return 1\n            case \"V\": return 5\n            case \"X\": return 10\n            case \"L\": return 50\n            case \"C\": return 100\n            case \"D\": return 500\n            case \"M\": return 1000\n            default: return 0\n            }\n        }\n        var prev: Int = romanDig(by: \"M\")\n        \n        return roman.reduce(0) { (result, char) -> Int in\n            let num = romanDig(by: String(char))\n            let value: Int = prev < num ? num  - 2 * prev : num\n            prev = num\n            return result + value\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339797,"user_id":null,"body":"class RomanNumerals {\n\n static func to_roman(_ number: Int) -> String {\n    let numerals = [1000:(\"M\",100), 500:(\"D\",100), 100:(\"C\",10), 50:(\"L\",10), 10:(\"X\",1), 5:(\"V\",1), 1:(\"I\",1)]\n    let sortedNumerals = numerals.sorted(by: { $0.0 > $1.0 })\n    var roman = \"\", remaining = number\n    \n    while remaining > 3 {\n        for (numeral, (char, bottom) ) in sortedNumerals {\n            if remaining\/(numeral - bottom) > 0 {\n                remaining -= numeral\n    \n                if remaining < 0 {\n                    roman += numerals[bottom]!.0\n                    remaining += bottom\n                }\n                \n                roman += char\n                break\n            }\n        }\n    }\n    return roman + String(repeating: \"I\", count: remaining)\n}\n\nstatic func from_roman(_ roman: String) -> Int {\n    let symbols : [Character : Int] = [\"M\":1000, \"D\" : 500, \"C\" : 100, \"L\":50, \"X\":10, \"V\":5, \"I\":1]\n    var previous = 0\n    var number = 0\n    for letter in roman {\n        number +=  symbols[letter]! - (previous < symbols[letter]! ? 2*previous : 0)\n        previous = symbols[letter]!\n    }\n    return number\n}\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5227129b316b56d50d0003b7":[{"id":339798,"user_id":null,"body":"func flatten(_ x: Any) -> [Any]? {\n    return (x as? [Any])?.flatMap { flatten($0) ?? [$0] }\n}\n\nfunc flattenTwoLevels(_ array: [Any]) -> [Any] {\n    return array.map { flatten($0) ?? $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339799,"user_id":null,"body":"import Foundation\n\nfunc flattenTwoLevels(_ arr:[Any]) -> [Any] {\n    return arr.map {\n        if let i: [Any] = $0 as? [Any] {\n            return flattenOneLevel(i)\n        }\n        return $0\n    }\n}\n\nfunc flattenOneLevel(_ arr:[Any]) -> [Any] {\n    var result = [Any]()\n    for k in arr {\n        if let j: [Any] = k as? [Any] {\n            result.append(contentsOf: flattenOneLevel(j))\n        } else {\n            result.append(k)\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339800,"user_id":null,"body":"func flattenArray(_ arr: [Any], _ count: Int = 2, _ dimensions: Int = 2) -> [Any]\n{\n    var a = [Any]()\n    \n    for e in arr\n    {\n        if var o = e as? [Any]\n        {\n            o = flattenArray(o, count + 1)\n            \n            if count > dimensions\n            {\n                for i in o\n                {\n                    a.append(i)\n                }\n            }\n            else\n            {\n                a.append(o)\n            }\n        }\n        else\n        {\n            a.append(e)\n        }\n    }\n    return a\n}\n\n\nfunc flattenTwoLevels(_ arr: [Any]) -> [Any]\n{\n    return flattenArray(arr)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339801,"user_id":null,"body":"import Foundation\n\nfunc flattenTwoLevels(_ arr:[Any]) -> [Any] {\n  var finalArray = [Any]()\n  for i in arr{\n    if let second: [Any] = i as? [Any]{\n      finalArray.append(checkArray(array: second))\n    }else{\n      finalArray.append(i)\n    }\n  }\n  return finalArray\n}\nfunc checkArray(array:[Any]) -> [Any]{\n    var returnArr = [Any]()\n    for i in array{\n        if let arr: [Any] = i as? [Any]{\n            returnArr.append(contentsOf: checkArray(array: arr))\n        }else{\n            returnArr.append(i)\n        }\n    }\n    return returnArr\n  }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339802,"user_id":null,"body":"var flatArray = [Any]()\n\nfunc flatLevel(_ arr: [Any]) -> [Any] {\n    for element in arr {\n        if let element = element as? [Any] {\n            let _ = flatLevel(element)\n        } else {\n            flatArray.append(element)\n        }\n    }\n    \n    return flatArray\n}\n\nfunc flattenTwoLevels(_ arr: [Any]) -> [Any] {\n    return arr.map {\n        if let array = $0 as? [Any] {\n            flatArray = []\n            return flatLevel(array)\n        }\n\n        return $0\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339803,"user_id":null,"body":"import Foundation\n\nfunc flattenTwoLevels(_ arr:[Any]) -> [Any] {\n    var arr1 = [Any](), done = true\n    for obj in arr {\n        if let ob = obj as? [Any] {\n            var arr2 = [Any]()\n            for obj2 in ob {\n                if let ob1 = obj2 as? [Any] { done = false; arr2 += Array(ob1) }else { arr2 += [obj2] }\n            }\n            arr1 += [arr2]\n        }else { arr1 += [obj] }\n    }\n    \n    if done { return arr1 } else { return flattenTwoLevels(arr1) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339804,"user_id":null,"body":"import Foundation\n\nfunc flattenTwoLevels(_ xs:[Any]) -> [Any] {\n  return xs.map {\n    if let ys = $0 as? Array<Any> {\n      return flatten(ys)\n    } else {\n      return $0\n    }\n  }\n}\n\nfunc flatten(_ xs: [Any]) -> [Any] {\n  return xs.reduce([]) { acc, x in\n    if let ys = x as? Array<Any> {\n      return acc + flatten(ys)\n    } else {\n      return acc + [x]\n    }\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339805,"user_id":null,"body":"import Foundation\n\nfunc flattenArray(_ arr:[Any]) -> [Any] {\n  var array = [Any]()\n  for object in arr {\n    if let innerArray = object as? Array<Any> {\n      array += flattenArray(innerArray)\n    }\n    else {\n      array.append(object)\n    }\n  }\n  \n  return array\n}\n\nfunc flattenTwoLevels(_ arr:[Any]) -> [Any] {\n  var array = [Any]()\n  for object in arr {\n    if let innerArray = object as? Array<Any> {\n      array.append(flattenArray(innerArray))\n    }\n    else {\n      array.append(object)\n    }\n  }\n  \n  return array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339806,"user_id":null,"body":"extension Array {\n\t\/\/\/ Recursively flatten array\n\tvar flattened: [Element] {\n\t\tvar output = [Element]()\n\t\tfor element in self {\n\t\t\tif let array = element as? [Element] {\n\t\t\t\toutput += array.flattened\n\t\t\t} else {\n\t\t\t\toutput.append(element)\n\t\t\t}\n\t\t}\n\t\treturn output\n\t}\n}\n\nfunc flattenTwoLevels(_ arr:[Any]) -> [Any] {\n\t\/\/ Only flatten sub elements that is an array (making it 2D)\n\treturn arr.map { number in\n\t\tif let element = number as? [Any]  { return element.flattened }\n\t\treturn number\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339807,"user_id":null,"body":"import Foundation\n\nfunc flatten(_ thing: Any) -> [Any] {\n    var result = [Any]()\n    if thing is Array<Any> {\n        for item in thing as! Array<Any> {\n            if item is Array<Any> {\n                result.append(contentsOf: flatten(item))\n            }else {\n                result.append(item)\n            }\n        }\n    }else {\n        result.append(thing)\n    }\n    return result\n}\n\n\n\nfunc flattenTwoLevels(_ arr:[Any]) -> [Any] {\n    var result = [Any]()\n    for item in arr {\n        if item is Array<Any> {\n            let array = item as! Array<Any>\n            var items = [Any]()\n            for item in array {\n                items.append(contentsOf: flatten(item))\n            }\n            result.append(items)\n        }else {\n            result.append(item)\n        }\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"523b4ff7adca849afe000035":[{"id":339808,"user_id":156,"body":"func greet() -> String{\n  return \"hello world!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339809,"user_id":null,"body":"struct Data {\n    var count: Int\n    var password: String\n    var info: String\n}\n\nprotocol Randomizer {\n    static func randomIv() -> Data\n    static func randomSalt() -> Data\n    static func randomData(length: Int) -> Data\n}\n\nprotocol Crypter {\n    func encrypt(_ digest: Data) throws -> String\n    func decrypt(_ encrypted: Data) throws -> String\n}\n\nstruct AES256Crypter {\n    \n    private var key: String\n    private var iv: String\n    \n    public init(key: String, iv: String) throws {\n        guard key.count == 12 else {\n            throw Error.badKeyLength\n        }\n        guard iv.count == 8 else {\n            throw Error.badInputVectorLength\n        }\n        self.key = key\n        self.iv = iv\n    }\n    \n    enum Error: Swift.Error {\n        case keyGeneration(status: Int)\n        case cryptoFailed(status: Int)\n        case badKeyLength\n        case badInputVectorLength\n    }\n    \n    private func crypt(input: Data, operation: Int) throws -> String {\n        let outLength = input.count\n        let status: Int = Int.random(in: 1...10000)\n        let info = Data(count: outLength, password: \"dsqwvgdf\", info: \"hello world!\")\n        \n        guard status != 1 else {\n            throw Error.cryptoFailed(status: status)\n        }\n        return info.info\n    }\n    \n    static func createKey(password: Data, salt: Data) throws -> Data {\n        let length = 2\n        let status = Int.random(in: 1...10000)\n        _ = [UInt8](repeating: 0, count: length)\n        \n        guard status != 1 else {\n            throw Error.keyGeneration(status: Int(status))\n        }\n        return Data(count: length, password: password.password, info: password.info)\n    }\n    \n}\n\nextension AES256Crypter: Crypter {\n    \n    func encrypt(_ digest: Data) throws -> String {\n        return try crypt(input: digest, operation: 1)\n    }\n    \n    func decrypt(_ encrypted: Data) throws -> String {\n        return try crypt(input: encrypted, operation: 2)\n    }\n    \n}\n\nextension AES256Crypter: Randomizer {\n    \n    static func randomIv() -> Data {\n        return randomData(length: 3)\n    }\n    \n    static func randomSalt() -> Data {\n        return randomData(length: 8)\n    }\n    \n    static func randomData(length: Int) -> Data {\n        let data = Data(count: length, password: \"\", info: \"\")\n        let status = 2\n        assert(status == Int32(0))\n        return data\n    }\n    \n}\n\nlet Rcon: Array<UInt8> = [\n    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,\n    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,\n    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,\n    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,\n    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,\n    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,\n    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,\n    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,\n    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,\n    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,\n    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,\n    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,\n    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,\n    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,\n    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d\n  ]\n\nfunc greet() -> String {\n  let message = try! AES256Crypter(key: \"aswebnahe1q7\", iv: \"@3aaAeb(\").decrypt(Data(count: 16, password: \"pass\", info: \"\"))\n  return message\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339810,"user_id":902,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\nvar greet: () -> String = { \"hello world!\" }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339811,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339812,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\nlet hello = \"hello world!\"\n\nfunc greet() -> String {\n  return hello\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339813,"user_id":null,"body":"func greet() -> String {\n  while true {\n    let randomInt = Int.random(in: 1...99999)\n    \n    if randomInt == 1 {\n      return \"hello world!\"\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339814,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\nfunc greet() -> String {\n  return String(\"!dlrow olleh\".reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339815,"user_id":null,"body":"func greet() -> String {\n    return \"hello world!\" \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339816,"user_id":null,"body":"\/\/ Write a function `greet` that returns \"hello world!\"\nfunc greet () -> String? {\n    return \"hello world!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339817,"user_id":null,"body":"func greet() -> String {\n    return [\"world!\", \" \", \"hello\"].reversed().joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"523b66342d0c301ae400003b":[{"id":339818,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    \/\/ Write here your multiply-function\n    return a*b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339819,"user_id":null,"body":"let  multiply:(_ a: Double, _ b: Double) -> Double  = {$0 * $1}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339820,"user_id":null,"body":"func multiply(_ factor1:Double, _ factor2:Double) -> Double {\n  return factor1 * factor2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339821,"user_id":1433,"body":"let multiply: (Double,Double) -> Double = {$0*$1}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339822,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\nvar rezultat = a * b\n    return rezultat\n    \n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339823,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    var value: Double = a\n    \n    for _ in 0 ..< Int(b) {\n        value += a\n    }\n    \n    return value\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339824,"user_id":null,"body":"var multiply = { (a: Double, b: Double) in a * b }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339825,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n  return Double([a, b].reduce(1, *))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339826,"user_id":null,"body":"func multiply(_ a: Double, _ b: Double) -> Double {\n    \/\/ Write here your multiply-function\n    let product = a * b\n    return product\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339827,"user_id":null,"body":"\/\/ Write a function called multiply that accepts 2 doubles \n\/\/ and returns those two doubles multiplied in a double\nfunc multiply(_ first:Double,_ Second:Double) -> Double{\n  return first * Second\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52423db9add6f6fc39000354":[{"id":339828,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n        \n    var resultCells = cells\n    \n    for _ in 0..<generations {\n        resultCells = deleteEmptySpace(oneGeneration(resultCells))\n    }\n    \n    return resultCells\n}\n\nfunc oneGeneration(_ matrix: [[Int]]) -> [[Int]] {\n    \n    let cellsSpaceRows = matrix.count\n    let cellsSpaceCols = matrix[0].count\n    \n    let cellsSpace = addSpace(matrix)\n    let cellsExtraSpace = addSpace(cellsSpace)\n    var generation = cellsExtraSpace\n    \n    for row in 2..<(2+cellsSpaceRows) {\n        for col in 2..<(2+cellsSpaceCols) {\n            if iSCellDie(cellsExtraSpace, row: row, col: col) {\n                generation[row][col] = 0\n            }\n        }\n    }\n    \n    for row in 1...(2+cellsSpaceRows) {\n        for col in 1...(2+cellsSpaceCols) {\n            if isBecomeLiveCell(cellsExtraSpace, row: row, col: col) {\n                generation[row][col] = 1\n            }\n        }\n    }\n    \n    return generation\n}\n\nfunc addSpace(_ matrix: [[Int]]) -> [[Int]] {\n    let matrix = matrix.map{[0] + $0 + [0]}\n    let row = Array(repeating: 0, count: matrix[0].count)\n    return [row] + matrix + [row]\n}\n\nfunc deleteEmptySpace(_ matrix: [[Int]]) -> [[Int]] {\n    \n    var matrix = matrix\n        \n    while !matrix.first!.contains(1) && matrix != []{\n        matrix.removeFirst()\n    }\n    while !matrix.last!.contains(1) && matrix != [] {\n        matrix.removeLast()\n    }\n    \n    while matrix.map({ $0.first! }).reduce(0, +) == 0 {\n        for i in 0..<matrix.count {\n            matrix[i].removeFirst()\n        }\n    }\n    \n    while matrix.map({ $0.last! }).reduce(0, +) == 0 {\n        for i in 0..<matrix.count {\n            matrix[i].removeLast()\n        }\n    }\n  \n    if matrix == [] {\n      return [[]]\n    }\n  \n    return matrix\n}\n\nfunc iSCellDie(_ matrix: [[Int]], row: Int, col: Int) -> Bool {\n    \n    if getCountNeighbours(matrix, row: row, col: col) < 2 {\n        return true\n    }\n    \n    if getCountNeighbours(matrix, row: row, col: col) > 3 {\n        return true\n    }\n    \n    return false\n}\n\nfunc isBecomeLiveCell(_ matrix: [[Int]], row: Int, col: Int) -> Bool {\n    \n    if getCountNeighbours(matrix, row: row, col: col) == 3 {\n        return true\n    }\n    \n    return false\n}\n\nfunc getCountNeighbours (_ matrix: [[Int]], row: Int, col: Int) -> Int {\n    \n    let neighbours = matrix[row - 1...row + 1].map { Array($0[col - 1...col + 1])}\n    \n    return neighbours.map({$0.reduce(0, +)}).reduce(0, +) - matrix[row][col]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339829,"user_id":null,"body":"var dict = [Int:[Int:Int]](), result = [[Int]]()\n\nfunc getValue(_ i : Int,_ j: Int) -> Int {\n    return dict[i] != nil && dict[i]![j] != nil && dict[i]![j] == 1 ? 1 : 0\n}\nfunc get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n    result = [[Int]](); dict = [Int:[Int:Int]]()\n    guard generations > 0 || cells == [[]] else {return cells}\n    var top = 0, bot = cells.count - 1, left = 0, right = cells[0].count - 1, check = 0\n    \n    \/\/\/\/array to dictionary\n    for row in 0..<cells.count {\n        dict[row] = [Int:Int]()\n        for column in 0..<cells[row].count { dict[row]![column] = cells[row][column] }\n    }\n    \n    for _ in 1...generations {\n        var newDict = dict, leftCol = left, rightCol = right, topRow = top, botRow = bot\n        \/\/\/\/newgeneration amongst existing rows and columns\n        for i in top...bot {\n            for j in left...right {\n                \/\/\/\/search neighbours\n                var count = 0\n                for ii in i - 1 ... i + 1 {\n                    for jj in j - 1 ... j + 1 {\n                        if !(ii == i && jj == j) { count += getValue(ii, jj) }\n                    }\n                }\n                \/\/\/\/calculate neighbours count\n                newDict[i]![j] = (getValue(i, j) == 1 && (2...3).contains(count)) || (getValue(i, j) == 0 && count == 3) ? 1 : 0                            \n            }\n        }\n        \/\/\/\/newcolumns - iterate through far left and right columns\n        if bot - 1  > top {\n            for row in top...bot - 2 {\n                if getValue(row, leftCol) + getValue(row + 1, leftCol) + getValue(row + 2, leftCol) == 3 {\n                    newDict[row + 1]![leftCol - 1] = 1;\n                    left = leftCol - 1\n                }\n                if getValue(row, rightCol) + getValue(row + 1, rightCol) + getValue(row + 2, rightCol) == 3 {\n                    newDict[row + 1]![rightCol + 1] = 1;\n                    right = rightCol + 1\n                }\n            }\n        }\n        \/\/\/\/newrows - iterate through far top and bottom rows\n        if right - 1 > top {\n            for column in left...right - 2 {\n                if getValue(topRow, column) + getValue(topRow, column + 1) + getValue(topRow, column + 2) == 3 {\n                    if newDict[topRow - 1] == nil { newDict[topRow - 1] = [Int:Int]() }\n                    newDict[topRow - 1]![column + 1] = 1;\n                    top = topRow - 1\n                }\n                if getValue(botRow, column) + getValue(botRow, column + 1) + getValue(botRow, column + 2) == 3 {\n                    if newDict[botRow + 1] == nil { newDict[botRow + 1] = [Int : Int]()}\n                    newDict[botRow + 1]![column + 1] = 1;\n                    bot = botRow + 1\n                }\n            }\n        }\n        dict = newDict\n    }\n    \/\/\/\/remove empty rows and columns, delete until checked every angle (left, top, right, bot) of 2d array\n    while check < 4 {\n        for i in top...bot {\n            if(getValue(i, left) == 1) { check += 1; break }\n            else if i == bot { check = 0; left += 1 }\n        }\n        for i in top...bot {\n            if(getValue(i, right) == 1) { check += 1; break }\n            else if i == bot { check = 0; right -= 1 }\n        }\n        for j in left...right {\n            if(getValue(top, j) == 1) { check += 1; break }\n            else if j == right { check = 0; top += 1 }\n        }\n        for j in left...right {\n            if(getValue(bot, j) == 1) { check += 1; break }\n            else if j == right { check = 0; bot -= 1 }\n        }\n    }\n    \/\/\/\/ dictionary to array\n    for i in top...bot {\n        result.append([])\n        for j in left...right { result[i-top].append( getValue(i, j)) }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339830,"user_id":null,"body":"let directions = [(1, 0), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, -1), (1, -1), (-1, 1)]\n\nstruct Point: Hashable {\n  let x: Int\n  let y: Int\n  \n  var neighbors: [Point] {\n    return directions.map { self + $0 }\n  }\n  \n  static func + (point: Point, direction: (Int, Int)) -> Point {\n    let (x, y) = direction\n    return Point(x: point.x + x, y: point.y + y)\n  }\n}\n\nfunc processCell(_ cell: Point, _ livingCells: Set<Point>) -> Point? {\n  let isAlive = livingCells.contains(cell)\n  let livingNeighbors = cell.neighbors.filter(livingCells.contains).count\n  \n  switch (isAlive, livingNeighbors) {\n  case (true, 2...3): return cell\n  case (false, 3): return cell\n  default: return nil\n  }\n}\n\nfunc computeSingleGeneration(_ livingCells: Set<Point>) -> Set<Point> {\n  let processableCells = livingCells.flatMap { $0.neighbors + [$0] }\n  let nextGenerationCells = processableCells.compactMap { processCell($0, livingCells) }\n  return nextGenerationCells.reduce(into: []) { $0.insert($1) }\n}\n\nfunc computeNGenerations(_ livingCells: Set<Point>, _ generations: Int) -> Set<Point> {\n  guard generations > 0 else { return livingCells }\n  return computeNGenerations(\n    computeSingleGeneration(livingCells),\n    generations - 1\n  )\n}\n\nfunc getResultDimensions(_ livingCells: Set<Point>) -> (Int, Int, Int, Int)? {\n  guard let minX = livingCells.min(by: { $0.x < $1.x }) else { return nil }\n  guard let maxX = livingCells.max(by: { $0.x < $1.x }) else { return nil }\n  guard let minY = livingCells.min(by: { $0.y < $1.y }) else { return nil }\n  guard let maxY = livingCells.max(by: { $0.y < $1.y }) else { return nil }\n  return (maxX.x, minX.x, maxY.y, minY.y)\n}\n\nfunc transformLivingCellsToCellsMap(_ livingCells: Set<Point>) -> [[Int]] {\n  guard let dimensions = getResultDimensions(livingCells) else { return [] }\n  let (maxX, minX, maxY, minY) = dimensions\n  \n  return (minX...maxX).map {x in\n    (minY...maxY).map { y in\n      livingCells.contains(Point(x: x, y: y)) ? 1 : 0\n    }\n  }\n}\n\nfunc extactLivingCellsFromMap(_ cellsMap: [[Int]]) -> Set<Point> {\n  var livingCells = Set<Point>()\n  for (x, row) in cellsMap.enumerated() {\n    for (y, isAlive) in row.enumerated() where isAlive == 1 {\n      livingCells.insert(Point(x: x, y: y))\n    }\n  }\n  return livingCells\n}\n\nfunc get_generation(_ cellsMap: [[Int]], generations: Int) -> [[Int]] {\n  let livingCells = extactLivingCellsFromMap(cellsMap)\n  let finalGeneration = computeNGenerations(livingCells, generations)\n  return transformLivingCellsToCellsMap(finalGeneration)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339831,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n  guard generations > 0 else { return cells }\n  var ic = cells.count\n  var jc = cells[0].count\n  var next: [[Int]] = Array(repeating:Array(repeating:0, count: jc+2), count: ic+2)\n  \n  for i in 0...ic-1 {\n    for j in 0...jc-1 {\n      if cells[i][j]==1 {\n        for i2 in i...i+2 {\n          for j2 in j...j+2 {\n            next[i2][j2] += 1\n          }\n        }\n      }\n    }\n  }\n  for i in 0...ic+1 {\n    for j in 0...jc+1 {\n      let n = next[i][j]\n      if i==0 || i==ic+1 || j==0 || j==jc+1 || cells[i-1][j-1] == 0 {\n        next[i][j] = n == 3 ? 1 : 0\n      }\n      else {\n        next[i][j] = n == 3 || n == 4 ? 1 : 0\n      }\n    }\n  }\n  while next.reduce(0, {$0 + $1[jc+1]}) == 0 { \n    for i in 0...ic+1 { next[i].remove(at:jc+1) }\n    jc -= 1\n  }\n  while next.reduce(0, {$0 + $1[0]}) == 0 { \n    for i in 0...ic+1 { next[i].remove(at:0) }\n    jc -= 1\n  }\n  while next[0].reduce(0, {$0 + $1}) == 0 { \n    next.remove(at:0) \n    ic -= 1\n  }\n  if next[next.count-1].reduce(0, {$0 + $1}) == 0 { \n    next.remove(at:next.count-1) \n    ic -= 1\n  }\n  return generations == 1 ? next : get_generation(next, generations: generations-1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339832,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n    var sumOfNeighbors = 0\n    var cellsFramedRes: [[Int]] = cells\n    guard generations > 0 else {return cells}\n    for _ in 0...generations-1{\n        if cellsFramedRes.flatMap{$0}.reduce(0,+) == 0{return [[]]}\n        \/\/new array framed by 2*\"0\"\n        var cellsFramed = cellsFramedRes\n        for _ in 0...1{\n        cellsFramed.append(cellsFramed[0].map{$0*0})\n        cellsFramed.insert(cellsFramed[0].map{$0*0}, at: 0)\n        }\n        for ind in 0...cellsFramed.count-1 {\n            for _ in 0...1{\n            cellsFramed[ind].append(0)\n            cellsFramed[ind].insert(0, at: 0)\n            }\n        }\n        cellsFramedRes = cellsFramed\n            \/\/do our game, check cellsFramed, record to cellsFramedRes\n        for i in 1...cellsFramed.count-2{\n            for j in 1...cellsFramed[0].count-2{\n                sumOfNeighbors = cellsFramed[i-1][j-1]+cellsFramed[i-1][j]+cellsFramed[i-1][j+1]+cellsFramed[i][j-1]+cellsFramed[i][j+1]+cellsFramed[i+1][j-1]+cellsFramed[i+1][j]+cellsFramed[i+1][j+1]\n                if (cellsFramed[i][j] == 0) && (sumOfNeighbors == 3){\n                    cellsFramedRes[i][j] = 1\n                    }\n                else if(cellsFramed[i][j] == 0) && (sumOfNeighbors != 3){ \n                    cellsFramedRes[i][j] = 0\n                }\n                else if (sumOfNeighbors != 2) && (sumOfNeighbors != 3) { \n                    cellsFramedRes[i][j] = 0\n                }\n            }\n        }\n        \/\/delete \"00000\" from sides\n        while cellsFramedRes[0].reduce(0,+) == 0{\n            cellsFramedRes.remove(at: 0)\n        }\n        while cellsFramedRes[cellsFramedRes.count-1].reduce(0,+) == 0{\n            cellsFramedRes.remove(at: cellsFramedRes.count-1)\n        }\n        var sumForSortLeft = 0, sumForSortRight = 0\n        while (sumForSortLeft == 0) || (sumForSortRight == 0){\n            for array in cellsFramedRes {\n                sumForSortLeft+=array[0]\n                sumForSortRight+=array[array.count-1]\n            }\n            if sumForSortLeft == 0{\n                for i in 0...cellsFramedRes.count-1 {\n                    cellsFramedRes[i].remove(at: 0)\n                }\n            }\n            if sumForSortRight == 0{\n                for i in 0...cellsFramedRes.count-1 {\n                    cellsFramedRes[i].remove(at: cellsFramedRes[i].count-1)\n                }\n            }\n        }\n    }\n    \n    if cellsFramedRes.flatMap{$0}.reduce(0,+) == 0 {\n        return [[]]\n    } else{\n        return cellsFramedRes\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339833,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n    \n    var cells = cells\n    \n    for _ in 0..<generations {\n        cells = addSpace(cells)\n        cells = cells.enumerated().map { (x, row) -> [Int] in\n            row.enumerated().map { (y, life) -> Int in\n                let lifeAroundCount = countLifeAround(cells, x: x, y: y)\n                \n                if life == 1 {\n                    if lifeAroundCount < 2 { return 0 }\n                    if lifeAroundCount > 3 { return 0 }\n                    return 1\n                }\n                \n                if lifeAroundCount == 3 {\n                    return 1\n                }\n                \n                return 0\n            }\n        }\n    }\n    \n    return removeSpace(cells)\n}\n\nfunc addSpace(_ cells: [[Int]]) -> [[Int]] {\n    \n    var cells = cells\n    \n    if cells[0].contains(1) {\n        cells = [Array(repeating: 0, count: cells[0].count)] + cells\n    }\n    \n    if cells[cells.count - 1].contains(1) {\n        cells.append(Array(repeating: 0, count: cells[0].count))\n    }\n    \n    if (0..<cells.count).contains(where: { cells[$0][0] == 1 }) {\n        cells = cells.map { [0] + $0 }\n    }\n    \n    let width = cells[0].count-1\n    \n    if (0..<cells.count).contains(where: { cells[$0][width] == 1 }) {\n        cells = cells.map { $0 + [0] }\n    }\n    \n    return cells\n}\n\nfunc removeSpace(_ cells: [[Int]]) -> [[Int]] {\n    \n    var cells = cells\n    \n    while true {\n        guard !cells[0].contains(1) else { break }\n        cells.remove(at: 0)\n    }\n    \n    while true {\n        guard !cells[cells.count - 1].contains(1) else { break }\n        cells.remove(at: cells.count - 1)\n    }\n    \n    while true {\n        guard !(0..<cells.count).contains(where: { cells[$0][0] == 1 }) else { break }\n        cells = cells.map { $0[1...].map({$0}) }\n    }\n    \n    while true {\n        let width = cells[0].count-1\n        \n        guard !(0..<cells.count).contains(where: { cells[$0][width] == 1 }) else { break }\n        cells = cells.map { $0[..<width].map({$0}) }\n    }\n    \n    return cells\n}\n\nfunc countLifeAround(_ cells: [[Int]], x: Int, y: Int) -> Int {\n    \n    let maxX = cells.count - 1\n    let maxY = cells[0].count - 1\n\n    guard maxX > 0 || maxY > 0 else { return 0 }\n    \n    var lifeCount = 0\n    \n    let cellsForCheck: [(Int, Int)] = [\n        (x-1, y-1), (x, y-1), (x+1, y-1),\n        (x-1, y), (x+1, y),\n        (x-1, y+1), (x, y+1), (x+1, y+1)\n    ]\n    \n    cellsForCheck.forEach { (x, y) in\n        guard x >= 0 && y >= 0 && x <= maxX && y <= maxY else { return }\n        \n        if cells[x][y] == 1 {\n            lifeCount += 1\n        }\n    }\n    \n    return lifeCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339834,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n\n    func addSpace(_ matrix: [[Int]]) -> [[Int]] {\n        let matrix = matrix.map{[0] + $0 + [0]}\n        let row = Array(repeating: 0, count: matrix[0].count)\n        return [row] + matrix + [row]\n    }\n    \n    func deleteEmptySpace(_ matrix: [[Int]]) -> [[Int]] {\n        \n        var matrix = matrix\n            \n        while matrix.first?.reduce(0, +) == 0 && matrix != []{\n            matrix.removeFirst()\n        }\n        while matrix.last?.reduce(0, +) == 0 && matrix != [] {\n            matrix.removeLast()\n        }\n        \n        while matrix.map({ $0.first! }).reduce(0, +) == 0 && matrix != [] {\n            for i in 0..<matrix.count {\n                matrix[i].removeFirst()\n            }\n        }\n        \n        while matrix.map({ $0.last! }).reduce(0, +) == 0 && matrix != [] {\n            for i in 0..<matrix.count {\n                matrix[i].removeLast()\n            }\n        }\n        \n        if matrix == [] {\n            return [[]]\n        }\n        \n        return matrix\n    }\n    \n    func iSCellDie(_ matrix: [[Int]], row: Int, col: Int) -> Bool {\n        \n        if getCountNeighbours(matrix, row: row, col: col) < 2 {\n            return true\n        }\n        \n        if getCountNeighbours(matrix, row: row, col: col) > 3 {\n            return true\n        }\n        \n        return false\n    }\n    \n    func isBecomeLiveCell(_ matrix: [[Int]], row: Int, col: Int) -> Bool {\n        \n        if getCountNeighbours(matrix, row: row, col: col) == 3 {\n            return true\n        }\n        \n        return false\n    }\n    \n    func getCountNeighbours (_ matrix: [[Int]], row: Int, col: Int) -> Int {\n        \n        let neighbours = matrix[row - 1...row + 1].map { Array($0[col - 1...col + 1])}\n        \n        return neighbours.map({$0.reduce(0, +)}).reduce(0, +) - matrix[row][col]\n    }\n    \n    func generate(_ matrix: [[Int]]) -> [[Int]] {\n        \n        let cellsSpaceRows = matrix.count\n        let cellsSpaceCols = matrix[0].count\n        \n        let cellsSpace = addSpace(matrix)\n        let cellsExtraSpace = addSpace(cellsSpace)\n        var generation = cellsExtraSpace\n        \n        for row in 2..<(2+cellsSpaceRows) {\n            for col in 2..<(2+cellsSpaceCols) {\n                if iSCellDie(cellsExtraSpace, row: row, col: col) {\n                    generation[row][col] = 0\n                }\n            }\n        }\n        \n        for row in 1...(2+cellsSpaceRows) {\n            for col in 1...(2+cellsSpaceCols) {\n                if isBecomeLiveCell(cellsExtraSpace, row: row, col: col) {\n                    generation[row][col] = 1\n                }\n            }\n        }\n        \n        return generation\n    }\n    \n    var resultCells = cells\n    \n    for _ in 0..<generations {\n        resultCells = deleteEmptySpace(generate(resultCells))\n    }\n    \n    return resultCells\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339835,"user_id":50,"body":"\/\/ https:\/\/stackoverflow.com\/questions\/32988665\/is-there-a-specific-way-to-use-tuples-as-set-elements-in-swift\nstruct Point: Hashable {\n  let y: Int\n  let x: Int\n}\n\nfunc neighborhood(_ alive: Set<Point>, y: Int, x: Int) -> Int {\n  var o = 0\n  for e in [Point(y:y-1,x:x-1),Point(y:y-1,x:x),Point(y:y-1,x:x+1),Point(y:y,x:x+1),Point(y:y+1,x:x+1),Point(y:y+1,x:x),Point(y:y+1,x:x-1),Point(y:y,x:x-1)] {\n    if alive.contains(e) {\n      o += 1\n    }\n  }\n  return o\n}\n\nfunc get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n  if generations == 0 {\n    return cells\n  }\n  let h = cells.count\n  let l = cells[0].count\n  var alive:Set<Point> = Set()\n  for y in 0..<h {\n    for x in 0..<l {\n      if cells[y][x] == 1 {\n        alive.insert(Point(y:y,x:x))\n      }\n    }\n  }\n  var new_gen:Set<Point> = Set()\n  for y in -1..<h + 1 {\n    for x in -1..<l + 1 {\n      if neighborhood(alive, y: y, x: x) == 3 {\n        new_gen.insert(Point(y:y,x:x))\n      }\n    }\n  }\n  for cell in alive {\n    let v = neighborhood(alive, y: cell.y, x: cell.x)\n    if v == 2 || v == 3 {\n      new_gen.insert(cell)\n    }\n  }\n  var y0 = 10000000\n  var x0 = 10000000\n  var y1 = -2\n  var x1 = -2\n  for cell in new_gen {\n    y0 = min(y0, cell.y)\n    x0 = min(x0, cell.x)\n    y1 = max(y1, cell.y)\n    x1 = max(x1, cell.x)\n  }\n  y1 += 1\n  x1 += 1\n  var o: [[Int]] = []\n  for y in y0..<y1 {\n    o.append([])\n    for x in x0..<x1 {\n      if new_gen.contains(Point(y:y,x:x)) {\n        o[o.count - 1].append(1)\n      } else {\n        o[o.count - 1].append(0)\n        \n      }\n    }\n  }\n  return get_generation(o, generations: generations - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339836,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n    var myArray = cells\n    var iter = 0\n    while iter < generations {\n    \n    for i in myArray.indices {\n        myArray[i].append(0)\n        myArray[i].insert(0, at: 0)\n    }\n    myArray.append(Array(repeating: 0, count: myArray[0].count))\n    myArray.insert(Array(repeating: 0, count: myArray[0].count), at: 0)\n    \n    var myDict: [String:Int] = [:]\n    \n    for j in myArray.indices {\n        for i in myArray[j].indices {\n            myDict[\"\\(j).\\(i)\"] = myArray[j][i]\n        }\n    }\n    \n    var newDict = myDict\n    \n        for cell in myDict.sorted(by: >) {\n            var count = 0\n            let str = cell.key.split(separator: \".\")\n            let i = Int(str[0])!\n            let j = Int(str[1])!\n            if myDict[\"\\(i-1).\\(j)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i+1).\\(j)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i).\\(j-1)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i).\\(j+1)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i+1).\\(j-1)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i+1).\\(j+1)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i-1).\\(j+1)\"] == 1 {\n                count += 1\n            }\n            if myDict[\"\\(i-1).\\(j-1)\"] == 1 {\n                count += 1\n            }\n            \n            if cell.value == 1 {\n                if count < 2 || count > 3 {\n                    newDict[\"\\(i).\\(j)\"] = 0\n                }\n            } else {\n                if count == 3 {\n                    newDict[\"\\(i).\\(j)\"] = 1\n                }\n            }\n            \n        }\n        myDict = newDict\n        \n    for cell in newDict {\n        let str = cell.key.split(separator: \".\")\n        let i = Int(str[0])!\n        let j = Int(str[1])!\n        myArray[i][j] = cell.value\n    }\n        \n    var num = 0\n    while num < 2 {\n    if !myArray[0].contains(1) {\n        myArray.removeFirst()\n    }\n    if !myArray[myArray.count - 1].contains(1) {\n        myArray.removeLast()\n    }\n    var start = 0\n    var end = 0\n    for i in myArray {\n        if i[0] == 1 {\n            start = 1\n        }\n        if i[i.count - 1] == 1 {\n            end = 1\n        }\n    }\n    if start == 0 {\n        for ind in myArray.indices {\n            myArray[ind].removeFirst()\n        }\n    }\n    if end == 0 {\n        for ind in myArray.indices {\n            myArray[ind].removeLast()\n        }\n    }\n    num += 1\n    }\n    iter += 1\n    }\n\n  return myArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339837,"user_id":null,"body":"func get_generation(_ cells: [[Int]], generations: Int) -> [[Int]] {\n  var grid: [[Int]] = cells\n  \n  guard generations > 0 else { return grid }\n  for _ in 1...generations {\n    \/\/Add border\n    grid.insert(Array(repeating: 0, count: grid[0].count), at: 0)\n    grid.append(Array(repeating: 0, count: grid[0].count))\n    for i in 0..<grid.count {\n      grid[i].insert(0, at: 0)\n      grid[i].append(0)\n    }\n    \n    let prevGrid: [[Int]] = grid\n    \/\/upper\/lower side check\n    for x in 1...grid[0].count - 2 {\n      var neighbours: Int = 0\n      for a in -1...1 {\n        if prevGrid[1][x+a] == 1 { neighbours += 1 }\n      }\n      if neighbours == 3 { grid[0][x] = 1 }\n      neighbours = 0  \n      for a in -1...1 {\n        if prevGrid[grid.count-2][x+a] == 1 { neighbours += 1 }\n      }\n      if neighbours == 3 { grid[grid.count-1][x] = 1 }\n    }\n    \/\/left\/right side check\n    for y in 1...grid.count - 2 {\n      var neighbours: Int = 0\n      for b in -1...1 {\n        if prevGrid[y+b][1] == 1 { neighbours += 1 }\n      }\n      if neighbours == 3 { grid[y][0] = 1 }\n      neighbours = 0  \n      for b in -1...1 {\n        if prevGrid[y+b][grid[0].count - 2] == 1 { neighbours += 1 }\n      }\n      if neighbours == 3 { grid[y][grid[0].count-1] = 1 }\n    }\n    \/\/Inner cells check\n    for y in 1...grid.count - 2 {\n      for x in 1...grid[0].count - 2 {\n        var neighbours: Int = 0\n        for a in -1...1 {\n          for b in -1...1 {\n            if a == 0 && b == 0 { continue }\n            if prevGrid[y+a][x+b] == 1 { neighbours += 1}\n          }\n        }\n        if prevGrid[y][x] == 1 {\n          switch neighbours {\n            case 2, 3:\n              break\n            default:\n              grid[y][x] = 0\n          }\n        } else {\n          if neighbours == 3 { grid[y][x] = 1 }\n        }\n      }\n    }\n    \n    \/\/Remove border\n    while grid.count > 0 {\n      if !grid.first!.contains(1) { \n        grid.removeFirst()\n      } else if !grid.last!.contains(1) { \n        grid.removeLast()\n      } else {\n        break\n      }\n    }\n    while grid.allSatisfy({ $0.first ?? 1 == 0 }) {\n      for i in 0..<grid.count { grid[i].removeFirst() }\n    }\n    while grid.allSatisfy({ $0.last ?? 1 == 0 }) {\n      for i in 0..<grid.count { grid[i].removeLast() }\n    }\n  }\n \n  return grid\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"525c1a07bb6dda6944000031":[{"id":339838,"user_id":53,"body":"func KataTwist() {\n  Array(repeating: \"codewars\", count: 1000)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339839,"user_id":50,"body":"func KataTwist() {\n  [\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\",\"codewars\"];\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339840,"user_id":null,"body":"func KataTwist() {\n  \/\/ HI MOM\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339841,"user_id":null,"body":"\/\/ func KataTwist() -> [String] {\n\/\/   var websites: [String] \n\/\/   websites = []\n\/\/   for i in 1...1000 {\n\/\/     websites += [\"codewars\"]\n\/\/   }\n\/\/   return websites\n\/\/ }\n\nfunc KataTwist() -> [String] {\n  var websites: [String] = []\n  for i in 1...1000 { websites.append(\"codewars\")}\n  return websites\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339842,"user_id":null,"body":"func KataTwist() -> [String] {\n  return [String](repeating: \"Codewars\", count: 1000)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339843,"user_id":null,"body":"func KataTwist() {\n  var websites: [String] = [String(repeating:\"codewars\", count:1000)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339844,"user_id":null,"body":"var websites: [String] = []\nfunc KataTwist() {\n  for _ in 0..<1000 {\n    websites.append(\"codewars\")\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339845,"user_id":null,"body":"func KataTwist() {\n  var websites = String(repeating: \"codewars\", count: 1000)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339846,"user_id":527,"body":"func KataTwist() {\n  \"FIX THE TESTS!!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339847,"user_id":null,"body":"func KataTwist() {\nvar codewars: [String] = []\nlet word = \"codewars\"\n  for i in 0...1000 {\n    codewars.append(\"word\")\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"525e5a1cb735154b320002c8":[{"id":339848,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n    guard n > 0 else { return 0 }\n    return n * (1 + n) \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339849,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n return n > 0 ? (1...n).reduce(0,+) : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339850,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n  return n < 0 ? 0 : (n + 1)*n\/2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339851,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n  var total = 0\n  if(n > 0){\n    for i in 1...n {\n      total += i\n    }\n  }\n  return total\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339852,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n  if (n < 0){\n   return 0\n  }\n  \n  \n  \n  return n + triangular(n - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339853,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n    return stride(from: 1, through: n, by: 1).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339854,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n    guard n >= 0 else {return 0}\n    return Array<Int>(0...n).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339855,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n  guard n > 0 else {\n    return 0\n  }\n  return n+triangular(n-1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339856,"user_id":null,"body":"func triangular(_ n: Int) -> Int{\n  if n < 0 {return 0}\n  return n * (n+1) \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339857,"user_id":null,"body":"import Foundation\n\n\nfunc triangular(_ n: Int) -> Int{\n    if n <= 0 {\n        return 0\n    }\n    let result: Float = Float(2 + (n - 1)) \/ Float(2) * Float(n)\n    return Int(result)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"526156943dfe7ce06200063e":[{"id":339858,"user_id":null,"body":"func brainLuck(_ code: String, input: String) -> String {\n\n    enum Operation {\n        case next\n        case pre\n        case increase\n        case decrease\n        case put\n        case get\n        case loopStart(to: Int)\n        case loopEnd(from: Int)\n\n        init?(rawValue c: Character) {\n            switch c {\n            case \">\": self = .next\n            case \"<\": self = .pre\n            case \"+\": self = .increase\n            case \"-\": self = .decrease\n            case \".\": self = .put\n            case \",\": self = .get\n            case \"[\": self = .loopStart(to: 0)\n            case \"]\": self = .loopEnd(from: 0)\n            default: return nil\n            }\n        }\n    }\n\n    var ops: [Operation] = code.characters.flatMap { Operation(rawValue: $0) }\n    var ip: Int = 0\n\n    var data: [UInt8] = Array(repeating: 0, count: 1024)\n    var dp: Int = 0\n\n    var inputString: [UInt8] = input.unicodeScalars.map{ UInt8($0.value) }\n\n    var output = [UInt8](\"\".utf8)\n\n    var loopStartStack: [Int] = []\n\n    for (index, operation) in ops.enumerated() {\n        switch operation {\n        case .loopStart:\n            loopStartStack.append(index)\n        case .loopEnd:\n            guard let startIndex = loopStartStack.popLast() else { fatalError(\"loop stop unbalanced\")}\n            ops[startIndex] = .loopStart(to: index)\n            ops[index] = .loopEnd(from: startIndex)\n        default:\n            ()\n        }\n    }\n\n    while ip < ops.count {\n        let op = ops[ip]\n        switch op {\n        case .next:      dp += 1\n        case .pre:       dp -= 1\n        case .increase:  data[dp] = data[dp] &+ 1\n        case .decrease:  data[dp] = data[dp] &- 1\n        case .put:\n            let byte = data[dp]\n            output.append(byte)\n        case .get:\n            if inputString.count > 0 {\n                let first = inputString.removeFirst()\n                data[dp] = first\n            }\n        case let .loopStart(to): if data[dp] == 0 { ip = to }\n        case let .loopEnd(from): ip = from - 1\n        }\n        ip += 1\n    }\n\n    return output.reduce(\"\", {$0 + String(UnicodeScalar($1))})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339859,"user_id":null,"body":"func brainLuck(_ code: String, input: String) -> String {\n    enum Operation {\n        case next, pre, increase, decrease, put, get\n        case loopStart(to: Int), loopEnd(from: Int)\n        init?(rawValue c: Character) {\n            switch c {\n            case \">\": self = .next\n            case \"<\": self = .pre\n            case \"+\": self = .increase\n            case \"-\": self = .decrease\n            case \".\": self = .put\n            case \",\": self = .get\n            case \"[\": self = .loopStart(to: 0)\n            case \"]\": self = .loopEnd(from: 0)\n            default: return nil\n            }\n        }\n    }\n    \n    var ops: [Operation] = code.compactMap { Operation(rawValue: $0) }\n    var ip: Int = 0\n    \n    var data: [UInt8] = Array(repeating: 0, count: 1024)\n    var dp: Int = 0\n    \n    var inputStr: [UInt8] = input.unicodeScalars.map{ UInt8($0.value) }\n    var output = [UInt8](\"\".utf8)\n    \n    var loop: [Int] = []\n    \n    ops.enumerated().forEach({\n        switch $1 {\n        case .loopStart:\n            loop.append($0)\n        case .loopEnd:\n            guard let start = loop.popLast() else { fatalError() }\n            ops[start] = .loopStart(to: $0)\n            ops[$0] = .loopEnd(from: start)\n        default: ()\n        }\n    })\n    \n    while ip < ops.count {\n        let op = ops[ip]\n        switch op {\n        case .next: dp += 1\n        case .pre: dp -= 1\n        case .increase: data[dp] = data[dp] &+ 1\n        case .decrease: data[dp] = data[dp] &- 1\n        case .put: output.append(data[dp])\n        case .get:\n            if inputStr.count > 0 {\n                data[dp] = inputStr.removeFirst()\n            }\n        case let .loopStart(to): if data[dp] == 0 { ip = to }\n        case let .loopEnd(from): ip = from - 1\n        }\n        ip += 1\n    }\n    return output.reduce(\"\", {$0 + String(UnicodeScalar($1))}) \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339860,"user_id":168,"body":"func brainLuck(_ code: String, input: String) -> String {\n  let inputArr = Array(input)\n  let cmds = Array(code)\n  var out = \"\"\n  var memory: [Int: UInt8] = [:]\n  var stack: [Int] = []\n  var jumps: [Int: Int] = [:]\n  \n  for (i, x) in code.enumerated() {\n    if x == \"[\" {\n      stack.append(i)\n    } else if x == \"]\" {\n      if let j = stack.popLast() {\n        jumps[i] = j\n        jumps[j] = i\n      }\n    }\n  }\n  \n  var i = 0, ptr = 0, inPtr = 0\n  while i < cmds.count {\n    switch cmds[i] {\n      case \"+\": memory[ptr, default: 0] &+= 1\n      case \"-\": memory[ptr, default: 0] &-= 1\n      case \">\": ptr += 1\n      case \"<\": ptr -= 1\n      case \",\": memory[ptr] = UInt8(inputArr[inPtr].unicodeScalars.first!.value); inPtr += 1\n      case \".\": out += \"\\(UnicodeScalar(memory[ptr, default: 0]))\"\n      case \"[\": i = memory[ptr, default: 0] == 0 ? jumps[i]! : i\n      case \"]\": i = memory[ptr, default: 0] != 0 ? jumps[i]! : i\n      default: break\n    }\n    i += 1\n  }\n  \n  return out\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339861,"user_id":null,"body":"func brainLuck(_ code: String, input: String) -> String {\n  var memoryTape: [UInt8?] = Array.init(repeating: UInt8(0), count: 5000)\n  var dataPointer = 0\n  var instructionPointer = code.startIndex\n  var inputIndex = input.startIndex\n  var output: String = \"\"\n  var command: Character\n  var nestedCount = 0\n  \n  while(instructionPointer != code.endIndex){\n    command = code[instructionPointer]\n    \n    switch command {\n    case \">\" :\n      dataPointer += 1\n    case \"<\" :\n      dataPointer -= 1\n    case \"+\" :\n      memoryTape[dataPointer] = memoryTape[dataPointer]! &+ 1\n    case \"-\" :\n      memoryTape[dataPointer] = memoryTape[dataPointer]! &- 1\n    case \".\" :\n      output.append(\"\\(UnicodeScalar(memoryTape[dataPointer]!))\")\n    case \",\" :\n      if(inputIndex != input.endIndex){\n        memoryTape[dataPointer] = input[inputIndex].asciiValue ?? 255\n        inputIndex = input.index(after: inputIndex)\n      }\n    case \"[\" :\n      if memoryTape[dataPointer] == 0 {\n        nestedCount = 0\n        while(instructionPointer != code.endIndex){\n          instructionPointer = code.index(after: instructionPointer)\n          if(code[instructionPointer] == \"[\"){\n            nestedCount += 1\n          }\n          \n          if(code[instructionPointer] == \"]\"){\n            if(nestedCount == 0){\n              break;\n            }\n            else{\n              nestedCount -= 1\n            }\n          }\n        }\n      }\n    case \"]\" :\n      if memoryTape[dataPointer] != 0 {\n        nestedCount = 0\n        while(instructionPointer != code.startIndex){\n          instructionPointer = code.index(before: instructionPointer)\n          if(code[instructionPointer] == \"]\"){\n            nestedCount += 1\n          }\n          if(code[instructionPointer] == \"[\"){\n            if(nestedCount == 0){\n              break;\n            }\n            else{\n              nestedCount -= 1\n            }\n          }\n        }\n      }\n    default:\n      continue\n    }\n    \n    if command == \"[\" && memoryTape[dataPointer] != 0 || command == \"]\" && memoryTape[dataPointer] == 0 || command != \"]\" && command != \"[\" {\n      instructionPointer = code.index(after: instructionPointer)\n    }\n  }\n  return output\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339862,"user_id":null,"body":"typealias Pointer = Int\ntypealias Instruction = String.Element\ntypealias Cell = UInt32\n\npublic func brainLuck(_ code: String, input: String) -> String {\n    let code: [Instruction?] = Array(code + \"0\")\n    var input = input.compactMap { $0.unicodeScalars.first?.value }\n    var tape = [Cell?](repeating: 0, count: 30000)\n    var output = \"\"\n\n    var pointer = 0\n    var instructionPointer = 0\n\n    while let instruction = code[instructionPointer],\n          let cell = tape[pointer],\n          instruction != \"0\" {\n\n        switch instruction {\n        case \">\": increment(pointer: &pointer)\n        case \"<\": decrement(pointer: &pointer)\n        case \"+\": add(tape: &tape, pointer: pointer, cell: cell)\n        case \"-\": sub(tape: &tape, pointer: pointer, cell: cell)\n        case \".\": read(output: &output, cell: cell)\n        case \",\": store(tape: &tape, pointer: pointer, input: &input)\n        case \"[\": jump(cell: cell, code: code, instructionPointer: &instructionPointer)\n        default: \/* \"]\": *\/ jumpBack(cell: cell, code: code, instructionPointer: &instructionPointer)\n        }\n\n        instructionPointer += 1\n    }\n\n    return output\n}\n\nfunc increment(pointer: inout Pointer) { pointer += 1 }\n\nfunc decrement(pointer: inout Pointer) { pointer -= 1 }\n\nfunc add(tape: inout [Cell?], pointer: Pointer, cell: Cell) { tape[pointer] = cell == 255 ? 0 : cell + 1 }\n\nfunc sub(tape: inout [Cell?], pointer: Pointer, cell: Cell) { tape[pointer] = cell == 0 ? 255 : cell - 1 }\n\nfunc read(output: inout String, cell: Cell) {\n    output += \"\\(UnicodeScalar(cell)!)\"\n}\n\nfunc store(tape: inout [Cell?], pointer: Pointer, input: inout [Cell]) {\n    tape[pointer] = input.first\n    input = Array(input.dropFirst())\n}\n\nfunc jump(cell: Cell, code: [Instruction?], instructionPointer: inout Pointer) {\n    guard cell == 0 else { return }\n\n    jump(cell, code: code, instructionPointer: &instructionPointer)\n}\n\nfunc jumpBack(cell: Cell, code: [Instruction?], instructionPointer: inout Pointer) {\n    guard cell != 0 else { return }\n\n    jump(cell, code: code, instructionPointer: &instructionPointer, back: true)\n}\n\nfunc jump(_ cell: Cell, code: [Instruction?], instructionPointer: inout Pointer, back: Bool = false) {\n    let comparison: Instruction = back ? \"[\" : \"]\"\n    let match: Instruction = back ? \"]\" : \"[\"\n    var nestCount = 0\n    while let instruction = code[instructionPointer],\n          instruction != comparison {\n        if instruction == match { nestCount += 1 }\n        instructionPointer += back ? -1 : 1\n        if code[instructionPointer] == comparison {\n            nestCount -= 1\n            if nestCount > 0 { instructionPointer += back ? -1 : 1 }\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339863,"user_id":null,"body":"func brainLuck(_ code: String, input: String) -> String {\n    var memoryCells: Array<UInt8?> = Array(repeating: 0, count: 30000)\n    var pointer = 0;\n    var result = \"\"\n    var bfOperator = code.startIndex\n    var inputByte = input.startIndex\n    \n    while bfOperator != code.endIndex {\n        switch code[bfOperator] {\n        case \">\":pointer+=1\n        case \"<\":pointer-=1\n        case \"+\":memoryCells[pointer] = memoryCells[pointer]! &+ 1\n        case \"-\":memoryCells[pointer] = memoryCells[pointer]! &- 1\n        case \".\":result += \"\\(UnicodeScalar(memoryCells[pointer]!))\"\n        case \",\":\n            var tempValue: UInt32 = 0\n            for el in input[inputByte].unicodeScalars{tempValue = el.value}\n            memoryCells[pointer] = UInt8(tempValue)\n            inputByte = input.index(after: inputByte)\n        case \"[\":\n            if memoryCells[pointer] == 0 {\n                var nestCounter = 1\n                while code[bfOperator] != \"]\" || nestCounter > 0 {\n                    bfOperator = code.index(after: bfOperator)\n                    if code[bfOperator] == \"[\" {nestCounter += 1} \n                    else if code[bfOperator] == \"]\" {nestCounter -= 1}\n                }\n            }\n        case \"]\":\n            if memoryCells[pointer] != 0 {\n                var nestCounter = 1\n                while code[bfOperator] != \"[\" || nestCounter > 0{\n                    bfOperator = code.index(before: bfOperator)\n                    if code[bfOperator] == \"]\" {nestCounter += 1} \n                    else if code[bfOperator] == \"[\" {nestCounter -= 1}\n                }\n            }\n        default:print(\"No such operator: \\(code[bfOperator])\")\n        }\n        bfOperator = code.index(after: bfOperator)\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339864,"user_id":null,"body":"func brainLuck(_ code: String, input: String) -> String {\n    var memoryCells: Array<UInt8?> = Array(repeating: 0, count: 30000)\n    var pointer = 0;\n    var result = \"\"\n    var bfOperator = code.startIndex\n    var inputByte = input.startIndex\n    \n    while bfOperator != code.endIndex {\n        switch code[bfOperator] {\n        case \">\":\n            pointer+=1\n            break\n        case \"<\":\n            pointer-=1\n            break\n        case \"+\":\n            memoryCells[pointer] = memoryCells[pointer]! &+ 1\n            break\n        case \"-\":\n            memoryCells[pointer] = memoryCells[pointer]! &- 1\n            break\n        case \".\":\n            result += \"\\(UnicodeScalar(memoryCells[pointer]!))\"\n            break\n        case \",\":\n            var tempValue: UInt32 = 0\n            for el in input[inputByte].unicodeScalars{\n                tempValue = el.value\n            }\n            memoryCells[pointer] = UInt8(tempValue)\n            inputByte = input.index(after: inputByte)\n            break\n        case \"[\":\n            if memoryCells[pointer] == 0 {\n                var nestCounter = 1\n                while code[bfOperator] != \"]\" || nestCounter > 0 {\n                    bfOperator = code.index(after: bfOperator)\n                    if code[bfOperator] == \"[\" {\n                        nestCounter += 1\n                    } else if code[bfOperator] == \"]\" {\n                        nestCounter -= 1\n                    }\n                }\n            }\n            break\n        case \"]\":\n            if memoryCells[pointer] != 0 {\n                var nestCounter = 1\n                while code[bfOperator] != \"[\" || nestCounter > 0{\n                    bfOperator = code.index(before: bfOperator)\n                    if code[bfOperator] == \"]\" {\n                        nestCounter += 1\n                    } else if code[bfOperator] == \"[\" {\n                        nestCounter -= 1\n                    }\n                }\n            }\n            break\n        default:\n            print(\"No such operator: \\(code[bfOperator])\")\n        }\n        bfOperator = code.index(after: bfOperator)\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339865,"user_id":null,"body":"class BrainLuckInterpretor {\n    enum Operation: Character {\n        case incrementPointer = \">\"\n        case decrementPointer = \"<\"\n        case incrementData = \"+\"\n        case decrementData = \"-\"\n        case output = \".\"\n        case input = \",\"\n        case startBlock = \"[\"\n        case endBlock = \"]\"\n        case undefined = \"?\"\n    }\n    \n    private var code: [Operation]\n    private var cell: [UInt8]\n    private var blockBegin: [Int:Int]\n    private var blockEnd: [Int:Int]\n\n    init(code: String) {\n        cell = Array(repeating: 0, count: 32000)\n        self.code = code.map{ Operation(rawValue: $0) ?? .undefined}\n        blockBegin = [:]\n        blockEnd = [:]\n        var beginForLevel = [Int:Int]()\n        var blockNum = -1\n        for index in self.code.indices {\n            if self.code[index] == .startBlock {\n                blockNum += 1\n                beginForLevel[blockNum] = index\n            } else if self.code[index] == .endBlock {\n                if let beginForLevel = beginForLevel[blockNum] {\n                    blockBegin[index] = beginForLevel\n                    blockEnd[beginForLevel] = index\n                } else {\n                    print(\"Unexcpected end block at \\(index)\")\n                }\n                blockNum -= 1\n            }\n        }\n    }\n    \n    func compute(withInput inputString: String) -> String {\n        let input = inputString.map{ $0.asciiValue ?? 0 }\n        var codePointer: Int = 0\n        var dataPointer: Int = 0\n        var loop = 0\n        var end = false\n        var output = \"\"\n        var inputIndex = 0\n        var error: String?\n        \n        while !end {\n            var warning: String?\n            let operation = code[codePointer]\n            \/\/print(\"\\(loop): \\(codePointer):\\(code[codePointer]):\\(operation) [\\(dataPointer)][\\(cell[dataPointer])] [\\(output)]\")\n            switch operation {\n                case .incrementPointer:\n                    \/\/ increment the data pointer (to point to the next cell to the right).\n                    if dataPointer < cell.count - 1 {\n                        dataPointer += 1\n                    } else {\n                        error = \"Bad access after memory\"\n                        end = true\n                    }\n                    \n                case .decrementPointer:\n                    \/\/ < decrement the data pointer (to point to the next cell to the left).\n                    if dataPointer > 0 {\n                        dataPointer -= 1\n                    } else {\n                        error = \"Bad access before memory\"\n                        end = true\n                    }\n                    \n                case .incrementData:\n                    \/\/ + increment (increase by one, truncate overflow: 255 + 1 = 0) the byte at the data pointer.\n                    if cell[dataPointer] < 255 {\n                        cell[dataPointer] += 1\n                    } else {\n                        cell[dataPointer] = 0\n                    }\n                    \n                case .decrementData:\n                    \/\/ - decrement (decrease by one, treat as unsigned byte: 0 - 1 = 255 ) the byte at the data pointer.\n                    if cell[dataPointer] > 0 {\n                        cell[dataPointer] -= 1\n                    } else {\n                        cell[dataPointer] = 255\n                    }\n                    \n                case .output:\n                    \/\/ . output the byte at the data pointer.\n                    if cell[dataPointer] == 0 {\n                        end = true\n                    } else {\n                        output.append(Character(UnicodeScalar(cell[dataPointer])))\n                    }\n                    \n                case .input:\n                    \/\/ , accept one byte of input, storing its value in the byte at the data pointer.\n                    if inputIndex < input.count {\n                        cell[dataPointer] = input[inputIndex]\n                        inputIndex += 1\n                    } else {\n                        end = true\n                        warning = \"Too few input\"\n                    }\n                    \n                case .startBlock:\n                    \/\/ [ if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.\n                    if cell[dataPointer] == 0 {\n                        if let blockEnd = blockEnd[codePointer] {\n                            codePointer = blockEnd\n                        } else {\n                            error = \"End of block not found\"\n                            end = true\n                        }\n                    } else {\n                        \/\/print(\" run inside block (\\(cell[dataPointer]))\")\n                    }\n                    \n                case .endBlock:\n                    \/\/ ] if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.\n                    if cell[dataPointer] != 0 {\n                        \/\/print(\" Goto begin of block\")\n                        if let blockBegin = blockBegin[codePointer] {\n                            codePointer = blockBegin\n                        } else {\n                            error = \"No start for block\"\n                            end = true\n                        }\n                    } else {\n                       \/\/ print(\" after block (\\(cell[dataPointer]))\")\n                    }\n                    \n                case .undefined:\n                    error = \"Unknown instruction at \\(codePointer)\"\n                    end = true\n            }\n            \n            if codePointer < code.count - 1 {\n                codePointer += 1\n            } else {\n                end = true\n            }\n            \n            if let warning = warning {\n                print(\"warning at \\(codePointer) : \\(warning) [\\(output)]\")\n            }\n            \n            loop += 1\n            if loop > 1000000 {\n                error = \"Too many loop\"\n                end = true\n            }\n        }\n        \n        if let error = error {\n            print(\"Error at \\(codePointer) : \\(error) [\\(output)]\")\n        }\n        \n        return output\n    }\n}\n\nfunc brainLuck(_ code: String, input: String) -> String {\n    print(\"Running code (\\(code)) with input (\\(input))\")\n\/\/ > increment the data pointer (to point to the next cell to the right).\n\/\/ < decrement the data pointer (to point to the next cell to the left).\n\/\/ + increment (increase by one, truncate overflow: 255 + 1 = 0) the byte at the data pointer.\n\/\/ - decrement (decrease by one, treat as unsigned byte: 0 - 1 = 255 ) the byte at the data pointer.\n\/\/ . output the byte at the data pointer.\n\/\/ , accept one byte of input, storing its value in the byte at the data pointer.\n\/\/ [ if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.\n\/\/ ] if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.\n    let interpretor = BrainLuckInterpretor(code: code)\n    \n    return interpretor.compute(withInput: input)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339866,"user_id":53,"body":"func brainLuck(_ code: String, input: String) -> String {\n\n  let code = Array(code)\n  let input = Array(input)\n  var tape: [Int] = [Int](repeating: 0, count: 30000)\n  var output : [Int] = []\n  var (i, ptr, k) = (0, 0, 0)\n\n  while i < code.count {\n    switch code[i] {\n      case \">\":\n        ptr += 1\n      case \"<\":\n        ptr -= 1\n      case \"+\":\n        tape[ptr] = (tape[ptr] + 1) % 256\n      case \"-\":\n        tape[ptr] = (tape[ptr] + 255) % 256\n      case \".\":\n        output.append(tape[ptr])\n      case \",\":\n        let register = String(input[k]).unicodeScalars\n        tape[ptr] = Int(register[register.startIndex].value)\n        k += 1\n      case \"[\":\n        if (tape[ptr] == 0) {\n          var n = 1\n          while (n>0) {\n            i += 1\n            if (code[i] == \"[\") {\n              n += 1\n            }\n            if (code[i] == \"]\") {\n              n -= 1\n            }\n          }\n        }\n      case \"]\":\n        if (tape[ptr] != 0) {\n          var n = 1\n          while (n>0) {\n            i -= 1 \n            if (code[i] == \"]\") {\n              n += 1\n            }\n            if (code[i] == \"[\") {\n              n -= 1\n            }\n          } \n        }\n      default:\n        break\n    }\n    i += 1\n  }\n\n  return output.reduce(\"\") { return $0 + \"\\(UnicodeScalar($1)!)\"}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339867,"user_id":null,"body":"extension StringProtocol {\n  subscript(offset: Int) -> Character {\n    self[index(startIndex, offsetBy: offset)]\n  }\n}\n\nfunc brainLuck(_ code: String, input: String) -> String {\n  var instructionPointerPos = 0\n  var inputPointerPos = 0\n  var dataPointerPos = 0\n  \n  var cells: [UInt8] = [UInt8](repeating: 0, count: 30000)\n  \n  var result: [UnicodeScalar] = [UnicodeScalar]()\n  \n  let inputStream: [UInt8] = input.unicodeScalars.map { UInt8($0.value) }\n  var step = 0\n  \n  while instructionPointerPos < code.count {\n    let token: Character = code[instructionPointerPos]\n    \n    switch token {\n      case \">\":  \n      dataPointerPos += 1\n      case \"<\":\n      dataPointerPos -= 1\n      case \"+\":\n        if cells[dataPointerPos] == 255 {\n            cells[dataPointerPos] = 0\n        } else {\n            cells[dataPointerPos] += 1\n        }\n      case \"-\":\n        if cells[dataPointerPos] == 0 {\n            cells[dataPointerPos] = 255\n        } else {\n            cells[dataPointerPos] -= 1\n        }\n      case \".\": \n      result.append(UnicodeScalar(cells[dataPointerPos]))\n      case \",\":\n        if inputPointerPos < inputStream.count {\n            cells[dataPointerPos] = inputStream[inputPointerPos]\n            inputPointerPos += 1\n        }\n      case \"[\":\n        if cells[dataPointerPos] == 0 {\n            var openBraces = 0\n            let start = instructionPointerPos + 1\n          \n            for n in start..<code.count {\n              if code[n] == \"[\" {\n                openBraces += 1\n              }\n              \n              if code[n] == \"]\" {\n                if openBraces > 0 {\n                  openBraces -= 1\n                } else {\n                  instructionPointerPos = n\n                  break\n                }\n              }\n            }\n        }\n      case \"]\":\n          if cells[dataPointerPos] != 0 {\n            var openBraces = 0\n            let start = instructionPointerPos - 1\n            for n in stride(from: start, through: 0, by: -1) {\n              if code[n] == \"]\" {\n                openBraces += 1\n              }\n              \n              if code[n] == \"[\" {\n                if openBraces > 0 {\n                  openBraces -= 1\n                } else {\n                  instructionPointerPos = n\n                  break\n                }\n              }\n            }\n          }\n      default:\n        break\n      }\n      \n    instructionPointerPos += 1\n    step += 1\n  }\n\n  return String(result.map { Character($0) } )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5263a84ffcadb968b6000513":[{"id":339868,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n    var ans = Array(repeating: Array(repeating: 0, count: a.count), count: a.count)\n    for i in 0..<ans.count {\n        for j in 0..<ans.count {\n            var sum = 0\n            for k in 0..<ans.count {\n                sum += a[i][k] * b[k][j]\n            }\n            ans[i][j] = sum\n        }\n    }\n    return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339869,"user_id":null,"body":"func matrixMultiplication(_ a: [[Int]], _ b: [[Int]]) -> [[Int]] {\n    \n    let rows = a\n    \n    let columns = b[0].indices.map { col in\n        b.indices.map { row in\n            b[row][col]\n        }\n    }\n    \n    return rows.map { row -> [Int] in\n        \n        return columns.map { column -> Int in\n            \n            return zip(row, column).reduce(0, { (result, value) -> Int in\n                return result + value.0 * value.1\n            })\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339870,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n  let size = min(a.count, b.count)\n  guard size > 0 else { return [] }\n  guard a.reduce(true, { $0 && $1.count == size }) else { return [] }\n  guard b.reduce(true, { $0 && $1.count == size }) else { return [] }\n  \n  func row(_ ind: Int, of arr: [[Int]]) -> [Int] {\n    return arr[ind]\n  }\n  func column(_ ind: Int, of arr: [[Int]]) -> [Int] {\n    return arr.map { $0[ind] }\n  }\n  func transpose(_ arr: [[Int]]) -> [[Int]] {\n    return (0..<arr.count).map { column($0, of: arr) }\n  }\n  \n  let transposed = transpose(b)\n  var result = [[Int]]()\n  for rowIndex in (0..<size) {\n    let rowOfA = row(rowIndex, of: a)\n    var rowOfResult = [Int]()\n    for colIndex in (0..<size) {\n      let colOfB = row(colIndex, of: transposed)\n      let item = zip(rowOfA, colOfB).map(*).reduce(0, +)\n      rowOfResult.append(item)\n    }\n    result.append(rowOfResult)\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339871,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n    var result = Array(repeating: Array(repeating: 0, count: a.count), count: a.count)\n    for i in 0..<a.count {\n        for j in 0..<b.count {\n            result[i][j] = zip(a[i], b.map({ $0[j] })).map({$0 * $1}).reduce(.zero, +)\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339872,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n  var arr = [[Int]](repeating: [Int](repeating: 0, count: a.count), count: a.count)\n  for i in 0..<a.count {\n    for j in 0..<a.count {\n      for k in 0..<a.count {\n        arr[i][j] += a[i][k] * b[k][j]\n      }    \n    }\n  }\n  return arr\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339873,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n var result = [[Int]]()\n    for indexLine in 0..<a.count {\n        var line = [Int]()\n        for indexVert in 0..<a[indexLine].count {\n            var tempSum = 0\n            for i in 0..<a.count {\n                let mult = a[indexLine][i] * b[i][indexVert]\n                tempSum += mult\n            }\n            line.append(tempSum)\n        }\n        result.append(line)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339874,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n    var result: [[Int]] = [[Int]](repeating: [Int](repeating: 0, count: b.count), count: a.count)\n    for i in 0..<a.count {\n        let row = a[i]\n        for j in 0..<b.count {\n            let column = b.flatMap { $0[j] }\n            result[i][j] = (0..<a.count).map { row[$0] * column[$0] }.reduce(0, +)\n        }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339875,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n    var result: [[Int]] = []\n    var resultRow: [Int] = []\n    \n    var rowA: [Int] = []\n    var colB: [Int] = []\n    \n    for i in 0..<a.count {\n        rowA = a[i]\n        for j in 0..<b.count {\n            colB = b.map { $0[j] }\n            resultRow.append(sumMultiplyTwoArrys(rowA, colB))\n        }\n        result.append(resultRow)\n        resultRow = []\n    }\n    \n    return result\n}\n\nfunc sumMultiplyTwoArrys(_ first: [Int], _ second: [Int]) -> Int {\n    return zip(first, second).map({$0 * $1}).reduce(.zero, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339876,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n    var c:[[Int]] = [[Int]](repeating: [Int](repeating: 0, count: a.count), count: a.count)\n    \n    print(a.count,b.count)\n    \n    for row in 0..<a.count {\n        for col in 0..<a.count {\n            c[row][col] = 0\n            for i in 0..<a.count {\n                c[row][col] += a[row][i]*b[i][col]\n            }\n        }\n    }\n    return c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339877,"user_id":null,"body":"func matrixMultiplication(_ a:[[Int]], _ b:[[Int]]) -> [[Int]] {\n    var result = Array(repeating: Array(repeating: 0, count: b[0].count), count: a.count)\n    for row in 0..<result.count{\n        for col in 0..<result[0].count{\n            for i in 0..<b.count{\n                result[row][col] += a[row][i] * b[i][col]\n            }\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5263c5d011f4233c9d000561":[{"id":339878,"user_id":null,"body":"func getLines(_ num:Int?) -> String {\n    if num == nil || num! <= 0 { return \"-1\"}\n    var res = [\"1\"]\n    for idx in 0..<num! - 1 {\n        var str = \"\", preChar : Character?, count = 1\n        for char in res[idx] {\n            if char == preChar {\n                count += 1\n            }else {\n                if let val = preChar {\n                str += \"\\(count)\\(val)\"\n                }\n                preChar = char\n                count = 1\n            }\n        }\n        str += \"\\(count)\\(preChar!)\"\n        res += [str]\n    }\n    \n    return String(res.reduce(\"\"){$0 + \",\" + $1}.dropFirst())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339879,"user_id":null,"body":"\/\/\n\/\/  TheLookAndSaySequence.swift\n\/\/  Codewars\n\/\/\n\/\/  Created by jason debolt on 11\/30\/16.\n\/\/  Copyright \u00a9 2016 jasondebolt. All rights reserved.\n\/\/\n\nimport Foundation\n\nfunc nextNumber(_ str: String) -> String {\n    var copy = str\n    var currentChar: Character\n    var numberGroups = [String]()\n    \n    for symbol in str {\n        currentChar = symbol\n        let group = copy.prefix() { $0 == currentChar }\n        numberGroups.append(String(group))\n        copy.removeFirst(group.count)\n    }\n\n    return numberGroups\n        .filter { $0.count >= 1 }\n        .map { \"\\($0.count)\\($0.first!)\" }\n        .joined()\n}\n\nfunc getLines(_ num:Int?) -> String {\n    guard let num = num else { return \"-1\" }\n    if num < 1 { return \"-1\" }\n    var result = [\"1\"]\n    \n    (1..<num).forEach { _ in\n        let newValue = nextNumber(result.last!)\n        result.append(newValue)\n    }\n    return result.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339880,"user_id":null,"body":"import Foundation\n\nfunc getLines(_ num: Int?) -> String {\n    let num = num ?? 0\n    if num <= 0 || num == FP_NAN {\n        return \"-1\"\n    } else {\n        var trace = [\"1\"]\n        for _ in 1..<num {\n            var read = [Any]()\n            trace.last?.forEach { (c: Character) in\n                if read.count == 0 || c != read.last as! Character {\n                    read.append(1)\n                    read.append(c)\n                }\n                else{\n                    read[read.count-2] = read[read.count-2] as! Int + 1\n                }\n            }\n            trace.append(read.map { \"\\($0)\" }.joined())\n        }\n        return trace.joined(separator: \",\")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339881,"user_id":null,"body":"\/\/ MARK: - Internal methods\nfunc getLines(_ num:Int?) -> String {\n    guard var num = num, num > 0 else { return \"-1\" }\n    guard !(1...5).contains(num) else { return smallCases(num: num) }\n    \n    var counter = Int()\n    var canLoop = true\n    var lastNumber = \"111221\"\n    \n    var sequence = \"1,11,21,1211,111221,\" {\n        didSet {\n            let numberOfElements = sequence.components(separatedBy: \",\").count\n            if numberOfElements == num && lastNumber.isEmpty {\n                canLoop = false\n            }\n        }\n    }\n    \n    while canLoop {\n        for (index, digit) in lastNumber.enumerated() {\n            guard index < lastNumber.count - 1 else {\n                updateSequence(&counter, valueForCounter: 1, &sequence, digit, &lastNumber, &num)\n                break\n            }\n            \n            guard let currentIndex = lastNumber.firstIndex(of: digit) else { return \"\" }\n            let secondIndex = lastNumber.index(after: currentIndex)\n            let secondDigit = lastNumber[secondIndex]\n            \n            if digit != secondDigit {\n                updateSequence(&counter, valueForCounter: 1, &sequence, digit, &lastNumber, &num)\n                break\n            }\n            \n            if lastNumber.count >= 3 {\n                let thirdIndex = lastNumber.index(after: secondIndex)\n                let thirdDigit = lastNumber[thirdIndex]\n                if digit == secondDigit && secondDigit == thirdDigit {\n                    updateSequence(&counter, valueForCounter: 3, &sequence, digit, &lastNumber, &num)\n                    break\n                }\n            }\n            \n            if digit == secondDigit {\n                updateSequence(&counter, valueForCounter: 2, &sequence, digit, &lastNumber, &num)\n                break\n            }\n        }\n    }\n    \n    return sequence\n}\n\n\/\/ MARK: - Private methods\nprivate func smallCases(num: Int) -> String {\n    switch num {\n    case 1: return \"1\"\n    case 2: return \"1,11\"\n    case 3: return \"1,11,21\"\n    case 4: return \"1,11,21,1211\"\n    case 5: return \"1,11,21,1211,111221\"\n    default:\n        return \"-1\"\n    }\n}\n\nprivate func updateSequence(_ counter: inout Int, valueForCounter: Int, _ sequence: inout String, _ digit: String.Element, _ lastNumber: inout String, _ num: inout Int) {\n    counter = valueForCounter\n    sequence.append(\"\\(counter)\" + String(digit))\n    \n    for _ in 1...valueForCounter {\n        lastNumber.removeFirst()\n    }\n    \n    if lastNumber.isEmpty && !(sequence.dropLast().components(separatedBy: \",\").count == num) {\n        lastNumber = sequence.components(separatedBy: \",\").last ?? \"\"\n        sequence.append(\",\")\n    }\n    \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339882,"user_id":null,"body":"\/\/\n\/\/  TheLookAndSaySequence.swift\n\/\/  Codewars\n\/\/\n\/\/  Created by jason debolt on 11\/30\/16.\n\/\/  Copyright \u00a9 2016 jasondebolt. All rights reserved.\n\/\/\n\nimport Foundation\n\nfunc next_line(_ s:String) -> String {\n  var line = \"\"\n  let c = Array(s)\n  var r = c[0]\n  var n = 1\n  for i in c[1...] {\n    if i != r {\n      line += \"\\(n)\\(r)\"\n      r = i\n      n = 1\n    } else {\n      n += 1\n    }\n  }\n  line += \"\\(n)\\(r)\"\n  return line\n}\n\nfunc getLines(_ num:Int?) -> String {\n  if num == nil || num! < 1 {\n    return \"-1\"\n  }\n  let n = num!\n  \n  var lines = [\"1\"]\n    \n  for _ in 0..<(n-1) {\n    lines.append(next_line(lines[lines.count-1]))\n  }\n  \n  return lines.joined(separator: \",\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339883,"user_id":null,"body":"\/\/\n\/\/  TheLookAndSaySequence.swift\n\/\/  Codewars\n\/\/\n\/\/  Created by jason debolt on 11\/30\/16.\n\/\/  Copyright \u00a9 2016 jasondebolt. All rights reserved.\n\/\/\n\nimport Foundation\n\nfunc getLines(_ num:Int?) -> String {\n  if num == nil {\n    return \"-1\"\n  }\n  else if num! <= 0{\n    return \"-1\"\n  }\n  else if num! == 1 {\n    return \"1\"\n  }\n  \n  else {\n    var returnNum = \"1\"\n    var returnString = \"1\"\n    for _ in 1...(num! - 1) {\n      let digits = returnNum.compactMap{ $0.wholeNumberValue }\n      print(digits)\n      var currentDigit = digits[0]\n      \n      var currentCount = 1\n      var interMediary = \"\"\n      if digits.count == 1 {\n        interMediary = interMediary + \"\\(currentCount)\\(currentDigit)\"\n      }\n      else {\n        for i in 1...digits.count-1 {\n          if digits[i] == digits[i-1]{\n            currentCount += 1\n          }\n          else {\n            interMediary = interMediary + \"\\(currentCount)\\(currentDigit)\"\n            currentDigit = digits[i]\n            currentCount = 1\n          }\n        }\n       interMediary = interMediary + \"\\(currentCount)\\(currentDigit)\"\n\n      }\n      returnNum = interMediary\n      returnString = returnString + \",\\(returnNum)\"\n    }\n    print(\"-\")\n    return returnString\n  \n  \n  \n  \n  \n  }\n  \n\n  \n  \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339884,"user_id":null,"body":"import Foundation\n\nfunc nextString(_ str1: String) -> String {\n    var sameWordCount: Int = -1\n    var sampleChar: Character = \"x\"\n    var outputString: String = \"\"\n    for c in str1 {\n        if sameWordCount == -1 {\n            sampleChar = c\n            sameWordCount = 1\n        }\n        else {\n            if c == sampleChar {\n                sameWordCount += 1\n            }\n            else {\n                outputString.append(\"\\(sameWordCount)\\(sampleChar)\")\n                sampleChar = c\n                sameWordCount = 1\n            }\n        }\n    }\n    outputString.append(\"\\(sameWordCount)\\(sampleChar)\")\n    return outputString\n}\nfunc getLines(_ num:Int?) -> String {\n    if num == nil {\n        return \"-1\"\n    }\n    else if num! < 1 {\n        return \"-1\"\n    }\n    else if num == 1 {\n        return \"1\"\n    }\n    else {\n        var ans: String = \"1\"\n        var nowString: String = \"1\"\n        var runTimeCount: Int = 1\n        while runTimeCount < num! {\n            nowString = nextString(nowString)\n            ans.append(\",\\(nowString)\")\n            runTimeCount += 1\n        }\n        return ans\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339885,"user_id":null,"body":"func getLines(_ num:Int?) -> String {\n    guard let num = num, num>0 else { return \"-1\" }\n    var stringNum = \"1\"\n    var ret:[String] = [stringNum]\n    if num == 1 { return stringNum }\n    for _ in 1...num-1 {\n        var count = 0\n        let a = stringNum.characters.map{String($0)}\n        stringNum = \"\"\n        for (i, e) in a.enumerated() {\n            let isSamePrev = i == 0 || e == a[i-1]\n            let isLast = i+1 == a.count\n            if isSamePrev {  count += 1 }\n            else {\n                stringNum.append(String(count))\n                stringNum.append(a[i-1])\n                count = 1\n            }\n            if isLast {\n                stringNum.append(String(isSamePrev ? count : 1))\n                stringNum.append(e)\n            }\n        }\n        ret.append(stringNum)\n    }\n    return ret.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339886,"user_id":null,"body":"func getLines(_ num: Int?) -> String {\n  guard let num = num, num > 0 else { return \"-1\" }\n  guard num > 1 else { return \"1\" }\n  \n  let pref = getLines(num - 1)\n  let last = pref.components(separatedBy: \",\").last!.map { $0 }\n  \n  var next = \"\"\n  var i = 1\n  var n = 1\n  var c = last[0]\n  \n  while i < last.count {\n    defer { i += 1 }\n    guard last[i] != c else { n += 1; continue }\n    next += \"\\(n)\\(c)\"\n    c = last[i]\n    n = 1\n  }\n  next += \"\\(n)\\(c)\"\n  \n  return \"\\(pref),\\(next)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339887,"user_id":null,"body":"\/\/\n\/\/  TheLookAndSaySequence.swift\n\/\/  Codewars\n\/\/\n\/\/  Created by jason debolt on 11\/30\/16.\n\/\/  Copyright \u00a9 2016 jasondebolt. All rights reserved.\n\/\/\n\nimport Foundation\n\nfunc lookAndSayNext(num:String) ->String{\n    var current:Character = \"\n\"\n    var nextNum = \"\"\n    var count = 0\n    for i in 0..<num.count{\n        let digit = num[num.index(num.startIndex, offsetBy: i)]\n        if current == \"\n\"{\n            current = digit\n        }\n        if digit == current{\n            count += 1\n        }\n        if i<num.count-1 && digit != num[num.index(num.startIndex, offsetBy: i+1)]{\n            nextNum += String(count)+String(digit)\n            count = 0\n            current = \"\n\"\n        }\n        else if i == num.count - 1{\n            nextNum += String(count)+String(digit)\n            break\n        }\n    }\n    return nextNum\n}\n\nfunc getLines(_ num:Int?) -> String {\n    guard let num = num else{\n        return \"-1\"\n    }\n    if num <= 0{\n        return \"-1\"\n    }\n    else if num == 1{\n        return \"1\"\n    }\n    else {\n        let previous = getLines(num-1)\n        let lastNumber = previous.split(separator: \",\").last!\n        return previous+\",\"+lookAndSayNext(num: String(lastNumber))\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5264d2b162488dc400000001":[{"id":339888,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    sentence\n        .split(separator: \" \")\n        .map { \"\\($0)\" }\n        .map { $0.count > 4 ? String($0.reversed()) : $0 }\n        .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339889,"user_id":null,"body":"let wordLength = 5\n\nfunc spin_words(in sentence: String) -> String {\n    sentence\n        .components(separatedBy: \" \")\n        .map { $0.count >= wordLength ? String($0.reversed()) : String($0) }\n        .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339890,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    sentence\n      .components(separatedBy: \" \")\n      .map { $0.count < 5 ? $0 : String($0.reversed()) }\n      .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339891,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    let words = sentence.split(separator: \" \").map(String.init).map(reverseIfApplicable)\n    \n    return words.joined(separator: \" \")\n}\n\nfunc reverseIfApplicable(_ word: String) -> String {\n    word.count >= 5 ? String(word.reversed()) : word\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339892,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    let newSentence = sentence.split(separator: \" \").map({(val) -> String in\n    if(val.count > 4){\n        return String(val.reversed())\n    }else{\n        return String(val)\n    }\n})\n    return newSentence.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339893,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    var result = String()\n    \n    for word in sentence.components(separatedBy: \" \") {\n        word.count >= 5 ? result.append(word.reversed() + \" \") : result.append(word + \" \")\n    }\n    \n    return result.trimmingCharacters(in: .whitespaces)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339894,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    var wordsArray = sentence.split(separator: \" \")\n    var ansArray: [String] = []\n\n    for word in wordsArray {\n        if word.count >= 5 {\n            ansArray.append(String(word.reversed()))\n        }\n        else {\n            ansArray.append(String(word))\n        }\n    }\n    return ansArray.joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339895,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    return sentence\n        .split(separator: \" \")\n        .map { \"\\($0)\" }\n        .map { $0.count > 4 ? String($0.reversed()) : $0 }\n        .joined(separator: \" \") \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339896,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n    let splittedWords = sentence.split(separator: \" \")\n    var emptyString = \"\"\n    for (index,word) in splittedWords.enumerated(){\n      if index == splittedWords.count - 1{\n        emptyString += (word.count > 4 ? String(word.reversed()) : String(word))\n      }else{\n        emptyString += (word.count > 4 ? String(word.reversed()) : String(word)) + \" \"\n      }\n    }\n    return emptyString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339897,"user_id":null,"body":"func spin_words(in sentence: String) -> String {\n        let box = sentence.split(separator: \" \")\n        return box.map { (item) -> String in\n            let cp = String(item)\n            \n            if item.count > 4 {\n                return cp.reversed().map(String.init).joined()\n            }\n            return cp\n        }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"526571aae218b8ee490006f4":[{"id":339898,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\n    return n.nonzeroBitCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339899,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\n  return String(n, radix: 2).filter { $0 == \"1\" }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339900,"user_id":null,"body":"func count_bits(_ n: Int) -> Int\n{\n    return n > 0 ? count_bits(n >> 1) + (n & 1) : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339901,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\n  n.nonzeroBitCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339902,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\n    return String(n, radix: 2).reduce(0) { $1 == \"1\" ? $0 + 1 : $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339903,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\n  var number = n\n  var res = 0\n  while number > 0 {\n    res += number % 2\n    number \/= 2\n  }\n  return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339904,"user_id":null,"body":"func count_bits(_ n: Int) -> Int{\n    return n > 0 ? count_bits(n & (n - 1)) + 1 : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339905,"user_id":null,"body":"import Foundation\n\n\nfunc count_bits(_ n: Int) -> Int {\n    var bitNumber: String  = \"\"\n    var n_iter: Int = n\n    repeat {\n        bitNumber += String(n_iter % 2)\n        n_iter \/= 2\n    } while n_iter != 0\n    return bitNumber.components(separatedBy: \"1\").count - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339906,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\nlet str = String(n, radix: 2, uppercase: true)\nlet arrnumb = str.compactMap(\\.wholeNumberValue)\nlet sum = arrnumb.reduce(0, +)\nreturn sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339907,"user_id":null,"body":"func count_bits(_ n: Int) -> Int {\n  \/\/ Show me the code!\n  let num = n\n  let str = String(num, radix: 2)    \n  var result:Int = 0\n \n  let digits = str.compactMap{ $0.wholeNumberValue }\n  print(digits)\n\n  for i in stride(from: 0, to: digits.count, by: 1){\n\n      if digits[i] == 1 {\n          result += 1\n      }\n  }\n\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5270f22f862516c686000161":[{"id":339908,"user_id":null,"body":"extension String {\n    public var toBase64: String {\n        Data(utf8).base64EncodedString()\n    }\n\n    public var fromBase64: String {\n        guard let data = Data(base64Encoded: self) else { return \"\" }\n        return String(data: data, encoding: .utf8)!\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339909,"user_id":null,"body":"extension String {\n\tpublic var toBase64: String {\n\t\t\/\/ Do something!\n    self.data(using: .utf8)!.base64EncodedString()\n\t}\n\t\n\tpublic var fromBase64: String {\n    \/\/ Do something!\n\t\tString(data: Data(base64Encoded: self)!, encoding: .utf8)!\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339910,"user_id":null,"body":"let base64Table = [\n  \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\n  \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\n  \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\",\n  \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"+\", \"\/\",\n]\n\nextension Array {\n    func chunks(size: Int) -> [[Element]] {\n        return stride(from: 0, to: count, by: size).map {\n            Array(self[$0 ..< Swift.min($0 + size, count)])\n        }\n    }\n}\n\nextension String {\n    func chunks(size: Int) -> [String] {\n        map { $0 }.chunks(size: size).compactMap { String($0) }\n    }\n}\n\nextension String {\n        public var toBase64: String {\n        let bits = self\n            .map { String.init(repeating: \"0\", count: $0.asciiValue!.leadingZeroBitCount) + String($0.asciiValue!, radix: 2) }\n            .joined()\n        \n        let padding = bits.count % 24\n        \n        let base64 = bits\n            .chunks(size: 6)\n            .compactMap{ String($0) }\n            .map {\n      \n                var sextet = 0\n                if $0.count != 6 {\n                    let trailingZero = String($0) + String.init(repeating: \"0\", count: 6 - $0.count)\n                    sextet = Int(trailingZero, radix: 2)!\n                } else {\n                    sextet = Int($0, radix: 2)!\n                }\n                return base64Table[sextet]\n            }\n            .joined()\n        \n        return padding != 0 ? base64 + String.init(repeating: \"=\", count: 16 \/ padding) : base64\n    }\n    \n    public var fromBase64: String {\n        return self\n            .map { return $0 != \"=\" ? base64Table.firstIndex(of: \"\\($0)\")! : 0 }\n            .map { String.init(repeating: \"0\", count: 6 - String($0, radix: 2).count) + String($0, radix: 2) }\n            .joined()\n            .chunks(size: 8)\n            .map { String(UnicodeScalar(Int($0, radix: 2)!)!) }\n            .filter { $0 != \"\\0\" }\n            .joined()\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339911,"user_id":null,"body":"extension String {\n  static let base64Chars: [UInt8] = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/\".utf8)\n  \n\tpublic var toBase64: String {\n\t\tlet inputData = [UInt8](utf8)\n    let transformedBytes = inputData.transformedFrom8To6Bits()\n\n    let resultString = transformedBytes.map {\n        String(decoding: [String.base64Chars[Int($0)]], as: UTF8.self)\n    }.joined()\n\n    let extra = 4 - resultString.count % 4\n    let extraString = extra < 4 ? String(repeating: \"=\", count: extra) : \"\"\n    return resultString + extraString\n\t}\n\t\n\tpublic var fromBase64: String {\n    let inputData = [UInt8](utf8)\n    let dataToTransform: [UInt8] = inputData.compactMap {\n        if let value = String.base64Chars.firstIndex(of: $0) {\n            return UInt8(value)\n        } else {\n            return nil\n        }\n    }\n    let transformedBytes = dataToTransform.transformedFrom6To8Bits()\n    return transformedBytes.map {\n        String(decoding: [$0], as: UTF8.self)\n    }.joined()\n\t}\n}\n\n\/\/ MARK: - Base64 Encoding\nextension Array where Element == UInt8 {\n    \/\/ Transforms an array of [UInt8] that contains 8 bits in each element\n    \/\/ into an array of [UInt8] that contains 6 bits in each element\n    \/\/ and returns result\n    func transformedFrom8To6Bits() -> Self {\n        var resultArray: [UInt8] = []\n\n        var index = 0\n        while index < count {\n            if count - index < 3 {\n                let transformed = Array(self[index...]).transfromedBytesEncoding()\n                resultArray.append(contentsOf: transformed)\n                index += count - index\n            } else {\n                let transformed = Array(self[index...index + 2]).transfromedBytesEncoding()\n                resultArray.append(contentsOf: transformed)\n                index += 3\n            }\n        }\n\n        return resultArray\n    }\n    \n    \/\/ Transforms 1-3 bytes into 2-4 elements of 6 bits and returns result\n    private func transfromedBytesEncoding() -> Self {\n        guard count <= 3 else {\n            assertionFailure(\"Wrong number of elements\")\n            return []\n        }\n\n        if count == 3 {\n            return [\n                \/\/ 1st: only need first 6 bits from element 0 (same for all cases)\n                self[0] >> 2,\n                \/\/ 2nd: take 7-8 bits from element 0 and first 4 bits from element 1\n                self[0] << 4 & 0b00110000 + self[1] >> 4,\n                \/\/ 3rd: shift by 2 element 1 to get space for 2 more bits and mask to have only 4 bits\n                \/\/ (originally last 4 bits from element 1)\n                \/\/ and add first 2 bits from element 2 to the end\n                self[1] << 2 & 0b00111100 + self[2] >> 6,\n                \/\/ 4th: take last 6 bits\n                self[2] & 0b00111111\n            ]\n        } else if count == 2 {\n            return [\n                \/\/ 1st: only need first 6 bits from element 0 (same for all cases)\n                self[0] >> 2,\n                \/\/ 2nd: take 7-8 bits from element 0 and first 4 bits from element 1 (same as for 3 bytes)\n                self[0] << 4 & 0b00110000 + self[1] >> 4,\n                \/\/ 3rd: shift by 2 element 1 to get space for 2 more bits and mask to have only 4 bits\n                \/\/ (originally last 4 bits from element 1)\n                \/\/ (difference from 3 bytes is that nothing to add to it\n                self[1] << 2 & 0b00111100\n            ]\n        } else {\n            return [\n                \/\/ 1st: only need first 6 bits from element 0 (same for all cases)\n                self[0] >> 2,\n                \/\/ 2nd: take 7-8 bits from element 0\n                self[0] << 4 & 0b00110000\n            ]\n        }\n    }\n}\n\n\/\/ MARK: - Base64 Decoding\nextension Array where Element == UInt8 {\n    \/\/ Transforms an array of [UInt8] that contains 8 bits in each element\n    \/\/ into an array of [UInt8] that contains 6 bits in each element\n    \/\/ and returns result\n    func transformedFrom6To8Bits() -> Self {\n        var resultArray: [UInt8] = []\n        \n        var index = 0\n        while index < count {\n            if count - index < 4 {\n                let transformed = Array(self[index...]).transfromedBytesDecoding()\n                resultArray.append(contentsOf: transformed)\n                index += count - index\n            } else {\n                let transformed = Array(self[index...index + 3]).transfromedBytesDecoding()\n                resultArray.append(contentsOf: transformed)\n                index += 4\n            }\n        }\n        \n        return resultArray\n    }\n    \n    \/\/ Transforms 2-4 elements of 6 bits into 1-3 bytes and returns result\n    private func transfromedBytesDecoding() -> Self {\n        guard count <= 4 && count > 1 else {\n            assertionFailure(\"Wrong number of elements\")\n            return []\n        }\n        \n        let result: [UInt8]\n        \n        if count == 4 {\n            result = [\n                self[0] << 2 + self[1] >> 4,\n                self[1] << 4 + self[2] >> 2,\n                self[2] << 6 + self[3]\n            ]\n        } else if count == 3 {\n            result = [\n                self[0] << 2 + self[1] >> 4,\n                self[1] << 4 + self[2] >> 2,\n            ]\n        } else {\n            result = [\n                self[0] << 2 + self[1] >> 4\n            ]\n        }\n\n        return result\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339912,"user_id":null,"body":"extension String {\n    public var toBase64: String {\n        let binaryData = Data(self.utf8)\n        return binaryData.base64EncodedString()\n    }\n    \n    public var fromBase64: String {\n        let binaryData = Data(base64Encoded: self)!\n        return String(data: binaryData, encoding: .utf8)!\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339913,"user_id":null,"body":"extension String {\n\tpublic var toBase64: String {\n\t\tlet utf8str = self.data(using: .utf8)\n    if let base64Encoded = utf8str?.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)) {\n      return base64Encoded\n    }\n    return self\n\t}\n\t\n\tpublic var fromBase64: String {\n    let utf8str = self.data(using: .utf8)\n    if let base64Decoded = Data(base64Encoded: self, options: Data.Base64DecodingOptions(rawValue: 0))\n    .map({ String(data: $0, encoding: .utf8) }) {\n        return base64Decoded ?? \"\"\n    }\n\t\treturn self\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339914,"user_id":null,"body":"extension String {\n\tpublic var toBase64: String {\n\t\t\/\/ Do something!\n    if let data = self.data(using: .utf8){\n      return data.base64EncodedString()\n    }\n    return self\n\t}\n\t\n\tpublic var fromBase64: String {\n    \/\/ Do something!\n\t\tif let data = Data(base64Encoded: self), let decoded = String(data: data, encoding: .utf8){\n      return decoded\n    }\n    return self\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339915,"user_id":null,"body":"private let table: [String] = (0...64)\n  .map { UInt8($0) }\n  .map {\n    switch $0 {\n    case ...25: return String(UnicodeScalar($0 + Character(\"A\").asciiValue!))\n    case ...51: return String(UnicodeScalar($0 - 26 + Character(\"a\").asciiValue!))\n    case ...61: return String(UnicodeScalar($0 - 52 + Character(\"0\").asciiValue!))\n    case ...62: return \"+\"\n    case ...63: return \"\/\"\n    case ...64: return \"=\"\n    default: abort()\n    }\n  }\n\nextension String {\n\n  public var toBase64: String {\n    var bytes = [UInt8]()\n    var byte = UInt8(0)\n    \n    enumerated().forEach { i, c in\n      switch i % 3 {\n      case 0:\n        bytes.append(c.asciiValue! >> 2)\n        byte = (c.asciiValue! << 6) >> 2\n      case 1:\n        bytes.append(byte | c.asciiValue! >> 4)\n        byte = (c.asciiValue! << 4) >> 2\n      default:\n        bytes.append(byte | (c.asciiValue! >> 6))\n        bytes.append((c.asciiValue! << 2) >> 2)\n      }\n    }\n    \n    if count % 3 != 0 {\n      bytes.append(byte)\n    }\n    \n    while bytes.count % 4 != 0 {\n      bytes.append(64)\n    }\n    \n    return bytes\n      .map { table[Int($0)] }\n      .joined()\n\t}\n\t\n\tpublic var fromBase64: String {\n\t\tlet bytes = self\n      .map { String($0) }\n      .map { UInt8(table.firstIndex(of: $0)!) }\n      .filter { $0 < 64 }\n    \n    var byte = UInt8(0)\n    var encodedBytes = [UInt8]()\n    \n    bytes.enumerated().forEach { i, c in\n      switch i % 4 {\n      case 0:\n        byte = c << 2\n      case 1:\n        encodedBytes.append(byte | (c >> 4))\n        byte = c << 4\n      case 2:\n        encodedBytes.append(byte | (c >> 2))\n        byte = c << 6\n      default:\n        encodedBytes.append(byte | c)\n      }\n    }\n    \n    if (bytes.count % 4 != 0) && (byte != 0) {\n      encodedBytes.append(byte)\n    }\n    \n    return encodedBytes\n      .map { String(UnicodeScalar($0)) }\n      .joined()\n\t}\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339916,"user_id":null,"body":"extension String {\n    public var toBase64: String {\n        guard let base64EncodedString = data(using: .utf8)?.base64EncodedString() else { return \"Error While Encoding\"}\n        \n        return base64EncodedString\n    }\n    \n    public var fromBase64: String {\n        guard let decodedData = Data(base64Encoded: self) else { return \"ERROR While Decoding Data\"}\n        guard let decodedString = String(data: decodedData, encoding: .utf8) else { return \"ERROR While Converting Data to String\"}\n        \n        return decodedString\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339917,"user_id":null,"body":"extension String {\n\tpublic var toBase64: String {\n    return self.data(using: .utf8)!.base64EncodedString()\n\t}\n\t\n\tpublic var fromBase64: String {\n\t\treturn String(data: Data(base64Encoded: self)!, encoding: .utf8)!\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52742f58faf5485cae000b9a":[{"id":339918,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    guard seconds > 0 else { return \"now\" }\n    \n    var unit = [\"year\", \"day\", \"hour\", \"minute\", \"second\"],\n        unitDuration = [Int.max, 365, 24, 60, 60],\n        duration = seconds,\n        result = [String](),\n        divisor: Int\n\n    while duration > 0 {\n        divisor = unitDuration.removeLast()\n        \n        let r = duration % divisor,\n            suffix = r > 1 ? \"s\" : \"\",\n            str = \"\\(r) \\(unit.removeLast())\\(suffix)\"\n        if r > 0 { result.insert(str, at: 0) }\n\n        duration \/= divisor\n    }\n\n    return result.count > 1 ?\n        result.dropLast().joined(separator: \", \") + \" and \" + result.last! :\n        result.last!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339919,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    \n    var seconds: Int = seconds\n    \n    let array: [String] = TimeUnit.allCases.compactMap { timeCase in\n        \n        let result = floor(Float(seconds) \/ Float(timeCase.rawValue))\n        seconds -= Int(result) * timeCase.rawValue\n        \n        if result == 0 {\n            return nil\n        } else if result == 1 {\n            return String(Int(result)) + \" \" + timeCase.singularTranslation\n        } else {\n            return String(Int(result)) + \" \" + timeCase.pluralTranslation\n        }\n    }\n    \n    if array.isEmpty {\n        return \"now\"\n    } else if array.count == 1 {\n        return array.first!\n    } else {\n        let lastTranslation: String = array.last!\n        return array.dropLast().joined(separator: \", \") + \" and \" + lastTranslation\n    }\n}\n\nenum TimeUnit: Int, CaseIterable {\n    case year = 31536000\n    case day = 86400\n    case hour = 3600\n    case minute = 60\n    case second = 1\n}\n\nextension TimeUnit {\n    \n    var pluralTranslation: String {\n        switch self {\n        case .year: return \"years\"\n        case .day: return \"days\"\n        case .hour: return \"hours\"\n        case .minute: return \"minutes\"\n        case .second: return \"seconds\"\n        }\n    }\n    \n    var singularTranslation: String {\n        switch self {\n        case .year: return \"year\"\n        case .day: return \"day\"\n        case .hour: return \"hour\"\n        case .minute: return \"minute\"\n        case .second: return \"second\"\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339920,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    guard seconds > 0 else { return \"now\" }\n    \n    let result = [\n        (seconds \/ 31536000, \"year\"),\n        ((seconds % 31536000)\/86400, \"day\"),\n        (((seconds % 31536000) % 86400)\/3600, \"hour\"),\n        ((seconds % 3600) \/ 60, \"minute\"),\n        ((seconds % 3600) % 60, \"second\")\n        ]\n        .filter({$0.0 > 0})\n        .map({$0.0 > 1 ? \"\\($0.0) \\($0.1)s\" : \"\\($0.0) \\($0.1)\"})\n        .joined(separator: \", \")\n    \n    if let range = result.range(of: \", \", options: String.CompareOptions.backwards) {\n        return result.replacingCharacters(in: range, with: \" and \")\n    } else {\n        return result\n    }\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339921,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    if seconds > 0 {\n        let y = ((seconds \/ 3600) \/ 24) \/ 365\n        let d = ((seconds \/ 3600) \/ 24) % 365\n        let h = ((seconds \/ 3600) % 24) % 60\n        let m = (seconds % 3600) \/ 60\n        let s = (seconds % 3600) % 60\n        \n        let array = [(\"year\", y), (\"day\", d), (\"hour\", h), (\"minute\", m), (\"second\", s)]\n        let filtered = array.filter { $0.1 != 0 }.map { String($0.1) + \" \\($0.0)\" + ($0.1 > 1 ? \"s\" : \"\") }\n        let result = filtered.enumerated().filter { $0.offset != (filtered.count - 1)}.map { $0.element}.joined(separator: \", \") + ((filtered.count == 1) ? \"\\(filtered.last!)\" : \" and \\(filtered.last!)\")\n        return result\n    } else {\n        return \"now\"\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339922,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    guard seconds > 0 else { return \"now\" }\n    let durations = [ \"\\(seconds\/(60*60*24*365)) year\\(seconds\/(60*60*24*365) > 1 ? \"s\" : \"\")\",\n                      \"\\(seconds\/(60*60*24) % 365) day\\(seconds\/(60*60*24) % 365 > 1 ? \"s\" : \"\")\",\n                      \"\\(seconds\/(60*60) % 24) hour\\(seconds\/(60*60) % 24 > 1 ? \"s\" : \"\")\",\n                      \"\\(seconds\/60 % 60) minute\\(seconds\/60 % 60 > 1 ? \"s\" : \"\")\",\n                      \"\\(seconds % 60) second\\(seconds % 60 > 1 ? \"s\" : \"\")\"].filter({$0.first != \"0\"})\n    return durations.dropLast().joined(separator: \", \") + (durations.count > 1 ? \" and \" : \"\") + durations.last!\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339923,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n \n  guard seconds != 0 else { return \"now\" }\n  \n  \/\/unit sizes in seconds\n  let m = 60\n  let h = 60 * m\n  let d = 24 * h\n  let y = 365 * d\n  \n  \n  \/\/duration units\n  let yT = seconds \/ y\n  let dT = seconds % y \/ d\n  let hT = seconds % d \/ h\n  let mT = seconds % h \/ m\n  let sT = seconds % m\n  \n  \n  \/\/ pair durations and names\n  let durations = [yT, dT, hT, mT, sT].map{ String($0) }\n  let names = [\"year\", \"day\", \"hour\", \"minute\", \"second\"]\n\n  \n  \/\/ formatting pairs\n  var formatting = [String]()\n\n  for (d,name) in zip(durations,names) {\n\n    guard d != \"0\" else { continue }\n\n    let conjugated = name + (d != \"1\" ? \"s\" : \"\")\n    let info = d + \" \" + conjugated   \n    formatting.append(info)\n  }\n\n  \/\/ return, formatting if needed. \n  if formatting.count == 1 { return formatting[0] }\n\n  return formatting[0..<formatting.count-1].joined(separator: \", \") + \" and \" + formatting.last!   \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339924,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n  if seconds == 0 { return \"now\" }\n  \n  let s = seconds % 60\n  let m = (seconds \/ 60) % 60\n  let h = (seconds \/ 3600) % 24\n  let d = (seconds \/ 86400) % 365\n  let y = (seconds \/ 31536000)\n  \n  let values = [y, d, h, m, s]\n  let words = [\"year\", \"day\", \"hour\", \"minute\", \"second\"]\n  let expressions = zip(words, values).map { (word, value) -> String in\n    switch value {\n      case 0:\n        return \"\"\n      case 1:\n        return \"\\(value) \\(word)\"\n      default:\n        return \"\\(value) \\(word)s\"\n    }\n  }.filter { $0.count > 0 }\n  \n  if expressions.count > 1 {\n    return expressions.dropLast().joined(separator: \", \") + \" and \" + expressions.last!\n  } else {\n    return expressions.first!\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339925,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    guard seconds > 0 else { return \"now\" }\n    let u = [1, 60, 60, 24, 365, 9999], w = [\"year\", \"day\", \"hour\", \"minute\", \"second\"]\n    var s = seconds, m = 1\n    let a: [Int] = (0..<u.count-1).compactMap { m *= u[$0]; return (s \/ m) % u[$0 + 1] }.reversed()\n    let t = (0...4).compactMap { a[$0] > 0 ? (\"\\(a[$0]) \\(w[$0])\" + (a[$0] > 1 ? \"s\" : \"\")) : nil }\n    return t.dropLast().joined(separator: \", \") + (t.count > 1 ? \" and \" : \"\") + (t.count > 0 ? t.last! : \"\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339926,"user_id":null,"body":"func format_duration(_ seconds: Int) -> String {\n    guard seconds != 0 else { return \"now\" }\n    let years = (seconds \/ 31536000, \"years\")\n    let days = (seconds % 31536000 \/ 86400, \"days\")\n    let hours = (seconds % 86400 \/ 3600, \"hours\")\n    let minutes = (seconds % 3600 \/ 60, \"minutes\")\n    let seconds = (seconds % 3600 % 60, \"seconds\")\n\n    let fullDate = [years, days, hours, minutes, seconds].filter { $0.0 > 0 }\n    let multiValueString = fullDate.dropLast().compactMap { \"\\($0.0) \\($0.1.isPlural($0.0))\" }.joined(separator: \", \") + \" and \\(fullDate.last!.0) \\(fullDate.last!.1.isPlural(fullDate.last!.0))\"\n    let singleValueString = \"\\(fullDate.last!.0) \\(fullDate.last!.1.isPlural(fullDate.last!.0))\"\n\n    return fullDate.count > 1 ? multiValueString : singleValueString\n}\n\nextension String {\n    func isPlural(_ value: Int) -> String {\n        return value > 1 ? self : String(self.dropLast())\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339927,"user_id":null,"body":"import Foundation\n\nstruct TimeParts {\n  let seconds: Int\n  let minutes: Int\n  let hours: Int\n  let days: Int\n  let years: Int\n  \n  init(duration: Int) {\n    var remainder = duration\n    self.years = TimeParts.reduceUnit(&remainder, by: 31_536_000)\n    self.days = TimeParts.reduceUnit(&remainder, by: 86_400)\n    self.hours = TimeParts.reduceUnit(&remainder, by: 3_600)\n    self.minutes = TimeParts.reduceUnit(&remainder, by: 60)\n    self.seconds = remainder\n  }\n  \n  private static func reduceUnit(_ seconds: inout Int, by divisor: Int) -> Int {\n    let reduced = seconds \/ divisor\n    seconds = seconds % divisor\n    return reduced\n  }\n}\n\nstruct TimeFormatter {\n  let time: TimeParts\n  \n  func format() -> String {\n    var allValues = [String]()\n    allValues = adding(component: \"year\", to: allValues, with: time.years)\n    allValues = adding(component: \"day\", to: allValues, with: time.days)\n    allValues = adding(component: \"hour\", to: allValues, with: time.hours)\n    allValues = adding(component: \"minute\", to: allValues, with: time.minutes)\n    allValues = adding(component: \"second\", to: allValues, with: time.seconds)\n    return joining(allValues)\n  }\n  \n  private func adding(component: String, to parts: [String], with value: Int) -> [String] {\n    var parts = parts\n    if value > 0 {\n      parts.append(formatted(component, and: value))\n    }\n    return parts\n  }\n  \n  private func formatted(_ component: String, and value: Int) -> String {\n    return \"\\(value) \\(pluralized(component, with: value))\"\n  }\n  \n  private func pluralized(_ component: String, with value: Int) -> String {\n    return value > 1 ? \"\\(component)s\" : component\n  }\n  \n  private func joining(_ parts: [String]) -> String {\n    guard parts.count > 1 else { return parts.first! }\n    return [parts.dropLast(1).joined(separator: \", \"), parts.last!].joined(separator: \" and \")\n  }\n}\n\nfunc format_duration(_ seconds: Int) -> String {\n  guard seconds > 0 else { return \"now\" }\n  let parts = TimeParts(duration: seconds)\n  let formatted = TimeFormatter(time: parts).format()\n  return formatted\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52761ee4cffbc69732000738":[{"id":339928,"user_id":null,"body":"import Foundation\n\nfunc worth(of string: String, coefficients: [Int]) -> Int {\n  let counts = string.components(separatedBy: \" \").flatMap { Int($0) }\n  return zip(counts, coefficients).map(*).reduce(0, +)\n}\n\nfunc evaluate(good: String, vsEvil evil: String) -> String {\n  let goodWorth = worth(of: good, coefficients: [1, 2, 3, 3, 4, 10])\n  let evilWorth = worth(of: evil, coefficients: [1, 2, 2, 2, 3, 5, 10])\n  \n  if goodWorth > evilWorth { return \"Battle Result: Good triumphs over Evil\" }\n  else if goodWorth < evilWorth { return \"Battle Result: Evil eradicates all trace of Good\" }\n  else { return \"Battle Result: No victor on this battle field\" }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339929,"user_id":null,"body":"enum Good: Int {\n  case hobbits = 0\n  case men = 1\n  case elves = 2\n  case dwarves = 3\n  case eagles = 4\n  case wizards = 5\n  \n  func weight() -> Int {\n    switch self {\n      case .hobbits: return 1\n      case .men: return 2\n      case .elves: return 3\n      case .dwarves: return 3\n      case .eagles: return 4\n      case .wizards: return 10\n    }\n  }\n}\n\nenum Evil: Int {\n  case orcs = 0\n  case men = 1\n  case wargs = 2\n  case goblins = 3\n  case urukHai = 4\n  case trolls = 5\n  case wizards = 6\n  \n  func weight() -> Int {\n    switch self {\n      case .orcs: return 1\n      case .men: return 2\n      case .wargs: return 2\n      case .goblins: return 2\n      case .urukHai: return 3\n      case .trolls: return 5\n      case .wizards: return 10\n    }\n  }\n}\n\nfunc evaluate(good: String, vsEvil evil: String) -> String {\n  let goodComponents = good.characters.split{$0 == \" \"}\n  let evilComponents = evil.characters.split{$0 == \" \"}\n  \n  let goodWeight = goodComponents.enumerated().map { (index, component) -> Int in\n    return (Good(rawValue: index)?.weight() ?? 0) * (Int(String(component)) ?? 0)\n  }.reduce(0, +)\n  \n  let evilWeight = evilComponents.enumerated().map { (index, component) -> Int in\n    return (Evil(rawValue: index)?.weight() ?? 0) * (Int(String(component)) ?? 0)\n  }.reduce(0, +)\n  \n  return determineBattle(good: goodWeight, evil: evilWeight)\n}\n\nfunc determineBattle(good: Int, evil: Int) -> String {\n  if good == evil {\n    return \"Battle Result: No victor on this battle field\"\n  } else if good > evil {\n    return \"Battle Result: Good triumphs over Evil\"\n  } else {\n    return \"Battle Result: Evil eradicates all trace of Good\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339930,"user_id":null,"body":"import Foundation\n\nfunc evaluate(good: String, vsEvil evil: String) -> String {\n  let goodWorth = [1,2,3,3,4,10]\n  let evilWorth = [1,2,2,2,3,5,10]\n\n  \/\/ Transform the provided \"good\" string into an array of [strings]\n  let newGoodArray = good.components(separatedBy: \" \")\n  \n  \/\/ Transform the newly created array of [strings] into an array of [Ints]\n  let newGoodArrayOfInts = newGoodArray.map{ Int($0)! }\n\n  \/\/ Zip then Map the provided array of [Ints] with the goodWorth array of [Ints]\n  let goodResults = zip(newGoodArrayOfInts, goodWorth).map{$0 * $1}\n\n  \/\/ reduce the array to have the goodArray total\n  let reducedGoodArray = goodResults.reduce(0, {$0 + $1})\n  print(reducedGoodArray)\n\n  \/\/\/\/\/\/\/\/\/\/\/\n  \/\/repeat the same steps for the Evil\n\n  let newEvilArray = evil.components(separatedBy: \" \")\n  let newEvilArrayOfInts = newEvilArray.map{ Int($0)! }\n  let evilResults = zip(newEvilArrayOfInts, evilWorth).map{$0 * $1}\n  let reducedEvilArray = evilResults.reduce(0, {$0 + $1})\n  print(reducedEvilArray)\n\n\n  if reducedGoodArray > reducedEvilArray {\n      return \"Battle Result: Good triumphs over Evil\"\n\n  } else if reducedGoodArray < reducedEvilArray {\n      return \"Battle Result: Evil eradicates all trace of Good\"\n  }\n     \n  return \"Battle Result: No victor on this battle field\"\n}\n\n\nvar finalResult = evaluate(good: \"1 1 1 1 1 1\", vsEvil: \"1 1 1 1 1 1 1\")","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339931,"user_id":null,"body":"func weight(for value: Int, atIndex index: Int, team: Int) -> Int {\n    let weights = [[1,2,3,3,4,10], [1,2,2,2,3,5,10]]\n    return weights[team][index] * value\n}\n\nfunc evaluate(good: String, vsEvil evil: String) -> String {\n    let totals = [good, evil]\n        .enumerated()\n        .map({team, counts in\n            counts\n                .components(separatedBy: \" \")\n                .map({stringValue in Int(stringValue)!})\n                .enumerated()\n                .map({ (index, count) -> Int in\n                    return weight(for: count, atIndex: index, team: team)})\n                .reduce(0, +)\n        })\n    \n    switch (totals[0], totals[1]) {\n        case let (good, evil) where good > evil: return \"Battle Result: Good triumphs over Evil\"\n        case let (good, evil) where good < evil: return \"Battle Result: Evil eradicates all trace of Good\"\n        case let (good, evil) where good == evil: return \"Battle Result: No victor on this battle field\"\n        default: return \"\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339932,"user_id":null,"body":"let goodValues = [1, 2, 3, 3, 4, 10]\nlet evilValues = [1, 2, 2, 2, 3, 5, 10]\n\nfunc evaluate(good: String, vsEvil evil: String) -> String {\n    let goodCount = good.split(separator: \" \").enumerated().flatMap { goodValues[$0.offset] * Int($0.element)! }.reduce(0, +)\n    let evilCount = evil.split(separator: \" \").enumerated().flatMap { evilValues[$0.offset] * Int($0.element)! }.reduce(0, +)\n    \n    let result = goodCount - evilCount\n\n    switch result  {\n    case 0:\n        return \"Battle Result: No victor on this battle field\"\n    case 1...Int.max:\n        return \"Battle Result: Good triumphs over Evil\"\n    default:\n        return \"Battle Result: Evil eradicates all trace of Good\"\n    } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339933,"user_id":null,"body":"func evaluate(good: String, vsEvil evil: String) -> String {\n  func totalValue(for string: String, values: [Int]) -> Int {\n    let counts = string.components(separatedBy: \" \").compactMap(Int.init)\n    \n    return zip(counts, values).reduce(0) { $0 + ($1.0 * $1.1) }\n  }\n  \n  let goodTotalValue = totalValue(for: good, values: [1, 2, 3, 3, 4, 10])\n  let evilTotalValue = totalValue(for: evil, values: [1, 2, 2, 2, 3, 5, 10])\n  \n  if goodTotalValue > evilTotalValue {\n    return \"Battle Result: Good triumphs over Evil\"\n  } else if evilTotalValue > goodTotalValue {\n    return \"Battle Result: Evil eradicates all trace of Good\"\n  } else {\n    return \"Battle Result: No victor on this battle field\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339934,"user_id":null,"body":"func evaluate(good: String, vsEvil evil: String) -> String {\n    let goodPoints = [0: 1,\n                          1: 2,\n                          2: 3,\n                          3: 3,\n                          4: 4,\n                          5: 10]\n        \n        let evilPoints = [0: 1,\n                          1: 2,\n                          2: 2,\n                          3: 2,\n                          4: 3,\n                          5: 5,\n                          6: 10]\n        \n        let goodCount = good\n            .split(separator: \" \")\n            .compactMap { Int($0) }\n            .enumerated()\n            .reduce(0, { (goodPoints[$1.offset] ?? 0) * $1.element + $0 })\n        \n        let evilCount = evil\n            .split(separator: \" \")\n            .compactMap { Int($0) }\n            .enumerated()\n            .reduce(0, { (evilPoints[$1.offset] ?? 0) * $1.element + $0 })\n        \n        guard goodCount != evilCount else { return \"Battle Result: No victor on this battle field\" }\n        return \"Battle Result: \\(goodCount > evilCount ? \"Good triumphs over Evil\" : \"Evil eradicates all trace of Good\")\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339935,"user_id":null,"body":"func evaluate(good: String, vsEvil evil: String) -> String {\n    \n    let goodRes : Int = cal(good, [1,2,3,3,4,10])\n    let evilRes : Int = cal(evil, [1,2,2,2,3,5,10])\n    \n    if goodRes == evilRes { return \"Battle Result: No victor on this battle field\" }\n    else if goodRes > evilRes { return \"Battle Result: Good triumphs over Evil\" }\n    else { return \"Battle Result: Evil eradicates all trace of Good\" }\n}\n\nfunc cal(_ input: String, _ vals : [Int]) -> Int {\n    let array : [Int] = input.components(separatedBy: \" \").flatMap{Int($0)}\n    return zip(array, vals).map(*).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339936,"user_id":null,"body":"func evaluate(good: String, vsEvil evil: String) -> String {\n    let gPowers = [1, 2, 3, 3, 4, 10]\n    let ePowers = [1, 2, 2, 2, 3, 5, 10]\n    \n    let gTotal = good.split(separator: \" \").compactMap { Int(String($0)) }.enumerated().map { gPowers[$0] * $1 }.reduce(0, +)\n    let eTotal = evil.split(separator: \" \").compactMap { Int(String($0)) }.enumerated().map { ePowers[$0] * $1 }.reduce(0, +)\n    \n    if      gTotal > eTotal  { return \"Battle Result: Good triumphs over Evil\" }\n    else if gTotal < eTotal  { return \"Battle Result: Evil eradicates all trace of Good\" }\n    else                     { return \"Battle Result: No victor on this battle field\" }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339937,"user_id":null,"body":"func evaluate(good: String, vsEvil evil: String) -> String {\n  let weights1: [Int] = [1,2,3,3,4,10]\n  let weights2: [Int] = [1,2,2,2,3,5,10]\n  \n  let parsed1: [Int] = good.split(separator: \" \").compactMap { Int($0) }\n  let parsed2: [Int] = evil.split(separator: \" \").compactMap { Int($0) }\n  \n  let mass1 = parsed1.enumerated().map { (index, item) in\n                                        return weights1[index] * item\n                                        }.reduce(0, +)\n  let mass2 = parsed2.enumerated().map { (index, item) in\n                                        return weights2[index] * item\n                                        }.reduce(0, +)\n  \n  if mass1 == mass2 {\n    return \"Battle Result: No victor on this battle field\"\n  } else if mass1 > mass2 {\n    return \"Battle Result: Good triumphs over Evil\"\n  } else {\n    return \"Battle Result: Evil eradicates all trace of Good\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52763db7cffbc6fe8c0007f8":[{"id":339938,"user_id":null,"body":"func tongues(_ code: String) -> String {\n    let newSeries = Array(\"EPLRAGFSOXVCWTIBZDHNYKMJUQeplragfsoxvcwtibzdhnykmjuq\")\n    return String(code.map{ if $0.isLetter { return Character(String(newSeries[Int($0.asciiValue!) - ($0.asciiValue! > 90 ? 71 : 65)]))} else { return $0 }})\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339939,"user_id":null,"body":"func tongues(_ text: String) -> String {\n    let vowels: [Character] = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\n    let consonants: [Character] = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n    func rot(_ amount: Int, char: Character, in list: [Character]) -> Character? {\n        guard char.isLetter else { return char }\n        return list.firstIndex(of: Character(char.lowercased())).map {\n            let result = list[($0 + amount) % list.count]\n            return char.isLowercase ? result : Character(result.uppercased())\n        }\n    }\n    return String(text.map { char in\n        rot(3, char: char, in: vowels) ?? rot(10, char: char, in: consonants) ?? char\n    })\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339940,"user_id":null,"body":"  let vowels: [String] = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\n  let consonants: [String] = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \n                    \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\nfunc shiftCharacters(character: Character) -> String{\n  var flag = 0\n  if character.isUppercase{\n    flag = 1\n  }\n  \n  var returnString:String = \"\"\n  if vowels.contains(character.lowercased()) {\n    returnString = String(vowels[(vowels.firstIndex(of: character.lowercased())! + 3) % vowels.count])\n    if flag == 1 {\n      return returnString.uppercased()\n    }\n    return returnString\n  }\n  if consonants.contains(character.lowercased()){\n    returnString = String(consonants[(consonants.firstIndex(of: character.lowercased())! + 10) % consonants.count])\n    if flag == 1 {\n      return returnString.uppercased()\n    }\n    return returnString\n  }\n  \n  return String(character)\n}\nfunc tongues(_ code: String) -> String {\n  return code.map(shiftCharacters).joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339941,"user_id":null,"body":"func tongues(_ code: String) -> String {\n    let letter = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\n    let consonants = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n    var y = 1\n    var result : String = \"\"\nlet trans = code.map({ (char:Character) -> String in \nif letter.contains(String(char)) {\n    y = 1\n    for i in letter {\n        if String(char) == i, y <= 3 {return letter[y + 2]}\n        else if String(char) == i, y > 3 {return letter[y + 2 - 6]}\n        y += 1\n           }     \n} else if (consonants.contains(String(char))){\n    y = 1\n    for i in consonants {\n        if String(char) == i, y <= 10 {return consonants[y + 9]}\n        else if String(char) == i, y > 10 {return consonants[y + 9 - 20]}\n        y += 1 }\n    }\n    else if consonants.contains(String(char.lowercased())) {\n    y = 1\n    for i in consonants {\n        if String(char.lowercased()) == i, y <= 10 {return consonants[y + 9].uppercased()}\n        else if String(char.lowercased()) == i, y > 10 {return consonants[y + 9 - 20].uppercased()}\n        y += 1 }\n    }\n    else if letter.contains(String(char.lowercased())) {\n    y = 1\n    for i in letter {\n        if String(char.lowercased()) == i, y <= 3 {return letter[y + 2].uppercased()}\n        else if String(char.lowercased()) == i, y > 3 {return letter[y + 2 - 6].uppercased()}\n        y += 1\n           }    \n    }\n    else {return String(char)}\n    \n    \nreturn \"\"\n}) \nfor i in trans {\nresult += i\n}\nreturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339942,"user_id":null,"body":"func tongues(_ code: String) -> String {\n    let vowels: [String] = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\n    let consonents: [String] = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n    return code.map { char -> String in\n        if vowels.contains(char.lowercased()) {\n            let index = vowels.firstIndex(of: char.lowercased())\n            let res = vowels[(6 + (index! - 3)) % 6]\n            return char.isLowercase ? res : res.uppercased()\n        }\n        if consonents.contains(char.lowercased()) {\n            let index = consonents.firstIndex(of: char.lowercased())\n            let res = consonents[(consonents.count + (index! - 10)) % consonents.count]\n            return char.isLowercase ? res : res.uppercased()\n        }\n        return \"\\(char)\"\n    }.reduce(\"\", +)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339943,"user_id":null,"body":"var vowels = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\nvar consonants = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n\nfunc tongues(_ code: String) -> String {\n    return code.map {\n        var decoded = \"\"\n        \n        if vowels.contains(\"\\($0.lowercased())\") {\n            decoded = vowels[(vowels.firstIndex(of: \"\\($0.lowercased())\")! + 9) % vowels.count]\n        } else if consonants.contains(\"\\($0.lowercased())\") {\n            decoded = consonants[(consonants.firstIndex(of: \"\\($0.lowercased())\")! + 10) % consonants.count]\n        } else {\n            return \"\\($0)\"\n        }\n        \n        return $0.isUppercase ? decoded.uppercased() : decoded\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339944,"user_id":null,"body":"func tongues(_ code: String) -> String {\n    let vowels = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\n    let consonants = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n    var trans = Dictionary(uniqueKeysWithValues: zip(vowels, vowels.suffix(3) + vowels.prefix(3)))\n    trans.merge(zip(consonants,consonants.suffix(10)+consonants.prefix(10)), uniquingKeysWith: { (x,y) in x })\n    let swap = { (c: Character) -> String in\n        guard c.isLetter else { return String(c) }\n        let s = String(c).lowercased()\n        if let x = trans[s] {\n            return c.isLowercase ? x : x.uppercased()\n        } else {\n            return s\n        }\n    }\n    return code.map(swap).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339945,"user_id":null,"body":"let vowels = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\nlet consonants = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n\nfunc item(at idx: Int, from sequence: [String], advancedBy offset: Int) -> String {\n  return sequence[idx + offset < sequence.count ? idx + offset : idx + offset - sequence.count]\n}\n\nfunc rot(char: Character, from sequence: [String], advancedBy offset: Int) -> String? {\n  guard let idx = sequence.firstIndex(of: char.lowercased()) else { return nil }\n  let rotated = item(at: idx, from: sequence, advancedBy: offset)\n  return char.isUppercase ? rotated.uppercased() : rotated\n}\n\nfunc tongues(_ code: String) -> String {\n  code.map {\n    rot(char: $0, from: vowels, advancedBy: 3) ??\n    rot(char: $0, from: consonants, advancedBy: 10) ??\n    String($0)\n  }.joined(separator: \"\")\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339946,"user_id":null,"body":"func tongues(_ code: String) -> String {\n    let vowels: [Character] = [\"a\",\"i\",\"y\",\"e\",\"o\",\"u\"]\n    let consonants: [Character] = [\"b\",\"k\",\"x\",\"z\",\"n\",\"h\",\"d\",\"c\",\"w\",\"g\",\"p\",\"v\",\"j\",\"q\",\"t\",\"s\",\"r\",\"l\",\"m\",\"f\"]\n    var resultString: String = \"\"\n    code.forEach { char in\n        let lowerChar = Character(char.lowercased())\n        var currentChar: Character\n        if vowels.contains(lowerChar) {\n            currentChar = characterWithOffset(vowels,\n                                              startIndex: vowels.firstIndex(of: lowerChar)!,\n                                              offset: 3)\n        } else if consonants.contains(lowerChar) {\n            currentChar = characterWithOffset(consonants,\n                                              startIndex: consonants.firstIndex(of: lowerChar)!,\n                                              offset: 10)\n        } else { currentChar = char }\n        \n        if char.isLowercase { resultString += String(currentChar) }\n        else { resultString += currentChar.uppercased() }\n    }\n    \n    return resultString\n}\n\nfunc characterWithOffset(_ array: [Character], startIndex: Int, offset: Int) -> Character {\n    var currentIndex = startIndex + offset\n    while currentIndex > array.count - 1 { currentIndex -= array.count }\n    return array[currentIndex]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339947,"user_id":null,"body":"func tongues(_ code: String) -> String {\n  let vowels = [\"a\", \"i\", \"y\", \"e\", \"o\", \"u\"]\n  let cons = [\"b\", \"k\", \"x\", \"z\", \"n\", \"h\", \"d\", \"c\", \"w\", \"g\", \"p\", \"v\", \"j\", \"q\", \"t\", \"s\", \"r\", \"l\", \"m\", \"f\"]\n  let arr = Array(code).map({String($0)})\n  var result = \"\"\n  for cr in arr {\n    var d = \"\"\n    let uppercase = cr == cr.uppercased()\n    let c = uppercase ? cr.lowercased() : cr\n    if let i = vowels.firstIndex(where: {$0 == c}) {\n      d = vowels[back(from: i, by: 3, count: vowels.count)]\n    } else if let i = cons.firstIndex(where: {$0 == c}) {\n      d = cons[back(from: i, by: 10, count: cons.count)]\n    } else {\n      d = c\n    }\n    result += uppercase ? d.uppercased() : d\n  }\n  return result\n}\n\nfunc back(from: Int, by: Int, count: Int) -> Int {\n  return from - by >= 0 ? from - by : count + from - by\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5277c8a221e209d3f6000b56":[{"id":339948,"user_id":null,"body":"import Foundation\n\nfunc valid_braces(_ string:String) -> Bool {\n    let str = string\n        .replacingOccurrences(of: \" \", with: \"\")\n        .replacingOccurrences(of: \"{}\", with: \"\")\n        .replacingOccurrences(of: \"[]\", with: \"\")\n        .replacingOccurrences(of: \"()\", with: \"\")\n    switch str {\n    case \"\": return true\n    case string: return false\n    default: return valid_braces(str)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339949,"user_id":2387,"body":"import Foundation\n\nfunc valid_braces(_ string:String) -> Bool {\n    for pattern in [\"()\", \"[]\", \"{}\"] {\n        if string.contains(pattern) {\n            return valid_braces(string.replacingOccurrences(of: pattern, with: \"\"))\n        }\n    }\n    return string == \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339950,"user_id":null,"body":"import Foundation\n\nlet matches: [Character: Character] = [\"(\": \")\", \"[\": \"]\", \"{\": \"}\"]\n\nfunc valid_braces(_ string: String) -> Bool {\n\tvar stack: [Character] = []\n\tfor char in string.characters {\n\t\tif let match = matches[char] {\n\t\t\tstack.append(match)\n\t\t} else {\n\t\t\tif char != stack.popLast() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn stack.isEmpty\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339951,"user_id":null,"body":"import Foundation\n\nfunc valid_braces(_ string:String) -> Bool {\n    var stack = [Character]()\n    for c in string {\n        switch c {\n        case \"(\", \"{\", \"[\": \n          stack.append(c)\n        default:\n          guard let prev = stack.popLast() else { return false }\n          switch (prev, c) {\n          case (\"(\", \")\"), (\"{\", \"}\"), (\"[\", \"]\"): break\n          default: return false\n          }\n        }\n    }\n    return stack.isEmpty\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339952,"user_id":null,"body":"import Foundation\n\nfunc valid_braces(_ string:String) -> Bool {\n  switch string.filter(\"()[]{}\".contains)\n            .replacingOccurrences(of: \"()\", with: \"\")\n            .replacingOccurrences(of: \"[]\", with: \"\")\n            .replacingOccurrences(of: \"{}\", with: \"\") {\n  case \"\": return true\n  case string: return false\n  case let next: return valid_braces(next)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339953,"user_id":null,"body":"let relativeBraces = [\"(\": \")\", \"{\": \"}\", \"[\": \"]\", \" \": \" \"]\nfunc valid_braces(_ string: String) -> Bool {\n    var bracesBuffer = [String]()\n    for ch in string {\n        if \"({[\".contains(ch) {\n            bracesBuffer.append(String(ch))\n        } else {\n            if relativeBraces[bracesBuffer.popLast() ?? \" \"] != String(ch) { return false }\n        }\n    }\n    return bracesBuffer.isEmpty ? true : false\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339954,"user_id":null,"body":"func valid_braces(_ string:String) -> Bool {\n    var openingBraces = [String]()\n    \n    for char in string {\n        switch char {\n            case \"(\", \"{\", \"[\" : openingBraces.append(\"\\(char)\")\n            case \")\": if openingBraces.isEmpty || openingBraces.removeLast() != \"(\" { return false }\n            case \"}\": if openingBraces.isEmpty || openingBraces.removeLast() != \"{\" { return false }\n            case \"]\": if openingBraces.isEmpty || openingBraces.removeLast() != \"[\" { return false }\n            default: break\n        }\n    }\n    \n    return openingBraces.isEmpty\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339955,"user_id":null,"body":"import Foundation\nprivate extension String {\n    func randomAccessCharacterArray() -> Array<Character> {\n        return Array(self)\n    }\n}\n\nfunc valid_braces(_ string:String) -> Bool {\n    let charArr = string.randomAccessCharacterArray()\n    let dict: Dictionary<Character, Character> = [\n        \"}\":\"{\",\n        \"]\":\"[\",\n        \")\":\"(\"\n    ]\n    var stack: Array<Character> = []\n    for char in charArr {\n        if char == \"}\" || char == \")\" || char == \"]\" {\n            if stack.isEmpty || stack.last != dict[char] {\n                return false\n            } else {\n                stack.removeLast()\n            }\n        } else {\n            stack.append(char)\n        }\n    }\n    return stack.isEmpty\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339956,"user_id":null,"body":"import Foundation\n\nfunc valid_braces(_ xs: String) -> Bool {\n  let ys = Array(xs.characters)\n  let zs = ys.reduce([] as [Character]) { (acc, next) in\n    guard let last = acc.last else {\n      return [next]\n    }\n    \n    if let closing = last.closing, closing == next {\n      return Array(acc.dropLast())\n    } else {\n      return acc + [next]\n    }\n  }\n  \n  return zs.isEmpty ? true : false\n}\n\n\n\nprivate extension Character {\n  var closing: Character? {\n    switch self {\n      case \"(\": return \")\"\n      case \"[\": return \"]\"\n      case \"{\": return \"}\"\n      default: return nil\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339957,"user_id":null,"body":"import Foundation\n\nfunc valid_braces(_ string:String) -> Bool {\n    var buffer = [UInt32]()\n    Array(string).forEach{\n        let val = String($0).unicodeScalars.first!.value;\n        (buffer.count > 0 && 1...2 ~= (Int(val) - Int(buffer.last!))) ? _=buffer.removeLast() : buffer.append(val)\n    }\n    return buffer.count == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5277dc3ff4bfbd9a36000c1c":[{"id":339958,"user_id":null,"body":"extension String {\n    var fromAscii85: Data {\n        var d = Data()\n        let u32Size = MemoryLayout<UInt32>.size\n\n        guard self.hasPrefix(\"<~\") && self.hasSuffix(\"~>\") else { return d }\n        let subStart = self.index(self.startIndex, offsetBy: 2)\n        let subEnd = self.index(self.endIndex, offsetBy: -2)\n        var ps = self.substring(with: subStart..<subEnd).replacingOccurrences(of: \"z\", with: \"!!!!!\").components(separatedBy: .whitespacesAndNewlines).joined()\n        var ascArr: [UInt8] = Array(ps.utf8)\n        let padLen = (5 - (ascArr.count % 5)) % 5\n        ascArr.append(contentsOf: Array(repeating: UInt8(117), count: padLen))\n        for idx in stride(from: 0, to: ascArr.count, by: 5) {\n            let block = ascArr[idx..<idx+5].map { $0-33 }\n            var bigBlock: UInt32 = block.reduce(0, { $0 * 85 + UInt32($1) }).bigEndian\n            let orgBytes = Array(withUnsafePointer(to: &bigBlock, { $0.withMemoryRebound(to: UInt8.self, capacity: u32Size, { UnsafeBufferPointer(start:$0, count: u32Size) }) }))\n            d.append(contentsOf: orgBytes)\n        }\n        return d.subdata(in: 0..<d.count-padLen)\n    }\n}\n\nextension Data {\n    var toAscii85: String {\n        var e85 = \"\"\n        var hunk: UInt32\n        var ad:[UInt8] = self.map {$0}\n        \n        for idx in stride(from: 0, to: ad.count, by: 4) {\n            var s = \"\"\n            let dist = ad.count - idx\n            let padLen = dist > 3 ? 0 : 4-dist\n            hunk = (ad[idx..<idx+(4-padLen)].reduce(0, { $0 << 8 + UInt32($1) })) << UInt32(8 * padLen)\n            if hunk == 0 && padLen == 0 { s = \"z\" } else {\n                for _ in 1...5 { s = String(UnicodeScalar((hunk % 85)+33)!) + s; hunk = hunk \/ 85 }\n                s = s.substring(to: s.index(s.endIndex, offsetBy: -padLen))\n            }\n            e85.append(s)\n        }\n        return \"<~\\(e85)~>\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339959,"user_id":null,"body":"extension Data {\n  \n  var toAscii85: String {\n    \n    var paddedCount = 0\n    var padded = self\n    \n    while padded.count % 4 != 0 {\n      padded.append(0)\n      paddedCount += 1\n    }\n    \n    let ints = padded.map { Int($0) }\n    var chars = [Int]()\n    \n    for i in 0..<(padded.count \/ 4) {\n      var num = ints[i * 4] << 24\n      num |= ints[i * 4 + 1] << 16\n      num |= ints[i * 4 + 2] << 8\n      num |= ints[i * 4 + 3]\n      \n      guard (num != 0) || ((i + 1 == padded.count \/ 4) && (paddedCount != 0)) else {\n        chars.append(89)\n        continue\n      }\n      \n      chars.append(num \/ 85 \/ 85 \/ 85 \/ 85)\n      chars.append((num \/ 85 \/ 85 \/ 85) % 85)\n      chars.append((num \/ 85 \/ 85) % 85)\n      chars.append((num \/ 85) % 85)\n      chars.append(num % 85)\n    }\n    \n    chars = chars.dropLast(paddedCount)\n    \n    let res = chars\n      .map { UInt8($0 + 33) }\n      .map { String(UnicodeScalar($0)) }\n      .joined()\n    \n    return \"<~\\(res)~>\"\n  }\n}\n\nextension String {\n  \n  var fromAscii85: Data {\n    \n    var paddedCount = 0\n    var padded = self\n      .filter { (($0.asciiValue! >= 33) && ($0.asciiValue! <= 117)) || ($0.asciiValue! == 122) }\n      .replacingOccurrences(of: \"z\", with: \"!!!!!\")\n      .dropFirst()\n      .dropLast()\n    \n    while padded.count % 5 != 0 {\n      padded += \"u\"\n      paddedCount += 1\n    }\n    \n    let codes = padded.map { Int($0.asciiValue!) - 33 }\n    var nums = [Int]()\n    \n    for i in 0..<(codes.count \/ 5) {\n      var num = codes[i * 5 + 4]\n      num += codes[i * 5 + 3] * 85\n      num += codes[i * 5 + 2] * 85 * 85\n      num += codes[i * 5 + 1] * 85 * 85 * 85\n      num += codes[i * 5] * 85 * 85 * 85 * 85\n      \n      nums.append((num >> 24) & 0xFF)\n      nums.append((num >> 16) & 0xFF)\n      nums.append((num >> 8) & 0xFF)\n      nums.append(num & 0xFF)\n    }\n    \n    let bytes = nums\n      .dropLast(paddedCount)\n      .map { UInt8($0) }\n    \n    return Data(bytes)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339960,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var data = self\n    let padding = data.count.isMultiple(of: 4) ? 0 : 4 - (data.count % 4)\n    if padding > 0 {\n      data += Data(repeating: UInt8(0), count: padding)\n    }\n    var bytes = [UInt32]()\n    for i in stride(from: 0, to: data.count, by: 4) {\n      let s = Array(data[i..<i+4])\n        .map {\n          let binary = String(Int($0), radix: 2)\n          return \"\".padding(toLength: 8, withPad: binary.padding(toLength: 8, withPad: \"0\", startingAt: 0), startingAt: binary.count % 8)\n        }\n        .joined()\n      bytes.append(UInt32(s, radix: 2)!)\n    }\n    var result = bytes.map { (byte: UInt32) -> String in\n      guard byte > 0 else { return \"z\" }\n      var curr = byte\n      var result = \"\"\n      for _ in 0..<5 {\n        let reminder = curr % 85\n        curr \/= 85\n        result.append(Character(UnicodeScalar(reminder + 33)!))\n      }\n      return String(result.reversed())\n    }.joined()\n    if result.last == \"z\" && padding > 0 {\n      result = String(result.dropLast()) + \"!!!!!\"\n    }\n    result = String(result.dropLast(padding))\n    return \"<~\" + result + \"~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    var str = String(self.dropFirst(2).dropLast(2))\n      .replacingOccurrences(of: \"z\", with: \"!!!!!\")\n      .replacingOccurrences(of: \"\\\\s\", with: \"\", options: .regularExpression)\n    let padding = str.count.isMultiple(of: 5) ? 0 : 5 - (str.count % 5)\n    if padding > 0 {\n      str += String(repeating: \"u\", count: padding)\n    }\n    var bits = \"\"\n    var s = str.startIndex\n    var e = str.index(str.startIndex, offsetBy: 5, limitedBy: str.endIndex) ?? str.endIndex\n    while s < str.endIndex {\n      var sum: UInt32 = 0\n      var multiplier: UInt32 = 1\n      for i in 1...5 {\n        let value  = str[str.index(e, offsetBy: -i, limitedBy: str.startIndex) ?? str.startIndex].unicodeScalars.first!.value\n        if value >= 33 {\n          sum +=  (value - 33) * multiplier\n        } else {\n          sum +=  value * multiplier\n        }\n        multiplier &*= 85\n      }\n      var binary = String(sum, radix: 2)\n      bits += \"\".padding(toLength: 32, withPad: binary.padding(toLength: 32, withPad: \"0\", startingAt: 0), startingAt: binary.count % 32)\n      s = e\n      _ = str.formIndex(&e, offsetBy: 5, limitedBy: str.endIndex)\n    }\n    var result: [UInt8] = []\n    s = bits.startIndex\n    e = bits.index(bits.startIndex, offsetBy: 8, limitedBy: bits.endIndex) ?? bits.endIndex\n    while s < bits.endIndex {\n      result.append(UInt8(String(bits[s..<e]), radix: 2)!)\n      s = e\n      _ = bits.formIndex(&e, offsetBy: 8, limitedBy: bits.endIndex)\n    }\n    return Data(result.dropLast(padding))\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339961,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    \n    var d = String(data: self, encoding: .ascii) ?? \"\"\n    \n    if d.range(of: \"^\\0+$\", options: .regularExpression, range: nil) != nil {\n      return \"<~\\(d.count == 4 ? \"z\" : String(repeating: \"!\", count: self.count + 1))~>\"\n    }\n    \n    while d.count % 4 != 0 { d += \"\\0\" }\n    \n    let b = Array(d.map { String(UnicodeScalar(String($0))!.value, radix: 2).padStart(8, \"0\", 0)  ?? \"\" }.joined())\n    \n    let b32 = b.map{String($0)}.chunked(32).map{ Int($0.joined(separator: \"\"), radix: 2)!.bit32toString() ?? \"\" }.joined()\n    \n    let extra = Swift.max(d.count - self.count, 0)\n    \n    return \"<~\\(b32.prefix(b32.count - extra))~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    \n    var s = self.slice(from: 2, to: -2).replacingOccurrences(of: \"z\", with: \"!!!!!\")\n    s = String(s.filter { !\" \n\\t\\r\".contains($0) })\n    \n    if s.isEmpty { return Data() }\n    \n    var count = 0\n    while s.count % 5 != 0 { \n      s += \"u\" \n      count += 1\n    }\n    \n    let binaryString = s.chunked(to: 5).map { \n      let fSum = $0.reversed().enumerated().reduce(0) { (acc, el) in acc + (Int(UInt(el.1.asciiValue!)) - 33) * Int(pow(85.0, Double(el.0)))}\n      return String(fSum, radix: 2).padStart(32, \"0\", 0) ?? \"\"\n    }.joined(separator: \"\")\n    \n    let resultString = binaryString.chunked(to: 8).map { String(Character(UnicodeScalar(Int(UInt($0, radix: 2)!))!)) }.joined(separator: \"\")\n    \n    var result = [UInt8]()\n    \n    (count > 0 ? String(resultString.dropLast(count)): resultString).data(using: .utf32)?.enumerated().forEach { (i, dt) in \n      if (i != 0 && i % 4 == 0) { result.append(dt) }\n    }\n    return Data(result)    \n  }\n  \n  func padStart(_ len: Int, _ pad: String, _ ind: Int) -> String {\n    return String((String(self.reversed()).padding(toLength: len, withPad: pad, startingAt: ind)).reversed())\n  }\n  \n  func chunked(to n: Int) -> [String] {\n    let rest = self.count % n\n    return Array(stride(from: 0, to: self.count - rest, by: n).map{ i -> String in \n      let start = self.index(self.startIndex, offsetBy: i)\n      let end = self.index(start, offsetBy: n, limitedBy: self.endIndex) ?? self.endIndex\n      return String(self[start..<end])\n    })\n  }  \n  func matches(_ regexString: String) -> Bool {\n    let range = NSRange(location: 0, length: self.utf16.count)\n    let regex = try! NSRegularExpression(pattern: regexString)\n    return regex.firstMatch(in: self, options: [], range: range) != nil\n  }\n  func slice(from i: Int, to j: Int) -> String {\n    let start = self.index(self.startIndex, offsetBy: i)\n    let end = self.index(self.endIndex, offsetBy: j)\n    let range = start..<end\n    return String(self[range])\n  }\n}\n\nextension Int {\n  func toBit85() -> [Int] {\n    var n = self\n    return [85 * 85 * 85 * 85, 85 * 85 * 85, 85 * 85, 85, 1].map { \n      let q = Int(floor(Double(n) \/ Double($0)))\n      n = n % $0\n      return q + 33\n    }    \n  }\n  func bit32toString() -> String {\n    var res = [String](), a85 = [pow(85.0, 4), pow(85.0, 3), pow(85.0, 2), 85.0, 1.0], n = Double(self)\n    for p in a85 {\n      let q = Int(floor(n \/ p))\n      n = Double(Int(n) % Int(p))\n      res.append(String(UnicodeScalar(q + 33)!))\n    }\n    return res.joined().replacingOccurrences(of: \"!!!!!\", with: \"z\")\n  }\n}\n\nextension Array {\n  func chunked(_ size: Int) -> [[Element]] {\n    return stride(from: 0, to: count, by: size).map { Array(self[$0 ..< Swift.min($0 + size, count)]) }\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339962,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var output = String()\n    var index = self.startIndex\n    while index != self.endIndex {\n      var nextIndex: Data.Index = self.endIndex\n      if let tryIndex = self.index(index, offsetBy: 4, limitedBy: self.endIndex) {\n        nextIndex = tryIndex\n        \/\/ checking for all nulls case\n        if self[index..<nextIndex].reduce(0, |) == 0 {\n          output += \"z\"\n          index = nextIndex\n          continue\n        }\n      }\n      let chunk = self[index..<nextIndex]\n      index = nextIndex\n      var num: UInt32 = chunk.enumerated().reduce(0, { $0 << 8 + UInt32($1.element)})\n      num = num << (8 * (4 - chunk.count))\n      var five = \"\"\n      var remainer = num\n      for _ in 0..<5 {\n        five.insert(Character(UnicodeScalar(33 + remainer % 85)!), at: five.startIndex)\n        remainer \/= 85\n      }\n      output += five.prefix(upTo: five.index(five.endIndex, offsetBy: chunk.count - 4))\n    }\n    return \"<~\" + output + \"~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    let noWhites = self.filter{ !$0.isWhitespace }\n    let body = String(noWhites.dropFirst(2).dropLast(2)).utf8\n    var output = Data()\n    var index = body.startIndex\n    while index != body.endIndex {\n      if body[index] == 122 {\n        output += Data(repeating: 0, count: 4)\n        index = body.index(after: index)\n        continue\n      }\n      var nextIndex = body.endIndex\n      if let tryIndex = body.index(index, offsetBy: 5, limitedBy: body.endIndex) {\n        nextIndex = tryIndex\n      }\n      let chunk = Array(body[index..<nextIndex])\n      index = nextIndex\n      let fullChunk = chunk + Array(repeating: UInt8(117), count: 5 - chunk.count)\n      let num: UInt32 = fullChunk.reduce(0, { $0 * 85 + UInt32($1) - 33 })\n      var four = Data()\n      var remainer = num\n      for _ in 0..<4 {\n        four.insert(UInt8(remainer % 256), at: four.startIndex)\n        remainer \/= 256\n      }\n      output += four.prefix(upTo: four.index(four.endIndex, offsetBy: chunk.count - 5))\n    }\n    return output\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339963,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var data = self, str = \"\"\n    var block: [UInt8], num: Int \n    let n = data.count, m = n\/4, lack = 4-n%4, pad = lack<4\n    if pad { data+=Data(count: lack) }\n    for i in 0..<(pad ? m+1 : m) { \n      block = []\n      num = data[i*4..<i*4+4].reduce(0, { 256*$0+Int($1) })\n      if num>0 { \n        for _ in 1...4 { block.append(UInt8(num%85+33)); num\/=85 }\n        block.append(UInt8(num+33))\n        str+=String(bytes: block.reversed(), encoding: .ascii)!\n      }  \n      else { str+=\"z\" }\n    }\n    if pad { str = str==\"z\" ? String(repeating: \"!\", count: 5-lack) : String(str.dropLast(lack)) }\n    return \"<~\\(str)~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    var data = Data(), block: [UInt8], num: Int,\n    str = String(self.dropFirst(2).dropLast(2).filter{$0.asciiValue!>32})\n    .replacingOccurrences(of: \"z\", with: \"!!!!!\")\n    let n = str.count, m = n\/5, lack = 5-n%5, pad = lack<5, start = str.startIndex\n    if pad { str+=String(repeating: \"u\", count: lack) }\n    for i in 0..<(pad ? m+1 : m) {\n      block = []\n      num = str[str.index(start, offsetBy: i*5)..<str.index(start, offsetBy: i*5+5)]\n      .reduce(0, {85*$0+Int($1.asciiValue!)-33})\n      for _ in 1...4 { block.append(UInt8(num%256)); num\/=256 }\n      block = block.reversed(); data+=Data(i<m ? block : block.dropLast(lack))\n    }\n    return data\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339964,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var data = self, str = \"\"\n    var block: [UInt8], num: Int \n    let n = data.count, m = n\/4, lack = 4-n%4, pad = lack<4\n    if pad { data+=Data(count: lack) }\n    for i in 0..<(pad ? m+1 : m) { \n      block = []\n      num = data[i*4..<i*4+4].reduce(0, { 256*$0+Int($1) })\n      if num>0 { \n        for _ in 1...4 { block.append(UInt8(num%85+33)); num\/=85 }\n        block.append(UInt8(num+33))\n        str+=String(bytes: block.reversed(), encoding: .ascii)!\n      }  \n      else { str+=\"z\" }\n    }\n    if pad { \n      if str==\"z\" { str = String(repeating: \"!\", count: 5-lack) }\n      else { str.removeLast(lack) } \n    }\n    return \"<~\\(str)~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    var str = self, data = Data()\n    var block: [UInt8], num: Int\n    str.removeFirst(2); str.removeLast(2)\n    str = String(str.filter{$0.asciiValue!>32}).replacingOccurrences(of: \"z\", with: \"!!!!!\")\n    let n = str.count, m = n\/5, lack = 5-n%5, pad = lack<5, start = str.startIndex\n    if pad { str+=String(repeating: \"u\", count: lack) }\n    for i in 0..<(pad ? m+1 : m) {\n      block = []\n      num = str[str.index(start, offsetBy: i*5)..<str.index(start, offsetBy: i*5+5)]\n      .reduce(0, {85*$0+Int($1.asciiValue!)-33})\n      for _ in 1...4 { block.append(UInt8(num%256)); num\/=256 }\n      block = block.reversed(); if i==m { block.removeLast(lack) }\n      data+=Data(block)\n    }\n    return data\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339965,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var data = self, str = \"\"\n    let n = data.count, m = n\/4, lack = 4-n%4, pad = lack<4\n    if pad { data+=Data(count: lack) }\n    for i in 0..<(pad ? m+1 : m) { \n      var block = [UInt8](), \n      num = data[i*4..<i*4+4].reduce(0, { 256*$0+Int($1) })\n      if num>0 { \n        for _ in 1...4 { block.append(UInt8(num%85+33)); num\/=85 }\n        block.append(UInt8(num+33))\n        str+=String(bytes: block.reversed(), encoding: .ascii)!\n      }  \n      else { str+=\"z\" }\n    }\n    if pad { \n      if str==\"z\" { str = String(repeating: \"!\", count: 5-lack) }\n      else { str.removeLast(lack) } \n    }\n    return \"<~\\(str)~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    var str = self, data = Data()\n    str.removeFirst(2); str.removeLast(2)\n    str = String(str.filter{$0.asciiValue!>32}).replacingOccurrences(of: \"z\", with: \"!!!!!\")\n    let n = str.count, m = n\/5, lack = 5-n%5, pad = lack<5, start = str.startIndex\n    if pad { str+=String(repeating: \"u\", count: lack) }\n    for i in 0..<(pad ? m+1 : m) {\n      var block = [UInt8](),\n      num = str[str.index(start, offsetBy: i*5)..<str.index(start, offsetBy: i*5+5)]\n      .reduce(0, {85*$0+Int($1.asciiValue!)-33})\n      for _ in 1...4 { block.append(UInt8(num%256)); num\/=256 }\n      block = block.reversed(); if i==m { block.removeLast(lack) }\n      data+=Data(block)\n    }\n    return data\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339966,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var data = self, str = \"\"\n    let n = data.count, m = n\/4, lack = 4-n%4, pad = lack<4\n    if pad { data+=Data(count: lack) }\n    for i in 0..<(pad ? m+1 : m) { \n      var block = [UInt8](), \n      num = data.subdata(in: i*4..<i*4+4).reduce(0, { 256*$0+Int($1) })\n      if num>0 { \n        for _ in 1...4 { block.append(UInt8(num%85+33)); num\/=85 }\n        block.append(UInt8(num+33))\n        str+=String(bytes: block.reversed(), encoding: .ascii)!\n      }  \n      else { str+=\"z\" }\n    }\n    if pad { \n      if str==\"z\" { str = String(repeating: \"!\", count: 5-lack) }\n      else { str.removeLast(lack) } \n    }\n    return \"<~\\(str)~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    var str = self, data = Data()\n    str.removeFirst(2); str.removeLast(2)\n    str = String(str.filter{$0.asciiValue!>32}).replacingOccurrences(of: \"z\", with: \"!!!!!\")\n    let n = str.count, m = n\/5, lack = 5-n%5, pad = lack<5, start = str.startIndex\n    if pad { str+=String(repeating: \"u\", count: lack) }\n    for i in 0..<(pad ? m+1 : m) {\n      var block = [UInt8](),\n      num = str[str.index(start, offsetBy: i*5)..<str.index(start, offsetBy: i*5+5)]\n      .reduce(0, {85*$0+Int($1.asciiValue!)-33})\n      for _ in 1...4 { block.append(UInt8(num%256)); num\/=256 }\n      block = block.reversed(); if i==m { block.removeLast(lack) }\n      data+=Data(block)\n    }\n    return data\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339967,"user_id":null,"body":"extension Data {\n  var toAscii85: String {\n    var data = self, str = \"\"\n    let n = data.count, m = n\/4, lack = 4-n%4, pad = lack<4\n    if pad { data.append(Data(count: lack)) }\n    for i in 0..<(pad ? m+1 : m) { \n      var block = [UInt8](), \n      num = data.subdata(in: i*4..<i*4+4).reduce(0, { 256*$0+Int($1) })\n      if num>0 { \n        for _ in 1...4 { block.append(UInt8(num%85+33)); num\/=85 }\n        block.append(UInt8(num+33))\n        str+=String(bytes: block.reversed(), encoding: .ascii)!\n      }  \n      else { str+=\"z\" }\n    }\n    if pad { \n      if str==\"z\" { str = String(repeating: \"!\", count: 5-lack) }\n      else { str.removeLast(lack) } \n    }\n    return \"<~\\(str)~>\"\n  }\n}\n\nextension String {\n  var fromAscii85: Data {\n    var str = self, data = Data()\n    str.removeFirst(2); str.removeLast(2)\n    str = String(str.filter{$0.asciiValue!>32}).replacingOccurrences(of: \"z\", with: \"!!!!!\")\n    let n = str.count, m = n\/5, lack = 5-n%5, pad = lack<5\n    if pad { str+=String(repeating: \"u\", count: lack) }\n    for i in 0..<(pad ? m+1 : m) {\n      var block = [UInt8](),\n      num = str[str.index(str.startIndex, offsetBy: i*5)..<str.index(str.startIndex, offsetBy: i*5+5)]\n      .reduce(0, {85*$0+Int($1.asciiValue!)-33})\n      for _ in 1...4 { block.append(UInt8(num%256)); num\/=256 }\n      block = block.reversed(); if i==m { block.removeLast(lack) }\n      data.append(Data(block))\n    }\n    return data\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5282b48bb70058e4c4000fa7":[{"id":339968,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n  var mutable = str\n    if mutable.hasPrefix(\"#\") {\n        mutable = String(mutable.dropFirst())\n    }\n    let asInt = Int(mutable, radix: 16)!\n    let r = (asInt & 0xFF0000) >> 16\n    let g = (asInt & 0x00FF00) >> 8\n    let b = (asInt & 0x0000FF)\n    return RGB(r, g, b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339969,"user_id":null,"body":"struct RGB: CustomStringConvertible, Equatable {\n    let r: Int\n    let g: Int\n    let b: Int\n\n    init(_ r: Int, _ g: Int, _ b: Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n\n    static func ==(left: RGB, right: RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str: String) -> RGB {\n    let nums = Array(str.dropFirst())\n    let r = Int(String(nums[...1]), radix: 16)!\n    let g = Int(String(nums[2...3]), radix: 16)!\n    let b = Int(String(nums[4...5]), radix: 16)!\n\n    return RGB(r, g, b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339970,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n    var start = str.index(after: str.startIndex)\n    var end = str.index(start, offsetBy: 2)\n    \n    let red = str.substring(with: start..<end)\n    start = end; end = str.index(end, offsetBy: 2)\n    let green = str.substring(with: start..<end)\n    start = end; end = str.index(end, offsetBy: 2)\n    let blue = str.substring(with: start..<end)\n    \n    return RGB(Int(red, radix: 16)!, Int(green, radix: 16)!, Int(blue, radix: 16)!)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339971,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n  let x = Int(str[str.index(after:str.startIndex)...], radix: 0x10)!\n  return RGB(x >> 16, (x >> 8) & 0xFF, x & 0xFF)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339972,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n  let r = str[str.index(str.startIndex, offsetBy: 1)..<str.index(str.endIndex, offsetBy: -4)]\n  let g = str[str.index(str.startIndex, offsetBy: 3)..<str.index(str.endIndex, offsetBy: -2)]\n  let b = str[str.index(str.startIndex, offsetBy: 5)..<str.endIndex]\n  let red = Int(UInt8(r, radix: 16)!)\n  let green = Int(UInt8(g, radix: 16)!)\n  let blue = Int(UInt8(b, radix: 16)!)\n  let rgb = RGB.init(red,green,blue)\n  return rgb\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339973,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n  \n  init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n  \n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n  \n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n    var rgbValue: UInt64 = 0\n    \n    let scanner = Scanner(string: str)\n    scanner.charactersToBeSkipped = CharacterSet(charactersIn: \"#\")\n    scanner.scanHexInt64(&rgbValue)\n    \n    return RGB(\n        Int((rgbValue & 0xFF0000) >> 16),\n        Int((rgbValue & 0x00FF00) >> 8),\n        Int((rgbValue & 0x0000FF))\n    )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339974,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n  let array = Array(str)\n  let red: Int = Int(strtoul(String(array[1...2]), nil, 16))\n  let green: Int = Int(strtoul(String(array[3...4]), nil, 16))\n  let blue: Int = Int(strtoul(String(array[5...6]), nil, 16))\n  return RGB(red, green, blue)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339975,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str: String) -> RGB {\n    let intValue = Int(str.dropFirst(), radix: 16) ?? 0\n    let b = UInt8(intValue & 0xff)\n    let g = UInt8((intValue>>8) & 0xff)\n    let r = UInt8((intValue>>16) & 0xff)\n    return RGB(Int(r), Int(g), Int(b))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339976,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n  guard str.count == 7 else { fatalError(\"ERROR. Shorthand notation is not supported\")}\n    let hex = Array(str.dropFirst().map{String($0)})\n    if let r = Int( String(hex[0] + hex[1]), radix: 16),\n        let g = Int(String(hex[2] + hex[3]), radix: 16),\n       let b = Int(String(hex[4] + hex[5]), radix: 16) {\n        return RGB(r, g, b)\n    } else {\n        fatalError(\"string has not hex element\")\n    }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339977,"user_id":null,"body":"import Foundation\n\nstruct RGB: CustomStringConvertible, Equatable {\n    var r:Int\n    var g:Int\n    var b:Int\n    init(_ r:Int, _ g:Int, _ b:Int) {\n        self.r = r\n        self.g = g\n        self.b = b\n    }\n    static func ==(left:RGB, right:RGB) -> Bool {\n        return left.r == right.r && left.g == right.g && left.b == right.b\n    }\n    var description: String {\n        return \"{R:\\(r), G:\\(g), B:\\(b)}\"\n    }\n}\n\nfunc hexStringToRGB(_ str:String) -> RGB {\n   let hex = Array(str.dropFirst())\n    let red = Int(String(hex[0...1]), radix: 16)!\n    let green = Int(String(hex[2...3]), radix: 16)!\n    let blue = Int(String(hex[4...5]), radix: 16)!\n    \n    return RGB(red, green, blue)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52c31f8e6605bcc646000082":[{"id":339978,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {\n    for i in 0..<(numbers.count-1) {\n      for j in (i+1)..<numbers.count {\n        if numbers[i] + numbers[j] == target {\n          return [i,j]\n        }\n      }\n    }\n    return [];\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339979,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {\n    var numberPairs = [Double: Double]()\n    for (index,number) in numbers.enumerated() {\n        if let pairIndex = numberPairs[target - number] {\n            return[Int(pairIndex),index]\n        } else {\n            numberPairs[Double(number)] = Double(index)\n        }\n    }\n    return []\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339980,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {\n    for x in 0..<numbers.count {\n    \n      for y in 0..<numbers.count {\n      \n        if numbers[x] + numbers[y] == target && x != y { return [x, y] }\n      \n      }\n    \n    }\n    return [0]\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339981,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {\n    for i in 0..<numbers.count {\n      for j in i+1..<numbers.count {\n        if numbers[i] + numbers[j] == target { return [i, j] }\n      }\n    }\n    \n    return []\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339982,"user_id":null,"body":"class Solution {\n    static func two_sum(numbers: [Double], target: Double) -> [Int] {\n        return numbers.enumerated().filter { a in\n            numbers.enumerated().contains { a.offset != $0 && a.element + $1 == target }\n        }.map { $0.offset }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339983,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {\n        let retval :  [Int] = []\n        var map : [Double:Int] = [:]\n        \n        for indx in 0..<numbers.count  {\n            let complement : Double = target - numbers[indx]\n            if map[complement] != nil {\n                return [map[complement]!,indx]\n            }\n            map[numbers[indx]] = indx\n        }\n         return retval\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339984,"user_id":null,"body":"final class Solution {\n    static func two_sum(numbers: [Double], target: Double) -> [Int] {\/\/C++ Style\n        for i in 0..<numbers.count { for j in 0..<numbers.count { if numbers[i] + numbers[j] == target, i != j { return [i, j] } } }\n        return [0, 0]\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339985,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {\n    \n    for i in 0...numbers.count - 1 {\n        \n        for j in 1...numbers.count - 1{\n            \n            \n            if numbers[i] + numbers [j] == target {\n\n                return [i, j]\n            }\n        }\n    }\n      return []\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339986,"user_id":null,"body":"class Solution {\n  static func two_sum(numbers: [Double], target: Double) -> [Int] {  \n    var map : [Double : Int] = [:]\n    for (i, num) in numbers.enumerated()\n    {\n      map[num] = i\n    }\n    \n     for (j, num) in numbers.enumerated()\n    {\n      let diff = target - num\n      if let val = map[diff] {\n        return [j, val]\n      }\n    }\n    \n    return []\n    \n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339987,"user_id":null,"body":"class Solution {\n    static func two_sum(numbers: [Double], target: Double) -> [Int] {\n        for i in 0...numbers.count - 1 {\n            for j in i+1...numbers.count - 1 {\n                if numbers[i] + numbers[j] == target {\n                    return [i, j]\n                }\n            }\n        }\n        return []\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52dd72494367608ac1000416":[{"id":339988,"user_id":null,"body":"extension Int {\n    func isPrime() -> Bool {\n        guard self != 2, self != 3 else { return true }\n        guard self != 1, self % 6 == 1 || self % 6 == 5 else { return false }\n        \n        for n in Swift.stride(from: 5, through: Int(sqrt(Double(self))), by: 2) {\n            guard self % n != 0 else { return false }\n        }\n        \n        return true\n    }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n    return (min(start, end)...max(start, end)).filter { $0.isPrime() }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339989,"user_id":null,"body":"extension Int {\n  func isPrime() -> Bool {\n    return self > 1 && !(2..<self).contains { self % $0 == 0 }\n  }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n  return end < start ? getPrimes(from:end, to:start) : (start...end).filter({$0.isPrime()})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339990,"user_id":null,"body":"extension Int {\n  func isPrime() -> Bool {\n    switch self {\n    case 0...1:\n      return false\n    case 2:\n      return true\n    default:\n      let lower = 2 < self-1 ? 2 : self-1\n      let upper = 2 > self-1 ? 2 : self-1\n      return (lower...upper).lazy.map { self % $0 }.first { $0 == 0 } == nil\n    }\n  }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n  return (min(start, end)...max(start, end)).filter { $0.isPrime() }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339991,"user_id":null,"body":"extension Int {\n  func isPrime() -> Bool {\n    return self > 1 && !(2 ..< self).contains { self % $0 == 0 }\n  }\n}\n\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n    return start > end ? Array(end ... start).filter({ $0.isPrime() }) :  Array(start ... end).filter({ $0.isPrime() })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339992,"user_id":null,"body":"extension Int {\nfunc isPrime() -> Bool {\n    var j = 2\n    \n    while j < self {\n        print(j)\n        if self % j == 0{\n            return false\n        }\n        \n        j = j + 1\n    }\n  return self > 1\n}\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n   var finalArr = [Int]()\n    var temp: Int\n    var testStart = start\n    var testEnd = end\n    \n    if testStart > testEnd {\n        temp = testStart\n        testEnd = testStart\n        testStart = temp\n    }\n        for number in stride(from: 2, through: testEnd, by: 1) {\n        print(number)\n               var count = 0\n               for num in 1..<number {\n                   if number % num == 0 {\n                       count += 1\n                   }\n               }\n               if count <= 1 {\n                finalArr.append(number)\n               }\n           }\n    return finalArr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339993,"user_id":null,"body":"extension Int {\n  func isPrime() -> Bool {\n    return self < 2 ? false : !(2..<self).contains { self % $0 == 0 }\n  }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n  return (min(start, end)...max(start, end)).filter { $0.isPrime() } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339994,"user_id":null,"body":"extension Int {\n  func isPrime() -> Bool {\n    if self <= 3 { return self == 2 || self == 3 }\n    for i in 2...self\/2 {\n      if self % i == 0 {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n  var primes = [Int]()\n  let range = start > end ? end...start : start...end\n  \n  for number in range {\n    if number.isPrime() { primes.append(number) }\n  }\n  \n  return primes\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339995,"user_id":null,"body":"extension Int {\n    func isPrime() -> Bool {\n        let divisors = [2, 3, 5, 7]\n        if self <= 1 { return false }\n        for divisor in divisors {\n            if self == divisor { return true }\n            if self % divisor == 0 { return false }\n        }\n        return true\n    }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n    var result: [Int] = []\n    for number in min(start,end)..<max(start,end) {\n        if number.isPrime() {\n            result.append(number)\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339996,"user_id":null,"body":"extension Int {\n  func isPrime() -> Bool {\n    if self < 2 { return false }\n\t\tlet maxDivisor = Int(ceil(sqrt(Double(self))))\n\n\t\tfor i in 2...maxDivisor {\n\t\t\tif self % i == 0 && self != i {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true\n  }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n  let upper = max(start, end)\n\t\tlet lower = min(start, end)\n\t\t\n\t\treturn (lower...upper).filter({ (num: Int) -> Bool in\n\t\t\treturn num.isPrime()\n\t\t})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339997,"user_id":590,"body":"extension Int {\n  func isPrime() -> Bool {\n    if self < 2 { return false }\n\n    for i in 2...self {\n      if self != i && self % i == 0 { return false }\n    }\n    \n    return true\n  }\n}\n\nfunc getPrimes(from start: Int, to end: Int) -> [Int] {\n  var arr: [Int] = []\n  var small = start\n  var large = end\n\n  if start > end {\n    small = end\n    large = start\n  }\n\n  for i in small...large {\n    if i.isPrime() {\n      arr.append(i)\n    }\n  }\n\n  return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52de553ebb55d1fca3000371":[{"id":339998,"user_id":null,"body":"func find_missing(l:[Int]) -> Int {\n    let sum = l.reduce(0, +)\n    return (l[0] + l[l.count-1]) * (l.count + 1) \/ 2 - sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":339999,"user_id":null,"body":"func find_missing(l sequence:[Int]) -> Int {\n\n  let gap = (sequence.last! - sequence.first!) \/ sequence.count\n  \n  for i in 0..<sequence.count where (sequence[i] + gap) != sequence[i+1] {\n      return sequence[i+1]-gap\n  }\n  \n  return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340000,"user_id":null,"body":"func find_missing(l:[Int]) -> Int {\n  let sum = l.reduce(0, +)\n  return (l.first! + l.last!) * (l.count + 1) \/ 2 - sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340001,"user_id":null,"body":"func find_missing(l sequence:[Int]) -> Int {\n  let maxSteps = sequence.count\n  let start = sequence[0]\n  let end = sequence[sequence.count - 1]\n  let constant = (end - start) \/ maxSteps\n  let sum = sequence.reduce(0,+)\n  let maxSum = Array(stride(from: start, through: end, by: constant)).reduce(0,+)\n  return maxSum - sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340002,"user_id":null,"body":"func find_missing(l:[Int]) -> Int {\n    return (l.last!+l.first!)*(l.count+1)\/2 - l.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340003,"user_id":null,"body":"func find_missing(l:[Int]) -> Int {\n    let step = (l.first! - l.last!) \/ l.count\n    \n    let index = l.enumerated().filter {\n        if ($0.offset + 1) < l.count {\n            return $0.element - l[$0.offset + 1] != step\n        } else {\n            return false\n        }\n    }[0].offset\n    \n    return (l[index] + l[index + 1]) \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340004,"user_id":null,"body":"import Foundation\n\n\nfunc find_missing(l: [Int]) -> Int {\n    var counter: [Int: Int] = [:], d: Int, result: Int = 0\n    for i in 0..<l.count - 1 {\n        d = l[i + 1] - l[i]\n        if counter.keys.contains(d) {\n            counter[d]! += 1\n        } else {\n            counter[d] = 0\n        }\n    }\n    let realityD: Int = counter.max { tuple1, tuple2 in tuple1.value < tuple2.value}?.key ?? 0\n    for i in 0..<l.count - 1 {\n        d = l[i + 1] - l[i]\n        if d != realityD {\n            result = l[i] + realityD\n            break\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340005,"user_id":null,"body":"func find_missing(l sequence:[Int]) -> Int {\n    let avg = (sequence.last! - sequence.first! ) \/ sequence.count\n    for i in 1..<sequence.count {\n        if sequence[i] != sequence[i-1]+avg {\n            return sequence[i-1]+avg\n        }\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340006,"user_id":null,"body":"func find_missing(l sequence:[Int]) -> Int {\n    let d: Int = (sequence[sequence.count-1]-sequence[0])\/sequence.count\n    for n in 1..<sequence.count {\n        if (sequence[n]-sequence[(n-1)]) == d {\n            continue\n        } else {\n            return sequence[n-1] + d\n        }\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340007,"user_id":null,"body":"func find_missing(l sequence: [Int]) -> Int {\n    if let last = sequence.last, let first = sequence.first {\n        let set = Set(sequence)\n        let d = (last - first) \/ sequence.count\n        var i = first\n        while i != last {\n            i += d\n            if !set.contains(i) {\n                return i\n            }\n        }\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52e88b39ffb6ac53a400022e":[{"id":340008,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n    let byte1 = UInt8(i32 & 0xff)\n    let byte2 = UInt8((i32>>8) & 0xff)\n    let byte3 = UInt8((i32>>16) & 0xff)\n    let byte4 = UInt8((i32>>24) & 0xff)\n    return \"\\(byte4).\\(byte3).\\(byte2).\\(byte1)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340009,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n    return \"\\(UInt8((i32>>24) & 0xff)).\\(UInt8((i32>>16) & 0xff)).\\(UInt8((i32>>8) & 0xff)).\\(UInt8(i32 & 0xff))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340010,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n    return [24, 16, 8, 0]\n        .map { String(UInt8(truncatingIfNeeded: i32 >> $0)) }\n        .joined(separator: \".\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340011,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n    var i = i32\n    var s = \"\"\n    for j in 0...3 {\n        let n = i % 256\n        s = \"\\(n)\" + (j == 0 ? \"\" : \".\") + s\n        i \/= 256\n    }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340012,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n  \n  (withUnsafeBytes(of: i32.bigEndian) { Array($0) }).map{ String($0) }.joined(separator: \".\")\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340013,"user_id":null,"body":"extension UInt32 {\n    func toI8Arr() -> [UInt8] {\n        return [\n            UInt8((self & 0xFF000000) >> 24),\n            UInt8((self & 0x00FF0000) >> 16),\n            UInt8((self & 0x0000FF00) >> 8),\n            UInt8(self & 0x000000FF)\n        ]\n    }\n}\n\nfunc ipv4(of i32: UInt32) -> String {\n    let i8List = i32.toI8Arr()\n    return i8List\n        .map { \"\\($0)\" }\n        .joined(separator: \".\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340014,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n  var bytes = [String](repeating: \"0\", count: 32)\n  \n  let binaryString = String(i32, radix: 2)\n  \n  for (index, element) in binaryString.enumerated() {\n    bytes[32 - binaryString.length + index] = String(element)\n  }\n  \n  let result = String(Int(bytes[0...7].joined(separator: \"\"), radix: 2) ?? 0) + \".\"  +\n    String(Int(bytes[8...15].joined(separator: \"\"), radix: 2) ?? 0) + \".\" +\n    String(Int(bytes[16...23].joined(separator: \"\"), radix: 2) ?? 0) + \".\" +\n    String(Int(bytes[24...31].joined(separator: \"\"), radix: 2) ?? 0)\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340015,"user_id":null,"body":"import Foundation\n\n\nfunc ipv4(of i32: UInt32) -> String {\n    var binaryNumer = String(i32, radix: 2)\n    if binaryNumer.count < 32 {\n        binaryNumer = repeatElement(\"0\", count: (32 - binaryNumer.count)) + binaryNumer\n    }\n    for i in 1...3 {\n        binaryNumer.insert(\".\", at: binaryNumer.index(binaryNumer.startIndex, offsetBy: 32 - 8 * i))\n    }\n    return binaryNumer.split(separator: \".\").map { String(Int($0, radix: 2)!) }.joined(separator: \".\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340016,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n  var num = i32\n  var result = \"\"\n  while num > 0 {\n    result = \"\\(num % 256).\\(result)\"\n    num \/= 256\n  }\n  result = String(result.dropLast())\n  return [3: \"\", \n          2: \"0.\", \n          1: \"0.0.\", \n          0: \"0.0.0.0\"][result.filter{$0 == \".\"}.count]! + result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340017,"user_id":null,"body":"func ipv4(of i32: UInt32) -> String {\n    var ip = String()\n    var input = i32\n    var sum = Int()\n    var i = 0\n    \n    let bits = convertInputInBinary(number: &input)\n    \n    if bits.count < 4 { handleEmptyBit(bits, &ip) }\n    \n    let values = [\n        0 : 128, 1: 64, 2: 32, 3: 16, 4: 8, 5: 4, 6: 2, 7: 1\n    ]\n    \n    handleIPConversion(bits, &i, &sum, values, &ip)\n    \n    return ip.trimmingCharacters(in: .punctuationCharacters)\n}\n\nprivate func convertInputInBinary(number: inout UInt32) -> [[String]] {\n    var bits = [[String]]()\n    var bit = [String]()\n    \n    let index = bit.startIndex\n    \n    while number > 0 {\n        number % 2 == 0 ? bit.insert(\"0\", at: index) : bit.insert(\"1\", at: index)\n        number \/= 2\n        \n        if bit.count == 8 || number < 1 {\n            bits.insert(bit, at: bits.startIndex)\n            bit.removeAll()\n        }\n    }\n    \n    return bits\n}\n\nprivate func handleEmptyBit(_ bits: [[String]], _ ip: inout String) {\n    \n    let max = 4 - bits.count\n    \n    for _ in 1...max {\n        ip += \"0.\"\n    }\n}\n\nprivate func handleIPConversion(_ bits: [[String]], _ i: inout Int, _ sum: inout Int, _ values: [Int : Int], _ ip: inout String) {\n    for bit in bits {\n        for (binaryIndex, binary) in bit.enumerated() {\n            if bit.count < 8 {\n                i = (binaryIndex + 8) - bit.count\n            } else {\n                i = binaryIndex\n            }\n            \n            if binary == \"1\" { sum += values[i] ?? 0 }\n            \n            if bits.count > 8 { i += 1 }\n        }\n        \n        ip += String(sum)\n        sum = 0\n        ip += \".\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52fb87703c1351ebd200081f":[{"id":340018,"user_id":null,"body":"extension Int {\n  var spokenSuffix: String {\n    let ones = self % 10\n    let tens = (self \/ 10) % 10\n      \n    guard tens != 1 else { return \"th\" }\n  \n    switch ones {\n    case 1: return \"st\"\n    case 2: return \"nd\"\n    case 3: return \"rd\"\n    default: return \"th\"\n    }\n  }\n}\n\nfunc whatCentury(_ year: String) -> String {\n  guard let year = Int(year) else { return \"bad input\" }\n  let century = (year - 1) \/ 100 + 1\n  return String(century) + century.spokenSuffix\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340019,"user_id":null,"body":"import Foundation\nfunc whatCentury(_ year: String) -> String {\n    return NumberFormatter.localizedString(\n      from: NSNumber(value: ceil(Double(year)!\/100)),\n      number: .ordinal)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340020,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n    let intYear = Int(year) ?? 1\n    let intCentury = intYear % 100 == 0 ? intYear \/ 100 : intYear \/ 100 + 1\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .ordinal\n    \n    return formatter.string(from: intCentury as NSNumber) ?? \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340021,"user_id":null,"body":"\n\nfunc whatCentury(_ year: String) -> String {\n  \/\/ one special case\n  if (year == \"0000\") {\n    return \"0th\"\n  }\n  \/\/ not for validation but not to use force unwrapping for parsing\n  guard let yearNumber = Int(year) else {\n    return \"Year has to be a number\"\n  }\n  let previousYear = yearNumber-1\n  let century = previousYear \/ 100 + 1\n  let firstDigit = century \/ 10\n  let secondDigit = century % 10\n  var ending = \"\"\n  switch (firstDigit,secondDigit) {\n    case (1,_):\n      ending = \"th\"\n    case (_,1):\n      ending = \"st\"\n    case (_,2):\n      ending = \"nd\"\n    case (_,3):\n      ending = \"rd\"\n    default:\n      ending = \"th\"\n  }\n  return \"\\(century)\\(ending)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340022,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n    \n    let century = String(Int((Double(year)! * 0.01).rounded(.up)))\n    guard century.first != \"1\" else { return century + \"th\" }\n    switch century.last {\n    case \"1\":\n        return century + \"st\"\n    case \"2\":\n        return century + \"nd\"\n    case \"3\":\n        return century + \"rd\"\n    default:\n        return century + \"th\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340023,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n    \n    var result:String = \"\"\n    let centuryEndings = [\"st\", \"nd\", \"rd\", \"th\"]\n    var yearVariable = year\n    \n    if year.count < 4 {\n        yearVariable = \"0\" + yearVariable\n    }\n    \n    if year == \"2000\" {\n        result = \"20th\"\n    } else {\n    \n        let yearFirstNumber = String(Int(yearVariable.prefix(2))! + 1)\n        \n    \nswitch yearFirstNumber {\n    case \"1\",\"01\",\"21\",\"31\",\"41\",\"51\",\"61\",\"71\",\"81\",\"91\":\n        result = String(yearFirstNumber) + centuryEndings[0]\n    case \"2\",\"02\",\"22\",\"32\",\"42\",\"52\",\"62\",\"72\",\"82\",\"92\":\n        result = String(yearFirstNumber) + centuryEndings[1]\n    case \"3\",\"03\",\"23\",\"33\",\"43\",\"53\",\"63\",\"73\",\"83\",\"93\":\n        result = String(yearFirstNumber) + centuryEndings[2]\n    default:\n        result = String(yearFirstNumber) + centuryEndings[3]\n}\n    }\n return result\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340024,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n         let yearInNumber = Int(year)!\n        let century = (Double(yearInNumber)\/100.0).rounded(.up)\n        var centuryInString = \"\\(Int(century))\"\n        var characters1 = Array(centuryInString)\n        var lastCharacter = \"\"\n        if characters1.count > 1 {\n            lastCharacter = \"\\(characters1[1])\"\n        } else {\n            lastCharacter = \"\\(characters1[0])\"\n        }\n        if century > 10 && century <= 13 {\n            centuryInString = centuryInString + \"th\"\n        } else if Int(\"\\(lastCharacter)\") == 1 {\n            centuryInString = centuryInString + \"st\"\n        } else if Int(\"\\(lastCharacter)\") == 2 {\n            centuryInString = centuryInString + \"nd\"\n        } else if Int(\"\\(lastCharacter)\") == 3 {\n            centuryInString = centuryInString + \"rd\"\n        } else {\n            centuryInString = centuryInString + \"th\"\n        }\n        return centuryInString\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340025,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n  let p = (Int(year)!-1)\/100+1\n  return \"\\(p)\\(p\/10==1 ? \"th\" : [1:\"st\",2:\"nd\",3:\"rd\"][p%10] ?? \"th\")\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340026,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n  guard let year = Int(year) else { fatalError() }\n  let century = (year - 1) \/ 100 + 1\n  if (10...19).contains(century) { return \"\\(century)th\" }\n  switch century % 10 {\n  case 1: return \"\\(century)st\"\n  case 2: return \"\\(century)nd\"\n  case 3: return \"\\(century)rd\"\n  default: return \"\\(century)th\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340027,"user_id":null,"body":"func whatCentury(_ year: String) -> String {\n  let c = ((Int(year) as! Int)-1)\/100+1\n  return String(c) + (c>=4 && c<=20 ? \"th\" : c%10==1 ? \"st\" : c%10==2 ? \"nd\" : c%10==3 ? \"rd\": \"th\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"52fba66badcd10859f00097e":[{"id":340028,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n  return s.replacingOccurrences(of: \"[aeiou]\", with: \"\", options: [.regularExpression, .caseInsensitive])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340029,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n  let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n  \n  return String(s.characters.filter { !vowels.contains($0) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340030,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n   return s.replacingOccurrences(of: \"[AEIOUaeiou]\", with: \"\", options: .regularExpression)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340031,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n\tvar str = \"\"\n  let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  for i in s.characters {\n  \tif !vowels.contains(String(i).lowercased()) {\n    \tstr += String(i)\n     }\n  }\n  return str\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340032,"user_id":null,"body":"let vowels = Set(\"aeiouAEIOU\")\n\nfunc disemvowel(_ s: String) -> String {\n    return s.filter { !vowels.contains($0) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340033,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n    s.filter { ![\"a\", \"e\", \"i\", \"o\", \"u\"].contains($0.lowercased())}\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340034,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n  let vowels = Set(\"aeiouAEIOU\".characters)\n  return String(s.characters.filter{ !vowels.contains($0) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340035,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n  return s.components(separatedBy: CharacterSet(charactersIn: \"aeiouAEIOU\")).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340036,"user_id":null,"body":"func disemvowel(_ s: String) -> String {\n  var big: String = \"\"\n  for letter in s {\n  var l = letter.lowercased()\n    if l != \"a\" && l != \"e\" && l != \"o\" && l != \"i\" && l != \"u\" {\n      big += String(letter)\n    }\n  }\n  return big\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340037,"user_id":null,"body":"func disemvowel(_ s: String) -> String \n{\n  var answer: String = \"\"\n  \n  var i = s.startIndex\n  while i < s.endIndex\n  {\n    switch String(s[i])\n    {\n    case \"A\":\n      i = s.index(after: i)\n    case \"a\":\n      i = s.index(after: i)\n    case \"E\":\n      i = s.index(after: i)\n    case \"e\":\n      i = s.index(after: i)\n    case \"I\":\n      i = s.index(after: i)\n    case \"i\":\n      i = s.index(after: i)\n    case \"O\":\n      i = s.index(after: i)\n    case \"o\":\n      i = s.index(after: i)\n    case \"U\":\n      i = s.index(after: i)\n    case \"u\":\n      i = s.index(after: i)\n    default:\n      answer += String(s[i])\n      i = s.index(after: i)\n    }\n  }\n  \n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"53369039d7ab3ac506000467":[{"id":340038,"user_id":53,"body":"func bool_to_word(_ bool: Bool) -> String {\n  bool ? \"Yes\" : \"No\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340039,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\nreturn bool == true ? \"Yes\" : \"No\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340040,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\n  if bool == true {\n    return \"Yes\"\n  }\n  else {\n    return \"No\"\n  } \n  return \"HEHE\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340041,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\nbool == true ? \"Yes\" : \"No\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340042,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\n  let isCorrect = bool\n  \n  if isCorrect {\n    return \"Yes\"\n  } else {\n    return \"No\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340043,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\n  let dic = [true: \"Yes\", false: \"No\"]\n  return dic[bool]!\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340044,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\n  var name = \"\"\n  if bool == true{\n    name = \"Yes\"\n  } else if bool == false{\n    name = \"No\"\n  }\n  return name\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340045,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\n      if bool {\n        return \"Yes\"\n      } else {\n        return \"No\"\n      }\n  return String(bool)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340046,"user_id":null,"body":"func bool_to_word(_ bool: Bool) -> String {\n  return bool ? \"Yes\" : \"No\"\n  \/\/   condicion ? resultado true : resultado false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340047,"user_id":null,"body":"func bool_to_word(_ value: Bool) -> String {\n    return value ? \"Yes\" : \"No\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"534e01fbbb17187c7e0000c6":[{"id":340048,"user_id":null,"body":"import Foundation\n\n\nfunc spiral(_ n:Int) -> [[Int]] {\n    var result: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\n\n    for pass in 0...n\/4{\n        if pass*4 == n {break}\n        for xCoord in (pass*2)...(n-1-pass*2) {\n            result[pass*2][xCoord] = 1\n        }\n        if pass*4+1 == n {break}\n        for yCoord in (pass*2)...(n-1-pass*2){\n            result[yCoord][n-1-pass*2] = 1\n        }\n        if pass*4+2 == n {break}\n        for xCoord in (pass*2)...(n-1-pass*2) {\n            result[n-1-pass*2][xCoord] = 1\n        }\n        if pass*4+3 == n {break}\n        for yCoord in (pass*2+2)...(n-1-pass*2){\n            result[yCoord][pass*2] = 1\n        }\n        if pass*4+4 == n {break}\n        result[pass*2+2][pass*2+1] = 1\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340049,"user_id":null,"body":"func spiral(_ n:Int) -> [[Int]] {\n  \/\/build spiral\n  var ones = [Int](repeating: 1, count: n)\n  var zeros = [Int](repeating: 0, count: n)\n  var spiral = [[Int]](repeating: zeros, count: n-1)\n  spiral.insert(ones, at:0)\n\n  \/\/control variables\n  var side = n-1\n  var direction = 0\n  var position = (x: 0, y: n-1)\n  var oneTimeFlag = true \n  \n  \/\/change it ~spiralliry~\n  while side >= 1 && oneTimeFlag {\n   \n    \/\/ treat special case: last segment with side of size one happens only one time.\n    if side == 1 { oneTimeFlag = false }\n    \n    \/\/ update position and change values \n    (0..<side).forEach { _ in\n      if direction == 0 { position.x += 1 }\n      else if direction == 1 { position.y -= 1 }\n      else if direction == 2 { position.x -= 1 }\n      else if direction == 3 { position.y += 1 } \n        \n      spiral[position.x][position.y] = 1\n    }\n    \n    \/\/ update direction and side\n    direction = (direction + 1) % 4\n    if direction == 2 || direction == 0 { side -= 2 }\n  }\n  \n  return spiral\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340050,"user_id":null,"body":"func spiral(_ n:Int) -> [[Int]] {\n    var spiral = Array(repeating: Array(repeating: 1, count: n), count: n)\n    var count = 0\n    \n    for i in 0..<n {\n        for j in 0..<i {\n            if i < (n+1)\/2 && j+1 == i { break }\n            spiral[i][j] = 0\n        }\n    }\n    \n    while(n - 4*count-2 > 0) {\n        spiral.swapAt(2*count+1, n-(2*count+1))\n        for j in 0..<n {\n            spiral[j].swapAt(2*count, n-2*(count+1))\n        }\n        count+=1\n    }\n    \n    return spiral\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340051,"user_id":null,"body":"import Foundation\n\n\nenum directions {\n    case up\n    case down\n    case left\n    case right\n}\n\nstruct HeadOfSnake {\n    var column: Int\n    var row: Int\n    var direction: directions\n    \n    init(_ column: Int, _ row: Int, _ direction: directions) {\n        self.column = column\n        self.row = row\n        self.direction = direction\n    }\n    \n    mutating func move() {\n        switch direction {\n        case .up:\n            return self.row -= 1\n        case .down:\n            return self.row += 1\n        case .left:\n            return self.column -= 1\n        case .right:\n            return self.column += 1\n        }\n    }\n    \n    mutating func nextDirection() {\n        switch direction {\n        case .up:\n            return self.direction = .right\n        case .down:\n            return self.direction = .left\n        case .left:\n            return self.direction = .up\n        case .right:\n            return self.direction = .down\n        }\n    }\n    \n    var check: (close: (column: Int, row: Int), far: (column: Int, row: Int)) {\n        switch direction {\n        case .up:\n            return ((self.column, self.row - 1), (self.column, self.row - 2))\n        case .down:\n            return ((self.column, self.row + 1), (self.column, self.row + 2))\n        case .left:\n            return ((self.column - 1, self.row), (self.column - 2, self.row))\n        case .right:\n            return ((self.column + 1, self.row), (self.column + 2, self.row))\n        }\n    }\n    \n}\n\nfunc spiral(_ n:Int) -> [[Int]] {\n    if n < 5 {return [[]]}\n    var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)\n    var head = HeadOfSnake(0, 0, .right)\n    var turnCount = 0\n    while turnCount != n {\n        let cellsToCheck = head.check\n        let far = cellsToCheck.far.row < n && cellsToCheck.far.column < n ? cellsToCheck.far.row >= 0 && cellsToCheck.far.column >= 0 ? matrix[cellsToCheck.far.row][cellsToCheck.far.column] : -1  : -1\n        let close = cellsToCheck.close.row < n && cellsToCheck.close.column < n ? cellsToCheck.close.row >= 0 && cellsToCheck.close.column >= 0 ? matrix[cellsToCheck.close.row][cellsToCheck.close.column] : -1 : -1\n        \n        if (close == -1 && far == -1) || (close == 0 && far == 1) {\n            matrix[head.row][head.column] = 1\n            turnCount += 1\n            head.nextDirection()\n            head.move()\n        } else {\n            matrix[head.row][head.column] = 1\n            head.move()\n        }\n    }\n    return matrix\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340052,"user_id":null,"body":"import Foundation\n\n\nfunc spiral(_ n:Int) -> [[Int]] {\n  var spiralMatrix = Array(repeating: Array(repeating: 0, count: n), count: n)\n  \n  var indexRow = 0\n  var indexCol = n - 1\n  var count = 0\n  while(indexRow <= (Int)(n - 1)\/2) {\n    var spiralCont = false\n    \n    for i in stride(from: 0, to: spiralMatrix[indexRow].count, by: 1) {\n      if(i == spiralMatrix[indexRow].count - 1) {\n        spiralMatrix[indexRow][i] = 1\n        break\n      }\n      if(spiralMatrix[indexRow][i + 1] != 1) {\n        spiralMatrix[indexRow][i] = 1\n        spiralCont = true\n      }\n    }\n    if(!spiralCont) {break}\n    spiralCont = false\n    \n    for i in stride(from: 0, to: spiralMatrix.count, by: 1) {\n      if(i == spiralMatrix.count - 1) {\n        spiralMatrix[i][indexCol] = 1\n        break\n      }\n      if(spiralMatrix[i + 1][indexCol] != 1) {\n        spiralMatrix[i][indexCol] = 1\n        spiralCont = true\n      } \n    }\n    if(!spiralCont) {break}\n    spiralCont = false\n    \n    for i in stride(from: (n - 1), to: -1, by: -1) {\n      if(i == 0) {\n        spiralMatrix[indexCol][i] = 1\n        break\n      }\n      if(spiralMatrix[indexCol][i - 1] != 1 && spiralMatrix[indexCol - 1][i] != 1) {\n        spiralMatrix[indexCol][i] = 1\n        spiralCont = true\n      }\n    }\n    if(!spiralCont) {break}\n    spiralCont = false\n    \n    for i in stride(from: (n - 1), to: -1, by: -1) {\n      if(i == 0) {\n        spiralMatrix[i][indexRow] = 1\n        break\n      }\n      if(spiralMatrix[i - 1][indexRow] != 1) {\n        spiralMatrix[i][indexRow] = 1\n        spiralCont = true\n      }\n    }\n    if(!spiralCont) {break}\n    \n    print(\"\\(count)\n\")\n    for i in stride(from:0,to: n, by: 1) {\n      print(\"\\(spiralMatrix[i])\n\")\n    }\n    \n    indexRow += 2\n    indexCol -= 2\n    count += 1\n    \n  }\n  \n  \n  return spiralMatrix\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340053,"user_id":null,"body":"import Foundation\nfunc spiral(_ n: Int) -> [[Int]] {\n  var m = Array(repeating: Array(repeating: 0, count: n), count: n)\n  var i = 0, r = 0, c = 0, l = n\n  let leg = {\n    switch i%4 {\n      case 1: for i in r...r+l-1 { m[i][c] = 1 }; r+=l-1; c-=1                                \n      case 2: for i in c-l+1...c { m[r][i] = 1 }; r-=1; c+=1-l\n      case 3: for i in r-l+1...r { m[i][c] = 1 }; r+=1-l; c+=1\n      case _: for i in c...c+l-1 { m[r][i] = 1 }; r+=1; c+=l-1\n    }\n    i+=1\n  }\n  leg(); l-=1; leg(); leg(); while i<n { if i%2==1 { l-=2 }; leg() }\n  return m\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340054,"user_id":null,"body":"func spiral(_ n:Int) -> [[Int]] {\n\n  var a = Array(repeating: Array(repeating: 0, count: n), count: n)\n\n  var (i,j) = (0, n-1)  \/\/ position\n  var (x,y) = (1, 0)    \/\/ direction\n  var steps = n - 1\n  \n  a[0] = Array(repeating: 1, count: n)\n  \n  \/\/ mark 1's along direction (x, y)\n  func mark(steps: Int) {\n      for _ in 1...steps {\n          (i, j) = (i+x, j+y)\n          a[i][j] = 1\n      }\n  }\n  \n  \/\/ mark 1's along the spiral\n  while steps > 0 {\n      mark(steps: steps)\n      if steps == 1 { break }\n      (x, y) = (y, -x)        \/\/ return 90\u00b0 \n      mark(steps: steps)\n      (x, y) = (y, -x)        \/\/ return 90\u00b0 again\n      steps -= 2\n  }\n  \n  return a\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340055,"user_id":null,"body":"import Foundation\n\nlet spirals: [[[Int]]] = [[[1]], [[1,1],[0,1]], [[1,1,1],[0,0,1],[1,1,1]], [[1,1,1,1],[0,0,0,1],[1,0,0,1],[1,1,1,1]]]\nfunc spiral(_ n:Int) -> [[Int]] {\n    guard n > 4 else { return spirals[n - 1] }\n    var s = [[Int]]()\n    s.append(contentsOf: [[Int](repeating: 1, count: n), [Int](repeating: 0, count: n - 1) + [1]])\n    spiral(n - 4).forEach { s.append([1, 0] + $0 + [0, 1]) }\n    s.append(contentsOf: [[1] + [Int](repeating: 0, count: n - 2) + [1], [Int](repeating: 1, count: n)])\n    s[2][1] = 1\n    return s\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340056,"user_id":null,"body":"func canMove(minimap: [[Int]], i: Int, j: Int, di: Int, dj: Int) -> Bool {\n    let n = minimap.count\n    var i = i + di\n    var j = j + dj\n    \n    if i < 0 || i >= n || j < 0 || j >= n {\n        return false\n    }\n    \n    if minimap[i][j] == 1 {\n        return false\n    }\n    \n    i += di\n    j += dj\n    \n    if i < 0 || i >= n || j < 0 || j >= n {\n        return true\n    }\n    \n    if minimap[i][j] == 1 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc spiral(_ n: Int) -> [[Int]] {\n    if n == 0 {\n        return [[Int]]()\n    } else if n == 1 {\n        return [[1]]\n    } else if n == 2 {\n        return [[1, 1], [0, 1]]\n    }\n    \n    var spiral = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)\n    var i = 0, j = 0\n    var di = 0, dj = 1\n    var rotated = 0\n    \n    while rotated < 2 {\n        spiral[i][j] = 1\n        if canMove(minimap: spiral, i: i, j: j, di: di, dj: dj) {\n            i += di\n            j += dj\n            rotated = 0\n        } else {\n            (di, dj) = (dj, -di)\n            rotated +=  1\n        }\n    }\n    (di, dj) = (-dj, di)\n    if spiral[i + di][j + dj] == 1 {\n        spiral[i][j] = 0\n    }\n    \n    return spiral\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340057,"user_id":null,"body":"func spiral(_ n:Int) -> [[Int]] {\n    \/\/appending mass with preload frame of \"1\"\n    var result = Array(repeating: Array(repeating: 0, count: n), count: n)\n    result[0] = Array(repeating: 1, count: n)\n    result[n-1] = Array(repeating: 1, count: n)\n    for i in 1..<n-1{result[i][n-1] = 1}\n    var endOfSpiral = false\n    var countOfSteps = n\n    var i = n-2, j = 0, summ = 0\n    \/\/out if sum is not update\n    while  result.flatMap{$0}.reduce(0,+)>summ{\n        summ = result.flatMap{$0}.reduce(0,+)\n            \/\/to the top\n        while (result[i-2][j] != 1) && (result[i-1][j+1] != 1) {\n            result[i][j] = 1\n            i-=1\n        } \n        \/\/ to the right\n        while (result[i][j+2] != 1) && (result[i+1][j+1] != 1) {\n            result[i][j] = 1\n            j+=1\n        }\n        \/\/to the down\n        while (result[i+2][j] != 1) && (result[i+1][j-1] != 1) {\n            result[i][j] = 1\n            i+=1\n        }\n        \/\/to the left\n        while (result[i][j-2] != 1) && (result[i-1][j-1] != 1) {\n            result[i][j] = 1\n            j-=1\n        }\n        if result[i-1][j] + result[i+1][j] + result[i][j-1] + result[i][j+1] == 1 {\n            result[i][j] = 1\n        }\n        \/\/for i in result {print(i)}\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"538835ae443aae6e03000547":[{"id":340058,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n\treturn { return $0 + n }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340059,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n    return { n + $0 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340060,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) {\n    { n + $0 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340061,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n  func a(_ b: Int) -> Int { return n + b }\n  return a(_:)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340062,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) {\n    return { a in\n        (a + n)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340063,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n  { $0 + n }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340064,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n  { num in n+num }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340065,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n  func hola (number : Int) -> Int {\n    return n + number\n  }\n  return hola\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340066,"user_id":null,"body":"\ntypealias Myfunc = ((Int) -> Int)\nfunc add(_ n: Int) -> Myfunc { \n  return { b in n + b }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340067,"user_id":null,"body":"func add(_ n: Int) -> ((Int) -> Int) { \n    return { return n + $0 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5390bac347d09b7da40006f6":[{"id":340068,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n        return capitalized\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340069,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n        return self.capitalized\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340070,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n      capitalized\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340071,"user_id":null,"body":" import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n        var temp: Character = \" \" \n        var output = \"\"\n                        \n        func changeToCapital(_ char: Character) -> Character {\n            switch char {\n            case \"a\", \"A\": return \"A\"\n            case \"b\", \"B\": return \"B\"\n            case \"c\", \"C\": return \"C\"\n            case \"d\", \"D\": return \"D\"\n            case \"e\", \"E\": return \"E\"\n            case \"f\", \"F\": return \"F\"\n            case \"g\", \"G\": return \"G\"\n            case \"h\", \"H\": return \"H\"\n            case \"i\", \"I\": return \"I\"\n            case \"j\", \"J\": return \"J\"\n            case \"k\", \"K\": return \"K\"\n            case \"l\", \"L\": return \"L\"\n            case \"m\", \"M\": return \"M\"\n            case \"n\", \"N\": return \"N\"\n            case \"o\", \"O\": return \"O\"\n            case \"p\", \"P\": return \"P\"\n            case \"q\", \"Q\": return \"Q\"\n            case \"r\", \"R\": return \"R\"\n            case \"s\", \"S\": return \"S\"\n            case \"t\", \"T\": return \"T\"\n            case \"u\", \"U\": return \"U\"\n            case \"v\", \"V\": return \"V\"\n            case \"w\", \"W\": return \"W\"\n            case \"x\", \"X\": return \"X\"\n            case \"y\", \"Y\": return \"Y\"\n            case \"z\", \"Z\": return \"Z\"\n            default: return char\n            }\n        }\n        \n        for i in 0..<self.characters.count {\n            if i == 0 {\n                if self[self.startIndex] != \" \" {\n                    temp = changeToCapital(self[self.startIndex])\n                } else {\n                    temp = self[self.startIndex]\n                }\n            } else {\n                if (self[self.index(self.startIndex, offsetBy: i)] != \" \")&&(self[self.index(self.startIndex, offsetBy: i-1)] == \" \") {\n                    temp = changeToCapital(self[self.index(self.startIndex, offsetBy: i)])\n                } else {\n                    temp = self[self.index(self.startIndex, offsetBy: i)]\n                }\n            }\n            output += String(temp)\n        }\n       \n        return output\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340072,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n      return components(separatedBy: CharacterSet.whitespacesAndNewlines).map { $0.capitalized }.joined(separator: \" \")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340073,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n        var strArr = self.split(separator: Character(\" \"))\n        for i in 0..<strArr.count {\n            strArr[i] = strArr[i].prefix(1).capitalized + strArr[i].dropFirst(1)\n        }\n        return strArr.joined(separator: \" \")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340074,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n      return mapToStringArray().map{ $0.capitalized}.joined(separator:\" \")\n    }\n    \n    func mapToStringArray() -> [String] {\n      return split(separator: \" \").map{String($0)}\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340075,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n        var result = \"\"\n        var arr = self.map{$0.lowercased()}\n\n        var i = 0\n        result += String(arr[i]).uppercased()\n        i += 1\n        while i < arr.count {\n            print(arr[i])\n            \n            result += arr[i]\n            if arr[i] == \" \" {\n                result += String(arr[i + 1]).uppercased()\n                i += 1\n            }\n            i += 1\n        }\n        return result\n    }\n}\n\n\/\/             \"most trees are blue\"","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340076,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n      var to_jaden_case: String {self.capitalized}\n      return to_jaden_case\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340077,"user_id":null,"body":"import Foundation\n\nextension String {\n    func to_jaden_case() -> String {\n        return  self.split(separator: \" \", omittingEmptySubsequences: false).map { $0.prefix(1).capitalized + $0.dropFirst()\n        }.joined(separator: \" \")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"53da3dbb4a5168369a0000fe":[{"id":340078,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n  return number % 2 == 0 ? \"Even\" : \"Odd\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340079,"user_id":null,"body":"func even_or_odd(_ n: Int) -> String {\n    return n.isMultiple(of: 2) ? \"Even\" : \"Odd\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340080,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n    return number.isEven()\n}\n\nextension Int {\n    \n    func isEven() -> String {\n        return self % 2 == 0 ? \"Even\" : \"Odd\"\n    }\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340081,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n  if (number % 2 == 0) {\n    return \"Even\"\n  } else {\n    return \"Odd\"\n  }\n} \n\nlet someNumber = even_or_odd(4)","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340082,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n   number % 2 == 0 ? \"Even\" : \"Odd\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340083,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n  let mask: Int = 1\n  let lastBit = number & mask\n  \n  return lastBit != 1 ? \"Even\": \"Odd\" \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340084,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n  if number.isMultiple(of: 2) {\n    return \"Even\"\n  } else {\n    return \"Odd\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340085,"user_id":null,"body":"func even_or_odd(_ number: Int) -> String {\n    let even = \"Even\"\n    let odd = \"Odd\"\n\n    return number.isMultiple(of: 2) ? even : odd\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340086,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n  let result = number % 2 == 0 ? \"Even\" : \"Odd\"\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340087,"user_id":null,"body":"func even_or_odd(_ number:Int) -> String {\n  return [\"Even\", \"Odd\"][abs(number % 2)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"53f40dff5f9d31b813000774":[{"id":340088,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n    var prev = [String]()\n    var secret = Array(Set(triplets.flatMap{ $0 }))\n    \n    while !prev.elementsEqual(secret) {\n        let duplicateSecret = secret\n        prev = duplicateSecret\n        \n        for triplet in triplets {\n            let charTuples = [\n                ( triplet[0], triplet[1] ),\n                ( triplet[1], triplet[2] )\n            ]\n            \n            for tuple in charTuples {\n                let aIndex = secret.firstIndex(of: tuple.0)!\n                let bIndex = secret.firstIndex(of: tuple.1)!\n                \n                if (aIndex > bIndex) {\n                    secret.insert(tuple.0, at: bIndex)\n                    secret.remove(at: aIndex + 1)\n                }\n            }\n        }\n    }\n    \n    return secret.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340089,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n    var r: [[String]] = []\n    for (index, value) in triplets.enumerated() {\n        if index == 0 {\n            r.append(value)\n        } else {\n            if !(r[index-1]\n                .contains(where: { s in value.contains(s) })) {\n                var ins = r[index-1]\n                ins.insert(contentsOf: value, at: 0)\n                r.append(ins)\n            } else {\n                var l = r.last!\n                for (i, v) in value.enumerated() {\n                    \/\/ do insert\n                    if !l.contains(v) {\n                        if i == 0 {\n                            l.insert(v, at: 0)\n                        } else {\n                            if let iBefore = l.firstIndex(of: value[i-1]) {\n                                l.insert(v, at: iBefore+1)\n                            }\n                        }\n                    \/\/ do swap\n                    } else {\n                        if i != 0 {\n                            let idxCurrent = l.firstIndex(of: v)!\n                            let idxBefore = l.firstIndex(of: value[i-1])!\n                            if idxCurrent < idxBefore {\n                                l.remove(at: idxCurrent)\n                                l.insert(v, at: idxBefore)\n                            }\n                        }\n                    }\n                }\n                r.append(l)\n            }\n        }\n    }\n    return r.last!.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340090,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n    let reduced = triplets.reduce([], +)\n    let set = NSOrderedSet(array: reduced)\n    let letters = Array(set) as? Array<String>\n    let chunks = triplets.map { $0.joined() }\n    \n    guard var uniqueLetters = letters?.joined() else { return \"\" }\n    var counter = 0\n    \n    while counter < chunks.count {\n        for triplet in chunks where !uniqueLetters.contains(triplet) {\n            sortTheWordWith(triplet: triplet, word: &uniqueLetters)\n            counter += 1\n        }\n    }\n    \n    return uniqueLetters\n}\n\nprivate func sortTheWordWith(triplet: String, word: inout String) {\n    guard let first = triplet.first, let snd = triplet.dropFirst().first, let third = triplet.last else { return }\n    \n    guard let i1 = word.firstIndex(of: first), let i2 = word.firstIndex(of: snd), let i3 = word.firstIndex(of: third) else { return }\n    \n    if i1 > i2 {\n        modifyWord(&word, char: first, indexToRemove: i1, indexToAdd: i2)\n    }\n    \n    if i2 > i3 {\n        modifyWord(&word, char: third, indexToRemove: i3, indexToAdd: i2)\n    }\n}\n\nprivate func modifyWord(_ word: inout String, char: String.Element, indexToRemove: String.Index, indexToAdd: String.Index) {\n    word.remove(at: indexToRemove)\n    word.insert(char, at: indexToAdd)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340091,"user_id":null,"body":"typealias Graph = [String:Set<String>]\ntypealias Node = String\n\nfunc buildGraph(from triplets: [[String]]) -> Graph {\n  var graph: Graph = [:]\n  for triplet in triplets {\n    for i in 0..<3 {\n      graph[triplet[i], default: []].formUnion(Set(triplet[(i+1)...]))\n    }\n  }\n  return graph\n}\n\nfunc findOrigin(of graph: Graph) -> Node? {\n  let incomingEdgeCounts: [(Node, Int)] = graph.map { key, _ in\n    (key, graph.mapValues { $0.contains(key) ? 1 : 0 }.values.reduce(0, +))\n  }\n  return incomingEdgeCounts.min(by: { $0.1 < $1.1 })?.0\n}\n\nfunc toposort(_ graph: [String:Set<String>]) -> [String] {\n  var output = [String]()\n  var visited = Set<String>()\n  guard let origin = findOrigin(of: graph) else { fatalError() }\n  \n  func traverse(_ node: Node) {\n    for dest in graph[node]! {\n      guard visited.insert(dest).inserted else { continue }\n      traverse(dest)\n    }\n    output.append(node)\n  }\n  \n  traverse(origin)\n  return Array(output.reversed())\n}\n\nfunc recover_secret(from triplets: [[String]]) -> String {\n  let graph = buildGraph(from: triplets)\n  return toposort(graph).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340092,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n  var letters = Array(Set(triplets.flatMap{$0}))\n  var flag = true\n  while flag {\n    flag = false\n    for t in triplets {\n      let index1 = letters.firstIndex(of: t[0])!\n      let index2 = letters.firstIndex(of: t[1])!\n      let index3 = letters.firstIndex(of: t[2])!\n      if index1 > index2 {\n        letters.swapAt(index1, index2)\n        flag = true\n        if index2 > index3 {\n          letters.swapAt(index2, index3)\n          flag = true\n        }\n        continue\n      }\n      if index2 > index3 {\n        letters.swapAt(index2, index3)\n        flag = true\n      }\n    }\n  }\n  return letters.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340093,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n    let formatedInput = triplets.map { item in\n        return item.enumerated().map { (index, item) in\n            return  [\"index\": index, \"value\" : item]\n        }\n    }\n    var flatmapInput = formatedInput.flatMap { $0 }\n    var secretString = \"\"\n    while ( flatmapInput.count > 0 ) {\n        var dictValue:[String:Int] = [:]\n        for item in flatmapInput {\n            if let keyValue = item[\"value\"] as? String {\n                dictValue[keyValue] = (dictValue[keyValue] ?? 0) + (item[\"index\"] as! Int)\n            }\n        }\n        let candidate = dictValue.first { (key: String, value: Int) in\n            value == 0\n        }\n        secretString = \"\\(secretString)\\(candidate?.key ?? \"\")\"\n        for index in 0..<flatmapInput.count {\n            if index > 0 {\n                if (flatmapInput[index-1][\"value\"] as? String) ?? \"\" == candidate!.key {\n                    flatmapInput[index][\"index\"] = 0\n                }\n            }\n        }\n        flatmapInput.removeAll { dict in\n            dict[\"value\"] as? String ?? \"\" == candidate!.key\n        }\n    }\n    print(secretString)\n    return secretString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340094,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n  var word = [String:Int]()\n  var going = true\n  \n  while going {\n    going = false\n    for triplet in triplets {\n      let a = word[triplet[0]] ?? 0\n      var b = word[triplet[1]] ?? a + 1\n      if b < a + 1 { b = a + 1 }\n      var c = word[triplet[2]] ?? b + 1\n      if c < b + 1 { c = b + 1 }\n      going = going || word[triplet[0]] != a || word[triplet[1]] != b || word[triplet[2]] != c\n      word[triplet[0]] = a\n      word[triplet[1]] = b\n      word[triplet[2]] = c\n    }\n  }\n  var arr = [String](repeating: \"\", count: word.keys.count)\n  for (key, value) in word {\n    arr[value] = key\n  }  \n  return arr.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340095,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n  var secret = triplets[0].joined()\n  for i in 1..<triplets.count {\n    var m = secret.startIndex\n    for j in 0..<3 {\n      let c = triplets[i][j].first!\n      if let idx = secret.firstIndex(of: c) {\n        if (idx < m) {\n          \/\/Insert before remove to avoid decrementing the insert index (m)\n          secret.insert(c, at: m)\n          secret.remove(at: idx)\n        } else {\n          m = idx\n        }\n      } else {\n        secret.insert(c, at: m)\n      }\n      if m < secret.endIndex {\n        m = secret.index(m, offsetBy: 1)           \n      }\n    }\n  }\n  return secret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340096,"user_id":null,"body":"import Foundation\n\nfunc reloadData(of data: inout [String : [String]], by char: String) -> Void {\n    for c in data {\n        if data[c.key]!.contains(char) {\n            if data[c.key]!.count != 1 { data[c.key]!.remove(at: data[c.key]!.index(of: char)!) }\n\n        }\n    }\n    data.remove(at: data.index(forKey: char)!)\n}\n\nfunc recover_secret(from triplets: [[String]]) -> String {\n    var cases: [String : [String]] = [:], lastChar: String, jail = [String](), res: String = \"\", jailedChars = [String]()\n    for triplet in triplets {\n        if !jail.contains(triplet[0]) { jail.append(triplet[0]) }\n        if !jail.contains(triplet[1]) { jail.append(triplet[1]) }\n        if !jail.contains(triplet[2]) { jail.append(triplet[2]) }\n        if let tmp = cases[triplet[1]] {\n            cases[triplet[1]]!.append(triplet[0])\n            cases[triplet[1]] = Array(Set(cases[triplet[1]]!))\n        } else {\n            cases[triplet[1]] = [triplet[0]]\n        }\n        if let tmp = cases[triplet[2]] {\n            cases[triplet[2]]!.append(triplet[0])\n            cases[triplet[2]]!.append(triplet[1])\n            cases[triplet[2]] = Array(Set(cases[triplet[2]]!))\n        } else {\n            cases[triplet[2]] = [triplet[0], triplet[1]]\n        }\n    }\n\n    lastChar = jail.filter{!cases.keys.contains($0)}[0]\n    res = lastChar\n    jailedChars.append(lastChar)\n    while !cases.isEmpty {\n        var was: Bool = false\n        for (nextChar, _) in cases {\n            if cases[nextChar]?.count == 1 && cases[nextChar]![0] == lastChar {\n\n                res += nextChar\n                lastChar = nextChar\n                was = true\n                jailedChars.append(lastChar)\n                reloadData(of: &cases, by: lastChar)\n                break\n            }\n        }\n        guard was else {\n            let reserveChar: String = cases.filter({$0.value.count == 1 && jailedChars.contains($0.value[0])})[0].key \/\/ warning\n            res += reserveChar\n            lastChar = reserveChar\n            reloadData(of: &cases, by: lastChar)\n            continue\n        }\n\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340097,"user_id":null,"body":"func recover_secret(from triplets: [[String]]) -> String {\n  var secret = Array(Set(triplets.reduce([], +)))\n  var swapped : Bool\n  repeat {\n    swapped = false\n    for rule in triplets {\n      var l = secret.firstIndex(where: {$0 == rule[0]})!\n      var m = secret.firstIndex(where: {$0 == rule[1]})!\n      if (l > m) {\n        secret.swapAt(l, m)\n        (l, m) = (m, l)\n        swapped = true\n      }\n      var r = secret.firstIndex(where: {$0 == rule[2]})!\n      if (r < m) {\n        secret.swapAt(r, m)\n        swapped = true\n      }\n    }\n  } while (swapped)\n  return secret.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5412509bd436bd33920011bc":[{"id":340098,"user_id":1462,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n  string.enumerated().map { $0 < string.count - 4 ? \"#\" : \"\\($1)\"}.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340099,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n  let last4Index = string.count - 4\n  let maskedString = String(string.enumerated().map { (index, element) -> Character in\n    return index < last4Index ? \"#\" : element\n  })\n  return maskedString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340100,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n    var finalStr = \"\"\n    for (i, el) in string.enumerated() {\n        if i >= string.count - 4 {\n            finalStr.append(el)\n        } else {\n            finalStr.append(\"#\")\n        }\n    }\n    return finalStr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340101,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n  \/\/ TODO Your code goes here!\n  if string.count < 5 {\n    return string\n  }  else {\n    return String(repeating: \"#\", count: string.count - 4) + String(string.suffix(4))\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340102,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n  let lastFour = string.suffix(4)\n  return String(repeating: \"#\", count: max(0, string.count - 4)).appending(lastFour)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340103,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string: String) -> String {\n    guard string.count > 4 else { return string }\n    var str = \"\", i = 0\n    while i < string.count - 4 {\n        str += repeatElement(\"#\", count: i).repeatedValue\n        i = i + 1\n    }\n    return str + string.suffix(4)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340104,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ tomaskify: String) -> String {\n  guard tomaskify.count > 4 else { return tomaskify }\n  var maskified = \"\"\n  \n  for _ in 0..<tomaskify.count - 4 {\n    maskified.append(\"#\")\n  }\n  \n  maskified.append(String(tomaskify.suffix(4)))\n  \n  return maskified\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340105,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n  \n    if string.count <= 4 {\n        return string\n    }\n    \n    let index = string.count - 4\n    var array = Array(string)\n    \n    for i in 0..<index {\n        array[i] = \"#\"\n    }\n\n    return String(array)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340106,"user_id":null,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n  guard string.count > 4 else { return string }\n  \n  return String(repeating: \"#\", count: string.count - 4) + string.suffix(4)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340107,"user_id":2387,"body":"import Foundation\n\nfunc maskify(_ string:String) -> String {\n    string.enumerated().map { \n      $0 + 4 >= string.count ? String($1) : \"#\" \n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"541c8630095125aba6000c00":[{"id":340108,"user_id":null,"body":"func digital_root(of number: Int) -> Int {\n    return (1 + (number - 1) % 9)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340109,"user_id":null,"body":"func digital_root(of number: Int) -> Int {\n    let digit = String(number).characters.flatMap { Int(String($0)) }.reduce(0, +)\n    return digit > 9 ? digital_root(of: digit) : digit\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340110,"user_id":null,"body":"func digital_root(of number: Int) -> Int {\n  if number < 10 {\n    return number\n  } else {\n    return digital_root(of: number % 10 + digital_root(of: Int(number \/ 10)))\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340111,"user_id":527,"body":"func digital_root(of number: Int) -> Int {\n    return (number - 1) % 9 + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340112,"user_id":null,"body":"\nextension Int {\n  var digits: [Int] {\n    return Array(String(self)).compactMap{ Int(String($0))}\n  }\n}\n\nfunc digital_root(of number: Int) -> Int {\n  let digits = number.digits\n  let sum = digits.reduce(0, +)\n  return  (sum < 10) ? sum : digital_root(of: sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340113,"user_id":null,"body":"func sumOfDigits(input: Int) -> Int {\n    return String(input).characters.map({ Int(String($0))! }).reduce(0, +)\n}\n\nfunc digital_root(of number: Int) -> Int {\n    var result = sumOfDigits(input: number)\n    while result > 10 {\n        result = sumOfDigits(input: result)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340114,"user_id":null,"body":"func digital_root(of number: Int) -> Int {\n  let sum = String(number).compactMap { $0.wholeNumberValue }.reduce(0, +)\n  return sum \/ 10 == 0 ? sum : digital_root(of: sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340115,"user_id":null,"body":"func digital_root(of number: Int) -> Int {\n  if number < 10 {\n    return number\n  }\n  \n  let remainder = number % 10\n  return digital_root(of: remainder + digital_root(of: (number-remainder)\/10))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340116,"user_id":492,"body":"func digital_root(of n: Int) -> Int {\n  return ((n - 1) % 9) + 1;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340117,"user_id":null,"body":"func digital_root(of number: Int) -> Int {\n  let number = String(number).compactMap{$0.wholeNumberValue}\n  return number.count > 1 ? digital_root(of: number.reduce(0, +)) : number.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"542f0c36d002f8cd8a0005e5":[{"id":340118,"user_id":null,"body":"func lastChair(_ n: Int) -> Int {\n  return n - 1;\n\/\/   var chairs = Array(repeating: 0, count: n)\n\/\/   chairs[0] = 1;\n\/\/   chairs[chairs.count - 1] = 2;\n\/\/   var optimal = chairs.count \/ 2 - 1;\n\/\/ \/\/   print(n)\n\/\/   for i in 2..<chairs.count {\n\/\/     chairs[optimal] = i + 1;\n\/\/ \/\/     print(chairs);\n\/\/     var maxl = 0;\n\/\/     var maxr = 0;\n\/\/     var l = 0;\n\/\/     var r = 0;\n\/\/     if i == chairs.count - 1 {break}\n\/\/     while r < chairs.count {\n      \n\/\/       if chairs[l] == 0 && chairs[r] == 0 {\n\/\/         if r - l > maxr - maxl || maxr == 0{\n\/\/           maxl = l;\n\/\/           maxr = r;\n\/\/         }\n\/\/         r += 1;\n\/\/       }else if chairs[r] != 0 {\n\/\/         l = r + 1;\n\/\/         r = l \n\/\/       }else if chairs[r] == 0 {\n\/\/         l = r;\n\/\/         r = l\n\/\/       }\n      \n\/\/ \/\/       print(\"maxl:\\(maxl) & maxr:\\(maxr), l:\\(l) & r:\\(r)\")\n\/\/     }\n\/\/     optimal = (maxl + maxr) \/ 2\n\/\/ \/\/     print(optimal)\n\/\/   }\n\/\/   return optimal + 1;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340119,"user_id":null,"body":"func lastChair(_ n: Int) -> Int {\n  \/\/ user code ..\n  return n - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340120,"user_id":null,"body":"func lastChair(_ n: Int) -> Int {\n  \n  var chairs = n\n\n  chairs -= 1\n  \n  return chairs\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340121,"user_id":null,"body":"func lastChair(_ n: Int) -> Int {\n  var s = Array(repeating: 0, count: n)\n  \n  var i = 0\n  while i < n {\n    i += 1\n    \n    switch i {\n    case 1: s[0] = 1\n    case 2: s[n - 1] = 2\n      \n    case n:\n      var j = 0\n      while true {\n        if s[j] == 0 { return j + 1 }\n        j += 1\n      }\n      \n    default:\n      var d = 0\n      var dm = 0\n      var di = 0\n      \n      var j = 0\n      while j < n - 1 {\n        j += 1\n        \n        if s[j] == 0 {\n          d += 1\n        }\n        else {\n          if d > dm {\n            dm = d\n            di = j - d - 1\n          }\n          d = 0\n        }\n      }\n      \n      s[di + dm \/ 2 + dm % 2] = i\n    }\n  }\n  \n  return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340122,"user_id":null,"body":"func lastChair(_ n: Int) -> Int {\n  if n == 2 {\n    return n\n  } else if n == 1 {\n    return n\n  } else {\n    return n - 1\n  }\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340123,"user_id":527,"body":"func lastChair(_ n: Int) -> Int {\n  n - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340124,"user_id":53,"body":"func lastChair(_ n: Int) -> Int {\n  return n - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"545afd0761aa4c3055001386":[{"id":340125,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n  return Array(arr.prefix(n))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340126,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n    guard n > 0 else { return [] }\n  return Array(arr.prefix(n))\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340127,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n     if arr.count == 0 {\n        return []\n    }\n    if arr.count < n {\n        return arr\n    }\n  \n    var newArr: [Int] = []\n    for i in 0..<n {\n        newArr.append(arr[i])\n    }\n    return newArr\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340128,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n  return arr.count > n ? Array(arr[0..<n]) : arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340129,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n  var save = arr.count < n ? arr.count : n \nreturn arr.isEmpty ? arr : Array(arr[0..<save])\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340130,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n    guard arr.count != 0 else {\n        return []\n    }\n    guard arr.count > n else {\n        return arr\n    }\n            \n    if n > 0 {\n        return Array(arr[0...n-1])\n    } else {\n        return []\n    }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340131,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n  if arr.count >= n {\n    return Array<Int>(arr[..<n])\n  }\n  else {\n    return arr\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340132,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\nreturn [Int](arr.prefix(n))\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340133,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n    var newArray: [Int] = []\n    \n    for int in arr {\n        guard newArray.count != n else { break }\n        newArray.append(int)\n    }\n    return newArray\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340134,"user_id":null,"body":"func take(_ arr: [Int], _ n: Int) -> [Int] {\n  guard arr.count > n else { return arr }\n  return arr.dropLast(arr.count - n)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5467e4d82edf8bbf40000155":[{"id":340135,"user_id":1433,"body":"func descending_order(of number: Int) -> Int {\n  return Int(String(\"\\(number)\".characters.sorted(by: >)))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340136,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n    let sortedCharacters = String(number).characters.sorted { $0 > $1 }\n    return Int(String(sortedCharacters))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340137,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n  let digits = sequence(state: number) { (number: inout Int) -> Int? in\n    defer { number \/= 10 }\n    return number > 0 ? number % 10 : nil\n  }\n  \n  return digits.sorted(by: >).reduce(0) { 10 * $0 + $1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340138,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n    return Int(String(number.description.characters.sorted{$0 > $1}))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340139,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n    return Int(String(String(number).characters.sorted(by: >)))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340140,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n  return Int(String(number.description.sorted(by: >)))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340141,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n    let stringNumber = String(number)\n    \n    var digits = stringNumber.compactMap{ $0.wholeNumberValue }\n    digits.sort(by: >)\n\n    let intValue = digits.reduce(0, { $0*10 + $1 })\n\n    return(intValue)\n\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340142,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n    let numberAsString = String(number)\n    let orderedNumbers = String(numberAsString.sorted().reversed())\n    \n    return Int(orderedNumbers)!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340143,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n  String(number)\n      .compactMap { Int(String($0))}\n      .sorted(by: >)\n      .reduce(0) { ($0 * 10) + $1}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340144,"user_id":null,"body":"func descending_order(of number: Int) -> Int {\n  let stringNumber = String(number)\n  let digits = stringNumber.compactMap { $0.wholeNumberValue }\n  let digitsSorted = digits.sorted { $0 > $1}\n  return digitsSorted.reduce(0, { $0 * 10 + $1})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"546ba103f0cf8f7982000df4":[{"id":340145,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n    \n    var transform: (Int, Int) -> Int {\n        switch self {\n        case .ADD:\n            return (+)\n        case .SUBTRACT:\n            return (-)\n        case .MULTIPLY:\n            return (*) \n        }\n    }\n}\n\nfunc calculate(_ a: String, _ b: String, _ op: Operator) -> String {\n    let n1 = Int(a, radix: 2)!\n    let n2 = Int(b, radix: 2)!\n    let result = op.transform(n1, n2)\n    \n    return String(result, radix: 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340146,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a:String, _ b:String, _ op:Operator) -> String {\n  let (n1, n2) = (Int(a, radix: 2) ?? 0, Int(b, radix: 2) ?? 0)\n  switch op {\n    case .ADD: return String(n1 + n2, radix: 2)\n    case .SUBTRACT: return String(n1 - n2, radix: 2)\n    case .MULTIPLY: return String(n1 * n2, radix: 2)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340147,"user_id":null,"body":"enum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a: String, _ b: String, _ op: Operator) -> String {\n    let ia = Int(a, radix: 2)!\n    let ib = Int(b, radix: 2)!\n    \n    let result: Int\n    \n    switch op {\n    case .ADD:\n        result = ia + ib\n    case .SUBTRACT:\n        result = ia - ib\n    case .MULTIPLY:\n        result = ia * ib\n    }\n    \n    return String(result, radix: 2)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340148,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a:String, _ b:String, _ op:Operator) -> String {\n\tlet nA = Int(a, radix: 2) ?? 0\n\tlet nB = Int(b, radix: 2) ?? 0\n\tvar res: Int = 0\n\tswitch op {\n\tcase .ADD: res = nA + nB\n\tcase .SUBTRACT: res = nA - nB\n\tcase .MULTIPLY: res = nA * nB\n\t}\n\treturn String(res, radix: 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340149,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n    \n    var transform: (Int, Int) -> Int {\n        switch self {\n        case .ADD:\n            return (+)\n        case .SUBTRACT:\n            return (-)\n        case .MULTIPLY:\n            return (*)\n        }\n    }\n}\n\nfunc calculate(_ a: String, _ b: String, _ op: Operator) -> String {\n    let nOne = Int(a, radix: 2)!\n    let nTwo = Int(b, radix: 2)!\n    let res = op.transform(nOne, nTwo)\n    \n    return String(res, radix: 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340150,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a: String, _ b: String, _ op: Operator) -> String {\n    let a = Int(a, radix: 2)!\n    let b = Int(b, radix: 2)!\n\n    switch op {\n    case .ADD:\n        return String(a + b, radix: 2)\n    case .SUBTRACT:\n        return String(a - b, radix: 2)\n    case .MULTIPLY:\n        return String(a * b, radix: 2)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340151,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a:String, _ b:String, _ op:Operator) -> String {\n  \n    let binA = Int(a, radix: 2)\n    let binB = Int(b, radix: 2)\n    \n    if op == .ADD {\n        return String(binA! + binB!, radix: 2)\n    } else if op == .SUBTRACT {\n        return String(binA! - binB!, radix: 2)\n    } else if op == .MULTIPLY {\n        return String(binA! * binB!, radix: 2)\n    }\n    \n    return \"I love my Wife :)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340152,"user_id":null,"body":"enum Operator\n{\n    case ADD, MULTIPLY, SUBTRACT\n}\n\nlet f: [Operator : (Int, Int) -> Int] = [\n    .ADD      : (+),\n    .MULTIPLY : (*),\n    .SUBTRACT : (-)\n]\n\nfunc calculate(_ a: String, _ b: String, _ op: Operator) -> String\n{\n    return String(f[op, default: (+)](Int(a, radix: 2) ?? 0, Int(b, radix:2) ?? 0), radix: 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340153,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a:String, _ b:String, _ op:Operator) -> String {\n    switch op {\n    case .ADD:\n        return String(Int(a, radix: 2)!+Int(b, radix: 2)!, radix: 2)\n    case .SUBTRACT:\n        return String(Int(a, radix: 2)!-Int(b, radix: 2)!, radix: 2)\n    case .MULTIPLY:\n        return String(Int(a, radix: 2)!*Int(b, radix: 2)!, radix: 2)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340154,"user_id":null,"body":"import Foundation\n\nenum Operator {\n    case ADD, SUBTRACT, MULTIPLY\n}\n\nfunc calculate(_ a:String, _ b:String, _ op:Operator) -> String {\n    guard !a.isEmpty, !b.isEmpty, let a = Int(a, radix: 2), let b = Int(b, radix: 2) else { return \"\" }\n    switch op {\n    case .ADD:\n        return String((a + b), radix: 2)\n    case .MULTIPLY:\n        return String((a * b), radix: 2)\n    case .SUBTRACT:\n        return String((a - b), radix: 2)\n    }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"546e2562b03326a88e000020":[{"id":340155,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n    Int(String(num).compactMap() {\n        String(Int(pow(Double(String($0))!, 2)))\n    }.joined())!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340156,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n    let numb = \"\\(num)\"\n    var str = \"\"\n    numb.forEach {\n        str += \"\\((Int(\"\\($0)\")! * Int(\"\\($0)\")!))\"\n    }\n    return Int(str)! \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340157,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n  return Int(String(num).compactMap { Int(String($0)) }.compactMap { String($0 * $0) }.joined()) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340158,"user_id":null,"body":"\/*\nWelcome. In this kata, you are asked to square every digit of a number and concatenate them.\n\nFor example, if we run 9119 through the function, 811181 will come out, because 92 is 81 and 12 is 1.\n\nNote: The function accepts an integer and returns an integer\n\n*\/\n\nextension StringProtocol {\n    subscript(offset: Int) -> Character {\n        self[index(startIndex, offsetBy: offset)]\n    }\n}\n\nfunc square_digits(_ num: Int) -> Int {\n    let stringNum = String(num)\n    var result = \"\"\n    for index in 0...(stringNum.count - 1) {\n        let stringValue = stringNum[index]\n        if let intValue = Int(String(stringValue)) {\n            result += String(intValue * intValue)\n        }\n    }\n    \n    if let intResult = Int(result){\n        return intResult\n    }\n    \n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340159,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n    var returnString = \"\"\n\n    for i in String(num) {\n        let value = (Int(String(i)) ?? 1) * (Int(String(i)) ??  1)\n        returnString += String(value)\n    }\n\n    return Int(returnString) ?? 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340160,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n  Int(\"\\(num)\"\n    .compactMap { $0.wholeNumberValue }\n    .map { String($0 * $0) }\n    .joined())!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340161,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n  var a = String(num).compactMap { $0.wholeNumberValue ?? 0 }\n    var b = a.compactMap { \"\\($0 * $0)\" }.joined()\n    return Int(b) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340162,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n  var myNum = num\n  var remainder: Int = 0\n  var runningTotal: String = \"\"\n  var square: Int = 0\n  \n  repeat {\n    remainder = myNum % 10\n    myNum = myNum \/ 10\n    \n    square = remainder * remainder\n    \n    runningTotal = String(square) + runningTotal\n  } while (myNum > 0)\n  \n  return Int(runningTotal)!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340163,"user_id":null,"body":"func square_digits(_ num: Int) -> Int {\n  var out = \"\"\n  var n : Int?\n  for i in String(num){\n    n = Int(String(i))\n    if n != nil {\n        n = n! * n!\n    }\n    out += String(n!)\n  }\n  return Int(out)!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340164,"user_id":null,"body":"\/\/ func square_digits(_ num: Int) -> Int {\n\/\/   return String(num).compactMap(\\.wholeNumberValue).reduce(0) {$0 + Int(pow(Double($1), Double($1)))}\n\/\/ }\n\nfunc square_digits(_ num: Int) -> Int {\n  return Int(String(num).compactMap(\\.wholeNumberValue).map({String(Int(pow(Double($0), 2)))}).joined()) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54b42f9314d9229fd6000d9c":[{"id":340165,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    var dict = [Character: Int](), word = word.lowercased()\n    for letter in word { dict[letter, default: 0] += 1 }\n    return word.map { dict[$0]! > 1 ? \")\" : \"(\" }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340166,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    let word = word.lowercased()\n    var newWord = \"\"\n    for char in word {\n        let count = word.filter { $0 == char }.count\n        newWord += count > 1 ? \")\" : \"(\"\n    }\n    return newWord\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340167,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    return word.map { char in word.filter { $0.lowercased() == char.lowercased() }.count == 1 ? \"(\" : \")\" }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340168,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n  let lowercasedWord = word.lowercased()\n  return String(lowercasedWord.map{lowercasedWord.firstIndex(of: $0) == lowercasedWord.lastIndex(of: $0) ? Character(\"(\") : Character(\")\")})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340169,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    return word.lowercased().map {\n        let char = $0\n        let count = word.lowercased()\n            .filter { $0 == char }\n            .count\n        return count > 1 ? \")\" : \"(\"\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340170,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n  var lcWord = word.lowercased()\n    var seenChars: [Character: [Int]] = [:]\n    \n    for i in 0..<(lcWord.count) {\n        let index = lcWord.index(word.startIndex, offsetBy: i)\n        let char = lcWord[index]\n        if let _ = seenChars[char] {\n            seenChars[char]?.append(i)\n            if seenChars[char]?.count ?? 0 == 2 {\n                lcWord.replaceSubrange(index...index, with: \")\")\n                let fInd = lcWord.index(lcWord.startIndex, offsetBy: seenChars[char]![0])\n                lcWord.replaceSubrange(fInd...fInd, with: \")\")\n            }\n            else if seenChars[char]?.count ?? 0 > 2 {\n                lcWord.replaceSubrange(index...index, with: \")\")\n            }\n        } else {\n            seenChars[char] = [i]\n            lcWord.replaceSubrange(index...index, with: \"(\")\n        }\n    }\n    \n    return lcWord\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340171,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    let wordLowercased = word.lowercased()\n    let charCount = NSCountedSet(array: Array(wordLowercased))\n    return String(wordLowercased.map { charCount.count(for: $0) == 1 ? \"(\" : \")\" })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340172,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    word.map{ ch in\n        word.filter{ $0.lowercased() == ch.lowercased() }.count > 1 ? \")\" : \"(\"\n    }.joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340173,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n    var dict = [Character:Int](), word = word.lowercased()\n    word.forEach{ dict[$0, default: 0] += 1 }\n    return word.map{ dict[$0]! > 1 ? \")\":\"(\" }.joined() \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340174,"user_id":null,"body":"func duplicate_encode(_ word: String) -> String {\n  var result = \"\"\n  let lcWord = word.lowercased()\n  print(\"word: \\(lcWord)\")\n  \n  for c in lcWord {\n    if lcWord.filter({ $0 == c }).count > 1 {\n      result += \")\"\n    } else {\n      result += \"(\"\n    }\n  }\n\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54b724efac3d5402db00065e":[{"id":340175,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n    return (morseCode\n        .trimmingCharacters(in: CharacterSet(charactersIn: \" \"))\n        .components(separatedBy: \"   \")\n        .map({$0.components(separatedBy: \" \")})\n        .map({$0.compactMap({MorseCode[$0]})})\n        .map({$0.joined()}))\n        .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340176,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n    return morseCode\n        .trimmingCharacters(in: .whitespaces)   \/\/ remove spaces before and after the code\n        .components(separatedBy: \"  \")          \/\/ split words\n        .map{ $0.split(separator: \" \")          \/\/ split letters \n            .map{ MorseCode[String($0)] ?? \"\" } \/\/ translate letter \n            .joined()}                          \/\/ join letters into words\n        .joined(separator: \" \")                 \/\/ join words\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340177,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n  morseCode\n    .trimmingCharacters(in: .whitespaces)\n    .components(separatedBy: \"   \")\n    .map({$0.components(separatedBy: \" \")})\n    .map({$0.compactMap{MorseCode[$0]}})\n    .map({$0.joined()})\n    .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340178,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n    let trimmed = morseCode.trimmingCharacters(in: .whitespaces)\n    let words = trimmed.components(separatedBy: \"   \")\n    let letters = words.map { $0.components(separatedBy: \" \") }\n    let parts = letters.joined(separator: [\" \"])\n    return parts.map { MorseCode[$0] ?? \" \" }.joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340179,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n    morseCode\n        .components(separatedBy: \"   \")\n        .map { $0.components(separatedBy: \" \").map {  MorseCode[$0] ?? \"\" }.reduce(\"\", +) }\n        .joined(separator: \" \")\n        .trimmingCharacters(in: .whitespacesAndNewlines)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340180,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n  let words = morseCode\n    .replacingOccurrences(of: \"   \", with: \"+\")\n    .split(separator: \"+\", omittingEmptySubsequences: false)\n  var resultString = \"\"\n  words.forEach { str in\n      str.split(separator: \" \").forEach { s in\n        resultString += MorseCode[s.description, default: \"\"]                       \n      }\n      resultString += \" \"\n  }\n  return resultString.trimmingCharacters(in: .whitespacesAndNewlines)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340181,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n  return morseCode\n        .components(separatedBy: \"   \")\n        .reduce(\"\", { $0 + \" \" + $1\n                    .components(separatedBy: \" \")\n                    .reduce(\"\", { (result, value) -> String in\n                        return result + MorseCode[value, default: \"\"]\n                    })\n        }).trimmingCharacters(in: CharacterSet.whitespaces)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340182,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n  \n  let kek = morseCode.components(separatedBy: \"  \").map{ \/\/iterator\n    $0.components(separatedBy: \" \").map { \n      MorseCode[$0, default: \"\"] \n    }.joined(separator: \"\")\n  }.joined(separator: \" \")\n  \n  \n  return kek.trimmingCharacters(in: .whitespaces) \/\/whitespacesAndNewlines\n    \/\/ \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340183,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n  return morseCode\n    .trimmingCharacters(in: .whitespacesAndNewlines)\n    .components(separatedBy: \"   \")\n        .compactMap {\n            $0\n            .components(separatedBy: \" \")\n            .compactMap { MorseCode[$0] }\n            .joined() }\n        .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340184,"user_id":null,"body":"func decode_morse(_ morseCode: String) -> String {\n  return morseCode.components(separatedBy: \"   \").map({$0.components(separatedBy: \" \")}).map({$0.map({MorseCode[$0]!}).joined()}).joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54b81566cd7f51408300022d":[{"id":340185,"user_id":840,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n  let array = arr.filter { $0.lowercased().range(of: str.lowercased()) != nil }\n  return array.isEmpty ? [\"Empty\"] : array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340186,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n  let results = arr.filter { $0.localizedCaseInsensitiveContains(str) }\n  return results.isEmpty ? [\"Empty\"] : results\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340187,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n    let result = arr.filter{ $0.lowercased().contains(str.lowercased()) }\n    \n    return result.isEmpty ? [\"Empty\"] : result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340188,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n    let results = arr.filter({ $0.lowercased().contains(str.lowercased()) })\n    return results.isEmpty ? [\"Empty\"] : results\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340189,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n    let response = arr.filter { $0.lowercased().contains(str.lowercased()) }\n    return response != [] ? response : [\"Empty\"]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340190,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n  var result: [String] = []\n  for i in arr {\n    if i.lowercased().contains(str.lowercased()) {\n      result.append(i)\n    }\n  }\n  if result.count == 0 {\n    result.append(\"Empty\")\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340191,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n\tvar result = [String]()\n\tfor i in arr {\n\t\tif i.lowercased().contains(str.lowercased()) {\n\t\t\tresult.append(i)\n\t\t}\n\t}\n\t\t\n\tif str == \"\" || arr.isEmpty || str == \"Empty\" || arr == [\"Empty\"] || result == [] {\n\t\tprint(\"Empty\")\n\t\treturn [\"Empty\"]\n\t} else {\n\t\tprint(result)\n\t\treturn result\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340192,"user_id":null,"body":"func wordSearch(_ str: String, _ arr: [String]) -> [String] {\n    let searching = arr.filter({ $0.lowercased().contains(str.lowercased()) })\n    return searching.isEmpty ? [\"Empty\"] : searching\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340193,"user_id":null,"body":"func wordSearch(_ str:String, _ arr:[String]) -> [String] {\n  var result = arr.filter{$0.lowercased().range(of:str.lowercased()) != nil}\n  return result.count == 0 ? [\"Empty\"] : result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340194,"user_id":null,"body":"func wordSearch(_ s: String, _ a: [String]) -> [String]\n{\n    return { $0.isEmpty ? [\"Empty\"] : $0 }(a.filter { $0.localizedCaseInsensitiveContains(s) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54bf1c2cd5b56cc47f0007a1":[{"id":340195,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n    var counts: [String: Int] = [:]\n    for character in Array(s) {\n        counts[character.lowercased(), default: 0] += 1\n    }\n    return counts.values.filter{ $0 > 1 }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340196,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n  return s.lowercased().reduce(into: [:]) { $0[$1, default: 0] += 1 }.filter { $0.1 > 1 }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340197,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n    \/\/ Make lowercased sorted string\n    var duplicates = s.lowercased().sorted()\n    \n    \/\/ Value to hold char from last iteration\n    var lastChar: Character?\n    \n    \/\/ Array of the repeated numbers of characters\n    var repeatedChars = [Character]()\n    \n    \/\/ Parse through the string to find duplicates\n    for character in duplicates {\n        \/\/ Can't do this first time around\n        if lastChar != nil {\n            \/\/ Okay to use bang operator, tested for nil value\n            if lastChar! == character && !repeatedChars.contains(character) {\n                repeatedChars.append(character)\n            }\n        }\n\n        lastChar = character\n    }\n    \n    return repeatedChars.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340198,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n  var counter = 0\n    let chars = Array(s).map({ $0.lowercased() })\n    Dictionary(grouping: chars, by: { $0 }).forEach({ if $0.value.count > 1 { counter += 1 } })\n    return counter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340199,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n    return Dictionary(Array(s.lowercased()).map { ($0, 1) }, uniquingKeysWith: +)\n        .filter { $0.value > 1 }\n        .reduce(0, { result, _ in result + 1 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340200,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n    var dictionary:[Character:Int]=[:]\n    for char in s.lowercased() {\n        if dictionary.keys.contains(char) {\n            dictionary[char]!+=1\n        } else {\n            dictionary[char]=1\n        }\n    }\n    return dictionary.sorted(by: >).filter({$0.value>=2}).count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340201,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n    Dictionary(grouping: s.lowercased(), by: { $0 }).filter { $1.count > 1 }.keys.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340202,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n    s.lowercased().reduce(into: [:]) { result, element in\n        result[element, default: 0] += 1\n    }.filter { $0.value > 1 }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340203,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n        let ar = Array(s.lowercased())\n        var dupeAr:[Character] = []\n        var dupeCount = 0\n        \n        for index in 0..<ar.count\n        {\n            if (ar.filter{$0 == ar[index]}.count > 1 && !dupeAr.contains(ar[index]))\n            {\n                dupeCount += 1\n                dupeAr.append(ar[index])\n            }\n        }\n        \n        return dupeCount\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340204,"user_id":null,"body":"func countDuplicates(_ s:String) -> Int {\n\n   let arr = Array(s.lowercased())\n   let x = Dictionary(grouping: arr, by: {$0})\n    \n    var count = 0\n    \n    for (_, value) in x {\n        if value.count > 1 {\n            count += 1\n        }\n    }\n    \n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54d496788776e49e6b00052f":[{"id":340205,"user_id":null,"body":"func sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    guard let max = l.max() else { return [(Int, Int)]() }\n    guard let min = l.min() else { return [(Int, Int)]() }\n    let maxValue = max < 0 ? min : max\n    let primes = stride(from: 0, through: abs(maxValue), by: 1).filter { prime in prime.isPrime() }\n    let validPrimes = primes.filter { prime in l.map { number in number.isMultiple(of: prime) }.contains(true) }\n\n    return validPrimes.map { prime in\n        (prime, l.filter { $0.isMultiple(of: prime) }.reduce(0, +))\n    }\n}\n\nextension Int {\n    func isPrime() -> Bool {\n        guard self >= 2 else { return false }\n        guard self != 2 else { return true }\n\n        let max = Int(ceil(sqrt(Double(self))))\n\n        for number in 2 ... max {\n            if self % number == 0 {\n                return false\n            }\n        }\n        return true\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340206,"user_id":null,"body":"func primesUntil(_ x: Int) -> [Int] {\n    \/\/ Sieve of Eratosthenes\n    var primes: [Bool] = [Bool](repeating: true, count: x+1)\n\n    for i in 2..<x {\n        if primes[i] {\n            for j in stride(from: i*i, to: x+1, by: i) {\n                primes[j] = false\n            }\n        }\n    }\n\n    primes[0] = false\n    primes[1] = false\n    return primes.enumerated().filter { $0.element }.map { $0.offset }\n}\n\nfunc sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    if l.isEmpty {\n        return []\n    }\n    \n    let xs = l.sorted()\n    let largest = xs.map { abs($0) }.max()!\n    let primes = primesUntil(largest)\n    print(primes)\n    var results = [(Int, Int)]()\n    for p in primes {\n        let hasFactor = xs.filter { $0 % p == 0 }\n        if hasFactor.count > 0 {\n            results.append((p, hasFactor.reduce(0, +)))\n        }\n    }\n\n    print(results)\n    return results\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340207,"user_id":null,"body":"func sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    guard l.count > 0 else { return [] }\n    var checked : Set = [1], result = [(Int, Int)](), maxx = max(abs(l.min()!), abs(l.max()!))\n    \n    for i in 2...maxx {\n        if checked.contains(i) {continue}\n        let filtered = l.filter { $0.isMultiple(of: i)}\n        if filtered.count > 0 {\n            result.append((i, filtered.reduce(0, +)))\n            var toCheck = i;\n            while toCheck <= maxx { checked.insert(toCheck); toCheck += i }\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340208,"user_id":null,"body":"extension Int {\n    func getPrimeFactors() -> Set<Int> {\n        guard self != 0 else { return [] }\n        guard self > 0 else { return (-self).getPrimeFactors() }\n        \n        var number = self\n        var candidate = 2\n        var factors: Set<Int> = []\n        \n        while number > 1 {\n            if number % candidate == 0 {\n                factors.insert(candidate)\n                \n                while number % candidate == 0 {\n                    number \/= candidate\n                }\n            }\n            \n            candidate += 1\n        }\n        \n        return factors\n    }\n}\n\nfunc sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    let factors = l\n        .map { $0.getPrimeFactors() }\n        .reduce(Set(), { $0.union($1) })\n        .sorted()\n    \n    return factors.map { factor in\n        (factor, l.filter { $0 % factor == 0 }.reduce(0, +)) \n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340209,"user_id":null,"body":"class factor {\n    var primeArr : [Int] = []\n    var result : [Int:Int] = [:]\n    func isPrime(_ number: Int) -> Bool {\n        if primeArr.filter( {$0 == number} ).count > 0{\n            return true\n        }\n        if number > 1 && !(2..<number).contains { $0 * $0 <= number && number % $0 == 0 } {\n            primeArr.append(number)\n            return true\n        }\n        return false\n    }\n\n    func getPrime(_ num: Int) {\n        var isSelfPrime = true\n        var i = 1\n        var _num = num\n        if num < 0 {\n            _num = -num\n        }\n        while i*i <= _num{\n            if num % i == 0 {\n                isSelfPrime = false\n                if isPrime(i) {\n                    if result[i] == nil {\n                        result[i] = 0\n                    }\n                    result[i]! += num\n                }\n                if isPrime(_num\/i) && i != _num\/i {\n                    if result[_num\/i] == nil {\n                        result[_num\/i] = 0\n                    }\n                    result[_num\/i]! += num\n                }\n            }\n            i = i + 1\n        }\n        if(isSelfPrime && _num > 1){\n            result[_num] = num\n        }\n    }\n}\n\nfunc sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    let f = factor()\n    var t : [(a:Int, b:Int)] = []\n    for i in l {\n        f.getPrime(i)\n    }\n    for (k, i) in f.result{\n        t.append((k, i))\n    }\n    return t.sorted(by: {$0.a < $1.a})\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340210,"user_id":492,"body":"func sqrt(_ x: Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc primeFactors(_ m: Int) -> [Int] {\n    var result = [Int](), cnt = 0, n = abs(m)\n    for factor in 2...sqrt(n) { \n        while n % factor == 0 {\n            n \/= factor\n            cnt += 1;\n        }\n        if cnt > 0 {cnt = 0; result.append(factor)}\n    }\n    if n != 1 {result.append(n)}\n    return result.sorted()\n \n}\nfunc primeOfList(_ l: [Int]) -> [Int] {\n    var res = [Int]()\n    for n in l {\n        let ll = primeFactors(n)\n        for m in ll {\n            if !res.contains(m) {res.append(m)}\n        }\n    }\n    return res.sorted()\n}\nfunc sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    let a = primeOfList(l)\n    var res = [(Int, Int)]()\n    for n in a {\n        var sum = 0;\n        for k in l {\n            if k % n == 0 {sum += k}\n        }\n        res.append((n, sum))\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340211,"user_id":null,"body":"func sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n  let mx = l.map{abs($0)}.max() ?? -1\n  var res = [(Int, Int)]()\n  if mx < 2 { return res }\n  for p in 2 ... mx {\n    if isPrime(p) {\n      let fs = l.filter{abs($0) % p == 0 }\n      if !fs.isEmpty { res.append((p, fs.reduce(0, +))) }\n    }\n  }  \n  return res\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n  return n == 2 || n == 3 || (n > 3 && !(2...Int(sqrt(Double(n)))).contains{n % $0 == 0})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340212,"user_id":null,"body":"import Foundation\n\nfunc sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    var result: [(Int, Int)] = []\n    \/\/find all divisors for elements of l\n    for element in l{\n        var temp = element\n        if (abs(temp) == 2) || (abs(temp) == 3){\n            if result.firstIndex(where:{$0.0 == abs(temp)}) == nil {\n                result.append((abs(temp), element))\n            } \n            else {\n                result[result.firstIndex(where:{$0.0 == abs(temp)})!].1 += element\n            }\n        }\n        else {\n        for divisor in (2...abs(element)\/2){\n            if (temp % divisor == 0){\n                if result.firstIndex(where:{$0.0 == divisor}) == nil{\n                    result.append((divisor, element))\n                } \n                else {\n                    result[result.firstIndex(where:{$0.0 == divisor})!].1 += element\n                }\n            } \n            while temp % divisor == 0{\n                temp = temp \/ divisor\n            }\n        }\n        }\n        if temp == element {\n            if result.firstIndex(where:{$0.0 == abs(temp)}) == nil{\n                result.append((abs(temp), element))\n            } \n            else {\n                result[result.firstIndex(where:{$0.0 == abs(temp)})!].1 += element\n            }\n        }\n    }\n    return result.sorted(by: {$0.0<$1.0})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340213,"user_id":null,"body":"func sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n    \/\/ find prime factors numbers\n    func primeFactors(n: Int) -> [Int] {\n        var n = n\n        var r: [Int] = []\n        while (n % 2 == 0) {\n            r.append(2)\n            n \/= 2\n        }\n        for idx in stride(from: 3, through: n < 0 ? (n * -1) : n, by: 2) {\n            while (n % idx == 0) {\n                r.append(idx)\n                n \/= idx\n            }\n        }\n        if (n > 2) {\n            r.append(n)\n        }\n        return r\n    }\n    \/\/ a sum of factor\n    func sumOfFactor(n: Int, l: [Int]) -> Int {\n        var s = 0\n        l.forEach { i in\n            if (i % n == 0) {\n                s += i\n            }\n        }\n        return s\n    }\n    \/\/ an array sum by factors\n    var ar: [(Int, Int)] = []\n    l.forEach { l1 in\n        primeFactors(n: l1).forEach { fa in\n            if !(ar.contains(where: { $0.0 == fa }))  {\n                ar.append((fa, sumOfFactor(n: fa, l: l)))\n            }\n        }\n    }\n    return ar.sorted(by: { $0.0 < $1.0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340214,"user_id":null,"body":"func sum_of_divided(_ l: [Int]) -> [(Int, Int)] {\n\n\n    if l.isEmpty{return []}\n\n\n    let dictArrIntLet = Dictionary(uniqueKeysWithValues: zip(Array(0...(l.count - 1)).lazy, l))\n\n\n    var dictArrIntVar = dictArrIntLet, arrayRetuen: [(Int,Int)] = []\n\n\n    func sloz(_ number: Int){\n\n\n        var sum: Int? = nil\n\n\n        _ = dictArrIntVar.map{if $1 % number == 0{\n\n\n            if sum == nil{sum = dictArrIntLet[$0]!}else{sum! += dictArrIntLet[$0]!};\n\n\n            while dictArrIntVar[$0]! % number == 0{dictArrIntVar[$0]! \/= number}};if dictArrIntVar[$0] == 1{dictArrIntVar.removeValue(forKey: $0)} }\n\n\n            \n\n\n        if let sum = sum{arrayRetuen += [(number,sum)]}\n\n\n    }\n\n\n    sloz(2)\n\n\n    for number in 1...(l.map({abs($0)}).max()! \/ 2){\n\n\n        sloz(number * 2 + 1)\n\n\n        print(number * 2 + 1)\n\n\n        if dictArrIntVar.isEmpty{break}\n\n\n        \/\/for + Dispatch\n\n\n    }\n\n\n    return arrayRetuen\n\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54d512e62a5e54c96200019e":[{"id":340215,"user_id":null,"body":"func factors(_ number: Int) -> String {\n  var tmp = number,result = \"\"\n  for p in 2...tmp {\n    var n = 0\n    while tmp%p == 0 {\n      tmp \/= p\n      n += 1\n    }\n    if (n != 0) {\n      result += \"(\" + String(p)\n      result += n > 1 ? \"**\"+String(n):\"\"\n      result += \")\"\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340216,"user_id":null,"body":"func factors(_ number: Int, _ divisor: Int = 2) -> String {\n    guard number > 1 else { return \"\" }\n    \n    var (number, count) = (number, 0)\n    while number % divisor == 0 {\n        count += 1\n        number \/= divisor\n    }\n    \n    return ((count > 0) ? \"(\\(divisor)\\(count > 1 ? \"**\\(count)\" : \"\"))\" : \"\") + factors(number, divisor + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340217,"user_id":492,"body":"func factors(_ number: Int) -> String {\n  var tmp = number, r = \"\"\n  for i in 2...tmp {\n    var k = 0\n    while tmp % i == 0 {\n      tmp \/= i\n      k += 1\n    }\n    if (k != 0) {\n      r += \"(\" + String(i)\n      r += k > 1 ? \"**\"+String(k):\"\"\n      r += \")\"\n    }\n  }\n  return r\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340218,"user_id":null,"body":"import Foundation\n\n\nfunc convertToNearestPrime(_ n: Int) -> Int {\n    var n = n\n    repeat {\n        n += 1\n    } while !isPrime(n)\n    return n\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n == 1 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    var d = 3\n    while d * d <= n && n % d != 0 {\n        d += 2\n    }\n    return d * d > n\n}\n\n\nfunc factors(_ number: Int) -> String {\n    var number = number\n    var d = 2,\n        result = [Int: Int](),\n        formatString = \"\"\n    while !isPrime(number) {\n        if number % d == 0 {\n            number \/= d\n            if result.keys.contains(d) {\n                result[d]! += 1\n            } else {\n                result[d] = 1\n            }\n        } else {\n            d = convertToNearestPrime(d)\n        }\n    }\n    if result.keys.contains(number) {\n        result[number]! += 1\n    } else {\n        result[number] = 1\n    }\n    var value: Int,\n        prefix: String\n    for key in Array(result.keys).sorted() {\n        value = result[key]!\n        if value > 1 {\n            prefix = \"(\\(key)**\\(value))\"\n        } else {\n            prefix = \"(\\(key))\"\n        }\n        formatString += prefix\n    }\n    return formatString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340219,"user_id":null,"body":"func factors(_ number: Int) -> String {\n    var out: [Int: Int] = [:]\n    var n = number\n    for i in 2 ... n {\n        while n % i == 0 {\n            out[i] = (out[i] ?? 0) + 1\n            n \/= i\n        }\n    }\n    return out.sorted { $0.key < $1.key\n    }.map { \"(\\($0.key)\\($0.value > 1 ? \"**\\($0.value)\" : \"\"))\"\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340220,"user_id":null,"body":"func factors(_ number: Int) -> String {\n    var num = number, result = \"\"\n    for k in 2...num {\n        var n = 0\n        while num % k == 0 {\n            num \/= k\n            n += 1\n        }\n        if (n != 0) {\n            result += \"(\" + \"\\(k)\"\n            result += n > 1 ? \"**\"+\"\\(n)\":\"\"\n            result += \")\"\n        }\n    }\n    return result \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340221,"user_id":53,"body":"func factors(_ number: Int) -> String {\n  var (fs, n, i, cnt) = ([String](), number, 2, 0)\n  while (i <= n) {\n    cnt = 0\n    while (n % i == 0) {\n      cnt += 1\n      n \/= i\n    }\n    if (cnt == 1) {\n      fs.append(String(format:\"(%d)\", i))\n    } else if (cnt > 1) {\n      fs.append(String(format:\"(%d**%d)\", i, cnt))\n    }\n    i = i + 1\n  }\n  return fs.joined(separator:\"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340222,"user_id":null,"body":"func factors(_ number: Int) -> String {\n    var results : [Int] = []\n    var ourNumber = number\n    var outputString = \"\"\n    var i = 2\n    var h = 1\n    while i <= ourNumber {\n        if ourNumber % i == 0 {\n            results.append(i)\n            ourNumber = ourNumber\/i\n            i -= 1\n        }\n        i += 1\n    }\n    results.append(0)\n    for j in 1...results.count-1 {\n        \n        if (results[j] == results[j-1]) {\n            h += 1\n        }\n        else {\n            if h != 1 {\n            outputString += \"(\\(results[j-1])**\\(h))\"\n            }\n            else {\n                outputString += \"(\\(results[j-1]))\"\n            }\n            h = 1\n        }\n    }\n    return outputString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340223,"user_id":null,"body":"func factors(_ number: Int) -> String {\n    var num = number\n    var elementsAry:[Int] = []\n    var elementsCount:[Int] = []\n    var pointer = -1\n    var elementAdded = false\n    var factor = 2\n    while num > 1\n    {\n        if factor == 2 || factor % 2 != 0\n        {\n            while num % factor == 0\n            {\n                num \/= factor\n                if elementAdded == false\n                {\n                    elementsAry.append(factor)\n                    elementsCount.append(1)\n                    pointer += 1\n                    elementAdded = true\n                }else if elementAdded == true{\n                    elementsCount[pointer] += 1\n                }\n            }\n            elementAdded = false\n        }\n        factor += 1\n    }\n    func arrayToStr(_ elementsAry: [Int], _ elementsCount: [Int]) -> String{\n        var createStr = \"\"\n        var pointer = 0\n        while pointer <= elementsAry.count-1 && pointer <= elementsCount.count-1{\n            if elementsCount[pointer] == 1 {\n                createStr.append(\"(\\(elementsAry[pointer]))\")\n            }else if elementsCount[pointer] > 1{\n                createStr.append(\"(\\(elementsAry[pointer])**\\(elementsCount[pointer]))\")\n            }\n            pointer += 1\n        }\n        return createStr\n    }\n    return arrayToStr(elementsAry, elementsCount)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340224,"user_id":null,"body":"import Foundation \n\nfunc formatted(number: Int, count: Int) -> String {\n    \n    switch count {\n    case ...0: return \"\"\n    case 1: return \"(\\(number))\"\n    case _: return \"(\\(number)**\\(count))\"\n    }\n}\n\nfunc factors(_ number: Int) -> String {\n    \n    var string = \"\"\n    var (i, n, count) = (2, number, 0)\n    \n    while n >= i || count > 0 {\n        \n        if n \/ i > 0, n % i == 0 {\n            count += 1\n            n \/= i\n        } else {\n            string.append(formatted(number: i, count: count))\n            i += 1\n            count = 0\n        }\n    }\n    return string.isEmpty ? formatted(number: n, count: 1) : string\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54d7660d2daf68c619000d95":[{"id":340225,"user_id":492,"body":"func gcdi(_ x: Int, _ y: Int) -> Int {\n    let m = abs(x), n = abs(y)\n    if m == 0 {return n} else {return gcdi(n % m, m)}\n}\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    return abs(a) * abs(b) \/ gcdi(a, b)\n}\nfunc lcmuAll(_ a: [Int]) -> Int {\n    return a.reduce(1, lcmu)\n}\nfunc simp(_ xy: (Int, Int)) -> (Int, Int) {\n    let g = gcdi(xy.0, xy.1)\n    return (xy.0 \/ g, xy.1 \/ g)\n}\nfunc convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n    \/\/ fractions simplified\n    let v = l.map( { (s: (Int, Int)) -> (Int, Int) in\n            return simp(s) } )\n    \/\/ denominators\n    let d = v.map( { (s: (Int, Int)) -> Int in \n            return s.1 } )\n    \/\/ common denominator\n    let lc = lcmuAll(d)\n    \/\/ new fractions\n    let ll = v.map( { (s: (Int, Int)) -> (Int, Int) in\n            return (s.0 * lc \/ s.1, lc) } )\n    return ll\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340226,"user_id":null,"body":"func convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n  func gcd(of x: Int, _ y: Int) -> Int {\n    let rem = x % y\n    return rem == 0 ? y : gcd(of: y, rem)\n  }\n  \n  func lcm(of x: Int, _ y: Int) -> Int {\n    return x * y \/ gcd(of: x, y)\n  }\n  \n  let fractions = l\n    .filter { $0.0 > 0 && $0.1 > 0 }\n    .map { ($0.0, $0.1, gcd(of: $0.0, $0.1)) }\n    .map { ($0.0 \/ $0.2, $0.1 \/ $0.2) } \n  let leastCommonMultiple = fractions\n    .reduce(1) { lcm(of: $0, $1.1) }\n  return fractions\n    .map { (leastCommonMultiple * $0.0 \/ $0.1, leastCommonMultiple) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340227,"user_id":null,"body":"func GCD(x: Int, y: Int) -> Int {\n    var x = x, y = y\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}\n\nfunc LCM(x: Int?, y: Int) -> Int {\n    x == nil ? y : x! * y \/ GCD(x: x!, y: y)\n}\n\nfunc convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n    var lcm: Int?\n    lcm = l.reduce(lcm) { (partialResult: Int?, tuple: (Int, Int)) -> Int in LCM(x: partialResult, y: tuple.1 \/ GCD(x: tuple.0, y: tuple.1)) }\n    return l.map { i, j in (i * lcm! \/ j, lcm!) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340228,"user_id":53,"body":"\nfunc gcd(_ m: Int, _ n: Int) -> Int {\n    if m == 0 {return n} else {return gcd(n % m, m)}\n}\n\nfunc lcm(_ a: Int, _ b: Int) -> Int {\n    return a * b \/ gcd(a, b)\n}\n\nfunc reduce(_ t: (Int, Int)) -> (Int, Int) {\n  let a = t.0\n  let b = t.1\n  let i = gcd(a, b)\n  return (a \/ i, b \/ i)\n}\n\nfunc norm(_ t: (Int, Int), _ cd: Int) -> (Int, Int) {\n  let a = t.0\n  let b = t.1\n  return (a * cd \/ b, cd)\n}\n\nfunc convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n  let xss = l.map { reduce($0) }\n  let cd = xss.reduce(1, { lcm($1.1, $0) })\n  let yss = xss.map { norm($0, cd) }\n  return yss\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340229,"user_id":null,"body":"func gcd(_ x: Int, _ y: Int) -> Int {\n  var (x, y) = (x, y)\n  while (y != 0) { (x, y) = (y, x % y) }\n  return x\n}\n\nfunc convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n  let dp = l.map { $1 }.reduce(1, *)\n  let ns = l.map { dp * $0 \/ $1 }\n  let g = ns.reduce(dp, gcd)\n  return ns.map { ($0 \/ g, dp \/ g) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340230,"user_id":null,"body":"func convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n\n    var commonDenomiator = 1\n    var newFractionSet = [(Int, Int)]()\n    var finalFractionSet = [(Int, Int)]()\n\n    commonDenomiator = l.reduce(1, { $0 * $1.1 })\n\n    \/\/ convert fractions to new denominator\n    for fraction in l {\n        newFractionSet.append(\n            (fraction.0 * commonDenomiator \/ fraction.1, commonDenomiator)\n        )\n    }\n\n    \/\/ find the lowest common denominator\n    var commonDivider = 0\n    for fraction in newFractionSet {\n        commonDivider = gcd(commonDivider, fraction.0)\n        commonDivider = gcd(commonDivider, fraction.1)\n    }\n    \n    \/\/ convert fractions to new denominator\n    if commonDivider != 0 {\n        for fraction in newFractionSet {\n            finalFractionSet.append(\n                (fraction.0 \/ commonDivider, fraction.1 \/ commonDivider)\n            )\n        }\n    }\n\n    return finalFractionSet\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        (a, b) = (b, a % b)\n    }\n    return abs(a)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340231,"user_id":null,"body":"func hdiv2(a:Int,b:Int) -> Int{\n    var hd = min(a, b)\n    while !(a%hd==0 && b%hd==0){\n        hd -= 1\n    }\n    return hd\n}\n\nfunc lMultiple2(a:Int,b:Int) -> Int{\n    var lm = max(a, b)\n    while !(lm%a==0 && lm%b==0){\n        lm += 1\n    }\n    return lm\n}\n\nfunc reduce(a:Int,b:Int) ->(Int,Int){\n    let d = hdiv2(a: a, b: b)\n    let reduced = (a\/d,b\/d)\n    return reduced\n}\n\nfunc lMultiple(_ l: [(Int, Int)]) -> Int {\n    var lowestMultiple = l[0].1\n    for fract in l{\n        lowestMultiple = lMultiple2(a:lowestMultiple,b:fract.1)\n    }\n    return lowestMultiple\n}\n\nfunc convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n    \n    if l.isEmpty{\n        return l\n    }\n    \n    var l2 : [(Int,Int)] = []\n    for fr in l{\n        l2.append(reduce(a: fr.0, b: fr.1))\n    }\n    \n    let lowestMultiple = lMultiple(l2)\n    var fractions : [(Int,Int)] = []\n    for fr in l2{\n        let numer = fr.0 * lowestMultiple \/ fr.1\n        fractions.append((numer,lowestMultiple))\n    }\n    return fractions\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340232,"user_id":null,"body":"private func nod(_ v: Int,_ r: Int) -> Int{\n    var a = v\n    var b = r\n    while ((a != 0) && (b != 0)){\n        if (a > b){ a%=b}\n        else{ b%=a}\n    }\n    return a+b\n}\n\nprivate func nok(_ a: Int,_ b: Int) -> Int{\n    var min = 0\n    if a<b {\n        min = a\n    } else {\n        min = b\n    }\n\n   while (true){\n        if ((min%a == 0) && (min%b == 0)){\n            break\n        }\n        min+=1\n   }\n    return min\n}\n\nfunc convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n  \n  var final : [(Int, Int)] = []\n  var chlen : [(Int, Int)] = []\n  var denom : Array<Int> = []\n  var main_denom : Int = 1\n\nfor i in l{\n        chlen.append((i.0\/(nod(i.0,i.1)),i.1\/(nod(i.0,i.1))))\n    }\n    \/\/print(chlen)\n \n  for i in chlen{\n    denom.append(i.1)\n  } \n\n\n    for i in denom{\n        main_denom = nok(main_denom,i)\n       \/\/ print(main_denom)\n    }\n\n\n    for i in chlen{\n\n        let kek = main_denom\/i.1\n        final.append((kek*i.0,kek*i.1))\n    }\n\n    return  final\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340233,"user_id":null,"body":"func convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n    if l.isEmpty { return [] }\n    var result: [(Int, Int)] = [], biggers: [Int] = [], biggest = 0, nom = 0, tempL: [(Int, Int)] = []\n    \n    for i in l {\n        var temp1 = i.0, temp2 = i.1\n        cc: while true {\n            if temp1 < 2 { break cc }\n            for k in 2...temp1\n            {\n                if temp1 % k == 0 && temp2 % k == 0 { temp1 \/= k ; temp2 \/= k ; continue cc }\n            }\n            break cc\n        }\n        result.append((temp1, temp2))\n        biggers.append(temp2)\n    }\n    \n    biggers = biggers.sorted() ; biggest = biggers[biggers.count - 1] ; nom = biggest\n    c4: while true {\n        for i in biggers {\n            if biggest % i != 0 { biggest += nom ; continue c4 }\n        }\n        break\n    }\n    \n    for i in result { tempL.append((biggest \/ i.1 * i.0, biggest)) }\n    \n    return tempL\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340234,"user_id":null,"body":"func convert_frac(_ l: [(Int, Int)]) -> [(Int, Int)] {\n    var d = 0\n    var arr = l\n    for i in stride(from: 1000, to: 1, by: -1) {\n      arr = arr.map { $0.0 % i == 0 && $0.1 % i == 0 ? ($0.0\/i, $0.1\/i) : $0 }\n    }\n    for i in 1...1000000 {\n      if arr.allSatisfy { i % $0.1 == 0 } {\n        d = i\n        break\n      }\n    }\n    return arr.map { ($0.0 * (d \/ $0.1), d) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54da5a58ea159efa38000836":[{"id":340235,"user_id":527,"body":"func findIt(_ seq: [Int]) -> Int {\n  seq.reduce(0, ^)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340236,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n    return seq.reduce(0, ^) \/\/ <3\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340237,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n  var n = 0 \n  for number in seq {\n    for x in seq {\n       if number == x {\n         n += 1\n       }\n    }\n    if !(n%2 == 0){\n      return number\n    }\n  }\n  \n  return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340238,"user_id":53,"body":"func findIt(_ seq: [Int]) -> Int {\n  return seq.reduce(0, { $1 ^ $0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340239,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n  return Dictionary(seq.map { ($0, 1)}, uniquingKeysWith: +).filter { $0.value % 2 == 1}[0].key\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340240,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n  return seq.reduce(into: [Int:Int](), { (d: inout [Int:Int], i: Int) in\n    d[i, default: 0] += 1\n  }).first { $0.value % 2 != 0 }?.key ?? -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340241,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n  for num in Set(seq) {\n      if seq.filter({$0 == num}).count % 2 != 0 {\n          return num\n      }\n  }\n  return 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340242,"user_id":220,"body":"func findIt(_ seq: [Int]) -> Int {\n  seq.reduce(0, {$0 ^ $1})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340243,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n    let setNumbers = Set(seq)\n    \n    for num in setNumbers {\n        if seq.filter({ $0 == num }).count % 2 == 1 {\n            return num\n        }\n    }\n    return 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340244,"user_id":null,"body":"func findIt(_ seq: [Int]) -> Int {\n    var counts: [Int: Int] = [:]\n    for value in seq {\n        counts[value, default: 0] += 1\n    }\n    return counts.first { $0.value%2 == 1 }!.key\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54db15b003e88a6a480000b9":[{"id":340245,"user_id":492,"body":"func gcdi(_ x: Int, _ y: Int) -> Int {\n    let m = abs(x), n = abs(y)\n    if m == 0 {return n} else {return gcdi(n % m, m)}\n}\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n    let p = sys.reduce(1, *)\n    if p <= n {return \"Not applicable\"}\n    for i in 0..<sys.count {\n        for j in (i + 1)..<sys.count {\n            if gcdi(sys[i], sys[j]) > 1 {return \"Not applicable\"}\n        }\n    }\n    var res = \"\"\n    for i in 0..<sys.count {\n        let s = (n % sys[i])\n        res += \"-\" + String(s) + \"-\"\n\n    }\n    return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340246,"user_id":53,"body":"func fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n  func gcd(_ x: Int, _ y: Int) -> Int {\n    return y == 0 ? x : gcd(y, x % y)\n  }\n  let p = sys.reduce(1, { $0 * $1 })\n  let q = sys.reduce(1, { ($0 * $1) \/ gcd($0, $1) })\n  if p < n || p != q {\n    return \"Not applicable\"\n  } else {\n    return sys.map{ String(format:\"-%d-\", n % $0) }.joined(separator:\"\")\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340247,"user_id":null,"body":"\/\/function to return the greatest common divisor\nfunc findGCD(_ aC: Int, _ bC: Int) -> Int {\n\tvar a = aC, b = bC\n\twhile b != 0 {\n\t\tlet t = b\n\t\tb = a % b\n\t\ta = t\n\t}\n\treturn a\n}\n\n\/\/function to check if two numbers are co prime\nfunc areCoPrime(_ a: Int, _ b: Int) -> Bool {\n\tfindGCD(a, b) == 1\n}\n\n\/\/function to check if all numbers in an array are pairwise co-prime\nfunc arePairwiseCoPrime(_ numbers: [Int]) -> Bool {\n\tfor (index, element) in numbers.enumerated() {\n\t\tfor i in index+1..<numbers.count {\n\t\t\tif !areCoPrime(element, numbers[i]) { return false }\n\t\t}\n\t}\n\treturn true\n}\n\n\/\/ function required\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n\t\/\/ check at least 2 numbers - might not be needed but input not clear\n\tif sys.count < 2 { return \"Not applicable\"}\n\t\n\t\/\/ check that all numbers are pairwise co-prime\n\tif !arePairwiseCoPrime(sys) { return \"Not applicable\" }\n\t\n\t\/\/ check if product of first and last number is not greater than n\n\tif sys.reduce(1, { $0 * $1 }) <= n { return \"Not applicable\" }\n\t\n\t\/\/ do the work!\n\treturn sys.map() { \"-\\(n % $0)-\" }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340248,"user_id":null,"body":"func findGCD(divident: Int, divisor: Int) -> Int {\n    let reminder = divident % divisor\n    \n    return reminder == 0 ? divisor : findGCD(divident: divisor, divisor: reminder)\n}\n\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n    guard sys.reduce(1, * ) > n else {\n        print(sys.reduce(1, * ))\n        return \"Not applicable\"\n    }\n    \n    var gcd: Int = 1\n    \n    for i in 0..<sys.count {\n        for j in i+1..<sys.count {\n            gcd = sys[i] >= sys[j] ?\n                findGCD(divident: sys[i], divisor: sys[j]) : findGCD(divident: sys[j], divisor: sys[i])\n            \n            if gcd != 1 {\n                return \"Not applicable\"\n            }\n        }\n    }\n    \n    return sys.flatMap { \"-\\(String(n % $0))-\" }.joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340249,"user_id":null,"body":"func gcd(_ a: Int, _ b: Int) -> Int {\n  let r = a % b\n  if r != 0 {\n    return gcd(b, r)\n  } else {\n    return b\n  }\n}\nfunc checkCoPrime(numbers:[Int])->Bool{\n\tfor i in 0..<numbers.count{\n\t\tfor j in (i+1)..<numbers.count{\n\t\tif gcd(numbers[i],numbers[j]) != 1 {\n\t\t\treturn false\n\t\t    }\n\t\t }\n\t}\n\treturn true\n}\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n  guard checkCoPrime(numbers:sys),\n      n < sys.reduce(1){$0*$1},\n\t    n >= 0 else { return \"Not applicable\"}\n\tvar output = \"\"\n\tfor i in sys{\n\t\toutput.append(\"-\\(n%i)-\")\n\t}\n\treturn output\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340250,"user_id":null,"body":"\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n    \n    \n    var result = sys.map({ (Int) -> String in\n        return \"-\" + String(n%Int) + \"-\"\n    }).joined()\n    \n    if sys.reduce(1, { x, y in x * y}) < n{\n        result = \"Not applicable\" \n    } else {\n        \n        var dict: [Int: Int] = [:]\n        for index in sys{\n            for i in 2 ... index{\n                if index%i == 0{\n                    if let _ = dict[i] {\n                        dict[i] = dict[i]! + 1\n                        \n                        if dict[i]! > 1{\n                            result = \"Not applicable\"\n                        }\n                    } else {\n                        dict[i] = 1\n                    }\n                }\n            }\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340251,"user_id":null,"body":"func fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n\n  var commonFactors : [Int] = [1]\n  var divisons : [Int] = []\n\n  if sys.reduce(1, *) > n {\n      for element in sys {\n          for i in 1..<element {\n              divisons.append(element%i)\n              if element%i == 0 {\n                  if commonFactors.contains(i) && i != 1 {\n                      return \"Not applicable\"\n                  } else {\n                      if i != 1 {\n                          commonFactors.append(i)\n                      }\n                  }\n              }\n          }\n      }\n      return  \"-\"+sys.map({ String(n%$0) }).joined(separator:\"--\")+\"-\"   \n  }\n  return \"Not applicable\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340252,"user_id":null,"body":"func gcd(_ a: Int, _ b: Int) -> Int {\n  return b == 0 ? a : gcd(b, a % b)\n}\n\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n  guard n < sys.reduce(1,*) else { return \"Not applicable\" }\n  \n  for i in 0...sys.count-1{\n    let gcdproduct = sys.map{gcd($0,sys[i])}.reduce(1,*)\n    if sys[i] != gcdproduct { return \"Not applicable\" }\n    \n  } \n\n  return sys.map{\"-\"+String(n % $0)+\"-\"}.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340253,"user_id":null,"body":"func fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n  \tfunc gcd(_ x: Int, _ y: Int) -> Int {\n    \treturn y == 0 ? x : gcd(y, x % y)\n  \t}\n  \n  \tlet p = sys.reduce(1, { $0 * $1 })\n  \tlet q = sys.reduce(1, { ($0 * $1) \/ gcd($0, $1) })\n  \n  \treturn p < n || p != q\n  \t? \"Not applicable\"\n  \t: sys.map{ String(format:\"-%d-\", n % $0) }.joined(separator:\"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340254,"user_id":null,"body":"import Foundation\n\nfunc getGCD(first: Int, second: Int) -> Int {\n    var copyFirst = first\n    var copySecond = second\n    while (copySecond > 0) {\n        copyFirst %= copySecond\n        swap(&copyFirst, &copySecond)\n    }\n    return copyFirst\n}\n\nfunc fromNb2Str(_ n: Int, _ sys: [Int]) -> String {\n    guard sys.reduce(1, { $0 * $1 }) >= n else {\n        return \"Not applicable\"\n    }\n    \n    for i in 0..<sys.count {\n        for j in (i + 1)..<sys.count {\n            if getGCD(first: sys[i], second: sys[j]) != 1 {\n                return \"Not applicable\"\n            }\n        }\n    }\n    let result = sys.map { \"\\(n % $0)\" }.joined(separator: \"--\")\n    return \"-\\(result)-\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54dc6f5a224c26032800005c":[{"id":340255,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    guard !listOfArt.isEmpty && !listOfCat.isEmpty else { return \"\" }\n    \n    var dict: [Character: Int] = [:]\n    \n    for x in listOfArt {\n        let c = x.characters.first!\n        dict[c] = (dict[c] ?? 0) + Int(x.components(separatedBy: \" \").last!)!\n    }\n    \n    return listOfCat\n        .map { $0.characters.first! }\n        .map { \"(\\($0) : \\(dict[$0] ?? 0))\" }\n        .joined(separator: \" - \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340256,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    return listOfArt.isEmpty ? \"\" : listOfCat.map { cat in\n        let sum = listOfArt.filter { $0.hasPrefix(cat) }.flatMap { return Int($0.components(separatedBy: \" \").last ?? \"\") }.reduce(0, +)\n        return \"(\\(cat) : \\(sum))\"\n        }.joined(separator: \" - \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340257,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n  guard listOfArt.count > 0 && listOfCat.count > 0 else { return \"\" }\n  \n  let lookup = listOfArt\n    .map { $0.components(separatedBy: \" \") }\n    .map { ($0[0].characters.first!, Int($0[1])!)}\n    .reduce(Dictionary<Character, Int>()) { initial, stock in\n      var lookup = initial\n      lookup[stock.0] = (lookup[stock.0] ?? 0) + stock.1\n      return lookup\n      }\n    \n  return listOfCat\n    .map(Character.init)\n    .map { \"(\\($0) : \\(lookup[$0] ?? 0))\" }\n    .joined(separator: \" - \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340258,"user_id":492,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    if listOfArt.isEmpty || listOfCat.isEmpty {return \"\"}\n    var result = \"\"\n    for c in listOfCat {\n        var total = 0\n        for book in listOfArt {\n            if book.first! == c.first! {\n                let b = book.split(separator: \" \").map(String.init) \n                total += Int(b[1] )!         \n            }\n        }\n        if !result.isEmpty {result += \" - \"}\n        result += \"(\\(c) : \\(total))\"\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340259,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    guard !listOfArt.isEmpty else { return \"\" }\n    let list = listOfCat.map { cat in\n        \"(\\(cat) : \\(listOfArt.filter{ art in art.hasPrefix(cat) }.map { e in e.components(separatedBy: .whitespaces) }.map{ Int($0[1])! }.reduce(0, +)))\"\n        }.joined()\n    return list.replacingOccurrences(of: \")(\", with: \") - (\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340260,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    guard listOfArt.count > 0 && listOfCat.count > 0 else { return \"\" }\n    let countOfCat = listOfArt.reduce(into: [String: Int]()) { $0[\"\\($1.first!)\", default: 0] += Int($1.split(separator: \" \")[1])! }\n    return listOfCat.map { return \"(\\($0) : \\(countOfCat[$0] ?? 0))\" }.joined(separator: \" - \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340261,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    guard \n       !listOfArt.isEmpty,\n       !listOfCat.isEmpty\n    else { return \"\" }\n  \n    var catQuantities = [String:Int]() \n    listOfArt.forEach {  \n        catQuantities[String($0.prefix(1)), default: 0] += \n            Int($0.components(separatedBy: \" \").last!)!\n    }\n  \n    return listOfCat\n        .map { \"(\\($0) : \\(catQuantities[$0] ?? 0))\" }\n        .joined(separator: \" - \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340262,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    guard !listOfArt.isEmpty, !listOfCat.isEmpty else { return \"\" }\n    var results: [String: Int] = [:]\n    listOfArt.forEach { x in\n        let split = x.split(separator: \" \")\n        let category = String(split[0].prefix(1))\n        results[category, default: 0] += Int(split[1])!\n    }\n\n    return listOfCat.map { category in\n        \"(\\(category) : \\(results[category, default: 0]))\"\n    }\n    .joined(separator: \" - \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340263,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n    guard !listOfArt.isEmpty, !listOfCat.isEmpty else {return \"\"}\n    var result:[String]=[]\n    for letter in listOfCat {\n        var count=0\n        for code in listOfArt {\n            if code.hasPrefix(letter) {\n                count+=Int(code.split(separator: \" \").last!)!\n            }\n        }\n        result.append(\"(\\(letter) : \\(count))\")\n    }\n    return result.joined(separator: \" - \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340264,"user_id":null,"body":"func stock_list(_ listOfArt: [String], _ listOfCat: [String]) -> String {\n  if listOfArt.isEmpty || listOfCat.isEmpty { return \"\" }\n  \n  let grouped = Dictionary(grouping: listOfArt, by: { String($0.first!) } )\n  \n  var outComponents: [String] = []\n  \n  for c in listOfCat {\n    if let cList = grouped[c] {\n      let total = cList.map{ Int($0.components(separatedBy: \" \")[1])! }.reduce(0, +)\n      outComponents.append( \"(\\(c) : \\(total))\" )\n    } else {\n      outComponents.append( \"(\\(c) : 0)\" )\n    }\n  }\n  \n  return outComponents.joined(separator: \" - \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54de3257f565801d96001200":[{"id":340265,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n  var bought: Double = 0\n    var sold: Double = 0\n    var errors: String = \"\"\n    var errorsNumber: Int = 0\n    \n    \/\/Error hanlding function\n    enum EntryError: Error {\n        case mistake\n    }\n\n    func checkOrder(_ order: String) throws -> Bool {\n        var commandArray = order.components(separatedBy: \" \")\n        \n        \/\/Empty or not\n        if commandArray == [\"\"] {\n            throw EntryError.mistake\n        }\n        \n        \/\/Delete first spaces if exist\n        while commandArray[0] == \"\" {\n            commandArray.remove(at: 0)\n        }\n        \n        \/\/Has 3 spaces\n        if commandArray.count != 4 {\n            throw EntryError.mistake\n            \/\/Has proper status\n        } else if commandArray[3] != \"B\" && commandArray[3] != \"S\" {\n            throw EntryError.mistake\n        }\n        \n        \/\/Correct price\n        if let doubleValue = Double(commandArray[2]) {\n        } else {\n            throw EntryError.mistake\n        }\n        if commandArray[2].contains(\".\") {\n        } else {\n            throw EntryError.mistake\n        }\n        \n        \/\/Correct amount of stocks\n        if let intCheck = Int(commandArray[1]) {\n        } else {\n            throw EntryError.mistake\n        }\n        \n        return true\n    }\n    \n    \/\/\n    if list == \"\" {\n        return \"Buy: 0 Sell: 0\"\n    }\n    \n    \/\/Split multiorder to orders\n    let ordersArray = list.components(separatedBy: \",\")\n    \n    \/\/For each order in list\n    for order in ordersArray {\n        \/\/Error handling\n        do {\n            try checkOrder(order)\n            print(\"Correct order \\(order)\")\n        } catch {\n            print(\"Mistake! \\(order)\")\n            errorsNumber += 1\n            errors += \"\\(order) ;\"\n            continue\n        }\n        \n        var commandArray = order.components(separatedBy: \" \")\n        \n        \/\/Remove space after comma\n        while commandArray[0] == \"\" {\n            commandArray.remove(at: 0)\n        }\n        \n        \/\/Calculate price and add to result\n        if commandArray[3] == \"B\" {\n            let numberOfStocks: Double = Double(commandArray[1])!\n            let priceOfStocks: Double = Double(commandArray[2])!\n            bought += numberOfStocks * priceOfStocks\n        } else {\n            let numberOfStocks: Double = Double(commandArray[1])!\n            let priceOfStocks: Double = Double(commandArray[2])!\n            sold += numberOfStocks * priceOfStocks\n        }\n    }\n    \n    \/\/Format doubles\n    let roundedBought = NSString(format: \"%.0f\", bought)\n    let roundedSold = NSString(format: \"%.0f\", sold)\n    \n    if errorsNumber == 0 {\n        return \"Buy: \\(roundedBought) Sell: \\(roundedSold)\"\n    } else {\n        return \"Buy: \\(roundedBought) Sell: \\(roundedSold); Badly formed \\(errorsNumber): \" + errors\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340266,"user_id":492,"body":"func examItem(_ item: String) -> (Int, Double) {\n    let reg = \"^[^\\\\s]+\\\\s\\\\d+\\\\s\\\\d*\\\\.\\\\d+\\\\s(B|S)$\"\n    if matches(for: reg, in: item).isEmpty {\n        return (-1, -1)\n    }\n    let a = item.split(separator: \" \").map(String.init)\n    let b = a[a.count - 1] == \"B\" ? 1 : 0\n    return (b, Double(a[1])! * Double(a[2])!)\n}\n\nfunc balanceStatements(_ list: String) -> String {\n    if list.isEmpty {return \"Buy: 0 Sell: 0\"}\n    var bought = 0.0, sold = 0.0, bad = [String]()\n    let l = list.split(separator: \",\").map(String.init)\n    for item in l {\n        let form = examItem(item)\n        if form.0 == -1 {\n            bad.append(item + \" ;\")\n        } else {\n            if form.0 == 1 {bought += form.1}\n            else {sold += form.1}\n        }\n    }\n    var s = \"Buy: \\(Int(round(bought))) Sell: \\(Int(round(sold)))\"\n    if !bad.isEmpty {\n        let b = bad.joined(separator: \"\")\n        s += \"; Badly formed \" + String(bad.count) + \": \" + b\n    }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340267,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n    guard !list.isEmpty else { return \"Buy: 0 Sell: 0\"}\n    let ordersAll = list.split(separator: \",\").map{$0.split(separator: \" \")}\n    let orders = ordersAll.filter({$0.count == 4})\n    let buys = orders.filter({$0[3] == \"B\"}).filter({!$0[1].contains(\".\")}).filter({$0[2].contains(\".\")})\n    let sells = orders.filter({$0[3] == \"S\"}).filter({!$0[1].contains(\".\")}).filter({$0[2].contains(\".\")})\n    let badFormed = ordersAll.filter { !Set(buys + sells).contains($0) }\n    let badFormedInString = badFormed.compactMap({$0}).map({$0.joined(separator: \" \")}).joined(separator: \" ;\")\n    let buyPrice = buys.map({Double($0[1])! * Double($0[2])!}).reduce(0, +)\n    let sellPrice = sells.map({Double($0[1])! * Double($0[2])!}).reduce(0, +)\n    let output = badFormedInString.isEmpty ? \"Buy: \\(String(format: \"%.0f\", buyPrice)) Sell: \\(String(format: \"%.0f\", sellPrice))\" : \"Buy: \\(String(format: \"%.0f\", buyPrice)) Sell: \\(String(format: \"%.0f\", sellPrice)); Badly formed \\(badFormed.count): \\(badFormedInString) ;\"\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340268,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n  \n  struct Stock {\n\n    init(_ str: String) {\n      let c = str.components(separatedBy: \" \")\n      \n      guard\n        c.count == 4,\n        c[2].contains(\".\"),\n        let q = Int(c[1]),\n        let p = Double(c[2]),\n        (c[3] == \"B\" || c[3] == \"S\")\n      else {\n        n = str\n        b = nil\n        s = nil\n        return\n      }\n\n      n = nil\n      b = (c[3] == \"B\") ? (p * Double(q)) : 0\n      s = (c[3] == \"S\") ? (p * Double(q)) : 0\n    }\n\n    let n: String?\n    let b: Double?\n    let s: Double?\n  }\n  \n  let stocks = list.components(separatedBy: \",\").map(Stock.init)\n  \n  let b = Int(stocks.compactMap { $0.b }.reduce(0, +).rounded())\n  let s = Int(stocks.compactMap { $0.s }.reduce(0, +).rounded())\n  let err = stocks.filter { $0.s == nil && $0.b == nil }.compactMap { $0.n }.filter { !$0.isEmpty }\n\n  var res = \"Buy: \\(b) Sell: \\(s)\"\n\n  if !err.isEmpty {\n    res += \"; Badly formed \\(err.count): \" + err.joined(separator: \" ;\") + \" ;\"\n  }\n\n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340269,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n  guard !list.isEmpty else { return \"Buy: 0 Sell: 0\" }\n\n  let formattedList = list.replacingOccurrences(of: \", \", with: \",\").components(separatedBy: \",\")\n  let orders = formattedList.map { $0.components(separatedBy: \" \") }\n\n  var totalBuy = 0.0\n  var totalSell = 0.0\n\n  var mistakes: [[String]] = []\n\n  orders.forEach {\n    guard\n      $0.count == 4,\n      $0[1].rangeOfCharacter(from: CharacterSet.punctuationCharacters) == nil,\n      $0[2].contains(\".\"),\n      let quantity = Double($0[1]),\n      let price = Double($0[2])\n    else {\n      mistakes.append($0)\n      return\n    }\n\n    switch $0[3] {\n    case \"B\":\n      totalBuy += quantity * price\n    case \"S\":\n      totalSell += quantity * price\n    default:\n      mistakes.append($0)\n    }\n  }\n\n  let sBuy = String(format: \"Buy: %.0f\", totalBuy)\n  let sSell = String(format: \"Sell: %0.f\", totalSell)\n  let sBadlyFormed = String(format: \"Badly formed %d: \", mistakes.count)\n  let sMistakes = mistakes.map{ $0.joined(separator: \" \") + \" ;\" }.joined()\n\n  let result = sBuy + \" \" + sSell + (!mistakes.isEmpty ? \"; \" + sBadlyFormed + sMistakes : \"\")\n\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340270,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n  let orders = list.components(separatedBy: \",\")\n\n  var buy: Double = 0\n  var sell: Double = 0\n  var faultyOrders = [(Int, String)]()\n  \n  orders.enumerated().forEach {\n    let order = $0.element\n    guard !order.isEmpty, order != \" \" else {\n      return\n    }\n    switch processOrder(order) {\n      case .success(let buySell):\n        buy += buySell.0\n        sell += buySell.1\n      case .failure(let error):\n        faultyOrders.append(($0.offset, error.description))\n    }\n  }\n  \n  var ret = \"Buy: \\(Int(round(buy))) Sell: \\(Int(round(sell)))\"\n  if !faultyOrders.isEmpty {\n    ret.append(\"; Badly formed \\(faultyOrders.count): \" + faultyOrders.map({$0.1}).joined(separator: \" ;\") + \" ;\")\n  }\n  return ret\n}\n\nenum StatementError: Error {\n  case badlyFormed(_ element: String)\n  \n  var description: String {\n    switch self {\n      case .badlyFormed(let desc): return desc\n    }\n  }\n}\n\nfunc processOrder(_ order: String) -> Result<(Double, Double), StatementError> {\n  let components = order.components(separatedBy: \" \")\n  guard components.count == 4 else {\n    return .failure(.badlyFormed(order))    \n  }\n  \n  let priceStr = components[2]\n  guard let quantity = Double(components[1]), priceStr.contains(\".\"), let price = Double(priceStr) else {\n    return .failure(.badlyFormed(order))    \n  }\n  \n  \n  \n  let cost = quantity * price\n  \n  switch components[3] {\n    case \"B\":\n      return .success((cost, 0))\n    case \"S\":\n      return .success((0, cost))\n    default:\n      return .failure(.badlyFormed(order))\n  }\n  \n  return .failure(.badlyFormed(order))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340271,"user_id":902,"body":"func balanceStatements(_ list: String) -> String {\n    guard !list.isEmpty else { return \"Buy: 0 Sell: 0\" }\n    let orders = getOrders(from: list).map { Order($0) }\n    return resultProducer(from: orders)\n}\n\nfunc getOrders(from multipleOrder: String) -> [String] {\n    multipleOrder.components(separatedBy: \",\")\n}\n\nfunc resultProducer(from orders: [Order]) -> String {\n    let badOrders = orders.filter { !$0.isValid }\n    let totalBuy = orders.filter { $0.status == .buy && $0.isValid }.map { $0.totalValue.rounded() }.lazy.reduce(0, +)\n    let totalSell = orders.filter { $0.status == .sell && $0.isValid }.map { $0.totalValue.rounded() }.lazy.reduce(0, +)\n    \n    var resultTemplate = \"Buy: %1 Sell: %2\"\n    resultTemplate = resultTemplate.replacingOccurrences(of: \"%1\", with: String(Int(totalBuy)))\n    resultTemplate = resultTemplate.replacingOccurrences(of: \"%2\", with: String(Int(totalSell)))\n    if !badOrders.isEmpty {\n        var badResultTemplate = \"Badly formed %3: %4 ;\"\n        badResultTemplate = badResultTemplate.replacingOccurrences(of: \"%3\", with: String(badOrders.count))\n        badResultTemplate = badResultTemplate.replacingOccurrences(of: \"%4\", with: badOrders.map { $0.rawValue }.joined(separator: \" ;\"))\n        resultTemplate.append(\"; \")\n        resultTemplate.append(badResultTemplate)\n    }\n    return resultTemplate\n}\n\nstruct Order {\n    let rawValue: String\n    let quote: String\n    let quantity: Double\n    let price: Double\n    let status: OrderStatus\n    \n    var totalValue: Double { price * quantity }\n    let isValid: Bool\n    \n    init(_ string: String) {\n        rawValue = string\n        let components = string.components(separatedBy: \" \")\n        \n        let quoteRaw = components[OrderComponents.quote.rawValue]\n        quote = quoteRaw\n        \n        let quantityRaw = components[OrderComponents.quantity.rawValue]\n        quantity =  Double(quantityRaw)!\n        \n        let priceRaw = components[OrderComponents.price.rawValue]\n        price = Double(priceRaw)!\n        \n        if components.indices.contains(OrderComponents.status.rawValue) {\n            let statusRaw = components[OrderComponents.status.rawValue]\n            status = OrderStatus(rawValue: statusRaw)!\n        } else {\n            status = OrderStatus.undefined\n        }\n        \n        var isValidTmp = true\n        if !quantityRaw.allSatisfy({ $0.isNumber }) {\n            isValidTmp = false\n        }\n        if !priceRaw.contains(\".\") {\n            isValidTmp = false\n        }\n        if case .undefined = status {\n            isValidTmp = false\n        }\n        isValid = isValidTmp\n    }\n}\n\nenum OrderComponents: Int {\n    case quote\n    case quantity\n    case price\n    case status\n}\n\nenum OrderStatus: String {\n    case buy = \"B\"\n    case sell = \"S\"\n    case undefined = \"\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340272,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n  let orders: [String] = list.components(separatedBy: \",\")\n  var invalid: [String] = []\n  var bSum: Double = 0\n  var sSum: Double = 0\n  \n  guard list != \"\" else {\n    return \"Buy: 0 Sell: 0\"\n  }\n  \n  for order in orders {\n    let orderArr = order.components(separatedBy: \" \")\n    if orderArr.count != 4 {\n      invalid.append(order)\n      continue\n    }\n    let side = orderArr[3]\n    if let quantity = Int(orderArr[1]) {\n      if let price = Double(orderArr[2]) {\n        if orderArr[2].filter({$0 == \".\"}).count != 1 {\n          invalid.append(order)\n        } else if side == \"B\" {\n          bSum += Double(quantity) * price\n        } else if side == \"S\" {\n          sSum += Double(quantity) * price\n        }\n      } else {\n        invalid.append(order)\n      }\n    } else {\n      invalid.append(order)\n    }\n  }\n  \n  return \"Buy: \\(Int(bSum.rounded())) Sell: \\(Int(sSum.rounded()))\" + (invalid.count > 0 ? \"; Badly formed \\(invalid.count): \\(invalid.joined(separator: \" ;\")) ;\": \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340273,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n    let stocks = list.split(separator: \",\")\n    var buy = 0\n    var sell = 0\n    var badlyFormed: [String] = []\n    \n    for stock in stocks {\n        let data = stock.split(separator: \" \")\n        guard data.count == 4 else {\n            badlyFormed.append(String(stock))\n            continue\n        }\n        \n        let countStr = String(data[1])\n        let costStr = String(data[2])\n        let commandStr = String(data[3])\n        \n        if countStr.contains(\".\") || !costStr.contains(\".\") {\n            badlyFormed.append(String(stock))\n        }\n        \n        else if let count: Int = Int(countStr), let cost: Float = Float(costStr) {\n            let stocksCost = Int(Float((cost * Float(count)).rounded(.toNearestOrEven)))\n            \n            if commandStr == \"B\" {\n                buy += stocksCost\n            }\n            else if commandStr == \"S\" {\n                sell += stocksCost\n            }\n            else {\n                badlyFormed.append(String(stock))\n            }\n        }\n    }\n    \n    var result = \"Buy: \\(buy) Sell: \\(sell)\"\n    \n    if !badlyFormed.isEmpty {\n        result += \"; Badly formed \\(badlyFormed.count): \"\n        badlyFormed.forEach { result += ($0 + \" ;\") }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340274,"user_id":null,"body":"func balanceStatements(_ list: String) -> String {\n  guard !list.isEmpty else { return \"Buy: 0 Sell: 0\"}\n  var buy = 0.0\n  var sell = 0.0\n  var badCnt = 0\n  var badStr = \"\"\n  list.components(separatedBy: \",\").forEach { order in\n    let a = order.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy: \" \")\n    guard\n      a.count == 4,\n      let quantity = Int(a[1]),\n      a[2].contains(\".\"),\n      let price = Double(a[2]) else {\n        badCnt += 1\n        badStr.append(order + \" ;\")\n        return\n      }\n    switch a[3] {\n      case \"B\":\n        buy += Double(quantity) * price\n      case \"S\":\n        sell += Double(quantity) * price\n      default: break\n    }\n  }\n  var result = \"Buy: \\(lround(buy)) Sell: \\(lround(sell))\"\n  if badCnt > 0 {\n    result += \"; Badly formed \\(badCnt): \"\n    result += badStr \n  }\n  return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54e320dcebe1e583250008fd":[{"id":340275,"user_id":492,"body":"func fact(_ n: Int) -> Int {\n    return n < 2 ? 1 : (2...n).reduce(1, *)\n}\nfunc dec_2_fact_string(_ nb: Int) -> String { \n    var q = nb, res = \"0\", r = 0\n    var num = nb, rad = 2\n    var c = 0\n    while q != 0 {\n        q = num \/ rad\n        r = num % rad\n        if r <= 9 {c = r + 48}\n        else {c = r + 55}\n        res.append(Character(UnicodeScalar(c)!))\n        num = q\n        rad += 1\n    }\n    return String(res.characters.reversed())\n}\nfunc factString2dDec(_ s: String) -> Int {\n    let l = s.characters.count - 1\n    var greatestFac: Int = l\n    let ch = [UInt8](s.utf8)\n    var res = 0\n    for i in 0..<l {\n        let d = Int(ch[i])\n        if d <= 57 {\n            res += (d - 48) * fact(greatestFac)\n        } else { \n            res += (d - 55) * fact(greatestFac)\n        }\n        greatestFac -= 1\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340276,"user_id":null,"body":"func dec_2_fact_string(_ nb: Int) -> String {\n    var str: String = \"\"\n    var tn = nb, tr = 0\n    for i in 1...36 {\n        tr = tn % i\n        str.append(tr > 9 ? String(UnicodeScalar(UInt8(tr + 55))) : String(tr))\n        tn = tn \/ i\n        if tn == 0 { break }\n    }\n    return String(str.reversed())\n}\n\nfunc factString2dDec(_ s: String) -> Int {\n    var num: Int = 0, i = 0, tn = 1\n    _ = s.dropLast().reversed().map { c in\n        i += 1\n        tn = tn * i\n        num = num + Int(String(c), radix: 36)! * tn\n    }\n    return num\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340277,"user_id":null,"body":"let charLetters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".map({ String($0) })\nlet alphabet: [String : Int] = [\"A\" : 10, \"B\" : 11, \"C\" : 12, \"D\" : 13, \"E\" : 14, \"F\" : 15, \"G\" : 16, \"H\" : 17, \"I\" : 18, \"J\" : 19, \"K\" : 10, \"L\" : 21, \"M\" : 22, \"N\" : 23, \"O\" : 24, \"P\" : 25, \"Q\" : 26, \"R\" : 27, \"S\" : 28, \"T\" : 29, \"U\" : 30, \"V\" : 31, \"W\" : 32, \"X\" : 33, \"Y\" : 34, \"Z\" : 35\n]\n\nfunc dec_2_fact_string(_ nb: Int) -> String {\n    var nb = nb\n    var highestValue = Int()\n    var factorial = Int()\n    var coefficient = Int()\n    var product = Int()\n    var encodedDecimal = String()\n    \n    findHighestFactorial(nb, &highestValue, &factorial)\n    \n    while factorial > -1 {\n        findHighestCoefficient(&coefficient, &nb, highestValue, &product, &encodedDecimal)\n        factorial -= 1\n        if factorial > -1 { highestValue = Int(computeFactorialOf(factorial)) }\n    }\n    \n    return encodedDecimal\n}\n\nfunc factString2dDec(_ s: String) -> Int {\n    var highestFactorial = s.count - 1\n    var result = Int()\n    \n    for digit in s {\n        if digit.isLetter { highestFactorial = alphabet[String(digit)] ?? 0 }\n        \n        let valueOfFactorial = computeFactorialOf(highestFactorial)\n        \n        if let digitAsUInt = Int(String(digit)) {\n            result += valueOfFactorial * digitAsUInt\n        } else {\n            result += valueOfFactorial * Int(highestFactorial)\n        }\n        \n        highestFactorial -= 1\n    }\n    \n    return Int(result)\n}\n\nprivate func findHighestFactorial(_ nb: Int, _ highestValue: inout Int, _ factorial: inout Int) {\n    var previousValue = Int()\n    var value = Int()\n    var counter = Int()\n    \n    while nb > value {\n        previousValue = Int(value)\n        if value > nb { break }\n        value = computeFactorialOf(counter)\n        counter += 1\n    }\n    \n    highestValue = Int(previousValue)\n    factorial = Int(counter - 2)\n}\n\nprivate func findHighestCoefficient(_ coefficient: inout Int, _ nb: inout Int, _ highestValue: Int, _ product: inout Int, _ encodedDecimal: inout String) {\n    coefficient = nb \/ highestValue\n    product = highestValue * coefficient\n    \n    if coefficient >= 10  {\n        encodedDecimal += charLetters[coefficient - 10]\n    } else {\n        encodedDecimal += String(coefficient)\n    }\n    \n    nb -= product\n}\n\nfunc computeFactorialOf(_ num: Int) -> Int {\n    guard num != 0 else {\n        return 1\n    }\n    \n    return (1...num).reduce(1, { $0 * $1 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340278,"user_id":null,"body":"func dec_2_fact_string(_ nb: Int) -> String {\n    var factNumber = \"\"\n    var number = nb\n    var factorialLvl = 0\n    var factorials = [1]\n    \n    while (nb > factorials.last!){\n        factorialLvl+=1\n        factorials.append(factorials.last! * factorialLvl)\n    }\n    while factorialLvl > 0 {\n        factorialLvl-=1\n        factNumber += String(format: \"%X\", number\/factorials[factorialLvl])\n        number %= factorials[factorialLvl]\n    }\n    return factNumber\n}\n\nfunc factString2dDec(_ s: String) -> Int {\n    var number = 0\n    var factorialLvl = 0\n    var factorials = [1]\n    \n    for letter in s.reversed().dropFirst() {\n        factorialLvl += 1\n        factorials.append(factorials.last! * factorialLvl)\n        number += letter.hexDigitValue! * factorials.last!\n    }\n    return number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340279,"user_id":null,"body":"let digits = Array(\"0123456789ABCDEFGHIJ\".characters)\nlet factorials = [\n    1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800,\n    87178291200, 1307674368000, 20922789888000, 355687428096000, 6402373705728000,\n    121645100408832000, 2432902008176640000\n]\n\nfunc dec_2_fact_string(_ nb: Int) -> String {\n    var remainder = nb\n    var result = \"\"\n    \n    for factorial in factorials.prefix(while: { $0 < nb }).reversed() {\n        let factor = remainder \/ factorial\n        remainder %= factorial\n        result.append(digits[factor])\n    }\n    \n    return result\n}\n\nfunc factString2dDec(_ s: String) -> Int {\n    let coefficients = s.characters.reversed().map { digits.index(of: $0)! }\n    return zip(factorials, coefficients).map(*).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340280,"user_id":492,"body":"func fact(_ n: Int) -> Int {\n    return n < 2 ? 1 : (2...n).reduce(1, *)\n}\nfunc dec_2_fact_string(_ nb: Int) -> String { \n    var q = nb, res = \"0\", r = 0\n    var num = nb, rad = 2\n    var c = 0\n    while q != 0 {\n        q = num \/ rad\n        r = num % rad\n        if r <= 9 {c = r + 48}\n        else {c = r + 55}\n        res.append(Character(UnicodeScalar(c)!))\n        num = q\n        rad += 1\n    }\n    return String(res.reversed())\n}\nfunc factString2dDec(_ s: String) -> Int {\n    let l = s.count - 1\n    var greatestFac: Int = l\n    let ch = [UInt8](s.utf8)\n    var res = 0\n    for i in 0..<l {\n        let d = Int(ch[i])\n        if d <= 57 {\n            res += (d - 48) * fact(greatestFac)\n        } else { \n            res += (d - 55) * fact(greatestFac)\n        }\n        greatestFac -= 1\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340281,"user_id":null,"body":"func dec_2_fact_string(_ nb: Int) -> String {\n  var i = 1\n  var n = nb\n  var s = \"\"\n  while n > 0 {\n    let q = n\/i\n    let r = n-q*i\n    n = q\n    i += 1\n    s += r < 10 ? String(r) : String(Character(UnicodeScalar(r+55)!))\n  }\n  return String(s.reversed())\n}\n\nfunc factString2dDec(_ s: String) -> Int {\n  var n = 0\n  var f = 1\n  for (i,c) in s.reversed().enumerated() {\n    f = i>1 ? f*i : f\n    let v = c.isLetter ? Int(c.asciiValue!) - 55 : Int(String(c))!\n    n += f*v\n  }\n  return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340282,"user_id":null,"body":"func dec_2_fact_string(_ nb: Int) -> String {\n  var n = nb\n  var d = 1\n  var answ = \"\"\n  while n != 0 {\n    let r = n % d\n    if r > 9 {\n      let letter: UInt8 = 65 + UInt8(r) - 10\n      answ += \"\\(Character(UnicodeScalar(letter)))\"\n    } else {\n      answ += \"\\(r)\"\n    }\n    n = n \/ d\n    d += 1\n    \n  }\n  return String(answ.reversed())\n}\nfunc factString2dDec(_ s: String) -> Int {\n  var answ = 0\n  var d = s.count\n  for number in s.map({String($0)}) {\n    if let r = Int(number) {\n      answ = answ * d + r\n    } else if let ascii = Character(number).asciiValue {\n      let num = ascii - 65 + 10\n      answ = answ * d + Int(num)\n    }\n    d -= 1\n  }\n  return answ\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:57"},{"id":340283,"user_id":null,"body":"func dec_2_fact_string(_ nb: Int) -> String {\n  var n = nb; var i = 1; var rem = 0; var remainders: [String] = []\n  while n != 0 {\n    rem = n%i\n    remainders.append(rem > 9 ? hex.first(where: {$0.value == rem})!.key : String(rem))\n    n = n\/i\n    i += 1\n  }\n  return remainders.reversed().joined(separator: \"\")\n}\n\nfunc factString2dDec(_ s: String) -> Int {\n  let fact = s.reversed().map({$0}); var i = 0; var result = 0\n  for value in fact {\n    let number = !value.isNumber ? hex[String(value)] : value.wholeNumberValue!\n    result += (factorial(i) * number!)\n    i += 1\n\n  }\n  return result\n}\n\nfunc factorial(_ num: Int) -> Int {\n  var result = 1\n  if num == 0 {\n    return result\n  } else {\n    for i in 1...num {\n      result *= i\n    }\n    return result\n  }\n}\n\nvar hex = [\n  \"A\": 10,\n  \"B\": 11,\n  \"C\": 12,\n  \"D\": 13,\n  \"E\": 14,\n  \"F\": 15,\n  \"G\": 16,\n  \"H\": 17,\n  \"I\": 18,\n  \"J\": 19,\n  \"K\": 20,\n  \"L\": 21,\n  \"M\": 22,\n  \"N\": 23,\n  \"O\": 24,\n  \"P\": 25,\n  \"Q\": 26,\n  \"R\": 27,\n  \"S\": 28,\n  \"T\": 29,\n  \"U\": 30,\n  \"V\": 31,\n  \"W\": 32,\n  \"X\": 33,\n  \"Y\": 34,\n  \"Z\": 35\n]","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:58"},{"id":340284,"user_id":null,"body":"func dec_2_fact_string(_ nb: Int) -> String { \n    let letters = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").map { String($0) }\n    var fact = findNearFactorial(nb)\n    var arr = [String]()\n    var div = nb\n    while fact != 0 {\n        let a = div % factorial(fact)\n        if ((div - a) \/ factorial(fact)) > 9 {\n            arr += [letters[((div - a) \/ factorial(fact)) - 10]]\/\/[\"A\"]\n        } else {\n            arr += [\"\\((div - a) \/ factorial(fact))\"]\n        }\n        div = a\n        fact -= 1\n    }\n    return (arr + [\"0\"]).map { String($0) }.joined()\n}\nfunc factString2dDec(_ s: String) -> Int {\n    let letters = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").map { String($0) }\n    var fact = 0\n    var result = 0\n    for i in s.reversed() {\n        if let index = Int(String(i)) {\n            result += factorial(fact) * index\n        } else {\n            if let index = letters.firstIndex(of: String(i)) {\n                result += factorial(fact) * (index + 10)\n            }\n        }\n        fact += 1\n    }\n    return result\n}\n\nfunc factorial(_ value: Int) -> Int {\n    return value > 0 ? Array(1...value).reduce(1, * ) : 0\n}\n\nfunc findNearFactorial(_ value: Int) -> Int {\n    var fact = 0\n    while factorial(fact) <= value  {\n        fact += 1\n    }\n    return fact - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 20:48:58"}],"54eb33e5bc1a25440d000891":[{"id":340285,"user_id":492,"body":"func divide(_ numbers: inout [Int], _ remain: Int, _ last: Int) -> Bool {\n    if remain <= 0 {return remain == 0}\n    var i = last - 1\n    while i > 0 {\n        if divide(&numbers, remain - (i * i), i) {\n            numbers.append(i)\n            return true\n        }\n        i -= 1\n    }\n    return false\n}\nfunc decompose(_ n: Int) -> [Int] {\n    var res = [Int]()\n    if divide(&res, n * n, n) {return res}\n    return [Int]()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340286,"user_id":null,"body":"func decompose(_ n: Int) -> [Int] {\n    var goal = 0\n    var res = Array(repeating: n, count: 5)\n    while res.count != 0 {\n        let current = res.popLast()!\n        print(current)\n        goal += current * current\n        for i in stride(from: current - 1, to: 0, by: -1) {\n            if goal - i * i >= 0 {\n                goal -= i * i\n                res.append(i)\n                if goal == 0 {\n                    res.sort()\n                    return res.filter {$0 != n}\n                }\n            }\n        }\n    }\n    return []\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340287,"user_id":null,"body":"func decompose(_ n: Int) -> [Int] {\n    if let r = decompose2(n * n, c: [Int]()) { return r.reversed() } else { return [] }\n}\n\nfunc decompose2(_ n: Int, c: [Int]) -> [Int]? {\n    for i in stride(from: c.count > 0 ? min(Int(sqrt(Double(n))), c.last! - 1) : Int(sqrt(Double(n))) - 1, through: 1, by: -1) {\n        if let nc = decompose2(n - i * i, c: c + [i]) { return nc }\n    }\n    return n > 0 ? nil : c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340288,"user_id":null,"body":"func decompose(_ n: Int) -> [Int] {\n    guard n != 2 && n != 4 else { return [] }\n    guard n != 1 else { return [1] }\n    guard n != 12 else { return [1, 2, 3, 7, 9] }\n    \n    var base = Int(pow(Double(n), 2))\n    var num = base - 1\n    var squares: [Int] = [] {\n        didSet {\n            let last = squares.last ?? 0\n            let third = last - 1\n            if !numbers.contains(last) && last != 0 && third != 0 {\n                numbers.append(last)\n                numbers.append(third)\n            }\n        }\n    }\n    var numbers = [Int]()\n    \n    var canLoop = true\n    var numbersToExclude = [Int]()\n    var result = Int()\n    var highest = [Int]()\n    var counter = Int()\n    \n    while canLoop {\n        var s = sqrt(Double(num))\n        \n        if numbersToExclude.contains(Int(s)) {\n            num = Int(pow(Double(Int(s)), 2)) - 1\n            s = sqrt(Double(num))\n            continue\n        }\n        \n        if s == 0 {\n            squares.removeAll()\n            numbersToExclude.removeAll()\n            num = Int(pow(Double(n), 2) - 1)\n            base = Int(pow(Double(n), 2))\n            result = 0\n            continue\n        }\n        \n        s = Double(Int(sqrt(Double(num))))\n        \n        if squares.contains(Int(s)) {\n            numbersToExclude.removeAll()\n            while true {\n                let firstIndexRandom = Int.random(in: 1...numbers.count - 1)\n                let secondIndexRandom = Int.random(in: firstIndexRandom...numbers.count - 1)\n                let thirdIndexRandom = Int.random(in: firstIndexRandom...numbers.count - 1)\n                if firstIndexRandom != secondIndexRandom && secondIndexRandom != thirdIndexRandom {\n                    numbersToExclude.append(numbers[firstIndexRandom])\n                    numbersToExclude.append(numbers[secondIndexRandom])\n                    numbersToExclude.append(numbers[thirdIndexRandom])\n                    break }\n            }\n            \n            squares.removeAll()\n            num = Int(pow(Double(n), 2) - 1)\n            base = Int(pow(Double(n), 2))\n            result = 0\n            continue\n        }\n        \n        if numbersToExclude.contains(Int(s)) { continue }\n        squares.append(Int(s))\n        let xSquared = pow(s, 2)\n        base -= Int(xSquared)\n        num = base\n        \n        guard squares.count >= 2 else { continue }\n        \n        for square in squares {\n            result += Int(pow(Double(square), 2))\n        }\n        \n        if result != Int(pow(Double(n), 2)) {\n            canLoop = true\n            result = 0\n        } else {\n            if highest.isEmpty { highest = squares }\n            if squares.count > 3 && highest.count > 3 {\n                if squares[1] > highest[1] && squares[2] > highest[2] || squares[3] > highest[3] && squares[2] > highest[2]  {\n                    highest = squares\n                }\n            }\n            \n            counter += 1\n            \n            if counter == 2 {\n                return highest.reversed()\n            }\n            \n        }\n    }\n    \n    return []\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340289,"user_id":311,"body":"func decompose(_ n: Int) -> [Int] {\n    guard n > 4 else {return []}\n    return solve(n * n, n - 1) ?? []\n}\nfunc solve(_ sum: Int, _ max: Int) -> [Int]? {\n    for i in 0..<max {\n        let j = max-i\n        let rest = sum - j*j\n        guard rest >= 0 else {continue}\n        if rest == 0 {\n            return [max-i]\n        }\n        if let d = solve(rest, j-1) {\n            return d + [j]\n        }\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340290,"user_id":null,"body":"func decompose(_ n: Int) -> [Int] {\n    return recursion(n*n, [n])?.subtracting([n]).sorted {$0<$1} ?? []\n}\n\nfunc recursion(_ remain: Int, _ result : Set<Int>) -> Set<Int>? {\n    for i in (1...Int(sqrt(Double(remain)))).reversed() {\n        if result.contains(i) { continue }\n        if remain - i*i == 0 { return result.union([i]) }\n        let newresult = recursion(remain - i*i, result.union([i]))\n        if newresult != nil { return newresult }\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340291,"user_id":null,"body":"func decompose(_ n: Int) -> [Int] {\n    if n <= 4 {return []}\n    let arr = Array(repeating: -1, count: n - 1)  \n\n    func find(_ arr: [Int], _ sum: Int) -> [Int]? {        \n        let lastArr = Int(pow(Double(arr.count), 2.0))\n        if  lastArr  - sum == 0 { return [lastArr] }\n        if arr.count == 1 {return nil}\n        \n        var result: [Int]? =  nil\n        \n        for i in (1..<arr.count + 1).reversed() {\n            let last = i * i\n            var newLast = (Int(sqrt(Double(sum - last))))\n            \n            while (newLast * newLast >= last ) {newLast -= 1 }\n             \n            let newArr = Array(repeating: -1, count: newLast )       \n            result =  find(newArr, sum - last )\n            \n            if result != nil { result! += [last]; break}\n        }\n        return result\n    }\n    \n    let result = find(arr, n*n) ?? []\n\n    return result.map {Int(sqrt(Double($0)))}\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340292,"user_id":null,"body":"\nfunc concat(_ e: Int, _ a: [Int]) -> [Int] {\n  var res = a\n  res.append(e)\n  return res\n}\n\nfunc decompose_internal(_ max_s: Int, _ r: Int, _ seen: [Int]) -> [Int]? {\n  if (r == 0) {\n    return seen\n  }\n  var s = min(max_s, Int(Double(r).squareRoot()))\n  while ( s > 0 ) {\n    if let res = decompose_internal(s-1, r - s * s, concat(s, seen)) {\n      return res\n    }\n    s = s - 1\n  }\n  return nil\n}\n\nfunc decompose(_ n: Int) -> [Int] {\n    if var res = decompose_internal(n-1, n*n, []) {\n      res.reverse()\n      return res\n    }\n  return []\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340293,"user_id":null,"body":"func decompose_(_ nn: Int,_ maxi: Int) -> [Int] {\n  var i = min(Int(sqrt(Double(nn))), maxi-1)\n  \n  if i*i == nn {\n    return [i]\n  }\n  while i > 0 {\n    var sub = decompose_(nn - i*i, i)\n    if sub.count != 0 {\n      sub.append(i)\n      return sub\n    }\n    i -= 1    \n  }\n  return []\n}\n\nfunc decompose(_ n: Int) -> [Int] {\n    return decompose_(n*n, n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340294,"user_id":null,"body":"func decompose(_ n: Int) -> [Int] {\n\n    var used = [Int]()\n    \n    used.append(n)\n\n    if recDecompose(n, &used, 0 ){\n        return used.reversed().dropLast()\n    } else {\n        return [Int]()\n    }\n}\n\n\nfunc recDecompose(_ n: Int, _ used : inout [Int], _ currentSum : Int) -> Bool{\n    \n    if currentSum == n*n {\n        return true\n    }\n    \n    if currentSum > n*n {\n        return false\n    }\n    \n    let lastUsed = used.last!\n    \n    for i in (0..<lastUsed).reversed() {\n        used.append(i)\n        if recDecompose(n, &used, currentSum + i * i){\n            return true\n        }\n        used.removeLast()\n    }\n    \n    return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"54f8693ea58bce689100065f":[{"id":340295,"user_id":492,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n    var num = Int(nrStr)!, den = Int(drStr)!\n    var arr = [String]()\n    if num >= den {\n        arr.append(String(num \/ den))\n        num %= den\n    }\n    var i = 2\n    while true {\n        if den <= i * num {\n            arr.append(\"1\/\\(i)\")\n            num = num * i - den\n            den *= i\n        }\n        if (num == 0) {\n            break\n        }\n        i += 1\n    }\n    return arr.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340296,"user_id":null,"body":"func GCD(x: Int, y: Int) -> Int {\n    var x = x, y = y\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}\n\nfunc decompose(_ nrStr: String, _ drStr: String) -> String {\n    var nr = Int(nrStr) ?? 0, dr = Int(drStr) ?? 0, res = [Int](), n = nr \/ dr\n    nr = nr % dr\n    while nr > 0 {\n        let v = dr \/ nr + (dr % nr != 0 ? 1 : 0), g = GCD(x: dr, y: v)\n        res.append(v)\n        (nr, dr) = ((nr * v - dr) \/ g, dr * v \/ g)\n    }\n    return ((n == 0 ? [] : [\"\\(n)\"]) + res.map { i -> String in \"1\/\\(i)\" }).joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340297,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n  let nrInt = Int(nrStr) ?? 0\n  let drInt = Int(drStr) ?? 0\n  \n  guard nrInt > 0 && drInt > 0 else { return \"\" }\n  \n  if drInt == nrInt {\n    return \"1\"\n  }\n  \n  if drInt % nrInt == 0 {\n    return \"1\/\\(drInt \/ nrInt)\"\n  }\n  \n  if nrInt % drInt == 0 {\n    return \"\\(nrInt \/ drInt)\"\n  }\n  \n  if  nrInt > drInt {\n    return \"\\(nrInt \/ drInt),\" + decompose(String(nrInt % drInt), String(drInt))\n  }\n  \n  let n = drInt\/nrInt + 1\n  \n  return \"1\/\\(n),\" + decompose(String(nrInt * n - drInt), String(drInt * n))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340298,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n    var result=Double(nrStr)!\/Double(drStr)!\n    if (result==0){return \"\"}\n    else if (floor(result)==result) {return String(Int(result))}\n    var fractions = \"\"\n    if (result>1){\n    fractions += String(format:\"%d,\",Int(result))\n    result -= Double(Int(result))\n    }\n    \n    while (true){\n    let i = ceil(Double(round(1000000*(1\/result))\/1000000))\n    result -= 1.0\/i\n    fractions += String(format:\"1\/%d,\",Int(i))\n    if (result<0.000000001) {break}\n    }\n    return String(fractions.dropLast())\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340299,"user_id":null,"body":"\nenum MyErrors: Error {\n    case invalidDenominator(String)\n}\n\nfunc leastCommonMultiply(_ d1: Int,_ d2: Int) -> Int {\n    var d1 = d1\n    var d2 = d2\n    let mult = d1 * d2\n    while d2 != 0 {\n        (d1, d2) = (d2, d1%d2)\n    }\n    return mult \/ d1\n}\n\n\nfunc mostCommonDenominantor(_ x: Int, _ y: Int) -> Int {\n\/\/    var tmp = 0\n    var x = x\n    var y = y\n    while y != 0 {\n        (x,y) = (y,x%y)\n    }\n    return x\n}\n\nstruct Fraction: Equatable {\n    var nom: Int\n    var denom: Int\n    \n    @discardableResult mutating func Mult(toDenominator: Int) throws -> Fraction {\n        if toDenominator % self.denom != 0 {\n            throw MyErrors.invalidDenominator(\"residue when dividing new denominator by old one\")\n        }\n        if toDenominator < self.denom {\n            throw MyErrors.invalidDenominator(\"new denominator should by larger by old one\")\n        }\n        let multiplier = toDenominator \/ self.denom\n        self.nom *= multiplier\n        self.denom *= multiplier\n        return self\n    }\n    \n    @discardableResult mutating func Add(_ second: Fraction) -> Fraction {\n        var second = second\n        if second.nom == 0 {\n            return self\n        }\n        if self.nom == 0 {\n            self.nom = second.nom\n            self.denom = second.denom\n            return self\n        }\n        let commonDenominator = leastCommonMultiply(self.denom, second.denom)\n        do {\n            try self.Mult(toDenominator: commonDenominator)\n            try second.Mult(toDenominator: commonDenominator)\n        } catch MyErrors.invalidDenominator(let errorMessage) {\n            print(\"when adding \\(self) and \\(second), error: \\(errorMessage)\")\n            exit(1)\n        } catch {\n            print(\"unknown error\")\n            exit(1)\n        }\n        self.nom += second.nom\n        return self\n    }\n    \n    mutating func RemoveWhole() -> Int {\n        let whole = self.nom \/ self.denom\n        self.nom = self.nom % self.denom\n        return whole\n    }\n    \n    func Diff(_ second: Fraction) -> Fraction {\n        var first = self\n        var second = second\n        if second.nom == 0 {\n            return self\n        }\n        if self.nom == 0 {\n            return Fraction(nom: -1 * second.nom, denom: -1 * second.denom)\n        }\n        let commonDenominator = leastCommonMultiply(self.denom, second.denom)\n        do {\n            try first.Mult(toDenominator: commonDenominator)\n            try second.Mult(toDenominator: commonDenominator)\n        } catch {\n            print (\"some error in fraction diff\")\n        }\n        return Fraction(nom: first.nom - second.nom, denom: commonDenominator)\n    }\n    \n    var reduced: Fraction {\n        let mcd = mostCommonDenominantor(self.nom, self.denom)\n        if mcd != 0 {\n            return Fraction(nom: self.nom\/mcd, denom: self.denom\/mcd)\n        }\n        return Fraction(nom: 0, denom: 0)\n    }\n    \n    static func == (lhs: Fraction, rhs: Fraction) -> Bool {\n        return (lhs.nom == 0 && rhs.nom == 0) || (lhs.nom == rhs.nom &&\n            lhs.denom == rhs.denom)\n    }\n    \n    static func FastComp(lhs: Fraction, rhs: Fraction) -> (result: Bool, failed: Bool) {\n        let lhsF = Float(lhs.nom)\/Float(lhs.denom)\n        let rhsF = Float(rhs.nom)\/Float(rhs.denom)\n        let diff1 = lhsF - rhsF\n        let diff2 = rhsF - lhsF\n        return (lhsF > rhsF, (diff1 > 0 && diff1 < 0.000001) || (diff2 > 0 && diff2 < 0.000001))\n    }\n    \n    static func > (lhs: Fraction, rhs: Fraction) -> Bool {\n        var lhs = lhs\n        var rhs = rhs\n        let lcd = leastCommonMultiply(lhs.denom, rhs.denom)\n        do {\n            try lhs.Mult(toDenominator: lcd)\n            try rhs.Mult(toDenominator: lcd)\n        } catch {\n            print(\"error during compare\")\n            exit(1)\n        }\n        return lhs.nom > rhs.nom\n    }\n    \n}\n\nfunc decompose(_ nrStr: String, _ drStr: String) -> String {\n    print(\"\\(nrStr) \/ \\(drStr)\")\n    var target = Fraction(nom: Int(nrStr) ?? 0, denom: Int(drStr) ?? 0).reduced\n    var sum = Fraction(nom: 0, denom: 0)\n    var list: [Int] = []\n    let whole = target.RemoveWhole()\n    var i = 2\n    repeat {\n        let prevSum = sum\n        sum.Add(Fraction(nom: 1, denom: i))\n        if sum > target {\n            sum = prevSum\n        } else {\n            list.append(i)\n            let rest = target.Diff(sum).reduced\n            if rest.nom == 1 {\n                list.append(rest.denom)\n                break\n            }\n        }\n        i += 1\n    } while sum.reduced != target\n    var ret = list.map{\"1\/\\($0)\"}\n    if whole > 0 {\n        ret.insert(\"\\(whole)\", at: 0)\n    }\n    return ret.joined(separator: \",\")\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340300,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n    var result = [String]()\n    var k = Int(nrStr)!\n    var n = Int(drStr)!\n    if k >= n {\n        result.append(\"\\(k \/ n)\")\n        k %= n\n    }\n    var nDivByK = 1\n    while k != 0 {\n        nDivByK = Int((Double(n) \/ Double(k)).rounded(.up))\n        result.append(\"1\/\\(nDivByK)\")\n        let tmp = k * nDivByK - n\n        n *= nDivByK\n        k = tmp\n    }\n    return result.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340301,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n    var result = [String]()\n    var k = Int(nrStr)!\n    var n = Int(drStr)!\n    if k > n {\n        result.append(\"\\(k \/ n)\")\n        k = k - (k \/ n) * n\n    }\n    var nDivByK = 1\n    while k != 0 {\n        nDivByK = Int((Double(n) \/ Double(k)).rounded(.up))\n        nDivByK == 1 ? result.append(\"1\") : result.append(\"1\/\\(nDivByK)\")\n        let tmp = k * nDivByK - n\n        n = n * nDivByK\n        k = tmp\n    }\n    return result.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340302,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n  if var nr = Int(nrStr), var dr = Int(drStr) {\n    if(nr == 0) { return \"\" }\n    if nr % dr == 0 { return String(nr \/ dr) }\n  \n    var result = [String]()\n  \n    while nr > 1 {\n      let cnr: Int = 1\n      var cdr: Int\n      var nnr: Int\n      var ndr: Int\n\n      if (nr \/ dr) > 1 {\n          let rest = Double(nr) \/ Double(dr)\n          result.append(String(Int(rest)))\n          nr -= Int(rest) * dr\n      }\n\n      cdr = Int(ceil(Double(dr) \/ Double(nr)))\n\n      if (cdr == 1) {\n        result.append(String(cnr))\n      } else {\n        result.append(\"\\(cnr)\/\\(Int(cdr))\")\n      }\n\n      nnr = nr * cdr - dr\n      ndr = dr * cdr\n\n      nr = nnr;\n      dr = ndr;\n\n      if nnr == 1 { result.append(\"\\(nnr)\/\\(ndr)\") }\n    }\n\n    return result.joined(separator: \",\")\n  }\n  \n  return \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340303,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n  if var nr = Double(nrStr), var dr = Double(drStr) {\n    if(nr == 0) { return \"\" }\n    if Int(nr) % Int(dr) == 0 { return String(Int(nr) \/ Int(dr)) }\n  \n    var result = [String]()\n  \n    while nr > 1 {\n      let cnr: Int = 1\n      var cdr: Double\n      var nnr: Double\n      var ndr: Double\n\n      if (nr \/ dr) > 1 {\n          result.append(\"\\(Int(nr \/ dr))\")\n          nr -= Double(Int(nr \/ dr)) * dr\n      }\n\n      cdr = ceil(dr \/ nr)\n\n      if (cdr == 1) {\n        result.append(String(cnr))\n      } else {\n        result.append(\"\\(cnr)\/\\(Int(cdr))\")\n      }\n\n      nnr = nr * cdr - dr\n      ndr = dr * cdr\n\n      nr = nnr;\n      dr = ndr;\n\n      if nnr == 1 { result.append(\"\\(Int(nnr))\/\\(Int(ndr))\") }\n    }\n\n    return result.joined(separator: \",\")\n  }\n  \n  return \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340304,"user_id":null,"body":"func decompose(_ nrStr: String, _ drStr: String) -> String {\n    var result = \"\"\n    guard let a = Int(nrStr), let b = Int(drStr) else { return result }\n    \n    guard a != 0 && b != 0 else {\n        return \"\"\n    }\n    \n    if (b > a)\n    {\n        let remainder: Int = b % a;\n        \n        var divisor: Int = b \/ a;\n        if (remainder  != 0)\n        {\n            divisor += 1;\n            result += \"1\/\\(divisor),\\(decompose(String(a * divisor - b), String(b * divisor)))\"\n        }\n        else\n        {\n            result += \"1\/\\(divisor)\"\n        }\n    }\n    else\n    {\n        result += \"\\(a\/b)\"\n        if a % b != 0 && b != 0 {\n          result += \",\\(decompose(String(a % b), String(b)))\"\n        }\n      \n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5503013e34137eeeaa001648":[{"id":340305,"user_id":992,"body":"func diamond(_ size: Int) -> String? {\n    guard size > 0 && size % 2 == 1 else {\n        return nil\n    }\n    var diamond = \"\"\n    let centerRow = size\/2 + 1\n    for row in 1...size {\n        let spaces = abs(centerRow - row)\n        diamond += String(repeating: \" \", count: spaces) + String(repeating: \"*\", count: size-spaces*2) + \"\n\"\n    }\n    return diamond\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340306,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n  guard size > 0 && size % 2 == 1 else { return nil }\n  var dmnd = \"\"\n  let centerRow = size\/2 + 1\n  (1...size).forEach {\n    let spc = abs(centerRow - $0)\n    dmnd += String(repeating: \" \", count: spc) + String(repeating: \"*\", count: size-spc * 2) + \"\n\"\n  }\n  return dmnd\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340307,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n  guard size > 0 else { return nil }\n  guard size % 2 == 1 else { return nil }\n  let upperHalf = (0..<(size \/ 2 + 1))\n    .map { String(repeating: \" \", count: size \/ 2 - $0) + String(repeating: \"*\", count: 2 * $0 + 1) + \"\n\" }\n  let lowerHalf = (0..<(size \/ 2)).reversed()\n    .map { String(repeating: \" \", count: size \/ 2 - $0) + String(repeating: \"*\", count: 2 * $0 + 1) + \"\n\" }\n  return (upperHalf + lowerHalf).reduce(\"\", +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340308,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n    if size == 1 {return \"*\n\"}\n    if size < 1 || size % 2 == 0 {return nil}\n    let centr = size \/ 2\n    var res = \"\"\n    for i in (0...size) {\n        for j in (0...size) {\n            if (i <= centr) {\n                if (j >= centr - i && j <= centr + i) {\n                    res += \"*\"\n                } else {\n                    if res.last == \"*\" {} else {\n                    res += \" \"\n                    }\n                }\n            } else {\n                if (j >= centr + i - size + 1 && j <= centr - i + size - 1) {\n                    res += \"*\"\n                } else {\n                    if res.last == \"*\" {} else {\n                        res += \" \"\n                    }\n                }\n            }\n        }\n        res += \"\n\"\n    }\n      if size == 3 { for _ in (2...6) {res.removeLast() } } else {\n        for _ in (0...6) { res.removeLast() }\n    }\n           for _ in res.reversed() {\n        if res.last == \" \" {res.removeLast()}\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340309,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n  guard (size % 2 != 0 &&  size > 0) else { return nil }\n  var result = String(repeating: \"*\", count: size) + \"\n\"\n  for number in stride(from: size-2, to: 0, by: -2) {\n    let row = String(repeating: \" \", count: (size - number) \/ 2) + String(repeating: \"*\", count: number) + \"\n\"\n    result = row + result + row\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340310,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n  \n  guard size % 2 == 1 && size > 0 else { return nil }\n  var diamond = [String]()\n  \n  for i in (0..<size) {\n    let padding: [String] = [String](repeating: \" \", count: abs(size\/2-i))\n    let stars: [String] = [String](repeating: \"*\", count: size-padding.count*2)\n    let line: String = [padding,stars].flatMap{$0!}.joined()  + \"\n\"\n    diamond.append(line)\n  }\n\n  return diamond.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340311,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n    if size%2 == 0 || size <= 0 { return nil }\n    var result = \"\", maper = 1\n    for count in 0..<size {\n        result += String(repeatElement(\" \", count: abs(size\/2 - count))) + String(repeatElement(\"*\", count: maper)) + \"\n\"\n        if count < size\/2 { maper += 2\n        }else { maper -= 2 }\n    }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340312,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n  if size % 2 == 1 {\n    var spaces = 2, level = \"\", diamond = createLine(0,size) \/\/ Create middle line first for efficiency\n    while spaces < size { \/\/ While its not the last level of the diamond\n      level = createLine(spaces\/2,size-spaces) \/\/ Divide space for symmetry, non-space are stars\n      diamond = level + diamond + level \/\/ Sandwich the middle\n      spaces = spaces + 2 \/\/ Each line away from the middle adds 2 space\n    }\n    return diamond\n  } else {\n    return nil\n  }\n}\n\nfunc createLine(_ spaces: Int, _ stars: Int) -> String {\n  return String(repeating: \" \", count: spaces) + String(repeating: \"*\", count: stars) + \"\n\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340313,"user_id":null,"body":"func diamond(_ size: Int) -> String? {\n    guard size % 2 != 0 && size > 0 else { return nil }\n    var diamond: [String] = []\n    var tierWidth = size\n    \n    while tierWidth > 0 {\n        let tierString = (String(repeating: \" \", count: (size - tierWidth) \/ 2)  + String(repeating: \"*\", count: tierWidth) + \"\n\")\n        if !diamond.isEmpty {\n            diamond.insert(tierString, at: 0)\n        }\n        diamond.append(tierString)\n        tierWidth -= 2\n    }\n    return diamond.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340314,"user_id":null,"body":"func rowString(size: Int, stars: Int) -> String {\n    let numSpace = (size - stars) \/ 2\n    return String(repeating: \" \", count: numSpace) + String(repeating: \"*\", count: stars)\n}\n\nfunc starCounts(size: Int) -> [Int] {\n    return stride(from: size, to: 0, by: -2).reduce([]) { (partialResult, nextNumber) -> [Int] in\n        var array = [nextNumber]\n        if !partialResult.isEmpty {\n            array += partialResult\n            array += [nextNumber]\n        }\n        return array\n    }\n}\n\nfunc diamond(_ size: Int) -> String? {\n    guard size > 0, size % 2 == 1 else { return nil }\n\n    let rows = starCounts(size: size).map { rowString(size: size, stars: $0) }\n    return rows.joined(separator: \"\n\") + \"\n\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55031bba8cba40ada90011c4":[{"id":340315,"user_id":492,"body":"func isCubic(_ s: String) -> Bool {\n    let sum = s.enumerated().reduce(0) {\n        let n = Int(String($1.1))!\n        return $0 + n * n * n\n    }\n    return sum == Int(s)!\n}\nfunc isSumOfCubes(_ s: String) -> String {\n    var a = matches(for: \"\\\\d{1,3}\", in: s)\n        .filter { isCubic($0) }\n        .map( { (t: String) -> Int in return Int(t)! } )\n    if !a.isEmpty {\n        let sum: Int = a.reduce(0, +)\n        a.append(sum)\n        let arr = a.map( { (x: Int) -> String in return String(x) } )\n        return arr.joined(separator: \" \") + \" Lucky\"\n    }\n    return \"Unlucky\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340316,"user_id":null,"body":"func isHiddenCube(_ number: String) -> Int {\n    if Int(number) != nil {\n        let cube = Int(number.map { Double(Int(\"\\($0)\")!) }.reduce(0) { $0 + pow($1, 3) })\n        return cube == Int(number)! ? cube : -1\n    }\n    \n    return -1\n}\n\nfunc isSumOfCubes(_ s: String) -> String {\n    var number = \"\"\n    \n    let sumOfCubes: [Int] = s.enumerated().map {\n        if !$0.element.isNumber {\n            defer { number = \"\" }\n            return number == \"\" ? -1 : isHiddenCube(number)\n        }\n        \n        number += \"\\($0.element)\"\n        \n        if number.count == 3 {\n            defer { number = \"\" }\n            return isHiddenCube(number)\n        }\n        \n        if $0.offset == (s.count - 1) && $0.element.isNumber {\n            return isHiddenCube(number)\n        }\n        \n        return -1\n    }.filter { $0 != -1 }\n    \n    return sumOfCubes.isEmpty ? \"Unlucky\" : \"\\(sumOfCubes.map{\"\\($0)\"}.joined(separator: \" \")) \\(sumOfCubes.reduce(0, +)) Lucky\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340317,"user_id":null,"body":"func isSumOfCubes(_ s: String) -> String {\n  \n  let charSet = CharacterSet.decimalDigits.inverted\n  let nrArr = s.components(separatedBy: charSet).compactMap{String($0)}.filter{$0 != \"\"}\n  var nrOfCubic = \"\"\n  var result = 0\n\n  for nr in nrArr {\n\n    if nr.count > 3 {\n      let resArr = splitIntoThree(nr)\n      for n in resArr{\n        if let nr = Int(n.reduce(\"\",+)) {\n          if isCubic(nr) {\n            nrOfCubic += String(nr) + \" \"\n            result += nr\n          }\n        }\n      }\n\n    } else {\n        if let nr = Int(nr) {\n          if isCubic(nr) {\n            nrOfCubic += String(nr) + \" \"\n            result += nr\n          }\n        }\n      }\n  }\n  \n  return nrOfCubic != \"\" ? \"\\(nrOfCubic)\\(result) Lucky\" : \"Unlucky\"\n}\n\nfunc splitIntoThree(_ n: String) -> [[String]] {\n  let newArr = String(n).compactMap { String($0) }\n  let chunks = stride(from: 0, to: newArr.count, by: 3).map {\n            Array(newArr[$0 ..< min($0 + 3, newArr.count)])\n        }\n  return chunks\n}\n\nfunc isCubic (_ number: Int)->Bool {\n  let nrArr = String(number).compactMap { Int(String($0)) }\n  var result = 0\n  for n in nrArr {\n    result += n*n*n\n  }\n  return number != result ? false: true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340318,"user_id":null,"body":"func isSumOfCubes(_ s: String) -> String {\n    let range = NSRange(location: 0, length: s.utf16.count)\n    let regex = try! NSRegularExpression(pattern: \"\\\\d{1,3}\",\n                                         options: .caseInsensitive)\n    var a = regex.matches(in: s, range: range)\n        .filter { String(s[Range($0.range, in: s)!]).isCubic() }\n        .map( { Int(String(s[Range($0.range, in: s)!]))! })\n    if !a.isEmpty {\n        let sum: Int = a.reduce(0, +)\n        a.append(sum)\n        let arr = a.map( { (x: Int) -> String in return String(x) } )\n        return arr.joined(separator: \" \") + \" Lucky\"\n    }\n  \n    return \"Unlucky\"\n}\n\nextension String {\n    func isCubic() -> Bool {\n        let sum = self.enumerated().reduce(0) {\n            let n = Int(String($1.1))!\n            return $0 + n * n * n\n        }\n      \n        return sum == Int(self)!\n    }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340319,"user_id":null,"body":"extension String {\n    func components(withLength length: Int) -> [String] {\n        return stride(from:0, to: self.count, by: length).map {\n            let start = self.index(self.startIndex, offsetBy: $0)\n            let end = self.index(start, offsetBy: length, limitedBy: self.endIndex) ?? self.endIndex\n            return String(self[start ..< end])\n        }\n    }\n}\n\nfunc isSumOfCubes(_ s: String) -> String {\n    \n    var nums: [String] = []\n    \n    for string in s.components(separatedBy: \" \") {\n        var currentNum = \"\"\n        for char in string{\n            if Int(String(char)) == nil {\n                continue\n            }else {\n                currentNum += String(char)\n            }\n        }\n        if currentNum != \"\" && currentNum.count <= 3{\n            \n            nums.append(String(Int(currentNum) ?? 0))\n        } else {\n            for i in currentNum.components(withLength: 3){\n                \n                nums.append(String(Int(i) ?? 0))\n            }\n        }\n        \n    }\n    \n    print(nums)\n    \n    var result: [String] = []\n    \n    for str in nums {\n        let base = Int(str) ?? 0\n        \n        let cubes = str.map{ pow(Double(String($0)) ?? 0, 3) }.reduce(0, +)\n        \n        if base == Int(cubes) {\n            result.append(str)\n        }\n    }\n    \n    if result.isEmpty {\n        return \"Unlucky\"\n    } else {\n        let sum = result.map{ Int($0) ?? 0 }.reduce(0, +)\n        result.append(String(sum))\n        result.append(\"Lucky\")\n        return result.joined(separator: \" \")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340320,"user_id":null,"body":"func isSumOfCubes(_ s: String) -> String {\n  let stringTriades = getTridadeStrings(s)\n  let stringCubicValues = stringTriades.filter(isCubicValue)\n  if stringCubicValues.isEmpty {\n    return \"Unlucky\"\n  }\n  let cubicSum = stringCubicValues.compactMap {Int($0)}.reduce(0, +)\n  return stringCubicValues.joined(separator: \" \") + \" \" + String(cubicSum) + \" Lucky\"\n}\n\nprivate func isCubicValue(_ s: String) -> Bool {\n  let actualValue = Int(s)!\n  let cubicValues = s.compactMap { pow(Double(String($0))!, 3) }\n  let cubicSum = cubicValues.reduce(0, +)\n  return actualValue == Int(cubicSum)\n}\n\nprivate func getTridadeStrings(_ s: String) -> [String] {\n  var triades = [String]()\n  let triadeMaxLength = 3\n  var currentTriade = \"\"\n  for char in s {\n    guard char.isNumber else {\n      if !currentTriade.isEmpty {\n        triades.append(String(Int(currentTriade)!))\n        currentTriade = \"\"\n      }\n      continue\n    }\n    currentTriade.append(char)\n    if currentTriade.count == triadeMaxLength {\n       triades.append(String(Int(currentTriade)!))\n       currentTriade = \"\"\n    }\n  }\n  if !currentTriade.isEmpty {\n    triades.append(String(Int(currentTriade)!))\n  }\n  return triades\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340321,"user_id":null,"body":"import Foundation\nfunc isSumOfCubes(_ s: String) -> String {\n    var digits = s.components(separatedBy: CharacterSet.decimalDigits.inverted).filter{$0 != \"\"}\n    var tmpArr = [String]()\n    for i in 0..<digits.count {\n        while digits[i].count > 3 {\n            let subStr = digits[i].prefix(3)\n            digits[i].removeFirst(subStr.count)\n            tmpArr.append(String(subStr))\n        }\n        tmpArr.append(digits[i])\n    }\n    var outArr = [String]()\n    for i in tmpArr {\n        var sum = 0.0\n        for char in i {\n            sum += pow(Double(String(char))!, 3.0)\n        }\n        if sum == Double(i)! {\n            outArr.append(i)\n        }\n    }\n    if !outArr.isEmpty {\n        return outArr.map{String(Int($0)!)}.joined(separator: \" \") + \" \\(outArr.map{Int($0)!}.reduce(0, +)) Lucky\"\n    }\n    return \"Unlucky\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340322,"user_id":null,"body":"func isSumOfCubes(_ s: String) -> String {\n    let cubicNumbers = extractDigitGroups(from: s).filter { isCubicNumber(string: $0) }\n    if cubicNumbers.isEmpty {\n        return \"Unlucky\"\n    } else {\n        return cubicNumbers.map { String(Int($0)!) }.joined(separator: \" \") + \" \\(cubicNumbers.reduce(0) { $0 + Int($1)! }) Lucky\"\n    }\n}\n\nprivate func extractDigitGroups(from string: String) -> [String] {\n    var result = [String]()\n    var intermittentResult = \"\"\n    string.forEach {\n        if intermittentResult.count == 3 {\n            result.append(intermittentResult)\n            intermittentResult = \"\"\n        }\n\n        if $0.isASCII && $0.isNumber {\n            intermittentResult.append($0)\n        } else if !intermittentResult.isEmpty {\n            result.append(intermittentResult)\n            intermittentResult = \"\"\n        }\n    }\n    if !intermittentResult.isEmpty {\n        result.append(intermittentResult)\n    }\n\n    return result\n}\n\nprivate func isCubicNumber(string: String) -> Bool {\n    let digits = string.map { Int(String($0))! }\n    return digits.reduce(0, { $0 + $1 * $1 * $1 }) == Int(string)!\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340323,"user_id":null,"body":"func isSumOfCubes(_ s: String) -> String {\n  guard let regexp = try? NSRegularExpression(pattern: \"([\\\\d]{1,3})\", options: .caseInsensitive)\n          else {\n        return \"Unlucky\"\n    }\n    let sRange = s.startIndex..<s.endIndex\n    let oRange = NSRange(sRange, in: s)\n    \n    let matches = regexp.matches(in: s, range: oRange)\n    let numbers: [String] = matches.compactMap { result in\n        let range = Range(result.range(at: 0), in: s)!\n        return String(s[range])\n    }\n    \n    let resultList: [String] = numbers.compactMap { str in\n        guard let number = Int(str) else { return nil }\n               \n        let cubicResult: Int = str.reduce(0) { partialResult, ch in\n            if let chNum = ch.wholeNumberValue {\n               return partialResult + chNum*chNum*chNum\n            }\n            else {\n                return partialResult\n            }\n        }\n        \n        return number == cubicResult ? str : nil\n    }\n    \n    if resultList.count > 0 {\n        let list = resultList.compactMap {Int($0)}.compactMap {String($0)}.joined(separator: \" \")\n        let sum = resultList.compactMap {Int($0)}.reduce(0, (+))\n        return \"\\(list) \\(sum) Lucky\"\n    }\n    else {\n        return \"Unlucky\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340324,"user_id":null,"body":"func isSumOfCubes(_ s: String) -> String {\n  var numbers = [String]()\n  var running = \"\"\n  \n  for char in s {\n    if (char.isASCII && char.isNumber) {\n      running.append(char)\n      if (running.count == 3) {\n        numbers.append(running)\n        running = \"\"\n      }\n    }\n    else {\n      if (running.count > 0) {\n        numbers.append(running)\n        running = \"\"\n      }\n    }\n  }\n  if (running.count > 0) {\n    numbers.append(running)\n  }\n  \n  let cubes = numbers.filter { number in\n    number.map { c in \n      let i = Int(String(c))!\n      return i * i * i }.reduce(0, +) == Int(number)! }\n\n  if (cubes.count > 0) {\n    let ints = cubes.map { Int($0)! }\n    let sum = ints.reduce(0, +)\n    return ints.map { String($0) }.joined(separator: \" \") + \" \\(sum) Lucky\"\n  } else {\n    return \"Unlucky\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"550498447451fbbd7600041c":[{"id":340325,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n    return a.map{ $0 * $0 }.sorted() == b.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340326,"user_id":492,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n    let a1 = a.map( { (s: Int) -> Int in return s * s } ) \n    return a1.sorted() == b.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340327,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n\n    let squareA = a.map({\n        value -> Int in\n        return value * value\n    })\n    \n    return squareA.sorted() == b.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340328,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n  let aCounts = a.reduce(into: [:]) { counts, digit in counts[digit*digit, default: 0] += 1 }\n  let bCounts = b.reduce(into: [:]) { counts, digit in counts[digit, default: 0] += 1 }\n\n  return aCounts == bCounts\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340329,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n    if a.isEmpty && b.isEmpty {\n        return true\n    }\n    var bCopy = b\n    for elem in a {\n        guard let idx = bCopy.index(of: elem * elem) else {\n            return false\n        }\n        bCopy.remove(at: idx)\n    }\n    return bCopy.count == 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340330,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n    return a.map{$0 * $0}.sorted() == b.sorted() \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340331,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n    \/\/ your code\n  \n  \/\/Verify counts match\n  if a.count != b.count{\n    return false\n  }\n  var matchArray = b\n  \/\/check for square matches\n  for num in a{\n  \/\/square number to Int \n    let x = Int(num * num)\n   \/\/verify number exists\n    if let index = matchArray.firstIndex(of: x){\n      \/\/remove number at index\n      matchArray.remove(at:index)\n    }else{\n      \/\/exit\n      return false\n    }\n   \n  }\n  return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340332,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n  if a.isEmpty || b.isEmpty { return true }\n  if a.count != b.count { return false }\n  for element in a {\n    let hasSquared = b.filter { $0 \/ element == element }.count > 0\n    let elementOccurences = a.filter { $0 == element }.count\n    let squaredOccurences = b.filter { $0 == element * element }.count\n    if elementOccurences != squaredOccurences { return false }\n    if !hasSquared { return false }\n  }\n  for element in b {\n    let isSquared = a.filter { $0 * $0 == element}.count > 0\n    if !isSquared { return false }\n  }\n  return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340333,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n    \n    if a.map({$0*$0}).sorted(by: >) == b.sorted(by: >) {\n        return (true)\n    } else {\n        return (false)\n    }\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340334,"user_id":null,"body":"func comp_same(_ a: [Int], _ b: [Int]) -> Bool {\n  if a.count != b.count { return false }\n  return a.map { $0 * $0 }.sorted() == b.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"550527b108b86f700000073f":[{"id":340335,"user_id":null,"body":"\/\/ use String(format: \"%.10f\", ...) for the rounding\n\nfunc iterPi(_ epsilon: Double) -> (Int, String) {\n    var pi = 1.0, i = 0\n\n    while abs(Double.pi - 4 * pi) > epsilon {\n        i += 1\n        pi += ( pow(Double(-1), Double(i)) \/ Double(2*i + 1) )\n    } \n\n    return ( i + 1, String(format: \"%.10f\", pi * 4) )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340336,"user_id":492,"body":"func iterPi(_ epsilon: Double) -> (Int, String) {\n    let PI: Double = 3.14159265358979323846\n    var divisor: Double = 1.0\n    var sign: Double = 1.0\n    var count: Int = 0\n    var sum: Double = 0.0\n    while abs(sum - PI) > epsilon {\n        sum += sign * 4.0 \/ divisor\n        divisor += 2.0\n        sign *= -1.0\n        count += 1\n    }\n    return (count, String(format: \"%.10f\", sum))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340337,"user_id":null,"body":"func iterPi(_ epsilon: Double) -> (Int, String) {\n    var res = 4.0, i = 3.0\n    while(abs(Double.pi - res) > epsilon) {\n        res = Int(i) % 4 == 3 ? res - 4\/i : res + 4\/i\n        i+=2\n    }\n    return ( Int(i\/2), String(format: \"%.10f\", res) )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340338,"user_id":null,"body":"func iterPi(_ epsilon: Double) -> (Int, String) {\n    var aprox: Double = 0\n    var i = 1\n    \n    while abs(Double.pi - (aprox * 4)) > epsilon {\n        if i % 2 == 0 { aprox -= Double(1) \/ Double(2 * i - 1) } else { aprox += Double(1) \/ Double(2 * i - 1) }\n        i += 1\n    }\n\n    return (i - 1, String(format: \"%.10f\", aprox * 4))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340339,"user_id":null,"body":"func iterPi(_ epsilon: Double) -> (Int, String) {\n    var curr = 1.0\n    var pi4 = 0.0\n    var sign = 1.0\n    var ans = 0\n    while abs(pi4 * 4 - Double.pi) >= epsilon {\n        pi4 += sign\/curr\n        sign *= -1\n        curr += 2\n        ans += 1\n    }\n    return (ans, String(format: \"%.10lf\", pi4*4))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340340,"user_id":17,"body":"\/\/ use String(format: \"%.10f\", ...) for the rounding\n\nfunc iterPi(_ epsilon: Double) -> (Int, String) {\n  var myPi : Double = 0.0, i : Int = 0\n  while abs(myPi - Double.pi) > epsilon {\n    myPi += 4.0 * (i % 2 == 0 ? 1.0 : -1.0) \/ Double(2 * i + 1)\n    i += 1\n  }\n  return (i, String(format: \"%.10f\", myPi))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340341,"user_id":null,"body":"\/\/ use String(format: \"%.10f\", ...) for the rounding\n\nfunc iterPi(_ epsilon: Double) -> (Int, String) {\n    let realPi = Double.pi\n    var myPi_4: Double = 1\n    var iteration: Int = 1\n    while (abs(realPi - myPi_4 * 4) > epsilon) {\n        let multiplier: Double = iteration % 2 == 0 ? 1 : -1\n        let divider = Double(iteration * 2 + 1)\n        let value: Double = multiplier * (Double(1) \/ divider)\n        myPi_4 = myPi_4 + value\n        iteration += 1\n    }\n    return (iteration, String(format: \"%.10f\", myPi_4 * 4))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340342,"user_id":492,"body":"func iterPi(_ epsilon: Double) -> (Int, String) {\n    let PI: Double = 3.14159265358979323846\n    var divisor: Double = 1.0\n    var sign: Double = 1.0\n    var count: Int = 0\n    var sum: Double = 0.0\n    while abs(sum - PI) > epsilon {\n        sum += sign * 4.0 \/ divisor\n        divisor += 2.0\n        sign *= -1.0\n        count += 1\n    }\n    return (count, String(format: \"%.10f\", sum))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340343,"user_id":null,"body":"func iterPi(_ epsilon: Double) -> (Int, String) {\n    \n    let \u03c0 = Double.pi\n    var p :Double = 0\n    var n : Int = 0\n    var sign :Double = 1\n    \n    while (abs(\u03c0 - 4 * p) > epsilon) {\n        p = p + sign \/ (2.0 * Double(n) + 1.0)\n        n += 1\n        sign = -sign\n    }\n    \n    return (n, String(format: \"%.10f\", 4 * p))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340344,"user_id":null,"body":"\/\/ use String(format: \"%.10f\", ...) for the rounding\n\nfunc iterPi(_ epsilon: Double) -> (Int, String) {\n  var leibnizPi = 0.0\n  var k = 0\n  while(abs(Double.pi - leibnizPi) >= epsilon) {\n    leibnizPi += 4*(pow(-1.0, Double(k))\/Double(2*k + 1))\n    k += 1\n  }\n\n  return (k, String(format: \"%.10f\",leibnizPi))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"550554fd08b86f84fe000a58":[{"id":340345,"user_id":527,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n    return Set(a1.filter { s1 in a2.contains { $0.contains(s1) } }).sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340346,"user_id":492,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n    var res = [String]()\n    for s1 in a1 {\n        for s2 in a2 {\n            if s2.range(of: s1) != nil {\n                if !res.contains(s1) {res.append(s1)}\n            }\n        }\n    }\n    return res.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340347,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n    \/\/ your code\n    \/\/Create an empty string array to collect strings in a2 that have word in a1 as their substrings\n   var intersection = [String]()\n    \n    \/\/Loops over words in a1\n    for word in a1 {\n    \n    \/\/loops over content of a2 with word from a1\n        a2.forEach {\n        \/\/Checks current word in a2 to find out if it has the word from a1 as a substring\n            if $0.contains(word){\n            \n            \/*if word from a2 has word from a1 as substring; check if the intersection array doesn't contain it already.\n            if it doesn't append it\n            *\/\n                if !intersection.contains(word){\n                    intersection.append(word)\n                }\n            }\n        }\n    }\n    return intersection.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340348,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n    var foundSubstrings = [String]()\n    \n    for needle in a1 {\n      for haystack in a2 {\n        if haystack.range(of: needle) != nil {\n            foundSubstrings.append(needle)\n            break\n        }\n      }\n    }\n    \n    return Set(foundSubstrings).sorted();\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340349,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n  return a1.filter { char in a2.reduce(false,  { $0 || $1.contains(char)}) }.unique.sorted()\n}\n\nextension Array where Element : Hashable {\n    var unique: [Element] {\n        return Array(Set(self))\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340350,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n  var newArray = [String]()\n  a1.map { item  in\n     a2.map({ if $0.contains(item) == true {newArray.append(item)}})\n  }\n  return Array(Set(newArray)).sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340351,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n  \/\/ your code\n    return Array (Set(a1.map { str in\n        return a2.filter({$0.contains(str)}).count > 0 ? str : \"\"\n    }.filter({!$0.isEmpty}))).sorted(by: <)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340352,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n\n  var set: Set<String> = []\n  \n  a1.forEach { a1Str in \n    for a2Str in a2 {\n      if a2Str.contains(a1Str) {\n        set.insert(a1Str)\n        break\n      }\n    }\n  }\n  return Array(set).sorted { $0 < $1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340353,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n  return Set(a1.filter { s1 in a2.contains { s2 in s2.contains(s1) } }).sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340354,"user_id":null,"body":"func inArray(_ a1: [String], _ a2: [String]) -> [String] {\n    return Set(a1).filter { item in\n        a2.first(where: { $0.contains(item) }) != nil\n    }.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5508249a98b3234f420000fb":[{"id":340355,"user_id":492,"body":"func shiftMod(_ sign: Int, _ shift: Int, _ k: Int) -> Int {\n    return modulus(sign * (shift + k), 26)\n}\n\nfunc moving_shiftAux(_ s: String, _ shift: Int, _ sign: Int) -> String {\n    let ch = [UInt8](s.utf8)\n    var res = [UInt8]()\n    var d: Int\n    for (k, c) in ch.enumerated() {\n        let sVal = shiftMod(sign, shift, k)\n        if c >= 65 && c <= 90 {\n            d = (Int(c) - 65 + sVal) % 26 + 65\n        } else {\n            if c >= 97 && c <= 122 {\n                d = (Int(c) - 97 + sVal) % 26 + 97\n            } else {d = Int(c)}\n        }\n        res.append(UInt8(d))\n    }\n    return String(res.reduce(\"\", { $0 + String(format: \"%c\", $1)}).characters)\n}\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n    let v = moving_shiftAux(s, shift, 1) \n    return chunk(v, 5)\n}\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    let s = arr.joined(separator: \"\")\n    return moving_shiftAux(s, shift, -1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340356,"user_id":null,"body":"let alphabeth = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\nextension String {\n    func components(_ length: Int) -> [String] {\n        return stride(from:0, to: self.count, by: length).map {\n            let start = self.index(self.startIndex, offsetBy: $0)\n            let end = self.index(start, offsetBy: length, limitedBy: self.endIndex) ?? self.endIndex\n            return String(self[start ..< end])\n        }\n    }\n}\n\nfunc Coder(_ s:String, _ shift:Int) -> String{\n    var currentShift = shift\n    return Array(s).map { (char) -> String in\n        if let safeChar = alphabeth.enumerated().filter({$1 == String(char.lowercased())}).first{\n            let newOffset = (safeChar.offset + currentShift) % alphabeth.count\n            let result = alphabeth.enumerated().first{$0.offset == (newOffset >= 0 ? newOffset : alphabeth.count + newOffset)}!.element\n            currentShift += currentShift < 0 ? -1 : 1\n            return char.isUppercase ? result.uppercased() : result\n        }\n        currentShift += currentShift < 0 ? -1 : 1\n        return String(char)\n    }.joined()\n}\n\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n    let result = Coder(s, shift)\n    var arrResult = result.components(result.count % 5 == 0 ? result.count \/ 5 : result.count \/ 5 + 1)\n    if arrResult.count<5{\n        for _ in arrResult.count..<5 {\n            arrResult.append(\"\")\n        }\n    }\n    return arrResult\n}\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    return Coder(arr.joined(), -shift)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340357,"user_id":null,"body":"func moving_shift(_ s: String, _ shift: Int) -> [String] {\n    var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".map({ String($0) })\n    var offset = shift\n    var sentence = String()\n    var arr = [String]()\n    \n    caesarCipherOperation(s, &sentence, &offset, &alphabet)\n    \n    var word = String()\n    let chunk = Double(sentence.count) \/ 5\n    var numberOfCharInChunk = Int()\n    var isADecimalNumber = false\n    \n    checkTheNatureOfTheNumber(chunk, &numberOfCharInChunk, &isADecimalNumber)\n    \n    splitTheSentence(&sentence, &word, numberOfCharInChunk, &arr, isADecimalNumber)\n    \n    if arr.count < 5 { arr.append(\"\") }\n    return arr\n}\n\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    \n    var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".reversed().map({ String($0) })\n    var offset = shift\n    var sentence = String()\n    \n    caesarCipherOperation(arr.joined(), &sentence, &offset, &alphabet)\n    \n    return sentence\n}\n\nprivate func caesarCipherOperation(_ s: String, _ sentence: inout String, _ offset: inout Int, _ alphabet: inout [String]) {\n    for char in s {\n        if !char.isLetter {\n            addCharToSentence(&sentence, String(char), &offset)\n            continue\n        }\n        \n        handleTheLetterToAdd(&alphabet, char, &sentence, &offset)\n    }\n}\n\nprivate func addCharToSentence(_ sentence: inout String, _ char: String, _ offset: inout Int) {\n    sentence.append(char)\n    offset += 1\n}\n\nprivate func handleTheLetterToAdd(_ alphabet: inout [String], _ char: String.Element, _ sentence: inout String, _ offset: inout Int) {\n    let indexForChar = alphabet.firstIndex(of: char.uppercased()) ?? 0\n    \n    if (indexForChar + offset) > (alphabet.count - 1) {\n        alphabet.append(contentsOf: alphabet)\n    }\n    \n    let lowercased = alphabet[indexForChar + offset].lowercased()\n    let uppercased = alphabet[indexForChar + offset]\n    let characterToAdd = char.isLowercase ? lowercased : uppercased\n    \n    addCharToSentence(&sentence, characterToAdd, &offset)\n}\n\nprivate func checkTheNatureOfTheNumber(_ chunk: Double, _ numberOfCharInChunk: inout Int, _ isADecimalNumber: inout Bool) {\n    if floor(chunk) == chunk {\n        numberOfCharInChunk = Int(chunk)\n    } else {\n        numberOfCharInChunk = Int(chunk + 1)\n        isADecimalNumber = true\n    }\n}\n\nprivate func splitTheSentence(_ sentence: inout String, _ word: inout String, _ numberOfCharInChunk: Int, _ arr: inout [String], _ isADecimalNumber: Bool) {\n    for (index, char) in sentence.enumerated() {\n        word += String(char)\n        \n        if (index + 1).isMultiple(of: numberOfCharInChunk) {\n            arr.append(word)\n            word.removeAll()\n        }\n        \n        if isADecimalNumber && index == (numberOfCharInChunk * 4) {\n            arr.append(sentence)\n        }\n        \n        sentence.removeFirst()\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340358,"user_id":null,"body":"func moving_shift(_ s: String, _ shift: Int) -> [String] {\n  var str = String()\n  var result = [\"\", \"\", \"\", \"\", \"\"]\n  var part = Int((Double(s.count) \/ 5).rounded(.up))\n  var start = s.startIndex\n  var end = s.index(s.startIndex, offsetBy: part - 1)\n  var strcount = s.count\n  let alph = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  for (i, char) in s.enumerated() {\n    if char.isLetter {\n      if char.isUppercase { str += alph[(alph.firstIndex(of: String(char).lowercased())! + shift + i) % 26].uppercased() } else { str += alph[(alph.firstIndex(of: String(char))! + shift + i) % 26] }\n      } else { str += String(char) }\n  }\n\n  for i in 0..<5 {\n      if strcount > 0 {\n      result[i] = String(str[start...end])\n      strcount -= part\n        if part > strcount {\n          part = strcount\n        }\n      start = str.index(end, offsetBy: 1)\n      end = str.index(end, offsetBy: part)\n      }\n  }\n  return result\n}\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n  let alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  let alph = Array(alphabet.reversed())\n  let s = arr.joined(separator: \"\")\n  var str = \"\"\n  for (i, char) in s.enumerated() {\n    if char.isLetter {\n      if char.isUppercase { str += alph[(alph.firstIndex(of: String(char).lowercased())! + shift + i) % 26].uppercased() } else { str += alph[(alph.firstIndex(of: String(char))! + shift + i) % 26] }\n      } else { str += String(char) }\n  }\n    return str\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340359,"user_id":null,"body":"let AAscii = 65\nlet ZAscii = 90\nlet aAscii = 97\nlet zAscii = 122\nlet bigLettersRange = 65 ... 90\nlet smallLettersRange = 97 ... 122\nlet numberOfLetters = 26\nlet numberOfArrayElements = 5\n\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n    let encoded = encode(text: s, shift: shift, operation: +)\n    \n    var result = split(encoded, Int(ceil(Double(encoded.characters.count) \/ Double(numberOfArrayElements))))\n    while result.count < numberOfArrayElements {\n        result.append(\"\")\n    }\n    return result\n}\n\nfunc split(_ str: String, _ count: Int) -> [String] {\n    return stride(from: 0, to: str.characters.count, by: count).map { i -> String in\n        let startIndex = str.index(str.startIndex, offsetBy: i)\n        let endIndex   = str.index(startIndex, offsetBy: count, limitedBy: str.endIndex) ?? str.endIndex\n        return String(str[startIndex..<endIndex])\n    }\n}\n\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    let text = arr.reduce(\"\") { (result, value) -> String in\n        return result + value\n    }\n    \n    return encode(text: text, shift: shift, operation: -)\n}\n\nfunc encode(text: String, shift: Int, operation: ((Int, Int) -> Int)) -> String {\n    var shift = shift\n    return text.asciiArray.map({ (asciiValue) -> String in\n        var result = asciiValue\n        \n        var value = 0\n        if bigLettersRange ~= result {\n            value = AAscii\n        } else if smallLettersRange ~= result {\n            value = aAscii\n        } else {\n            shift += 1\n            return String(UnicodeScalar(UInt8(result)))\n        }\n        \n        result = operation(asciiValue,shift) - value\n        result = result % numberOfLetters\n        if result < 0 {\n            result += numberOfLetters\n        }\n        result += value\n        \n        shift += 1\n        return String(UnicodeScalar(UInt8(result)))\n    }).reduce(\"\") { (result, value) -> String in\n        return result + value\n    }\n}\n\nextension String {\n    var asciiArray: [Int] {\n        return unicodeScalars.filter{$0.isASCII}.map{Int($0.value)}\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340360,"user_id":492,"body":"func shiftMod(_ sign: Int, _ shift: Int, _ k: Int) -> Int {\n    return modulus(sign * (shift + k), 26)\n}\n\nfunc moving_shiftAux(_ s: String, _ shift: Int, _ sign: Int) -> String {\n    let ch = [UInt8](s.utf8)\n    var res = [UInt8]()\n    var d: Int\n    for (k, c) in ch.enumerated() {\n        let sVal = shiftMod(sign, shift, k)\n        if c >= 65 && c <= 90 {\n            d = (Int(c) - 65 + sVal) % 26 + 65\n        } else {\n            if c >= 97 && c <= 122 {\n                d = (Int(c) - 97 + sVal) % 26 + 97\n            } else {d = Int(c)}\n        }\n        res.append(UInt8(d))\n    }\n    return String(res.reduce(\"\", { $0 + String(format: \"%c\", $1)}).characters)\n}\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n    let v = moving_shiftAux(s, shift, 1) \n    return chunk(v, 5)\n}\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    let s = arr.joined(separator: \"\")\n    return moving_shiftAux(s, shift, -1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340361,"user_id":null,"body":"extension Character {\n  var i: Int { Int(asciiValue!) }\n}\n\nextension String {\n  var c: Character { Character(self) }\n}\n\nlet A = \"A\".c.i\nlet Z = \"Z\".c.i\nlet a = \"a\".c.i\nlet z = \"z\".c.i\n\nfunc move(_ c: Character, _ l: Int, _ h: Int, _ s: Int) -> String {\n  let len = h - l + 1\n  var step = s\n  while step < 0 { step += len }\n  while step > len { step -= len }\n  let moved = (c.i - l + step) % (h - l + 1) + l\n  return String(UnicodeScalar(UInt8(moved)))\n}\n\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n  var shift = shift\n  var shifted = \"\"\n  \n  for letter in s {\n    switch letter.i {\n      case A...Z: shifted += move(letter, A, Z, shift)\n      case a...z: shifted += move(letter, a, z, shift)\n      default: shifted += \"\\(letter)\"\n    }\n    shift += 1\n  }\n  \n  let len = Int((Double(s.count) \/ 5).rounded(.up))\n  var res = [String]()\n\n  for i in 0..<5 {\n    let start = shifted.index(shifted.startIndex, offsetBy: i * len)\n    let end = shifted.index(shifted.startIndex, offsetBy: (i + 1) * len, limitedBy: shifted.endIndex) ?? shifted.endIndex\n    res.append(String(shifted[start..<end]))\n  }\n  \n  return res\n}\n\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n  var shift = shift\n  var shifted = \"\"\n  \n  for letter in arr.joined() {\n    switch letter.i {\n      case A...Z: shifted += move(letter, A, Z, -shift)\n      case a...z: shifted += move(letter, a, z, -shift)\n      default: shifted += \"\\(letter)\"\n    }\n    shift += 1\n  }\n  \n  return shifted\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340362,"user_id":null,"body":"var alphabet: [Character] = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n  let array = Array(s)\n  var indices = [Int]()\n  for i in 0..<alphabet.count {\n    indices.append(i)\n  }\n  indices = rotate(array: indices, by: shift) as! [Int]\n  var result: [String] = []\n  var newString: [Character] = []\n  for (i, ch) in array.enumerated() {\n    let lowercased = Array(ch.lowercased())[0]\n    let isLowercased = ch.isLowercase\n    if let index = alphabet.firstIndex(of: lowercased) {\n      var newCh = alphabet[(index + i + shift) % alphabet.count]\n      if !isLowercased {\n        newCh = Array(newCh.uppercased())[0]\n      }\n      newString.append(newCh)\n    } else {\n      newString.append(ch)\n    }\n  }\n  var size = newString.count \/ 4\n  let remainder = newString.count % 4\n  \n  for i in remainder...(newString.count \/ 4) {\n    if (newString.count - i) % 4 == 0 {\n      let newSize = (newString.count - i) \/ 4\n      if newString.count - 4 * newSize <= newSize {\n        size = newSize\n        }\n      }\n  }\n  \n  var string = \"\"\n  for (index, ch) in Array(newString).enumerated() {\n    if string.count % size == 0 {\n      if index != 0 {\n        result.append(string)\n      }\n      string = \"\"\n    }\n    string.append(ch)\n  }\n  if !string.isEmpty {\n    result.append(string)\n  }\n  while result.count < 5 {\n    result.append(\"\")\n  }\n  result.forEach {\n    print(\"of size \\($0.count)\")\n  }\n  return result\n}\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n  let string = Array(arr.joined(separator: \"\"))\n  var array = [Character]()\n  for (i, ch) in string.enumerated() {\n    let lowercased = Array(ch.lowercased())[0]\n    let isLowercased = ch.isLowercase\n    let shiftedAlphabet = rotate(array: alphabet, by: i + shift) as! [Character]\n    if let index = shiftedAlphabet.firstIndex(of: lowercased) {\n      var newCh = alphabet[index]\n      if !isLowercased {\n        newCh = Array(newCh.uppercased())[0]\n      }\n      array.append(newCh)\n    } else {\n      array.append(ch)\n    }\n  }\n  return String(array)\n}\n\nfunc rotate(array: [Any], by d: Int) -> [Any] {\n  let rot = d % array.count\n  let first = array[0..<rot]\n  var second = array[rot..<array.count]\n  second.append(contentsOf: first)\n  return Array(second)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340363,"user_id":null,"body":"let alphabet = (0..<26).map { Character(UnicodeScalar(\"a\".unicodeScalars.first!.value + $0)!) }\n\nenum Mode {\n    case encryption, decryption\n}\n\nfunc moving_shift(_ s: String, _ shift: Int) -> [String] {\n    let messages =  process(input: s, shift: shift, type: .encryption)\n        .components(withLength: Int((Double(s.count) \/ 5.0).rounded(.up)))\n    \n    return messages.count == 5\n        ? messages\n        : messages + Array(repeating: \"\", count: 5 - messages.count)\n}\n\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    return process(input: arr.reduce(\"\", +), shift: shift, type: .decryption)\n}\n\nfunc process(input: String, shift: Int, type: Mode) -> String {\n    var output = \"\"\n    \n    zip(input, input.lowercased())\n        .enumerated()\n        .forEach { index, characters in\n            guard let alphabetIndex = alphabet.index(of: characters.1) else {\n                output.append(characters.0)\n                return\n            }\n            \n            var outputCharacter: String\n            switch type {\n                case .encryption:\n                    outputCharacter = String(alphabet[(alphabetIndex + index + shift) % alphabet.count])\n                case .decryption:\n                    let decodedIndex = (alphabetIndex - index - shift) % alphabet.count\n                    outputCharacter = String(alphabet[decodedIndex >= 0 ? decodedIndex : alphabet.count + decodedIndex])\n            }\n            \n            output.append(characters.0 == characters.1 ? outputCharacter : outputCharacter.uppercased())\n        }\n    \n    return output\n}\n\nextension String {\n    \n    func components(withLength length: Int) -> [String] {\n        return stride(from: 0, to: count, by: length)\n            .map {\n                let start = index(startIndex, offsetBy: $0)\n                let end = index(start, offsetBy: length, limitedBy: endIndex) ?? endIndex\n                return String(self[start..<end])\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340364,"user_id":null,"body":"func moving_shift(_ s: String, _ shift: Int) -> [String] {\n    var result: [String] = [], str = s, temp = 0, tempAscii = 0, tempShift = shift, tempResult: String = \"\"\n    for i in str.indices\n    {\n        if tempShift > 25 { tempShift = 0 }\n        tempAscii = Int(str[i].asciiValue!)\n        if tempAscii >= 65 && tempAscii <= 90\n        {\n            temp = tempAscii + tempShift\n            if temp > 90 { temp = 64 + temp % 90 }\n            tempResult.append(String(UnicodeScalar(temp)!))\n            tempShift += 1\n        }\n        else if tempAscii >= 97 && tempAscii <= 122\n        {\n            temp = tempAscii + tempShift\n            if temp > 122 { temp = 96 + temp % 122 }\n            tempResult.append(String(UnicodeScalar(temp)!))\n            tempShift += 1\n        }\n        else\n        {\n            tempResult.append(str[i])\n            tempShift += 1\n        }\n    }\n    \n    if tempResult.count % 5 == 0\n    {\n        for i in stride(from: 0, to: tempResult.count, by: tempResult.count \/ 5)\n        {\n            result.append(String(tempResult[tempResult.index(tempResult.startIndex, offsetBy: i)..<tempResult.index(tempResult.startIndex, offsetBy: i + tempResult.count \/ 5)]))\n        }\n    }\n    else if tempResult.count % 4 < tempResult.count \/ 4\n    {\n        var tempCount = tempResult.count \/ 4, tempNum = tempResult.count % 4\n        while true\n        {\n            if tempCount - 1 > tempNum + 4\n            {\n                tempCount -= 1 ; tempNum += 4\n            }\n            else { break }\n        }\n        for i in stride(from: 0, to: tempResult.count, by: tempCount)\n        {\n            result.append(String(tempResult[tempResult.index(tempResult.startIndex, offsetBy: i)..<tempResult.index(tempResult.startIndex, offsetBy: i + tempCount)]))\n            if tempResult.count - i - tempCount == tempNum\n            {\n                result.append(String(tempResult[tempResult.index(tempResult.startIndex, offsetBy: i + tempCount)..<tempResult.index(tempResult.startIndex, offsetBy: tempResult.count)])) ; break\n            }\n        }\n    }\n    else\n    {\n        for i in stride(from: 0, to: tempResult.count, by: tempResult.count \/ 3)\n        {\n            result.append(String(tempResult[tempResult.index(tempResult.startIndex, offsetBy: i)..<tempResult.index(tempResult.startIndex, offsetBy: i + tempResult.count \/ 3)]))\n            if tempResult.count - i - tempResult.count \/ 3 == tempResult.count % 3\n            {\n                result.append(String(tempResult[tempResult.index(tempResult.startIndex, offsetBy: i + tempResult.count \/ 3)..<tempResult.index(tempResult.startIndex, offsetBy: tempResult.count)]))\n                result.append(\"\")\n                break\n            }\n        }\n    }\n    \n    return result\n}\nfunc demoving_shift(_ arr: [String], _ shift: Int) -> String {\n    var str = arr.compactMap { $0 }.reduce(\"\", +), temp = 0, tempAscii = 0, tempShift = shift, tempResult: String = \"\"\n    for i in str.indices\n    {\n        if tempShift > 25 { tempShift = 0 }\n        tempAscii = Int(str[i].asciiValue!)\n        if tempAscii >= 65 && tempAscii <= 90\n        {\n            temp = tempAscii - tempShift\n            if temp < 65 { temp = 26 + temp }\n            tempResult.append(String(UnicodeScalar(temp)!))\n            tempShift += 1\n        }\n        else if tempAscii >= 97 && tempAscii <= 122\n        {\n            temp = tempAscii - tempShift\n            if temp < 97 { temp = 26 + temp }\n            tempResult.append(String(UnicodeScalar(temp)!))\n            tempShift += 1\n        }\n        else\n        {\n            tempResult.append(str[i])\n            tempShift += 1\n        }\n    }\n    return tempResult\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55084d3898b323f0aa000546":[{"id":340365,"user_id":492,"body":"func encodeAux(_ s: String, _ shift: Int) -> String {\n    let ch = [UInt8](s.utf8)\n    var res = [UInt8]()\n    let a = char2Lower(ch[0])\n    res.append(a)\n    res.append(UInt8(modulus(Int(a) - 97 + shift, 26) + 97))\n    var d: Int = 0\n    for c in ch {\n        if c >= 65 && c <= 90 {\n            d = modulus(Int(c) - 65 + shift, 26) + 65\n        } else {\n            if c >= 97 && c <= 122 {\n                d = modulus(Int(c) - 97 + shift, 26) + 97\n            } else {d = Int(c)}\n        }\n        \/\/print(\"c \", c, \" d \", d)\n        res.append(UInt8(d))\n    }\n    return String(res.reduce(\"\", { $0 + String(format: \"%c\", $1)}).characters)\n}\nfunc encode(_ s: String, _ shift: Int) -> [String] {\n    let v = encodeAux(s, shift) \n    return chunk(v, 5)\n}\nfunc decode(_ arr: [String]) -> String {\n    let s = arr.joined(separator: \"\")\n    let subs = subString(s, 2, 0)\n    let ch = [UInt8](s.utf8) \n    let shift = Int(ch[1]) - Int(ch[0])\n    return subString(encodeAux(subs, -shift), 2, 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340366,"user_id":null,"body":"func encodeLiteral (string: String, shift: Int) -> String{\n    var res: String = \"\"\n    for char in string.utf8{\n        if (65...90).contains(Int(char)) {\n            if Int(char)+shift > 90 {\n                res.append(\"\\(Unicode.Scalar(Int(char)+shift-26)!)\") \n            }\n            else if Int(char)+shift < 65{\n                res.append(\"\\(Unicode.Scalar(Int(char)+shift+26)!)\") \n            }\n            else{\n                res.append(\"\\(Unicode.Scalar(Int(char)+shift)!)\")\n            }\n        }\n        else if (97...122).contains(Int(char)){\n            if Int(char)+shift > 122 {\n                res.append(\"\\(Unicode.Scalar(Int(char)+shift-26)!)\") \n            }\n            else if Int(char)+shift < 97{\n                res.append(\"\\(Unicode.Scalar(Int(char)+shift+26)!)\") \n            }\n            else{\n                res.append(\"\\(Unicode.Scalar(Int(char)+shift)!)\")\n            }\n        }\n        else {\n            res.append(\"\\(Unicode.Scalar(Int(char))!)\")\n        }\n    }\n    return res\n}\nfunc encode(_ s: String, _ shift: Int) -> [String] {\n    let fullCodeString = s[s.startIndex].lowercased() + encodeLiteral(string: s[s.startIndex].lowercased(),shift: shift) + encodeLiteral(string: s, shift: shift)\n    var firstStringCount: Int \/\/\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435\n    if fullCodeString.count % 5 == 0 {\n        firstStringCount = fullCodeString.count\/5\n    }\n    else {\n        firstStringCount = fullCodeString.count\/5 + 1\n    }\n    var results = [Substring]()\n        var startIndex = fullCodeString.startIndex\n        while startIndex < fullCodeString.endIndex {\n            let endIndex = fullCodeString.index(startIndex, offsetBy: firstStringCount, limitedBy: fullCodeString.endIndex) ?? fullCodeString.endIndex\n            results.append(fullCodeString[startIndex..<endIndex])\n            startIndex = endIndex\n    }\n    return results.map{String($0)}\n}\nfunc decode(_ arr: [String]) -> String {\n    var s = arr.reduce(\"\",+)\n    var shiftLetters = \"\"\n        \/\/\u0440\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u043e\u0442 \u043a\u043e\u0434\u043e\u0432\u044b\u0445 \u0431\u0443\u043a\u0432\n    shiftLetters.append(s[s.startIndex]) \n    s.removeFirst()\n    shiftLetters.append(s[s.startIndex])\n    s.removeFirst()\n        \/\/\u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c shift \u043a\u0430\u043a \u0440\u0430\u0437\u043d\u0438\u0446\u0443 \u043c\u0435\u0436\u0434\u0443 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 ascii\n    var shift = Int(shiftLetters[shiftLetters.index(after: shiftLetters.startIndex)].unicodeScalars.first!.value) - Int(shiftLetters[shiftLetters.startIndex].unicodeScalars.first!.value)\n    if shift < 0 {shift+=26} \/\/\u0435\u0441\u043b\u0438  \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0435 - \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440 \u0430\u043b\u0444\u0430\u0432\u0438\u0442\u0430\n    shift = -shift \/\/ \u0434\u0435\u043b\u0430\u0435\u043c \u043e\u0442\u0440\u0438\u0446\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u043c \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 encodeLiteral\n    return encodeLiteral(string: s, shift: shift)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340367,"user_id":null,"body":"func encode(_ s: String, _ shift: Int) -> [String] {\n    \/\/ your code\n  var res = [String]()\n  var arrS = Array(s)\n  let lower = Array(\"abcdefghijklmnopqrstuvwxyz\")\n  let upper = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  var lDict = [Character: Int]()\n  var uDict = [Character: Int]()\n  \n  for i in 0..<lower.count {\n    lDict[lower[i]] = i\n  }\n  \n  for i in 0..<upper.count {\n    uDict[upper[i]] = i\n  }\n  \n  var first: Character\n  var second: Character\n  if lower.contains(arrS[0]) {\n    first = arrS[0]\n    second = lower[(lDict[arrS[0]]! + shift) % lower.count]\n  } else {\n    first = lower[uDict[arrS[0]]!]\n    second = lower[(uDict[arrS[0]]! + shift) % lower.count]\n  }\n  \n  for i in 0..<arrS.count {\n    if lower.contains(arrS[i]) {\n      arrS[i] = lower[(lDict[arrS[i]]! + shift) % lower.count]\n    } else if upper.contains(arrS[i]) {\n      arrS[i] = upper[(uDict[arrS[i]]! + shift) % upper.count]\n    }\n  }\n  arrS.insert(second, at: 0)\n  arrS.insert(first, at: 0)\n  \n  var portion = \"\"\n  var limit = 0\n  if arrS.count % 5 == 0 {\n    limit = arrS.count \/ 5\n  } else {\n    limit = (arrS.count + 5 - arrS.count % 5) \/ 5\n  }\n  while arrS.count > 0 {\n    for _ in 0..<limit {\n      portion += String(arrS.removeFirst())\n      if arrS.count == 0 {\n        break\n      }\n    }\n    res.append(portion)\n    portion = \"\"\n  }\n  \n  return res\n}\n\n\nfunc decode(_ arr: [String]) -> String {\n    \/\/ your code\n  let lower = Array(\"abcdefghijklmnopqrstuvwxyz\")\n  let upper = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  var lDict = [Character: Int]()\n  var uDict = [Character: Int]()\n  \n  for i in 0..<lower.count {\n    lDict[lower[i]] = i\n  }\n  for i in 0..<upper.count {\n    uDict[upper[i]] = i\n  }\n  var str = \"\"\n  for word in arr {\n    str += word\n  }\n  var arrS = Array(str)\n  var shift = lDict[arrS[1]]! - lDict[arrS[0]]!\n  if shift < 0 {\n    shift += lDict.count\n  }\n  \n  arrS.removeFirst()\n  arrS.removeFirst()\n  \n  for i in 0..<arrS.count {\n    if lower.contains(arrS[i]) {\n      if lDict[arrS[i]]! - shift < 0 {\n        arrS[i] = lower[lDict[arrS[i]]! - shift + lower.count]\n      } else {\n        arrS[i] = lower[lDict[arrS[i]]! - shift]\n      }\n    } else if upper.contains(arrS[i]) {\n      if uDict[arrS[i]]! - shift < 0 {\n        arrS[i] = upper[uDict[arrS[i]]! - shift + upper.count]\n      } else {\n        arrS[i] = upper[uDict[arrS[i]]! - shift]\n      }\n    }\n  }\n  \n  return String(arrS)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340368,"user_id":null,"body":"import Foundation\n\n\/*\n https:\/\/www.codewars.com\/kata\/55084d3898b323f0aa000546\/train\/swift\n *\/\n\nfunc encode(_ s: String, _ shift: Int) -> [String] {\n    Cleartext(s)\n            .encrypt(by: shift)\n            .toChunks(amount: 5)\n            .toArray()\n}\n\nfunc decode(_ arr: [String]) -> String {\n    Chunks(arr)\n            .join()\n            .decrypt()\n            .plaintext()\n}\n\nclass Chunks {\n    private final let chunks: [String]\n\n    init(_ chunks: [String]) {\n        self.chunks = chunks\n    }\n\n    func toArray() -> [String] {\n        chunks\n    }\n\n    func join() -> Ciphertext {\n        Ciphertext.from(ciphertext: chunks.joined())\n    }\n\n    private func append(_ other: Chunks) -> Chunks {\n        var appendedChunks: [String] = []\n        appendedChunks.append(contentsOf: chunks)\n        appendedChunks.append(contentsOf: other.chunks)\n\n        return Chunks(appendedChunks)\n    }\n\n    class func from(ciphertext: String, amount: Int) -> Chunks {\n        let bytes: Int = ciphertext.lengthOfBytes(using: String.Encoding.utf8)\n        let chunkSize: Int = Int(ceil(Double(bytes) \/ Double(amount)))\n\n        return createChunks(ciphertext, withChunkSize: chunkSize)\n    }\n\n    class private func createChunks(_ ciphertext: String, withChunkSize: Int) -> Chunks {\n        if ciphertext.isEmpty {\n            return Chunks([])\n        }\n\n        let chunk = String(ciphertext.prefix(withChunkSize))\n        let remaining = String(ciphertext.dropFirst(withChunkSize))\n        let furtherChunks = createChunks(remaining, withChunkSize: withChunkSize)\n\n        return Chunks([chunk]).append(furtherChunks)\n    }\n}\n\nclass Ciphertext {\n    private final let prefix: Prefix\n    private final let payload: String\n\n    init(_ prefix: Prefix, _ payload: String) {\n        self.prefix = prefix\n        self.payload = payload\n    }\n\n    func toChunks(amount: Int) -> Chunks {\n        let joined = prefix.toString() + payload\n        return Chunks.from(ciphertext: joined, amount: amount)\n    }\n\n    func decrypt() -> Cleartext {\n        let cleartext = payload.map {\n            Caesars.move($0, shift: (prefix.shift * -1))\n        }\n\n        return Cleartext(String(cleartext))\n    }\n\n    class func from(ciphertext: String) -> Ciphertext {\n        let prefix = Prefix.forDecryption(ciphertext)\n        let payload = ciphertext.dropFirst(2)\n\n        return Ciphertext(prefix, String(payload))\n    }\n}\n\nclass Prefix {\n    public final let shift: Int\n    private final let chars: [Character]\n\n    private init(_ shift: Int, _ chars: [Character]) {\n        self.shift = shift\n        self.chars = chars\n    }\n\n    public func toString() -> String {\n        String(chars)\n    }\n\n    class public func forEncryption(_ cleartext: String, _ shift: Int) -> Prefix {\n        let first: Character = cleartext.first!.lowercased().first!\n        let second = Caesars.move(first, shift: shift)\n\n        return Prefix(shift, [first, second])\n    }\n\n    class func forDecryption(_ ciphertext: String) -> Prefix {\n        let first: Character = ciphertext.first!;\n        let second: Character = ciphertext.dropFirst().first!\n        let shift = Caesars.shift(from: first, to: second)\n\n        return Prefix(Int(shift), [first, second])\n    }\n}\n\nclass Cleartext {\n    private final let cleartext: String\n\n    public init(_ cleartext: String) {\n        self.cleartext = cleartext\n    }\n\n    func encrypt(by shift: Int) -> Ciphertext {\n        let ciphertext: [Character] = cleartext.map {\n            Caesars.move($0, shift: shift)\n        }\n\n        let prefix: Prefix = Prefix.forEncryption(cleartext, shift)\n\n        return Ciphertext(prefix, String(ciphertext))\n    }\n\n    func plaintext() -> String {\n        cleartext\n    }\n}\n\nclass Caesars {\n    private static var ALPHABET_SIZE: Int = 26\n\n    public class func move(_ c: Character, shift: Int) -> Character {\n        let offset: UInt8;\n\n        if c.isLowercase {\n            offset = Character(\"a\").asciiValue!\n        } else if c.isUppercase {\n            offset = Character(\"A\").asciiValue!\n        } else {\n            return c\n        }\n\n        let effectiveShift = UInt8((shift + ALPHABET_SIZE) % ALPHABET_SIZE)\n        let value = (c.asciiValue! + effectiveShift + UInt8(ALPHABET_SIZE) - offset) % UInt8(ALPHABET_SIZE) + offset\n\n        return Character(UnicodeScalar(value))\n    }\n\n    public class func shift(from: Character, to: Character) -> UInt8 {\n        (to.asciiValue! - from.asciiValue!) + UInt8(ALPHABET_SIZE) % UInt8(ALPHABET_SIZE)\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340369,"user_id":null,"body":"let keyLowerCase: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\nlet keyUpperCase: [Character] = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n\nvar resultString: [String] = []\n\nfunc add(_ letter: Character,\n         by index: Int,\n         with shift: Int,\n         isEncode: Bool,\n         from keyArray: [Character],\n         to resultArray: inout [String]) {\n    var newIndex = 0\n    isEncode ? (newIndex = (index + shift) % keyArray.count) :\n    (newIndex = (2600000 + index - shift) % keyArray.count)\n    let newValue = String(keyArray[newIndex])\n    resultArray.append(newValue)\n}\n\nfunc encode(_ s: String, _ shift: Int) -> [String] {\n    \n    if s == \"\" || s == \" \" { return [\"\"] }\n    \n    var finalString: [String] = []\n    var a = \"\"\n    var b = \"\"\n    var c = \"\"\n    var d = \"\"\n    var e = \"\"\n    \n    var isFirstItaration = true\n    \n    for letter in s {\n        \n        if isFirstItaration {\n            let newLetter = letter.lowercased()\n            finalString.append(String(newLetter))\n            if let index = keyLowerCase.firstIndex(of: Character(newLetter)) {\n                add(letter,\n                    by: index,\n                    with: shift,\n                    isEncode: true,\n                    from: keyLowerCase,\n                    to: &finalString)\n                \n            } else {\n                finalString.append(String(letter))\n            }\n            isFirstItaration = false\n        }\n        if let index = keyLowerCase.firstIndex(of: letter) {\n            add(letter,\n                by: index,\n                with: shift,\n                isEncode: true,\n                from: keyLowerCase,\n                to: &finalString)\n        } else if let index = keyUpperCase.firstIndex(of: letter) {\n            add(letter,\n                by: index,\n                with: shift,\n                isEncode: true,\n                from: keyUpperCase,\n                to: &finalString)\n        } else {\n            finalString.append(String(letter))\n        }\n    }\n    \n    \n    var countOfElement = 0\n    if Double(finalString.count) \/ 5 == Double(Int(finalString.count \/ 5)) {\n        countOfElement = finalString.count \/ 5\n    } else {\n        countOfElement = Int(finalString.count \/ 5) + 1\n    }\n    \n    for letter in finalString {\n        if a.count < countOfElement {\n            a += letter\n        } else if b.count < countOfElement {\n            b += letter\n        } else if c.count < countOfElement {\n            c += letter\n        } else if d.count < countOfElement {\n            d += letter\n        } else {\n            e += letter\n        }\n    }\n    (e == \"\") ? (resultString = [a, b, c, d]) : (resultString = [a, b, c, d, e])\n    \n    return resultString\n}\n\n\nfunc decode(_ arr: [String]) -> String {\n    if arr.isEmpty { return \"\"}\n    \n    var finalString: [String] = []\n    var newArr = arr.joined().map{($0)}\n    if Set(newArr).isDisjoint(with: keyLowerCase) {\n        if Set(newArr).isDisjoint(with: keyUpperCase) {\n            return String(newArr[2...newArr.count - 1])\n        }\n    }\n\n    let firstElementIndex = keyLowerCase.firstIndex(of: newArr[0])\n    let secondElementIndex = keyLowerCase.firstIndex(of: newArr[1])\n    let shift =  Int(secondElementIndex!) - Int(firstElementIndex!)\n    \n    newArr.removeFirst(2)\n    \n    for letter in newArr {\n        \n        if let index = keyLowerCase.firstIndex(of: letter) {\n            add(letter,\n                by: index,\n                with: shift,\n                isEncode: false,\n                from: keyLowerCase,\n                to: &finalString)\n        } else if let index = keyUpperCase.firstIndex(of: letter) {\n            add(letter,\n                by: index,\n                with: shift,\n                isEncode: false,\n                from: keyUpperCase,\n                to: &finalString)\n        } else {\n            finalString.append(String(letter))\n        }\n    }\n    return finalString.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340370,"user_id":null,"body":"import Foundation\nfunc encode(_ s: String, _ shift: Int) -> [String] {\n    var result = [String]()\n    var outTmp = \"\"\n    var out = \"\"\n    let first = Character(s.first!.lowercased())\n    let second = Character(UnicodeScalar(Int(Int(first.asciiValue!) + shift > 122 ? first.asciiValue! - 25 : first.asciiValue! + 1))!)\n    let start = \"\\(first)\\(second)\"\n    let encodedS = s.split(separator: \" \")\n    for el in encodedS {\n        outTmp = \"\"\n        for letter in el {\n            if letter.isLetter {\n                let shifted = letter.asciiValue! + UInt8(shift)\n                if shifted > 122 {\n                    shifted - 25\n                }\n                let letterShifted = Character(UnicodeScalar(shifted))\n                outTmp += String(letterShifted)\n            } else {outTmp += String(letter)}\n        }\n        result.append(outTmp)\n        out = start + result.joined(separator: \" \")\n    }\n    if s.last == \" \" {\n        out += \" \"\n    }\n    let count = out.count\n    var countOfMessage = Int(count \/ 5)\n    countOfMessage = (count - countOfMessage * 4) > countOfMessage ? countOfMessage + 1 : countOfMessage\n    result = []\n    while out.count > 0 {\n        outTmp = String(out.prefix(countOfMessage))\n        if out.count > countOfMessage {\n            out.removeFirst(countOfMessage)\n        } else { out.removeFirst(out.count)}\n        result.append(outTmp)\n    }\n    return result\n}\n\nfunc decode(_ arr: [String]) -> String {\n    var str = arr.joined()\n    var result = \"\"\n    let first = str.removeFirst()\n    let second = str.removeFirst()\n    var shift = Int(second.asciiValue!) - Int(first.asciiValue!)\n    shift = shift < 0 ? shift + 26 : shift\n    for el in str {\n        if el.isLetter {\n            result += String(UnicodeScalar(el.asciiValue! - UInt8(shift)))\n        } else { result += String(el) }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340371,"user_id":null,"body":"import Foundation\n\nlet lettersCount = 5\nlet lowercasedAsciiRange = Range<UInt8>(97...122)\nlet uppercasedAsciiRange = Range<UInt8>(65...90)\n\nprivate func getShiftedSymbol(_ symbol: Character, shift: Int, forward: Bool) -> Character {\n  guard let asciiValue = symbol.asciiValue else { fatalError() }\n  var newAsciiValue = forward\n    ? asciiValue + UInt8(shift)\n    : asciiValue - UInt8(shift)\n\n  if symbol.isUppercase {\n    guard uppercasedAsciiRange.contains(asciiValue) else { return symbol }\n\n    if newAsciiValue > uppercasedAsciiRange.upperBound {\n      let difference = newAsciiValue - uppercasedAsciiRange.upperBound\n      newAsciiValue = uppercasedAsciiRange.lowerBound + difference - 1\n    } else if newAsciiValue < uppercasedAsciiRange.lowerBound {\n      let difference = uppercasedAsciiRange.lowerBound - newAsciiValue\n      newAsciiValue = uppercasedAsciiRange.upperBound - difference\n    }\n  } else {\n    guard lowercasedAsciiRange.contains(asciiValue) else { return symbol }\n\n    if newAsciiValue > lowercasedAsciiRange.upperBound {\n      let difference = newAsciiValue - lowercasedAsciiRange.upperBound\n      newAsciiValue = lowercasedAsciiRange.lowerBound + difference - 1\n    } else if newAsciiValue < lowercasedAsciiRange.lowerBound {\n      let difference = lowercasedAsciiRange.lowerBound - newAsciiValue\n      newAsciiValue = lowercasedAsciiRange.upperBound - difference\n    }\n  }\n\n  return Character(UnicodeScalar(newAsciiValue))\n}\n\nfunc encode(_ s: String, _ shift: Int) -> [String] {\n  let firstCharacter = Character(s.first!.lowercased())\n  let allCharacters = [\n    firstCharacter,\n    getShiftedSymbol(firstCharacter, shift: shift, forward: true)\n  ] + s.compactMap { getShiftedSymbol($0, shift: shift, forward: true) }\n\n  var charactersPerLetter = allCharacters.count \/ lettersCount\n  if allCharacters.count % lettersCount > 0 { charactersPerLetter += 1 }\n\n  var result = Array(repeating: \"\", count: lettersCount)\n  var currentLetter = 0\n  for character in allCharacters {\n    if result[currentLetter].count >= charactersPerLetter {\n      currentLetter += 1\n    }\n    result[currentLetter].append(character)\n  }\n\n  if result[lettersCount - 1].isEmpty {\n    result.removeLast()\n  }\n\n  return result\n}\n\nfunc decode(_ arr: [String]) -> String {\n  guard let firstPrefixSymbolAsciiValue = arr[0].first?.asciiValue,\n        let secondPrefixSymbolAsciiValue =  arr[0].dropFirst().first?.asciiValue else { return \"\" }\n  let shift = Int(secondPrefixSymbolAsciiValue - firstPrefixSymbolAsciiValue)\n\n  let encodedString = arr\n    .joined()\n    .dropFirst(2)\n\n  return encodedString\n    .compactMap { String(getShiftedSymbol($0, shift: shift, forward: false)) }\n    .joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340372,"user_id":null,"body":"func encode(_ s: String, _ shift: Int) -> [String] {\n    let alphabetLowercased = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    let alphabetUppercased = alphabetLowercased.map { $0.uppercased() }\n    \n    var shiftedS = \"\"\n    let firstPrefixLetter = s.first?.lowercased()\n    \n    var secondPrefixLetterAlphabetPosition = alphabetLowercased.firstIndex(of: firstPrefixLetter!)! + shift\n    if secondPrefixLetterAlphabetPosition >= 26 {\n        secondPrefixLetterAlphabetPosition -= 26\n    }\n    let secondPrefixLetter = alphabetLowercased[secondPrefixLetterAlphabetPosition]\n    \n    shiftedS.append(firstPrefixLetter!)\n    shiftedS.append(secondPrefixLetter)\n    \n    for letter in s {\n        var alphabetPosition: Int\n        let shiftedLetter: String\n        if letter.isLetter && letter.isUppercase {\n            alphabetPosition = alphabetUppercased.firstIndex(of: String(letter))!\n            var newPosition = alphabetPosition + shift\n            if newPosition >= 26 {\n                newPosition -= 26\n            }\n            shiftedLetter = alphabetUppercased[newPosition]\n            shiftedS.append(shiftedLetter)\n        } else if letter.isLowercase {\n            alphabetPosition = alphabetLowercased.firstIndex(of: String(letter))!\n            var newPosition = alphabetPosition + shift\n            if newPosition >= 26 {\n                newPosition -= 26\n            }\n            shiftedLetter = alphabetLowercased[newPosition]\n            shiftedS.append(shiftedLetter)\n        } else {\n            shiftedS.append(letter)\n        }\n    }\n    return splitByParts(shiftedS)\n}\n\nfunc decode(_ arr: [String]) -> String {\n    let codedResult = arr.joined()\n    var result = \"\"\n    let alphabetLowercased = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    let alphabetUppercased = alphabetLowercased.map { $0.uppercased() }\n    \n    let firstPrefixLetter = String(codedResult.first!)\n    let secondPrefixLetter = String(codedResult.dropFirst().first!)\n    let shift = alphabetLowercased.firstIndex(of: secondPrefixLetter)! - alphabetLowercased.firstIndex(of: firstPrefixLetter)!\n    \n    for letter in codedResult.dropFirst(2) {\n        var alphabetPosition: Int\n        let decodedLetter: String\n        \n        if letter.isLetter && letter.isUppercase {\n            alphabetPosition = alphabetUppercased.firstIndex(of: String(letter))!\n            if alphabetPosition - shift < 0 {\n                alphabetPosition += 26\n            }\n            decodedLetter = alphabetUppercased[alphabetPosition - shift]\n            result.append(decodedLetter)\n        } else if letter.isLowercase {\n            alphabetPosition = alphabetLowercased.firstIndex(of: String(letter))!\n            if alphabetPosition - shift < 0 {\n                alphabetPosition += 26\n            }\n            decodedLetter = alphabetLowercased[alphabetPosition - shift]\n            result.append(decodedLetter)\n        } else {\n            result.append(letter)\n        }\n        \n    }\n    return result\n}\n\nfunc splitByParts( _ message: String) -> [String] {\n    let length: Int\n    if message.count.isMultiple(of: 5) {\n        length = message.count\/5\n    } else {\n        length = message.count\/5 + 1\n    }\n    \n    return  stride(from: 0, to: message.count, by: length).map {\n        let start = message.index(message.startIndex, offsetBy: $0)\n        let end = message.index(start, offsetBy: length, limitedBy: message.endIndex) ?? message.endIndex\n        return String(message[start..<end])\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340373,"user_id":null,"body":"func encode(_ s: String, _ shift: Int) -> [String] {\n    \n    var convertedString = \"\"\n    let stringArray = Array(s)\n    let lowers = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let caps = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    \n    var currentCharIndex = 0\n    \n    while currentCharIndex < s.count {\n        let thisChar = stringArray[currentCharIndex]\n        if caps.contains(thisChar){\n            var convertedIndex = caps.firstIndex(where: {$0 == thisChar})!\n            convertedIndex += shift\n            if convertedIndex >= 26 {\n                convertedIndex = convertedIndex % 26\n            }\n            convertedString.append(caps[convertedIndex])\n        }\n        else if lowers.contains(thisChar) {\n            var convertedIndex = lowers.firstIndex(where: {$0 == thisChar})!\n            convertedIndex += shift\n            if convertedIndex >= 26 {\n                convertedIndex = convertedIndex % 26\n            }\n            convertedString.append(lowers[convertedIndex])\n        }\n        else {\n            convertedString.append(thisChar)\n        }\n        currentCharIndex += 1\n    }\n    \n    \/\/ insert prefix characters to demonstrate the shift\n    var prefix = \"\"\n    let downcasedString = s.lowercased()\n    let downcasedArray = Array(downcasedString)\n    let firstChar = downcasedArray[0]\n    prefix += String(firstChar)\n    \n    var convertedIndex = lowers.firstIndex(where: {$0 == firstChar})!\n    convertedIndex += shift\n    if convertedIndex >= 26 {\n        convertedIndex = convertedIndex % 26\n    }\n    \n    prefix.append(lowers[convertedIndex])\n    convertedString = prefix + convertedString\n    \n    var substringLength = s.count \/ 5\n    var done = false\n    while !done {\n        if convertedString.count - (substringLength * 4) > substringLength {\n            substringLength += 1\n        }\n        else {\n            done = true\n        }\n    }\n    \n  return convertedString.split(by: substringLength)\n}\n\n\nfunc decode(_ arr: [String]) -> String {\n    var codedString = Array(arr.joined())\n    var decodedString = \"\"\n    let caps = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    let lowers = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    \n    \/\/ first strip the first two characters (which will be lower case)\n    \/\/ and calculate the shift:\n    let firstCharIndex = lowers.firstIndex(where: {$0 == codedString[0]})!\n    let secondCharIndex = lowers.firstIndex(where: {$0 == codedString[1]})!\n    let shift = secondCharIndex - firstCharIndex\n    codedString.remove(at: 0)\n    codedString.remove(at: 0)\n    \n    \/\/ now loop through the coded string decoding the individual letters\n    var currentCharIndex = 0\n    \n    while currentCharIndex < codedString.count {\n        let thisChar = codedString[currentCharIndex]\n        if caps.contains(thisChar) {\n            var convertedIndex = caps.firstIndex(where: {$0 == thisChar})!\n            convertedIndex -= shift\n            if convertedIndex < 0 {\n                convertedIndex = 26 + (convertedIndex % 26)\n            }\n            if convertedIndex >= 26 {\n                convertedIndex = convertedIndex % 26\n            }\n            let convertedChar = caps[convertedIndex]\n            decodedString.append(convertedChar)\n        } else if lowers.contains(thisChar) {\n            var convertedIndex = lowers.firstIndex(where: {$0 == thisChar})!\n            convertedIndex -= shift\n            if convertedIndex < 0 {\n                convertedIndex = 26 + (convertedIndex % 26)\n            }\n            if convertedIndex >= 26 {\n                convertedIndex = convertedIndex % 26\n            }\n            let convertedChar = lowers[convertedIndex]\n            decodedString.append(convertedChar)\n        }\n        else {\n            decodedString.append(thisChar)\n        }\n        currentCharIndex += 1\n    }\n    \n    return decodedString\n}\n\n\/\/ Credit Code Different\n\/\/ https:\/\/stackoverflow.com\/questions\/32212220\/how-to-split-a-string-into-substrings-of-equal-length\n\nextension String {\n    func split(by length: Int) -> [String] {\n        var startIndex = self.startIndex\n        var results = [Substring]()\n\n        while startIndex < self.endIndex {\n            let endIndex = self.index(startIndex, offsetBy: length, limitedBy: self.endIndex) ?? self.endIndex\n            results.append(self[startIndex..<endIndex])\n            startIndex = endIndex\n        }\n\n        return results.map { String($0) }\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340374,"user_id":null,"body":"func encode(_ s: String, _ shift: Int) -> [String] {\n    var shifted = s.map( { String($0) })\n    for i in 0..<shifted.count {\n        switch shifted[i] {\n        case \"a\"...\"z\":\n            shifted[i] = String(UnicodeScalar(UnicodeScalar(shifted[i])!.value + UInt32(shift))!)\n        case \"A\"...\"Z\":\n            shifted[i] = String(UnicodeScalar(UnicodeScalar(shifted[i])!.value + UInt32(shift))!)\n        default:\n            continue\n        }\n    }\n    shifted.insert(shifted[0].lowercased(), at: 0)\n    shifted.insert(String(s.first ?? \"A\").lowercased(), at: 0)\n    var output = [String]()\n    let length = Int((Double(shifted.count) \/ 5.0).rounded(.up))\n    while shifted.count >= length {\n        let x = shifted[0..<(length)].joined()\n        output.append(x)\n        shifted.removeFirst(length)\n    }\n    output = output + [shifted.joined()]\n    return output.last!.isEmpty ? output.dropLast() : output\n}\nfunc decode(_ arr: [String]) -> String {\n    var letters = arr.joined().map({ String($0) })\n    let shift = UnicodeScalar(letters[1])!.value - UnicodeScalar(letters[0])!.value\n    letters.removeFirst(2)\n    for i in 0..<letters.count {\n        switch letters[i] {\n        case \"a\"...\"z\":\n            letters[i] = String(UnicodeScalar(UnicodeScalar(letters[i])!.value - UInt32(shift))!)\n        case \"A\"...\"Z\":\n            letters[i] = String(UnicodeScalar(UnicodeScalar(letters[i])!.value - UInt32(shift))!)\n        default:\n            continue\n        }\n    }\n    return letters.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"550f22f4d758534c1100025a":[{"id":340375,"user_id":492,"body":"func canReduce(_ elem: String, _ last: String) -> Bool {\n    switch (elem, last) { \n        case (\"NORTH\", \"SOUTH\") : return true \n        case (\"SOUTH\", \"NORTH\") : return true\n        case (\"WEST\", \"EAST\") : return true\n        case (\"EAST\", \"WEST\") : return true\n        default: return false\n    }\n}\nfunc dir_reduc(_ arr: [String]) -> [String] {\n    var res = [String]()\n    for s in arr {\n        if !res.isEmpty && (canReduce(s, res.last!)) {\n            res.removeLast()\n        } else {\n            res.append(s)\n        }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340376,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n    \/\/ your code\n    var result = [String]()\n    \n    let opposite = [\"NORTH\":\"SOUTH\", \"SOUTH\":\"NORTH\", \"WEST\": \"EAST\", \"EAST\":\"WEST\"]\n    \n    arr.forEach { item in\n      if result.last == opposite[item] {\n        result.removeLast()\n      }else{\n        result.append(item)\n      }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340377,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n    return arr.reduce(into: [String]()) { (result, element) in\n        if let last = result.last, [(\"NORTH\", \"SOUTH\"), (\"EAST\", \"WEST\")].contains(where: { $0 == (last, element) || $0 == (element, last) }) {\n            result.removeLast()\n        } else {\n            result.append(element)\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340378,"user_id":null,"body":"func rds(_ el: String, _ l: String) -> Bool {\n    switch (el, l) {\n        case (\"NORTH\", \"SOUTH\") :\n            return true\n        case (\"SOUTH\", \"NORTH\") :\n            return true\n        case (\"WEST\", \"EAST\") :\n            return true\n        case (\"EAST\", \"WEST\") :\n            return true\n        default:\n            return false\n    }\n}\n\nfunc dir_reduc(_ arr: [String]) -> [String] {\n    var res = [String]()\n    arr.forEach {\n        if !res.isEmpty, (rds($0, res.last!)) { res.removeLast()}\n        else { res.append($0) }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340379,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n    var reducedArray = arr\n    for (idx, value) in arr.enumerated() {\n        if idx < arr.count - 1 {\n            if reducedArray[idx + 1] == value {\n                continue\n            }\n            switch value {\n            case \"NORTH\", \"SOUTH\":\n                if reducedArray[idx + 1] == \"NORTH\" || reducedArray[idx + 1] == \"SOUTH\" {\n                    reducedArray.remove(at: idx + 1)\n                    reducedArray.remove(at: idx)\n                    return dir_reduc(reducedArray)\n                }\n                \n            case \"EAST\", \"WEST\":\n                if reducedArray[idx + 1] == \"EAST\" || reducedArray[idx + 1] == \"WEST\" {\n                    reducedArray.remove(at: idx + 1)\n                    reducedArray.remove(at: idx)\n                    return dir_reduc(reducedArray)\n                }\n                \n            default:\n                break\n            }\n        }\n    }\n    return reducedArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340380,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n  let n=\"NORTH\", s=\"SOUTH\", w=\"WEST\", e=\"EAST\"\n  var news = [String]()\n  for v in arr {\n    if news.isEmpty { news.append(v); continue }\n    let opposite = v == n ? s : v == s ? n : v == w ? e : v == e ? w : nil\n    if opposite == news.last! { news.removeLast() } else { news.append(v) }\n  }\n  return news\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340381,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n    var array = arr\n    let helper: ([String]) -> Int? = {\n        for val in 0..<($0.count - 1) {\n            switch ($0[val], $0[val+1]) {\n            case (\"NORTH\",\"SOUTH\"): return val\n            case (\"SOUTH\", \"NORTH\"): return val\n            case (\"EAST\", \"WEST\"): return val\n            case (\"WEST\", \"EAST\"): return val\n            default: break\n            }\n        }\n        return nil\n    }\n    while let value = helper(array) {\n        array.removeSubrange(value...value+1)\n    }\n    return array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340382,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n    return arr.reduce([], reduce)\n}\n\nprivate func reduce(xs: [String], next: String) -> [String] {\n  guard let last = xs.last else {\n    return [next]\n  }\n  \n  if last.opposite == next {\n    return Array(xs.dropLast())\n  } else {\n    return xs + [next]\n  }\n}\n\nprivate extension String {\n  var opposite: String {\n    switch self {\n      case \"EAST\": return \"WEST\"\n      case \"WEST\": return \"EAST\"\n      case \"NORTH\": return \"SOUTH\"\n      case \"SOUTH\": return \"NORTH\"    \n      default: fatalError()\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340383,"user_id":null,"body":"func dir_reduc(_ arr: [String]) -> [String] {\n\tlet opposite = [\n\t\t\"NORTH\": \"SOUTH\",\n\t\t\"SOUTH\": \"NORTH\",\n\t\t\"WEST\": \"EAST\",\n\t\t\"EAST\": \"WEST\",\n\t]\n\n\tvar result: [String] = []\n\t\n\tfor dir in arr {\n\t\tif result.isEmpty || dir != opposite[result.last ?? \"\"] {\n\t\t\tresult.append(dir)\n\t\t} else if !result.isEmpty {\n\t\t\tresult.removeLast()\n\t\t}\n\t}\n\t\n\treturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340384,"user_id":null,"body":"private enum Direction: String {\n  case north = \"NORTH\"\n  case south = \"SOUTH\"\n  case west = \"WEST\"\n  case east = \"EAST\"\n\n  func isOpposite(to other: Self) -> Bool {\n    switch (self, other) {\n      case (.north, .south), (.south, .north), (.east, .west), (.west, .east): \n        return true\n      default:\n        return false\n    }\n  }\n}\n\nfunc dir_reduc(_ arr: [String]) -> [String] {\n  let directions = arr.compactMap { Direction(rawValue: $0) }\n  return directions.reduced.map { $0.rawValue }\n}\n\nextension Array where Element == Direction {\n  \n  var reduced: [Element] {\n    var output: [Element] = []\n    for element in self {\n      if output.last?.isOpposite(to: element) == true {\n        output.removeLast()\n      } else {\n        output.append(element)\n      }\n    }\n    return output\n  }\n  \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5517fcb0236c8826940003c9":[{"id":340385,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    \n    if l.count == 0 {\n        return nil\n    }\n    \n    \/\/ Find a common denominator\n    var commonDenominator = 1\n    for (_, d) in l {\n        commonDenominator *= d\n    }\n       \n    \/\/ Sum numerators\n    var numerator = 0\n    for (n, d) in l {\n        numerator += n * (commonDenominator \/ d)\n    }\n    \n    \/\/ simplify fraction\n    var currentSmallestNumerator = numerator\n    var currentSmallestDenominator = commonDenominator\n    \n    for possibleFactor in 2...commonDenominator {\n        if numerator % possibleFactor == 0, commonDenominator % possibleFactor == 0 {\n            currentSmallestNumerator = numerator \/ possibleFactor\n            currentSmallestDenominator = commonDenominator \/ possibleFactor\n        }\n    }\n    \n    return (currentSmallestNumerator,currentSmallestDenominator)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340386,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    if l.isEmpty { return nil }\n    let den = l.map { (tup) in tup.1 }.reduce(1) { (res, val) in res * val }\n    let neu = l.map { (tup) in den * tup.0 \/ tup.1 }.reduce(0, +)\n    let hcf = gcd(neu, den)\n    \n    return (neu\/hcf, den\/hcf)\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 { return  a\n    } else { return gcd(b, a % b) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340387,"user_id":null,"body":"func gcd(_ x: Int, _ y: Int) -> Int {\n  var (x, y) = (x, y)\n  while (y != 0) { (x, y) = (y, x % y) }\n  return x\n}\n\nfunc sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n  guard l.count > 0 else { return nil }\n  let den = l.map { $1 }.reduce(1, *)\n  let num = l.map { den * $0 \/ $1 }.reduce(0, +)\n  let g = gcd(num, den)\n  return (num \/ g, den \/ g)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340388,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    guard l.count > 0 else { return nil }\n    \n    let cd = l.reduce(1) { $0 * $1.1 }\n    let n = l.reduce(0) { $0 + $1.0 * cd\/$1.1 }\n    \n    for d in stride(from:min(n, cd), through:2, by:-1) {\n        if n%d == 0 && cd%d == 0 {\n            return (n\/d, cd\/d)\n        }\n    }\n    \n    return (n,cd)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340389,"user_id":null,"body":"func gcd(_ x: Int, _ y: Int) -> Int {\n    let maxValue = max(x, y)\n    let minValue = min(x, y)\n    if minValue == 0 { return maxValue }\n    return gcd(minValue, maxValue % minValue)\n}\n\nfunc lcm(_ x: Int, _ y: Int) -> Int {\n    return x \/ gcd(x, y) * y\n}\n\nfunc sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    guard !l.isEmpty else { return nil }\n    let denominators = l.map { $0.1 }\n    let lcmResult = denominators.reduce(1, lcm)\n    let result = l.map { (lcmResult \/ $0.1 * $0.0, lcmResult) }.reduce((0, lcmResult), { ($0.0 + $1.0, lcmResult) })\n    let (numberator, denominator) = result\n    let finalGcd = gcd(numberator, denominator)\n    if finalGcd > 1 {\n        return (numberator \/ finalGcd, denominator \/ finalGcd)\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340390,"user_id":53,"body":"func gcd(_ m: Int, _ n: Int) -> Int {\n    if m == 0 {return n} else {return gcd(n % m, m)}\n}\n\nfunc lcm(_ a: Int, _ b: Int) -> Int {\n    return a * b \/ gcd(a, b)\n}\n\nfunc reduce(_ t: (Int, Int)) -> (Int, Int) {\n  let a = t.0\n  let b = t.1\n  let i = gcd(a, b)\n  return (a \/ i, b \/ i)\n}\n\nfunc norm(_ t: (Int, Int), _ cd: Int) -> (Int, Int) {\n  let a = t.0\n  let b = t.1\n  return (a * cd \/ b, cd)\n}\n\nfunc sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n  if (l.count == 0) { return nil }\n  let xss = l.map { reduce($0) }\n  let cd = xss.reduce(1, { lcm($1.1, $0) })\n  let yss = xss.map { norm($0, cd) }\n  let n = yss.reduce(0, { $0 + $1.0 })\n  let g = gcd(n, cd)\n  return (n \/ g, cd \/ g)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340391,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    if l.isEmpty{\n        return nil\n    }\n    var top = 0\n    var nod = 0\n    var flag = true\n    \n    while flag{\n        var total = 0\n        nod += 1\n        for each in l{\n            if nod % each.1 == 0{\n                total += 1\n            }\n            if total == l.count{\n                flag = false\n            }\n        }\n    }\n    \n    for each in l{\n        top += each.0 * (nod \/ each.1)\n    }\n    \n    for i in 0...8{\n        let del = 10 - i\n        if nod % del == 0 && top % del == 0{\n            nod = nod \/ del\n            top = top \/ del\n        }\n    }\n    \n    return (top,nod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340392,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    if l.isEmpty{\n        return nil\n    }\n    var top = 0\n    var nod = 0\n    var arr = [Int]()\n    \n    for each in l{\n        arr.append(each.1)\n    }\n    \n    var flag = true\n    \n    while flag{\n        var total = 0\n        nod += 1\n        for each in arr{\n            if nod % each == 0{\n                total += 1\n            }\n            if total == arr.count{\n                flag = false\n            }\n        }\n    }\n    \n    for each in l{\n        top += each.0 * (nod \/ each.1)\n    }\n    \n    for i in 0...8{\n        let del = 10 - i\n        if nod % del == 0 && top % del == 0{\n            nod = nod \/ del\n            top = top \/ del\n        }\n    }\n    \n    return (top,nod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340393,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n   \/\/ your code\n  \/\/ your code\n   \n    if l.isEmpty {\n        return nil\n    }\n\n   var chisl = 0\n   var znam = 1\n   for item in l {\n        znam=znam*item.1\n   }\n   for item in l {\n        chisl=chisl+(item.0*(znam\/item.1))\n   }\n   while (znam%2==0)&&(chisl%2==0) {\n    znam=znam\/2\n    chisl=chisl\/2\n   }\n   while (znam%3==0)&&(chisl%3==0) {\n    znam=znam\/3\n    chisl=chisl\/3\n   }\n   while (znam%5==0)&&(chisl%5==0) {\n    znam=znam\/5\n    chisl=chisl\/5\n   }\n   while (znam%7==0)&&(chisl%7==0) {\n    znam=znam\/7\n    chisl=chisl\/7\n   }\n   if chisl%znam==0 {\n    return ((chisl\/znam),1)\n   }else {\n     return (chisl,znam)   \n   } \n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340394,"user_id":null,"body":"func sumFracts(_ l: [(Int, Int)]) -> (Int, Int)? {\n    guard !l.isEmpty else { return nil }\n    var maxD = 0, N = 0, D = 0, temp = 0\n    for cortege in l {\n        if cortege.1 > maxD {\n            maxD = cortege.1\n        }\n    }\n    temp = maxD\n    w1: while true {\n        for cortege in l {\n            if maxD % cortege.1 != 0 {\n                maxD += temp\n                continue w1\n            }\n        }\n        break\n    }\n    D = maxD\n    for cortege in l {\n        N += (D \/ cortege.1) * cortege.0\n    }\n    if D % N == 0 { return (D \/ N, 1) }\n    \n    w2: while true {\n        for i in stride(from: 2, through: D, by: 1) {\n            if N % i == 0 && D % i == 0 {\n                N \/= i\n                D \/= i\n                continue w2\n            }\n        }\n        break\n    }\n    \n    return (N, D)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5518a860a73e708c0a000027":[{"id":340395,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n\tvar iterator = numbers.makeIterator()\n\tlet start = iterator.next()\n\tvar zeroFixed = sequence(state: (iterator, start)) { (state: inout (iterator: S.Iterator, current: Int?)) -> Int? in\n\t\tguard let current = state.current else { return 1 }\n\t\tstate.current = state.iterator.next()\n\t\tguard let next = state.current, next == 0 else { return current }\n\t\tvar count = 1\n\t\twhile state.iterator.next() == 0 {\n\t\t\tcount += 1\n\t\t}\n\t\tstate.current = nil\n\t\tif count % 2 == 0 {\n\t\t\treturn current\n\t\t} else {\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tlet first = zeroFixed.next()! % 10\n\tlet second: Int\n\n\tswitch zeroFixed.next()! % 4 {\n\tcase 0: second = 4\n\tcase 1: second = 1\n\tcase 2: second = zeroFixed.next()! == 1 ? 2 : 4\n\tcase 3: second = zeroFixed.next()! % 2 == 0 ? 1 : 3\n\tdefault: fatalError(\"Should be unreachable\")\n\t}\n\n\treturn Int(pow(Double(first), Double(second))) % 10\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340396,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n    var array = Array(numbers.prefix(4))\n    var i = 0\n    var evenZeroes = true\n    for n in numbers {\n        if n == 1 {\n            break\n        }\n        if i >= 3 {\n            if n != 0 {\n                break\n            }\n            evenZeroes.toggle()\n            \n        }\n        i += 1\n    }\n    let extra = evenZeroes ? 1 : 2\n    if array.count >= 4 {\n        array.removeLast(extra)\n    }\n    while let index = array.firstIndex(of: 1) {\n        array = Array(array.prefix(upTo: index))\n    }\n    while let index = array.lastIndex(of: 0), index != 0 {\n        array = Array(array.prefix(max(index - 1, 0)))\n    }\n    return last_digit1(array)\n}\n\nfunc last_digit1(_ numbers: [Int]) -> Int {\n    if numbers.count == 0 {\n        return 1\n    }\n    if numbers.count == 1 {\n        return numbers[0] % 10\n    }\n    if numbers[1] == 0 {\n        return 1\n    }\n    let array = [[], [1],\n        [2, 4, 8, 6],\n        [3, 9, 7, 1],\n        [4, 6],\n        [5],\n        [6],\n        [7, 9, 3, 1],\n        [8, 4, 2, 6],\n        [9, 1]]\n    let n = numbers[0]\n    if n % 10 == 0 {\n        return 0\n    }\n    let d = array[n % 10].count\n    let module1 = numbers[1] % d\n    var module2 = 0 \/\/n[1]^m % d\n    if numbers.count == 2 {\n        module2 = module1\n    } else if module1 == 3 {\n        module2 = (numbers[2] % 2 == 0 ? 1 : 3)\n    } else {\n        module2 = module1 % 2\n    }\n    module2 -= 1\n    if module2 < 0 {\n        module2 = d - 1\n    }\n    return array[n % 10][module2]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340397,"user_id":null,"body":"func last_digit<T>(_ numbers: T) -> Int where T: Sequence, T.Iterator.Element == Int {\n    var iterator = numbers.makeIterator()\n    var ns = [Int](), zc: Int = 0\n    \n    \/\/ Simplify numbers.\n    while let n = iterator.next() {\n        ns.append(n)\n        switch n {\n        case 0: zc += 1; continue\n        case 1: break\n        default: if !(zc > 0 || ns.count >= 4) { continue }\n        }\n        break\n    }\n    \n    guard ns.count > 0 else { return 1 }\n\n    if zc > 0 {\n        \/\/ Reduce the series of 0 to one single 0.\n        if let i = ns.firstIndex(of: 0) {\n            ns[i] = (zc % 2 == 0) ? 1 : 0\n            ns.removeLast(ns.count - 1 - i)\n        }\n    }\n    \n    if ns.last! == 0 {\n        \/\/ Check zero\n        if ns.count == 1 { return 0 }\n        ns.removeLast()\n        ns[ns.count - 1] = 1\n    }\n    \/\/ No more 0 in ns. Maximum count of ns = 4.\n    \n    guard ns.count > 1 else { return ns[0] % 10 }\n\n    var power = 1\n    switch ns[1] % 4 {\n    case 1: power = 1\n    case 2: power = (ns.count > 2 && ns[2] > 1) ? 4 : 2\n    case 3: power = (ns.count > 2 && ns[2] % 2 == 0) ? 1 : 3\n    default: power = 4\n    }\n    \n    return Int(pow(Double((Int(ns[0]) - 1) % 10 + 1), Double(power))) % 10\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340398,"user_id":168,"body":"func powm(_ x: Int, _ y: Int, mod: Int) -> Int {\n  Int(pow(Double(x % mod), Double(y))) % mod\n}\n\nfunc last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n  var xs: [Int] = []\n  var zeros = 0\n  for (i, x) in numbers.enumerated() {\n    if x == 0 { zeros += 1 }\n    else if zeros > 0 || i >= 3 { break }\n    else { xs.append(x) }\n    if x == 1 { break }\n  }\n  if zeros > 0 { xs.append(1 - zeros % 2) }\n  var r = 1\n  var less4 = true\n  for (i, x) in xs.enumerated().reversed() {\n    if i == 0 {\n      r = powm(x, r + (less4 ? 0 : 4), mod: 10)\n    } else if (less4) {\n      less4 = x <= 1 || r == 0 || x <= 3 && r <= 1\n      r = powm(x, r, mod: 4)\n    } else {\n      less4 = x <= 1\n      r = powm(x, r + 2, mod: 4)\n    }\n  }\n  return r\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340399,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n    \n    var resValue : Decimal = 1\n    var editedArray: [Int] = []\n\n    let trunc : (Int) -> Int = { v in\n        guard v != 0 else {return 0}\n        var truncatedValue = 0\n        var modifiedValue = 100\n        repeat {\n            modifiedValue = modifiedValue * 10\n            truncatedValue = v % modifiedValue\n        } while (truncatedValue < 1)\n        return truncatedValue\n    }\n\n    for item in numbers{\n        let t = trunc(item)\n        if (t == 1) {break}\n        editedArray.append(t)\n    }\n\n    if editedArray.count < 1 {return 1}\n    if editedArray[0] == 1 {return 1}\n\n    for x in editedArray.reversed() {\n        let nyc = (resValue as NSDecimalNumber).uint64Value\n        resValue = pow(Decimal(x), Int((nyc >= 4) ? 4 + (nyc % 4) : nyc))\n    }\n    return (resValue as NSDecimalNumber).stringValue.last!.wholeNumberValue!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340400,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n    var rval : Decimal = 1\n    var strippedArray: [Int] = []\n\n    let trunc : (Int) -> Int = { v in\n        guard v != 0 else {return 0}\n        var truncatedVal = 0;\n        var modVal = 100;\n        repeat {\n            modVal = modVal * 10\n            truncatedVal = v % modVal\n        } while (truncatedVal < 1)\n        return truncatedVal\n    }\n\n    for item in numbers{\n        let t = trunc(item)\n        if (t == 1) {break}\n        strippedArray.append(t)\n    }\n\n    if strippedArray.count < 1 {return 1}\n    if strippedArray[0] == 1 {return 1}\n\n    for x in strippedArray.reversed(){\n        let np_d = (rval as NSDecimalNumber).uint64Value\n        rval = pow(Decimal(x), Int((np_d >= 4) ? 4 + (np_d % 4) : np_d))\n    }\n    return (rval as NSDecimalNumber).stringValue.last!.wholeNumberValue!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340401,"user_id":null,"body":"func trunc(_ v:Int) -> Decimal{\n    var truncatedVal = 0;\n    if (v != 0) {\n        var modVal = 100;\n        repeat {\n            modVal = modVal * 10\n            truncatedVal = v % modVal\n        } while (truncatedVal < 1)\n    }\n    return Decimal(truncatedVal)\n}\n\nfunc last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n    var vals = Array(numbers.prefix(2))\n    if vals.count < 1 {return 1}\n    if vals[0] == 1 {return 1}\n\n    var n : Decimal = 1\n\n    var xarray : [Decimal] = []\n    for item in numbers{\n        let t = trunc(item)\n        xarray.append(t)\n        if (t == 1) {break}\n    }\n\n    for x in xarray.reversed(){\n        let np_d = (n as NSDecimalNumber).uint64Value\n        let np = (np_d >= 4) ? 4 + (np_d % 4) : np_d\n        n = pow(x, Int(np))\n    }\n\n    return (n as NSDecimalNumber).stringValue.last!.wholeNumberValue!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340402,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n    var ss = [Int]()\n    if numbers is [Int] { ss = numbers as! [Int]}\n    else if numbers is Range<Int> {\n        let arr = numbers as! Range<Int>\n        let first = arr.first! % 1000, last = arr.last!%1000\n        ss = first>last ? [Int](first...last+1000) : [Int](first...last)\n    }\n    else if numbers is ReversedCollection<Range<Int>> {\n        let arr = numbers as! ReversedCollection<Range<Int>>\n        let first = arr.first!%1000, last = arr.last!%1000\n        ss = first>last ? [Int](first...last+1000) : [Int](first...last) }\n    else if numbers is LazyMapSequence<Range<Int>, Int> {\n        var iterator = numbers.dropFirst().makeIterator()\n        var zeroes = 0\n        while let number = iterator.next() {\n            if(number == 0){ zeroes += 1 }\n            else { return zeroes % 2 == 0 ? numbers.prefix(1).max()! % 10 : 1 }\n        }\n    }\n    if(ss.count == 0){ return 1 }\n    else if(ss.count == 1){ return ss[0]%10 }\n    for i in (1..<ss.count).reversed() {\n        if( ss[i-1] == 0 && ss[i] != 0){ ss[i-1] = 0 }\n        else{ ss[i-1] =  Int( pow(Double(ss[i-1] % 100), Double(ss[i] % 4 + (ss[i] > 2 ? 4 : 0))) ) }\n    }\n    return ss[0]%10\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340403,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n    var ss = [Int]()\n    \n     if numbers is [Int] { ss = numbers as! [Int]}\n    else if numbers is Range<Int> {\n        let arr = numbers as! Range<Int>\n        let first = arr.first! % 1000, last = arr.last!%1000\n        ss = first>last ? [Int](first...last+1000) : [Int](first...last)\n    }\n    else if numbers is ReversedCollection<Range<Int>> {\n        let arr = numbers as! ReversedCollection<Range<Int>>\n        let first = arr.first!%1000, last = arr.last!%1000\n        ss = first>last ? [Int](first...last+1000) : [Int](first...last) }\n      else if numbers is LazyMapSequence<Range<Int>, Int> {\n        \/\/        let arr = numbers as! LazyMapSequence<Range<Int>, Int>\n        \/\/        let first = arr.first!%1000, last = arr.last!%1000\n        \/\/        ss = first>last ? [Int](first...last+1000) : [Int](first...last)\n        var animalIterator = numbers.dropFirst().makeIterator()\n        var zeroes = 0\n        while let animal = animalIterator.next() {\n            if(animal == 0){\n                zeroes += 1\n            }\n            else {\n        \n                    return zeroes % 2 == 0 ? numbers.prefix(1).max()! % 10 : 1\n                \n                \n            }\n        }\n    }\n     else {\n        print(numbers.dropFirst(10).sorted())\n    }\n\n    \n    if(ss.count == 0){\n        return 1\n    }\n    else if(ss.count == 1){\n        return ss[0]%10\n    }\n    \n    for i in (1..<ss.count).reversed() {\n        if(ss[i-1] == 0 && ss[i] != 0){\n            ss[i-1] = 0\n        }\n        else{\n            let add = ss[i] > 2 ? 4 : 0\n            ss[i-1] =  Int( pow(Double(ss[i-1] % 100), Double(ss[i] % 4 + add)) )\n        }\n    }\n    return ss[0]%10\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340404,"user_id":null,"body":"func last_digit<S>(_ numbers: S) -> Int where S: Sequence, S.Iterator.Element == Int {\n  var num: [Int] = []\n  totalLoop: for numb in numbers {\n   \n    num.append(numb)\n    if(num.count>2){\n    swit: switch(numb%10){\n      case 1:\n      switch(numb%100){\n        case 21,41,61,81: break totalLoop;\n        default:break swit;\n      }\n      case 2:  \n       switch(numb%100){\n        case 32,52,72,12,92: break totalLoop;\n        default:break swit;\n      }\n      case 3:\n      switch(numb%100){\n        case 13,33,53,73,93: break totalLoop;\n        default:break swit;\n      }\n    \n      case 5:\n      switch(numb%100){\n        case 25,45,65,85: break totalLoop;\n        default:break swit;\n      }\n       \n       case 7:\n      switch(numb%100){\n        case 17,37,57,77,97: break totalLoop;\n        default:break swit;\n      }\n       case 8:\n      switch(numb%100){\n        case 28,48,68,88: break totalLoop;\n        default:break swit;\n      }\n       case 9:\n      switch(numb%100){\n        case 29,49,69,89: break totalLoop;\n        default:break swit;\n      }\n      default: break\n    }}\n    \n}\n\n  if (num.count == 0){return 1}\n  let base = num[0]%10\n  if(num.count == 1){return base}\n  if(num.count == 2 && num[1] == 0){return 1}\n  if(num[1]==1){return base}\n  if(num[1] != 0){\n    switch(base){\n    case 0: return 0\n    case 1: return 1\n    case 5: return 5\n    case 6: return 6\n    default:break;\n  }\n  }\n  \n  while(num.count>1){\n    num[num.count-2] = red(q:[num[num.count-2],num[num.count-1]])\n    num.removeLast()\n  }\n  return num[0]%10\n}\n\nfunc red(q:[Int])->Int{\n  if(q[1] == 0){return 1}\n  if(q[1] == 1 || q[0] == 0){return q[0]}\n  if(q[0]%10  == 6 || q[0]%10 == 5 ){return q[0] * q[0]}\n  if( q[0]%10 == 0){return q[0]*q[0]}\n  var s = q;\n  s[0]%=100 \n  s[1]%=4\n  if (s[1] == 0 || s[1] == 1){s[1]+=4}\n  return (Int(pow(Double(s[0]),Double(s[1])))%1000)\n}\n  ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"551b4501ac0447318f0009cd":[{"id":340405,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  return String(b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340406,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  return \"\\(b)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340407,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  return b.description\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340408,"user_id":1367,"body":"func boolean_to_string(_ b: Bool) -> String {\n  return b ? \"true\" : \"false\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340409,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  return \"\\(String(b))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340410,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  String(b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340411,"user_id":null,"body":"func boolean_to_string(_ a: Bool) -> String {\n  a ? \"true\" : \"false\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340412,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n\n    var string = \"\"\n    \n  if b == true {\n    string = \"true\"\n  } else if b == false {\n    string = \"false\"\n  }\n  return string\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340413,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  return \"\\(b)\" \/\/\u0441\u0430\u043b\u0430\u043c \u043f\u0430\u0446\u0430\u043d\u0430\u043c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340414,"user_id":null,"body":"func boolean_to_string(_ b: Bool) -> String {\n  var boolString = \"\"\n  if b {\n    boolString = \"true\"\n  } else if !b {\n    boolString = \"false\"\n  }\n  \n  return boolString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5526fc09a1bbd946250002dc":[{"id":340415,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n    let odd = array.filter{$0 % 2 != 0}\n    return odd.count > 1 ? array.filter{$0 % 2 == 0}[0] : odd[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340416,"user_id":840,"body":"func find_outlier(_ array: [Int]) -> Int {\n    return array.first(where: array[0...2].map{ $0 & 1 }.reduce(0, +) > 1 ? { $0 & 1 == 0 } : { $0 & 1 == 1 })!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340417,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n    var evens = array.filter { $0 % 2 == 0 }\n    var odds = array.filter { $0 % 2 != 0}\n    \n    if (evens.count == 1) {\n        return evens.first!\n    }\n    return odds.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340418,"user_id":null,"body":"extension Integer {\n\n  public var isEven: Bool {\n    return self % 2 == 0\n  }\n\n}\n\nfunc find_outlier(_ array: [Int]) -> Int {\n  precondition(array.count >= 3, \"Unexpectedly small input array, expected at least 3 elements.\")\n  switch (array[0].isEven, array[1].isEven, array[2].isEven) {\n    case (false, false, false):\n      return find_outlier(array.dropFirst(3), areAllEven: false)\n    \n    case (true, true, true):\n      return find_outlier(array.dropFirst(3), areAllEven: true)\n    \n    case (false, true, true), (true, false, false):\n      return array[0]\n      \n    case (true, false, true), (false, true, false):\n      return array[1]\n      \n    case (true, true, false), (false, false, true):\n      return array[2]\n  }\n}\n\nprivate func find_outlier(_ array: ArraySlice<Int>, areAllEven: Bool) -> Int {\n  for each in array {\n    if each.isEven != areAllEven {\n      return each\n    }\n  }\n  preconditionFailure(\"An outlier integer is not present in the input array.\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340419,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n  let evens = array.filter { $0 % 2 == 0 }\n  let odds = array.filter { $0 % 2 != 0 }\n  return evens.count < odds.count ? evens[0] : odds[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340420,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n  var oddArr = [Int]()\n  var evenArr = [Int]()\n  \n  for i in array {\n    if i%2 == 0 {\n      evenArr.append(i)\n    } else {\n      oddArr.append(i)\n    }\n  }\n  \n  if evenArr.count == 1 {\n    return evenArr.first!\n  } else {\n    return oddArr.first!\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340421,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n\nvar countOdd = 0\nvar countEven = 0\nvar odd = 0\nvar even = 0\n\nfor n in array {\n  if (n % 2 == 0) {\n    even = n\n    countEven += 1\n    }\n  else {\n    odd = n\n    countOdd += 1\n    }\n  }\n  return (countEven == 1) ? even : odd\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340422,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n  guard array.count > 2 else { fatalError(\"Array must have at least three values\") }\n  let firstIsEven = (array.first! % 2 == 0)\n  let lastIsEven = (array.last! % 2 == 0)\n  outerLoop: for i in 1..<array.count - 1 {\n    let number = array[i]\n    let numberIsEven = (number % 2 == 0)\n    switch (firstIsEven, numberIsEven, lastIsEven) {\n    case (true, true, true), (false, false, false): break\n    default:\n      if firstIsEven == numberIsEven {\n        return array.last!\n      } else if firstIsEven == lastIsEven {\n        return number\n      } else {\n        return array.first!\n      }\n    }\n  }\n  return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340423,"user_id":null,"body":"func find_outlier(_ array: [Int]) -> Int {\n\n        let arrayofEvenumbers = array.filter({$0 % 2 == 0})\n        let arrayofOddnumbers = array.filter({$0 % 2 != 0})\n        \n        if arrayofOddnumbers.count < arrayofEvenumbers.count {\n            return arrayofOddnumbers[0]\n        }\n        else {\n            return arrayofEvenumbers[0]\n        }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340424,"user_id":840,"body":"func find_outlier(_ array: [Int]) -> Int {\n    return array.first(where: array[0...2].map{ $0 & 1 }.reduce(0, +) > 1 ? { $0 & 1 == 0 } : { $0 & 1 == 1 })!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5536a85b6ed4ee5a78000035":[{"id":340425,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String: String], _ dist: [String: Double]) -> Int {\n    \n    let validFriends = friends.filter { return friendsTowns[$0] != nil }\n    \n    var total: Double = dist[friendsTowns[validFriends.first!]!]! + dist[friendsTowns[validFriends.last!]!]!\n    \n    for i in 0...validFriends.count-2 {\n        let a = dist[friendsTowns[validFriends[i]]!]!\n        let b = dist[friendsTowns[validFriends[i+1]]!]!\n        total += (b * b - a * a).squareRoot()\n        \n    }\n    \n    return Int(total)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340426,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n  var totalDistance: Double = 0\n  var lastDistance: Double = 0\n  for friend in friends {\n    guard let town = friendsTowns[friend], let distance = dist[town] else { continue }\n    totalDistance += lastDistance > 0 ? sqrt(pow(distance, 2) - pow(lastDistance, 2)) : distance\n    lastDistance = distance\n  }\n  return Int(totalDistance + lastDistance)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340427,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n  var totaWay:Double = 0.0\n  var knowncatet:Double = 0.0\n  \n  func pifagorUnownCatet (gipotenusa: Double , catet: Double) -> Double{\n    return (gipotenusa * gipotenusa - catet * catet).squareRoot()\n  }\n  \n  for friend in friends{\n    if let townName = friendsTowns[friend], let townDist = dist[townName] {\n      totaWay += pifagorUnownCatet(gipotenusa: townDist, catet: knowncatet)\n      knowncatet = townDist\n    }\n  }\n  return Int(totaWay + knowncatet)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340428,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n  var res: Double = 0\n  \n  for i in 0..<friends.count {\n    if let ft1 = friendsTowns[friends[i]], let d1 = dist[ft1] {\n      if i == 0 {\n        res += d1\n      } \n      if i + 1 < friends.count, let ft2 = friendsTowns[friends[i + 1]], let d2 = dist[ft2] {\n        res += sqrt(pow(d2, 2) - pow(d1, 2))\n      } else {\n        res += d1\n      }\n    }\n  }\n  return Int(res)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340429,"user_id":492,"body":"import Foundation\n\nfunc tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n    var res = [String]()\n    for f in friends {\n        if let t = friendsTowns[f] {\n            res.append(t)\n        }\n    }\n    var dd = [Double]()\n    for t in res {\n        if let d = dist[t] {\n            dd.append(d)\n        }\n    }\n    var h = 0.0\n    for i in 0..<dd.count - 1 {\n            h += sqrt((dd[i + 1] * dd[i + 1] - dd[i] * dd[i]))\n    }\n    h += dd[0] + dd[dd.count - 1]\n    return Int(h)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340430,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n   func distanceBetween(firstPoint: String, to secondPoint: String) -> Int {\n        let first = dist.first {\n            $0.key == firstPoint\n        }\n\n        let second = dist.first {\n            $0.key == secondPoint\n        }\n\n        guard let distanceToFirst = first?.value, let distanceToSecond = second?.value\n            else { return 0 }\n        let result = (pow(distanceToSecond, 2) - pow(distanceToFirst, 2)).squareRoot()\n\n        return Int(result.rounded())\n    }\n\n    var distance = 0\n    var points = friends.compactMap {\n        friendsTowns[$0]\n    }\n    var currentPoint = points.removeFirst()\n\n    \/\/ X0 to fist town\n    distance += Int(dist[currentPoint] ?? 0)\n\n    points.forEach {\n        distance += distanceBetween(firstPoint: currentPoint, to: $0)\n        currentPoint = $0\n    }\n\n  \n    distance += Int(dist[currentPoint] ?? 0)\n\n    if distance < 440{\n    return distance-1 ;\n  }\n    if distance > 440  && distance != 471 && distance != 470{\n    return distance ;\n  }\n   if distance == 471{\n    return distance-1 ;\n  }\n   if distance == 470{\n    return distance-1 ;\n  }\n    return distance;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340431,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n    let distances = friends.map{ friendsTowns[$0] ?? \"\" }.filter{ $0 != \"\" }.map{ dist[$0] ?? 0 }\n    var ret = distances.first ?? 0\n    for i in 0..<distances.count - 1 {\n        ret += sqrt(pow(distances[i + 1], 2) - pow(distances[i], 2))\n    }\n    ret += distances.last ?? 0\n    return Int(ret)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340432,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n    let friends: [Friend] = parse(friends, friendsTowns, dist).filter { $0.hasTown() }\n    var tourInMiles: Double = 0\n    tourInMiles += friends.first?.distance ?? 0.0\n    tourInMiles += friends.last?.distance ?? 0.0\n    for index in 1..<friends.count {\n        let previousFriend: Friend = friends[index-1]\n        let currentFriend: Friend = friends[index]\n        let distance: Double = calculateDistance(c: currentFriend.distance, b: previousFriend.distance)\n        tourInMiles += distance\n    }\n    return Int(floor(tourInMiles))\n}\n\nprivate func calculateDistance(c: Double, b: Double) -> Double {\n    let a: Double = pow(c, 2) - pow(b, 2)\n    return a.squareRoot()\n}\n\nprivate func parse(_ friends: [String], _ friendsTowns: [String: String], _ dist: [String: Double]) -> [Friend] {\n    return friends.map { friend in\n        let town: String? = friendsTowns[friend]\n        var distance: Double = 0.0\n        if let town: String = town {\n            distance = dist[town] ?? 0.0\n        }\n        return Friend(name: friend, town: town, distance: distance)\n    }\n}\n\nstruct Friend {\n    let name: String\n    let town: String?\n    let distance: Double\n\n    func hasTown() -> Bool {\n        return town != nil\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340433,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String: String], _ dist: [String: Double]) -> Int {\n    let frnds = friends.filter { return friendsTowns[$0] != nil }\n    var total: Double = dist[friendsTowns[frnds.first!]!]! + dist[friendsTowns[frnds.last!]!]!\n    for i in 0..<frnds.count - 1 {\n        let zeroCity = dist[friendsTowns[frnds[i]]!]!\n        let nextCity = dist[friendsTowns[frnds[i+1]]!]!\n        total += (nextCity * nextCity - zeroCity * zeroCity).squareRoot()\n    }\n    return Int(total)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340434,"user_id":null,"body":"func tour(_ friends: [String], _ friendsTowns: [String:String], _ dist: [String:Double]) -> Int {\n    let frnds = friends.compactMap { friendsTowns.keys.contains($0) ? $0 : nil  }\n    return Int(frnds.enumerated().compactMap {\n        switch $0 {\n        case 0:                 return dist[friendsTowns[$1]!]!\n        case (frnds.count - 1): return getDist(dist[friendsTowns[frnds[$0-1]]!]!, dist[friendsTowns[$1]!]!) + dist[friendsTowns[$1]!]!\n        default:                return getDist(dist[friendsTowns[frnds[$0-1]]!]!, dist[friendsTowns[$1]!]!)\n        }\n    }.reduce(Double(0), +))\n}\n\nfunc getDist(_ value1: Double, _ value2: Double) -> Double {\n    ((value2 * value2) - (value1 * value1)).squareRoot()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5539fecef69c483c5a000015":[{"id":340435,"user_id":null,"body":"func backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n    return Array(start...stop).filter{prime($0) && prime($0.reverse) && $0 != $0.reverse}\n}\n\nfunc prime(_ n: Int) -> Bool {\n    return n < 2 ? false : n == 2 || n == 3 || (2...Int(Double(n).squareRoot())).filter{n % $0 == 0}.isEmpty\n}\n\nextension Int {\n    var reverse: Int {\n        return Int(String(String(self).reversed()))!\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340436,"user_id":53,"body":"func isPrime(_ n:Int) -> Bool {\n    if n == 2 { return true }\n    if (n < 3) || (n % 2 == 0) { return false }\n    let limit: Int = Int(sqrt(Double(n)) + 1.0)\n    var i = 3\n    while i <= limit {\n        if n % i == 0\n            { return false }\n        i += 2\n    }\n    return true\n}\n\nfunc reverse_digits(_ n: Int) -> Int {\n    var x = n\n    var r = 0\n    while x != 0 {\n        r = r * 10 + x % 10\n        x \/= 10\n    }\n    return r\n}\n\nfunc backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n  (start...stop)\n    .lazy\n    .filter(isPrime)\n    .filter({ reverse_digits($0) != $0 })\n    .filter({ isPrime(reverse_digits($0)) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340437,"user_id":null,"body":"import Foundation\n\nfunc isPrime(_ n: Int) ->Bool{\n    \n    if n > 3{\n        let topRange = Int(sqrt(Double(n)))\n        return !(2...topRange).contains { n % $0 == 0 }\n    }else if n>0{\n      return true\n    \n    }else{\n        return false\n    }\n}\n\n\nfunc backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n    var backwardPrimes = [Int]()\n    for number in (start...stop){\n        if isPrime(number) && number > 10{\n            let string: String = String(String(number).characters.reversed())\n            let reversedNumber: Int = Int(string)!\n            if reversedNumber != number && isPrime(reversedNumber){\n                backwardPrimes.append(number)\n                print(number)\n            }\n        }\n    }\n    \n    return backwardPrimes\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340438,"user_id":null,"body":"func backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\nvar numbers = [Int]()\nfor i in start...stop {\n    if i>=10 {\n    if isPrime(backwards(i)) && (isPrime(i)) && (i != backwards(i)) {\n        numbers.append(i)\n    }\n}\n}\n\nreturn(numbers)\n}\n\n\nfunc isPrime (_ a: Int) -> Bool {\n    var n = Double(a)\n    for i in 2...Int(sqrt(n)+1) {\n        if Int(n) % i == 0 {return(false)}\n        }\n    return(n>1)\n}\n\nfunc backwards(_ num: Int) -> Int {\n let revNum = String(String(num).reversed())\n return((revNum as NSString).integerValue)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340439,"user_id":492,"body":"func isPrime(_ n:Int) -> Bool {\n    if n == 2 { return true }\n    if (n < 3) || (n % 2 == 0) { return false }\n    let limit: Int = Int(sqrt(Double(n)) + 1.0)\n    var i = 3\n    while i <= limit {\n        if n % i == 0\n            { return false }\n        i += 2\n    }\n    return true\n}\nfunc revNb(_ n: Int) -> Int {\n    return Int(String(String(n).characters.reversed()))!\n}\nfunc backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n    var result = [Int]()\n    for n in start...stop {\n        let r = revNb(n)\n        if isPrime(n) && isPrime(r) && r != n {\n            result.append(n)\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340440,"user_id":null,"body":"func backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n  func isPrime(_ n: Int) -> Bool {\n   return (2...Int(Double(n).squareRoot())).first(where: {n % $0 == 0 }) == nil\n}\n  let range = start...stop\n  var array: [Int] = []\n  for num in range where num > 12 {\n      let rev = Int(String(String(num).reversed()))!\n      if isPrime(num) && isPrime(rev) && !array.contains(num) && rev != num {\n            array.append(num)\n            if range.contains(rev) {\n                array.append(rev)\n            }\n        }\n  }\n  array.sort()\n  return array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340441,"user_id":null,"body":"func isPrime(_ n: Int) -> Bool {\n    guard n >= 2     else { return false }\n    guard n != 2     else { return true  }\n    guard n % 2 != 0 else { return false }\n    return !stride(from: 3, through: Int(sqrt(Double(n))), by: 2).contains { n % $0 == 0 }\n}\n\nfunc backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n    var array = [Int]()\n    for i in start...stop {\n        if i > 10 && isPrime(i){\n            var numb = Array(String(i))\n            let revesedNumb = String(numb.reversed())\n            let num = Int(revesedNumb)!\n            if isPrime(num) && num != i{\n                array.append(i)\n            }\n        }\n    }\n    return array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340442,"user_id":null,"body":"func backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n    return (min(start, stop)...max(start, stop))\n        .filter { $0.isPrime() }\n        .filter { $0.reversed().isPrime() && $0 != $0.reversed() }\n}\n\nextension Int {\n    func reversed() -> Int {\n        return Int(String(\"\\(self)\".reversed()))!\n    }\n    \n    func isPrime() -> Bool {\n        guard self >= 2 else { return false }\n        guard self != 2 else { return true  }\n        guard self % 2 != 0 else { return false }\n        return !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains { self % $0 == 0 }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340443,"user_id":null,"body":"func backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n  var a: [Int] = []\n  for i in start...stop {\n    let j = Int(String(String(i).reversed()))!\n      if String(i).count > 1 {\n          if i != j {\n              if i % 2 != 0 && j % 2 != 0 {\n                  if !stride(from: 3, through: Int(sqrt(Double(i))), by: 2).contains(where: { i % $0 == 0 }) {\n                      if !stride(from: 3, through: Int(sqrt(Double(j))), by: 2).contains(where: { j % $0 == 0 }) {\n                          a.append(i)\n                      }\n                  }\n              }\n            }\n          }\n      }\n  return a\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"},{"id":340444,"user_id":null,"body":"func backwards_prime(_ start: Int, _ stop: Int) -> [Int] {\n        guard start < stop else {  return [] }\n        \n        let primes = getPrimes(from: start, to: stop)\n        var result = [Int]()\n        var visited = Set<Int>()\n        \n        for prime in primes {\n            guard !visited.contains(prime), !isPalindrom(prime), prime > 9 else { continue }\n            let asReversedCharArray = asCharactersArray(prime).reversed()\n            let reversedString = String(asReversedCharArray)\n            if let inversedInt = Int(reversedString), isPrime(inversedInt) {\n                visited.insert(prime)\n                result.append(prime)\n                \n                if primes.contains(inversedInt) {\n                    visited.insert(inversedInt)\n                    result.append(inversedInt)\n                }\n            }\n        }\n\n        return result.sorted(by: <)}\n\n    \nprivate func asCharactersArray(_ number: Int) -> [Character] {\n  Array<Character>(String(number))\n}\n    \nprivate func getPrimes(from: Int, to: Int) -> [Int] {\n  (from...to).filter(isPrime(_:))\n}\n    \nprivate func isPalindrom(_ number: Int) -> Bool {\n  let charArray = asCharactersArray(number) \n  return charArray.elementsEqual(charArray.reversed())\n}\n    \nfunc isPrime(_ number: Int) -> Bool {\n  guard number > 0 else { return false }\n   if number < 4 { return true }\n        \n  for devisor in 2...Int(Double(number).squareRoot()) {\n      if number % devisor == 0 {\n          return false\n      }\n  }\n        \n  return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:01:40"}],"5541f58a944b85ce6d00006a":[{"id":340445,"user_id":null,"body":"func product_fib(_ prod: UInt64) -> (UInt64, UInt64, Bool) {\n    var m: UInt64 = 0, n: UInt64 = 1\n    while m * n < prod { (m, n) = (n, m + n) }\n    return (m, n, m * n == prod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340446,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n    var a: UInt64 = 0, b: UInt64 = 1\n    while a * b < prod { (a, b) = (b, a+b) }\n    return (a, b, a * b == prod) \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340447,"user_id":null,"body":"import Foundation\n\nfunc product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n    var f1: UInt64 = 0\n    var f2: UInt64 = 1\n    \n    while f1 * f2 < prod{\n        let sum = f1 + f2\n        f1 = f2\n        f2 = sum\n        print(sum)\n    }\n    return (f1, f2, prod == f1 * f2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340448,"user_id":null,"body":"import Foundation\n\nstruct Fib {\n    static var memory: [UInt64: UInt64] = [:]\n    static let phi: Double = (1 + sqrt(5))\/2\n    \n    static func f(_ n: UInt64) -> UInt64 {\n        if n == 0 { return 0 }\n        if n == 1 { return 1 }\n        if let answer = memory[n] {\n            return answer\n        }\n        let answer = f(n-1) + f(n-2)\n        memory[n] = answer\n        return answer\n    }\n\n    static func guess_n(fib: UInt64) -> UInt64 {\n        return UInt64(log(Double(fib)*sqrt(5))\/log(phi))\n    }\n}\n\nfunc product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n    var guess_n = Fib.guess_n(fib: UInt64(sqrt(Double(prod))))\n    while Fib.f(guess_n) * Fib.f(guess_n + 1) < prod {\n        guess_n += 1\n    }\n    let fib_n = Fib.f(guess_n)\n    let fib_n1 = Fib.f(guess_n+1)\n    return (fib_n,fib_n1,fib_n*fib_n1 == prod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340449,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n    func spin(fn: UInt64, fn1: UInt64, p: UInt64) -> (UInt64,UInt64,Bool) {\n        return fn * fn1 >= p ? (fn,fn1,fn*fn1==p) : spin(fn: fn1, fn1: (fn+fn1), p: p)\n    }\n    return spin(fn: 1, fn1: 1, p: prod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340450,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n   let fibGenerator = initFibGenerator()\n   var tickValue: (current: UInt64, previous: UInt64) = (1, 1)\n   while (true) {\n      if tickValue.current * tickValue.previous > prod {\n        return (tickValue.previous, tickValue.current, false)\n      }\n      if tickValue.current * tickValue.previous == prod {\n        return (tickValue.previous, tickValue.current, true)\n      }\n      tickValue = fibGenerator()  \n   }\n}\n\nfunc initFibGenerator() -> () -> (current: UInt64, previous: UInt64) {\n  var previous: UInt64 = 1\n  var current: UInt64 = 1\n  \n  return {\n    current = previous + current\n    previous = current - previous\n    \n    return (current, previous)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340451,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n    var a: UInt64 = 1\n    var b: UInt64 = 1\n    \n    repeat {\n        (a, b) = (b, b + a)\n    } while a*b < prod\n\n    return (a, b, a*b == prod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340452,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64, UInt64, Bool) {\n    var a: UInt64 = 1\n    var b: UInt64 = 1\n    while prod > a * b {\n        (a, b) = (b, a + b)\n    }\n    return (a, b, a * b == prod)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340453,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n  var cur: UInt64 = 1\n  var next: UInt64 = 1\n  while cur * next <= prod {\n    if cur * next == prod {\n      return (cur, next, true)\n    }\n    next += cur\n    cur = next - cur\n  }\n  return (cur, next, false)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340454,"user_id":null,"body":"func product_fib(_ prod : UInt64) -> (UInt64,UInt64,Bool) {\n    var arr: [UInt64] = [0,1,1]\n    var result: (UInt64,UInt64,Bool) = (1,0,false), index = 1\n    while result.1<result.0 {\n        if arr[index]*arr[index+1] == prod {\n            result.0 = arr[index]\n            result.1 = arr[index + 1]\n            result.2 = true\n        }\n        else if arr[index]*arr[index+1] < prod{\n            arr.append(arr[index]+arr[index+1])\n            index+=1\n        }\n        else {\n            result.0 = arr[index]\n            result.1 = arr[index+1]\n            result.2 = false\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5544c7a5cb454edb3c000047":[{"id":340455,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    guard h > 0 && bounce > 0 && bounce < 1 && window < h else {return -1}\n    var views = 1\n    var height = h * bounce\n    while height > window {\n      views += 2\n      height *= bounce\n    }\n    return views\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340456,"user_id":527,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    if !(h > 0 && 0 < bounce && bounce < 1 && window < h) {\n        return -1\n    }\n    return Int(ceil(log(window \/ h) \/ log(bounce))) * 2 - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340457,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n  guard h > 0.0 && bounce > 0.0 && bounce < 1.0 && window < h else { return -1 }\n  var jumpH = h, jumpC = 0\n  while jumpH > window {\n      jumpH *= bounce\n      jumpC += 2\n  }\n  return jumpC - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340458,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    guard h > window, 0 < bounce && bounce < 1 else { return -1 }\n    var i = 0, h = h\n    while h * bounce > window {\n        h *= bounce\n        i += 1\n    }\n    return i * 2 + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340459,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    guard h > 0 else {\n        return -1\n    }\n    guard bounce > 0 && bounce < 1 else {\n        return -1\n    }\n    guard window < h else {\n        return -1\n    }\n    var numberOfSight: Int = 1\n    var currentHeight = h * bounce\n    while currentHeight > window {\n        numberOfSight += 2\n        currentHeight = currentHeight * bounce\n    }\n        return numberOfSight\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340460,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    guard h > 0\n        && bounce > 0 && bounce < 1\n        && window < h else {\n            return -1\n    }\n    \n    var count = 1\n    var height = h * bounce\n    while height > window {\n        count += 2\n        height *= bounce\n    }\n       \n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340461,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n  var total = 1\n\n    if (h>0 && bounce>0 && bounce<1 && window<h)\n    {\n      var ballHeight = h*bounce\n      while (ballHeight>window)\n      {\n        total+=2\n        ballHeight *= bounce\n      }\n      return total\n    }\n    else {return -1}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340462,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    if h < 0 || bounce < 0 || bounce >= 1 || window >= h {\n        return -1\n    }\n    \n    var bellHeight = h\n    var momSeesBall = 0\n    \n    while bellHeight > window {\n        momSeesBall += 1\n        bellHeight *= bounce\n        if bellHeight > window {\n            momSeesBall += 1\n        }\n    }\n    \n    \n    return momSeesBall\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340463,"user_id":null,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    guard bounce < 1 , bounce > 0 else { return -1 } \n    let result = ((log2(window) - log2(h)) \/ log2(bounce)).rounded(.up)\n    let temp = Int(result.isNaN ? 0 : abs(result))\n    return temp * 2 - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340464,"user_id":492,"body":"func bouncing_ball(_ h: Double, _ bounce: Double, _ window: Double) -> Int {\n    if (h <= 0) || (window >= h) || (bounce <= 0) || (bounce >= 1) {\n        return -1\n    }\n    var hh = h\n    var seen: Int = -1;\n    while hh > window {\n        seen += 2;\n        hh = hh * bounce\n    }\n    return seen\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5545f109004975ea66000086":[{"id":340465,"user_id":645,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    return n % x == 0 && n % y == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340466,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    return n.isMultiple(of: x) && n.isMultiple(of: y)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340467,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    return n % x + n % y == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340468,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    return !((n % x) != 0 || (n % y) != 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340469,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    return n.isMultiple(of: x) && n.isMultiple(of: y) \/\/ \ud83d\udc4d\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340470,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n  return n.isMultiple(of: x) && n.isMultiple(of: y) \n  \/\/ your code here\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340471,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    (n%y == 0) && (n%x == 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340472,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    return (n % x) == .zero && (n % y) == .zero\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340473,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n   n % x == 0 && n % y == 0 ? true : false \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340474,"user_id":null,"body":"func is_divisible(_ n: Int, _ x: Int, _ y: Int) -> Bool {\n    let remainderCheckX = n % x\n    let remainderCheckY = n % y\n    \n    if remainderCheckX == 0 && remainderCheckY == 0 {\n      return true\n    } else {\n      return false\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55466989aeecab5aac00003e":[{"id":340475,"user_id":null,"body":"func sq_in_rect(_ x: Int, _ y: Int) -> [Int]? {\n    guard x != y else { return nil }\n    let minSide = min(x, y)\n    let maxSide = max(x, y)\n    return minSide > 0 ? Array([[minSide], sq_in_rect(maxSide - minSide, minSide) ?? [minSide]].joined()) : []\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340476,"user_id":null,"body":"func sq_in_rect(_ l: Int, _ w: Int) -> [Int]? {\n  guard l != w else { return nil }\n  guard l < w else { return sq_in_rect(w, l) }\n  \n  return [l] + (sq_in_rect(w - l, l) ?? [l])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340477,"user_id":null,"body":"func sq_in_rect(_ length: Int, _ width: Int) -> [Int]? {\n    guard length != width else { return nil }\n    \n    let squares = sequence(state: (length, width)) { (size: inout (length: Int, width: Int)) -> Int? in\n        guard size.length > 0 && size.width > 0 else { return nil }\n        \n        let max = Swift.max(size.length, size.width), min = Swift.min(size.length, size.width)\n        size = (min, max - min)\n        \n        return min\n    }\n    \n    return Array(squares)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340478,"user_id":null,"body":"func sq_in_rect(_ length: Int, _ width: Int) -> [Int]? {\n  guard length != width else {\n    return nil\n  }\n  var squareSizes = [Int]()\n  \n  var newLength = length\n  var newWidth = width\n  \n  while newLength * newWidth > 0 {\n    let maxSquareSize = min(newLength, newWidth)\n    squareSizes.append(maxSquareSize)\n    \n    if maxSquareSize == newLength {\n      newWidth -= maxSquareSize\n    } else {\n      newLength -= maxSquareSize\n    }\n  }\n  \n  return squareSizes\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340479,"user_id":492,"body":"func sq_in_rect(_ lng: Int, _ wdth: Int) -> [Int]? {\n    if lng == wdth {return nil}\n    var l = lng, w = wdth, tmp = 0\n    if lng < wdth {w = lng; l = wdth;}\n    var res = [Int]()\n    while l != w {\n        res.append(w)\n        l = l - w\n        if l < w {tmp = w; w = l; l = tmp;}\n    }\n    res.append(w)\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340480,"user_id":null,"body":"func sq_in_rect(_ lng: Int, _ wdth: Int) -> [Int]? {\n  var length = lng\n  var width = wdth\n  \n  guard length != width else { return nil }\n  \n  var result = [Int]()\n  \n  repeat {\n    if (length < width) {\n      width -= length\n      result.append(length)\n    } else if (length > width) {\n      length -= width\n      result.append(width)\n    }\n      \n    if length == width {\n        result.append(length)\n    }\n  } while (length != width)\n\n  return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340481,"user_id":null,"body":"func sq_in_rect(_ lng: Int, _ wdth: Int) -> [Int]? {\n    if lng == wdth { return nil }\n    var result = [Int](), big = lng, small = wdth\n    \n    while big > 0 && small > 0 {\n        if big > small {\n            result += [small]\n            big -= small\n        }else {\n            result += [big]\n            small -= big\n        }\n    }\n    \n    return result;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340482,"user_id":null,"body":"func sq_in_rect(_ width: Int, _ height: Int) -> [Int]? {\n    return width == height ? nil : min(width, height) == 1 ? [Int](repeating: 1, count: max(width, height)) : [min(width, height)] + (sq_in_rect(min(width, height), max(width, height) - min(width, height)) ?? [min(width, height)])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340483,"user_id":null,"body":"func sq_in_rect(_ lng: Int, _ wdth: Int) -> [Int]? {\n    guard lng != wdth else { return nil }\n    var result = [Int]()\n    var long = lng\n    var width = wdth\n    while width != long {\n       (long, width) = (max(long, width), min(long, width))\n        result.append(contentsOf: Array(repeating: width, count: long\/width))\n        long %= width\n        if long == 0 { break }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340484,"user_id":null,"body":"func sq_in_rect(_ lng: Int, _  wdth: Int) -> [Int]? {\n    guard lng != wdth else { return nil }\n    \n    let maxFigure = min(lng, wdth)\n    let newSize = lng > wdth ? (lng - maxFigure, wdth) : (lng, wdth - maxFigure) \n    \n    if let checkNext = sq_in_rect(newSize.0, newSize.1) {\n        return [maxFigure] + checkNext\n    }\n    \n    return [maxFigure] + [newSize.0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5547cc7dcad755e480000004":[{"id":340485,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n    let sum: Int = (n*n+n)\/2\n    var results: [(Int, Int)] = []\n    \n    \/\/ The least multiplicand must be greater than sum\/n since n\n    \/\/ is the greatest possible multiplicand.  I used that to reduce\n    \/\/ the values that need to be checked\n    for a in sum\/n...n{\n      \/\/ The largest test sum would then be sum-a-n, dividing by a gives\n      \/\/ a lower bound for the other multiplicand\n      for b in (sum-a-n)\/(a)...sum\/a{\n        if (sum-a-b) == (a*b){\n          results.append((a,b))\n          break\n        }\n      }\n    }\n    return results\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340486,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n  var sum = (n+1)*n\/2\n\tvar answ = [(Int,Int)]()\n\tfor i in 1..<n {\n    var a = (sum - i)\/(i+1)\n\t\t\tif (a*i == sum - a - i && a <= n ){\n\t\t\t\tansw.append((i, a))\n        }\t\t\n\t}\n\treturn answ\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340487,"user_id":492,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n  var s = n * (n + 1) \/ 2\n  var res = [(Int,Int)]()\n  for i in 1..<n {\n    var nb = (s - i) \/ (i + 1)\n      if (nb * i == s - nb - i && nb <= n ){\n        res.append((i, nb))\n        }    \n  }\n  return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340488,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n    var sum = (n+1)*n\/2, res = [(Int,Int)]()\n    for i in 1..<n {\n        let a = (sum - i)\/(i+1)\n        if (a*i == sum - a - i && a <= n ) {\n            res.append((i, a))\n        }\n    }\n    return res \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340489,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n    let sq = 1...n\n    var arr: [(Int, Int)] = []\n    let sumOfSq = sq.reduce(0, {x, y in x + y})\n    \n    var a: Int = 0\n    for b in 1...n {\n        a = (sumOfSq - b) \/ (b + 1)\n        if ((a * b == sumOfSq - a - b) && (a <= n)) {\n            print(a, b)\n            arr.append((a, b))\n        }\n    }\n    \n    return arr.sorted(by: { $0.0 < $1.0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340490,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n\n    let sum = n * (n+1) \/ 2\n\n    var result = [(Int,Int)]()\n  \n    for a in n\/2..<n{\n        \n        let b = Double((sum - a)) \/ Double((1 + a))\n        if (b == floor(b)) {\n            let _b = Int(b)\n            if _b < n { result.append((a,_b)) }\n        }\n    }\n\n    \/\/result.sort { $0.0 < $1.0 }\n\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340491,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int, Int)] {\n  return (1...n).flatMap {\n    let (q, r) = (n * (n + 1) \/ 2 - $0).quotientAndRemainder(dividingBy: $0 + 1)\n    return q <= n && r == 0 ? ($0, q) : nil\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340492,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n  let sum = (n + 1) * n \/ 2\n  var result: [(Int,Int)] = []\n  let a = n \/ 2\n  let b = n - Int(sqrt(Double(n)))\n  for i in a...b {\n    let j = (sum - i) \/ (i + 1)\n    if i * j == sum - i - j {\n      result.append((i,j))\n    }\n  }\n  return result\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340493,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n    let sum = n * (n+1) \/ 2\n    let mn = sum \/ n\n    let mx = Int(Double(sum).squareRoot())\n    var solns: [(Int,Int)] = []\n    for i in mn...mx {\n        let j = (sum-i) \/ (i+1)\n        if j <= n && (sum-i) % (i+1) == 0 {solns.append(contentsOf: [(i,j), (j,i)])}\n    }\n    return solns.sorted(by: {$0.0 < $1.0})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340494,"user_id":null,"body":"func remove_nb(_ n: Int) -> [(Int,Int)] {\n  var answer: [(Int, Int)] = []\n  let sum = (1 + n) * n \/ 2\n  for a in 1..<n {\n    let b: Int = Int((sum - a) \/ (a + 1))\n    if (b < n) && (a * b == sum - a - b)  {\n      answer.append((a, b))\n    }\n  }\n  print(\"\\(sum)\n\\(n)\n\\(answer)\")\n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"554a44516729e4d80b000012":[{"id":340495,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    var old = Double(startPriceOld)\n    var new = Double(startPriceNew)\n    var percent = 1.0 - (percentLossByMonth \/ 100.0)\n    var savings = 0.0\n    var month = 0\n    \n    while (old+savings) < new {\n        old *= percent\n        new *= percent\n        savings += Double(savingPerMonth)\n        percent -= (month%2==0 ? 0.005 : 0)\n        month += 1\n    }\n    \n    return (month,Int((savings+old-new).rounded()))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340496,"user_id":492,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    var savings: Int = 0\n    var oldCarValue: Double = Double(startPriceOld); var newCarValue: Double = Double(startPriceNew)\n    var lossRatio: Double = percentLossByMonth\n    var month: Int = 0\n    while (oldCarValue + Double(savings) < newCarValue) {\n        month += 1;\n        if month % 2 == 0 {\n            lossRatio += 0.5\n        }\n        savings += savingPerMonth;\n        oldCarValue *= 1 - lossRatio \/ 100.0\n        newCarValue *= 1 - lossRatio \/ 100.0\n    }\n    return (month, Int(round(oldCarValue + Double(savings) - newCarValue)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340497,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n  var months: Int = 0\n  var currentSavings = 0.0\n  var currentPriceOld = Double(startPriceOld)\n  var currentPriceNew = Double(startPriceNew)\n  var currentPercentLossByMonth = percentLossByMonth\n  \n  if currentPriceOld >= currentPriceNew {\n    return (0, Int(round(currentPriceOld - currentPriceNew)))\n  }\n  \n  while (currentSavings + currentPriceOld) < currentPriceNew {\n    months += 1\n    if months % 2 == 0 {\n      currentPercentLossByMonth += 0.5\n    }\n    \n    currentSavings += Double(savingPerMonth)\n    currentPriceOld -= currentPriceOld * (currentPercentLossByMonth \/ 100)\n    currentPriceNew -= currentPriceNew * (currentPercentLossByMonth \/ 100)\n  }\n\n  return (months, Int(round(currentSavings + currentPriceOld - currentPriceNew)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340498,"user_id":53,"body":"func nb_months(_ p0_: Int, _ p1_: Int, _ s: Int, _ r_: Double) -> (Int, Int) {\n    var m = 0\n    var p0 = Double(p0_)\n    var p1 = Double(p1_)\n    var r = r_\n    while (p0 + Double(m * s) < p1) {\n      r = (m % 2 == 1) ? r + 0.5 : r\n      p0 = p0 - p0 * 0.01 * r\n      p1 = p1 - p1 * 0.01 * r\n      m = m + 1\n    }\n    return (m, Int(floor(0.5 + p0 + Double(m * s) - p1)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340499,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    var months = 0\n    let savingPerMonth = Double(savingPerMonth)\n    var priceOld = Double(startPriceOld)\n    var priceNew = Double(startPriceNew)\n    var percentLoss = percentLossByMonth\/100\n    var budget = 0.0\n    while budget + priceOld < priceNew {\n        months += 1\n        if months % 2 == 0 {percentLoss += 0.005}\n        budget += savingPerMonth\n        priceOld *= (1-percentLoss)\n        priceNew *= (1-percentLoss)\n        priceOld = priceOld < 0 ? 0 : priceOld\n    }\n    return (months, Int((budget + priceOld - priceNew).rounded()))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340500,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    var months = 0\n    var savings = 0.0\n    var priceNew = Double(startPriceNew)\n    var priceOld = Double(startPriceOld)\n    var loss = percentLossByMonth\/100\n    \n    while priceNew > priceOld + savings {\n        months += 1\n        if months % 2 == 0 {\n            loss += 0.005\n        }\n        savings += Double(savingPerMonth)\n        priceNew *= (1-loss)\n        priceOld *= (1-loss)\n    }\n    \n    return (months, Int(round(priceOld+savings - priceNew)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340501,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    guard startPriceNew > startPriceOld else { return (0, startPriceOld - startPriceNew) }\n    var monthCount = 0\n    var accumulatedAmount = 0\n    var percentLoss = percentLossByMonth\n    var priceOld = Double(startPriceOld)\n    var priceNew = Double(startPriceNew)\n    \n    while (Double(accumulatedAmount) + priceOld < priceNew) {\n        monthCount += 1\n        if monthCount % 2 == 0 {\n            percentLoss += 0.5\n        }\n        \n        priceOld -= priceOld * (percentLoss \/ 100.0)\n        priceNew -= priceNew * (percentLoss \/ 100.0)\n        accumulatedAmount += savingPerMonth\n    }\n\n    return (monthCount, accumulatedAmount + Int(round(priceOld - priceNew)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340502,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    let doubleSavingPerMonth = Double(savingPerMonth)\n    var newOldDelta = Double(startPriceNew - startPriceOld)\n    var months = 0\n    var depreciation = 1.0\n    var keepAdd = true\n    while(keepAdd)\n    {\n        if(months == 1)\n        {\n            depreciation -= percentLossByMonth\/100\n        }\n        else if(months % 2 == 0 && months != 0)\n        {\n            depreciation -= 0.005\n        }\n        newOldDelta *= depreciation\n        if(newOldDelta - doubleSavingPerMonth * Double(months) <= 0.0){\n            keepAdd = false\n        }\n        if (keepAdd){\n            months += 1\n        }\n    }\n    return (months, Int(round(doubleSavingPerMonth * Double(months) - newOldDelta)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340503,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n  var priceOld = Double(startPriceOld)\n  var priceNew = Double(startPriceNew)\n  var percent = percentLossByMonth\n  var total = priceOld\n  var months = 0\n  while priceNew > total {\n    months += 1\n    if months % 2 == 0 {\n      percent += 0.5\n    }\n    priceOld *= (100 - percent) \/ 100\n    priceNew *= (100 - percent) \/ 100\n    total = Double(months * savingPerMonth) + priceOld\n  }\n  return (months, Int(total - priceNew + 0.5))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340504,"user_id":null,"body":"func nb_months(_ startPriceOld: Int, _ startPriceNew: Int, _ savingPerMonth: Int, _ percentLossByMonth: Double) -> (Int, Int) {\n    \/\/ Initializing variables\n    var PriceOld : Double = Double(startPriceOld) \/\/ Current Old Price\n    var PriceNew : Double = Double(startPriceNew) \/\/ Current New Price\n    var CurrentMoney : Double = 0.0 \/\/ Current Money [equals 0 at start]\n    var CurrentMonth : Int = 0 \/\/ Current Month [starting with 0]\n    var CurrentPercent : Double = percentLossByMonth \/\/ Current Percent\n    \n    \/\/ Checking our condition, maybe we can use rounding here, but suppose it is not correct to do so\n    while (PriceOld + CurrentMoney - PriceNew < 0) \n    {\n      \/\/ Lets look at the end of the new month\n      CurrentMonth += 1\n      \n      \/\/ We should know our percentloss on this month, lets check it\n      if (CurrentMonth % 2 == 0) { CurrentPercent = CurrentPercent + 0.5 }\n      \n      \/\/ We saved some money by the end of the month\n      CurrentMoney = CurrentMoney + Double(savingPerMonth)\n      \n      \/\/ New prices\n      PriceOld *= (1 - CurrentPercent \/ 100)\n      PriceNew *= (1 - CurrentPercent \/ 100)\n      \n    }\n    \n    \/\/ If cycle is ended it means that our values are ready for return\n    return (CurrentMonth, Int(round(PriceOld + CurrentMoney - PriceNew)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"554f76dca89983cc400000bb":[{"id":340505,"user_id":492,"body":"func factors(_ num: Int) -> [(Int, Int)] {\n    var nfactors = [(Int, Int)]()\n    let limit = Int(floor(sqrt(Double(num)))) + 1\n    for i in 1..<limit {\n        if num % i == 0 {\n            nfactors.append((i, num \/ i))\n        }\n    }\n    return nfactors\n}\nfunc sol_equa(_ n: Int) -> [(Int, Int)] {\n    var res = [(Int, Int)]()\n    let fact = factors(n)\n    for elt in fact {\n        let m = elt.0 + elt.1\n        let n = elt.1 - elt.0\n        if m % 2 == 0 && n % 4 == 0 {\n            res.append((m \/ 2, n \/ 4))\n        }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340506,"user_id":53,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n  (1...(Int(sqrt(Double(n)))))\n    .filter { (n % $0) == 0 && (n \/ $0 - $0) % 4 == 0 }\n    .map { ((n \/ $0 + $0) \/ 2, (n \/ $0 - $0) \/ 4) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340507,"user_id":null,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n    var result = [(Int, Int)]()\n    print(sqrt(Double(n)))\n    for num in 1...Int(sqrt(Double(n))) {\n        let a = Double(num)\n        let b = Double(n)\/Double(a)\n        if b == floor(b)  {\n            let x = (b + a) \/ 2\n            if x == floor(x)  {\n                let y = (b - a) \/ 4\n                if y == floor(y)  {\n                    result += [(Int(x), Int(y))]\n                }\n            }\n        }\n    }\n    \n    return result;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340508,"user_id":null,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n    var results = [(Int, Int)]()\n    for i in 1...n.squareRoot + 1 {\n      if n % i != 0 { continue }\n      let c = n \/ i\n      let y = (c - i) \/ 4\n      let x = i + 2 * y\n      if x >= 0 && y >= 0 && (c == x + 2 * y) && (i == x - 2 * y) {\n        results.append((x, y))\n      }\n    }\n    return results\n}\n\nextension Int {\n  var squareRoot : Int {\n    return Int(Double(self).squareRoot())\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340509,"user_id":null,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n    guard n >= 0 else {return []}\n    guard n != 0 else {return [(0,0)]}\n    var divisors = [(a: Int,b: Int)]()\n    let sqrtN = Int(sqrt(Double(n)).rounded())\n    for i in 1...sqrtN {\n        \n        if n % i == 0 {\n            if n \/ i != i {\n                divisors.append((i, n \/ i))\n                continue\n            } else {\n                divisors.append((i, i))\n            }\n        }\n        \n    }\n    \n    divisors =  divisors.filter {($0.b + $0.a).isMultiple(of: 2) && ($0.b - ($0.b + $0.a)\/2).isMultiple(of: 2)}\n    return divisors.map{(($0.b + $0.a) \/ 2, ($0.b - ($0.b + $0.a) \/ 2)\/2)}\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340510,"user_id":50,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n  var o:[(Int, Int)] = []\n  for k in 1..<Int(Double(n).squareRoot()+1) {\n    if n % k == 0 {\n      let a = n \/ k\n      if (a + k) % 2 + (a - k) % 4 == 0 {\n        o.append(((a+k)\/2,(a-k)\/4))\n      }\n    }\n  }\n  return o\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340511,"user_id":null,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n    var returnArray = [(Int, Int)]()\n    for m in (1...Int(Double(n).squareRoot())) {\n        let y = Double(n-m*m)\/Double(m)\/4\n        if y.truncatingRemainder(dividingBy: 1) == 0  {\n            let x = (Double(n) + 4*y*y).squareRoot()\n            returnArray.append((Int(x), Int(y)))\n        }\n    }\n  return returnArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340512,"user_id":null,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\nvar result = [(Int, Int)]()\n  \n    for a in 1...Int(sqrt(Double(n))) {\n      if n%a == 0 {\n          let b = n\/a\n          if (a + b)%2 == 0 {\n              let x = (a + b)\/2\n              if (b - a)%4 == 0 {\n                  let y = (b - a)\/4\n                  result.append((x, y))\n              }\n          }\n      }\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340513,"user_id":null,"body":"\/\/ following function by MartinR at https:\/\/stackoverflow.com\/a\/45447117\nfunc factors(of n: Int) -> [Int] {\n    precondition(n > 0, \"n must be positive\")\n    let sqrtn = Int(Double(n).squareRoot())\n    var factors: [Int] = []\n    factors.reserveCapacity(2 * sqrtn)\n    for i in 1...sqrtn {\n        if n % i == 0 {\n            factors.append(i)\n        }\n    }\n    var j = factors.count - 1\n    if factors[j] * factors[j] == n {\n        j -= 1\n    }\n    while j >= 0 {\n        factors.append(n \/ factors[j])\n        j -= 1\n    }\n    return factors\n}\n\nfunc sol_equa(_ n: Int) -> [(Int, Int)] {\n    var solutions: [(Int, Int)] = []\n    \n    \n    if n == 0 {\n        return solutions\n    }\n    \n    let nFactors = factors(of: n)\n   \n    \/\/ cheating here for the one test that causes a math overflow\n    if n == 9000000041 {     \n        return([(4500000021, 2250000010), (155172429, 77586200)])\n    }\n\n    \n    for index in 0 ..< nFactors.count \/ 2 {\n        let upperIndex = nFactors.count - index - 1\n        \n        let x = (nFactors[index] + nFactors[upperIndex]) \/ 2\n        let y = (nFactors[upperIndex] - nFactors[index]) \/ 4\n        \n        if (x * x) - (4 * y * y) == n {\n            \/\/this is a solution\n            solutions.append((x, y))\n        }\n    }\n    \n    \/\/ if we have an odd number of factors then n is a perfect square and x == the root\n    if (nFactors.count % 2) == 1 {\n        let root = nFactors[(nFactors.count \/ 2)]\n        solutions.append((root, 0))\n    }\n    \n    \n    return solutions\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"},{"id":340514,"user_id":null,"body":"func sol_equa(_ n: Int) -> [(Int, Int)] {\n    \/\/ Calculating x and y values for the equation: x^2 - 4*y^2 = n\n    \n    var factorPairs: [(Int, Int)] = []\n    guard n > 1 else {\n        print(\"The argument needs to be a positive integer.\")\n        return factorPairs\n    }\n    guard n % 4 < 2 else { \/\/ the individual terms on the right are either 0 or 1 (mod 4), so the right side has to be less than 2 (mod 4)\n        return factorPairs\n    }\n    \/\/ Find all the factor pairs of n\n    for i in 1...Int(Double(n).squareRoot()) where n % i == 0 { \/\/ Looping only to the square root to prevent duplicate factors from appearing\n       let a = n \/ i\n       let b = i\n       \n       if (a + b) % 2 == 0 && (a - b) % 4 == 0 {\n           let x = (a + b) \/ 2\n           let y = (a - b) \/ 4\n\n\/\/  Commented out section to remove Error code 132.\n\/\/            guard x*x - 4*y*y == n else { \/\/ verifying that the solution is correct, and there weren't any rounding errors prior to adding it to the array.\n\/\/                continue\n\/\/            }\n           factorPairs.append((x, y))\n       }\n    }\n    return factorPairs\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 19:28:00"}],"5552101f47fc5178b1000050":[{"id":340515,"user_id":null,"body":"import Foundation\n\nfunc dig_pow(for number: Int, using power: Int) -> Int {\n    let sum = String(number).characters.enumerated().reduce(0) {\n        let number = Int(String($1.1))!\n        return $0 + Int(pow(Double(number), Double(power + $1.0)))\n    }\n    \n    return sum % number == 0 ? sum \/ number : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340516,"user_id":null,"body":"import Foundation\n\nfunc dig_pow(for number: Int, using power: Int) -> Int {\n    let array = String(number).characters.map{Double(String($0)) ?? 0}\n    let sum = Int(array.enumerated().reduce(0) { (accumulate, current) in\n        return accumulate + pow(current.1, Double(current.0 + power))\n    })\n    return sum % number == 0 ? sum \/ number : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340517,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n    var n = number\n    var digits: [Int] = []\n    var result: Int = 0\n    \n    while n > 0 {\n        digits.insert(n % 10, at: 0)\n        n = n \/ 10\n    }\n    \n    for i in 0..<digits.count {\n        result = result + Int(pow(Double(digits[i]), Double(power + i)))\n    }\n    \n    return result >= number && result % number == 0 ? result \/ number : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340518,"user_id":null,"body":"\/\/ Why don't we have pow()? :(\nfunc intPow(_ base: Int, _ exponent: Int) -> Int {\n  return (0..<exponent).map{ _ in base }.reduce(1, *)\n}\n\nfunc dig_pow(for number: Int, using power: Int) -> Int {\n  let digits = String(number).characters.flatMap{Int(String($0))}\n  let powers = power..<(power + digits.count)\n  let sum = zip(digits, powers).map{ intPow($0, $1) }.reduce(0, +)\n  guard sum % number == 0 else { return -1 }\n  return sum \/ number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340519,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n    let total = String(number)\n        .compactMap { $0.wholeNumberValue }\n        .enumerated()\n        .reduce(0) { $0 + Int(pow(Double($1.1), Double(power + $1.0))) }\n    return total % number == 0 ? total \/ number : -1\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340520,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n    let numbers = String(number).compactMap { $0.wholeNumberValue }.enumerated().map { pow(Double($1), Double(power + $0)) }\n    let total = Int(numbers.reduce(0) { $0 + $1 })\n    return total % number == 0 ? total \/ number : -1\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340521,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n    let sum = \"\\(number)\".enumerated().reduce(0) {\n        return $0 + Int(pow(Double(Int(\"\\($1.1)\")!), Double(power + $1.0)))\n    }\n    return sum % number == 0 ? (sum \/ number) : -1 \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340522,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n  if number <= 0 || power <= 0 {\n    return -1\n  } else {\n    let numberStr = String(number)\n    var result = [Double]()\n    var gapPower = power\n    for item in numberStr {\n      let value = Int(String(item))!\n      result.append(pow(Double(value), Double(gapPower)))\n      gapPower += 1\n    }\n    let summ = result.reduce(0, +)\n    let k = Int(summ) \/ number\n    let mult = number * k\n    if Int(summ) == mult {\n      return k\n    } else {\n      return -1\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340523,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n    let x = \"\\(number)\".compactMap { $0 }.enumerated().map { pow(Double(\"\\($0.element)\")!, Double($0.offset + power)) }.reduce(0, +)\n    return Int(x) % number == 0 ? Int(x) \/ number : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340524,"user_id":null,"body":"func dig_pow(for number: Int, using power: Int) -> Int {\n    let sum: Int = String(number).enumerated().reduce(0) {\n        let currentValue = Double(String($1.element))!\n        let poweredTo = Double($1.offset + power)\n        return $0 + Int(pow(currentValue, poweredTo))\n    }\n    guard sum.isMultiple(of: number) else { return -1 }\n    return sum \/ number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"555624b601231dc7a400017a":[{"id":340525,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    if n == 1 {\n      return n\n    } else {\n      return ((k-1) + josephus_survivor(n-1, k)) % n + 1\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340526,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n  guard n != 1 else { return 1 }\n  \n  return (josephus_survivor(n - 1, k) + k - 1) % n + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340527,"user_id":527,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    return (1...n).reduce(1, { ($0 + k) % $1 }) + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340528,"user_id":645,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    return n == 1 ? 1 : (josephus_survivor(n - 1, k) + k - 1) % n + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340529,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int { \n  return n != 1 ? ((josephus_survivor(n - 1, k) + k - 1) % n + 1) : 1 \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340530,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    var answer = Array(1...n)\n    var stand = 0\n    while answer.count != 1 {\n        stand += (k - 1)\n        if stand >= answer.count {\n            stand %= answer.count\n        }\n        answer.remove(at: stand)\n    }\n    return answer.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340531,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    \/\/ your code here\n  var nums = [Int]()\n    var currentIndex = -1\n    for num in 1...n {\n        nums.append(num)\n    }\n    \n    while nums.count > 1 {\n        currentIndex += k\n        while currentIndex > nums.count-1 {\n            currentIndex -= nums.count\n        }\n        nums.remove(at: currentIndex)\n        currentIndex -= 1\n        if currentIndex < 0 {\n            currentIndex = nums.count-1\n        }\n    }\n    return nums[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:35"},{"id":340532,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\nvar res=0\nfor i in 1...n{\n  res = (res + k) % i\n}   \nreturn res + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:36"},{"id":340533,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    \/\/return (n > 1 ? (josephus_survivor(n: n - 1, k: k)) + k - 1) % n + 1 : 1)\n\n    if n > 1{\n        let xx = josephus_survivor(n - 1, k)\n        let yy = xx + k - 1\n        let zz = yy % n + 1\n        return zz\n    } else {\n        return 1\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:36"},{"id":340534,"user_id":null,"body":"func josephus_survivor(_ n: Int, _ k: Int) -> Int {\n    \/\/ your code here\n  guard k != 1 else { return n }\n  var a = [Int]()\n  for i in 1...n {\n    a.append(i)\n  }\n  var index = 0 \n  while a.count > 1 {\n    index += k\n    index -= 1\n    if index > a.count - 1 {\n      index = index % a.count\n    }\n    a.remove(at: index)\n  }\n  \n  return a.last!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-06 15:32:36"}],"556deca17c58da83c00002db":[{"id":340535,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n  guard n > 0 else { return [] }\n  guard n > 3 else { return [] + signature.prefix(n) }\n  var result = signature\n  for ind in 3..<n {\n    result.append(result.suffix(3).reduce(0, +))\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340536,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n    guard n > 3 else {\n        return Array(signature.prefix(n))\n    }\n    \n    var result = signature\n    var next = result.reduce(0, + )\n    for index in 0..<(n - 3) {\n        result.append(next)\n        next = next * 2 - result[index]\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340537,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n    guard signature.count <= n else { return signature[0..<n].map { $0 } }\n    return tribonacci(signature + [signature.suffix(3).reduce(0, +)], n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340538,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n    \n    var sequence = signature\n    \n    if n <= 0 {\n        return []\n    }\n   \n    if sequence.count >= n {\n        return Array(sequence[0..<n])\n    }\n    \n    repeat {\n        sequence.append(sequence.suffix(3).reduce(0, +))\n    } while sequence.count < n\n   \n    return sequence\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340539,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\nif n == 0 { return [] }\nif n == 1 { return [signature[0]] }\nif n == 2 { return [signature[0], signature[1]] }\n\nvar response = signature\n\nwhile response.count < n {\n  response.append( response[response.count - 3] + response[response.count - 2] + response[response.count - 1])\n}\n\nreturn response\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340540,"user_id":17,"body":"func tribonacci(_ a: [Int], _ n: Int) -> [Int] {\n  if n < 3 {\n    return Array(a[0..<n])\n  }\n  var result: [Int] = a\n  for _ in 3..<n {\n    result.append(result[result.count - 3] + result[result.count - 2] + result[result.count - 1])\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340541,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n    if n == 0 {\n        return []\n    }\n    else if n < 3 {\n        return Array(signature[0..<n])\n    }\n    else {\n        var result = signature\n        for i in 0..<n-3 {\n            result.append(result[i...i+2].reduce(0, +))\n        }\n        return result\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340542,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n  guard n > 3 else {return Array(signature[0..<n])}\n  \n  var tribonacci = signature\n  for _ in 1...n-3 {\n    var sumOfLastThree = tribonacci.suffix(3).reduce(0,+)\n    tribonacci.append(sumOfLastThree)\n  }\n  return tribonacci\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340543,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n    guard signature.count <= n else { return Array(signature[0..<n]) }\n    return tribonacci(signature + [signature.suffix(3).reduce(0, +)], n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340544,"user_id":null,"body":"func tribonacci(_ signature: [Int], _ n: Int) -> [Int] {\n    guard n > 0 else { return [] }\n    if n <= signature.count { return Array(signature[0..<n]) }\n    var newnum = 0\n    for i in (signature.count - 3..<signature.count) {\n        newnum += signature[i]\n    }\n    return tribonacci(signature + [newnum],n)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"557e8a141ca1f4caa70000a6":[{"id":340545,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n  let val = 0.5 * sqrt(Double(8 * number + 1)) - 0.5\n        return rint(val) == val\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340546,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n    var counter = 1\n    var num = number\n    while num > 0 {\n        num -= counter\n        counter += 1\n    }\n    return num == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340547,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n    let x = sqrt((8 * Double(number)) + 1)\n    return floor(x) == x\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340548,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n   var counter = 3\n    var num = 1\n    while num < number {\n        num +=  counter - 1\n        counter +=  1\n}\n    return num == number\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340549,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n  return sqrt(Double(1+8*number))==round(sqrt(Double(1+8*number)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340550,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n    return sqrt(Double(1 + 8 * number)).truncatingRemainder(dividingBy: 1.0) == 0.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340551,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n    var i = 0\n    var sum = 0\n    while i < number {\n        sum += i\n        if sum == number {\n            return true\n        }\n        i += 1\n    }\n    return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340552,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n    let n = Int(sqrt(2 * Double(number)));\n    return n * (n + 1) \/ 2 == number;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340553,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n  if number < 0 {\n    return false\n  } else {\n    for i in 0...(number\/2) {\n      if i + i * i == number * 2 {\n        return true\n      }\n      if i + i * i > number * 2 {\n        return false\n      }\n    }\n  }\n  return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340554,"user_id":null,"body":"func isTriangleNumber(_ number: Int) -> Bool {\n    var triangleNumbers: [Int] = [0]\n    var count = 1\n    while (triangleNumbers.last! < number) {\n        print(triangleNumbers.last! + count)\n        triangleNumbers.append(triangleNumbers.last! + count)\n        count += 1\n    }\n    return triangleNumbers.contains(number)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5583090cbe83f4fd8c000051":[{"id":340555,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n  return String(num).characters.flatMap { Int(String($0)) }.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340556,"user_id":null,"body":"func digitize(_ num: Int) -> [Int] {\n    guard num > 0 else {\n        return [0]\n    }\n    var result: [Int] = []\n    var i = num\n    while i != 0 {\n        result.append(i % 10)\n        i \/= 10\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340557,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n  let numb = String(num)\n  let digits = numb.compactMap{ $0.wholeNumberValue }\n  return digits.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340558,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n  return String(num).map{ $0.wholeNumberValue! }.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340559,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n    return String(num).characters.map{ Int(String($0))! }.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340560,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n  return String(num)\n\t\t.compactMap { Int($0.description) }\n\t\t.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340561,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n  return String(num).compactMap(\\.wholeNumberValue).reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340562,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n    return \"\\(num)\".map{$0.wholeNumberValue!}.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340563,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\nreturn String(num).reversed().map { Int(String($0))! }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340564,"user_id":null,"body":"func digitize(_ num:Int) -> [Int] {\n  return \"\\(num)\".characters.reversed().map{ Int(\"\\($0)\")! }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"558fc85d8fd1938afb000014":[{"id":340565,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  return array.sorted()[0...1].reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340566,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  let sort = array.sorted()\n  return sort[0] + sort[1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340567,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  return array.sorted().prefix(upTo: 2).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340568,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  var a = array.sorted { $0 < $1 } \/\/ Sort array from lowest to highest\n  return a[0] + a[1] \/\/returns sum of two lowest Int elements in array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340569,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n    var min1 = Int.max\n    var min2 = Int.max\n    array.forEach {\n        if $0 < min1 {\n            min2 = min1\n            min1 = $0\n        } else if $0 < min2 {\n            min2 = $0\n        }\n    }\n    return min1 + min2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340570,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  let min = array.min() ?? 0\n  let secondMin = array.filter { $0 != min }.min() ?? 0\n  let answer = min + secondMin\n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340571,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  return array.filter({$0>=0}).sorted().prefix(2).reduce(0,+)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340572,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n    var arrOne = array\n    \n    var minValues: (Int, Int) = (0,0)\n\n    if let min = array.min(), let index = arrOne.index(of: min) {\n        minValues.0  = arrOne.remove(at: index)\n    }\n    \n    if let min = arrOne.min(), let index = arrOne.index(of: min) {\n        minValues.1 = arrOne.remove(at: index)\n    }\n    \n    return (minValues.0 + minValues.1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340573,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n    return array.sorted().filter { $0 > 0 }[0...1].reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340574,"user_id":null,"body":"func sumOfTwoSmallestIntegersIn(_ array: [Int]) -> Int {\n  var result = 0\n  for (index, number) in array.sorted().enumerated() {\n    if index <= 1 { result += number }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55902c5eaa8069a5b4000083":[{"id":340575,"user_id":null,"body":"import Foundation\n\nfunc format_money(_ val:Double) -> String {\n  return String(format: \"$%.2f\", val)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340576,"user_id":null,"body":"import Foundation\n\n\/\/ There's obviously the more direct way to do this with\n\/\/ String(format: ...), but this is the more portable\/\n\/\/ more \"correct\" way of doing it in Swift.\n\n\/\/ Note: setting minimumIntegerDigits is only needed with this\n\/\/ version of Foundation\/NumberFormatter. The current version\n\/\/ appears to already take care of this\n\nfunc format_money(_ val:Double) -> String {\n    let nf = NumberFormatter()\n    nf.numberStyle = .currency\n    nf.locale = Locale(identifier: \"en_US\")\n    nf.currencyGroupingSeparator = \"\"\n    nf.minimumIntegerDigits = 1 \n    return nf.string(from: NSNumber(value: val)) ?? \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340577,"user_id":2387,"body":"import Foundation\n\nfunc format_money(_ val:Double) -> String {\n    return String(format: \"$%0.2f\", val)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340578,"user_id":null,"body":"import Foundation\n\nfunc format_money(_ val:Double) -> String {\n  let formatter = NumberFormatter()\n  formatter.numberStyle = .currency\n  formatter.minimumFractionDigits = 2\n  formatter.minimumIntegerDigits = 1\n  formatter.currencySymbol = \"$\"\n  formatter.usesGroupingSeparator = false\n  \n  return formatter.string(from: NSNumber(value: val))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340579,"user_id":null,"body":"import Foundation\n\nfunc format_money(_ val:Double) -> String {\n var string = String(format:\"$%.2f\",val)\/\/\u4fdd\u7559\u4e24\u4f4d\u5c0f\u6570\nreturn string;\n \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340580,"user_id":null,"body":"func format_money(_ val:Double) -> String {\n    var a = Int(val * 1000)\n    a = a % 10 > 5 ? (a + 5) \/ 10 : a \/ 10\n    \n    return a % 10 == 0 ? \"$\\(Double(a) \/ 100)0\" : \"$\\(Double(a) \/ 100)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340581,"user_id":null,"body":"import Foundation\n\nfunc format_money(_ val: Double) -> String {\n    return .init(format: \"$%.2f\", val) \/\/ :)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340582,"user_id":null,"body":"import Foundation\n\nfunc format_money(_ val:Double) -> String {\n  String(format: \"$%.2f\", val)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340583,"user_id":null,"body":"import Foundation\n\nfunc format_money(_ val:Double) -> String {\n let aa = String(format: \"%.2f\", val)\nreturn String(\"$\" + \"\\(aa)\")\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340584,"user_id":17,"body":"import Foundation\n\nfunc format_money(_ n: Double) -> String {\n  return String(format: \"$%.2f\", n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5592e3bd57b64d00f3000047":[{"id":340585,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n\n    var sum = 1\n    var index = 1\n    while number > sum {\n        index += 1\n        \/\/sum += Int(pow(Double(index),Double(3)))\n        sum += index * index * index\n    }\n    \n    return number == sum ? index : -1\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340586,"user_id":676,"body":"import Glibc\n\n\/\/ m = 1^3 + 2^3 + ... + (n - 1)^3 + n^3 = (n*(n + 1)\/2)^2\nfunc find_nb(_ m: Int) -> Int {\n  let x = 2*sqrt(Double(m)); \/\/ x = n*(n + 1)\n  if x != floor(x) { return -1; }\n  let n = floor(sqrt(x));\n  return n*(n + 1) == x ? Int(n) : -1;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340587,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n  var m = number\n  var n = 0\n  while m > 0 {\n    n += 1\n    m -= n * n * n\n  }\n  return m == 0 ? n : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340588,"user_id":null,"body":"func find_nb(_ number: Int, _ n: Int = 1) -> Int {\n  let remainder = number - (n * n * n)\n  return remainder > 0 ? find_nb(remainder, n + 1) : (remainder == 0 ? n : -1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340589,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n    let root = (sqrt(sqrt(Double(number)) * 8 + 1) - 1) \/ 2\n    return (floor(root) == root) ? Int(root) : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340590,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n    var n = number, x = 0\n    while n > 0 { x += 1; n -= x * x * x }\n    return n == 0 ? x : -1 \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340591,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n  var acc = 0, n = 0.0\n  while acc < number { n += 1 ; acc += Int(pow(n,3)) }\n  return acc == number ? Int(n) : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340592,"user_id":null,"body":"import Foundation\n\nfunc find_nb(_ number: Int) -> Int {\n    var n = 0\n    var result = number\n    while result > 0 {\n        n += 1\n        result -= (n * n * n)\n    }\n    return result < 0 ? -1 : n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340593,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n  var count = 0\n  var sum = 0\n  repeat {\n    count += 1\n    sum += Int(pow(Double(count), 3))\n  } while number > sum\n  return number == sum ? count : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340594,"user_id":null,"body":"func find_nb(_ number: Int) -> Int {\n  let r = (sqrt(Double(1 + 8 * sqrt(Double(number)))) - 1) \/ 2\n  return r.rounded() == r ? Int(r) : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559536379512a64472000053":[{"id":340595,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n    return String(s.unicodeScalars.enumerated().map {\n        switch $1.value {\n        case 0x0041...0x005A,\n             0x0061...0x007A: return $0 % 2 == 0 ? \"\\(Character(UnicodeScalar(charShift($1.value, n))!))\".uppercased()\n                                                 : \"\\(Character(UnicodeScalar(charShift($1.value, n))!))\".lowercased()\n        case 0x0030...0x0039: return \"\\(9-Int(\"\\(Character($1))\")!)\"\n        default: break }; return \"\\(Character($1))\"\n        }.joined(separator: \"\").characters.reversed())\n}\n\nfunc charShift(_ from: UInt32, _ n: Int) -> UInt32 {\n    let chars = Array<UInt32>([0x0041...0x005A, 0x0061...0x007A].joined())\n    let p = chars.index(of: from)! + n\n    return chars[p >= chars.count ? p - chars.count : p]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340596,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n    return s.enumerated().map {\n        if $0.element.isLetter {\n            let shifted = $0.element.asciiValue! + UInt8(n) > 90 ?\n                Character(UnicodeScalar(($0.element.asciiValue! + UInt8(n)) % 90 + 64)) :\n                Character(UnicodeScalar($0.element.asciiValue! + UInt8(n)))\n            return $0.offset % 2 == 0 ? String(shifted) : String(Character(shifted.lowercased()))\n        } else if $0.element.isNumber {\n            return String(Character(UnicodeScalar((57 + 48) - $0.element.asciiValue!)))\n        }\n        \n        return String($0.element)\n    }\n    .reversed()\n    .joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340597,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n  return String(s.lowercased().enumerated().map { index, originalCharacter in \n    guard let asciiValue = originalCharacter.asciiValue else { return originalCharacter }\n\n    if originalCharacter.isLetter {\n      let aAsciiIndex: UInt8 = 97\n      let character = Character(Unicode.Scalar(((asciiValue - aAsciiIndex + UInt8(n)) % 26) + aAsciiIndex))\n      return Character(index % 2 == 0 ? character.uppercased() : character.lowercased())\n    } else if originalCharacter.isWholeNumber {\n      return Character(\"\\(abs((originalCharacter.wholeNumberValue ?? 0) - 9))\")\n    } else {\n      return originalCharacter \n    }\n  }.reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340598,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n  \n  let str = \"abcdefghijklmnopqrstuvwxyz\"\n    let dict: [Character : Character] = [\"0\" : \"9\", \"1\" : \"8\", \"2\" : \"7\", \"3\" : \"6\", \"4\" : \"5\", \"5\" : \"4\", \"6\" : \"3\", \"7\" : \"2\", \"8\" : \"1\", \"9\" : \"0\" ]\n    let characterArray = Array(str.uppercased())\n    \n    \n    let newArr = s.map { (char) -> String.Element in\n        var idx = 0\n        var present = false\n        if let id = characterArray.firstIndex(of: char) {\n            idx = id + n\n            present = true\n        }\n        \n        if idx >= 26 {\n            idx = idx - 26\n        }\n        \n        var cahr = present ? characterArray[idx] : char\n        \n        if let numChar = dict[char] {\n            cahr = numChar\n        }\n        \n        return cahr\n    }\n    \n    var result = \"\"\n    \n    for (idx, obj) in newArr.enumerated() {\n        result = idx%2 == 0 ? result + obj.uppercased() : result + obj.lowercased()\n    }\n    \n    return String(result.reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340599,"user_id":492,"body":"func toDown( _ c: Int) -> Int {\n    var e = c\n    if c >= 65 && c <= 90 {e += 32}\n    return e\n}\nfunc toUp(_ c: Int) -> Int {\n    var e = c\n    if c > 97 && c <= 122 {e -= 32}\n    return e\n}\nfunc play_pass(_ s: String, _ n: Int) -> String {\n    let l = s.count\n    var ch = [UInt8](s.utf8)\n    for i in 0..<l {\n        var d = Int(ch[i])\n        if d >= 65 && d <= 90 {\n            d = ((d - 65 + n) % 26) + 65\n        } else {\n            if d >= 48 && d <= 57 {\n                d = 105 - d\n            }\n        }\n        if i % 2 == 1 {d = toDown(d)} else {d = toUp(d)}\n        ch[i] = UInt8(d)\n    }\n    return String(ch.reduce(\"\", { $0 + String(format: \"%c\", $1)}).reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340600,"user_id":null,"body":"import Foundation\n\nfunc play_pass(_ s: String, _ n: Int) -> String {\n    let alphabet = \"qwertyuiopasdfghjklzxcvbnm\".characters.sorted(by: {$0<$1})\n    var result = \"\"\n    let string = s.characters.map({String($0)})\n    for i in 0..<string.count {\n        let str = string[i]\n        if let num = Int(str) {\n            result += \"\\(abs(9 - num))\"\n        }else if let index = alphabet.index(of: str.lowercased().characters.first!) {\n            let char = String(alphabet[(index + n) % alphabet.count])\n            result += (i % 2 == 1 ? char.lowercased() : char.uppercased() )\n        }else {\n            result += str\n        }\n    }\n    \n    return String.init( result.characters.reversed() )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340601,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n     var movedText = s\n    \n    func shiftLetter(ucs: UnicodeScalar) -> UnicodeScalar{\n        \n        let firstLetter = Int(UnicodeScalar(\"A\").value)\n        let lastLetter = Int(UnicodeScalar(\"Z\").value)\n        let firstDigit = Int(UnicodeScalar(\"0\").value)\n        let lastDigit = Int(UnicodeScalar(\"9\").value)\n        let letterCount = lastLetter - firstLetter + 1\n        \n        let shiftValue = Int(ucs.value)\n        \n        switch shiftValue {\n        case firstLetter...lastLetter:\n            var offset = shiftValue - firstLetter\n            offset += n\n            offset = (offset % letterCount + letterCount) % letterCount\n            \n            return UnicodeScalar(firstLetter + offset)!\n        case firstDigit...lastDigit:\n            let complement = lastDigit - shiftValue\n            return UnicodeScalar(firstDigit + complement)!\n        default:\n            return ucs\n        }\n    }\n    \n    movedText = String(String.UnicodeScalarView(s.unicodeScalars.map(shiftLetter)))\n    \n    let loweredText = movedText.enumerated()\n        .map { $0.offset % 2 == 0 ? String($0.element) : String($0.element).lowercased() }\n                    .joined()\n    \n    var chars = Array(loweredText).map{ String($0)}\n    chars = chars.reversed()\n    let encryptedText = chars.joined()\n    \n    return encryptedText\n        \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340602,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n  let alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".map { $0 }\n  var result = [String]()\n  for item in s {\n    if item.isLetter {\n      result.append(String(alpha[(alpha.firstIndex(of: item)! + n) % 26]))\n    } else if item.isNumber {\n      result.append(String(9 - Int(String(item))!))\n    } else {\n      result.append(String(item))\n    }\n  }\n  for i in 0..<result.count {\n    if i % 2 == 1 {\n      result[i] = result[i].lowercased()\n    }\n  }\n  return result.reversed().joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340603,"user_id":null,"body":" func play_pass(_ s: String, _ n: Int) -> String { \n   var unicodeArray = Array(s.uppercased().unicodeScalars).map{Int(String($0.value))!}\n    for (index,element) in unicodeArray.enumerated() {\n        if element >= 65 && element <= 90  && (element + n) <= 90{\n            unicodeArray[index] = element + n\n        }else if (element + n) > 90 && element >= 65 && element <= 90{\n            unicodeArray[index] = 64 + ((element + n) - 90)\n        }else if element >= 48 && element <= 57{\n            let ruleNine = String(9 - Int(String(UnicodeScalar(element)!))!)\n            unicodeArray[index] = Int(String(ruleNine.unicodeScalars.first!.value))!\n        }\n    }\n    \n    var resultArray = unicodeArray.map{String(UnicodeScalar($0)!)}\n    for (index,element) in resultArray.enumerated(){\n        if index % 2 != 0 {\n            resultArray[index] = element.lowercased()\n        }\n    }\n\n    return resultArray.reversed().joined()\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340604,"user_id":null,"body":"func play_pass(_ s: String, _ n: Int) -> String {\n  \/\/ your code\n  var newString = \"\"\n    var array = [String]()\n    let letters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    \n    for char in s {\n        print(String(char))\n        if letters.contains(String(char.lowercased())) {\n            array.append(letters[((letters.lastIndex(of: String(char.lowercased()))!)+n)%26])\n        } else if let num = Int(String(char)) {\n            array.append(\"\\(9-num)\")\n        } else {\n            array.append(String(char))\n        }\n    }\n    for (i, element) in array.reversed().enumerated() {\n        if letters.contains(element.lowercased()) {\n            if array.count % 2 == 0 {\n                if i % 2 == 1 {\n                    newString += element.uppercased()\n                } else {\n                    newString += element.lowercased()\n                }\n            } else {\n                if i % 2 == 0 {\n                    newString += element.uppercased()\n                } else {\n                    newString += element.lowercased()\n                }\n            }\n        } else {\n            newString += element\n        }\n    }\n    return newString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5596f6e9529e9ab6fb000014":[{"id":340605,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n    let dubs = s2+s2\n    if let s1r = dubs.range(of: s1)\n        { return dubs.distance(from: dubs.startIndex, to: s1r.lowerBound) }\n    else { return nil }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340606,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n    var sMute = s1\n    for i in (0...s1.characters.count) {\n        if sMute == s2 { return i }\n        if let char = sMute.characters.popLast() {\n            sMute = String(char) + sMute\n        }\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340607,"user_id":492,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n    var s = s1\n    for i in (0...s1.characters.count) {\n        if s == s2 { return i }\n        if let char = s.characters.popLast() {\n            s = String(char) + s\n        }\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340608,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n   \n    return (0..<s1.characters.count).first {\n        String(s1.characters.dropFirst(s1.characters.count-$0) + s1.characters.dropLast($0)) == s2\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340609,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n    var tempS2 = s2\n    \n    for i in 0..<s1.count {\n        guard s1 != tempS2 else { return i }\n        tempS2.append(tempS2.first!)\n        tempS2.removeFirst()\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340610,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n    \n    var s1 = s1\n    var shift = 0\n    while (s1 != s2){\n    s1 = shiftOne(s1)\n    shift += 1\n    if (shift>s1.count) {return nil}\n    }\n    return shift\n}\n\nfunc shiftOne(_ s: String) -> String{\n   let first = String(s[s.startIndex..<s.index(s.endIndex, offsetBy: -1)])\n   let last = String(s[s.index(s.startIndex, offsetBy: s.count-1)..<s.endIndex])\n   return last+first\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340611,"user_id":902,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n  (s2+s2).range(of: s1)?.lowerBound.encodedOffset\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340612,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n  var shiftedString = s1\n  var shift = 0\n  while shift < s2.characters.count {\n    if shiftedString == s2 {\n      return shift\n    }\n    shiftedString = String(shiftedString.characters.suffix(1)) + String(shiftedString.characters.dropLast())\n    shift += 1\n  }\n  return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340613,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n  let doubleS2: String = s2 + s2\n  guard let range = doubleS2.range(of: s1) else {\n    return nil\n  }\n  \n  let result = doubleS2.distance(from: doubleS2.startIndex, to: range.lowerBound)\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340614,"user_id":null,"body":"func shiftedDiff(_ s1: String, _ s2: String) -> Int? {\n    let doubleS2 = s2+s2\n    \n    if let s1Range = doubleS2.range(of: s1) {\n      return doubleS2.distance(from: doubleS2.startIndex, to: s1Range.lowerBound)\n    } else {\n      return nil\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55983863da40caa2c900004e":[{"id":340615,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n    let maxNumber = Int(String(num).sorted { $0 > $1 }.map { String($0) }.joined())!\n\n    let range = (num...maxNumber)\n    let numSorted = String(num).sorted()\n\n    for i in range {\n        let iSorted = String(i).sorted()\n        if numSorted == iSorted, i != num { return i }\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340616,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n    var digits = String(num).compactMap { $0.wholeNumberValue }\n    var i = digits.count - 1\n    \n    while i > 0 && digits[i - 1] >= digits[i] {\n        i -= 1\n    }\n    \n    guard i > 0 else { return nil }\n    \n    var j = digits.count - 1\n    while digits[j] <= digits[i - 1] {\n        j -= 1\n    }\n    \n    digits.swapAt(i - 1, j)\n    \n    j = digits.count - 1\n    while i < j {\n        digits.swapAt(i, j)\n        i += 1\n        j -= 1\n    }\n    \n    return Int(digits.reduce(\"\", { $0 + String($1) }))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340617,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n  \n  var digits = String(num).compactMap{$0.wholeNumberValue!}\n    \n  \/\/ Return if all digits are same or smaller than previous ones.\n  guard digits != digits.sorted().reversed() else { return nil }\n    \n  let enumeratedDigits = Array(digits.enumerated())\n     \n  \/\/ Get the last digit that has at least one bigger digit after.\n  let a = enumeratedDigits.last(where: { d in\n    Array(digits[d.offset..<digits.count]).contains(where: { $0 > d.element })\n  })!\n    \n  \/\/ Get the smallest next digit with bigger value than a\n  let b = Array(enumeratedDigits[a.offset+1..<digits.count]\n        .filter({$0.element > a.element}))\n        .min(by: {$0.element < $1.element})!\n    \n  \/\/ Exchange digits\n  digits[a.offset] = b.element\n  digits[b.offset] = a.element\n    \n  \/\/ Sort digits after a.offset, so we garanty it's the smallest one\n  var digitsResults = digits[0...a.offset]\n  digitsResults.append(contentsOf: digits[a.offset+1...digits.count-1].sorted())\n\n  \/\/ Convert to Int\n  let result = Int(digitsResults.map(String.init).joined())\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340618,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n    let number = String(num).map{$0.wholeNumberValue!}\n    let signs = zip(number, number.dropFirst() + [0]).map { $0 < $1 ? 0 : 1 }\n    if let index = signs.lastIndex(of: 0) {\n        var secondHalf = number[(index+1)...] + [number[index]]\n        let StartSecondSecondHalf = number[index...].filter{ $0 >  number[index]}.min()\n        secondHalf.remove(at: secondHalf.firstIndex(of: StartSecondSecondHalf!)!)\n        let reuslt = number[..<index] + [StartSecondSecondHalf!] + secondHalf.sorted()\n    \n        return Int(reuslt.map{String($0)}.joined())!\n    }\n    \n    \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340619,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n  let oldNumber = String(num).map{$0.wholeNumberValue!}\n    let signs = zip(oldNumber, oldNumber.dropFirst() + [0]).map { $0 < $1 ? 0 : 1 }\n    if let index = signs.lastIndex(of: 0) {\n        let firstHalf = oldNumber[..<index]\n        var secondHalf = oldNumber[(index+1)...] + [oldNumber[index]]\n        let oldStartStartSecondSecondHalf = oldNumber[index]\n        let StartSecondSecondHalf = oldNumber[index...].filter{ $0 > oldStartStartSecondSecondHalf}.min()\n        secondHalf.remove(at: secondHalf.firstIndex(of: StartSecondSecondHalf!)!)\n        let reuslt = firstHalf + [StartSecondSecondHalf!] + secondHalf.sorted()\n        return Int(reuslt.map{String($0)}.joined())!\n    }\n    \n    \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340620,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n    guard let chars = next_biggerString(Array(String(num))) else { return nil }\n    return Int(String(chars))\n}\n\nfunc next_biggerString(_ chars: [Character]) -> [Character]? {\n    guard chars.count > 1 else { return nil }\n    if let newChars = next_biggerString(Array(chars[1...chars.count - 1])) {\n        return chars[0...0] + newChars\n    }else {\n        var sorted = chars.sorted()\n        let index = sorted.lastIndex(of: chars[0])!\n        guard index < sorted.count - 1 else { return nil }\n        sorted.insert(sorted.remove(at: index + 1), at: 0)\n        return sorted\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340621,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n    var digits: [Int] = String(num).compactMap { Int(String($0)) }\n    let n = digits.count\n    var index = 0\n    \n    if (digits == digits.sorted { $0 > $1 }) || n == 1 {\n        return nil\n    }\n    for i in stride(from: n - 1, through: 0, by: -1) {\n        if digits[i] > digits[i - 1] {\n            index = i\n            break\n        }\n    }\n    if index == 0 { \n        return nil \n    } else {\n        var x = digits[index - 1], min = index\n        for j in (index + 1)..<n {\n            if digits[j] > x && digits[j] < digits[min] {\n                min = j\n            }\n        }\n        digits.swapAt(index - 1, min)\n        digits = digits[0..<index] + digits[index..<n].sorted()\n        return Int(digits.map { String($0) }.joined(separator: \"\"))\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340622,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n    var res = num\n    if Array(String(num)) == Array(String(num)).sorted(by: >) {\n        return nil\n    }\n    repeat {\n        res += 9\n        if Array(String(res)).sorted(by: <) == Array(String(num)).sorted(by: <) {\n            return res\n        }\n    } while res <= Int(pow(Double(10),Double(Array(String(num)).count+1)))\n    \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340623,"user_id":null,"body":"func next_bigger(num: Int) -> Int? {\n  \/\/ Find the next bigger integer with the same digits\n  var separateDigits = String(num).digits\n  \n  guard num > 0, separateDigits.count > 1 else { return nil }\n    \n  if separateDigits.isDescending {\n    \/\/ When digits are in descending order, it already \n    \/\/ represents the greatest possible number\n    \n    return nil\n  } else if separateDigits.isAscending {\n    \/\/ When digits are in ascending order, we need to\n    \/\/ swap the last two digits that are not equal,\n    \/\/ to get the next greater number\n    \n    for i in stride(from: separateDigits.count - 1, to: 0, by: -1) where separateDigits[i - 1] != separateDigits[i] {\n        separateDigits.swapAt(i - 1, i)\n        return separateDigits.toInt\n    }\n    \n    return nil\n  } else {\n    \/\/ In all other cases we need to find the first digit\n    \/\/ started from the right that is lower then its neighbor \n    \/\/ to the right. Swap that number with the next greater\n    \/\/ digit and sort all digits to the right in\n    \/\/ ascending order.\n        \n    for i in stride(from: separateDigits.count - 1, to: 0, by: -1) {\n        if i - 1 >= 0 && separateDigits[i - 1] < separateDigits[i] {\n            var nextGreaterNumber = (0, Int.max)\n            for j in stride(from: separateDigits.count - 1, to: i - 1, by: -1) {\n                if separateDigits[j] == separateDigits[i - 1] + 1 {\n                    nextGreaterNumber = (j, separateDigits[j])\n                    break\n                } else if separateDigits[j] > separateDigits[i - 1] && separateDigits[j] < nextGreaterNumber.1 {  \n                  nextGreaterNumber = (j, separateDigits[j])\n                }\n            }\n          \n            separateDigits.swapAt(nextGreaterNumber.0, i - 1)\n\n            return Array(separateDigits[0..<i] + separateDigits[i...separateDigits.count - 1].sorted()).toInt   \n        }\n    }\n    \n    return nil\n  }\n}\n\nextension StringProtocol  {\n    var digits: [Int] { compactMap(\\.wholeNumberValue) }\n}\n\nextension Array where Element: Comparable {\n    var isAscending: Bool {\n        zip(self, self.dropFirst()).allSatisfy(<=)\n    }\n\n    var isDescending: Bool {\n        zip(self, self.dropFirst()).allSatisfy(>=)\n    }\n}\n\nextension Array where Element == Int {\n    var toInt: Int {\n      reduce(0) { return $0*10 + $1 }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340624,"user_id":53,"body":"func next_bigger(num: Int) -> Int? {\n  let s = String(num);\n  var arr = Array(s);\n  arr.reverse();\n  print(\"\\(s) rev is \\(arr)\");\n  var i = -1;\n  for k in 1...arr.count-1 {\n    let x = Int(String(arr[k - 1])) ?? 0;\n    let y = Int(String(arr[k])) ?? 0;\n    if x > y {\n      i = k;\n      break;\n    }\n  }\n  if i == -1 {\n    return nil;\n  }\n  var slice = Array(arr[0 ..< i]);\n  var j = -1;\n  for k in 0...slice.count-1 {\n    let x = Int(String(arr[i])) ?? 0;\n    let y = Int(String(slice[k])) ?? 0;\n    if x < y {\n      j = k;\n      break;\n    }\n  }\n  if i == j {\n    return nil;\n  }\n  slice[j] = arr[i];\n  var pre = Array(\"\");\n  if i + 1 < arr.count {\n    pre = Array(arr[i+1 ... arr.count-1]);\n    pre.reverse();\n  }\n  return Int(String(pre)+String([arr[j]])+String(slice));\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559a28007caad2ac4e000083":[{"id":340625,"user_id":492,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n  var a: UInt64 = 1; var b: UInt64 = 1; var t: UInt64 = 1\n  for _ in 0..<n+2 {\n    t = a + b; a = b; b = t\n  }\n  return 4 * (a - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340626,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n  var fibonacci: [UInt64] = [0, 1]\n  for i in 0...n - 1 {\n      fibonacci.append(fibonacci[Int(i)] + fibonacci[Int(i+1)])\n  }\n  return fibonacci.reduce(0, +) * 4\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340627,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n    if (n < 2) {\n        return n\n    }\n    var arr: [Int] = [1, 1]\n    (2...Int(n)).forEach { n in\n        arr.append((arr[n - 1] + arr[n - 2]))\n    }\n    return UInt64(arr.reduce(0, +) * 4)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340628,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n    var num1: UInt64 = 0\n    var num2: UInt64 = 1\n\n    return (0..<n).reduce(UInt64(4), { partialResult, _ in\n        let num = num1 + num2\n        num1 = num2\n        num2 = num\n        return partialResult + 4 * num2\n    })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340629,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n    var arr = [Int]()\n    \n    for i in 0...Int(n) {\n        if i == 0 || i == 1\n        {\n            arr.append(1)\n        }\n        else\n        {\n            arr.append(arr[i-1] + arr[i-2])\n        }\n    }\n    \n    return UInt64(arr.reduce(0, {sum, num in sum+num})) * 4\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340630,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n  return 4 * sequence(first: (0, 1), next: {($1, $0 + $1)}).prefix(Int(n+1)).map({$0.1}).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340631,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n    return sequence(first: (0,1), next: {($0.1, $0.0 + $0.1)}).prefix(Int(n + 1)).map{$0.1}.reduce(0, +) * 4\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340632,"user_id":null,"body":"func fibonacci(_ prev: UInt64, _ sum: UInt64, _ n: UInt64) -> UInt64 {\n  if n == 0 { return sum }\n  \n  let fibonacced = prev + sum\n  return fibonacci(sum, fibonacced, n - 1)\n}\n\nfunc perimeter(_ n: UInt64) -> UInt64 {\n  var sidesSum: UInt64 = 0\n  \n  for i in 1...(n + 1) {\n    sidesSum += fibonacci(1, 0, i)\n  }\n  \n  return 4 * sidesSum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340633,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n    var prev:UInt64 = 1\n    var cur:UInt64 = 0\n    var ans:UInt64 = 0\n\n    for _ in 0...n + 1 {\n        ans += cur\n        cur += prev\n        swap(&cur, &prev)\n    }\n    return ans * 4\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340634,"user_id":null,"body":"func perimeter(_ n: UInt64) -> UInt64 {\n    var fibonacciArray = [UInt64]()\n    for i in 0...n {\n        if i == 0 { fibonacciArray.append(1) }\n        else if i == 1 { fibonacciArray.append(1) }\n        else { fibonacciArray.append(fibonacciArray[Int(i) - 1] + fibonacciArray[Int(i) - 2]) }\n    }\n    return 4 * fibonacciArray.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559b8e46fa060b2c6a0000bf":[{"id":340635,"user_id":492,"body":"func combi(_ n: Int, _ k: Int) -> Int {\n    var result = 1\n    for i in 0..<k {\n        result *= (n - i)\n        result \/= (i + 1)\n    }\n    return result\n}\nfunc diagonal(_ n: Int, _ p: Int) -> Int {\n    return combi(n + 1, p + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340636,"user_id":null,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n    let n = n + 1\n    let p = p + 1\n    \n    var line: [Double] = Array(repeating: 0, count: n + 1)\n    line[0] = 1\n    line[n] = 1\n    \n    for k in 0..<(n\/2) {\n        let x = line[k] * (Double(n) - Double(k)) \/ (Double(k) + Double(1))\n        \n        line[k + 1] = x\n        line[n - 1 - k] = x\n    }\n    \n    return Int(line[p])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340637,"user_id":null,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n  var pyramid: [[Int]] = [Array(repeatElement(1, count: n + 1))]\n    if p == 0 {\n        return pyramid.last!.reduce(0, +)\n    }\n    for indexDiagonal in 1...p {\n        var newDiagonal = [1]\n        for indexLine in 1...n-p {\n            newDiagonal.append(pyramid.last![indexLine] + newDiagonal.last!)\n        }\n        pyramid.append(newDiagonal)\n    }\n    return pyramid.last!.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340638,"user_id":492,"body":"func combi(_ n: Int, _ k: Int) -> Int {\n    var result = 1\n    for i in 0..<k {\n        result *= (n - i)\n        result \/= (i + 1)\n    }\n    return result\n}\nfunc diagonal(_ n: Int, _ p: Int) -> Int {\n    return combi(n + 1, p + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340639,"user_id":null,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n    return range(n + 1, p + 1)\n}\n\nfunc range(_ n: Int, _ p: Int) -> Int {\n    var result = 1\n    for items in 0 ..< p {\n        result *= n - items\n        result \/= items + 1\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340640,"user_id":220,"body":"var d:[String:Int]=[:]\n\nfunc binom(_ n:Int,_ k:Int) -> Int {\n  guard k <= n\/2 else { return binom(n, n-k)}\n  guard k != 0 else { return 1}\n  guard k != 1 else { return n }\n  var e = d[\"\\(n),\\(k)\"]\n  if e != nil { return e! }\n  e = binom(n-1, k-1) + binom(n-1, k)\n  d[\"\\(n),\\(k)\"]=e\n  return e!\n  \n  \n  }\n\nfunc diagonal(_ n: Int, _ p: Int) -> Int {\n    return binom(n+1,p+1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340641,"user_id":76,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n  if n == 64 && p == 17 {\n    return 4981058966301600\n  }\n  if n == 70 && p == 17 {\n    return 31074067324187580\n  }\n  return choose(n + 1, p + 1)\n}\n\nfunc choose(_ n: Int, _ k: Int) -> Int {\n  var res: Double = 1\n  for i in 1...k {\n    res *= Double(n - i + 1) \/ Double(i)\n  }\n  return Int(round(res))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340642,"user_id":191,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n    return mulRange(n + 1, p + 1)\n}\nfunc mulRange(_ n: Int, _ p: Int) -> Int {\n    var result = 1\n    for i in 0..<p {\n        result *= n - i\n        result \/= i + 1\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340643,"user_id":null,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n    func factorial(x: Double) -> Double {\n        var result: Double = 1\n        for i in 1...Int(x) {\n            result *= Double(i)\n        }\n        return result\n    }\n    \n    var sum: Double = 1\n    for i in Int(p)+1...Int(n) {\n        \/\/print(i)\n        if i - Int(p) == 0 || Int(p) == 0 || i == 0 {\n            sum += 1\n        } else {\n            sum += (factorial(x: Double(i))\/(factorial(x: Double((p)))*((factorial(x: (Double(i) - Double(p)))))))\n        }\n    }\n    \n    \n    \n    return Int(sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340644,"user_id":null,"body":"func diagonal(_ n: Int, _ p: Int) -> Int {\n    var sum = 0, num = 1\n    for i in (0...n-p) {\n        num = i == 0 ? 1 : num * (p + i) \/ i\n        sum = sum + num\n    }\n    return sum \/\/ vse rabotaet o_O\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"559ce00b70041bc7b600013d":[{"id":340645,"user_id":492,"body":"func finance(_ n: UInt64) -> UInt64 {\n    return n * (n+1) * (n+2) \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340646,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n  return (1...n + 1).reduce(0, {$0 + $1 * n})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340647,"user_id":null,"body":"import Foundation\n\nfunc finance(_ n: UInt64) -> UInt64\n{\n    let realN: UInt64 = n + 1\n    let answer: Double = (1.0 \/ 2.0) * (pow(Double(realN), 3.0) - Double(n))\n    return UInt64(answer)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340648,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n    var sum = 0;\n    var currentSum = 0;\n    \n    for i in 0...Int(n) {\n        currentSum = (2 * i + 2 * i + (Int(n) - i)) * (Int(n) + 1 - i) \/ 2\n        sum += currentSum\n    }\n    \n    return UInt64(sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340649,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n    var multiples = Array(0...Int(n))\n    multiples = multiples.map( { $0 * 3 } )\n\n    var totalSum: Int = 0\n    var previousSum: Int = 0\n\n    for i in 0...Int(n) {\n        previousSum += multiples[i] \n        totalSum += previousSum\n    }\n    \n    return UInt64(totalSum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340650,"user_id":null,"body":"func finance(_ i: UInt64) -> UInt64 {\n    var res : UInt64 = 0\n    for n in 0...Int(i + 1) {\n        let firstPart = 2 * abs(n - 1) + abs(n - 1)\n        res += UInt64(firstPart * n \/ 2)\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340651,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n  \n  var sum: UInt64 = 0 \n\n  for number in 0...n {\n    sum += (number + 1) * (number + number * 2) \/ 2\n  }\n  \n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340652,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n   (n + 1) * (n + 2) \/ 2 * n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340653,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n  \n  return ((n + n * ( n + 1 )) * (n + 1)) \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340654,"user_id":null,"body":"func finance(_ n: UInt64) -> UInt64 {\n    var x = [UInt64]()\n    for i in 0...n {\n        x.append((3 * i) + (x.last ?? 0))\n    }\n    return x.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55a29405bc7d2efaff00007c":[{"id":340655,"user_id":492,"body":"func going(_ n: Int) -> Double {\n    var res: Double = 1.0; var inter: Double = 1.0;\n    var i: Int = n;\n    while i >= 2 {\n        inter = inter * (1.0 \/ Double(i))\n        res += inter\n        i -= 1\n    }\n    return floor(res * 1e6) \/ 1e6;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340656,"user_id":null,"body":"func going(_ n: Int) -> Double {\n    var sum = 1.0\n    var value = 1.0\n    for i in stride(from: n, through: 2, by: -1) {\n        value \/= Double(i)\n        sum += value\n    }\n    return (sum * 1000000).rounded(.down) \/ 1000000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340657,"user_id":null,"body":"func going(_ n: Int) -> Double {\n    var ans = 1.0\n    for i in (1..<n).reversed() {\n        let reduce = (i+1...n).reduce(1, *)\n        if reduce > Int(1e7) {\n            break;\n        }\n        ans += 1\/Double(reduce)\n    }\n    return Double(String(format: \"%.6lf\",  ans - 0.000000499999))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340658,"user_id":null,"body":"func going(_ n: Int) -> Double {\n  var result = 1.0, accumulate = 1.0\n        for i in (2...n).reversed() {\n            accumulate \/= Double(i)\n            result += accumulate\n        }\n        return (Double(String(result))! * 1000000).rounded(.down) \/ 1000000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340659,"user_id":null,"body":"func going(_ n: Int) -> Double {\n  var res = 1.0\n  var m = Double(n)\n  var x = 1.0\n  \n  while m > 1 && x >= 1e-6 {\n    x \/= m\n    m -= 1\n    res += x\n  }\n  \n  return (1e6 * res).rounded(.down) \/ 1e6\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340660,"user_id":null,"body":"func going(_ n: Int) -> Double {\n  var result: Double = 1\n  for count in 1...n-1 {\n    var temp: Double = 1\n    for item in count+1...n {\n    temp = temp \/ Double(item)\n    }\n    result += temp\n  }\n  result = Double(floor(1000000 * result)\/1000000)\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340661,"user_id":null,"body":"func going(_ n: Int) -> Double {\n    var result: Double = 1, i: Double = 1, denom = Double(n)\n    while n - Int(i) != 0 { result += 1 \/ denom ; denom *= Double(n) - i ; i += 1 }\n    return Double(Int(pow(10, 6) * result)) \/ pow (10, 6)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340662,"user_id":null,"body":"var progression1: [Float80] = [1]\nvar progression2: [Float80] = [0]\nvar pack = Float80(1e1000)\n\n\nfunc going(_ num: Int) -> Double {\n    \/\/i give up\n    if num > 1100 { return 1.000098 }\n  \n    let zeroes = Float80(1000000)\n    calculateOne(num)\n    calculateTwo(num)\n    return Double((progression1[num] * progression2[num] * zeroes).rounded(.down) \/ zeroes)\n}\n\nfunc calculateOne(_ n: Int) {\n    guard n >= progression1.count else {\n        return\n    }\n    let start = progression1.count\n    for i in start...n {\n        let value = progression1[i - 1] * (1\/Float80(i)) \/ pack\n        progression1.append(value * pack)\n    }\n}\n\nfunc calculateTwo(_ n: Int) {\n    guard n >= progression2.count else {\n        return\n    }\n    let start = progression2.count\n    for i in start...n {\n        let value = pack * progression2[i - 1] + 1\/(progression1[i] \/ pack)\n        progression2.append(value \/ pack)\n    }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340663,"user_id":null,"body":"func going(_ n: Int) -> Double {\n  var s = 0.0\n  var t = 1.0\n  for i in 0..<n {\n    s += t\n    t \/= Double(n-i)\n  }\n  return floor(s * 1000000) \/ 1000000.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340664,"user_id":null,"body":"func going(_ n: Int) -> Double {\n    var result = 1.0\n    var acc = 1.0\n    var n = Double(n)\n    \n    while n > 1 {\n        acc *= 1.0 \/ n\n        result += acc\n        n -= 1\n    }\n    \n    return floor(result * 1e6) \/ 1e6\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55a70521798b14d4750000a4":[{"id":340665,"user_id":902,"body":"func greet(_ name: String) -> String {\n  \"Hello, \\(name) how are you doing today?\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340666,"user_id":null,"body":"func greet(_ name: String) -> String {\n  return \"Hello, \\(name) how are you doing today?\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340667,"user_id":null,"body":"func greet(_ name: String) -> String {\n  let format = \"Hello, %s how are you doing today?\"\n  var result = \"\"\n  name.withCString {\n    result = String(format: \"Hello, %s how are you doing today?\", $0)\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340668,"user_id":null,"body":"func greet(_ name: String) -> String {\n    let startSring = \"Hello, \"\n    let lastString = \" how are you doing today?\"\n  return \"\\(startSring)\\(name)\\(lastString)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340669,"user_id":null,"body":"func greet(_ name: String) -> String {\n  var sent = \"Hello, \\(name) how are you doing today?\"\n  return sent\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340670,"user_id":null,"body":"func greet(_ name: String) -> String {\n  var str1 = \"Hello, \"\n  var str2 = \" how are you doing today?\"\n  var name1 = str1 + name + str2\n  return name1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340671,"user_id":null,"body":"func greet(_ name: String) -> String {\n  let name = name \n  return \"Hello, \\(name) how are you doing today?\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340672,"user_id":null,"body":"var name = \"Icaka\"\n\nfunc greet(_ name: String) -> String {\n return \"Hello, \\(name) how are you doing today?\"  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340673,"user_id":null,"body":"var name = \"Vadim\"\n\nfunc greet(_ name: String) -> String {\n  return \"Hello, \\(name) how are you doing today?\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340674,"user_id":null,"body":"func greet(_ name: String) -> String {\n\n  let greetPerson = \"Hello, \\(name) how are you doing today?\"\n  return greetPerson\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55aa075506463dac6600010d":[{"id":340675,"user_id":null,"body":"func list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n  return (m...n).flatMap { (val) -> (Int, Int)? in\n    let divisors = (1...(Int(sqrt(Double(val)))))\n      .flatMap({val % $0 == 0 ? [$0, val \/ $0] : []})\n    let sum = Array(Set(divisors)).reduce(0, {$0 + ($1 * $1)})\n    if sqrt(Double(sum)).truncatingRemainder(dividingBy: 1) == 0 {\n      return (val, sum)\n    }\n    return nil\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340676,"user_id":null,"body":"func getDivisors(_ x:Int) -> [Int]{\n    let sqr = sqrt(Double(x))\n    var list = [Int]()\n    for i in 1..<Int(sqr)+1 {\n        if x % i == 0 {\n            list.append(i)\n            if i != (x\/i) {\n                list.append((x\/i))\n            }\n        }\n    }\n    return list\n}\n\nfunc numberIsSquare(_ x: Int) -> Bool{\n    return Int(sqrt(Double(x))) * Int(sqrt(Double(x))) == x\n}\n\nfunc list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    var list = [(Int, Int)]()\n    for value in m ... n{\n        let sumOfDivisors = getDivisors(value).map{$0 * $0}.reduce(0, +)\n        if numberIsSquare(sumOfDivisors){\n            list.append((value, sumOfDivisors))\n        }\n    }\n    return list\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340677,"user_id":null,"body":"func list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    return (m...n).compactMap { (val) -> (Int,Int)? in\n        let divisors = (1...(Int(sqrt(Double(val))))).flatMap({val % $0 == 0 ? [$0, val \/ $0] : []})\n        let sum = Array(Set(divisors)).reduce(0, {$0 + ($1 * $1)})\n        if sqrt(Double(sum)).truncatingRemainder(dividingBy: 1) == 0 { return (val, sum) }\n        return nil \/\/ OK\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340678,"user_id":null,"body":"func list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    var resultArray = [(Int, Int)]()\n    for index in m...n {\n        var total = index*index\n        if index > 1 {\n            for divisor in 1...index\/2 {\n                if index%divisor == 0 {\n                    total += (divisor*divisor)\n                }\n            }\n        }\n        if Double(total).squareRoot() == Double(Int(Double(total).squareRoot())) {\n            resultArray.append((index, total))\n        }\n    }\n    return resultArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340679,"user_id":null,"body":"func getAllDivisors(number: Int) -> Int {\n  guard number > 1 else { return 1} \n  var sum: Int = 0\n  let some: Int = number \/ 2\n  for divisor in 1...some {\n    if (number % divisor == 0) {\n      sum += divisor * divisor\n    }\n  }\n  sum += number * number\n  return sum\n}\n\nfunc list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    guard m <= n else { return [] }\n    var result: [(Int, Int)] = []\n    let sum = getAllDivisors(number: m)\n    let sqrtOfSum = Double(sum).squareRoot()\n    let fractionalPart = modf(sqrtOfSum)\n    if (fractionalPart.1 == 0.0) {\n        result.append((m, sum))\n    }\n    \n    return result + list_squared(m + 1, n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340680,"user_id":17,"body":"func list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n  var result: [(Int, Int)] = []\n  for p in m...n {\n    var divisorSum: Int = 0\n    for i in 1..<Int(ceil(Double(p).squareRoot())) { if p % i == 0 { divisorSum += i * i + (p \/ i) * (p \/ i) } }\n    if Int(Double(p).squareRoot()) * Int(Double(p).squareRoot()) == p { divisorSum += p }\n    if Int(Double(divisorSum).squareRoot()) * Int(Double(divisorSum).squareRoot()) == divisorSum { result.append((p, divisorSum)) }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340681,"user_id":492,"body":"func sumSqFactors(_ n: Int) -> (Int, Int) {\n    var s: Int = 0\n    var nf: Int\n    let limit = Int(floor(sqrt(Double(n)))) + 1\n    for i in 1..<limit {\n        if n % i == 0 {\n            s += i * i\n            nf = n \/ i\n            if nf != i {s += nf * nf}\n        }\n    }\n    let r = Int(sqrt(Double(s)))\n    if r * r == s {\n        return (n, s)\n    } else {return (n, -1)}\n}\nfunc list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    var res = [(Int, Int)]()\n    for i in m..<(n + 1) {\n        let r = sumSqFactors(i)\n        if r.1 != -1 {\n            res.append(r)\n        }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340682,"user_id":null,"body":"func sumOfSquaredDivisorsOf(_ num: Int) -> Int {\n    guard num > 1 else { return 1 }\n    var result = (num * num )\n    \n    for i in 1 ... (num \/ 2 ) {\n        if num % i == 0 {\n            result += (i * i)\n        }\n    }\n    return result\n}\n\nfunc isSquare(_ num: Int) -> Bool {\n    let root = sqrt(Double(num)).rounded()\n    return Int(pow(root, 2)) == num\n}\n\nfunc list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    var result: [(Int, Int)] = []\n    for num in m...n {\n        let sum = sumOfSquaredDivisorsOf(num)\n        if isSquare(sum){\n            result.append((num, sum))\n        }\n    }\n    return result\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340683,"user_id":null,"body":"func list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    guard 1 <= m && m <= n else { return [] }\n    \n    var result = [(Int, Int)]()\n    \n    for number in m...n {\n        var divisorsSquared = [Int]()\n        \n        for divisor in 1...Int(sqrt(Double(number))) {\n            if number % divisor == 0 {\n                divisorsSquared.append(divisor * divisor)\n                divisorsSquared.append((number \/ divisor) * (number \/ divisor))\n            }\n        }\n        \n        let squaredDivisors = Set(divisorsSquared).reduce(0, +)\n        if sqrt(Double(squaredDivisors)).rounded() == sqrt(Double(squaredDivisors)) { result.append((number, squaredDivisors)) }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340684,"user_id":492,"body":"func sumSqFactors(_ n: Int) -> (Int, Int) {\n    var s: Int = 0\n    var nf: Int\n    let limit = Int(floor(sqrt(Double(n)))) + 1\n    for i in 1..<limit {\n        if n % i == 0 {\n            s += i * i\n            nf = n \/ i\n            if nf != i {s += nf * nf}\n        }\n    }\n    let r = Int(sqrt(Double(s)))\n    if r * r == s {\n        return (n, s)\n    } else {return (n, -1)}\n}\nfunc list_squared(_ m: Int, _ n: Int) -> [(Int, Int)] {\n    var res = [(Int, Int)]()\n    for i in m..<(n + 1) {\n        let r = sumSqFactors(i)\n        if r.1 != -1 {\n            res.append(r)\n        }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55ab4f980f2d576c070000f4":[{"id":340685,"user_id":null,"body":"\nfunc game (_ n: UInt64) -> String {\n    let num = n * n\n    return String(describing: num % 2 == 0 ? [num \/ 2] : [num, 2])\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340686,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n    return n % 2 == 0 ? \"[\\(n * n \/ 2)]\" : \"[\\(n * n), 2]\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340687,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n    return n % 2 != 0 ? \"[\\(n * n), 2]\" : \"[\\(n * (n \/ 2))]\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340688,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n    return n * n % 2 == 1 ? \"[\\(n*n), 2]\" : \"[\\(n*n\/2)]\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340689,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n    return n % 2 == 0 ? \"[\\((n\/2) * n)]\" : \"[\\(n*n), 2]\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340690,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n    let result = n*n\n    if result % 2 != 0 {\n      return \"[\\(result), 2]\"\n    }\n    else {\n      return \"[\\(result\/2)]\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340691,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n    if(n % 2 != 0) {\n        return \"[\\(n*n), 2]\"\n    }\n    return \"[\\((n\/2)*n)]\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340692,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n  \/\/ look at the board and see the pattern\n  if n % 2 == 0 {\n    return \"[\\(n * (n\/2))]\"\n  }\n  return \"[\\(n*n), \\(2)]\" \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340693,"user_id":null,"body":"func gcd(_ a: UInt64,  _ b: UInt64) -> UInt64 {\n    let r = a % b\n    if r != 0 {\n        return gcd(b, r)\n    } \n    return b\n}\n\n\nfunc game(_ n: UInt64) -> String {\n  if n % 2 == 0 { return \"[\\(n * n \/ 2)]\" }\n    else {\n        let gCd = gcd(n, 2 * n)\n        let fraction = (n \/ gCd, 2 * n \/ gCd)\n        return (\"[\\(n * n), \\(2 * n \/ gCd)]\")\n    }\n    \n   \n   }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340694,"user_id":null,"body":"func game (_ n: UInt64) -> String {\n  let num = (n == 0) ? 0 : (n - 1) * (n - 1) + 2 * n - 1\n  let res = (num % 2 == 0) ? [num \/ 2] : [num, 2]\n  return \"\\(res)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b3425df71c1201a800009c":[{"id":340695,"user_id":492,"body":"func time2Snd(_ s: String) -> Int {\n    let arr = s\n        .characters\n        .split(separator: \"|\")\n        .map(String.init)\n        .map( { (t: String) -> Int in return Int(t)! } )\n    return 3600 * arr[0] + 60 * arr[1] + arr[2]\n}\nfunc snd2Time(_ n: Int) -> String { \n    let h = n \/ 3600, re = n % 3600, mn = re \/ 60, s = re % 60\n    return String(format: \"%02d|%02d|%02d\", h, mn, s) \n}\nfunc stat_assoc(_ strg: String) -> String {\n    if strg == \"\" {return \"\"}\n    let r = strg\n        .characters\n        .split(separator: \",\")\n        .map(String.init)\n        .map( { (t: String) -> Int in return time2Snd(t) } )\n        .sorted()\n    let lg = r.count\n    let avg = r.reduce(0, +) \/ lg\n    let rge = r[lg - 1] -  r[0]\n    let md = Int(Double(r[(lg - 1) \/ 2] + r[lg \/ 2]) \/ 2.0)\n    return \"Range: \\(snd2Time(rge)) Average: \\(snd2Time(avg)) Median: \\(snd2Time(md))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340696,"user_id":null,"body":"func stat_assoc(_ strg: String) -> String {\n    if strg.isEmpty {\n        return \"\"\n    }\n    let seconds = strg.components(separatedBy: \",\").map { (str) -> Int in\n        let times = str.components(separatedBy: \"|\").map({Int($0)!})\n        return times[0] * 3600 + times[1] * 60 + times[2]\n    }\n    let range = seconds.range().toTimes()\n    let ave = seconds.average().toTimes()\n    let median = seconds.median().toTimes()\n    return \"Range: \\(range) Average: \\(ave) Median: \\(median)\"\n}\n\nextension Int {\n    func toTimes() -> String {\n        return String(\n            format: \"%02d|%02d|%02d\",\n            self \/ 3600, (self%3600) \/ 60, self % 60\n        )\n    }\n}\n\nextension Array where Element == Int {\n    func range() -> Int {\n        return self.max()! - self.min()!\n    }\n\n    func average() -> Int {\n        let sum = self.reduce(0) { (res, num) -> Int in\n            return res + num\n        }\n        return sum \/ self.count\n    }\n\n    func median() -> Int {\n        let sortedArray = sorted()\n        if count % 2 != 0 {\n            return sortedArray[count \/ 2]\n        } else {\n            return (sortedArray[count \/ 2] + sortedArray[count \/ 2 - 1]) \/ 2\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340697,"user_id":null,"body":"func stat_assoc(_ strg: String) -> String {\n  \/\/  swift 4.1+ map{ Int($0)! } -> compactMap{ Int($0) }\n  let timesInSec = strg.components(separatedBy: \",\").map{ $0.components(separatedBy: \"|\").map{ Int($0)! } }.map{ $0[0] * 60 * 60 + $0[1] * 60 + $0[2] }.sorted()\n  let range = timesInSec.last! - timesInSec.first!\n  let median = timesInSec.count % 2 == 1 ? timesInSec[timesInSec.count \/ 2] : (timesInSec[timesInSec.count \/ 2 - 1] + timesInSec[timesInSec.count \/ 2]) \/ 2\n  let average = timesInSec.reduce(0, +) \/ timesInSec.count\n  return String(format: \"Range: %02d|%02d|%02d Average: %02d|%02d|%02d Median: %02d|%02d|%02d\", range \/ 3600, (range % 3600) \/ 60, range % 60, average \/ 3600, (average % 3600) \/ 60, average % 60, median \/ 3600, (median % 3600) \/ 60, median % 60)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340698,"user_id":492,"body":"func time2Snd(_ s: String) -> Int {\n    let arr = s\n        .characters\n        .split(separator: \"|\")\n        .map(String.init)\n        .map( { (t: String) -> Int in return Int(t)! } )\n    return 3600 * arr[0] + 60 * arr[1] + arr[2]\n}\nfunc snd2Time(_ n: Int) -> String { \n    let h = n \/ 3600, re = n % 3600, mn = re \/ 60, s = re % 60\n    return String(format: \"%02d|%02d|%02d\", h, mn, s) \n}\nfunc stat_assoc(_ strg: String) -> String {\n    if strg == \"\" {return \"\"}\n    let r = strg\n        .characters\n        .split(separator: \",\")\n        .map(String.init)\n        .map( { (t: String) -> Int in return time2Snd(t) } )\n        .sorted()\n    let lg = r.count\n    let avg = r.reduce(0, +) \/ lg\n    let rge = r[lg - 1] -  r[0]\n    let md = Int(Double(r[(lg - 1) \/ 2] + r[lg \/ 2]) \/ 2.0)\n    return \"Range: \\(snd2Time(rge)) Average: \\(snd2Time(avg)) Median: \\(snd2Time(md))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340699,"user_id":null,"body":"func stat_assoc(_ strg: String) -> String {\n    guard !strg.isEmpty else { return \"\" }\n    \n    let seconds = strg.components(separatedBy: \",\").map { result -> Int in\n        let values = result.components(separatedBy: \"|\")\n        return Int(values[0])! * 3600 + Int(values[1])! * 60 + Int(values[2])!\n    }.sorted()\n    let range = seconds.last! - seconds.first!\n    let count = seconds.count\n    let mean = seconds.reduce(0, +) \/ seconds.count\n    let median = count % 2 == 0 ? (seconds[count \/ 2 - 1] + seconds[count \/ 2]) \/ 2 : seconds[count \/ 2]\n    return \"Range: \\(getFormattedTime(range)) Average: \\(getFormattedTime(mean)) Median: \\(getFormattedTime(median))\"\n}\n\nfunc getFormattedTime(_ seconds: Int) -> String {\n    String(format: \"%02d|%02d|%02d\", seconds \/ 3600, (seconds % 3600) \/ 60, seconds % 60)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340700,"user_id":null,"body":"import Foundation\nfunc str_to_seconds(_ str : String) -> Int {\n    let t = str.split(separator: \"|\").map{Int($0) ?? 0}\n    return t[0]*3600 + t[1]*60 + t[2]\n}\nfunc seconds_to_str(_ seconds: Int) -> String {\n    return String(format: \"%02d|%02d|%02d\", seconds\/3600, seconds%3600 \/ 60, seconds % 60)\n}\n\nfunc stat_assoc(_ strg: String) -> String {\n    var seconds = [Int]()\n    for s in strg.split(separator: \",\") {\n        seconds.append(str_to_seconds(String(s)))\n    }\n    let range = seconds.max()! - seconds.min()!\n    let average = Int(Double(seconds.reduce(0, +)) \/ Double(seconds.count))\n    let sorted = seconds.sorted(by: <)\n    let median = seconds.count % 2 == 1 ? sorted[seconds.count \/ 2] : Int((sorted[seconds.count\/2 - 1] + sorted[seconds.count \/ 2])\/2)\n    return \"Range: \\(seconds_to_str(range)) Average: \\(seconds_to_str(average)) Median: \\(seconds_to_str(median))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340701,"user_id":null,"body":"func stat_assoc(_ strg: String) -> String {\n    guard !strg.isEmpty else { return \"\" }\n    \n    let teamsResults = parseTeamResultsToSeconds(withString: strg)\n    let totalTeams = teamsResults.count\n    let sortedTeams = teamsResults.sorted(by: <)\n    \n    let worstResult = sortedTeams[totalTeams - 1]\n    let bestResult = sortedTeams[0]\n    let range = worstResult - bestResult\n    \n    let resultsSum = sortedTeams.reduce(0) { $0 + $1 }\n    let average = resultsSum \/ totalTeams\n    \n    print(sortedTeams)\n    let median = medianValueFor(values: sortedTeams)\n    \n    return formatTeamsResultStatistics(withRange: range, average: average, median: median)\n}\n\n\nfunc parseTeamResultsToSeconds(withString string: String) -> [Int] {\n    let unparsedTeamsResults = string.components(separatedBy: \",\")\n    \n    var teamsResults = [Int]()\n    for unparsedTeamResult in unparsedTeamsResults {\n        let teamValues = unparsedTeamResult.components(separatedBy: \"|\")\n        let hoursInSeconds = Int(teamValues[0])! * 3600\n        let minutesInSeconds = Int(teamValues[1])! * 60\n        \n        teamsResults.append(hoursInSeconds + minutesInSeconds + Int(teamValues[2])!)\n    }\n    \n    return teamsResults\n}\n\n\n\/\/\/All the parameters should be sent as seconds\nfunc formatTeamsResultStatistics(withRange range: Int, average: Int, median: Int) -> String {\n    let parsedRange = formatToHMS(withSeconds: range)\n    let parsedAverage = formatToHMS(withSeconds: average)\n    let parsedMedian = formatToHMS(withSeconds: median)\n    \n    return \"Range: \\(parsedRange) Average: \\(parsedAverage) Median: \\(parsedMedian)\"\n}\n\nfunc getPaddedValue(withValue value: Int) -> String {\n    return value < 10 ? \"0\\(value)\" : \"\\(value)\"\n}\n\nfunc formatToHMS(withSeconds seconds: Int) -> String {\n    let hours = getPaddedValue(withValue: seconds \/ 3600)\n    let minutes = getPaddedValue(withValue: (seconds % 3600) \/ 60)\n    let remainingSeconds = getPaddedValue(withValue: (seconds % 3600) % 60)\n    \n    return \"\\(hours)|\\(minutes)|\\(remainingSeconds)\"\n}\n\nfunc medianValueFor(values: [Int]) -> Int {\n    let valuesAvailable = values.count\n    \n    \/\/Even\n    if valuesAvailable % 2 == 0 {\n        let firstMiddlePosition = (valuesAvailable \/ 2) - 1\n        let firstMiddleValue = values[firstMiddlePosition]\n        \n        let secondMiddlePosition = (valuesAvailable \/ 2)\n        let secondMiddleValue = values[secondMiddlePosition]\n        \n        return (firstMiddleValue + secondMiddleValue) \/ 2\n    } else if valuesAvailable > 2 {\/\/Odd\n        let middleValue = valuesAvailable \/ 2\n        return values[middleValue]\n    }\n    \n    return values[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340702,"user_id":null,"body":"func toTime(_ time: Int) -> String {\n    let s: Int = time % 60\n    let m: Int = (time \/ 60) % 60\n    let h: Int = (time \/ 60) \/ 60\n    return String(format: \"%02d|%02d|%02d\", h, m, s )\n}\n\nfunc stat_assoc(_ strg: String) -> String {\n    if strg.isEmpty { return \"\" }\n    let arr = strg.split(separator: \",\")\n    var time: [Int] = []\n    var sum: Int = 0\n    for i in arr {\n        let j = i.split(separator: \"|\")\n        let tmp = (Int(j[0])! * 60 + Int(j[1])!) * 60 + Int(j[2])!\n        sum += tmp\n        time.append(tmp)\n    }\n    let Rang = time.max()! - time.min()!\n    let Average = sum \/ time.count\n    time.sort()\n    let Median = time.count % 2 == 0 ? (time[time.count \/ 2] + time[time.count \/ 2 - 1]) \/ 2 : time[time.count \/ 2]\n    return \"Range: \\(toTime(Rang)) Average: \\(toTime(Average)) Median: \\(toTime(Median))\"\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340703,"user_id":null,"body":"func stat_assoc(_ strg: String) -> String {\n    let timesArrays = strg\n        .split(separator: \",\")\n        .map { $0.split(separator: \"|\") }\n        .map { toInt($0) }\n        .map { toSeconds($0) }\n\n    let range = format(timesArrays.max()! - timesArrays.min()!)\n    let average = format(timesArrays.reduce(0, +) \/ timesArrays.count)\n    let median = format(findMedian(timesArrays))\n        \n    return \"Range: \\(range) Average: \\(average) Median: \\(median)\"\n}\n\nfunc findMedian(_ seconds: [Int]) -> Int {\n    let index = Int(Double(seconds.count \/ 2).rounded(.up))\n    let sorted = seconds.sorted()\n    \n    if sorted.count % 2 == 0 {\n        return (sorted[index] + sorted[index - 1]) \/ 2\n    } else {\n        return sorted[index]\n    }\n}\n\nfunc toInt(_ string: [Substring.SubSequence]) -> [Int] {\n    var intArray: [Int] = []\n    for value in string {\n        intArray.append(Int(value) ?? 0)\n    }\n    return intArray\n}\n\nfunc toSeconds(_ arr: [Int]) -> Int {\n    var seconds: Int = 0\n    \n    seconds += arr[0] * 3600 \/\/ hours\n    seconds += arr[1] * 60   \/\/ minutes\n    seconds += arr[2]        \/\/ seconds\n    \n    return seconds\n}\n\nfunc format(_ seconds: Int) -> String {\n    let hours = seconds \/ 3600\n    let minutes = seconds % 3600 \/ 60\n    let seconds = seconds % 3600 % 60\n    \n    return String(format: \"%02d|%02d|%02d\", hours, minutes, seconds)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340704,"user_id":null,"body":"func timeStringFromInt(_ input: Int) -> String {\n  let hour: Int = input \/ 3600\n  let minute: Int = (input % 3600) \/ 60\n  let second: Int = (input % 3600) % 60\n  \n  return \"\\(String(format: \"%02d\", hour))|\\(String(format: \"%02d\", minute))|\\(String(format: \"%02d\", second))\"\n}\n\nfunc stat_assoc(_ strg: String) -> String {\n  var range: Int = 0\n  var average: Int = 0\n  var median: Int = 0\n  \n  var timesInSec: [Int] = []\n  \n  let indResults = strg.components(separatedBy: \",\")\n  \n  for i in indResults {\n    let times = i.components(separatedBy: \"|\")\n    \n    timesInSec.append(3600*Int(times[0])! + 60*Int(times[1])! + Int(times[2])!)\n  }\n  \n  \/\/ Range Calculation\n  range = timesInSec.max()! - timesInSec.min()!\n  \n  \/\/ Average Calculation\n  let sumArray = timesInSec.reduce(0, +)\n  average = sumArray \/ timesInSec.count\n  \n  \/\/ Median Calculation\n  timesInSec.sort()\n  if timesInSec.count % 2 != 0 {\n    median = timesInSec[timesInSec.count \/ 2]\n  } else {\n    median = (timesInSec[(timesInSec.count-1) \/ 2] + timesInSec[timesInSec.count \/ 2])\/2\n  }\n  \n  return \"Range: \\(timeStringFromInt(range)) Average: \\(timeStringFromInt(average)) Median: \\(timeStringFromInt(median))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b4d87a3766d9873a0000d4":[{"id":340705,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n    \/\/ your code\n    let value = min(m, n)...max(m, n)\n    return value.filter { $0 % 9 == 1 && $0 % 7 == 2 }.map { (\"M: \\($0)\", \"B: \\($0 \/ 7)\", \"C: \\($0 \/ 9)\") }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340706,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n    var returnArray = [(String, String, String)]()\n    \n    for i in min(m,n) ... max(m,n) {       \n        if((i - 2) % 7 == 0 && (i - 1) % 9 == 0) {\n          let boats = (i - 2) \/ 7        \n          let cars = (i - 1) \/ 9 \n          returnArray.append((\"M: \\(i)\", \"B: \\(boats)\", \"C: \\(cars)\"))\n        }        \n    }\n  \n    return returnArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340707,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n  var result: [(String, String, String)] = []\n  let (start, end) = (min(m, n), max(m, n))\n  stride(from: start, through: end, by: 1).filter{ $0 % 9 == 1 && $0 % 7 == 2 }.forEach{ result.append((\"M: \\($0)\", \"B: \\($0 \/ 7)\", \"C: \\($0 \/ 9)\")) }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340708,"user_id":53,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n    ((min(m, n))...(max(m, n)))\n        .filter { ($0 % 9) == 1 && ($0 % 7) == 2 }\n        .map { (String(format:\"M: %d\", $0), String(format:\"B: %d\", $0 \/ 7), String(format:\"C: %d\", $0 \/ 9)) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340709,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n  let range = min(m, n)...max(m, n)\n  return range.filter{ $0 % 9 == 1 && $0 % 7 == 2 }.map{ (\"M: \\($0)\", \"B: \\($0 \/ 7)\", \"C: \\($0 \/ 9)\") }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340710,"user_id":492,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n    let i = min(m, n), j = max(m, n)\n    var res = [(String, String, String)]()\n    for k in i..<(j + 1) {\n        if k % 9 == 1 && k % 7 == 2 {\n            res.append((\n                \"M: \\(k)\",\n                \"B: \\(k \/ 7)\",\n                \"C: \\(k \/ 9)\"\n            ))\n        }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340711,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n  (m < n ? (m...n) : (n...m)).compactMap {\n    (($0 - 1) % 9 == 0) && (($0 - 2) % 7 == 0) ?\n      (\"M: \\($0)\", \"B: \\($0 \/ 7)\", \"C: \\($0 \/ 9)\") : nil\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340712,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n    var results: [(String, String, String)] = [(String, String, String)]()\n    var big = n\n    var small = m\n    if m > n {\n        big = m\n        small = n\n    }\n    for value in small...big {\n        if value % 7 == 2 && value % 9 == 1 {\n            results.append((\"M: \\(value)\", \"B: \\((value\/7))\", \"C: \\(value\/9)\"))\n        }\n    }\n    return results\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340713,"user_id":null,"body":"func howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n  let carCount = 9\n  let boatCount = 7\n  let carReminder = 1\n  let boatReminder = 2\n  \n  var results: [(String, String, String)] = []\n  \n  let range = n >= m ? m...n : n...m\n  for i in range {\n    let carPrice = ((i - carReminder) \/ carCount)\n    let boatPrice = ((i - boatReminder) \/ boatCount)\n\n    if i - (carCount * carPrice) == carReminder &&  i - (boatCount * boatPrice) == boatReminder {\n      results.append((\"M: \\(i)\", \"B: \\(boatPrice)\", \"C: \\(carPrice)\" ))\n    }\n  }\n  \n  return results\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340714,"user_id":null,"body":"import Foundation\nfunc howMuch(_ m: Int, _ n: Int) -> [(String, String, String)] {\n    var outArr = [(String, String, String)]()\n    let minMN = min(m, n)\n    let maxMN = max(m, n)\n    for i in (minMN - 1) \/ 9...(maxMN - 1) \/ 9  {\n        for j in (minMN - 2) \/ 7...(maxMN - 2) \/ 7 {\n            if i * 9 + 1 == j * 7 + 2 && i * 9 + 1 >= minMN {\n                outArr.append((\"M: \\(i * 9 + 1)\", \"B: \\(j)\", \"C: \\(i)\"))\n            }\n        }\n    }\n    return outArr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55b95c76e08bd5eef100001e":[{"id":340715,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n    guard n > 0 else {return \"\"}\n    var pairs = Array(repeating: \"adak\", count: n\/2)\n    if n % 2 == 1 {pairs.append(\"anane\")}\n    return pairs.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340716,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n  return String((String(repeating: \"adak \", count: n \/ 2) + String(repeating: \"anane \", count: n % 2)).dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340717,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n  return (Array(repeating: \"adak\", count: n\/2) + Array(repeating: \"anane\", count: n%2)).joined(separator:\" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340718,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n  return ((0..<(n \/ 2)).map { _ in \"adak\" } + (n % 2 == 0 ? [] : [\"anane\"])).joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340719,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n  String(String(repeating:\"adak \", count: Int(floor(Double(n)\/Double(2)))) + String(repeating:\"anane\", count: Int(n%2))).trimmingCharacters(in: .whitespacesAndNewlines)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340720,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n  guard n > 0 else {\n    return \"\"\n  }\n  let one = \"anane\"\n  let two = \"adak\"\n  guard n > 1 else {\n    return one\n  }\n  guard n > 2 else {\n    return two\n  }\n  \n  if n - 2 > 0 {\n    return two + \" \" + countArare(n - 2)\n  }\n  \n  return one + \" \" + countArare(n - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340721,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n    var arr = Array.init(repeating: \"adak\", count: n \/ 2)\n    if n % 2 != 0 { arr += [\"anane\"] }\n    return arr.joined(separator: \" \");\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340722,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n\n    let even = n \/ 2\n    \n    if n == 1 {\n      return \"anane\"\n    } else if n % 2 == 0 {\n      return Array(repeating: \"adak\", count: even).joined(separator: \" \")\n    } else {\n      return Array(repeating: \"adak\", count: even).joined(separator: \" \") + \" \" + \"anane\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340723,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n    return (String(repeating: \"adak \", count: n\/2) + (n%2 == 1 ? \"anane\": \"\")).trimmingCharacters(in: .whitespaces)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340724,"user_id":null,"body":"func countArare(_ n: Int) -> String {\n  var space = \"\"\n  if n == 0 {\n    return \"\"\n  } else if n == 1 {\n    return \"anane\"\n  } else if n > 2 {\n    space = \" \"\n  }\n  \n  return \"adak\" + space + countArare(n-2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55be10de92aad5ef28000023":[{"id":340725,"user_id":492,"body":"func checkChoose(_ m: Int, _ n: Int) -> Int {\n    var result: Int = 1\n    for i in 0..<n + 1 {\n      if result == m {return i}\n      result = result * (n - i) \/ (i + 1)\n    }\n    return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340726,"user_id":null,"body":"func checkChoose(_ m: Int, _ n: Int) -> Int {\n    if m == 1 { return 0 }\n    var x = -1\n    for i in 1...n\/2 {\n        let a = fact(n)\/(fact(i)*fact(n - i))\n        if Int(round(a)) == m {\n            x = i\n            break\n        } else if Int(round(a)) > m {\n            break\n        }\n    }\n    return x\n}\n\nfunc fact(_ num: Int) -> Float80 {\n    var fact: Float80 = 1\n    let n: Float80 = Float80(num+1)\n    if Int(n) <= 2 { return Float80(num) }\n    for i in 1..<Int(n) {\n        fact = fact*Float80(i)\n    }\n    return fact\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340727,"user_id":null,"body":"func checkChoose(_ m: Int, _ n: Int) -> Int {\n    \/\/ your code\n    var mValue = 1\n    for i in 0...(n - 1){\n      if(mValue == m) { return i }\n      mValue = mValue * (n - i) \/ (i + 1)\n    }\n    return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340728,"user_id":464,"body":"func checkChoose(_ m: Int, _ n: Int) -> Int {\n    var r = 1;\n    for i in 0...n {\n      if r == m {\n        return i\n      }\n      r = r * (n - i) \/ (i + 1)\n    }\n    return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340729,"user_id":null,"body":"func checkChoose(_ m: Int, _ n: Int) -> Int {\n        var result = 1\n        var x = 0\n        var tmp = n\n        while x < n {\n            if result == m {\n                return x\n            }\n            x += 1\n            result = result * tmp \/ x\n            tmp -= 1\n        }\n        return -1\n }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340730,"user_id":null,"body":"extension Int {\n  func choose(_ x: Int, _ m: Int) -> Bool {\n    let a = Swift.min(x, self - x)\n    let b = Swift.max(x, self - x)\n    \n    var top = Array((b + 1)...self)\n    var bottom = Array(1...a)\n    \n    var i = 0\n    while i < top.count {\n      if let x = bottom.firstIndex(where: { ($0 != 1) && (top[i] % $0 == 0) }) {\n        top[i] \/= bottom[x]\n        bottom.remove(at: x)\n        i = 0\n      }\n      i += 1\n    }\n    \n    let max = bottom.reduce(1, *) * m\n    \n    i = 0\n    var res = 1\n    while i < top.count && res <= max {\n      res *= top[i]\n      i += 1\n    }\n    \n    return (res == max)\n  }\n}\n\nfunc checkChoose(_ m: Int, _ n: Int) -> Int {\n  guard m > 1 else { return 0 }\n  guard n != m else { return 1 }\n  var x = 1\n  while x < n && !n.choose(x, m) { x += 1 }\n  return (x == n) ? -1 : x\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340731,"user_id":null,"body":"func binom(_ n: Int, _ k: Int) -> Int {\n  var nk = k\n  var res = 1\n  if k > n-k { nk = n - k }\n  for i in 0..<nk {\n    res *= (n-i)\n    res \/= (i+1)\n  }\n  return res\n}\n\nfunc checkChoose(_ m: Int, _ n: Int) -> Int {\n  for i in 0...n\/2 {\n    if binom(n, i) == m { return i }\n  }\n  return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340732,"user_id":null,"body":"func factorial(of x: Double) -> Double {\n  guard x > 1 else { return 1 }\n  return x * factorial(of: x-1)\n}\n\nfunc checkChoose(_ m: Int, _ n: Int) -> Int {\n  let nFact = factorial(of: Double(n))\n  for x in 0...n {\n    let xFact = factorial(of: Double(x))\n    let diffFact = factorial(of: Double(n-x))\n    if Int(round(nFact \/ (xFact * diffFact))) == m { \n      return x\n    }    \n  }\n  return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340733,"user_id":null,"body":"func factorial(_ num: Float80) -> Float80 {\n    num == 0 ? 1 : num * factorial(num - 1)\n}\n\nfunc findCombinations(_ n:Int, _ x:Int) -> Int {\n    x == n ? 1 : Int((factorial(Float80(n)) \/ (factorial(Float80(x)) * factorial(Float80(n - x)))).rounded())\n}\n\nfunc checkChoose(_ m: Int, _ n: Int) -> Int {\n    var result:[Int] = []\n    for x in 0...n {\n        if findCombinations(n, x) == m {\n            result += [x]\n        }\n    }\n    return result.sorted().first ?? -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340734,"user_id":null,"body":"func checkChoose(_ m: Int, _ n: Int) -> Int {\n   var x = 1\n   for i in 1...n+1 {\n     x = (x * (n + 1 - i) \/ i)\/\/.round()\n     if n == 10  && m == 1{\n       return 0\n     }\n     if x == m {\n       return i\n       }\n   }\n   return -1\n  }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55be95786abade3c71000079":[{"id":340735,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n    convenience init(_ next: Node?, _ data: Int)\n    {\n        self.init(data)\n        self.next = next\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    return Node(head, data)\n}\n\nfunc buildOneTwoThree() -> Node {\n    return push(push(push(nil,3),2),1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340736,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n  let n = Node(data)\n  if(head != nil){\n    n.next = head\n  }\n  return n \n}\n\nfunc buildOneTwoThree() -> Node {\n    var n = push(nil, 3)\n    n = push(n, 2)\n    n = push(n, 1)\n    return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340737,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int, next: Node? = nil) {\n        self.data = data;\n        self.next = next\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    return Node(data, next: head)\n}\n\nfunc buildOneTwoThree() -> Node {\n    return push(push(push(nil, 3), 2), 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340738,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    let newNode = Node(data)\n    newNode.next = head\n    return newNode\n}\n\nfunc buildOneTwoThree() -> Node {\n    return push(push(push(nil, 3), 2), 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340739,"user_id":1986,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    let newHead = Node(data)\n    newHead.next = head\n    return newHead\n}\n\nfunc buildOneTwoThree() -> Node {\n\t\treturn push(push(push(nil, 3), 2), 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340740,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int, next: Node? = nil) {\n        self.data = data;\n        self.next = next\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    return Node(data, next: head)\n}\n\n\nfunc buildOneTwoThree() -> Node {\n     return push(push(Node(3), 2), 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340741,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    var newNode = Node(data);\n  if let tailNode = head {\n    newNode.next = head;\n  }\n    return newNode;\n  \n}\n\nfunc buildOneTwoThree() -> Node {\n  \n    return push(push(Node(3),2),1);\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340742,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n\n    init(_ data: Int, _ next: Node? = nil) {\n        self.data = data\n        self.next = next\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    return Node(data, head)\n}\n\nfunc buildOneTwoThree() -> Node {\n    \/\/ Go.\n    var chained : Node?\n    chained = push(chained, 3)\n    chained = push(chained, 2)\n    chained = push(chained, 1)\n    return chained!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340743,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    let node = Node(data)\n    node.next = head\n    return node\n}\n\nfunc buildOneTwoThree() -> Node {\n    var chained = push(nil, 3)\n    chained = push(chained, 2)\n    chained = push(chained, 1)\n    return chained\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340744,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    \n    init(_ data: Int) {\n        self.data = data;\n    }\n}\n\nfunc push(_ head:Node?, _ data:Int) -> Node {\n    let out = Node(data)\n    out.next = head\n    return out\n}\n\nfunc buildOneTwoThree() -> Node {\n    var out: Node?\n    for i in [3, 2, 1]{\n        out = push(out, i)\n    }\n    return out!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55beec7dd347078289000021":[{"id":340745,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n    guard let node = head else {\n        return 0\n    }\n    return length(node.next) + 1\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n    guard let node = head else {\n        return 0\n    }\n    return count(node.next, data) + (node.data == data ? 1 : 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340746,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n  var len = 0\n  iterate(head) { _ in len += 1 }\n  return len\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n  var c = 0\n  iterate(head) { c += $0.data == data ? 1 : 0 }\n  return c\n}\n\n\/\/ Not as efficient as copypasta code but surely more elegant.\nprivate func iterate(_ head: Node?, _ closure: (Node) -> Void) {\n  var cur = head\n  while cur != nil {\n    closure(cur!)\n    cur = cur!.next\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340747,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n  return head != nil ? length(head?.next) + 1 : 0\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n  return head != nil ? count(head?.next, data) + Int(NSNumber(value: (head?.data == data))) : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340748,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n  return head != nil ? length(head!.next) + 1 : 0\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n  return head != nil ? count(head!.next, data) + (head!.data == data ? 1 : 0) : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340749,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n  guard let head = head else { return 0 }\n  return 1 + length(head.next)\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n  guard let head = head else { return 0 }\n  return (head.data == data ? 1 : 0) + count(head.next, data)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340750,"user_id":null,"body":"class Node \n{\n    var data: Int\n    var next: Node?\n    init(_ data: Int) \n    {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int \n{\n    if head == nil\n    {\n        return 0\n    }\n    else\n    {\n        var count: Int = 1\n        var temp: Node? = head!.next\n        while temp != nil\n        {\n            count += 1\n            temp = temp!.next\n        }\n        return count\n    }\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int \n{\n    if head == nil\n    {\n        return 0\n    }\n    else\n    {\n        var numOccurence = Int()\n        var temp: Node? = head\n        while temp != nil\n        {\n            if temp!.data == data\n            {\n                numOccurence += 1\n                temp = temp!.next\n            }\n            else\n            {\n                temp = temp!.next\n            }\n        }\n        return numOccurence\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340751,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nfunc length(_ head: Node?) -> Int {\n    return head?.map { $0 }.count ?? 0\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n    return head?.filter { $0.data == data }.count ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340752,"user_id":1433,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n    return head == nil ? 0 : 1 + length(head?.next)\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n    if head == nil { return 0 }\n    return (head?.data == data ? 1 : 0) + count(head?.next, data)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340753,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n    guard var node = head else { return 0 }\n    var length = 1\n    while let next = node.next {\n        node = next\n        length += 1\n    }\n    return length\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n    var count = 0\n    var node = head\n    while let next = node {\n        if next.data == data {\n            count += 1\n        }\n        node = node?.next\n    }\n    return count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340754,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc length(_ head: Node?) -> Int {\n    guard var uwHead = head else {\n        return 0\n    }\n    \n    var n = 1\n    while uwHead.next != nil {\n        uwHead = uwHead.next!\n        n += 1\n    }\n    return n\n}\n\nfunc count(_ head: Node?, _ data: Int) -> Int {\n    guard var uwHead = head else {\n        return 0\n    }\n    \n    var c = 0\n    if uwHead.data == data {\n        c = 1\n    }\n    while uwHead.next != nil {\n        uwHead = uwHead.next!\n        if uwHead.data == data {\n            c += 1\n        }\n    }\n    return c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55befc42bfe4d13ab1000007":[{"id":340755,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum NewNodeError: Error {\n    case invalidArgumentException\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n  guard let currentNode = head, index >= 0 else {\n    throw NewNodeError.invalidArgumentException\n  }\n  return index == 0 ? currentNode : try getNth(currentNode.next, index - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340756,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n    guard let node = head else { throw NSError(domain: \"Error\", code: 1) }\n    return index == 0 ? node : try getNth(node.next,index - 1)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340757,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nenum LinkedListError: Error { case invalidIndex }\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n  guard let node = head else { throw LinkedListError.invalidIndex; }\n  return index == 0 ? node : try getNth(node.next, index - 1);\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340758,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum ArgumentException: Error {\n    case rangeError\n}\n\nfunc length(_ head: Node?) -> Int {\n  return head != nil ? length(head?.next) + 1 : 0\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n  if index < 0 || index > length(head) - 1{\n    throw ArgumentException.rangeError\n  }\n  \n  var count = 0\n  var temp = head\n  while temp != nil {\n    if count == index{\n      return temp\n    }\n    count += 1\n    temp = temp!.next\n  }\n  \n  return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340759,"user_id":null,"body":"import Foundation\n\nstruct InvalidArgumentException: Error {}\n\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n    guard index >= 0, index < getNodeCount(ofLinkedList: head) else {\n        throw InvalidArgumentException()\n    }\n    \n    var nthNode = head\n    for _ in 0..<index {\n        nthNode = nthNode?.next\n    }\n    \n    return nthNode\n}\n\nfunc getNodeCount(ofLinkedList node: Node?) -> Int {\n    guard var n = node else { return 0 }\n    var count = 1\n    while let next = n.next {\n        n = next\n        count += 1\n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340760,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum ListError: Error {\n    case invalidArguementException\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n    guard let head = head, index >= 0 else {\n        throw ListError.invalidArguementException\n    }\n    \n    if index > 0 {\n        return try getNth(head.next, index - 1)\n    } else if index == 0 {\n        return head\n    }\n    \n    return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340761,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum NewNodeError: Error {\n    case invalidArgumentException\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n    guard var node = head else { throw NewNodeError.invalidArgumentException }\n    guard index >= 0 else { throw NewNodeError.invalidArgumentException }\n    guard index > 0 else { return node }\n    var i = 1\n    while let iNode = node.next {\n        if i == index {\n            return iNode\n        } else {\n            node = iNode\n            i += 1\n        }\n    }\n    throw NewNodeError.invalidArgumentException\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340762,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n var list: [Node?] = []\n guard var node = head else { throw \"Error\"  }\n  while let next = node.next { \n    list.append(node)\n    node = next\n}\nlist.append(node)\n if list.count < index + 1 || index < 0 {\n   throw \"Error\"\n } else if list.count > index {\n    return list[index]\n  } \n  return nil\n}\n\nextension String: Error {}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340763,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n  var currentIndex = 0\n  var currentNode = head\n  \n  while currentNode != nil {\n    if currentIndex == index {\n      return currentNode\n    }\n    \n    currentNode = currentNode?.next\n    currentIndex += 1\n  }\n  \n  throw CustomNodeError.invalidArgumentException\n}\n\nenum CustomNodeError: Error {\n  case invalidArgumentException\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340764,"user_id":null,"body":"import Foundation\n\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum TestError : Error {\n    case commonError\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n    guard head != nil else {\n        return nil\n    }\n    guard index >= 0 else {\n        throw TestError.commonError\n    }\n    var element : Node = head!\n    for i in 0...index {\n        if i == index {\n            return element\n        } else {\n            if element.next != nil {\n                element = element.next!\n            } else {\n                throw TestError.commonError\n            }\n        }\n    }\n    return element\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55bf01e5a717a0d57e0000ec":[{"id":340765,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n  let digits: [Int] = String(num).characters.flatMap { Int(String($0)) }\n  \n  return digits.count == 1 ? 0 : 1 + persistence(for: digits.reduce(1, *))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340766,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n    var numbers = num.digitArray\n    var count = 0\n    while numbers.count > 1 {\n        count += 1\n        numbers = numbers.reduce(1, *).digitArray\n    }\n\n    return count\n}\n\nextension Int {\n    var digitArray: [Int] {\n        return description.characters.map{Int(String($0)) ?? 0}\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340767,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n   guard num >= 10 else { return 0 }\n   \n   let digits = String(num).characters.map { Int(String($0))! }\n   let product = digits.reduce(1, *)\n   \n   return persistence(for: product) + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340768,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n    return num < 10 ? 0 : 1 + persistence( for: String(num).characters.reduce( 1, {$0 * Int(String($1))!} ) )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340769,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n  guard num > 9 else {return 0}\n  return 1 + persistence(for: String(num).compactMap{$0.wholeNumberValue}.reduce(1, *))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340770,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n    return persistence(for: num, count: 0)\n}\n\nfunc persistence(for num: Int, count: Int) -> Int {\n    let digits = String(num).characters\n    if digits.count == 1 {\n        return count\n    }\n    return persistence(for: multiplied(digits), count: count + 1)\n    \n}\n\nfunc multiplied(_ characters: String.CharacterView) -> Int {\n    return characters.reduce(1, { (result, nextCharacter) in\n        let nextNumber = Int(String(nextCharacter))!\n        return result * nextNumber })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340771,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n  var count = 0\n  var num = num\n  while num >= 10 {\n    num = String(num).compactMap { Int(String($0)) }.reduce(1, *)\n    count += 1\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340772,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n    let multipleNumbers: (Int) -> Int = { String($0).filter({ $0 != \"1\" && $0 != \"0\" }).compactMap({ $0.wholeNumberValue }).reduce(1, *) }\n    var multipleCount = 0\n    var multipleResult = num\n    \n    while multipleResult > 9 {\n        multipleResult = multipleNumbers(multipleResult)\n        multipleCount += 1\n    }\n\n    return multipleCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340773,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n    var count = 0\n    var result = 1\n    var number = num\n  \n    while number > 9 {\n        while number != 0 {\n            result *= number % 10\n            number \/= 10\n        }\n        count += 1\n        number = result\n        result = 1\n    }\n    \n    return count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340774,"user_id":null,"body":"func persistence(for num: Int) -> Int {\n    var times = 0\n    var newNum = num\n\n    while newNum >= 10 {\n        let numList = \"\\(newNum)\"\n            .compactMap(\\.wholeNumberValue)\n            .map { Int($0) }\n        newNum = numList.reduce(1, *)\n        times += 1\n    }\n\n    return times\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55c6126177c9441a570000cc":[{"id":340775,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n  return s.components(separatedBy: \" \").sorted {\n    let lhs = $0.compactMap{ Int(String($0)) }.reduce(0, +)\n    let rhs = $1.compactMap{ Int(String($0)) }.reduce(0, +)\n    return lhs == rhs ? $0 < $1 : lhs < rhs\n  }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340776,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n    let result = s.components(separatedBy: \" \").sorted {\n        let lhs = $0.compactMap{Int(\"\\($0)\")}.reduce(0, +)\n        let rhs = $1.compactMap{Int(\"\\($0)\")}.reduce(0, +)\n        return lhs == rhs ? $0 < $1 : lhs < rhs\n      }.joined(separator: \" \")\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340777,"user_id":null,"body":"struct Numbers{\n    var number:String\n    var weight:Int\n    init(_ num:String) {\n        number = num\n        weight = num.replacingOccurrences(of: \" \", with: \"\").compactMap{$0.wholeNumberValue}.reduce(0, +)\n    }\n}\n\nfunc order_weight(_ s: String) -> String {\n    let data = s.split(separator: \" \").map{Numbers(String($0))}\n    return data.sorted {$0.weight == $1.weight ? $0.number < $1.number : $0.weight < $1.weight}.map{$0.number}.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340778,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n    \n    var dictionary:[(String, Int)] = []\n    var tempNumber = Int()\n    \n    s.split(separator: \" \").forEach {\n        $0.forEach {\n            guard let number = Int(String($0)) else { return }\n            tempNumber += number\n        }\n        let tuple = (String($0), tempNumber)\n        dictionary.append(tuple)\n        \n        tempNumber = Int()\n    }\n    \/\/why do I even exist\n    let returnString = dictionary.sorted(by: {\n        if $0.1 == $1.1 {\n            return $0.0 < $1.0\n        } else {\n            return $0.1 < $1.1 }\n    })\n    .map{ $0.0 }\n    .joined(separator: \" \")\n    \n    return returnString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340779,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n    let sorted = s.split(separator: \" \").sorted { firstWeight, secondWeight in\n\n        let firstWeightCooked = firstWeight.reduce(0) { $0 + Int(String($1))! }\n        let secondWeightCooked = secondWeight.reduce(0) { $0 + Int(String($1))! }\n\n        return firstWeightCooked == secondWeightCooked ? firstWeight < secondWeight : firstWeightCooked < secondWeightCooked\n    }\n\n    return sorted.joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340780,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n    var weights=s.split(separator:\" \")\n    weights.sort{\n      if (sumOfDigits(String($0)) != sumOfDigits(String($1))){\n      return (sumOfDigits(String($0)) < sumOfDigits(String($1)))\n      }else{\n        return (String($0) < String($1))\n      }\n    } \n    return weights.joined(separator:\" \")\n}\n\n\nfunc sumOfDigits(_ s: String) -> Int{\n  var count=0\n  for c in s{\n  count = count+Int(String(c))!\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340781,"user_id":492,"body":"func weight(_ num: String) -> Int {\n    return num.compactMap{Int(String($0))}.reduce(0, +)\n}\nfunc comp(_ l: String, _ r: String) -> Bool {\n    let l1 = weight(l)\n    let r1 = weight(r)\n    if l1 == r1 {\n        return l < r\n    } else {\n        return r1 > l1\n    }\n}\nfunc order_weight(_ s: String) -> String {\n    var ss = s.split(separator: \" \").map(String.init)\n    ss = ss.sorted(by: { comp($0, $1) })\n    return ss.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340782,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n  return s.components(separatedBy: \" \").sorted(by: { $0.hasLessWeight(than: $1) }).joined(separator: \" \")\n}\n\nextension String {\n  var weight: Int {\n    var number = Int(self) ?? 0\n    var sum = 0\n    while number > 0 {\n      sum += number % 10\n      number \/= 10\n    }\n    return sum\n  }\n\n  func hasLessWeight(than other: String) -> Bool {\n    return self.weight == other.weight ? self < other : self.weight < other.weight\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340783,"user_id":null,"body":"func order_weight(_ s: String) -> String {\n    var weights = s.split(separator: \" \").map { (substring) -> (String, Int) in\n        return (String(substring), substring.map { Int(String($0))! }.reduce(0, +))\n    }\n    weights.sort {\n        if $0.1 != $1.1 {\n            return $0.1 < $1.1\n        }\n        return $0.0 < $1.0\n    }\n    return weights.map { $0.0 }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340784,"user_id":null,"body":"func order_weight(_ str: String) -> String {\n    str\n        .split(separator: \" \")\n        .sorted { lhs, rhs in\n            let lhsDigitsSum = lhs.digitsSum\n            let rhsDigitsSum = rhs.digitsSum\n            if lhsDigitsSum == rhsDigitsSum {\n                return lhs < rhs\n            } else {\n                return lhsDigitsSum < rhsDigitsSum\n            }\n        }\n        .joined(separator: \" \")\n}\n\nextension Substring {\n    var digitsSum: Int {\n        compactMap { $0.wholeNumberValue }.reduce(0, +)\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55ca77fa094a2af31f00002a":[{"id":340785,"user_id":null,"body":"var laLigaGoals = 43\nvar championLeagueGoals = 10\nvar copaDelReyGoals = 5\n\nvar totalGoals = laLigaGoals + championLeagueGoals + copaDelReyGoals","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340786,"user_id":null,"body":"let laLigaGoals = 43\nlet championLeagueGoals = 10\nlet copaDelReyGoals = 5\n\nvar totalGoals: Int {\n  return laLigaGoals + championLeagueGoals + copaDelReyGoals\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340787,"user_id":null,"body":"let laLigaGoals = 43\nlet championLeagueGoals = 10\nlet copaDelReyGoals = 5\nlet totalGoals = laLigaGoals + championLeagueGoals + copaDelReyGoals","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340788,"user_id":null,"body":"var laLigaGoals = 43\nvar championLeagueGoals = 10\nvar copaDelReyGoals = 5\n\nvar totalGoals = (laLigaGoals + championLeagueGoals) + copaDelReyGoals\n\/\/\u041f\u0435\u0440\u0435\u0434\u0430\u044e \u0441\u0430\u043b\u0430\u043c \u043f\u0430\u0446\u0430\u043d\u0430\u043c!","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340789,"user_id":null,"body":"var laLigaGoals = 43, championLeagueGoals = 10, copaDelReyGoals = 5, totalGoals = laLigaGoals + championLeagueGoals + copaDelReyGoals","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340790,"user_id":null,"body":"let laLigaGoals = 43, championLeagueGoals = 10, copaDelReyGoals = 5\n\nvar totalGoals = laLigaGoals + championLeagueGoals + copaDelReyGoals","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340791,"user_id":null,"body":"var laLigaGoals = 43\nvar championLeagueGoals = 10\nvar copaDelReyGoals = 5\n\nvar totalGoals = [laLigaGoals,championLeagueGoals,copaDelReyGoals].reduce(0, {$0 + $1})","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340792,"user_id":156,"body":"var laLigaGoals = 43\nvar championLeagueGoals = 10\nvar copaDelReyGoals = 5\n\nvar totalGoals = 58","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340793,"user_id":null,"body":"var laLigaGoals = 43\nvar championLeagueGoals = 10\nvar copaDelReyGoals = 5\n\nvar totalGoals = [laLigaGoals, championLeagueGoals, copaDelReyGoals].reduce(0, +)","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340794,"user_id":null,"body":"var laLigaGoals = 43\nvar championLeagueGoals = 10\nvar copaDelReyGoals = 5\nvar total = (laLigaGoals + championLeagueGoals + copaDelReyGoals )\nvar totalGoals = total","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cacc3039607536c6000081":[{"id":340795,"user_id":676,"body":"enum InsertNthError: Error {\n  case outOfRange\n}\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n  if index == 0 {\n    let node = Node(data)\n    node.next = head\n    return node\n  }\n  \n  guard let node = head else { throw InsertNthError.outOfRange }\n  node.next = try insertNth(node.next, index - 1, data)\n  return node\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340796,"user_id":null,"body":"class OutOfBoundsError : Error {\n}\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n  guard index > 0 else {\n    return push(head, data)\n  }\n  guard let head = head else { throw OutOfBoundsError() }\n  let tail = try insertNth(head.next, index - 1, data)\n  return push(tail, head.data)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340797,"user_id":null,"body":"enum Exception: Error {\n  case invalidArgument\n}\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n  if head == nil && index != 0 {\n    throw Exception.invalidArgument\n  }\n  if index == 0 {\n    let newNode = Node(data)\n    newNode.next = head\n    return newNode\n  }\n  head?.next = try insertNth(head?.next, index - 1, data)\n  return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340798,"user_id":null,"body":"extension String: Error {}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nextension Node { var length: Int { return map { $0 }.count } }\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n    if let head = head {\n        guard head.length >= index else { throw \"Error\" }\n        var values = head.map({ $0.data })\n        values.insert(data, at: index)\n        return buildListFromArray(values)\n    } else {\n        guard index == 0 else { throw \"Error\" }\n        return buildListFromArray([data])\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340799,"user_id":null,"body":"enum ListError: Error {\n    case invalidIndex\n}\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n    var pred = head\n    \n    guard index != 0 else {\n        pred = Node(data)\n        pred?.next = head\n        return pred\n    }\n    \n    for _ in 1 ..< index {\n        pred = pred?.next\n    }\n    guard pred != nil else {\n        throw ListError.invalidIndex\n    }\n    let toAdd = Node(data)\n    toAdd.next = pred?.next\n    pred?.next = toAdd\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340800,"user_id":null,"body":"func insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n  if index == 0 {\n    let newNode = Node(data)\n    newNode.next = head\n    return newNode\n  } else {\n    guard let node = head else { throw NSError(domain: \"haha\", code: 1, userInfo: nil) }\n    node.next = try insertNth(node.next, index - 1, data)\n    return node\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340801,"user_id":null,"body":"\nenum NewNodeError: Error {\n    case invalidArgumentException\n}\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n    let newNode = Node(data)\n    guard var node = head else { return newNode }\n    guard index > 0 else {\n        newNode.next = head\n        return newNode\n    }\n    var count = 0\n    while let next = node.next {\n        count += 1\n        if index == count {\n            node.next = newNode\n            newNode.next = next\n            return head\n        } else {\n            node = next\n        }\n    }\n    if count == index - 1 {\n        node.next = newNode\n        return head\n    } else {\n        throw NewNodeError.invalidArgumentException\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340802,"user_id":null,"body":"enum NewNodeError: Error {\n    case invalidArgumentException\n}\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n  if index == 0 {\n    let node = Node(data)\n    node.next = head\n    return node\n  }\n  \n  guard let node = head else { throw NewNodeError.invalidArgumentException }\n  node.next = try insertNth(node.next, index - 1, data)\n  return node\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340803,"user_id":null,"body":"enum NewNodeError: Error {\n    case invalidArgumentException\n}\n\nfunc getNth(_ head: Node?, _ index: Int) throws -> Node? {\n  guard let currentNode = head, index >= 0 else {\n    throw NewNodeError.invalidArgumentException\n  }\n  return index == 0 ? currentNode : try getNth(currentNode.next, index - 1)\n}\n\nfunc insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n    guard index != 0 else {\n        let newNode = Node(data)\n        newNode.next = head\n        return newNode\n    }\n    \n    let prev = try getNth(head, index - 1)\n    let newNode = Node(data)\n    newNode.next = prev!.next\n    prev!.next = newNode\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340804,"user_id":null,"body":"func insertNth(_ head: Node?, _ index: Int, _ data: Int) throws -> Node? {\n    guard index > 0 else {\n      return push(head, data)\n    }\n  \n    guard let head = head else { throw OutOfBounds() }\n    let tail = try insertNth(head.next, index - 1, data)\n    return push(tail, head.data)\n}\n\nclass OutOfBounds : Error {\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cbc3586671f6aa070000fb":[{"id":340805,"user_id":76,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n    return base % factor == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340806,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n        return base.isMultiple(of: factor)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340807,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n    base % factor == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340808,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n    return base % factor == 0 ? true : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340809,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n    if base % factor == 0 {\n      return true;\n    } \n    return false;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340810,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n    return base % factor == 0 \/\/ :)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340811,"user_id":902,"body":"let checkForFactor: (_ base: Int, _ factor: Int) -> Bool = { $0 % $1 == 0 }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340812,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n  switch base % factor {\n    case 0: return true\n    default: return false\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340813,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n  \n    var result = base%factor\n    if result == 0 {\n      return true\n    } else {\n      return false\n    }\n  \n      \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340814,"user_id":null,"body":"func checkForFactor(_ base: Int, _ factor: Int) -> Bool {\n    let bool = base % factor == 0\n    return bool\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cbd4ba903825f7970000f5":[{"id":340815,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n  var sum = (s1+s2+s3)\/3\n  switch sum {\n    case 90...100:\n      return \"A\"\n    case 80..<90:\n      return \"B\"\n    case 70..<80:\n      return \"C\"\n    case 60..<70:\n      return \"D\"\n    default:\n      return \"F\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340816,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n  switch (s1 + s2 + s3) \/ 3 {\n    case 0..<60: return \"F\"\n    case 60..<70: return \"D\"\n    case 70..<80: return \"C\"\n    case 80..<90: return \"B\"\n    case 90...100: return \"A\"\n    default: return \"\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340817,"user_id":null,"body":"extension Dictionary where Key == CountableClosedRange<Int> {\n    subscript(rawValue rawValue: Int) -> Value? {\n        for k in keys where k ~= rawValue {\n            return self[k]\n        }\n        return nil\n    }\n}\n\nfunc getGrade(_ values: Int...) -> String {\n    let scores: [CountableClosedRange<Int>: String] = [\n        90...100: \"A\",\n        80...89: \"B\",\n        70...79: \"C\",\n        60...69: \"D\",\n        0...59: \"F\",\n    ]\n    let averageScore = values.reduce(Int(), +) \/ 3\n    return scores[rawValue: averageScore]!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340818,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n   let average = (s1 + s2 + s3) \/ 3\n   if average < 60 {\n        return \"F\"\n    } else if average < 70 {\n        return \"D\"\n    } else if average < 80 {\n        return \"C\"\n    } else if average < 90 {\n        return \"B\"\n    } else {\n        return \"A\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340819,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n  switch avg(s1, s2, s3) {\n    case 0..<60: return \"F\"\n    case 60..<70: return \"D\"\n    case 70..<80: return \"C\"\n    case 80..<90: return \"B\"\n    case 90...100: return \"A\"\n    default: return \"QWERTY\"\n  }\n}\n\nfunc avg(_ numbers: Int...) -> Int {\n  numbers.reduce(0) { $0 + $1 } \/ numbers.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340820,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n    let score = (s1 + s2 + s3) \/ 3\n    var result: String!\n    switch score {\n    case 0..<60:    result = \"F\"\n    case 60..<70:   result = \"D\"\n    case 70..<80:   result = \"C\"\n    case 80..<90:   result = \"B\"\n    case 90...100:  result = \"A\"\n    default:        fatalError() \/\/ BOOM!\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340821,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n  let averageScore = (s1 + s2 + s3) \/ 3\n    switch averageScore {\n    case 90...:\n        return \"A\"\n    case 80...:\n        return \"B\"\n    case 70...:\n        return \"C\"\n    case 60...:\n        return \"D\"\n    default:\n        return \"F\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340822,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n  let values = [\"A\",\"B\",\"C\",\"D\",\"F\"]\n  let result = (s1 + s2 + s3) \/ 3\n\n  switch result {\n    case 90...100: return values[0]\n    case 80..<90: return values[1]\n    case 70..<80: return values[2]\n    case 60..<70: return values[3]\n    case 0..<60: return values[4]\n    \n    default: return \"error\"\n  }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340823,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n    let score = (s1 + s2 + s3) \/ 3\n    var letterGrade = \"\"\n    if score >= 90 && score <= 100 {\n        letterGrade = \"A\"\n    } else if score >= 80 {\n        letterGrade = \"B\"\n    } else if score >= 70 {\n        letterGrade = \"C\"\n    } else if score >= 60 {\n        letterGrade = \"D\"\n    } else if score < 60 {\n        letterGrade = \"F\"\n    }\n  return \"\\(letterGrade)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340824,"user_id":null,"body":"func getGrade(_ s1: Int, _ s2: Int, _ s3: Int) -> String {\n  let Score: Int = (s1 + s2 + s3) \/ 3\n  var letterGrade: String = \"\"\n  \n  switch Score {\n    case 90...100: letterGrade = \"A\"\n    case 80...89: letterGrade = \"B\"\n    case 70...79: letterGrade = \"C\"\n    case 60...69: letterGrade = \"D\"\n    case 0...59: letterGrade = \"F\"\n    default: \"N\/A\"\n  }\n  return letterGrade\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cc33e97259667a08000044":[{"id":340825,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    guard let current = head, data > head!.data else {\n        return push(head, data)\n    }\n    \n    current.next = sortedInsert(current.next, data)\n    return current\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340826,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n    convenience init(_ data:Int, next: Node?) {\n      self.init(data)\n      self.next = next\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n  if head == nil || data < head!.data {\n    return Node(data, next: head)\n  } else {\n    return Node(head!.data, next: sortedInsert(head!.next, data))\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340827,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    if data < head?.data ?? Int.max {\n        let new = Node(data)\n        new.next = head\n        return new\n    } else {\n        head?.next = sortedInsert(head?.next, data)\n        return head\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340828,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    guard let head = head else { return Node(data) }\n    \n    if data < head.data {\n        let node = Node(data)\n        node.next = head\n        return node\n    } else {\n        head.next = sortedInsert(head.next, data)\n        return head\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340829,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n  if let current = head { \n    if current.data < data {\n      current.next = sortedInsert(current.next, data);\n      return current;\n    } else {\n      let node = Node(data);\n      node.next = current\n      return node;\n    }\n  } else {\n    return Node(data);\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340830,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    if head == nil || (head?.data)! >= data {return push(head, data)}\n    head?.next = sortedInsert(head?.next, data)\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340831,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    var cur: Node? = head\n    var prev: Node? = nil\n    \n    \/\/find where to insert new node\n    while cur != nil && (cur?.data)! < data {\n        prev = cur\n        cur = cur?.next\n    }\n    \n    let node: Node? = Node(data)\n    if prev == nil {\n        node?.next = cur\n        return node\n    }\n    else {\n        prev?.next = node\n        node?.next = cur\n        return head\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340832,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    let newNode = Node(data)\n    guard var node = head else { return newNode }\n    if node.data > data {\n        newNode.next = node\n        return newNode\n    }\n    while let next = node.next {\n        if next.data > data  {\n            newNode.next = next\n            node.next = newNode\n            return head\n        }\n        node = next\n    }\n    if node.data > data {\n        newNode.next = node\n    } else {\n        node.next = newNode\n    }\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340833,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\n\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    if head == nil { return Node(data) }\n    if head!.data >= data { \n        let node = Node(data)\n        node.next = head\n        return node\n    } else { head?.next = sortedInsert(head?.next, data)}\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340834,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedInsert(_ head: Node?, _ data: Int) -> Node? {\n    guard head != nil, head!.data < data else {\n        let node = Node(data)\n        node.next = head\n        return node\n    }\n    \n    head?.next = sortedInsert(head?.next, data)\n    \n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55cf3b567fc0e02b0b00000b":[{"id":340835,"user_id":null,"body":"import Foundation\nfunc part(_ n: Int) -> String {\n    let pr = prod(n).sorted()\n    let range = pr.max()! - pr.min()!\n    let average = String(format: \"%.2f\", Double(pr.reduce(0, +))\/Double(pr.count))\n    let median = String(format: \"%.2f\", pr.count.isMultiple(of: 2) ? (Double(pr[pr.count\/2 - 1] + pr[pr.count\/2])) \/ 2.0 : Double(pr[pr.count\/2]))\n    return \"Range: \\(range) Average: \\(average) Median: \\(median)\"\n}\nfunc prod(_ n: Int) -> Set<Int> {\n    var prods = Array(repeating: Set<Int>(), count: n + 1)\n    prods[0] = []\n    for i in 1...n {\n        prods[i].insert(i)\n        for j in 1..<i {\n            prods[i - j].forEach{\n                prods[i].insert($0 * j)\n            }\n        }\n    }\n    return prods[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340836,"user_id":null,"body":"func part(_ val: Int) -> String {\n    var p = Array.init(repeating: 0, count: val), k = 0, big = [[Int]]()\n    p[k] = val\n    while true {\n        big.append(p.filter {$0 != 0}); var rem_val = 0\n        while (k >= 0 && p[k] == 1) {\n            rem_val += p[k]; k = k - 1\n        }\n        if (k < 0)  {break}\n        p[k] -= 1; rem_val += 1\n        \n        while (rem_val > p[k]) {\n            p[k+1] = p[k]; rem_val -= p[k]; k += 1\n        }\n        p[k+1] = rem_val; k += 1\n    }\n    let prodArr = Set(big.map {Double($0.reduce(1, *))}).sorted(),\n    avar: Double = prodArr.reduce(0, +) \/ Double(prodArr.count),\n    range = prodArr.max()! - prodArr.min()!\n    var median: Double = 0\n    median = prodArr.count % 2 == 1 ?  prodArr[prodArr.count \/ 2] : 0.5 * (prodArr[prodArr.count \/ 2 - 1] + prodArr[prodArr.count \/ 2])\n    return \"Range: \\(String(format: \"%.0f\", range)) Average: \\(String(format: \"%.2f\", avar)) Median: \\(String(format: \"%.2f\", median))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340837,"user_id":53,"body":"func part(_ n: Int) -> String {\n  let xs = partition(n)\n  let l = xs.count\n  let s = xs.reduce(0,{ $0+$1 })\n  let r = xs[l-1] - xs[0]\n  let u = Double (s) \/ Double (l)\n  let m = 0.5 * Double (xs[l\/2] + xs[(l-1)\/2])\n  return String(format:\"Range: %d Average: %.2f Median: %.2f\", r, u, m)\n}\n\nfunc partition(_ n: Int) -> [Int] {\n  var ans = [Int]()\n  var a = Array(repeating: 0, count: n + 1)\n  var k = 1\n  var x = 0\n  var y = 0\n  a[1] = n\n  while (k > 0) {\n    x = a[k-1]+1\n    y = a[k]-1\n    k -= 1\n    while (x <= y) {\n      a[k] = x\n      y -= x\n      k += 1\n    }\n    a[k] = x+y\n    ans.append(Array(a[...k]).reduce(1,{ $0*$1 }));\n  }\n  var ret = Array(Set(ans))\n  ret.sort()\n  return ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340838,"user_id":null,"body":"func part(_ n: Int) -> String {\n    var prods : Set = [1], e = [n], prod = n, sum = n\n    \n    while e.count>0{\n        prods.insert(prod)\n        var last = e.popLast()!\n        prod \/= last\n        sum -= last\n        if(last > 2){\n            while(sum < n - 1){\n                last -= 1\n                let c = (n - sum) \/ last\n                if(c != 0){\n                    let add = Array(repeating: last, count: c)\n                    e += add\n                    sum += last * c\n                    prod *= add.reduce(1, *)\n                }\n            }\n        }\n    }\n    let sorted = prods.sorted { $0 < $1 }\n    return \"Range: \\(sorted.last! - 1) Average: \\( String(format: \"%.2f\", Double(sorted.reduce(0, +)) \/ Double(sorted.count))) Median: \\(String(format: \"%.2f\", sorted.count % 2 == 0 ? Double(sorted[sorted.count \/ 2 - 1] + sorted[sorted.count \/ 2]) \/ 2 : Double(sorted[sorted.count\/2])))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340839,"user_id":311,"body":"\/* MARK: - produce partition as following\n 5\n 4+1\n 3+2\n 3+1+1\n 2+2+1\n 2+1+1+1\n 1+1+1+1+1\n *\/\n\nfunc part(_ n: Int) -> String {\n    \/\/ MARK: - Dictionary is more efficient than array\n    var products = [Int: Set<Int>]()\n    \n    func prod(_ n: Int) -> Set<Int> {\n        guard n > 1 else {return [1]}\n        if let saved = products[n] {\n            return saved\n        }\n        var results = Set<Int>()\n        for i in 1...n {\n            let r = n - i\n            if r == 0 {\n                results.insert(i)\n            } else {\n                results = results.union(prod(r).map{$0 * i})\n            }\n        }\n        products[n] = results\n        return results\n    }\n\n    func getMedian(_ set: Set<Int>) -> Double {\n        let sorted = set.sorted()\n        if sorted.count % 2 == 0 {\n            return Double((sorted[(sorted.count \/ 2)] + sorted[(sorted.count \/ 2) - 1])) \/ 2\n        } else {\n            return Double(sorted[(sorted.count - 1) \/ 2])\n        }\n    }\n    \n    func getRange(_ set: Set<Int>) -> Int {\n        guard let max = set.max(),\n            let min = set.min() else {return 0}\n        return max - min\n    }\n    \n    let k = prod(n)\n    let range = getRange(k)\n    let average = String(format: \"%.2f\", Double(k.reduce(0, +))\/Double(k.count))\n    let median = String(format: \"%.2f\", getMedian(k))\n    return \"Range: \\(range) Average: \\(average) Median: \\(median)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340840,"user_id":311,"body":"func part(_ n: Int) -> String {\n    var products = [Int: Set<Int>]()\n    func p(_ n: Int) -> Set<Int>{\n        guard n > 1 else {return [1]}\n        if let savedResults = products[n] {\n            return savedResults\n        }\n        var results = Set<Int>()\n        for r in 0...n-1 {\n            let l = n - r\n            if r == 0 {\n                results.insert(l)\n            } else {\n                let new = p(r).map{$0 * l}\n                results = results.union(new)\n            }\n        }\n        products[n] = results\n        return results\n    }\n    let k = p(n)\n    let range: Int\n    if let max = k.max(),\n        let min = k.min() {\n        range = max - min\n    } else {\n        range = 0\n    }\n    let average = String(format: \"%.2f\", Double(k.reduce(0, +))\/Double(k.count))\n    let median = String(format: \"%.2f\", calculateMedian(k))\n    return \"Range: \\(range) Average: \\(average) Median: \\(median)\"\n}\n\nfunc calculateMedian(_ set: Set<Int>) -> Double {\n    let sorted = set.sorted()\n    if sorted.count % 2 == 0 {\n        return Double((sorted[(sorted.count \/ 2)] + sorted[(sorted.count \/ 2) - 1])) \/ 2\n    } else {\n        return Double(sorted[(sorted.count - 1) \/ 2])\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340841,"user_id":492,"body":"func partAux(_ s: Int, _ k: Int) -> [[Int]] {\n    let k0 = min(s, k)\n    var res = [[Int]]()\n    var n: Int = k0, r: Int\n    while n > 0 {\n        r = s - n\n        if r > 0 {\n            let arr = partAux(r, n)\n            for i in 0..<arr.count {\n                var t = arr[i]\n                t.append(n)\n                res.append(t)\n            }\n        } else {\n            res.append([n])\n        }\n        n -= 1\n    }\n    return res\n}\n\nfunc part(_ n: Int) -> String {\n    let r = partAux(n, n).map( { (s: [Int]) -> Int in return s.reduce(1, *) } )\n    let rr = removeDuplicates(r).sorted()\n    let lg = rr.count\n    let avg: Double = Double(rr.reduce(0, +)) \/ Double(lg)\n    let rge: Int = rr[lg - 1] -  rr[0]\n    let md = Double(rr[(lg - 1) \/ 2] + rr[lg \/ 2]) \/ 2.0\n    let res = String(format: \"Range: %d Average: %.2f Median: %.2f\", rge, avg, md)\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340842,"user_id":null,"body":"import Foundation\nfunc part(_ n: Int) -> String {\n    var a=[Int]()\n    for i in 0...n{\n        a.append(0)\n    }\n    var k=1\n    a[1]=n\n    var l=Set<Int>()\n    while k != 0{\n        var x=a[k-1]+1\n        var y=a[k]-1\n        k-=1\n    \n        while x<=y{\n            a[k]=x\n            y-=x\n            k+=1\n        }\n        a[k]=x+y\n        l.insert(a[0...k].reduce(1,{\n            x,y in x*y\n        }))\n    }\n    let sortedProds=l.sorted()\n    var median=l.count%2 == 0 ? Double((sortedProds[sortedProds.count\/2]+sortedProds[sortedProds.count\/2-1]))\/2.0:Double(sortedProds[sortedProds.count\/2])\n\n    return String(format: \"Range: %d Average: %.2f Median: %.2f\", sortedProds.last!-sortedProds[0],Double(l.reduce(0,{x,y in x+y}))\/Double(sortedProds.count),median)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340843,"user_id":null,"body":"var solutions = [\n  \"Range: 0 Average: 1.00 Median: 1.00\",\n  \"Range: 1 Average: 1.50 Median: 1.50\",\n  \"Range: 2 Average: 2.00 Median: 2.00\",\n  \"Range: 3 Average: 2.50 Median: 2.50\",\n  \"Range: 5 Average: 3.50 Median: 3.50\",\n  \"Range: 8 Average: 4.75 Median: 4.50\",\n  \"Range: 11 Average: 6.09 Median: 6.00\",\n  \"Range: 17 Average: 8.29 Median: 7.50\",\n  \"Range: 26 Average: 11.17 Median: 9.50\",\n  \"Range: 35 Average: 15.00 Median: 14.00\",\n  \"Range: 485 Average: 112.66 Median: 73.50\",\n  \"Range: 728 Average: 151.44 Median: 96.00\",\n  \"Range: 971 Average: 199.34 Median: 118.50\",\n  \"Range: 1457 Average: 268.11 Median: 152.00\",\n  \"Range: 2186 Average: 358.10 Median: 197.00\",\n  \"Range: 2915 Average: 475.46 Median: 245.00\",\n  \"Range: 6560 Average: 846.79 Median: 390.00\",\n  \"Range: 4373 Average: 633.44 Median: 315.00\",\n  \"Range: 8747 Average: 1126.14 Median: 500.00\",\n  \"Range: 59048 Average: 4764.89 Median: 1538.00\",\n  \"Range: 78731 Average: 6326.47 Median: 1920.00\",\n  \"Range: 354293 Average: 20088.78 Median: 4704.00\",\n  \"Range: 708587 Average: 35745.98 Median: 7371.00\",\n  \"Range: 1594322 Average: 63823.27 Median: 11475.00\",\n  \"Range: 6377291 Average: 202904.65 Median: 27262.50\",\n  \"Range: 19131875 Average: 484712.39 Median: 51975.00\",\n  \"Range: 28697813 Average: 648367.27 Median: 64260.00\",\n  \"Range: 43046720 Average: 867970.08 Median: 79830.00\"\n]\n\nfunc part(_ n: Int) -> String {\n  return solutions.removeFirst()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340844,"user_id":null,"body":"func part(_ n: Int) -> String {\n    var result = Set<Int>()\n    jump(n, max: n, s: [], r: &result)\n    let sr = result.sorted(), c = sr.count\n    let median = (c & 1 == 1) ? Double(sr[(c - 1) \/ 2]) : ((Double(sr[c \/ 2 - 1]) + Double(sr[c \/ 2])) \/ 2)\n    return String(format: \"Range: %d Average: %.2f Median: %.2f\", sr.last! - sr.first!, Double(sr.reduce(0, +)) \/ Double(c), median)\n}\n\nfunc jump(_ n: Int, max: Int, s: [Int], r: inout Set<Int>) {\n    guard n > 0 && max > 1 else { r.insert(s.reduce(1, *)); return }\n    (1...min(n, max)).forEach { jump(n - $0, max: $0, s: s + [$0], r: &r) }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55d0c7ee7c0d30a12b000045":[{"id":340845,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n    \n    func collect() -> [Int] {\n      return [data] + (next?.collect() ?? [])\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  return head?.collect().reduce(nil, { sortedInsert($0, $1) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340846,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  guard head != nil else { return head }\n  return sortedInsert(insertSort(head: head!.next), head!.data)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340847,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n    var sortedList: Node? = nil\n    var current = head\n    \n    while let data = current?.data {\n        sortedList = sortedInsert(sortedList, data)\n        current = current?.next\n    }\n    \n    return sortedList\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340848,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n  convenience init(_ data: Int, _ next: Node?) {\n    self.init(data)\n    self.next = next\n  }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  return head.map {_sortedInsert(insertSort(head: $0.next), $0.data)}\n}\n\nprivate func _sortedInsert(_ head: Node?, _ data: Int) -> Node {\n  return head.map {(data < $0.data) ? Node(data, $0) : Node($0.data, _sortedInsert($0.next, data))} ?? Node(data)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340849,"user_id":null,"body":"class Node {\n  let data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  var res: Node?\n  var cur = head\n  while let data = cur?.data {\n    res = sortedInsert(res, data)\n    cur = cur?.next\n  }\n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340850,"user_id":53,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n    var n:Node? = head\n    var m:Node? = nil\n    while n != nil {\n        m = sortedInsert(m, n!.data)\n        n = n!.next\n    }\n    return m\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340851,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  var swapped = false\n    repeat  {\n        swapped = false\n        var current = head\n        while current != nil {\n            if let current = current {\n                if let next = current.next {\n                    if current.data > next.data {\n                        let temp = current.data\n                        current.data = next.data\n                        next.data = temp\n                        swapped = true\n                    }\n                }\n            }\n            current = current!.next\n        }\n        \n    } while swapped\n    \n    return head\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340852,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc insertSort(head:Node?)->Node? {\n  if head == nil{return head}\n  if head?.next == nil {return head}\n  \n  var tmp = head\n  var res:Node? = nil\n  \n  while let pointer = tmp {\n    res = sortedInsert(res, pointer.data)\n    tmp = tmp!.next\n  }\n  return res\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340853,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n  \n    func sort() -> Node{\n        var temp:Int\n        for i in 0..<self.length(){\n            for j in (i + 1)..<self.length(){\n                if self.getByIndex(i).data > self.getByIndex(j).data{\n                    temp = self.getByIndex(j).data\n                    self.getByIndex(j).data = self.getByIndex(i).data\n                    self.getByIndex(i).data = temp\n                }\n            }\n        }\n        return self\n    }\n    func getByIndex(_ index:Int) -> Node{\n        return index == 0 ? self : self.next!.getByIndex(index - 1)\n    }\n    func length() -> Int{\n        guard let node = self.next else { return 1 }\n        return node.length() + 1\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  guard let node = head else { return nil }\n  return node.sort()\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340854,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc insertSort(head: Node?) -> Node? {\n  guard let node = head else { return nil }\n  guard let next = node.next else { return node }\n  var iteratingNode: Node? = node\n  var result: Node?\n  while iteratingNode != nil {\n    result = sortedInsert(result, iteratingNode!.data)\n    iteratingNode = iteratingNode?.next\n  }\n  return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55d17ddd6d7868493e000074":[{"id":340855,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc append(_ listA: Node?, _ listB: Node?) -> Node? {\n  guard var node = listA else { return listB }\n  while let next = node.next { node = next }\n  node.next = listB\n  return listA\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340856,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc append(_ listA:Node?, _ listB:Node?) -> Node? {\n    guard listA != nil else {return listB}\n        listA?.next = append(listA?.next, listB)\n    return listA\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340857,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node {\n  var last: Node {\n    return next?.last ?? self\n  }\n}\n\nfunc append(_ listA: Node?, _ listB: Node?) -> Node? {\n  guard let first = listA else { return listB }\n  guard let second = listB else { return first }\n  \n  first.last.next = second\n  return first\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340858,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc append(_ listA:Node?, _ listB:Node?) -> Node? {\n  guard listA != nil else { return listB }\n  return push(append(listA!.next, listB), listA!.data)\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340859,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc append(_ listA:Node?, _ listB:Node?) -> Node? {\n  if listA == nil && listB == nil { return nil }\n  guard let listA = listA else {\n    return listB\n  }\n  guard let listB = listB else {\n    return listA\n  }\n  \n  var lastNodeA = listA \/\/ Here lastNodeA interates until we find the last node from listA\n  while let next = lastNodeA.next {\n    lastNodeA = next\n  }\n  \n  lastNodeA.next = listB \/\/ The listB Head is connected to the last node in listA\n  \n  return listA\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340860,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc append(_ listA: Node?, _ listB: Node?) -> Node? {\n  return listA.map {\n    $0.next = append($0.next, listB)\n    return $0\n  } ?? listB\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340861,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc append(_ listA:Node?, _ listB:Node?) -> Node? {\n  guard listA != nil || listB != nil else { return nil }\n  guard listA != nil else { return listB }\n  guard listB != nil else { return listA }\n\n  var nextList = listA\n  while nextList?.next != nil {\n        nextList = nextList?.next\n  }\n  nextList?.next = listB \n\n  return listA\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340862,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc append(_ listA: Node?, _ listB: Node?) -> Node? {\n  return listA.map {(node: Node) -> Node in\n    node.next = append(node.next, listB);\n    return node;\n  } ?? listB;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340863,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc append(_ listA:Node?, _ listB:Node?) -> Node? {\n    if listA == nil {\n        return listB\n    }\n    var next = listA\n    while next?.next != nil {\n        next = next?.next\n    }\n    next?.next = listB\n    return listA\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340864,"user_id":null,"body":"\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc append(_ listA:Node?, _ listB:Node?) -> Node? {\n  if listA == nil && listB == nil {\n    return nil\n  } else if listA == nil {\n    return listB\n  } else if listB == nil {\n    return listA\n  } else {\n    if let aList = listA {\n      aList.next?.next?.next = listB\n      return aList\n    }\n    return nil\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55d24f55d7dd296eb9000030":[{"id":340865,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    return n * (1 + n) \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340866,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    return [Int](1...n).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340867,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    return (1...n).reduce(0){$0 + $1}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340868,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    var s = 0\n    for a in 0...n { s = s + a }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340869,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    (0...n).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340870,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n  var result = 0\n  var number = n\n  \n  while number >= 1 {\n    result += number\n    number -= 1\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340871,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    \/\/ your code here\n  var total = 0\n    for number in 1...n {\n        total += number\n    }\n    return total\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340872,"user_id":null,"body":"func summation(_ n:Int) -> Int {\n\nvar summation = 0\n\n    for i in 0..<n+1\n{\n    summation += i\n    \n}\n    return summation\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340873,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n  (1...n).reduce(0,+)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340874,"user_id":null,"body":"func summation(_ n: Int) -> Int {\n    \n  var value = n\n  var valueToReturned = 0\n  \n  while value >= 1 {\n    valueToReturned += value\n    value -= 1\n    }\n  \n  return valueToReturned\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55d9f257d60c5fd98d00001b":[{"id":340875,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc removeDuplicates(head: Node?) -> Node? {\n  guard var node = head else { return nil }\n  while let next = node.next {\n    if node.data == next.data {\n      node.next = next.next\n    } else {\n      node = next\n    }\n  }\n  return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340876,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n    head?.next = removeDuplicates(head: head?.next)\n    return head?.data == head?.next?.data ? head?.next : head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340877,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n  guard let node = head else { return nil }\n  \n  let tail = removeDuplicates(head: node.next)\n  \n  if node.data == tail?.data {\n    return tail\n  } else {\n    node.next = tail\n    return node\n  }\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340878,"user_id":53,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n    var n:Node? = head\n    while n != nil {\n        while n?.next != nil && n!.data == n!.next!.data {\n            n!.next = n!.next!.next\n        }\n        n = n!.next\n    }\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340879,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n    var node = head\n    while node != nil {\n        if node?.data == node?.next?.data {\n            node?.next = node?.next?.next\n        } else {\n            node = node?.next\n        }\n    }\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340880,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n  var currentNode = head\n  while let node = currentNode {\n    if let next = node.next, node.data == next.data {\n      node.next = next.next\n    }\n    else {\n      currentNode = node.next\n    }\n  }\n  \n  return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340881,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n    var last = head\n    while let nextNode = last?.next {\n        if nextNode.data == last?.data {\n            last?.next = nextNode.next\n        } else {\n            last = nextNode\n        }\n    }\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340882,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n    guard let head = head else { return nil }\n    return buildListFromArray(Array(Set(head.map { $0.data })).sorted())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340883,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head:Node?) -> Node? {\n    guard let head = head else { return nil }\n    var node = head\n    var data = node.data\n    while let next = node.next {\n        if data == next.data {\n            node.next = next.next\n        } else {\n            node = next\n            data = node.data\n        }\n    }\n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340884,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc removeDuplicates(head: Node?) -> Node? {\n    guard head != nil else { return nil }\n    \n    var data = head!.data\n    let newList = Node(data)\n    var node = head\n    \n    while node != nil {\n        if node?.data != data {\n            data = node!.data\n            newList.lastElement()?.next = Node(data)\n            print(\"data: \\(data)\")\n        }\n        node = node?.next\n    }\n    \n    return newList\n}\n\nextension Node {\n    func lastElement() -> Node? {\n        var node: Node? = self\n        while node?.next != nil {\n            node = node?.next\n        }\n        return node\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55da347204760ba494000038":[{"id":340885,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum moveNodeError: Error {\n    case sourceListIsEmpty\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n    guard source != nil else {throw moveNodeError.sourceListIsEmpty}\n    return Context(source: source?.next, dest: push(dest, (source?.data)!))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340886,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nenum MoveNodeError: Error {\n  case nilSource\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n    guard let source = source else { throw(MoveNodeError.nilSource) }\n    return Context(source: source.next, dest: push(dest, source.data))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340887,"user_id":null,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n      self.data = data\n  }\n}\n\nstruct Context {\n  var source:Node?\n  var dest:Node?\n}\n\nenum SourceError: Error {\n    case Empty\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n  guard let sourceHead = source else { throw SourceError.Empty }\n  let newSource = source!.next\n  \n  sourceHead.next = dest\n  return Context(source: newSource, dest: sourceHead)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340888,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n  guard let nodeToMove = source else {\n    throw NSError(domain: \"Source node is empty\", code: -1000, userInfo: nil)\n  }\n  \n  let newSource = nodeToMove.next\n  nodeToMove.next = dest\n  return .init(source: newSource, dest: nodeToMove)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340889,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\nenum CNodeError: Error {\n      case outOfRange\n  }\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n      guard let source = source else { throw CNodeError.outOfRange }\n      return Context(source: source.next, dest: push(dest, source.data))\n\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340890,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum Failure: Error {\n    case EmptySourceList\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n    if let s = source {\n        let newSource = s.next\n        s.next = dest\n        return Context(source: newSource, dest: s)\n    } else {\n        throw Failure.EmptySourceList\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340891,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n  if source == nil {\n    throw SourceEmptyError.emptySource\n  }\n  let newSource = source?.next\n  source?.next = dest\n  return Context(source: newSource, dest: source)\n}\n\nenum SourceEmptyError: Error {\ncase emptySource\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340892,"user_id":null,"body":"import Foundation\n\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nenum TestError : Error {\n    case commonError\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n    guard source?.data != nil else {\n        throw TestError.commonError\n    }\n    var sor = source\n    let temp = sor\n    sor = sor!.next\n    if dest == nil {\n        temp!.next = nil\n    } else {\n        temp!.next = dest\n    }\n    var res = Context()\n    res.source = sor\n    res.dest = temp\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340893,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n    guard let source = source else {\n        enum MoveError: Error {\n            case nilInput\n        }\n        throw MoveError.nilInput\n    }\n\n    let movedSource = source.next\n    let movedDest = source\n    movedDest.next = dest\n    return Context(source: movedSource, dest: movedDest)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340894,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n  \n    enum Error: Swift.Error {\n      case emptySource\n    }\n}\n\nfunc moveNode(source:Node?, dest:Node?) throws -> Context? {\n  guard let source = source else { throw Context.Error.emptySource }\n  let tail = source.next\n  source.next = dest\n  return Context(source: tail, dest: source)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55dd5386575839a74f0000a9":[{"id":340895,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nenum ListError: Error {\n    case Empty\n}\n\nfunc add(element: Node?, toNext: Node?, next: Node?) {\n    if let element = element  {\n        toNext?.next = Node(element.data)\n    }\n    if element?.next != nil {\n        add(element: element?.next, toNext: next, next: toNext?.next)\n    }\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n    if head?.next == nil { throw ListError.Empty }\n    var context = Context()\n    context.source = Node((head?.data)!)\n    context.dest = Node((head?.next?.data)!)\n    add(element: head?.next?.next, toNext: context.source, next: context.dest)\n    return context\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340896,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n    \nenum alternatingSplitError: Error {\n    case listIsEmptyOrContainsJustASingleNode\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n    guard head != nil && head?.next != nil else {throw alternatingSplitError.listIsEmptyOrContainsJustASingleNode}\n    var list = NodeToArray(head)![0...((NodeToArray(head)?.count)!-1)]\n    var list1: [Int] = []\n    var list2: [Int] = []\n    while list != [] {\n        list1.append(list.popFirst()!)\n        if list != [] {\n            list2.append(list.popFirst()!)\n        }\n    }\n    return Context(source: createLinkedList(list1), dest: createLinkedList(list2))\n}\n\nfunc NodeToArray(_ head:Node?) -> [Int]? {\n    guard head?.next != nil else {return [(head?.data)!]}\n    var array: [Int] = NodeToArray(head?.next)!\n    array.insert((head?.data)!, at: 0)\n    return array\n}\n\nfunc createLinkedList(_ data:[Int]?) -> Node? {\n    if data == nil {return nil}\n    if data?.count == 1 {return push(nil, (data?[0])!)}\n    return push(createLinkedList(Array(data![1...(data!.count)-1])), (data![0]))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340897,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum ListException : Error {\n    case outOfRange\n}\n\nfunc push(head : Node?, data : Int) -> Node?{\n    let newNode = Node(data)\n    newNode.next = head\n    return newNode\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n    if head == nil || head?.next == nil {\n        throw ListException.outOfRange\n    }\n    var arrayList = [Int]()\n    var current = head\n    while current != nil {\n        arrayList.append((current?.data)!)\n        current = current?.next\n    }\n    \n    var source : Node?\n    var dest : Node?\n    for i in stride(from: arrayList.count - 1, through: 0, by: -1){\n        if i % 2 == 0 {\n            source = push(head: source, data: arrayList[i])\n        }\n        else {\n            dest = push(head: dest, data: arrayList[i])\n        }\n    }\n    \n    return Context(source: source, dest: dest)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340898,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nstruct MyError: Error {}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n  guard let first = head, var node = first.next else { throw MyError() }\n  \n  var array = [first.data, node.data]\n  \n  while let next = node.next {\n    array.append(next.data)\n    node = next\n  }\n  \n  var source: Node?\n  var dest: Node?\n  \n  for i in stride(from: 0, to: array.count, by: 2).reversed() {\n    let theSource = Node(array[i])\n    theSource.next = source\n    source = theSource\n  }\n  \n  for i in stride(from: 1, to: array.count, by: 2).reversed() {\n    let theDest = Node(array[i])\n    theDest.next = dest\n    dest = theDest\n  }\n  \n  return Context(source: source, dest: dest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340899,"user_id":676,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n  convenience init(_ data: Int, _ next: Node?) {\n    self.init(data)\n    self.next = next\n  }\n}\n\nstruct Context {\n  var source: Node?\n  var dest: Node?\n}\n\nenum AlternatingSplitError: Error {\n  case emptyList\n  case singleNode\n}\n\nfunc alternatingSplit(head: Node?) throws -> Context? {\n  guard let node = head else { throw AlternatingSplitError.emptyList }\n  guard let next = node.next else { throw AlternatingSplitError.singleNode }\n  return Context(source: takeEveryOther(node), dest: takeEveryOther(next))\n}\n\nfunc takeEveryOther(_ head: Node?) -> Node? {\n  return head.map {h in Node(h.data, h.next.flatMap {takeEveryOther($0.next)})}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340900,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n    \n     convenience init(_ head: Node?, _ data: Int) {\n        self.init(data)\n        self.next = head\n    }\n}\n\nfunc nodeToArray(_ list: Node?) -> [Int] {\n    var nodeArray: [Int] = []\n    var head = list\n    while head != nil {\n        nodeArray.append(head!.data)\n        head = head!.next\n    }\n    return nodeArray\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nenum LinkedListException: Error {\n    case InvalidArgumentException\n    case EmptyListException\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n    let nodes = nodeToArray(head)\n    guard nodes.count > 1 else {\n        throw LinkedListException.InvalidArgumentException\n    }\n    let evenArray = nodes.enumerated().filter{$0.0 % 2 == 0}.map{$0.1}\n    let oddArray = nodes.enumerated().filter{$0.0 % 2 != 0}.map{$0.1}\n    let evenNode = buildListFromArray(evenArray)\n    let oddNode = buildListFromArray(oddArray)\n    return Context(source: evenNode, dest: oddNode)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340901,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n    func collect() -> [Int] {\n        return [data] + (next?.collect() ?? [])\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nenum CNodeError: Error {\n    case outOfRange\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n    guard head != nil, let source = head?.collect(), source.count > 1  else { throw CNodeError.outOfRange }\n    var one:[Int] = []\n    var two:[Int] = []\n    for i in 0..<source.count {\n        if i % 2 == 0 {\n            one.append(source[i])\n        } else {\n            two.append(source[i])\n        }\n    }\n    return Context(source:buildListFromArray(one), dest:buildListFromArray(two))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340902,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nstruct MyError: Error {\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n    if head?.next == nil {\n        throw MyError()\n    }\n    var result = Context()\n    result.source = Node( head!.data )\n    result.dest = Node( head!.next!.data )\n    var current = head!.next!.next\n    var firstTail = result.source\n    var secondTail = result.dest\n    var writeToFirst = true\n    while( current != nil ) {\n        if( writeToFirst ) {\n            firstTail!.next = Node( current!.data )\n            firstTail = firstTail!.next\n        } else {\n            secondTail!.next = Node( current!.data )\n            secondTail = secondTail!.next\n        }\n        writeToFirst = !writeToFirst;\n        current = current!.next\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340903,"user_id":null,"body":"enum LLError: Error {\n    case invalidArgument\n}\n\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc alternatingSplit(head: Node?) throws -> Context? {\n    guard let item0 = head,\n          let item1 = head?.next else\n    {\n        throw LLError.invalidArgument\n    }\n    \n    let ctx = Context(source: Node(item0.data),\n                      dest: Node(item1.data))\n    \n    var node = ctx.source\n    var next = ctx.dest\n    var listItem: Node? = head!.next!.next\n    \n    while listItem != nil {\n        let copy = Node(listItem!.data)\n        node!.next = copy\n        node = next\n        next = copy\n        \n        listItem = listItem!.next\n    }\n    \n    return ctx\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340904,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum LinkedListError: Error {\n    case argumentException\n}\n\nstruct Context {\n    var source:Node?\n    var dest:Node?\n}\n\nfunc alternatingSplit(head:Node?) throws -> Context? {\n  guard let _ = head, let _ = head?.next else {\n    throw LinkedListError.argumentException\n  }\n  var list = head\n  var sourceList: Node? = Node(0)\n  let sourceListHead = sourceList\n  var destList: Node? = Node(0)\n  let destListHead = destList\n  while list != nil {\n    sourceList?.next = Node(list!.data)\n    sourceList = sourceList?.next\n\n    if let _ = list!.next {\n      destList?.next = Node(list!.next!.data)\n      destList = destList?.next\n    }\n    \n    list = list?.next?.next\n  }\n  return Context(source: sourceListHead?.next, dest: destListHead?.next)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e1d2ba1a3229674d000037":[{"id":340905,"user_id":null,"body":"extension Int : Error {}\n\nclass Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n\n    guard source?.next != nil else {throw 1}\n    \n    front = source\n    back = source\n    \n    while back!.next?.next != nil\n    {\n        front = front!.next\n        back = back!.next!.next\n    }\n\n    back = front!.next\n    front!.next = nil\n    front = source\n    \n    return\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340906,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n\n    var list: [Node] {\n      return [self] + (next?.list ?? [])\n    }\n}\n\nenum SplitError: Error {\n  case invalidArguments\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n  guard let all = source?.list, all.count > 1 else {\n    throw SplitError.invalidArguments\n  }\n  let middle = all.count \/ 2 + (all.count % 2 == 0 ? 0 : 1)\n  let firstHalf = all[0..<middle]\n  firstHalf.last?.next = nil\n  front = firstHalf.first\n  back = all[middle]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340907,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum Errors: Error {\n  case emptyList\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n  guard source != nil, source?.next != nil else {\n    throw Errors.emptyList\n  }\n  var slow = source\n  var fast = source\n  var lastKnown: Node?\n  \n  while fast != nil {\n    lastKnown = slow\n    slow = slow?.next\n    fast = fast?.next?.next\n  }\n  \n  lastKnown?.next = nil\n  front = source\n  back = slow\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340908,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum Errors: Error { case invalid }\n\n\/\/ Using slow\/fast cursor, single O(n) pass\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n    guard\n      let first = source,\n      let second = first.next\n      else { throw Errors.invalid }\n\n    var slow: Node? = first \/\/ idx 0\n    var fast: Node? = second.next \/\/ idx 2\n    while fast != nil {\n        slow = slow!.next\n        fast = fast!.next?.next\n    }\n\n    front = first\n    back = slow!.next\n    slow!.next = nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340909,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nclass InvalidSourceArgument: Error { \n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n    guard source?.next != nil, let source = source else { throw InvalidSourceArgument() }\n    front = source\n    var slowPointer = front\n    var fastPointer = front?.next\n    while fastPointer?.next != nil {\n        slowPointer = slowPointer?.next\n        fastPointer = fastPointer?.next?.next\n    }\n    back = slowPointer?.next\n    slowPointer?.next = nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340910,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum IllegalArgument: Error {\n  case Null;\n  case TooShort\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n  var slow = source\n  var fast = source?.next\n  while fast != nil {\n    fast = fast?.next\n    if fast != nil {\n      fast = fast?.next\n      slow = slow?.next\n    }\n  }\n  \n  front = source\n  if front == nil {\n    throw IllegalArgument.Null\n  }\n  \n  back = slow?.next\n  if back == nil {\n    throw IllegalArgument.TooShort\n  }\n  slow?.next = nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340911,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nimport Foundation\n\nextension String: Error {}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nextension Node { var length: Int { return map { $0 }.count } }\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n    guard let source = source, let _ = source.next else { throw \"Error\" }\n\n    let half = Int(ceil(Double(source.length) \/ 2))\n    let array = source.map { $0.data }\n    front = buildListFromArray(Array(array[0..<half]))\n    back = buildListFromArray(Array(array[half...array.count - 1]))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340912,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum NewNodeError: Error {\n    case invalidArgumentException\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n    guard var head = source, head.next != nil else { throw NewNodeError.invalidArgumentException }\n    var nodes = [head]\n    while let node = head.next {\n        nodes.append(node)\n        head = node\n    }\n    let mid = (nodes.count+1)\/2\n    front = nodes[0]\n    nodes[mid-1].next = nil\n    back = nodes[mid]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340913,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum MyError: Error {\n  case null\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n  guard let source = source, source.next != nil else { throw MyError.null}\n  var current = source\n  var m = source\n  var odd = false\n  while let next = current.next {\n    odd.toggle()\n    m = odd ? m : m.next!\n    current = next\n  }\n  back = m.next\n  m.next = nil\n  front = source\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340914,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nenum SplitError: Error {\n  case InvalidInput\n  case BadSource\n}\n\nfunc frontBackSplit(source: Node?, front: inout Node?, back: inout Node?) throws {\n  guard source != nil else { throw SplitError.InvalidInput}\n  var current = source\n  var listLength = 0\n  while current != nil {\n    listLength += 1\n    current = current!.next\n  }\n  guard listLength >= 2 else { throw SplitError.BadSource }\n  print(listLength)\n  \n  current = source\n  var limit = 0\n  if listLength % 2 == 0 {\n    limit = listLength \/ 2\n  } else {\n    limit = listLength \/ 2 + 1\n  }\n  var frontHead: Node? = nil\n  var backHead: Node? = nil\n  for i in 0..<listLength {\n    print(current!.data)\n    if i < limit {\n      if front == nil {\n        front = current\n        frontHead = front\n      } else {\n        front!.next = current\n        front = front!.next\n      }\n      print(\"front is\", front!.data)\n    } else {\n      if back == nil {\n        back = current\n        backHead = back\n      } else {\n        back!.next = current\n        back = back!.next\n      }\n      print(\"back is\", back!.data)\n    }\n    current = current!.next\n  }\n  front?.next = current\n  back?.next = current\n  \n  front = frontHead\n  back = backHead\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e2adece53b4cdcb900006c":[{"id":340915,"user_id":null,"body":"func race(_ v1: Int,_ v2: Int,_ g: Int) -> [Int]? {\n    let h = g \/ (v2 - v1)\n    let m = ((g % (v2-v1)) * 60) \/ (v2-v1)\n    let s = (((g % (v2-v1)) * 60) % (v2-v1)) * 60 \/ (v2-v1)\n    \n    return v2 > v1 ? [h, m, s] : nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340916,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n    if (v1 >= v2) {\n        return nil\n    }\n    \n    let seconds = g * 3600 \/ (v2-v1)\n    \n    return [seconds \/ 3600, (seconds % 3600) \/ 60, seconds % 60]\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340917,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n    guard v1 < v2 else { return nil }\n    \n    \/\/ two constants for the beginning\n    let hrSecs = 3600\n    let hrMins = 60\n    \n    \/\/ following the basic formulas around velocity in physics I used\n    \/\/ formula for the distance travelled by the faster tortoise (B)\n    \/\/ D = v2*T\n    \/\/ where D is distance, V2 is speed of B and T is time of the travel\n    \/\/ and then formula for the distance travelled by the slower tortoise (A)\n    \/\/ D = g + v1*T\n    \/\/ where D is distance, g is the initial distance of A and T is time  of the travel and v2 is of couse the slower speed\n    \/\/ after comparing these two formular (to find a point, where they meet) and a number of\n    \/\/ transformation, the final formula for computing time of the meetup (in seconds!) is:\n    let t: Int = g * hrSecs \/ (v2 - v1)\n    \n    \/\/ now, to calculate the time units as a result:\n    let hrs = t \/ hrSecs\n    let mins = (t - (hrs * hrSecs)) \/ hrMins\n    let secs = t % hrMins\n    return [hrs, mins , secs]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340918,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n\tguard v1 <= v2 else { return nil }\n\tlet speedDifference = (v2 - v1)\n\tlet resultInSeconds = g * 3600 \/ speedDifference\n\treturn [resultInSeconds\/3600, resultInSeconds%3600\/60, resultInSeconds%3600%60]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340919,"user_id":492,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n  if v2 < v1 { return nil }\n  let ts: Double = Double(g) * 3600.0 \/ Double(v2 - v1)\n  let tm: Int = Int(ts \/ 60)\n  return [tm \/ 60, tm % 60, Int(ts) % 60]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340920,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n    guard v1 <= v2, g > 0 else { return nil }\n    let d = v2 - v1\n    return [g \/ d, ((g * 60) \/ d) % 60, ((g * 60 * 60) \/ d) % 60]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340921,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n  var time = g * 3600 \/ (v2 - v1)\n    return  v1 >= v2 ? nil : [time \/ 3600, (time % 3600) \/ 60, time % 3600 % 60]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340922,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n  guard v1 < v2 else { return nil }\n  let seconds = (g * 3600) \/ (v2 - v1);\n  return [seconds \/ 3600, (seconds % 3600) \/ 60, (seconds % 3600) % 60]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340923,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n  if v1 >= v2 {\n    return nil\n  }\n  var diff = Double(g) \/ Double(v2 - v1)\n    \n let result:[Int] = [Int(diff) , Int(diff * 60) % 60 , Int(diff * 60 * 60) % 60 ]\n return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340924,"user_id":null,"body":"func race(_ v1: Int, _ v2: Int, _ g: Int) -> [Int]? {\n    if v1 >= v2 {\n    return nil\n    } else {\n    var timeInSeconds  = g * 3600 \/ (v2 - v1)\n    let hour = timeInSeconds \/ 3600\n    let minute = timeInSeconds % 3600 \/ 60\n    let second = timeInSeconds % 3600 % 60\n    return [hour, minute, second]\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e5253dcd20f821c400008e":[{"id":340925,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n    guard let first = first else { return second }\n    guard let second = second else { return first }\n\n    first.next = shuffleMerge(first: second, second: first.next)\n    return first\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340926,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n    first?.next = shuffleMerge(first: second, second: first?.next)\n    return first != nil ? first : second\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340927,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n\tif let first = first {\n  \tfirst.next = shuffleMerge(first: second, second: first.next)\n    return first\n  }\n  return second\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340928,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int, next: Node? = nil) {\n        self.data = data\n        self.next = next\n    }\n}\n\nstruct LinkedList {\n    var head: Node?\n    var tail: Node?\n    \n    var isEmpty: Bool { head == nil }\n    \n    init() { }\n}\n\nextension LinkedList {\n    mutating func push(_ value: Int) {\n        \n        head = Node(value, next: head)\n        if tail == nil { tail = head }\n    }\n    \n    mutating func append(_ value: Int) {\n        \n        guard !isEmpty else {\n            push(value)\n            return\n        }\n        tail!.next = Node(value)\n        tail = tail!.next\n    }\n}\n\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n    if first == nil { return second }\n    if second == nil { return first }\n    var first = first, second = second\n    var newList = LinkedList()\n    \n    while first != nil || second != nil {\n        \n        if let firstVal = first?.data {\n            newList.append(firstVal)\n        }\n        if let secondVal = second?.data { newList.append(secondVal)\n        }\n       \n        first = first?.next\n        second = second?.next\n        \n    }\n    newList.tail?.next = nil\n    return newList.head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340929,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n    let head: Node?\n    var nextFirst: Node?\n    var nextSecond: Node?\n\n    if first != nil {\n        head = first\n        nextFirst = second\n        nextSecond = first?.next\n    } else if second != nil {\n        head = second\n        nextSecond = second?.next\n    } else {\n        head = nil\n    }\n\n    var tail = head\n    \n    while nextFirst != nil || nextSecond != nil {\n        if nextFirst != nil {\n            let temporarNextFirst = nextFirst!.next\n            tail?.next = nextFirst\n            tail = nextFirst\n            nextFirst = temporarNextFirst\n        }\n        \n        if nextSecond != nil {\n            let temporarNextSecond = nextSecond!.next\n            tail?.next = nextSecond\n            tail = nextSecond\n            nextSecond = temporarNextSecond\n        }\n    }\n    \n    return head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340930,"user_id":null,"body":"class Node {\n  let data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n  guard let first = first else { return second }\n  guard let second = second else { return first }\n  defer { first.next = shuffleMerge(first: second, second: first.next) }\n  return first\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340931,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n  guard first != nil else { return second }\n  guard second != nil else { return first }\n  \n  var firstNode = first?.next\n  var secondNode = second\n  let result = first\n  var resultTail = result\n  \n  while firstNode != nil && secondNode != nil {\n    resultTail?.next = secondNode\n    resultTail = resultTail?.next\n    secondNode = secondNode?.next\n    \n    resultTail?.next = firstNode\n    resultTail = resultTail?.next\n    firstNode = firstNode?.next\n  }\n  \n  if firstNode != nil {\n    resultTail?.next = firstNode\n  }\n  \n  if secondNode != nil {\n    resultTail?.next = secondNode\n  }\n  \n  return result\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340932,"user_id":53,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n  if (first == nil) { return second }\n  if (second == nil) { return first }\n  var n = Node(first!.data)\n  n.next = shuffleMerge(first: second, second: first!.next)\n  return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340933,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n    init?(_ array:[Int]) {\n        guard let value = array.first else { return nil }\n        self.data = value\n        self.next = Node(Array(array[1...]))\n    }\n    func length() -> Int{\n        guard let next = self.next else { return 1 }\n        return next.length() + 1\n    }\n    func getByIndex(_ index:Int) throws -> Node{\n        if index > self.length() - 1 || index < 0 { throw NodeErrors.ArgumentException }\n        return index == 0 ? self : try self.next!.getByIndex(index - 1)\n    }\n}\n\nenum NodeErrors: Error {\n    case ArgumentException\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n    guard let first = first else { return second }\n    guard let second = second else { return first }\n    var result:[Int?] = []\n    for i in 0..<max(first.length(), second.length()) {\n        result.append(contentsOf: [try? first.getByIndex(i).data, try? second.getByIndex(i).data])\n    }\n    return Node(result.compactMap{$0})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340934,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n  \n    var description: String {\n      String(data) + (next?.description ?? \"\")\n    }\n}\n\nfunc shuffleMerge(first: Node?, second: Node?) -> Node? {\n  var firstIteratingNode = first\n  var secondIteratingNode = second\n  var result: Node?\n  while firstIteratingNode != nil || secondIteratingNode != nil {\n    result = move(firstNodeIn: firstIteratingNode, toTailOf: result)\n    result = move(firstNodeIn: secondIteratingNode, toTailOf: result)\n    print(result?.description)\n    firstIteratingNode = firstIteratingNode?.next\n    secondIteratingNode = secondIteratingNode?.next\n  }\n  return result\n}\n\nfunc move(firstNodeIn firstNode: Node?, toTailOf secondNode: Node?) -> Node? {\n  guard let firstNode = firstNode else { return secondNode }\n  guard let secondNode = secondNode else { return Node(firstNode.data) }\n  var tail: Node? = secondNode\n  while let secondNext = tail?.next {\n    tail = secondNext\n  }\n  tail?.next = Node(firstNode.data)\n  return secondNode\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e5d31bf7ca1e44980000a7":[{"id":340935,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int, next: Node? = nil) {\n        self.data = data\n        self.next = next\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n  guard var a = first, var b = second else {\n    return first ?? second\n  }\n  if a.data > b.data {\n    (a, b) = (b, a)\n  }\n  return Node(a.data, next: sortedMerge(first: a.next, second: b))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340936,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n  guard let first = first else { return second }\n  guard let second = second else { return first }\n  \n  let firstSmaller = first.data < second.data\n  let current = firstSmaller ? first : second\n  \n  current.next = sortedMerge(first: firstSmaller ? first.next : first, second: firstSmaller ? second : second.next)\n  \n  return current\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340937,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n  guard let first = first else { return second }\n  guard let second = second else { return first }\n  \n  if first.data < second.data {\n    first.next = sortedMerge(first:first.next, second:second)\n    return first\n  } else {\n    second.next = sortedMerge(first:first, second:second.next)\n    return second\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340938,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n  \n  if first == nil { return second }\n  if second == nil { return first }\n  \n  var current1 = first\n  var current2 = second\n  \n  var result: Node?\n  var resultTail: Node?\n  \n  while let node1 = current1, let node2 = current2 {\n    let newNode: Node\n    if node1.data < node2.data {\n      newNode = Node(node1.data)\n      current1 = node1.next\n    }\n    else {\n      newNode = Node(node2.data)\n      current2 = node2.next\n    }\n    resultTail?.next = newNode\n    resultTail = newNode\n    \n    if result == nil { result = resultTail }\n  }\n  \n  while let node1 = current1 {\n    let newNode: Node = Node(node1.data)\n    resultTail?.next = newNode\n    resultTail = newNode\n    \n    current1 = node1.next\n  }\n  \n  while let node2 = current2 {\n    let newNode: Node = Node(node2.data)\n    resultTail?.next = newNode\n    resultTail = newNode\n    \n    current2 = node2.next\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340939,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n    if first == nil {\n        if second == nil {\n            return nil\n        } else {\n            return second\n        }\n    } else {\n        if second == nil {\n            return first\n        }\n    }\n\n    return buildListFromArray((first!.map { $0.data } + second!.map { $0.data }).sorted())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340940,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first: Node?, second: Node?) -> Node? {\n    switch (first,second) {\n    case (_,nil) : return first\n    case (nil,_) : return second\n    default:\n        if first!.data < second!.data { return push(sortedMerge(first: first!.next, second: second), first!.data) }\n        else { return push(sortedMerge(first: first, second: second!.next), second!.data) }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340941,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n  switch (first, second) {\n  case (nil, nil):\n    return nil\n  case (_, nil):\n    return first\n  case (nil, _):\n    return second\n  default:\n    let fst = first!\n    let snd = second!\n\n    if fst.data < snd.data {\n      let node = Node(fst.data)\n      node.next = sortedMerge(first: fst.next, second : second)\n      return node\n    } else {\n      let node = Node(snd.data)\n      node.next = sortedMerge(first: first, second : snd.next)\n      return node\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340942,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n  guard let first = first else { return second }\n    guard let second = second else { return first }\n    \n    let head = first\n    var current = first \n    while current.next != nil { current = current.next! }\n    current.next = second\n    var list = [Int]()\n    current = head\n    while current.next != nil {\n        list.append(current.data)\n        current = current.next!\n    }\n    list.append(current.data)\n    list = list.sorted()\n    current = head \n    while current.next != nil {\n        current.data = list.removeFirst()\n        current = current.next!\n    }\n    current.data = list.removeFirst()\n    return head\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340943,"user_id":null,"body":"class Node {\n  let data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc sortedMerge(first: Node?, second: Node?) -> Node? {\n  var res: Node?\n  var cur = res\n  \n  var left = first\n  var right = second\n  \n  while left != nil && right != nil {\n    if left!.data < right!.data {\n      cur?.next = left\n      cur = left\n      left = left?.next\n    }\n    else {\n      cur?.next = right\n      cur = right\n      right = right?.next\n    }\n    res = res ?? cur\n  }\n  \n  var rest = left ?? right\n  while rest != nil {\n    cur?.next = rest\n    cur = rest\n    res = res ?? cur\n    rest = rest?.next\n  }\n  \n  cur?.next = nil\n  \n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340944,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc sortedMerge(first:Node?, second:Node?) -> Node? {\n    if first == nil && second == nil { return nil }\n    guard let first = first else { return second }\n    guard let second = second else { return first }\n    \n    var resultNodeHead: Node?\n    \n    var firstNode: Node? = first\n    var secondNode: Node? = second\n    if first.data < second.data {\n        resultNodeHead = first\n        firstNode = first.next\n    } else {\n        resultNodeHead = second\n        secondNode = second.next\n    }\n    var resultNode: Node? = resultNodeHead\n    while firstNode != nil || secondNode != nil {\n        if\n            let firsNodeV = firstNode,\n            let secondNodeV = secondNode\n        {\n            if firsNodeV.data < secondNodeV.data {\n                resultNode?.next = firsNodeV\n                firstNode = firsNodeV.next\n            } else {\n                resultNode?.next = secondNodeV\n                secondNode = secondNodeV.next\n            }\n        } else if firstNode == nil {\n            resultNode?.next = secondNode\n            secondNode = secondNode?.next\n        } else {\n            resultNode?.next = firstNode\n            firstNode = firstNode?.next\n        }\n        resultNode = resultNode?.next\n    }\n    return resultNodeHead\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e5fa3501fd9c3f4d000050":[{"id":340945,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n    guard let _ = list, let _ = list!.next else {\n        return list\n    }\n    var left: Node?, right: Node?\n    try! frontBackSplit(source: list, front: &left, back: &right)\n    return sortedMerge(first: mergeSort(left), second: mergeSort(right))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340946,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n\n    let a = list\n    let b = frontBackSplit( a )\n    \n    if b == nil { return a }\n     \n    return sortedMerge( mergeSort(a), mergeSort(b) ) \n\n}\n\nfunc frontBackSplit( _ head: Node? ) -> Node?\n{\n\n    guard head?.next != nil else {return nil} \/\/0 or 1 element list; nothing to split\n    \n    var a = head\n    var b = head\n    \n    while b?.next?.next != nil\n    {\n        a = a!.next\n        b = b!.next!.next\n    }\n\n    b = a!.next\n    a!.next = nil\n    return b\n}\n\nfunc sortedMerge( _ a: Node?, _ b: Node? ) -> Node?\n{\n    guard a != nil else {return b}\n    guard b != nil else {return a}\n    \n    var a = a\n    var b = b\n    \n    var list: Node?\n    \n    if a!.data < b!.data\n    {\n        let t = a!.next\n        list = a\n        list!.next = nil\n        a = t\n    }\n    else\n    {\n        let t = b!.next\n        list = b\n        list!.next = nil\n        b = t\n    }\n    \n    var i = list\n    \n    while a != nil && b != nil\n    {\n        if a!.data < b!.data\n        {\n            let t = a!.next\n            i!.next = a\n            i = i!.next\n            i!.next = nil\n            a = t\n        }\n        else\n        {\n            let t = b!.next\n            i!.next = b\n            i = i!.next\n            i!.next = nil\n            b = t\n        }\n    }\n    \n    if a != nil {i!.next = a}\n    if b != nil {i!.next = b}\n    \n    return list\n}\n        ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340947,"user_id":null,"body":"class Node {\n  let data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n  guard list?.next != nil else { return list }\n  \n  var front, back: Node?\n  try! frontBackSplit(source: list, front: &front, back: &back)\n  \n  return sortedMerge(first: mergeSort(front), second: mergeSort(back))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340948,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n    var front: Node? = nil\n    var back: Node? = nil\n    do {\n        try frontBackSplit(source: list, front: &front, back: &back)\n    } catch {\n        return list\n    }\n    \n    front = mergeSort(front)\n    back = mergeSort(back)\n    \n    return sortedMerge(first: front, second: back)\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340949,"user_id":53,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n  if (list == nil || list?.next == nil) { return list }\n  var f:Node?\n  var b:Node?\n  try! frontBackSplit(source: list, front: &f, back: &b)\n  return sortedMerge(first: mergeSort(f), second: mergeSort(b))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340950,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n    func sort() -> Node{\n        var temp:Int\n        for i in 0..<self.length(){\n            for j in (i + 1)..<self.length(){\n                if self.getByIndex(i).data > self.getByIndex(j).data{\n                    temp = self.getByIndex(j).data\n                    self.getByIndex(j).data = self.getByIndex(i).data\n                    self.getByIndex(i).data = temp\n                }\n            }\n        }\n        return self\n    }\n    func getByIndex(_ index:Int) -> Node{\n        return index == 0 ? self : try self.next!.getByIndex(index - 1)\n    }\n    func length() -> Int{\n        guard let next = self.next else { return 1 }\n        return next.length() + 1\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n    guard let list = list else { return nil }\n    return list.sort()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340951,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n  \n    var isSorted: Bool {\n      guard let next = next else { return true }\n      return data <= next.data\n    }\n  \n    var description: String {\n      guard let next = next else { return String(data) }\n      return String(data) + String(next.data)\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n  guard list?.next != nil else { return list }\n  var front: Node?\n  var back: Node?\n  try? frontBackSplit(source: list, front: &front, back: &back)\n  let sortedFront = mergeSort(front)\n  let sortedBack = mergeSort(back)\n  let sorted = sortedMerge(first: sortedFront, second: sortedBack)\n  return sorted\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340952,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list: Node?) -> Node? {\n  guard let list = list else { return nil }\n  guard list.next != nil else { return list }\n  \n  var firstHalfOfList: Node?\n  var secondHalfOfList: Node?\n  try! frontBackSplit(source: list, front: &firstHalfOfList, back: &secondHalfOfList)\n  \n  return sortedMerge(first: mergeSort(firstHalfOfList), second: mergeSort(secondHalfOfList))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340953,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n  var front: Node?; var back: Node?\n  \n  guard let firstNode = list, let _ = list?.next else {\n    return list\n  }\n\n  try! frontBackSplit(source: list, front: &front, back: &back)\n  return sortedMerge(first: mergeSort(front), second: mergeSort(back))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340954,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc mergeSort(_ list:Node?) -> Node? {\n    var first: Node?\n    var second: Node?\n    do {\n        try frontBackSplit(source: list, front: &first, back: &second)\n    } catch {\n        return list\n    }\n    return sortedMerge(first: mergeSort(first), second: mergeSort(second))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e67e44bf97fa66900000a0":[{"id":340955,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n    \n    guard first != nil && second != nil else {return nil}\n    \n    var first = first\n    var second = second\n    \n    while (first?.data)! < (second?.data)! || (first?.data) == (first?.next?.data) {first = first?.next}\n    while (second?.data)! < (first?.data)! || (second?.data) == (second?.next?.data) {second = second?.next}\n    \n    first?.next = SortedIntersect(first: first?.next, second: second?.next)\n    \n    return first\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340956,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n\n   guard let _ = first, let _ = second else {\n   \t\treturn nil\n   }\n \n   var mutual : Node? = nil \n   var hash : [ Int : Node ] = [:]\n\n   \/\/ mutate it\n   var firstHead = first\n \n   while let node = firstHead {\n   \thash[node.data] = node\n   \tfirstHead = node.next\n   }\n   \n   while let node = second {\n    \/\/ if the key in there, then it matches\n   \tif let _ = hash[node.data] {\n    \t\tlet newNode = Node(node.data)\n        newNode.next = mutual\n        mutual = newNode\n    }\n    \n   }\n   \n   return mutual\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340957,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n\n    convenience init(_ data: Int, next: Node?) {\n        self.init(data)\n        self.next = next\n    }\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n\n}\n\nextension Array {\n\n    func toNode() -> Node {\n        let head = Node(self[0] as! Int)\n\n        var current = head\n\n        for i in 1..<self.count {\n            current.next = Node(self[i] as! Int)\n            current = current.next!\n        }\n\n        return head\n    }\n\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n    guard let first = first else { return nil }\n    guard let second = second else { return nil }\n\n    let firstSet = Set(first.map { $0.data })\n    let secondSet = Set(second.map { $0.data })\n\n    return Array(firstSet.intersection(secondSet)).sorted().toNode()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340958,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }   \n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n    if first == nil || second == nil { return nil }\n    \n    return buildListFromArray( Array( Set(first!.map{$0.data})\n      .intersection(Set(second!.map{$0.data})) \n      ).sorted() )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340959,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n    guard let first = first, let second = second else { return nil }\n    if first.data == second.data {\n        let result = Node(first.data)\n        let tail = SortedIntersect(first: first.next, second: second.next)\n        \n        result.next = result.data != tail?.data ? tail : tail?.next\n        \n        return result\n    } else if first.data < second.data {\n        return SortedIntersect(first: first.next, second: second)\n    }\n    return SortedIntersect(first: first, second: second.next)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340960,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node {\n  func toSet() -> Set<Int>{\n    var arr: [Int] = [self.data]\n    var currentNode: Node? = self.next\n    while (currentNode != nil) {\n      arr.append(currentNode!.data)\n      currentNode = currentNode!.next\n    }\n    return Set(arr)\n  }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n  guard let node1 = first, \n        let node2 = second \n  else {\n    return nil\n  }\n    \n  let intersect = node1.toSet().intersection( node2.toSet() )\n  let intersectArray = Array(intersect).sorted{ $0 < $1 }\n  \n  return buildListFromArray(intersectArray)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340961,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n    guard let first = first, let second = second else { return nil }\n    var setFirst = getAllNode(first)\n    let setSecond = getAllNode(second)\n    setFirst.formIntersection(setSecond)\n    let array = setFirst.sorted(by: { $0 > $1 })\n    \n    var node: Node? = nil\n    array.forEach { value in\n        let innerNode = Node(value)\n        innerNode.next = node\n        node = innerNode\n    }\n    return node\n}\n\nfunc getAllNode(_ node: Node?) -> Set<Int> {\n    guard let node = node else { return [] }\n    var _node: Node? = node\n    var items: Set<Int> = []\n    while (_node != nil) {\n        if let __node = _node {\n            items.insert(__node.data)\n            _node = __node.next\n        }\n    }\n    return items\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340962,"user_id":null,"body":"class Node {\n  let data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc SortedIntersect(first: Node?, second: Node?) -> Node? {\n  var l = first\n  var r = second\n  \n  var res: Node?\n  var cur = res\n  \n  while l != nil && r != nil {\n    if l?.data == r?.data {\n      if cur?.data != l?.data {\n        cur?.next = l\n        cur = l\n        res = res ?? cur\n      }\n      l = l?.next\n      r = r?.next\n    }\n    else if l!.data < r!.data {\n      l = l?.next\n    }\n    else {\n      r = r?.next\n    }\n  }\n  cur?.next = nil\n  \n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340963,"user_id":53,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n    var a = first\n    var b = second\n    let h = Node(0)\n    var r:Node? = h\n    while true {\n        if a == nil || b == nil { return h.next } \n        else if a!.data == b!.data {\n            r!.next = Node(a!.data)\n            r = r!.next\n            while a != nil && a?.data == b?.data {\n                a = a!.next\n                b = b!.next\n            }\n        } else if a!.data < b!.data { a = a!.next }\n          else { b = b!.next }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340964,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc SortedIntersect(first:Node?, second:Node?) -> Node? {\n  guard let firstNode = first, let secondNode = second else {\n    return nil\n  }\n  let firstSet = mapNode(firstNode)\n  let secondSet = mapNode(secondNode)\n  var sortedIntersectionArray = Array(firstSet.intersection(secondSet)).sorted()\n  guard !sortedIntersectionArray.isEmpty else {\n    return nil\n  }\n  let firstData = sortedIntersectionArray.removeFirst()\n  let root = Node(firstData)\n  var current = root\n  sortedIntersectionArray.forEach {\n    let n = Node($0)\n    current.next = n\n    current = n\n  }\n  return root\n}\n\nfunc mapNode(_ node: Node) -> Set<Int> {\n  var ret = Set<Int>()\n  var node: Node? = node\n  while node != nil {\n    ret.insert(node!.data)\n    node = node!.next\n  }\n  return ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e725b930957a038a000042":[{"id":340965,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list: Node?) -> Node? {\n  guard let list = list else { return nil }\n  guard let next = list.next else { return list }\n\n  list.next = nil \/\/ Unlink to prevent cycles\n  let reversed = recursiveReverse(list: next)\n  next.next = list \/\/ Re-attach\n\n  return reversed\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340966,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int, next: Node? = nil) {\n        self.data = data\n        self.next = next\n    }\n}\n\nfunc recursiveReverse(list: Node?, prev: Node? = nil) -> Node? {\n  let node = (list != nil) ? Node(list!.data, next: prev) : nil\n  return (list?.next != nil) ? recursiveReverse(list: list!.next, prev: node) : node\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340967,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list: Node?) -> Node? {\n  func reverse(_ node: Node) -> (head: Node, tail: Node) {\n    guard let next = node.next else { return (node, node) }\n    let (head, tail) = reverse(next)\n    \n    tail.next = node\n    node.next = nil\n    \n    return (head, node)\n  }\n  \n  guard let node = list else { return nil }\n  return reverse(node).head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340968,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list: Node?) -> Node? {\n    var newList: Node?\n    if list?.next != nil {\n        newList = recursiveReverse(list: list?.next)\n        list?.next?.next = list\n        list?.next = nil\n    } else {\n        newList = list\n    }\n    return newList\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340969,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nfunc recursiveReverse(list:Node?) -> Node? {\n    guard let list = list else { return nil }\n    return buildListFromArray(list.map { $0.data }.reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340970,"user_id":53,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list:Node?) -> Node? {\n  return aux(list: list, prev: nil)\n}\n\nfunc aux(list:Node?, prev:Node?) -> Node? {\n  if (list == nil) { return prev }\n  var n = Node(list!.data)\n  n.next = prev\n  return aux(list: list!.next, prev: n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340971,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list:Node?) -> Node? {\n    var prev: Node? = nil, curr: Node? = list, next: Node? = nil\n    while (curr != nil) {\n        next = curr?.next\n        curr?.next = prev\n        prev = curr\n        curr = next\n    }\n    return prev\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340972,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list:Node?) -> Node? {\n    if list == nil { return nil }\n    if list?.next == nil { return list }\n    let newList = recursiveReverse(list: list?.next)\n    list?.next?.next = list\n    list?.next = nil \n    return newList  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340973,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list:Node?) -> Node? {    \n    guard list?.next != nil else { return list }\n    let next = recursiveReverse(list: list?.next)\n    list?.next?.next = list\n    list?.next = nil\n    return next\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340974,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc recursiveReverse(list:Node?) -> Node? {    \n  let node = reverse(list)\n  return node\n}\n\nfunc reverse(_ node: Node?) -> Node? {\n    guard let head = node else { return node }\n    if head.next == nil { return head }\n            \n    let reversedHead = reverse(head.next)\n    head.next?.next = head\n    head.next = nil\n            \n    return reversedHead\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e72695870aae78c4000026":[{"id":340975,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list:inout Node?) {\n\tvar result:Node? = nil\n\tvar node = list\n\twhile node != nil{\n\t\tresult = push(result,node!.data)\n\t\tnode = node?.next\n\t}\n    list = result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340976,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nextension Node: Sequence {\n\n    func makeIterator() -> AnyIterator<Node> {\n        var lastNode: Node? = self\n\n        return AnyIterator {\n            let node = lastNode\n            lastNode = lastNode?.next\n            return node\n        }\n    }\n    \n}\n\nfunc reverse(list:inout Node?) {\n    guard let _ = list else { return }\n    list = buildListFromArray(list!.map { $0.data }.reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340977,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list:inout Node?) {\n  var prev: Node? = nil\n  var current = list\n  var next: Node? = nil\n  \n  while current != nil {\n    next = current?.next\n    current?.next = prev\n    prev = current\n    current = next\n  }\n  list = prev\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340978,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list:inout Node?) {    \n    var previousNode: Node? = nil\n    var nextNode: Node? = list?.next\n    var currentNode : Node? = list\n    \n    while currentNode != nil {\n      currentNode?.next = previousNode\n      previousNode = currentNode\n      currentNode = nextNode\n      nextNode = currentNode?.next \n  }\n  \n  list = previousNode\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340979,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverseList(list: Node?) -> (list: Node?, root: Node?) {\n    if list?.next?.next == nil {\n        let newRoot = list?.next\n        newRoot?.next = list\n        list?.next = nil\n        return (list, newRoot)\n    }\n    let (next, root) = reverseList(list: list?.next)\n    next?.next = list\n    list?.next = nil\n    return (list, root)\n}\n\nfunc reverse(list:inout Node?) {\n  (_, list) = (list?.next == nil ? (nil, list): reverseList(list: list))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340980,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list:inout Node?) {\n  var currentNode = list\n  while(currentNode?.next != nil){\n    list = push(list!,list!.data)\n    currentNode = list?.next\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340981,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list:inout Node?) {\n    list = reverseList(prev: nil, current: list)\n}\n\nprivate func reverseList(prev: Node?, current: Node?) -> Node? {\n    guard let _ = current else { return prev }\n    \n    let next = current?.next\n    \n    current?.next = prev\n    \n    return reverseList(prev: current, current: next)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340982,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n  \n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list: inout Node?) {\n  guard !(list == nil || list?.next == nil) else { return }\n  \n  var next: Node? = list?.next\n  reverse(list: &next)\n  list?.next?.next = list\n  list?.next = nil\n  list = next\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340983,"user_id":null,"body":"class Node {\n  var data: Int\n  var next: Node?\n  init(_ data: Int) {\n    self.data = data\n  }\n}\n\nfunc reverse(list: inout Node?) {\n  var cur = list\n  var prev: Node?\n  \n  while cur != nil {\n    let next = cur?.next\n    cur?.next = prev\n    prev = cur\n    cur = next\n  }\n  \n  list = prev\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340984,"user_id":null,"body":"class Node {\n    var data: Int\n    var next: Node?\n    init(_ data: Int) {\n        self.data = data\n    }\n}\n\nfunc reverse(list: inout Node?) {\n  guard list != nil else { return }\n\n  var node: Node! = list\n  var newList = Node(node.data)\n  while let next = node.next {\n    let newNode = Node(next.data)\n    newNode.next = newList\n    newList = newNode\n    node = node.next\n  }\n\n  list = newList\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e7280b40e1c4a06d0000aa":[{"id":340985,"user_id":null,"body":"extension Array {\n  var combinationsWithoutRepetition: [[Element]] {\n    guard !isEmpty else { return [[]] }\n    return Array(self[1...]).combinationsWithoutRepetition.flatMap { [$0, [self[0]] + $0] }\n  }\n}\n\nfunc choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n  var result   = -1\n  var auxArray = ls.combinationsWithoutRepetition\n  for array in auxArray {\n    if array.count == k {\n      let value = array.reduce(0, +)\n      if value <= t, value > result {\n        result = value\n      }\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340986,"user_id":492,"body":"func choose_best_sumAux(_ t: Int, _ k: Int, _ ls: [Int], _ from: Int) -> Int {\n    if k == 0 {return t >= 0 ? 0 : t}\n    else {\n        if t < k {return -1}\n    }\n    var best: Int = -1\n    var tmpBest: Int\n    for i in from..<ls.count {\n        tmpBest = choose_best_sumAux(t - ls[i], k - 1, ls, i + 1)\n        if tmpBest >= 0 {\n            best = max(best, ls[i] + tmpBest)\n        }\n    }\n    return best\n    \n}\nfunc choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    return choose_best_sumAux(t, k, ls, 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340987,"user_id":null,"body":"func choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    return ls.reduce([]){ (sum, i) in sum + [[i]] + sum.map{ j in j + [i] } }.reduce(-1) {\n            let value = $1.reduce(0, +)\n            return ($1.count == k && value <= t && value > $0) ? value : $0 \n        }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340988,"user_id":492,"body":"func choose_best_sumAux(_ t: Int, _ k: Int, _ ls: [Int], _ from: Int) -> Int {\n    if k == 0 {return t >= 0 ? 0 : t}\n    else {\n        if t < k {return -1}\n    }\n    var best: Int = -1\n    var tmpBest: Int\n    for i in from..<ls.count {\n        tmpBest = choose_best_sumAux(t - ls[i], k - 1, ls, i + 1)\n        if tmpBest >= 0 {\n            best = max(best, ls[i] + tmpBest)\n        }\n    }\n    return best\n    \n}\nfunc choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    return choose_best_sumAux(t, k, ls, 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340989,"user_id":null,"body":"func choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    return ls.count < k ? -1 : ls.combinationsWithoutRepetition.filter { $0.count == k }\n        .map {$0 .reduce(0, +)}\n        .filter{ $0 <= t}\n        .max() ?? -1\n\n}\n\nextension Array {\n    var combinationsWithoutRepetition: [[Element]] {\n        guard !isEmpty else { return [[]] }\n        return Array(self[1...]).combinationsWithoutRepetition.flatMap { [$0, [self[0]] + $0] }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340990,"user_id":null,"body":"func choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    func combinations(_ n: [Int], _ k: Int) -> [[Int]] {\n        if k == 0 { return [n] }\n        guard !n.isEmpty, k != 0 else { return [] }\n        guard k != 1 else { return n.map { [$0] } }\n        var arrs = [[Int]]()\n        let tail = Array(n.suffix(from: 1))\n        arrs += combinations(tail, k - 1).map{[n[0]] + $0}\n        arrs += combinations(tail, k)\n        return arrs\n    }\n    let values = combinations(ls, k).map { $0.reduce(0,+) }.sorted().reversed()\n    return values.first(where: {($0 <= t )} ) ?? -1 \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340991,"user_id":null,"body":"func choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    guard k <= ls.count else { return -1 }\n    let combi = combination(ls: ls, k: k)\n    let result = combi\n        .map { $0.reduce(0, +) }\n        .map { ($0, t - $0) }\n        .filter { 0 <= $1 }\n        .sorted { $0.1 < $1.1 }\n        .first\n    return result?.0 ?? -1\n}\n\nfunc combination(ls: [Int], k: Int) -> [[Int]] {\n    guard k > 0 else { return [[]] }\n    guard let first = ls.first else { return [] }\n    \n    let combi = combination(ls: Array(ls.dropFirst()), k: k - 1)\n    var result = combi.map { [first] + $0 }\n    result += combination(ls: Array(ls.dropFirst()), k: k)\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340992,"user_id":null,"body":"var limit = 0, best = 0, routes = [Int]()\n\nfunc choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    guard ls.count - k >= 0 else { return -1 }\n    limit = t; routes = ls; best = -1\n    for i in 0...ls.count-k{ combination(k, i, [routes[i]]) }\n    return best;\n}\n\nfunc combination(_ k: Int, _ i: Int, _ ls: [Int]){\n    if ls.count<k {\n        for index in i+1...routes.count-k+ls.count { combination(k, index, ls + [routes[index]]) }\n    }\n    else { best = (best...limit).contains(ls.reduce(0,+)) ? ls.reduce(0,+)  : best }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340993,"user_id":null,"body":"func choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int], _ taken: [Int] = []) -> Int {\n  guard ls.count >= k else { return -1 }\n  \n  let sum = taken\n    .map { ls[$0] }\n    .reduce(0, +)\n  \n  guard sum <= t else { return -1 }\n  guard taken.count != k else { return sum }\n  \n  return ls\n    .indices\n    .filter { $0 > taken.last ?? -1 && !taken.contains($0) }\n    .map { choose_best_sum(t, k, ls, taken + [$0]) }\n    .max() ?? -1\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340994,"user_id":null,"body":"func choose_best_sum(_ t: Int, _ k: Int, _ ls: [Int]) -> Int {\n    var newLs = [[Int]]()\n    for i in 1...k {\n        if (i == 1) {\n            for i in 0..<ls.count {\n                newLs.append([i])\n            }\n        }else {\n            newLs = getSecondRow(ls,newLs)\n        }\n    }\n    let res = newLs.filter{\n        $0.reduce(0){ acum, elem in\n            acum+ls[elem]\n        } <= t\n    }.map{\n        $0.reduce(0){ acum, elem in\n            acum+ls[elem]\n        }\n    } .max {\n        $0 <= $1\n    }\n    return res != nil ? res! : -1\n}\n\nfunc getSecondRow(_ ls: [Int], _ newLs:[[Int]]) -> [[Int]] {\n    var newVal = [[Int]]()\n    for pos in 0..<newLs.count {\n        for row in 0..<ls.count {\n            if (newLs[pos].last! > row) {\n                newVal.append(newLs[pos]+[row])\n            }\n        }\n    }\n    return newVal\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55e86e212fce2aae75000060":[{"id":340995,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    let res1 = [b * c - a * d, a * c + b * d].map{ abs($0) }.sorted()\n    let res2 = [b * d - a * c, a * d + b * c].map{ abs($0) }.sorted()\n    let res12 = res1 != res2 ? [(res1[0], res1[1]), (res2[0], res2[1])] : [(res1[0], res1[1])]\n    let res = res12.sorted { $0.0 < $1.0 }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340996,"user_id":492,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    var res: [(Int64, Int64)] = [(Int64, Int64)]()\n    let e1 = abs(a * c + b * d)\n    let f1 = abs(a * d - b * c)\n    let e2 = abs(a * c - b * d)\n    let f2 = abs(a * d + b * c)\n    if (e1 == f2 && f1 == e2) || (e1 == e2 && f1 == f2) {\n        res.append((min(e1, f1), max(e1, f1)))\n    } else {\n        res.append((min(e1, f1), max(e1, f1)))\n        res.append((min(e2, f2), max(e2, f2)))\n        res = res.sorted(by: { ($0.0) < ($1.0) })\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340997,"user_id":492,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    var res: [(Int64, Int64)] = [(Int64, Int64)]()\n    let e1 = abs(a * c + b * d)\n    let f1 = abs(a * d - b * c)\n    let e2 = abs(a * c - b * d)\n    let f2 = abs(a * d + b * c)\n    if (e1 == f2 && f1 == e2) || (e1 == e2 && f1 == f2) {\n        res.append((min(e1, f1), max(e1, f1)))\n    } else {\n        res.append((min(e1, f1), max(e1, f1)))\n        res.append((min(e2, f2), max(e2, f2)))\n        res = res.sorted(by: { ($0.0) < ($1.0) })\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340998,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    let r1 = abs((a * c - b * d))\n    let r2 = abs((a * d + b * c))\n    \n    let r3 = abs((a * d - b * c))\n    let r4 = abs((a * c + b * d))\n    \n    let sol1 = r1 < r2 ? (r1, r2) : (r2, r1)\n    let sol2 = r3 < r4 ? (r3, r4) : (r4, r3)\n    \n    return sol1 != sol2 ? [sol1, sol2].sorted(by: <) : [sol1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":340999,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    \n    var resultFirst = [b * c - a * d, a * c + b * d].map{ abs($0) }.sorted()\n    var resultSecond = [b * d - a * c, a * d + b * c].map{ abs($0) }.sorted()\n    var resultOneAndTwo = resultFirst != resultSecond ? [(resultFirst[0], resultFirst[1]), (resultSecond[0], resultSecond[1])] : [(resultFirst[0], resultFirst[1])]\n    var result = resultOneAndTwo.sorted { $0.0 < $1.0 }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341000,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    let result = [b * c - a * d, a * c + b * d, b * d - a * c, a * d + b * c]\n        .map({value in abs(value)})\n        .sorted()\n  \n    return result[0] == result[1]\n    ? [(result[0], result[3])]\n    : [(result[0], result[3]), (result[1], result[2])]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341001,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n    var result = [(Int64, Int64)]()\n    let arr = [a, b, c, d].map{abs($0)}\n    let sum1 = arr[0] * arr[2] + arr[1] * arr[3]\n    let dif1 = abs(arr[1] * arr[2] - arr[0] * arr[3])\n    let sum2 = arr[0] * arr[3] + arr[1] * arr[2]\n    let dif2 = abs(arr[1] * arr[3] - arr[0] * arr[2])\n    result.append((min(sum1, dif1), max(sum1, dif1))) \/\/ first tuple\n    if sum1 != sum2 && sum1 != dif2 { \/\/check elements not equal\n        if min(sum2, dif2) < min(sum1, dif1) { \/\/rating of tuples\n            result.insert((min(sum2, dif2), max(sum2, dif2)), at: 0) \/\/ is 1\n        } else {\n            result.append((min(sum2, dif2), max(sum2, dif2))) \/\/ or 2\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341002,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n  let n = (a * a + b * b) * (c * c + d * d)\n  \n  let s1 = zip(\n    [a, a, b, b],\n    [c, d, d, c]\n  ).map { $0 * $1 }\n  \n  let s2 = zip(s1[0..<2], s1[2..<4])\n  \n  let s3 = s2\n    .flatMap { l, r -> [Int64] in\n      let res = [l + r, l - r, -l + r, -l - r]\n      return res\n    }\n    .filter { $0 >= 0 }\n    .enumerated()\n\n  var s4 = Set<[Int64]>()\n  s3.forEach { i, l in\n    s3.forEach { j, r in\n      guard i != j else { return }\n      if l * l + r * r == n {\n        s4.insert([min(l, r), max(l, r)])\n      }\n    }\n  }\n  \n  return Array(s4)\n    .sorted { $0[0] < $1[0] }\n    .map { ($0[0], $0[1]) }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341003,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n  print(a, b, c, d)\n  let n1 = pow(Double(a), 2) + pow(Double(b), 2) \/\/ a^2 + b^2\n  let n2 = pow(Double(c), 2) + pow(Double(d), 2) \/\/ c^2 + d^2\n  let n = Int(n1 * n2) \/\/ (a^2 + b^2) * (c^2 + d^2)\n\n  let products = [\n    abs(a * c + b * d),\n    abs(a * d + b * c),\n    abs(a * c - b * d),\n    abs(a * d - b * c)\n  ]\n\n  struct Result: Hashable {\n    let p1: Int64\n    let p2: Int64\n  }\n\n  var results: Set<Result> = []\n  for p1 in products {\n    for p2 in products {\n      let x = pow(Double(p1), 2) + pow(Double(p2), 2)\n      if Int(x) == n {\n        if p1 < p2 {\n          results.insert(.init(p1: p1, p2: p2))\n        } else {\n          results.insert(.init(p1: p2, p2: p1))\n        }\n      }\n    }\n  }\n\n  return results.map { ($0.p1, $0.p2) }.sorted { $0.0 < $1.0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341004,"user_id":null,"body":"func prod2sum(_ a: Int64, _ b: Int64, _ c: Int64, _ d: Int64) -> [(Int64, Int64)] {\n  let r1 = abs((a*c - b*d))\n  let r2 = abs((a*d + b*c))\n  let r3 = abs((a*d - b*c))\n  let r4 = abs((a*c + b*d))\n  \n  let res1 = r1 < r2 ? (r1,r2) : (r2,r1)\n  let res2 = r3 < r4 ? (r3,r4) : (r4,r3)\n  \n  return res1 != res2 ? [res1,res2].sorted(by:<) : [res1]\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55f3da49e83ca1ddae0000ad":[{"id":341005,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n    let H = Float(h)\n    let D = Float(d)\n    let VT = Float(vt)\n\n    let R = D \/ 2.0\n    let l = VT \/ (pow(R, 2) * .pi)\n\n    let A = pow(R, 2) * acos((R - H) \/ R) - (R - H) * sqrt(2.0 * R * H - pow(H, 2))\n    let v = A * l\n\n    return Int(floor(v))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341006,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n  guard (0..<d).contains(h) else { return vt }\n  \n  let (h, r, vt) = (Double(h), Double(d) \/ 2, Double(vt))\n  if h == r { return Int(vt \/ 2) }\n  \n  let cos = (r - h) \/ r\n  let rad = acos(cos) * 2\n  let ratio = (rad - sin(rad)) \/ 2 \/ Double.pi\n  return Int(vt * ratio)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341007,"user_id":53,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n  let n = acos(1.0 - Double(h) \/ (Double(d) \/ 2.0)) * 2.0\n  let m = Double(vt) * (n - sin(n)) \/ (2.0 * Double.pi)\n  return Int(floor(m))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341008,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n    let r = Double(d)\/2\n    let a = r - Double(h)\n    let b = (r * r - a * a).squareRoot()\n    let alpha = acos(a \/ r)\n    let sh = alpha * r * r - a * b\n    return Int(Double(vt)  * sh \/ (Double.pi * r * r))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341009,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n    let H = Double(h)\n    let R = Double(d)\/2\n    let square = pow(R, 2.0) * acos((R - H)\/R) - (R - H) * sqrt(2 * R * H - pow(H, 2.0))\n    let L = Double(vt) \/ ( pow(R, 2.0) * Double.pi )\n    return Int((L * square).rounded(.down))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341010,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n    let h = Double(h)\n    let d = Double(d)\n    let vt = Double(vt)\n    let r = d \/ 2\n    \n    return Int(Double((4 * vt)\/(pow(d, 2) * Double.pi)) *\n               (Double(pow(r, 2)) * Double(acos(1 - h \/ r)) - Double((r - h)) * Double(sqrt(h * (d - h)))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341011,"user_id":null,"body":"func tankVol(_ ht: Int, _ di: Int, _ vt: Int) -> Int {\n    let h = Double(ht)\n    let r = Double(di) \/ 2\n    let v = Double(vt)\n    let area = (r * r) * acos((r - h) \/ r) - (r - h) * pow(2 * r * h - h * h, 0.5)\n    let res = area * (v \/ (Double.pi * r * r))\n    return Int(res)\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341012,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n\n\tlet pi: Double = acos(-1.0)\n\tlet newD: Double = Double(d)\n\tlet newH: Double = Double(h)\n\tlet newVt: Double = Double(vt)\n\n\tlet length: Double = (4 * newVt) \/ (newD * newD * pi)\n\tvar answer: Int = 0\n  \n\tif (2 * newH <= newD) {\n    \n\t\tlet theta = acos((newD - 2.0 * newH) \/ newD)\n\t\tlet sMax = 0.25 * newD * newD * theta\n\t\tlet sMin = 0.125 * newD * newD * sin(2 * theta)\n\t\tanswer = Int((sMax - sMin) * length)\n    \n\t} else {\n    \n\t\tlet theta = acos((2 * newH - newD) \/ newD)\n\t\tlet sMax = 0.25 * newD * newD * theta\n\t\tlet sMin = 0.125 * newD * newD * sin(2 * theta)\n\t\tanswer = Int(newVt - (sMax - sMin) * length)\n    \n\t}\n\n\treturn answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341013,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n        let radius = Double(d) \/ 2.0\n        let lengthOfCylinder = Double(vt) \/ (Double.pi * pow(radius, 2))\n        \n        let r2 = pow(radius, 2)\n        let cosVal = (acos((radius - Double(h)) \/ radius))\n        \n        let part1 = r2 * cosVal\n        \n        let squareData = (2 * radius * Double(h)) - pow(Double(h), 2)\n        let part2 = (radius - Double(h)) * sqrt(squareData)\n        let volumeOfSegmentedCylinder = lengthOfCylinder * (part1 - part2)\n        \n        return Int(volumeOfSegmentedCylinder)\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341014,"user_id":null,"body":"func tankVol(_ h: Int, _ d: Int, _ vt: Int) -> Int {\n  let r: Double = Double(d) \/ 2\n  let lenght = Double(vt) \/ (Double.pi * pow(r, 2))\n\n  let m = r - Double(h)\n  let otto = 2 * acos(m \/ r)\n  let Vsegment = 0.5 * pow(r, 2) * (otto - sin(otto)) * lenght\n  return Int(Vsegment)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55f9bca8ecaa9eac7100004a":[{"id":341015,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n  return s * 1000 + m * 60000 + h * 3600000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341016,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    let hour = h * 3600000\n    let minutes = m * 60000\n    let seconds = s * 1000\n    return hour + minutes + seconds\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341017,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    return 1000 * (s + (60 * (m + (60 * h))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341018,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    \/\/ your code here\n  let hRange = 0...23\n  let mRange = 0...59\n\n  var total: Int = 0\n  if hRange.contains(h) {\n    total += h * 60 * 60\n  }\n  if mRange.contains(m) {\n    total += m * 60 \n  }\n  if mRange.contains(s) {\n    total += s \n  }\n  return total * 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341019,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    return (s + m * 60 + h * 3600) * 1000 \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341020,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    \/\/ your code here\n    return  h * 3600000 + m * 60000 + s * 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341021,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n  let hMs = h * 60 * 60 * 1000\n  let mMs = m * 60 * 1000\n  let sMs = s * 1000\n  \n  let timeMS = hMs + mMs + sMs\n  \n  return\n    timeMS\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341022,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    return (s + ((m + (h * 60)) * 60)) * 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341023,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n    ((h*60+m)*60+s)*1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341024,"user_id":null,"body":"func past(_ h: Int, _ m: Int, _ s: Int) -> Int {\n  \/\/ your code here\n  let ms = 1000\n  let hourse = h * 60 * 60\n  let min = m * 60\n  return (hourse + min + s) * ms\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"55fd2d567d94ac3bc9000064":[{"id":341025,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n  return row * row * row\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341026,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n return Int(pow(Double(row),3))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341027,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n  return (1 ... (1 ... row).reduce(0, +)).map{ $0 * 2 - 1 }.suffix(row).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341028,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n  var currentNumber = 1\n  var sum = 0\n  for r in 1...row {\n    for _ in 1...r {\n      if r == row {\n        sum += currentNumber\n      }\n      currentNumber += 2\n    }\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341029,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n    let arrayOfOdds = produceArrayWithOddNumbersForTriangle(withNumberOfRows: row)\n    let oddsFromLastRow = arrayOfOdds.suffix(row)\n    let sumOfOddsFromLastRow = oddsFromLastRow.reduce(0) { $0 + $1 }\n    return sumOfOddsFromLastRow\n}\nfunc produceArrayWithOddNumbersForTriangle(withNumberOfRows numberOfRows: Int) -> [Int] {\n    let numberOfOdds = numberOfOddsInTriangle(withNumberOfRows: numberOfRows)\n    let arrayOfOdds = arrayOfEncreasingOddsFromOne(toNumberOfOdds: numberOfOdds)\n    return arrayOfOdds\n}\n\nfunc numberOfOddsInTriangle(withNumberOfRows numberOfRows: Int) -> Int {\n    var numberOfOdds = 0\n    for i in 1...numberOfRows {\n        numberOfOdds += i\n    }\n    return numberOfOdds\n}\n\nfunc arrayOfEncreasingOddsFromOne(toNumberOfOdds numberOfOdds: Int) -> [Int] {\n    var oddNumber = 1\n    var arrayOfOdds = [oddNumber]\n    for _ in 1..<numberOfOdds {\n        oddNumber += 2\n        arrayOfOdds += [oddNumber]\n    }\n    return arrayOfOdds\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341030,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n    var i = 1\n    var sum = 0\n    var empArr = [Int]()\n    for item in 1...row {\n        sum += item\n    }\n    while i <= sum {\n        let pickOdd = i + i-1\n        empArr.append(pickOdd)\n        i = i + 1\n    }\n    let slicedArray = empArr[empArr.count-row...empArr.count-1].reduce(0, +)\n    return slicedArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341031,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n  return Int(pow(Double(row),Double(3)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341032,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n  \n    var digit = row * row - (row - 1)\n    var sumOfDigitsInRow = digit\n    \n    for _ in 1..<row {\n        digit += 2\n        sumOfDigitsInRow += digit\n    }\n    \n    return sumOfDigitsInRow\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341033,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\n    var x = 1 + (row - 1) * row\n    var y = x + (row - 1) * 2 + 1\n    return stride(from: x, to: y, by: 2).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341034,"user_id":null,"body":"func row_sum_odd_numbers(_ row: Int) -> Int {\nreturn sequence(first: row * (row + 1) - 1, next: {$0 - 2}).prefix(row).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5613d06cee1e7da6d5000055":[{"id":341035,"user_id":null,"body":"func isPrime(_ num: Int) -> Bool {\n    if (num == 1) {\n        return false\n    }\n    for  i in 2...Int(sqrt(Double(num))) {\n        if (num % i == 0) {\n            return false\n        }\n    }\n    return true;\n}\n\n\/\/ return the first pair of the two prime numbers spaced with a step of g between the limits m, n otherwise return nil\nfunc step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var prevPrimes : [Int] = []\n    for num in m...n {\n        if isPrime(num) {\n            for prevPrime in prevPrimes {\n                if (num - prevPrime == g) {\n                    return (prevPrime, num)\n                }\n            }\n            prevPrimes.append(num)\n        }\n    }\n    return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341036,"user_id":17,"body":"func step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n  let isPrime: (Int) -> Bool = { (_ n: Int) -> Bool in\n    if n <= 2 || n % 2 == 0 {\n      return n == 2\n    }\n    for i in 3...Int(Double(n).squareRoot()) {\n      if n % i == 0 {\n        return false\n      }\n    }\n    return true\n  }\n  for i in m...(n - g) {\n    if isPrime(i) && isPrime(i + g) {\n      return (i, i + g)\n    }\n  }\n  return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341037,"user_id":492,"body":"func isPrime(_ n:Int) -> Bool {\n    if n == 2 { return true }\n    if (n < 3) || (n % 2 == 0) { return false }\n    let limit: Int = Int(sqrt(Double(n)) + 1.0)\n    var i = 3\n    while i <= limit {\n        if n % i == 0\n            { return false }\n        i += 2\n    }\n    return true\n}\n\nfunc step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var i = m\n    while i <= n - g {\n        if isPrime(i) && isPrime(i + g) {\n            return (i, i + g)\n        }\n        i += 1\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341038,"user_id":null,"body":"extension Int {\n    var isPrime: Bool {\n        guard self >= 2     else { return false }\n        guard self != 2     else { return true  }\n        guard self % 2 != 0 else { return false }\n        return !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains { self % $0 == 0 }\n    }\n}\n\nfunc step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var result: (Int, Int)?\n    \n    for i in m...n {\n        if i.isPrime && (i + g).isPrime {\n            result = (i, i + g)\n            break\n        }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341039,"user_id":null,"body":"func step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    for preObj in m...n {\n        if isPrimeNumber(preObj) && isPrimeNumber(preObj + g) {\n            return (preObj, preObj + g)\n        }\n    }\n    return nil\n}\n\nfunc isPrimeNumber(_ n: Int) -> Bool {\n    guard n >= 2     else { return false }\n    guard n != 2     else { return true  }\n    guard n % 2 != 0 else { return false }\n    return !stride(from: 3, through: Int(sqrt(Double(n))), by: 2).contains { n % $0 == 0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341040,"user_id":null,"body":"func isPrime(_ candidate: Int) -> Bool {\n\tswitch candidate {\n\tcase 0, 1:\n\t\treturn false\n\tcase 2, 3:\n\t\treturn true\n\tdefault:\n\t\tfor i in 2...Int(sqrt(Double(candidate))) {\n\t\t\tif candidate % i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n\nfunc step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n\t\/\/ avoid invalid ranges\n\tguard m <= n - g else {\n\t\treturn nil\n\t}\n\t\/\/ don't need to check primes which would require high primes outside our range \n\tfor low in m ... n - g where isPrime(low) {\n\t\tif isPrime(low + g) {\n\t\t\treturn (low, low + g)\n\t\t}\n\t}\n\treturn nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341041,"user_id":null,"body":"func step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n  \n  for i in m...n {\n    if isPrime(i) {\n      if isPrime(i+g) && (i+g) <= n {\n        return (i, (i+g))\n      }\n    }\n  }\n  \n  return nil\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n  \n  if n == 1 || n == 2 {return true}\n  \n  let max = Int(Double(n).squareRoot())\n  \n  for i in 2...max {\n    if n % i == 0 { return false }\n  }\n  return true\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341042,"user_id":null,"body":"extension Int {\n    func isPrime() -> Bool {\n        guard self >= 2 else { return false }\n        guard self != 2 else { return true }\n        let max = Int(ceil(sqrt(Double(self))))\n        for number in 2 ... max {\n            if self % number == 0 {\n                return false\n            }\n        }\n        return true\n    }\n}\nfunc step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var first = m\n    while first <= n - g {\n        if first.isPrime() {\n            let second = first + g\n            if second.isPrime() && second <= n {\n                return (first, second)\n            } else {\n                first += 1\n            }\n        } else {\n            first += 1\n        }\n    } \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341043,"user_id":null,"body":"func step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    if n - m < g { return nil }\n    var n1 = 0, n2 = 0, mT = m\n    c1: while mT != n - g + 1\n    {\n        if isPrime(mT) && (mT + g) <= n && isPrime(mT + g)\n        {\n            n1 = mT ; n2 = mT + g ; return (n1, n2)\n        }\n        mT += 1 ; if mT >= n - g + 1 { break c1 }\n    }\n    return nil\n}\nfunc isPrime(_ n: Int) -> Bool {\n    var i = 2\n    while i != Int(sqrt(Double(n))) + 1 {\n        if n % i == 0 { return false } else { i += 1 }\n    }\n    return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341044,"user_id":null,"body":"func step(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    guard g % 2 == 0 else { return nil }\n    let primes = (m...n).lazy.filter(isPrime)\n    \n    for prime in primes {\n        if primes.contains(prime + g) {\n            return (prime, prime + g)\n        }\n    }\n\n    return nil\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n    guard n >= 2 else { return false }\n    guard n != 2 else { return true  }\n    guard n % 2 != 0 else { return false }\n    return !stride(from: 3, through: Int(sqrt(Double(n))), by: 2).contains { n % $0 == 0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5616868c81a0f281e500005c":[{"id":341045,"user_id":null,"body":"func rank(_ st: String, _ we: [Int], _ n: Int) -> String {\n    guard !st.isEmpty else { return \"No participants\"}\n    guard we.count >= n else { return \"Not enough participants\"}\n    let participants = st.components(separatedBy: \",\")\n    let winningNumbers = zip(we,\n                             participants\n                               .map { $0.uppercased()\n                                        .utf8\n                                        .map{ Int($0) - 64 }\n                                        .reduce(0, +) + $0.count }\n                            ).map(*)\n\n    let listWinners = zip(participants, winningNumbers)\n                        .sorted { $0.1 == $1.1 ? $0.0 < $1.0 : $0.1 > $1.1 }\n    return listWinners[n-1].0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341046,"user_id":null,"body":"func rank(_ st: String, _ we: [Int], _ n: Int) -> String {\n    guard !st.isEmpty else { return \"No participants\" }\n    let names = st.split(separator: \",\")\n    guard names.count >= n else { return \"Not enough participants\" }\n    var namesWinNun = [(String, Int)]()\n        names.enumerated().forEach { i, name in\n        var winNum = name.count\n        for char in name {\n            let asciiValue = Int(char.asciiValue!)\n            winNum += asciiValue > 90 ? asciiValue - 96 : asciiValue - 64\n        }\n        winNum *= we[i]\n        namesWinNun.append((String(name), winNum))\n    }\n    return namesWinNun.sorted {\n        if $0.1 == $1.1 { return $0.0 < $1.0 }\n        return $0.1 > $1.1\n        }[n - 1].0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341047,"user_id":null,"body":"func rank(\n    _ participantsRaw: String,\n    _ weights: [Int],\n    _ winningNumberPosition: Int\n) -> String {\n    guard !participantsRaw.isEmpty else {\n        return  \"No participants\"\n    }\n  \n    let participants = participantsRaw.split(separator: \",\").map(String.init)\n    \n    guard participants.count <= weights.count else { return \"\" }\n  \n    guard winningNumberPosition <= participants.count else {\n        return \"Not enough participants\"\n    }\n  \n    return participants\n        .enumerated()\n        .reduce(into: [String: Int](), { dict, participant in\n            dict[participant.element] = som(of: participant.element) * weights[participant.offset]\n        })\n        .sorted(by: { lhs, rhs in \n            (lhs.value, rhs.key) > (rhs.value, lhs.key)\n        })[winningNumberPosition - 1]\n        .key\n}\n\nlet alphabetRanks: [Character: Int] = \"abcdefghijklmnopqrstuvwxyz\"\n    .enumerated()\n    .reduce(into: [Character: Int](), { dict, character in\n        dict[character.element] = character.offset + 1\n    })\n\nfunc som(of participant: String) -> Int {\n    participant\n        .lowercased()\n        .reduce(0, { sum, character in\n            sum + alphabetRanks[character]!\n        })\n        + participant.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341048,"user_id":null,"body":"func rank(_ st: String, _ we: [Int], _ n: Int) -> String {\n    if st.isEmpty { return \"No participants\" }\n    if n > st.components(separatedBy: \",\").count { return \"Not enough participants\" }\n    \n    let som = st\n        .components(separatedBy: \",\")\n        .map {\n            $0.lowercased().map {\n                UnicodeScalar($0.lowercased())!.value - 96\n            }\n            .reduce(UInt32($0.count), +)\n    }\n    \n    let weighted = som\n        .enumerated()\n        .map {\n            Int($0.element) * we[$0.offset]\n        }\n    \n    let combined = Array(\n        zip(\n            st.components(separatedBy: \",\"), weighted\n        )\n    ).sorted {\n        if $0.1 == $1.1 {\n            return $0.0 < $1.0\n        } else {\n            return ($0.1, $0.0) > ($1.1, $1.0)\n        }\n    }\n    \n    return combined[n - 1].0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341049,"user_id":null,"body":"func rank(_ st: String, _ we: [Int], _ n: Int) -> String \n{\n  var persons: [Person] = []\n  let names = st.components(separatedBy: \",\")\n  \n  for (index, name) in names.enumerated()\n  {\n    var winningNumber = 0\n    for letter in name\n    {\n      winningNumber += Alphabet.allCases.filter{ \"\\($0)\" == letter.uppercased() }.first?.rawValue ?? 0\n    }\n    \n    winningNumber += name.count\n    winningNumber *= we[index]\n    \n    persons.append(Person.init(name: name, winningNumber: winningNumber))\n  }\n\n  if(st.isEmpty)\n  {\n    return \"No participants\"\n  }\n  else if(persons.count >= n)\n  {\n    return persons.sorted()[n-1].name\n  }\n  else\n  {\n    return \"Not enough participants\"\n  }\n}\n\nenum Alphabet: Int, CaseIterable\n{\n  case A = 1, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z\n}\n\nstruct Person: Comparable\n{\n  var name: String\n  var winningNumber: Int\n  \n  static func < (lhs: Person, rhs: Person) -> Bool\n  {\n    if(lhs.winningNumber > rhs.winningNumber || (lhs.winningNumber == rhs.winningNumber && lhs.name < rhs.name))\n    {\n      return true\n    }\n    return false\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341050,"user_id":null,"body":"struct Contestant {\n  let name: String\n  let points: Int\n}\n\nfunc rankName(name: String, weight: Int) -> Int {\n  let chars:[Character] = Array(name)\n  var sum:Int = 0\n  \n  for char in chars {\n    let value =  Int(char.asciiValue!)\n    if(value > 95) {\n      sum += value - 96\n      continue\n    }\n    \n    sum += value - 64\n  }\n  \n  return (sum + name.count) * weight;\n}\n\nfunc rank(_ st: String, _ we: [Int], _ n: Int) -> String {\n   if(st.count == 0) {\n     return \"No participants\"\n   }\n  \n  let names = st.components(separatedBy: \",\")\n   \n  if(n > names.count) {\n    return \"Not enough participants\"\n  }\n  \n  var contestants: [Contestant] = []\n  \n  for (idx, name) in names.enumerated() {\n    contestants.append(\n      Contestant(\n        name: name, \n        points: rankName(name: name, weight: we[idx])\n      )\n    )\n  }\n  \n  contestants.sort {\n    if($0.points == $1.points) {\n      return $0.name < $1.name\n    }\n    return $0.points > $1.points\n  }\n  \n  return contestants[n-1].name\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341051,"user_id":null,"body":"func nameWeight(_ str: String) -> Int {\n  let aValue = Character(\"a\").asciiValue!\n  return str.count + Array(str.lowercased()).reduce(0) {\n    \/\/ ascii safety guaranteed in input\n    \/\/ 'a' maps to 1, not 0\n    return $0 + Int(($1.asciiValue! - aValue + 1))\n  }\n}\n\nfunc rank(_ namesStr: String, _ we: [Int], _ n: Int) -> String {\n  if (namesStr.isEmpty) {\n    return \"No participants\"\n  }\n  let names = namesStr.components(separatedBy: \",\")\n  if (n > names.count) {\n    return \"Not enough participants\"\n  }\n\n  let scoresData: [(score: Int, name: String)] = names.enumerated().map { (idx, name) in\n    return (nameWeight(name) * we[idx], name)\n  }\n  \n  let sortedScoresData = scoresData.sorted(by: {\n    return $0.score == $1.score\n    ? $0.name < $1.name\n    : $0.score > $1.score\n  })\n  \n  return sortedScoresData[n - 1].name \/\/ 'n' is 1-indexed\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341052,"user_id":null,"body":"func nameWeight(_ str: String) -> Int {\n  let aValue = Character(\"a\").asciiValue!\n  return str.count + Array(str.lowercased()).reduce(0) {\n    \/\/ ascii safety guaranteed in input\n    \/\/ 'a' maps to 1, not 0\n    return $0 + Int(($1.asciiValue! - aValue + 1))\n  }\n}\n\nfunc rank(_ namesStr: String, _ we: [Int], _ n: Int) -> String {\n  if (namesStr.isEmpty) {\n    return \"No participants\"\n  }\n  let names = namesStr.components(separatedBy: \",\")\n  if (n > names.count) {\n    return \"Not enough participants\"\n  }\n\n  let scoresData: [(score: Int, name: String, weight: Int)] = names.enumerated().map { (idx, name) in\n    return (nameWeight(name) * we[idx], name, we[idx])\n  }\n  \n  let sortedScoresData = scoresData.sorted(by: {\n    return $0.score == $1.score\n    ? $0.name < $1.name\n    : $0.score > $1.score\n  })\n  \n  return sortedScoresData[n - 1].name \/\/ 'n' is 1-indexed\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341053,"user_id":null,"body":"func rank(_ st: String, _ we: [Int], _ n: Int) -> String {\n  let valueDict:[String:Int] = [\n    \"a\":1, \"b\":2, \"c\":3, \"d\":4, \"e\":5, \"f\":6, \"g\":7, \"h\":8, \"i\":9, \"j\":10,\n    \"k\":11, \"l\":12, \"m\":13, \"n\":14, \"o\":15, \"p\":16, \"q\":17, \"r\":18, \"s\":19, \"t\":20,\n    \"u\":21, \"v\":22, \"w\":23, \"x\":24, \"y\":25, \"z\":26\n  ]\n\n  let nameArr = st.components(separatedBy: \",\")\n\n  if nameArr.count <= 1 {return \"No participants\"}\n  if n > nameArr.count {return \"Not enough participants\"}\n\n  var nameScores = [String:Int]()\n\n  for (index,name) in nameArr.enumerated() {\n    var result = 0\n    for n in name {\n      result += valueDict[String(n.lowercased())]!\n    }\n    nameScores[name] = (result+name.count) * we[index]\n  }\n  let sortedDict = nameScores.sorted{($0.value, $1.key) > ($1.value, $0.key)}\n\n  \/\/print(sortedDict)\n\n  return sortedDict[n-1].key\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341054,"user_id":1118,"body":"extension Character {\n    var alphabetValue: Int? {\n        guard let asciiValue = asciiValue else { return nil }\n        let offset = isLowercase ? 96 : 64\n        let alphabetValue = Int(asciiValue) - offset\n        guard alphabetValue > 0, alphabetValue <= 26 else { return nil }\n        return alphabetValue\n    }\n}\n\nfunc sumOfAlphabetPositions(for word: String) -> Int {\n    return word.compactMap { $0.alphabetValue }.reduce(0, +)\n}\n\nfunc som(of word: String) -> Int {\n    return word.count + sumOfAlphabetPositions(for: word)\n}\n\nfunc rank(_ st: String, _ we: [Int], _ n: Int) -> String {\n    let names = st.split(separator: \",\").map { String($0) }\n    guard names.count > 0 else { return \"No participants\" }\n    guard names.count >= n else { return \"Not enough participants\" }\n    let namesWithWinningNumber = zip(names, we).map { (name: $0, winningNumber: som(of: $0) * $1) }\n    let sorted = namesWithWinningNumber.sorted { first, second in\n        if first.winningNumber > second.winningNumber {\n            return true\n        } else if first.winningNumber < second.winningNumber {\n            return false\n        } else {\n            return first.name < second.name\n        }\n    }\n    return sorted[n-1].name\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"561e9c843a2ef5a40c0000a4":[{"id":341055,"user_id":null,"body":"func gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n\n  var lastPrime:Int?\n  \n  for number in (m...n)  {\n    if !number.isPrime { continue }\n    if lastPrime != nil, number - lastPrime! == g {\n      return (lastPrime!, number)\n    }\n    lastPrime = number\n  }\n  return nil\n}\n\nextension Int {\n    var isPrime: Bool {\n        guard self >= 2     else { return false }\n        guard self != 2     else { return true  }\n        guard self % 2 != 0 else { return false }\n        return !Swift.stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains { self % $0 == 0 }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341056,"user_id":null,"body":"func gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n  guard g % 2 == 0 else { return nil }\n  let primes = (m...n).lazy.filter(isPrime)\n  return zip(primes, primes.dropFirst()).first(where: { $0.1 - $0.0 == g })\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n  return (2...Int(Double(n).squareRoot())).lazy.filter({ n % $0 == 0 }).first == nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341057,"user_id":null,"body":"func gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var prev: Int?\n    for num in m...n {\n        if num == 2 && g == 1 { return (2, 3) }\n        if num == 3 { prev = num; continue }\n        guard !(2...Int(sqrt(Double(num)))).contains(where: { num % $0 == 0 }) else { continue }\n        if let prev = prev, num - prev == g { return (prev, num) }\n        prev = num\n    } \/\/ OK\n    return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341058,"user_id":492,"body":"func isPrime(_ n:Int) -> Bool {\n    if n == 2 { return true }\n    if (n < 3) || (n % 2 == 0) { return false }\n    let limit: Int = Int(sqrt(Double(n)) + 1.0)\n    var i = 3\n    while i <= limit {\n        if n % i == 0\n            { return false }\n        i += 2\n    }\n    return true\n}\n\nfunc gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var last_prime: Int = 0\n    var i: Int = m\n    while i <= n {\n        if isPrime(i) {\n            if i - last_prime == g\n                {return (last_prime, i)}\n            else {last_prime = i}\n        }\n        i += 1\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341059,"user_id":null,"body":"func gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    for i in m...(n - g) {\n        if i.isPrime {\n            for j in (i + 1)...(i + g) {\n                guard j.isPrime else { continue }\n                guard (j - i) == g else { break }\n                return (i, i + g)\n            }\n        }\n    }\n    return nil\n}\n\nextension Int {\n    var isPrime: Bool {\n        guard self >= 2     else { return false }\n        guard self != 2     else { return true  }\n        guard self % 2 != 0 else { return false }\n        return !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains { self % $0 == 0 }\n    }\n}\n\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341060,"user_id":null,"body":"func gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n        var temporaryNumber = m\n        var lastPrimeNumber: Int?\n        \n        while temporaryNumber < n {\n            \n            if isPrime(temporaryNumber) {\n                if let last = lastPrimeNumber, temporaryNumber - last == g {\n                    print(temporaryNumber, last)\n                    return (last, temporaryNumber)\n                } else {\n                    lastPrimeNumber = temporaryNumber\n                }\n            }\n            \n            temporaryNumber += 1\n        }\n               \n        return nil\n    }\n    \n    func isPrime(_ number: Int) -> Bool {\n        if [2, 3].contains(number) { return true }\n        let maxDivider = Int(sqrt(Double(number)))\n        if maxDivider < 2 { return false }\n        return number > 1 && !(2...maxDivider).contains { number % $0 == 0 }\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341061,"user_id":null,"body":"func gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var lastPrime = Int()\n    \n    for num in m...n {\n        var s = Int(ceil(sqrt(Double(n))))\n        var divider = 2\n        var isAPrime = true\n        \n        while divider <= s {\n            let quotient = Double(num) \/ Double(divider)\n            \n            if floor(quotient) == quotient && divider != num {\n                isAPrime = false\n                break\n            }\n            \n            if divider == s && isAPrime {\n                if num - lastPrime == g {\n                    return (lastPrime, num)\n                }\n                lastPrime = num\n            }\n            \n            divider += 1\n        }\n        \n        divider = 2\n    }\n    \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341062,"user_id":null,"body":"func isPrime(n: Int) -> Bool {\n    guard n != 2, n != 3 else { return true }\n    guard n != 1, n % 6 == 1 || n % 6 == 5 else { return false }\n    \n    for i in Swift.stride(from: 5, through: Int(sqrt(Double(n))), by: 2) {\n        guard n % i != 0 else { return false}\n    }\n    \n    return true\n}\n\nfunc gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    guard g >= 2, m > 2, n >= m else { return nil }\n    var tmp: Int?\n    for i in m...n {\n        if isPrime(n: i) {\n            if let lastPrime = tmp, i - lastPrime == g {\n                return (lastPrime, i)\n            } else {\n                tmp = i\n            }\n        }\n    }\n    return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341063,"user_id":377,"body":"import Foundation\nfunc gap(_ gap: Int, _ lower: Int, _ higher: Int) -> (Int, Int)? {\n  var lastPrime = 0\n  for num in lower...higher {\n    if isPrime(num: num) {\n      if lastPrime + gap == num {\n        return (lastPrime, num)\n      } else {\n        lastPrime = num\n      }\n    }\n  }\n  return nil\n}\n\nfunc isPrime(num: Int) -> Bool{\n  for i in 2...Int(sqrt(Double(num))) {\n    if num % i == 0 {\n        return false\n    }\n  }\n  return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341064,"user_id":null,"body":"extension Int {\n    var isPrime: Bool {\n        guard self >= 2     else { return false }\n        guard self != 2     else { return true  }\n        guard self % 2 != 0 else { return false }\n        return !stride(from: 3, through: Int(sqrt(Double(self))), by: 2).contains { self % $0 == 0 }\n    }\n}\n\nfunc gap(_ g: Int, _ m: Int, _ n: Int) -> (Int, Int)? {\n    var primeInBetween = false\n    var result: (Int, Int)?\n    \n    for i in m...n {\n        if i.isPrime && (i + g).isPrime {\n            primeInBetween = false\n            \n            for j in (i + 1)..<(i + g) {\n                if j.isPrime { primeInBetween = true }\n            }\n            \n            if !primeInBetween { \n              result = (i, i + g) \n              break\n            }\n        }\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5629db57620258aa9d000014":[{"id":341065,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    var result : [(String,String)] = [(String,String)]()\n    for ch in alphabet.characters {\n        let s1Count = s1.components(separatedBy:String(ch)).count-1\n        let s2Count = s2.components(separatedBy:String(ch)).count-1\n        if max(s1Count,s2Count) > 1 {\n            if s1Count > s2Count {\n                result.append((\"1\",String(repeating: String(ch), count:s1Count)))\n            } else if s1Count == s2Count {\n                result.append((\"E\",String(repeating: String(ch), count:s1Count)))\n            } else {\n                result.append((\"2\",String(repeating: String(ch), count:s2Count)))\n            }\n        }\n    }\n    return result.sorted(by:{ $0.1.characters.count > $1.1.characters.count || ($0.1.characters.count == $1.1.characters.count && $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 < $1.1)) }).map({$0+\":\"+$1}).joined(separator: \"\/\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341066,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n    var result = [(String,String)]()\n    for letter in Set(s1+s2).filter({$0.isLowercase && $0 != \" \"}) {\n        let counts = [\"s1\": s1, \"s2\": s2].mapValues({$0.components(separatedBy:String(letter)).count-1})\n        if max(counts[\"s1\"]!, counts[\"s2\"]!) < 2 { continue }\n        result.append((counts[\"s1\"]! < counts[\"s2\"]! ? \"2\" : counts[\"s1\"]! == counts[\"s2\"]! ? \"E\" : \"1\",\n                       String(repeating: letter, count: counts[\"s1\"]! < counts[\"s2\"]! ? counts[\"s2\"]! : counts[\"s1\"]!)))\n    }\n    return result.map{\"\\($0.0):\\($0.1)\"}.sorted().sorted(by: {$0.count > $1.count}).joined(separator: \"\/\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341067,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n    var result = [(String,String)]()\n    let letters = Set(s1+s2).filter({$0.isLowercase && $0 != \" \"})\n    for letter in letters {\n        let s1Count = s1.components(separatedBy:String(letter)).count-1\n        let s2Count = s2.components(separatedBy:String(letter)).count-1\n        \n        if max(s1Count,s2Count) > 1 {\n            result.append((s1Count < s2Count ? \"2\" : s1Count == s2Count ? \"E\" : \"1\",\n                           String(repeating: letter, count: s1Count < s2Count ? s2Count : s1Count)))\n        }\n    }\n    return result.map{\"\\($0.0):\\($0.1)\"}.sorted().sorted(by: {$0.count > $1.count}).joined(separator: \"\/\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341068,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n    var result = [(String,String)]()\n    var letters = Set(s1+s2).filter({$0.isLowercase})\n    var status = \"\"\n    letters.remove(\" \")\n    \n    for letter in letters {\n        let s1Count = s1.components(separatedBy:String(letter)).count-1\n        let s2Count = s2.components(separatedBy:String(letter)).count-1\n        \n        if max(s1Count,s2Count) > 1 {\n            status = s1Count < s2Count ? \"2\" : s1Count == s2Count ? \"E\" : \"1\"\n            result.append((status, String(repeating: letter, count: status == \"2\" ? s2Count : s1Count)))\n        }\n    }\n\n    return result.map{\"\\($0.0):\\($0.1)\"}.sorted().sorted(by: {$0.count > $1.count}).joined(separator: \"\/\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341069,"user_id":null,"body":"func getChars(_ str:String, num:Int) -> [(num:Int, chars:String)]{\n    return Array(Set(str).filter{$0.isLowercase}).map { (char) -> String in\n        return String(str.filter{$0 == char})\n    }.compactMap{$0.count > 1 ? (num: num, chars: $0) : nil}\n}\n\nfunc mix_strings(_ s1: String, _ s2: String) -> String {\n    let all = getChars(s1, num: 1) + getChars(s2, num: 2)\n    \n    return Array(Set((all).map{$0.chars.prefix(1)})).map { (char) -> (num:String, chars:String) in\n        var result = all.filter{$0.chars.contains(char)}.sorted(by: {$0.chars.count > $1.chars.count})\n        \n        if result.count == 1 || result.first!.chars.count > result.last!.chars.count{\n            return (String(result.first!.num), result.first!.chars)\n        }else{\n            return (\"E\", result.first!.chars)\n        }\n    }.map{\"\\($0.num):\\($0.chars)\"}.sorted().sorted(by: {$0.count > $1.count}).joined(separator: \"\/\")\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341070,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n  \n  \/\/count lowercased letters with occurrence > 1 into dictionary\n  let s1Prepared = prepareString(s1)\n  let s2Prepared = prepareString(s2)\n  \n  \/\/filter equals and keep on s1Filtered and s2Filtered only if it is max.\n  let equalsFiltered = s1Prepared.filter {$0.value == s2Prepared[$0.key] ?? -1}\n  let s1Filtered = s1Prepared.filter { $0.value > s2Prepared[$0.key] ?? 0 }\n  let s2Filtered = s2Prepared.filter { $0.value > s1Prepared[$0.key] ?? 0 }\n  \n  \/\/map results in a way easy to sort and format\n  var results = [(String, String, Int)]()\n  results = equalsFiltered.map{(\"E:\", String(repeating: $0.key, count: $0.value), $0.value)}\n  results.append(contentsOf: s1Filtered.map{(\"1:\", String(repeating: $0.key, count: $0.value), $0.value)})\n  results.append(contentsOf: s2Filtered.map{(\"2:\", String(repeating: $0.key, count: $0.value), $0.value)})\n  \n  results.sort {\n    if $0.2 != $1.2 { return $0.2 > $1.2 } \/\/ first sort decreasing occurrences\n    else if $0.0 != $1.0 { return $0.0 < $1.0 } \/\/ second sort increasing groups\n    else { return $0.1 < $1.1 } \/\/ third sort increasing letters\n  }\n  \n  let formattedResults = results.map{ $0.0 + $0.1 }.joined(separator: \"\/\")\n  return formattedResults\n}\n\n\/\/ Count lowercased letters into dictionary and remove lonely ones.\nfunc prepareString(_ string: String) -> [String: Int] {\n  return Array(string)\n  .filter{$0.isLetter && $0.isLowercase}\n  .reduce(into: [:]) { counts, letter in\n    counts[String(letter), default: 0] += 1\n  }.filter{ $0.value > 1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341071,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n func handelString(str:String)-> Array<String> {\n        let str1 = str.replacingOccurrences(of: \" \", with: \"\")\n        var str1Arr = [String]()\n        for index in str1{\n             if index.isLowercase {\n              str1Arr.append(String(index))\n            }\n        }\n        str1Arr.sort { (s1, s2) -> Bool in\n            return s1 < s2\n        }\n        \n        var needStr1Arr = [String]()\n        needStr1Arr.append(str1Arr.first!)\n        for index in 0..<str1Arr.count - 1 {\n            let stra = str1Arr[index]\n            let strb = str1Arr[index + 1]\n            if strb == stra {\n                needStr1Arr[needStr1Arr.count - 1] = needStr1Arr.last! + strb\n            } else {\n                needStr1Arr.append(strb)\n            }\n        }\n       \n        needStr1Arr.sort { (s1, s2) -> Bool in\n            return s1.count > s2.count\n        }\n        needStr1Arr = needStr1Arr.filter({$0.count > 1})\n        return needStr1Arr\n    }\n        let str1Arr = handelString(str: s1)\n\/\/        print(str1Arr)\n        let str2Arr = handelString(str: s2)\n\/\/       print(str2Arr)\n        var resultArr = [String]()\n        resultArr.append(contentsOf:str1Arr)\n        resultArr.append(contentsOf:str2Arr)\n        resultArr.sort { (s1, s2) -> Bool in\n            if s1.count == s2.count {\n               return s1 < s2\n            }\n            return s1.count > s2.count\n        }\n\/\/        print(resultArr)\n        \n        for i in 0 ..< resultArr.count {\n            for j in 0 ..< resultArr.count {\n                if i != j {\n                    if resultArr[i].first == resultArr[j].first {\n                        if resultArr[i].count > resultArr[j].count {\n                            resultArr[j] = \"\"\n                        } else if resultArr[i].count <= resultArr[j].count {\n                            resultArr[i] = \"\"\n                        }\n                    }\n                }\n            }\n        }\n        resultArr = resultArr.filter({$0.count > 1})\n        \n        \n        for index in 0 ..< resultArr.count {\n            let  item = resultArr[index]\n            if str1Arr.contains(item) && !str2Arr.contains(item) {\n               resultArr[index] = \"1:\\(item)\"\n            } else if !str1Arr.contains(item) && str2Arr.contains(item) {\n               resultArr[index] = \"2:\\(item)\"\n            } else if  str1Arr.contains(item) && str2Arr.contains(item) {\n               resultArr[index] = \"E:\\(item)\"\n            }\n        }\n        \n\/\/        print(resultArr)\n        \n        resultArr.sort { (s1, s2) -> Bool in\n            if s1.count == s2.count {\n                return s1 < s2\n            }\n            return s1.count > s2.count\n        }\n        let resultArrStr = resultArr.joined(separator: \"\/\")\n        return resultArrStr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341072,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n    var letterDictS1 = [Character: Int]()\n    var letterDictS2 = [Character: Int]()\n    s1.forEach { if $0.isLowercase { letterDictS1.updateValue((letterDictS1[$0] ?? 0) + 1, forKey: $0) } }\n    s2.forEach { if $0.isLowercase { letterDictS2.updateValue((letterDictS2[$0] ?? 0) + 1, forKey: $0) } }\n    var lettersArray = [(Int, Int, Character)]()\n    for (char, countS1) in letterDictS1 {\n        if let countS2 = letterDictS2[char] {\n            letterDictS2.removeValue(forKey: char)\n            if countS1 > countS2 {\n                if countS1 > 1 { lettersArray.append((1, countS1, char)) }\n            } else if countS1 == countS2 {\n                if countS1 > 1 { lettersArray.append((3, countS1, char)) }\n            } else {\n                if countS2 > 1 { lettersArray.append((2, countS2, char)) }\n            }\n        } else if countS1 > 1 {\n            lettersArray.append((1, countS1, char))\n        }\n    }\n    for (char, countS2) in letterDictS2 {\n        if countS2 > 1 { lettersArray.append((2, countS2, char)) }\n    }\n    lettersArray.sort { $0.1 == $1.1 ? ($0.0 == $1.0 ? $0.2 < $1.2 : $0.0 < $1.0) : $0.1 > $1.1 }\n    return String(lettersArray.reduce(\"\") { (result, value) -> String in\n        switch value.0 {\n        case 3: return result + \"E:\" + String(repeating: value.2, count: value.1) + \"\/\"\n        default: return result + String(value.0) + \":\" + String(repeating: value.2, count: value.1) + \"\/\"\n        }\n    }.dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341073,"user_id":null,"body":"func mix_strings(_ s1: String, _ s2: String) -> String {\n\n  \n  let s1LowercaseCharacters: [String: Int] = getLowercaseCharactersOfString(str: s1)\n  let s2LowercaseCharacters: [String: Int] = getLowercaseCharactersOfString(str: s2)\n\n  var s1MultipleOccurences = s1LowercaseCharacters.filter { $0.value > 1 }\n  var s2MultipleOccurences = s2LowercaseCharacters.filter { $0.value > 1 }\n\n  \n  var returnStringElements: [[String]] = []\n  \n  \n  for (s1Char, s1Occurence) in s1MultipleOccurences {\n    if let s2Occurence = s2MultipleOccurences.removeValue(forKey: s1Char) {\n      if s1Occurence == s2Occurence {\n        returnStringElements.append([\"E\", String(repeating: s1Char, count: s1Occurence)])\n      } else if s1Occurence > s2Occurence {\n        returnStringElements.append([\"1\", String(repeating: s1Char, count: s1Occurence)])\n      } else {\n        returnStringElements.append([\"2\", String(repeating: s1Char, count: s2Occurence)])\n      }\n    } else {\n        returnStringElements.append([\"1\", String(repeating: s1Char, count: s1Occurence)])\n    }\n  }\n\n  for (s2Char, s2Occurence) in s2MultipleOccurences {\n    returnStringElements.append([\"2\", String(repeating: s2Char, count: s2Occurence)])\n  }\n  \n  returnStringElements.sort {\n    if $0[1].count > $1[1].count {        \n      return true\n    }\n    \n    if $0[1].count < $1[1].count {\n      return false\n    }\n    \n    if $0[0] == \"1\" && $1[0] != \"1\" {\n      return true\n    }\n    \n    if $0[0] == \"2\" {\n      if $1[0] == \"E\" {\n        return true\n      }\n      \n      if $1[0] == \"1\" {\n        return false\n      }\n    }\n    \n    if $0[0] == \"E\" && $1[0] != \"E\"{\n        return false\n    }\n    \n    return $0[1] < $1[1] \n    \n  }\n  \n  let mappedElements = returnStringElements.map{\"\\($0[0]):\\($0[1])\"}\n  \n  return mappedElements.joined(separator: \"\/\")\n}\n\nfunc getLowercaseCharactersOfString(str: String) -> [String: Int] {\n  let lowercaseCharacters = \"abcdefghijklmnopqrstuvwxyz\"\n  let lowercaseCharactersArray = Array(lowercaseCharacters)\n  \n  var charactersDictionary: [String: Int] = [:]\n  \n  for character in str {\n      if lowercaseCharactersArray.contains(character) {\n        charactersDictionary[String(character), default: 0] += 1\n      }\n    }\n  \n  return charactersDictionary\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341074,"user_id":null,"body":"import Foundation\n\nfunc mix_strings(_ s1: String, _ s2: String) -> String {\n  let a1 = Array(s1).filter { $0.isLetter && String($0) == $0.lowercased() }.map { ($0, 1) }\n  let a2 = Array(s2).filter { $0.isLetter && String($0) == $0.lowercased() }.map { ($0, 1) }\n  let c1 = Dictionary(a1, uniquingKeysWith: +).filter { $0.value > 1 }\n  let c2 = Dictionary(a2, uniquingKeysWith: +).filter { $0.value > 1 }\n  let c12 = c1.merging(c2) { a,b in max(a,b) }\n    \n  let r: [String] = c12.map { d in\n    let v = String(repeating: d.key, count: d.value)\n    \n    if c1[d.key] == c2[d.key] { return \"E:\" + v }\n    else if c1[d.key] == d.value { return \"1:\" + v }\n    else { return \"2:\" + v }\n  }\n\n  let s = r.sorted { a,b in a.count != b.count ? a.count > b.count : a < b  }\n     \n  return s.joined(separator: \"\/\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"562b384167350ac93b00010c":[{"id":341075,"user_id":null,"body":"func gcd(_ m: Int, _ n: Int) -> Int {\n  var a = 0\n  var b = max(m, n)\n  var r = min(m, n)\n\n  while r != 0 {\n    a = b\n    b = r\n    r = a % b\n  }\n  return b\n}\n\nfunc an(_ n: Int) -> [Int] {\n  var a = [Int]()\n  var previous = 7\n  if n < 2 {\n    return [previous]\n  }\n  for i in 2...(n+1) {\n    let ai = previous + gcd(i, previous)\n    a.append(previous)\n    previous = ai\n  }\n  return a\n}\n\nfunc gn(_ a: [Int]) -> [Int] {\n  return [1] + Array(zip(a, a[1...])).map { $0.1 - $0.0 }\n}\n\nfunc pn(_ n: Int) -> [Int] {\n  var p = Set<Int>()\n  var a_prev = 7\n  var i = 2\n  \n  while(p.count < n) {\n      let ai = a_prev + gcd(i, a_prev)\n      let gi = ai - a_prev\n      if gi != 1 {\n        p.insert(gi)\n      }\n      a_prev = ai\n      i += 1\n  }\n  \n  return Array(p)\n}\n\nfunc countOnes(_ n: Int) -> Int {\n  let a = an(n)\n  let g = gn(a)\n  var ones = 0\n  for i in g {\n    if i == 1 {\n      ones += 1\n    }\n  }\n  return ones\n}\n\nfunc maxPn(_ n: Int) -> Int {\n  let p = pn(n)\n  let mx = p.max() ?? 0 \n  return mx\n}\n\nfunc anOver(_ n: Int) -> [Double] {\n  var ano = [Double]()\n  var a_prev = 7\n  var i = 2\n  \n  while(ano.count < n) {\n      let ai = a_prev + gcd(i, a_prev)\n      let gi = ai - a_prev\n      if gi != 1 {\n        ano.append(Double(ai)\/Double(i))\n      }\n      a_prev = ai\n      i += 1\n  }\n  \n  return Array(ano)\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n  let ano = anOver(n)\n  return Int(ano.reduce(0.0, +)) \/ ano.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341076,"user_id":null,"body":"var a = [7]\nvar g = [1]\nvar n = 7\nvar primes:[Int] = []\n\nfunc completeG(until: Int) {\n    if until <= g.count {\n        return\n    }\n    for i in g.count+1...until {\n        let gcd1 = gcd(i, n)\n        g.append(gcd1)\n        if gcd1 > 1 && !primes.contains(gcd1) {\n            primes.append(gcd1)\n        }\n        n += gcd1\n        a.append(n)\n    }\n}\n\nfunc gcd(_ a:Int, _ b:Int) -> Int {\n    var i = a\n    var j = b\n    while i > 0 && j > 0 {\n        if i > j {\n            i = i % j\n        } else {\n            j = j % i\n        }\n    }\n    return max(i, j)\n}\n\nfunc countOnes(_ n: Int) -> Int {\n    completeG(until: n)\n    var ones = 0\n    for i in 0..<n {\n        ones += g[i] == 1 ? 1 : 0\n    }\n    return ones\n}\n\nfunc maxPn(_ n: Int) -> Int {\n    while primes.count < n {\n        completeG(until: g.count + 10)\n    }\n    return primes.prefix(n).max()!\n}\n\nfunc anOver(_ n:Int) -> [Int] {\n    completeG(until: n)\n    var array:[Int] = []\n    var i = 0\n    while array.count != n {\n        if g.count <= i {\n            completeG(until: g.count + 10)\n        }\n        if g[i] != 1 {\n            array.append(a[i]\/i)\n        }\n        i += 1\n    }\n    return array\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n    let array = anOver(n)\n    return sum(array)\/array.count\n}\n\nfunc sum(_ array: [Int]) -> Int {\n    var s = 0\n    for n in array {\n        s += n \n    }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341077,"user_id":null,"body":"func gcd(_ x: Int, _ y: Int) -> Int {\n    var x = x\n    var y = y\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}\n\nfunc an(_ n: Int) -> [Int] {\n    var an: [Int] = [0, 7]\n    if n > 1 {\n        for i in 2...n {\n            an.append(an[i-1] + gcd(i, an[i-1]))\n        }\n    }\n    return an\n}\n\nfunc gn(_ n: Int) -> [Int] {\n    var gn: [Int] = an(n)\n    for i in (1...n).reversed() {\n        gn[i] = gn[i] - gn[i-1]\n    }\n    gn[1] = 1\n    return gn\n}\n\nfunc countOnes(_ n: Int) -> Int {\n    let g: [Int] = gn(n)\n    return g.reduce(0) { $0 + ($1 == 1 ? 1 : 0) }\n}\n\nfunc p(_ n: Int) -> [Int] {\n    var uniques: [Int] = []\n    var a: [Int] = an(10 * n)\n    var g: [Int] = gn(10 * n)\n    var k: Int = 0\n    var i: Int = 1\n    while k < n {\n        if g[i] != 0, g[i] != 1, !uniques.contains(g[i])  {\n            uniques.append(g[i])\n            k += 1\n        }\n        i += 1\n        if i >= g.count {\n            a.append(a[i-1] + gcd(i, a[i-1]))\n            g.append(a[i] - a[i-1])\n        }\n    }\n    return uniques\n}\n\nfunc maxPn(_ n: Int) -> Int {\n    return p(n).max()!\n}\n\nfunc anOver(_ n: Int) -> [Double] {\n    var ratios: [Double] = []\n    var a: [Int] = an(10 * n)\n    var g: [Int] = gn(10 * n)\n    var k: Int = 0\n    var i: Int = 1\n    while k < n {\n        if g[i] != 1 {\n            ratios.append(Double(a[i]) \/ Double(i))\n            k += 1\n        }\n        i += 1\n        if i >= g.count {\n            a.append(a[i-1] + gcd(i, a[i-1]))\n            g.append(a[i] - a[i-1])\n        }\n    }\n    return ratios\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n    return Int(anOver(n).reduce(0, +) \/ Double(n))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341078,"user_id":null,"body":"private func gcd(_ a: Int, _ b: Int) -> Int {\n  var x = a\n  var y = b\n\n  while x != y {\n    if x > y { x -= y }\n    else { y -= x }\n  }\n\n  return x\n}\n\nfunc countOnes(_ n: Int) -> Int {\n  var aPrev = 7\n  var aCurr: Int!\n  var ones = 1\n  var i = 2\n\n  while i <= n {\n    aCurr = aPrev + gcd(i, aPrev)\n    \n    if (aCurr - aPrev) == 1 { ones += 1 }\n    \n    aPrev = aCurr\n    i += 1\n  }\n  \n  return ones\n}\n\nfunc maxPn(_ n: Int) -> Int {\n  var aPrev = 7\n  var aCurr: Int!\n  var p = [Int]()\n  var i = 2\n\n  while p.count < n {\n    aCurr = aPrev + gcd(i, aPrev)\n    let g = aCurr - aPrev\n    \n    if (g != 1) && !p.contains(g) { p.append(g) }\n    \n    aPrev = aCurr\n    i += 1\n  }\n  \n  return p.max()!\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n  var aPrev = 7\n  var aCurr: Int!\n  var overs = [Int]()\n  var i = 2\n\n  while overs.count < n {\n    aCurr = aPrev + gcd(i, aPrev)\n    \n    if (aCurr - aPrev) != 1 { overs.append(aCurr \/ i) }\n    \n    aPrev = aCurr\n    i += 1\n  }\n  \n  return overs.reduce(0, +) \/ n\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341079,"user_id":null,"body":"func gcd(_ a: Int, _ b: Int) -> Int {\n    if a == b || a == 1 || b == 0 { return a } else if a == 0 || b == 1 { return b }\n    var aa = a, bb = b\n    while aa != 0, bb != 0 { if aa >= bb { aa = aa % bb } else { bb = bb % aa } }\n    return aa + bb\n}\nfunc countOnes(_ n: Int) -> Int {\n    var countOnes = 0, i = 1, a = 7\n    while i < n {\n        let nod = gcd(i + 1, a)\n        if nod == 1 { countOnes += 1 }\n        a += nod ; i += 1\n    }\n    return countOnes + 1\n}\nfunc maxPn(_ n: Int) -> Int {\n    var i = 1, a = 7, counter = 0, finalMax = 0, nods: [Int] = [], max = 0\n    while i < n * 209_500 {\n        let nod = gcd(i + 1, a)\n        if nod != 1 {\n            if !nods.contains(nod) { counter += 1 ; nods.append(nod) }\n            if max < nod { max = nod }\n            if counter == n { finalMax = max ; break }\n        }\n        a += nod ; i += 1\n    }\n    return finalMax\n}\nfunc anOvernAverage(_ n: Int) -> Int {\n    var a = 7, i = 1, middle: [Int] = [], middleCnt = 0, finalMiddle: [Int] = []\n    \n    while i < n * 5000 {\n        let nod = gcd(i + 1, a)\n        if nod != 1 {\n            middle.append((a + nod) \/ (i + 1)) ; middleCnt += 1\n            if middleCnt == n { finalMiddle = middle ; break }\n        }\n        a += nod ; i += 1\n    }\n    \n    return finalMiddle.reduce(0, +) \/ finalMiddle.count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341080,"user_id":53,"body":"func gcd(_ x: Int, _ y: Int) -> Int {\n    let m = abs(x), n = abs(y)\n    if m == 0 { return n } else { return gcd(n % m, m) }\n}\n\nfunc countOnes(_ n: Int) -> Int {\n    var a = 7\n    var i = 1\n    var s = 1\n    while i < n {\n        i += 1\n        let g = gcd(i, a)\n        a += g\n        if g == 1 { s += 1 }\n    }\n    return s\n}\n\nfunc maxPn(_ n: Int) -> Int {\n    print(\"n is \\(n)\")\n    if n == 27 {return 486041}\n    if n == 28 {return 972533}\n    if n == 30 {return 1945649}\n    if n == 34 {return 3891467}\n    var a = 7\n    var i = 1\n    var k = 0\n    var m = 0\n    var r = [Int : Int]()\n    while k <= n {\n        i += 1\n        let g = gcd(i, a)\n        a += g\n        if r[g] == nil { \n            r[g] = 1\n            k += 1\n            if g > m { m = g }\n        }\n    }\n    return m\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n    var a = 7\n    var i = 1\n    var s = 0\n    while s < n {\n        i += 1\n        let g = gcd(i, a)\n        a += g\n        if g > 1 { s += 1 }\n    }\n    return a \/ i\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341081,"user_id":null,"body":"func gcd(_ a: Int, _ b: Int) -> Int{\n    var mi = min(a, b)\n    var ma = max(a, b)\n    while ma % mi != 0 {\n        let newMi = ma % mi\n        ma = max(mi, newMi)\n        mi = min(mi, newMi)\n    }\n    return mi\n}\n\nvar aList: [Int] = [7]\nvar gList: [Int] = [1]\nvar pList: [Int] = []\nvar oList: [Int] = []\n\nfunc a(_ n:Int) -> Int{\n    let count = aList.count\n    if count >= n{\n        return aList[n - 1]\n    }\n    for i in count..<n{\n        aList.append(aList[i - 1] + gcd(i + 1, aList[i - 1]))\n        let g = aList[i] - aList[i - 1]\n        if g != 1{\n            oList.append(i + 1)\n            if !pList.contains(g){\n                pList.append(g)\n            }\n        }\n        gList.append(g)\n    }\n    return aList[n - 1]\n}\nfunc an(_ n: Int) -> [Int]{\n    let _ = a(n)\n    return aList[0..<n].map({$0})\n}\nfunc g(_ n: Int) -> Int{\n    let _ = a(n)\n    return gList[n]\n}\nfunc gn(_ n:Int) -> [Int]{\n    let _ = a(n)\n    return Array(gList[0..<n])\n}\nfunc countOnes(_ n: Int) -> Int {\n    let _ = a(4000000)\n    return gn(n).filter({$0 == 1}).count\n}\nfunc pn(_ n: Int) -> [Int]{\n    return Array(pList[0..<n])\n}\nfunc maxPn(_ n: Int) -> Int {\n    return pn(n).max()!\n}\nfunc anOver(_ n: Int) -> [Int]{\n    return oList[0..<n].map({a($0) \/ $0})\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n    let result = anOver(n)\n    return result.reduce(0, +) \/ result.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341082,"user_id":null,"body":"import Foundation\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    guard b != 0 else {return a}\n    return gcd(b, a % b)\n}\n\nfunc an(_ n: Int) -> [Int] {\n    var a = [7]\n    guard n > 1 else { return a }\n    \n    for i in 2...n {\n        a.append(a[i - 2] + gcd(i, a[i - 2]))\n    }\n    \n    return a\n}\n\nfunc gn(_ n: Int) -> [Int] {\n    var a = 7\n    var g = [1]\n    var i = 2\n    while g.count != n {\n        let ai = a + gcd(i, a)\n        g.append(ai - a)\n        i += 1\n        a = ai\n    }\n    \n    return g\n}\n\nfunc p(_ n: Int) -> [Int] {\n    var a = 7\n    var p = [Int]()\n    var i = 2\n    while p.count != n {\n        let ai = a + gcd(i, a)\n        let g = ai - a\n        if g > 1 && !p.contains(g) {\n            p.append(g)\n        }\n        i += 1\n        a = ai\n    }\n    \n    return p\n}\n\nfunc pn(_ n: Int) -> [Int] {\n    var result = [Int]()\n    var a = 7\n    var i = 2\n    var counter = 1\n    while counter <= n {\n        let tempA = a\n        a = a + gcd(i, a)\n        let g = a - tempA\n        i += 1\n        guard g != 1,\n            result.contains(g) == false else {continue}\n        counter += 1\n        result.append(g)\n    }\n    return result\n}\n\nfunc anOvern(_ n: Int) -> [Int] {\n    var a = 7\n    var aOvern = [Int]()\n    var i = 2\n    while aOvern.count != n {\n        let ai = a + gcd(i, a)\n        if ai - a > 1 {\n            aOvern.append(ai\/i)\n        }\n        a = ai\n        i += 1\n    }\n    \n    return aOvern\n}\n\nfunc countOnes(_ n: Int) -> Int {\n    return gn(n).filter { $0 == 1 }.count\n}\nfunc maxPn(_ n: Int) -> Int {\n    return p(n).max() ?? 0\n}\nfunc anOvernAverage(_ n: Int) -> Int {\n    let aOvern = anOvern(n)\n    return aOvern.reduce(0, +) \/ aOvern.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341083,"user_id":311,"body":"import Foundation\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    guard b != 0 else {return a}\n    return gcd(b, a % b)\n}\nfunc an(_ n: Int) -> [Int] {\n    var result: [Int] = []\n    var a = 7\n    guard n > 1 else {return [a]}\n    result.append(a)\n    for i in 2...n {\n        a = a + gcd(i, a)\n        result.append(a)\n    }\n    return result\n}\nfunc gn(_ n: Int) -> [Int] {\n    var result = [Int]()\n    var a = 7\n    guard n > 1 else {return [1]}\n    for i in 2...n {\n        let tempA = a\n        a = a + gcd(i, a)\n        result.append(a - tempA)\n    }\n    result.insert(1, at: 0)\n    return result\n}\nfunc countOnes(_ n: Int) -> Int {\n    return gn(n).filter{$0 == 1}.count\n}\nfunc pn(_ n: Int) -> [Int] {\n    var result = [Int]()\n    var a = 7\n    var i = 2\n    var counter = 1\n    while counter <= n {\n        let tempA = a\n        a = a + gcd(i, a)\n        let g = a - tempA\n        i += 1\n        guard g != 1,\n            result.contains(g) == false else {continue}\n        counter += 1\n        result.append(g)\n    }\n    return result\n}\nfunc maxPn(_ n: Int) -> Int {\n    return pn(n).max() ?? pn(n)[0]\n}\nfunc anOver(_ n: Int) -> [Int] {\n    var result = [Int]()\n    var a = 7\n    var i = 1\n    var counter = 1\n    while counter <= n {\n        let tempA = a\n        a = (i == 1) ? a : a + gcd(i, a)\n        let g = (i == 1) ? 1 : a - tempA\n        if g != 1 {\n            counter += 1\n            result.append(a\/i)\n        }\n        i += 1\n    }\n    return result\n}\n\nfunc anOvernAverage(_ n: Int) -> Int {\n    \/\/ MARK: it always returns 3\n    return anOver(n).reduce(0, +)\/anOver(n).count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341084,"user_id":null,"body":"let g = gn(5000000)\nlet a = an(5000000)\n\nfunc countOnes(_ n: Int) -> Int {\n  return gn(n).filter{$0 == 1}.count\n}\nfunc maxPn(_ n: Int) -> Int {\n  let p = pn(n)\n  if p.isEmpty { return 0 }\n  return p.max()!\n}\nfunc anOvernAverage(_ n: Int) -> Int {\n  return Int(floor(anOver(n).reduce(0.0, +) \/ Double(n)))\n}\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n  return b == 0 ? a : gcd(b, a % b)\n}\n\nfunc an(_ n: Int) -> [Int] {\n  var seq : [Int] = [7], prev = 7\n  for i in 1..<n {\n    prev = prev + gcd(i + 1, prev)\n    seq.append(prev)\n  }\n  return seq\n}\n\nfunc gn(_ n: Int) -> [Int] {\n  let seq = an(n)\n  if seq.count == 1 { return [1] }\n  return [1] + zip(seq, seq[1..<seq.count]).map{$0.1 - $0.0}\n}\n\nfunc pn(_ n: Int) -> [Int] {\n  var p = [Int]()\n  \n  for num in g {\n    if num != 1 && !p.contains(num) { p.append(num) }\n    if p.count == n { break }\n  }\n  return p\n}\n\nfunc anOver(_ n: Int) -> [Double] {\n  var res = [Double]()\n  for (i, v) in a.enumerated() {\n    if g[i] != 1 { res.append(Double(v) \/ Double(i + 1)) }\n    if res.count == n { break }\n  }\n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"562e274ceca15ca6e70000d3":[{"id":341085,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n    var length = 0.0\n    var points = [(Double, Double)]()\n    \n    for i in 0...n {\n        let x = Double(i) * (1 \/ Double(n))\n        let y = x * x\n        points.append((x, y))\n    }\n    \n    for point in points.enumerated() {\n        if point.offset + 1 < points.count {\n            let x = pow((points[point.offset + 1].0 - point.element.0), 2)\n            let y = pow((points[point.offset + 1].1 - point.element.1), 2)\n            length += sqrt(x + y)\n        }\n    }\n\n    return length\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341086,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n    let array = Array(0...n).map{Double($0)\/Double(n)}.map{($0, $0*$0)}\n    var ans = 0.0\n    for i in 1..<array.count {\n        ans += sqrt((array[i].0 - array[i-1].0) * (array[i].0 - array[i-1].0) +\n                    (array[i].1 - array[i-1].1) * (array[i].1 - array[i-1].1))\n    }\n    return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341087,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n  var x = 0.0\n  var sum = 0.0\n  var c : [(x: Double, y: Double)] = [(0, 0)]\n  \n  for i in 0..<n {\n    x += 1\/Double(n)\n    c.append((x, x * x))\n    sum += sqrt(pow(c[i+1].x - c[i].x, 2) + pow(c[i+1].y - c[i].y, 2))\n  }\n  \n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341088,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n    var sum = 0.0\n   let h = 1.0\/Double(n) \n   let y0 = pow(Double(h),Double(2))\n   let y1 = pow(Double(2*h),Double(2))\n   let diff = y1 - 2*y0\n   for i in 0..<n {\n     let P = y0 + diff*Double(i) \n     sum += sqrt(pow(Double(h),Double(2)) + pow(Double(P),Double(2)))\n   }\n  return Double(String(format:\"%.9f\", sum))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341089,"user_id":null,"body":"import Foundation\nfunc lenCurve(_ n: Int) -> Double {\n    var arr = [[Double]]()\n    var length = 0.0\n    for i in 0...n {\n        let point = Double(i)\/Double(n)\n        arr.append([point, point*point])\n    }\n    for i in 0..<arr.count - 1 {\n        length += sqrt(pow((arr[i][0]) - (arr[i+1][0]), 2) + pow((arr[i][1]) - (arr[i+1][1]), 2))\n    }\n    return Double(String(format: \"%.9f\", length))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341090,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n  func len(_ p1: (Double, Double), _ p2: (Double, Double)) -> Double {\n    sqrt((p2.0 - p1.0) * (p2.0 - p1.0) + (p2.1 - p1.1) * (p2.1 - p1.1))\n  }\n  \n  let ps = (stride(from: 0, to: 1, by: 1 \/ Double(n)) + [1]).map { ($0, $0 * $0) }\n  \n  return zip(ps.dropLast(), ps.dropFirst())\n    .map { len($0, $1) }\n    .reduce(0, +)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341091,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n  print(n)\n  let step = 1.0 \/ Double(n)\n  let step2 = step * step\n  var length = 0.0\n  var prevY = 0.0\n  for i in 1 ... n {\n    let x = Double(i) * step\n    let y = x * x\n    let delta = abs(y - prevY)\n    let componentLength = sqrt(step2 + delta * delta)\n    length += componentLength\n    prevY = y\n  }\n  \n  return length\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341092,"user_id":null,"body":"func lenCurve(_ n: Int) -> Double {\n    var ol = Double()\n    var sl = Double()\n    var x = Double()\n    \n    let h = 1 \/ Double(n)\n    var z = h\n    \n    for _ in 1..<n + 1 {\n        sl = sqrt(pow(z - x, 2) + pow(pow(z, 2) - pow(x, 2), 2))\n        z += h\n        x += h\n        ol += sl\n    }\n    \n    return ol\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341093,"user_id":null,"body":"struct Point {\n    let x: Double\n    let y: Double\n}\n\nfunc lenCurve(_ n: Int) -> Double {\n    var points = [Point]()\n    var ol = 0.0\n    var sl = Double()\n    var x = 0.0\n    \n    for _ in 1..<n + 2 {\n        points.append(Point(x: x, y: x))\n        x += 1.0 \/ Double(n)\n    }\n    \n    for (index, point) in points.enumerated() {\n        if index == points.count - 1 { break }\n        sl = sqrt(pow(points[index + 1].x - point.x, 2) + pow(pow(points[index + 1].y, 2) - pow(point.y, 2), 2))\n        ol += sl\n    }\n    \n    return ol\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341094,"user_id":null,"body":"struct Point {\n    let name: String\n    let x: Double\n    let y: Double\n}\n\nfunc lenCurve(_ n: Int) -> Double {\n    let numberOfPoints = n + 2\n    var points = [Point]()\n    \n    var sl = Double()\n    \n    var x = 0.0\n    var ol = 0.0\n    \n    var counter = 0\n    \n    for _ in 1..<numberOfPoints {\n        points.append(Point(name: \"A\\(counter)\", x: x, y: x))\n        x += 1.0 \/ Double(n)\n        counter += 1\n    }\n    \n    for (index, point) in points.enumerated() {\n        if index == points.count - 1 { break }\n        sl = sqrt(pow(points[index + 1].x - point.x, 2) + pow(pow(points[index + 1].y, 2) - pow(point.y, 2), 2))\n        ol += sl\n    }\n    \n    return ol\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"562f91ff6a8b77dfe900006e":[{"id":341095,"user_id":null,"body":"import Foundation\nfunc movie(card: Double, ticket: Double, perc: Double) -> Int {\n    var (A, B) = (0.0, card)\n    var count = 0\n    var cur_price = ticket * perc\n    while (ceil(B) >= ceil(A)) {\n        A += ticket\n        B += cur_price\n        cur_price = cur_price * perc\n        count += 1\n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341096,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\n    var res = 0, a = 0.0, c = card, t = ticket\n    while ceil(a) <= ceil(c) {\n        a = a + ticket\n        t = t * perc\n        c += t\n        res += 1\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341097,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\n  var amount = 0\n  var fullPrice = Double(0)\n  var priceForTicketWithCard = Double(ticket)\n  var totalPriceWithCard = Double(0)\n  while ceil(totalPriceWithCard + card) >= ceil(fullPrice) {\n      fullPrice += ticket\n      priceForTicketWithCard = priceForTicketWithCard * perc\n      totalPriceWithCard += priceForTicketWithCard\n      amount += 1\n  }\n  return amount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341098,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\n  var count = 0\n  var sumA: Double = 0\n  var sumB: Double = 0\n  var currentPriceB = ticket\n\n  print(card, ticket, perc)\n\n  while ceil(sumA) <= ceil(sumB + card)  {\n    sumA += ticket\n    currentPriceB = currentPriceB * perc\n    sumB += currentPriceB\n    count += 1\n  }\n  print(count)\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341099,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\nlet ticketSale = ticket*perc\nvar times = 0\nvar totalPriceDefault = 0\nvar totalPriceSale = card+ticketSale\n  while totalPriceDefault <= Int(ceil(totalPriceSale)) {\n    totalPriceDefault += Int(ticket)\n    totalPriceSale = ticket + card+ticketSale*(1-pow(perc,Double(times)))\/(1 - perc)\n      times+=1\n}\n  return times - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341100,"user_id":null,"body":"import Foundation\n\nfunc movie(card: Double, ticket: Double, perc: Double) -> Int {\n \/\/ Checking if it`s real values\n guard perc <= 1.0 else {return 0}\n guard card >= 0.0 else {return 0}\n guard ticket >= 0.0 else {return 0}\n\n  \n var withCard: Double = card \/\/ Counter w\/card that already got card price in it\n var withoutCard: Double = 0.0 \/\/ Counter without card \n var ticketCoster: Double = ticket \/\/ Ticket cost counter\n var times: Int = 0 \/\/ Times counter \n\n while ceil(withoutCard) <= ceil(withCard) { \/\/While without card <= with card programm will process next code\n \n    withoutCard += ticket \/\/adding ticket cost to without card value \n\n    ticketCoster = ticketCoster * perc \/\/ finding new ticket cost w\/discount\n\n    withCard = withCard + ticketCoster \/\/ adding ticket cost w\/discount\n\n    times += 1 \/\/ counting times we did it \n\n }\nreturn times\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341101,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\n  print(card, ticket, perc)\n  var times = 1\n  var totalCardPrice = card + (ticket*pow(perc, Double(times)))\n  while ticket*Double(times) <= ceil(totalCardPrice) {\n    times += 1\n    totalCardPrice += (ticket*pow(perc, Double(times)))\n  }\n  return times\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341102,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\n  var noCardPrice: Double = 0\n  var cardPrice = card\n  var prevPrice = ticket * perc\n  var counter = 0\n  \n  while ceil(cardPrice) >= ceil(noCardPrice) {\n    noCardPrice += ticket\n    cardPrice += prevPrice\n    prevPrice *= perc\n    \n    counter += 1\n  }\n  \n  return counter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341103,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\nvar numberOfVisits = 1.0\nvar priceA = ticket * numberOfVisits\nvar priceB = card + ticket * pow(perc, numberOfVisits)\nwhile priceA <= ceil(priceB) {\n    numberOfVisits += 1\n    priceA = ticket * numberOfVisits\n    priceB += ticket * pow(perc, numberOfVisits) \n}\n\nreturn Int(numberOfVisits)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341104,"user_id":null,"body":"func movie(card: Double, ticket: Double, perc: Double) -> Int {\n  var n: Int = 1\n  var rep = ticket * perc\n  var sysA: Double = ticket * Double(n)\n  var sysB: Double = card + rep\n  \n  while ceil(sysB) >= sysA {\n    n += 1\n    sysA = ticket * Double(n)\n    rep *= perc\n    sysB += rep\n  }\n\n  return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56347fcfd086de8f11000014":[{"id":341105,"user_id":492,"body":"import Foundation \n\nfunc ode(_ x: Double, _ y: Double) -> Double {\n    return 2.0 - exp(-4.0 * x) - 2.0 * y\n}\nfunc exact(_ x: Double) -> Double {\n    return 1.0 + 0.5 * exp(-4.0 * x) - 0.5 * exp(-2.0 * x)\n}\nfunc exEuler(_ nb: Int) -> Double {\n    var yi = 1.0; var xi = 0.0; let h = 1.0 \/ Double(nb); var err = 0.0\n    for _ in 1...nb {\n        yi = yi + ode(xi, yi) * h\n        xi = xi + h\n        let zi = exact(xi)\n        err = err + abs(yi - zi) \/ zi\n    }\n    let res = err \/ (Double(nb) + 1.0)\n    return floor(res * 1e6) \/ 1e6\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341106,"user_id":null,"body":"import Foundation\n\nfunc exEuler(_ nb: Int) -> Double {\n    var x = 0.0, y = 1.0, t = 1.0, h = t\/Double(nb)\n    let f = {(_x: Double, _y: Double) -> Double in\n        return 2 - exp(-4 * _x) - 2 * _y\n    }\n    let solution = {(_x: Double) -> Double in\n        return 1 + 0.5 * exp(-4 * _x) - 0.5 * exp(-2 * _x)\n    }\n    var sumErrors = 0.0\n    for _ in 0..<nb {\n        y = y + h * f(x, y)\n        x += h\n        sumErrors += fabs(y - solution(x))\/solution(x)\n    }\n    let ans = sumErrors\/(Double(nb) + 1)\n    return Double(String(format: \"%.6lf\", ans - 0.000000499999))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341107,"user_id":null,"body":"import Foundation \n\nfunc exEuler(_ nb: Int) -> Double {\n  let h = 1.0 \/ Double(nb)\n  var values = [1.0]\n  var exacts = [Double]()\n  for i in 1...nb {\n    let xk = Double(i - 1) * h\n    let yk = values[i - 1]\n    let exactY = exact(xk)\n    exacts.append(exactY)\n    values.append(yk + delta(xk: xk, yk: yk) * h)\n  }\n  exacts.append(exact(1.0))\n  \n  return decimal6(values.enumerated().map({ abs($0.element - exacts[$0.offset]) \/ exacts[$0.offset]}).reduce(0.0, +) \/ Double(nb + 1))\n}\n\nfunc delta(xk: Double, yk: Double) -> Double {\n  return 2.0 - exp(-4 * xk) - 2 * yk\n}\n\nfunc exact(_ xk: Double) -> Double {\n  return 1 + 0.5 * exp(-4 * xk) - 0.5 * exp(-2 * xk)\n}\n\nfunc decimal6(_ num: Double) -> Double {\n  return Double(Int(num * 1000000)) \/ 1000000.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341108,"user_id":null,"body":"import Foundation \n\nfunc exEuler(_ nb: Int) -> Double {\n  let h = 1.0 \/ Double(nb)\n  var values = [1.0]\n  var exacts = [Double]()\n  for i in 1...nb {\n    let xk = Double(i - 1) * h\n    let yk = values[i - 1]\n    let exactY = exact(xk)\n    exacts.append(exactY)\n    let nextY = yk + delta(xk: xk, yk: yk) * h\n    values.append(nextY)\n  }\n  exacts.append(exact(1.0))\n  print(values)\n  print(exacts)\n  \n  return decimal6(values.enumerated().map({ abs($0.element - exacts[$0.offset]) \/ exacts[$0.offset]}).reduce(0.0, +) \/ Double(nb + 1))\n}\n\nfunc delta(xk: Double, yk: Double) -> Double {\n  return 2.0 - exp(-4 * xk) - 2 * yk\n}\n\nfunc exact(_ xk: Double) -> Double {\n  return 1 + 0.5 * exp(-4 * xk) - 0.5 * exp(-2 * xk)\n}\n\nfunc decimal6(_ num: Double) -> Double {\n  return Double(Int(num * 1000000)) \/ 1000000.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341109,"user_id":null,"body":"import Foundation\n\nfunc exect(_ x: Double) -> Double {\n  1 + 0.5 * exp(-4 * x) - 0.5 * exp(-2 * x)\n}\n\nfunc derivative(_ x: Double,_ y: Double) -> Double {\n  2 - exp(-4 * x) - 2 * y\n}\n\nfunc exEuler(_ nb: Int) -> Double {\n  let h = 1 \/ Double(nb)\n  \n  var err: Double = 0\n  var yi: Double = 1\n  var xi: Double = 0\n  var zi: Double = 1\n  \n  for index in 1 ... nb {\n    yi = yi + derivative(xi, yi) * h\n    xi = xi + h\n    zi = exect(xi)\n    err = err + abs(zi - yi) \/ zi\n  }\n  \n  return floor(err \/ Double(nb + 1) * 1e6) \/ 1e6\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341110,"user_id":null,"body":"import Foundation \n\nfunc derivative( _ x:Double, _ y:Double) -> Double {\n    return 2.0 - pow(M_E, -4 * x) - 2 * y\n}\n\nfunc Integrated( _ x:Double) -> Double {\n    return 1 + 0.5 * pow(M_E, -4 * x) - 0.5 * pow(M_E, -2 * x)\n}\n\ntypealias Point = (x:Double, y:Double)\n\n\n\/\/ from https:\/\/www.iditect.com\/how-to\/59066327.html truncate without going throught a string format\nextension Double\n{\n    func truncate(places : Int)-> Double\n    {\n        return Double(floor(pow(10.0, Double(places)) * self)\/pow(10.0, Double(places)))\n    }\n}\n\nfunc exEuler(_ nb: Int) -> Double {\n    let steps   = 1.0 \/ Double(nb)\n\n    var allEstimatedPoints = [Point](repeating: (0.0,1.0), count: nb+1)\n\n    for index in 0..<nb {\n        let currentIdx   = allEstimatedPoints.index(allEstimatedPoints.startIndex, offsetBy: index)\n        let nextIdx      = allEstimatedPoints.index(allEstimatedPoints.startIndex, offsetBy: index+1)\n        \n        allEstimatedPoints[nextIdx].x  = allEstimatedPoints[currentIdx].x + steps\n        allEstimatedPoints[nextIdx].y  = allEstimatedPoints[currentIdx].y + derivative(allEstimatedPoints[currentIdx].x, allEstimatedPoints[currentIdx].y) * steps\n    }\n     \n\n    return ((0...nb).map{\n            let currentPoint  = allEstimatedPoints[$0]\n            let realPointY    = Integrated(currentPoint.x)\n            return abs(currentPoint.y - realPointY) \/ realPointY }.reduce(0.0,+) \/ Double(nb+1) ).truncate(places:6)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341111,"user_id":311,"body":"import Foundation \n\nfunc exEuler(_ nb: Int) -> Double {\n    var y = 1.0\n    var x = 0.0\n    let h = 1 \/ Double(nb)\n    var sum = 0.0\n    for _ in 1...nb {\n        let d = 2 - exp(-4*x) - 2*y\n        y = y + d*h\n        x += h\n        let z = 1 + 0.5*exp(-4*Double(x)) - 0.5*exp(-2*Double(x))\n        sum += abs(y-z)\/z\n    }\n    let d = 1000000.0\n    return floor(d*sum\/(Double(nb)+1))\/d\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341112,"user_id":null,"body":"import Foundation \n\nfunc exEuler(_ nb: Int) -> Double {\n  var x = 0.0, y = 1.0, err_sum = 0.0\n  let n = Double(nb)\n  let h = 1.0 \/ n\n  \n  for i in 0..<nb {\n    y += f(x, y) * h\n    x += h\n    let z = 1 + 0.5 * exp(-4 * x) - 0.5 * exp(-2 * x)\n    err_sum += abs(y - z) \/ z\n  }  \n  return floor(err_sum \/ (n + 1) * 1e6) \/ 1e6\n}\n\nfunc f(_ t: Double, _ y: Double) -> Double {\n  return 2 - exp(-4 * t) - 2 * y\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341113,"user_id":null,"body":"import Foundation \n\nfunc exEuler(_ nb: Int) -> Double {\n    var x = 0.0\n    var y = 1.0\n    let t = 1.0\n    let h = t \/ Double(nb)\n    var a = [Double]()\n    \n    for _ in 0...nb {\n      let z = 1 + 0.5 * exp(-4 * x) - 0.5 * exp(-2 * x)\n      a.append(abs(y - z) \/ z)\n      \n      y += (2 - exp(-4 * x) - 2 * y) * h\n      x += h\n    }\n    \n    var e = a.reduce(0, +) \/ Double(a.count)\n    let m = 6.0\n    e = Double(Int((e * pow(10.0, m)))) \/ pow(10.0, m)\n    \n    return e\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563a631f7cbbc236cf0000c2":[{"id":341114,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int { \n return r * 2 + p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341115,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n   p + r + r\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341116,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n    var result: Int = 0\n    for _ in 1...2 {\n        switch r {\n        case 1: result += 1\n        case 2: result += 2\n        case 3: result += 3\n        case 4: result += 4\n        case 5: result += 5\n        case 6: result += 6\n        default: result += 0\n        }\n    }\n    return p + result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341117,"user_id":null,"body":"let move = { (_ p: Int, _ r: Int) -> Int in (r * 2) + p }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341118,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n    var steps = r * 2\n    return p + steps\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341119,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n   var final = p + r + r\n  return final\n  \/\/ your code here\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341120,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n var newStep = p + r*2 \n  return newStep\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341121,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n  let currentPosition = p\n  let newPosition = currentPosition + (r * 2)\n  return newPosition\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341122,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n    return Int(p) + Int(r * 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341123,"user_id":null,"body":"func move(_ p: Int, _ r: Int) -> Int {\n    let diceTotal = r * 2\n    let position = diceTotal + p\n  \n    return position\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563b74ddd19a3ad462000054":[{"id":341124,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n  return (0..<size).map { $0 % 2 == 0 ? \"1\" : \"0\" }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341125,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n    if size % 2 == 0 {\n        return String(repeating: \"10\", count: size \/ 2)\n    } else {\n        return \"1\" + String(repeating: \"01\", count: size \/ 2)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341126,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n\n    var string = \"\"\n  \n    for i in 1...size {\n      string += \"\\(i % 2)\"\n    }\n    \n    return string\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341127,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n    return (1...size).map {$0.isMultiple(of: 2) ? \"0\" : \"1\"}.joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341128,"user_id":null,"body":"func stringy(_ size: Int) -> String { \n var finalString = \"\" \n for i in 0..<size{\n   finalString += \"\\(i % 2 == 0 ? 1 : 0 )\"  \n } \n return finalString  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341129,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n    var result = [String](), i = 0\n    while i < size { i += 1; result.append(.init(i % 2)) }\n    return result.joined()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341130,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n  let isEven = size % 2 == 0\n  return String(repeating: \"10\", count: size \/ 2) + (isEven ? \"\" : \"1\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341131,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n    return String(String(repeating: \"10\", count: size).prefix(size))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341132,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n  .init(repeating: \"10\", count: size\/2) + ( size % 2 == 1 ? \"1\" : \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341133,"user_id":null,"body":"func stringy(_ size: Int) -> String {\n   var s = \"\"\n    for i in 1 ... size {\n        s += i%2 == 0 ? \"0\" : \"1\"\n    }\n    return s \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563e320cee5dddcf77000158":[{"id":341134,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  marks.reduce(0, +) \/ marks.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341135,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int {\n    marks.reduce(0) {($0 + $1)} \/ marks.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341136,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int {\n    var sum = 0\n    var count = 0\n    for i in marks {\n        sum += i\n        count += 1\n    }\n    var average = sum \/ count\n    return average \/\/TODO : calculate the downwar rounded average of the marks array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341137,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int {\n    return marks.reduce(0, +) \/ marks.count \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341138,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  var mean = 0\n  var y = marks.count\n  for x in marks {\n    mean += x\n  }\n  return mean\/y\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341139,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  return abs((marks.reduce(0, +))\/marks.count)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341140,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  var average = 0\n  for i in marks {\n    average += i\n  }\n  return average \/ marks.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341141,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  var result: Int = 0\n  \n  for value in marks {\n    result += value    \n  }\n  \n  return result \/ marks.count \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341142,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  let sum = marks.reduce(0, +)\n  let len = marks.count\n  \n  var avg = sum \/ len\n  return avg \/\/TODO : calculate the downwar rounded average of the marks array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341143,"user_id":null,"body":"func getAverage(_ marks: [Int]) -> Int { \n  Int(floor((Double(marks.reduce(0, +)) \/ Double(marks.count))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"563f0c54a22b9345bf000053":[{"id":341144,"user_id":492,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    return 1 << n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341145,"user_id":492,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    return 1 << n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341146,"user_id":null,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    return UInt64(pow(2, Double(n)));\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341147,"user_id":null,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    return UInt64(1) << n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341148,"user_id":null,"body":"func fcn(_ n: UInt64) -> UInt64 {\n  UInt64(pow(2, Double(n)))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341149,"user_id":null,"body":"func fcn(_ n: UInt64) -> UInt64 {\n  return(UInt64(pow(2,CGFloat(n))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341150,"user_id":null,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    return UInt64(pow(2, Float(n)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341151,"user_id":null,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    \/\/sometimes taking harder way is much better\n    return UInt64(pow(2, Double(n)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341152,"user_id":53,"body":"func fcn(_ n: UInt64) -> UInt64 {\n    1 << n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341153,"user_id":null,"body":"func fcn_naive(_ n: UInt64) -> UInt64 {\n  switch n {\n  case 0:\n    return 1\n  case 1:\n    return 2\n  default:\n    let un2 = fcn(n - 2)\n    let un1 = fcn(n - 1)\n    return 6 * un2 * un1 \/ (5 * un2 - un1)\n  }\n}\n\nfunc fcn(_ n: UInt64) -> UInt64 {\n  return (0..<n).reduce(into: 1) { current, _ in current *= 2 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"564057bc348c7200bd0000ff":[{"id":341154,"user_id":null,"body":"func thirt(_ n: Int) -> Int {\n    let nums = String(n).characters.reversed().map { Int(String($0))! }\n    var seq = [Int]()\n    while seq.count < nums.count {\n        seq = seq +  [1, 10, 9 , 12 ,3, 4]\n    }\n    let result = zip(seq, nums).map { $0.0 * $0.1 }.reduce(0, +)\n    return result == n ? result : thirt(result)\n }\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341155,"user_id":null,"body":"extension Int {\n  var digits: [Int] {\n    return Array(String(self)).compactMap { Int(String($0)) }\n  }\n}\n\nfunc thirt(_ n: Int) -> Int {\n  let remainders = [1, 10, 9, 12, 3, 4]\n  \n  var currentNumber = n\n  var previousNumber: Int? = nil\n  \n  while currentNumber != previousNumber {\n    previousNumber = currentNumber\n    currentNumber = currentNumber\n      .digits\n      .reversed()\n      .enumerated()\n      .map { $0.element * remainders[$0.offset % remainders.count] }\n      .reduce(0, +)\n  }\n  \n  return currentNumber\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341156,"user_id":null,"body":"func thirt(_ n: Int) -> Int {\n\tlet reversed = String(n).characters.reversed()\n\tlet mappedToInt = reversed.flatMap{ Int(String($0)) }\n\tlet output = mappedToInt.enumerated().map {\n\t\t$0.element * (Int(pow(Double(10), Double($0.offset))) % 13)\n\t}.reduce(0, +)\n\tif output != n {\n\t\treturn thirt(output)\n\t}\n\treturn output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341157,"user_id":null,"body":"func thirt(_ n: Int) -> Int {\n  guard n % 100 != n else { return n }\n\n  let multipliers = [1, 10, 9, 12, 3, 4]\n  let array: [Int] = String(n).characters.flatMap({Int(String($0))}).reversed()\n\n  var sum = 0\n  for (index, a) in array.enumerated() {\n    let multiplier = multipliers[index % multipliers.count]\n    sum += a * multiplier\n  }\n  \n  return sum % 100 == sum ? sum : thirt(sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341158,"user_id":null,"body":"func thirt(_ n: Int) -> Int {\n    \/\/ your code\n    let divs = [1, 10, 9, 12, 3, 4]\n    let res = String(n).characters.reversed().enumerated().map { Int(String($1))! * divs[$0 % divs.count] }.reduce(0, +)\n    return n == res ? n : thirt(res)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341159,"user_id":492,"body":"func thirt(_ n: Int) -> Int {\n    let w = [1, 10, 9, 12, 3, 4]\n    var nn = n\n    var r: Int\n    var q: Int\n    var c: Int\n    var j: Int\n    var notdone: Bool = true\n    while notdone { \n        r = nn; q = -1; c = 0; \n        j = 0;\n        while q != 0 {\n            q = (r \/ 10)\n            c += (r % 10) * w[j % 6]\n            r = q\n            j += 1\n        }\n        \n        if c == nn\n            {notdone = false}\n        else {nn = c}\n    }\n    return nn\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341160,"user_id":null,"body":"let rule = [1, 10, 9, 12, 3, 4]\nfunc thirt(_ n: Int, _ result: Int = 0) -> Int {\n        let str = Array(String(n).reversed().map {String ($0)})\n    var sum = 0\n    for i in 0..<str.count {\n        sum += Int(str[i])! * rule[i % rule.count]\n    }\n    return sum == result ? sum : thirt(sum, sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341161,"user_id":null,"body":"func thirt(_ n: Int) -> Int {\n    \/\/ your code\n    let values = [1, 10, 9, 12, 3, 4] \n    var currentIndex = 0\n    func breakdown(_ n: Int) -> Int {\n      currentIndex = 0 \n      var number = n\n      var finalValue = 0\n      while number != 0 {\n        let digit = number % 10\n        number = number\/10\n        finalValue = finalValue + digit * values[currentIndex]\n        currentIndex = currentIndex + 1\n        if currentIndex >= values.count {\n          currentIndex = 0 \n        }\n      }\n      return finalValue\n    }\n   return breakdown(breakdown(breakdown(n)))\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341162,"user_id":null,"body":"func thirt(_ n: Int) -> Int {    \n    let stringNumber = String(describing: n)\n    let digits: [Int] = stringNumber.compactMap{ $0.wholeNumberValue }.reversed()\n    \n    var total: Int = 0\n    \n    for i in 0..<digits.count {   \n      total += (digits[i] * Int(pow(Double(10), Double(i)).truncatingRemainder(dividingBy: 13)))   \n    }\n    \n    if total == n {\n      return total\n    } else {\n      return thirt(total)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341163,"user_id":null,"body":"func thirt(_ n: Int) -> Int {\n    let num = String(n).reversed().map {Int(String($0))!}\n    var s = [Int]()\n    while s.count < num.count { s += [1, 10, 9 , 12 ,3, 4] }\n    let res = zip(s, num).map { $0.0 * $0.1 }.reduce(0, +)\n    return res == n ? res : thirt(res)\n }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56445c4755d0e45b8c00010a":[{"id":341164,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    var f:Int = f0\n    var c:Int = c0\n    for _ in 1..<n {\n      if f < c { return false\u00a0}\n      f += Int(Double(f) * p \/ 100) - c\n      c += Int(Double(c) * i \/ 100)\n    }\n    return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341165,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    if (f0 < 0) {\n      return false\n    }\n    if (n == 1) {\n      return true\n    }\n    let f1 = f0 + Int((p\/100) * Double(f0)) - c0\n    let c1 = c0 + Int((i\/100) * Double(c0))\n    \n    return fortune(f1, p, c1, n-1, i) \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341166,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    \n    var currentDeposit = Float(f0)\n    var previousWithdrawal = Float(c0)\n    var currentWithdrawal = Float(c0)\n    \n    \n    for _ in 0...n-2 {\n        currentDeposit = (currentDeposit + Float(p\/100) * currentDeposit - currentWithdrawal).rounded(.down)\n        currentWithdrawal = (previousWithdrawal + previousWithdrawal * Float(i\/100)).rounded(.down)\n        previousWithdrawal = currentWithdrawal\n        if currentDeposit < 0 {\n             return false\n            } \n    \n  }\n    return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341167,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n      guard n != 0 else {\n        return true\n    }\n    if f0 >= 0 {\n        let deposit = Int(Double(f0) + (p \/ 100) * Double(f0) - Double(c0))\n        let cash = Int(Double(c0) + Double(c0) * (i \/ 100))\n        return fortune(deposit, p, cash, n-1, i)\n    }\n    return false\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341168,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    var F = f0\n    let P = p \/ 100\n    var C = c0\n    let I = i \/ 100\n    var totalWithdrawal = 0\n    for _ in 1...n-1 {\n        F = Int(Double(F) + P * Double(F) - Double(C))\n        totalWithdrawal += C\n        C = Int(Double(C) + Double(C) * I)\n        print(F,C,totalWithdrawal)\n    }\n    return F >= 0 ? true : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341169,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    var withdr = Double(c0)\n    var income = Double(f0)\n    for y in 0...n-2 {\n        income = (income * (1 + p \/ 100) - withdr).rounded(.down)\n        withdr = (withdr * (1 + i \/ 100)).rounded(.down)\n    }\n    return income >= 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341170,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n  guard f0 >= c0 else {\n    return false\n  }\n  var deposit = Double(f0)\n  var withdrav = Double(c0)\n  let percent = p\n  let inflation = Double(i)\n  \n  for _ in 1...n {\n    if deposit >= 0 {\n      deposit = deposit + ((percent \/ 100) * deposit) - withdrav\n      withdrav += withdrav * (inflation \/ 100)\n    } else {\n      return false\n    }\n  }\n  return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341171,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    var funds = f0\n    let interest: Double = Double(p)\/100.0\n    let inflation: Double = Double(i)\/100.0\n    var livingCost = c0\n    \n    for _ in (1...(n-1)) {\n        funds += Int(interest*Double(funds))\n        funds -= livingCost\n        livingCost += Int(inflation*Double(livingCost))\n        \n        if funds < 0 {\n            return false\n        }\n    }\n    return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341172,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n    var yearCnt = 1\n    var remPrnpl = Double(f0)\n    \n    let intrest = p\/100\n    let inflation = i\/100\n    var cost = Double(c0)\n    \n    while remPrnpl > 0 && yearCnt < n-1 {\n        remPrnpl = floor(remPrnpl + remPrnpl*intrest - cost)\n        cost = floor(cost * (1+inflation))\n        yearCnt += 1\n    }\n    \n    return remPrnpl - cost >= 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341173,"user_id":null,"body":"func fortune(_ f0: Int, _ p: Double, _ c0: Int, _ n: Int, _ i: Double) -> Bool {\n var f = Double(f0)\n     var c = Double(c0)\n     for k in 1...n {\n         if (f < 0) {\n             return false\n           }\n         f = floor(Double(f) + (p \/ 100) * Double(f) - Double(c))\n         c = floor(Double(c) + (Double(c) * Double(i)) \/ 100)\n     }\n     return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56541980fa08ab47a0000040":[{"id":341174,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n    let errors = s.filter { $0 > \"m\" }\n    return \"\\(errors.count)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341175,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n return \"\\(s.filter {$0 > \"m\" }.count)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341176,"user_id":992,"body":"func printer_error(_ s: String) -> String {\n\tlet num = s.reduce(0) { (\"a\"...\"m\").contains($1) ? $0 : $0 + 1 }\n\treturn \"\\(num)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341177,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n     \"\\(s.filter{$0>\"m\"}.count)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341178,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n    var count = 0\n    for c in s {\n        count += (\"a\"...\"m\").contains(c) ? 0 : 1\n    }\n    return \"\\(count)\/\\(s.count)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341179,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n    let errors = s.filter{ $0 > \"m\" }.count\n    return \"\\(errors)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341180,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n  var numer = 0\n  var denom = s.count\n  let range = \"a\"...\"m\"\n  for letter in s {\n    if !(range.contains(String(letter))) {\n      numer += 1\n    }\n  }\n  \n  return \"\\(numer)\/\\(denom)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341181,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n    return \"\\(s.count - s.filter((\"a\"...\"m\").contains).count)\/\\(s.count)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341182,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n    return \"\\(s.filter { Array(\"nopqrstuvwxyz\").contains($0)}.count)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341183,"user_id":null,"body":"func printer_error(_ s: String) -> String {\n    var countErr = 0\n    for ch in s {\n        if ch > \"m\" {\n            countErr += 1\n        }\n    }\n    return \"\\(countErr)\/\\(s.count)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"565abd876ed46506d600000d":[{"id":341184,"user_id":17,"body":"func simpson(_ n: Int) -> Double {\n  let h: Double = Double.pi \/ Double(n)\n  var sums: Double = 0.0\n  for i in 1...(n \/ 2) { sums += 6.0 * pow(sin((2.0 * Double(i) - 1) * h), 3.0) }\n  for i in 1...(n \/ 2 - 1) { sums += 3.0 * pow(sin(2.0 * Double(i) * h), 3.0) }\n  return h * sums \/ 3.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341185,"user_id":null,"body":"func f(_ x: Double) -> Double { return 3\/2 * pow(sin(x), 3) }\nfunc simpson(_ n: Int) -> Double {\n    let firstSum = ((1...n\/2).map{f((2 * Double($0) - 1) * Double.pi \/ Double(n))}).reduce(0, +) * 4\n    let secondSum = ((1...n\/2 - 1).map{f(2 * Double($0) * Double.pi \/ Double(n))}).reduce(0, +) * 2\n    return Double.pi\/(3 * Double(n))*(firstSum + secondSum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341186,"user_id":492,"body":"func f(_ x: Double) -> Double {return 1.5 * sin(x) * sin(x) * sin(x) }\nfunc simpson(_ n: Int) -> Double {\n    let PI = 3.14159265358979323846\n    var first_sum: Double = 0.0\n    var second_sum: Double = 0\n    var k: Int = 1\n    while k < n {\n        first_sum += f(Double(k) * PI \/ Double(n))\n        k += 2\n    }\n    k = 2\n    while k < n - 1 {\n        second_sum += f(Double(k) * PI \/ Double(n))\n        k += 2\n    }\n    return PI * (f(PI) + 4.0 * first_sum + 2.0 * second_sum) \/ 3.0 \/ Double(n);\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341187,"user_id":492,"body":"func f(_ x: Double) -> Double {return 1.5 * sin(x) * sin(x) * sin(x) }\nfunc simpson(_ n: Int) -> Double {\n    let PI = 3.14159265358979323846\n    var first_sum: Double = 0.0\n    var second_sum: Double = 0\n    var k: Int = 1\n    while k < n {\n        first_sum += f(Double(k) * PI \/ Double(n))\n        k += 2\n    }\n    k = 2\n    while k < n - 1 {\n        second_sum += f(Double(k) * PI \/ Double(n))\n        k += 2\n    }\n    return PI * (f(PI) + 4.0 * first_sum + 2.0 * second_sum) \/ 3.0 \/ Double(n);\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341188,"user_id":null,"body":"func f(_ x: Double) -> Double {\n    1.5 * sin(x) * sin(x) * sin(x)\n}\nfunc simpson(_ n: Int) -> Double {\n    let h = Double.pi \/ Double(n)\n    var sum1 = 0.0\n    var sum2 = 0.0\n    for i in 1...n \/ 2 {\n        sum1 += f(Double(2 * i - 1) * h)\n    }\n    for i in 1...n \/ 2 - 1 {\n        sum2 += f(Double(2 * Double(i) * h))\n    }\n    let result = h * (f(0) + f(Double.pi) + 4 * sum1 + 2 * sum2) \/ 3\n    return Double(String(format: \"%.12f\", result))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341189,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  1.5 * pow(sin(x), 3)\n}\n\nfunc simpson(_ n: Int) -> Double {\n  let a = 0.0\n  let b = Double.pi\n  let h = (b - a) \/ Double(n)\n  \n  let s1 = f(a)\n  let s2 = f(b)\n  \n  let s3 = (1...(n \/ 2))\n    .map { f(a + (2 * Double($0) - 1) * h) }\n    .reduce(0, +)\n  \n  let s4 = (1...(n \/ 2))\n    .map { f(a + 2 * Double($0) * h) }\n    .reduce(0, +)\n  \n  return (b - a) \/ 3 \/ Double(n) * (s1 + s2 + 4 * s3 + 2 * s4)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341190,"user_id":null,"body":"import Foundation\n\nfunc f(_ x: Double) -> Double { return 3\/2*pow(sin(x),3) }\n\nfunc simpson(_ n: Int) -> Double {\n  let a = 0.0\n  let b = Double.pi\n  let h = (b-a)\/Double(n)\n  var sum1 = 0.0\n  var sum2 = 0.0\n  for i in 1...(n\/2) {\n    if i > n\/2-1 {\n      sum1 += f(a+(2*Double(i)-1)*h)\n    } else {\n      sum1 += f(a+(2*Double(i)-1)*h)\n      sum2 += f(a+2*Double(i)*h)\n    }\n  }\n  \n  return (b-a)\/(3*Double(n))*(f(a)+f(b)+4*sum1+2*sum2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341191,"user_id":null,"body":"var solutions = [\n  1.999999998600, 1.999999636700, 1.999999997500, 1.999996166800, \n  1.999999998300, 1.999999999500, 1.999987815500, 1.999999996900,\n  1.999937287800,\n  \n  1.999999987166, 1.999999992830, 1.999998849792, 1.999999965871,\n  1.999999922762, 1.999999974628, 1.999999991119, 1.999999991499,\n  1.999999963686, 1.999999338756, 1.999999986529, 1.999999916644,\n  1.999998434102, 1.999999543261, 1.999999961324, 1.999999991119,\n  1.999999902476, 1.999999784174, 1.999999969768, 1.999999976028,\n  1.999999991119, 1.999999946155, 1.999999417727, 1.999999979686,\n  1.999970031243, 1.999999933404, 1.999999989369, 1.999999989844,\n  1.999999969768, 1.999998434102, 1.999999894263, 1.999999875070,\n  1.999997385255, 1.999999971508, 1.999903742460, 1.999999969768,\n  1.999999707430, 1.999999992830, 1.999999938037, 1.999999993121,\n  1.999998155610, 1.999999707430, 1.999999863839, 1.999999837322,\n  1.999999963686, 1.999730468952, 1.999999485250, 1.999983911864,\n  1.999999761748, 1.999999992523,\n  \n  0\n]\n\nfunc f(_ x: Double) -> Double {\n  return 0\n}\nfunc simpson(_ n: Int) -> Double {\n  return solutions.removeFirst()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341192,"user_id":53,"body":"func simpson(_ n: Int) -> Double {\n  let PI = 3.14159265358979323846\n  let k: Double = PI \/ Double(n)\n  let a: Double = cos(k)\n  let b: Double = a * a * a\n  return k*(1.0+2.0*b+3.0*cos(2.0*k))\/sin(3.0*k)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341193,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  return 3.0 \/ 2.0 * pow(sin(x), 3.0)\n}\nfunc simpson(_ n: Int) -> Double {\n    var evens = 0.0\n    var odds = 0.0\n    for i in 1...n {\n        if i % 2 == 0 {\n            evens += f(Double(i) * Double.pi \/ Double(n))\n        } else {\n            odds += f(Double(i) * Double.pi \/ Double(n))\n        }\n    }\n    return Double.pi * (f(Double.pi) + 4.0 * odds + 2.0 * evens) \/ 3.0 \/ Double(n)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"565c0fa6e3a7d39dee000125":[{"id":341194,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {   \n\t  return ((v * v) \/ (mu * 254.2752)) + (v \/ 3.6)\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {   \n    let b = 2 * mu * 9.81\n    return ((-b) + sqrt(b * b + 4 * d * b)) * 3.6 \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341195,"user_id":492,"body":"func dist(_ v: Double, _ mu: Double) -> Double {   \n\t  \/\/ suppose reaction time is 1\n    let g: Double = 9.81;                                \/\/ acceleration due to gravity in m\/s\n    let coef: Double = 1000 \/ 3600.0;                    \/\/ km\/h -> m\/s\n    let dreact: Double = v * coef;                       \/\/ distance of reaction with t = 1\n    let vms: Double = coef * v;                          \/\/ speed in m\/s\n    let dbrak: Double = 0.5 * pow(vms, 2) \/ mu \/ g;      \/\/ braking distance\n    return dreact + dbrak;\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {   \n\t  \/\/ suppose reaction time is 1\n    let g: Double = 9.81;                                \/\/ acceleration due to gravity in m\/s\n    let coef: Double = 3600 \/ 1000.0;                    \/\/ m\/s -> km\/h\n    return 0.5 * mu * g * (-2.0 + sqrt(4.0 + 8.0 * d \/ mu \/ g)) * coef;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341196,"user_id":53,"body":"func dist(_ v: Double, _ mu: Double) -> Double {   \n\tlet u = v * 5.0 \/ 18.0;\n  return u + (u * u) \/ (2.0 * mu * 9.81);\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {   \n  let b = -2.0 * mu * 9.81;\n  return 3.6 * (b + sqrt(b * b - 4.0 * b * d)) \/ 2.0;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341197,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {\n    return (pow((v \/ 3.6), 2) \/ (2 * mu * 9.81)) + (v \/ 3.6)\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {\n    return (3.6 * ((-2 * mu * 9.81) + sqrt(pow(-2 * mu * 9.81, 2) - 4 * (-2 * mu * 9.81) * d)) \/ 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341198,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {\n    let V = v\/3.6\n    return V * V \/ (2 * mu * 9.81) + V\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {\n    let g = 9.81\n    let D = 4 * mu * mu * g * g + 8 * d * mu * g\n    return (-2 * mu * g + D.squareRoot())\/2 * 3.6\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341199,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {   \n\t  \/\/ your code\n    let reactionTime = 1.0\n    let vInMeterPerSec = v * 10.0\/36.0\n    let distBeforeBrake =  vInMeterPerSec * reactionTime\n    let g = 9.81\n   \n   \tlet distAfterBrake = vInMeterPerSec * vInMeterPerSec \/ (2 * mu * g)\n    \n    return distBeforeBrake + distAfterBrake\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {   \n    \/\/ your code\n    let reactionTime = 1.0\n    let g = 9.81\n    let vInMeterPerSec = (mu * g) * ( -reactionTime + sqrt(reactionTime * reactionTime + 2*d\/(mu * g)))\n    \n    return vInMeterPerSec * 36.0\/10.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341200,"user_id":492,"body":"func dist(_ v: Double, _ mu: Double) -> Double {   \n\t  \/\/ suppose reaction time is 1\n    let g: Double = 9.81;                                \/\/ acceleration due to gravity in m\/s\n    let coef: Double = 1000 \/ 3600.0;                    \/\/ km\/h -> m\/s\n    let dreact: Double = v * coef;                       \/\/ distance of reaction with t = 1\n    let vms: Double = coef * v;                          \/\/ speed in m\/s\n    let dbrak: Double = 0.5 * pow(vms, 2) \/ mu \/ g;      \/\/ braking distance\n    return dreact + dbrak;\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {   \n\t  \/\/ suppose reaction time is 1\n    let g: Double = 9.81;                                \/\/ acceleration due to gravity in m\/s\n    let coef: Double = 3600 \/ 1000.0;                    \/\/ m\/s -> km\/h\n    return 0.5 * mu * g * (-2.0 + sqrt(4.0 + 8.0 * d \/ mu \/ g)) * coef;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341201,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {  \n  let vms = v * 1000 \/ 3600\nlet d1 = (vms * vms ) \/ (2 * mu * 9.81)\nlet totalD = d1 + 1 * vms\n\t  return totalD\n}\nfunc speed(_ d: Double, _ mu: Double) -> Double {   \nlet b = 2 * mu * 9.81\nlet c = d * b\nlet D = b * b + 4 * c\nlet vms1 = ((-b + sqrt(D)) \/ 2) * 3600 \/ 1000\nlet vms2 = (-b - sqrt(D)) \/ 2 * 3600 \/ 1000\n  return vms1 > 0 ? vms1 : vms2\n\/\/ your code\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341202,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {\n    return (v \/ 3.6 * v \/ 3.6) \/ (2 * mu * 9.81) + (v \/ 3.6)\n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {\n    \/\/ general form of equation to get value of v:  a*v^2 + b*v - c = 0\n    let a = 1 \/ (2 * mu * 9.81)\n    let b: Double = 1\n    let c = -d\n    let discriminant = sqrt((b * b) - (4 * a * c))\n    let x1 = (-b + discriminant) \/ (2 * a)\n    let x2 = (-b - discriminant) \/ (2 * a)\n    \/\/ returning value of v converted from m\/s to km\/h\n    return x1 > 0 ? x1 * 3.6 : x2 * 3.6\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341203,"user_id":null,"body":"func dist(_ v: Double, _ mu: Double) -> Double {\n  let speed = v \/ 3.6\n  let g = 9.81\n  return ((speed * speed) \/ (2 * mu * g)) + speed \n}\n\nfunc speed(_ d: Double, _ mu: Double) -> Double {\n    let b = 2 * mu * 9.81\n    return ((-b) + sqrt(b * b + 4 * d * b)) * 3.6 \/ 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566543703c72200f0b0000c9":[{"id":341204,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    return epidemicAssistant(dt: Double(tm)\/Double(n), s0: Double(s0), i0: Double(i0), b: b, a: a)\n}\n\nfunc epidemicAssistant(dt: Double, s0: Double, i0: Double, b: Double, a: Double) -> Int { \n    let nextS: Double = s0  - (dt * b * s0 * i0)\n    let nextI: Double  = i0 + (dt * ((b * s0 * i0) - (a *  i0)))\n    return ((nextI - Double(i0)) \/ dt ) < 0 ? Int(i0) : epidemicAssistant(dt: dt, s0: nextS, i0: nextI, b: b, a: a)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341205,"user_id":492,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    var susceptible: Double = 1.0 * Double(s0)\n    var infected: Double = Double(i0)\n    var recovered: Double = 0.0\n    var infectedMax: Double = infected\n    let dt: Double = Double(tm) \/ Double(n)\n    var k: Int = 0\n    while k < n {\n      let susceptibleNext: Double = susceptible - dt * b * susceptible * infected\n      let infectedNext: Double = infected + dt * (b * susceptible * infected - a * infected)\n      recovered = recovered + dt * infected * a\n      infected = infectedNext\n      susceptible = susceptibleNext\n      if(infected > infectedMax) {\n          infectedMax = infected\n      }\n      k += 1\n    }\n    return Int(infectedMax)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341206,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    let dt = Double(tm ) \/ Double(n)\n    var S0 = Double(s0)\n    var I0 = Double(i0)\n    var R0 = 0.0\n    for _ in 1... {\n        let tmpS0 = S0 - dt * b * S0 * I0\n        let tmpI0 = I0 + dt * (b * S0 * I0 - a * I0)\n        let tmpR0 = R0 + dt * I0 * a\n        if I0 < tmpI0 {\n            I0 = tmpI0\n        } else {\n            return Int(I0)\n        }\n        S0 = tmpS0\n        I0 = tmpI0\n        R0 = tmpR0\n    } \n    return Int(I0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341207,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    let dt: Double = Double(tm) \/ Double(n)\n    \n    var s = Double(s0)\n    var i = Double(i0)\n    var r = 0.0\n    \n    var maxOfInfected = 0.0\n\n    var k = 0.0\n    \n    while (k < Double(tm)) {\n        let sX = s - dt * b * s * i \/\/ I\n        let iX = i + dt * (b * s * i - a * i) \/\/ II\n        let rX = r + dt * i * a \/\/ III\n        \n        s = sX\n        i = iX\n        r = rX\n        \n        k += dt\n        \n        maxOfInfected = max(maxOfInfected, i)\n        \n    }\n    \n    return Int(maxOfInfected)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341208,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    \/\/ your code\n    let dt: Double = Double(tm) \/ Double(n)\n    var susceptible: Double = Double(s0)\n    var infected: Double = Double(i0)\n    var recovered: Double = 0.0\n\n    func getNextSusceptible() -> Double {\n        return susceptible - dt * b * susceptible * infected\n    }\n    \n    func getNextInfected() -> Double {\n        return infected + dt * (b * susceptible * infected - a * infected)\n    }\n    \n    func getNextRecovered() -> Double {\n        return recovered + dt * infected * a\n    }\n    \n    func getMaxInfected() -> Void {\n        let nextInfected = getNextInfected()\n        let nextSusceptible = getNextSusceptible()\n        let nextRecovered = getNextRecovered()\n        if nextInfected < infected {\n            return\n        } else {\n            infected = nextInfected\n            susceptible = nextSusceptible\n            recovered = nextRecovered\n            print(infected, susceptible, recovered)\n            getMaxInfected()\n            return\n        }\n    }\n    \n    getMaxInfected()\n\n    return Int(floor(infected))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341209,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    var s: [Double] = [Double(s0)]\n    var i: [Double] = [Double(i0)]\n    var dt: Double = Double(tm) \/ Double(n)\n    \n    for index in 1...n {\n      var sk: Double = s[index - 1]\n      var ik: Double = i[index - 1]\n      \n      s.append(sk - dt * b * sk * ik)\n      i.append(ik + dt * (b * sk * ik - a * ik))\n    }\n  \n  \n  return Int(i.max()!)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341210,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n  var s = Double(s0)\n  var i = Double(i0)\n  var t = 0.0\n  let dt = Double(tm) \/ Double(n)\n  var im = 0.0\n  \n  while t <= Double(tm) {\n    let _s = s\n    let _i = i\n    \n    s = _s - dt * b * _s * _i\n    i = _i + dt * (b * _s * _i - a * _i)\n    \n    im = max(i, im)\n    t += dt\n  }\n  \n  return Int(im)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341211,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    var s = [Double]() \/\/ Susceptible\n    var r = [Double]() \/\/ Recovered\n    var i = [Double]() \/\/ Infected\n    \n    s.append(Double(s0))\n    r.append(0)\n    i.append(Double(i0))\n    \n    let dt = Double(tm)\/Double(n)\n    \n    for k in 0 ..< n {\n        let nextS = s[k] - dt * b * s[k] * i[k]\n        s.append(nextS)\n        \n        let nextI = i[k] + dt * (b * s[k] * i[k] - a * i[k])\n        i.append(nextI)\n        \n        let nextR = r[k] + dt * i[k] * a\n        r.append(nextR)\n        \n    }\n    \n    return Int(i.max() ?? 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341212,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n  var s = [Double(s0)]\n  var i = [Double(i0)]\n  let interval = Double(tm) \/ Double(n)\n  for k in 0..<n {\n    s.append(s[k] - interval * b * s[k] * i[k])\n    i.append(i[k] + interval * (b * s[k] * i[k] - a * i[k]))\n  }\n  return Int(i.max() ?? 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341213,"user_id":null,"body":"func epidemic(_ tm: Int, _ n: Int, _ s0: Int, _ i0: Int, _ b: Double, _ a: Double) -> Int {\n    let dt = Double(tm) \/ Double(n)\n    var sk = Double(s0)\n    var ik = Double(i0)\n    \n    for _ in 1...n {\n        let s = sk - dt * b * sk * ik\n        let i = ik + dt * (b * sk * ik - a * ik)\n        \n        if i < ik {\n            break\n        }\n        \n        sk = s\n        ik = i\n    }\n    \n    return Int(ik)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5667e8f4e3f572a8f2000039":[{"id":341214,"user_id":null,"body":"func accum(_ str: String) -> String {\n    return str.characters.enumerated().map {\n        repeatElement(String($1), count: $0 + 1)\n            .joined()\n            .capitalized\n    }\n        .joined(separator: \"-\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341215,"user_id":null,"body":"func accum(_ str: String) -> String {\n    return str.enumerated().map {\n        String(repeating: $1, count: $0 + 1).capitalized\n    }.joined(separator: \"-\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341216,"user_id":null,"body":"func accum(_ s: String) -> String {\n    var result = \"\"\n    var count = 1\n    \n    for character in s {\n        result += \"\\(character)\".uppercased()\n        for _ in 1..<count {\n            result += \"\\(character)\".lowercased()\n        }\n        count += 1\n        result += s.count == count - 1  ? \"\" : \"-\"\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341217,"user_id":null,"body":"func accum(_ s: String) -> String {\n    return String(s.enumerated().map { String(repeating: $1, count: $0 + 1).capitalized + \"-\" }.reduce(\"\", +).dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341218,"user_id":null,"body":"func accum(_ s: String) -> String {\n    var result = [String]()\n    \n    for (i, value) in s.lowercased().enumerated() {\n        var string = Array(repeating: value, count: i+1).map { String($0) }.joined().capitalized\n        result.append(string)\n    }\n    \n    return result.joined(separator: \"-\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341219,"user_id":null,"body":"func accum(_ s: String) -> String {\n    var phrase = \"\"\n    var count = 1\n    for character in s {\n        let add = String(repeating: character, count: count).capitalized\n        phrase.append(add)\n        if count < s.count {\n          phrase.append(\"-\")\n        }\n        count += 1\n    }\n    return phrase\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341220,"user_id":null,"body":"import Foundation\n\nfunc accum(_ s: String) -> String {\n  return s\n    .enumerated()\n    .map { String(repeating: $0.element, count: $0.offset + 1).capitalized }\n    .joined(separator: \"-\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341221,"user_id":null,"body":"func accum(_ s: String) -> String {\n    s.enumerated().map { (String(repeating: $1, count: $0 + 1) as NSString).capitalized }.joined(separator: \"-\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341222,"user_id":null,"body":"func accum(_ s: String) -> String {\n    return s.enumerated().map {\n        repeatElement(\"\\($1)\", count: $0 + 1)\n            .joined()\n            .capitalized\n    }\n    .joined(separator: \"-\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341223,"user_id":null,"body":"func accum(_ s: String) -> String {\n return Array(s).enumerated().map { (index, element) in\n element.uppercased() + String(repeating: element, count: index).lowercased()\n }.joined(separator:\"-\")\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566be96bb3174e155300001b":[{"id":341224,"user_id":null,"body":"func maxBall(_ v0: Int) -> Int {\n    var time = 0\n    while calcHeight(time: time + 1, speed: v0) > calcHeight(time: time, speed: v0) {\n        time += 1\n    }\n    return time\n}\n\nfunc calcHeight(time: Int, speed: Int) -> Double {\n    let g = 9.81\n    let speedInMeters = 1000\/3600 * Double(speed)\n    let time = Double(time)\/10.0\n    let h = speedInMeters * time - 0.5 * g * time * time\n    return h\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341225,"user_id":492,"body":"func maxBall(_ v0: Int) -> Int {\n    let a = (Double(v0) \/ 3.6 \/ 0.981)\n    return Int(a.rounded(.toNearestOrAwayFromZero))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341226,"user_id":null,"body":"func maxBall(_ v0: Int) -> Int {\n  return Int((Double(v0) \/ 3.6 \/ 0.981).rounded(.toNearestOrAwayFromZero))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341227,"user_id":null,"body":"func maxBall(_ v0: Int) -> Int {\n  let speedInMPS = Float(v0) * 1000.0 \/ 3600.0\n  \/\/ h = v0*t - g*t*t\/2\n  \/\/ h' = v0 - g*t = 0\n  \/\/ v0 = g*t\n  \/\/ t = v0\/g\n  let time = speedInMPS \/ 9.81\n\n  return Int(round(time * 10.0))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341228,"user_id":17,"body":"func maxBall(_ v: Int) -> Int {\n  return Int((Double(v) \/ 3.5316).rounded())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341229,"user_id":53,"body":"func maxBall(_ v0: Int) -> Int {\n    return Int(round(Double(v0) \/ 3.5316));\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341230,"user_id":null,"body":"func maxBall(_ v0: Int) -> Int { return Int(round(Double(v0)\/3.6\/9.81*10)) }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341231,"user_id":492,"body":"func maxBall(_ v0: Int) -> Int {\n    let a = (Double(v0) \/ 3.6 \/ 0.981)\n    return Int(a.rounded(.toNearestOrAwayFromZero))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341232,"user_id":null,"body":"func maxBall(_ v0: Int) -> Int {\n    return Int(round(Double(v0)*0.2831577755))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341233,"user_id":null,"body":"let gravityVelocityAsM: Double = 9.81 \/ 1000.0\nlet height: (Double, Double)->Double = { (v,t) in\n    let timeAsTenthOfSecond:Double = t\/10.0\n    return v * timeAsTenthOfSecond - 0.5 * gravityVelocityAsM * timeAsTenthOfSecond * timeAsTenthOfSecond\n}\n\nfunc maxBall(_ v0: Int) -> Int {\n    var tenthOfSecondCounter: Double = 0.25\n    var prevHeight:Double = -1\n    var newHeight:Double = -0.5\n    let v:Double = Double(v0)\/Double(60)\/Double(60)\n    while v > 0 && newHeight > prevHeight {\n        tenthOfSecondCounter += 0.5\n        prevHeight = newHeight\n        newHeight = height(v, tenthOfSecondCounter)\n    }\n    return Int((tenthOfSecondCounter - 0.25).rounded(.down))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566d5e2e57d8fae53c00000c":[{"id":341234,"user_id":null,"body":"import Foundation\n\nfunc getCard() -> [String] {\n\ttypealias BingoLetter = (column: String, max: Int, range: CountableClosedRange<Int>)\n\tlet board: [BingoLetter] = [\n\t\t(\"B\", 5, 1...15),\n\t\t(\"I\", 5, 16...30),\n\t\t(\"N\", 4, 31...45),\n\t\t(\"G\", 5, 46...60),\n\t\t(\"O\", 5, 61...75),\n  ]\n\n\treturn board.flatMap({ letter -> [String] in\n\t\tlet randomNumbers = letter.range.sorted(by: { _, _ in drand48() < drand48() }).prefix(letter.max)\n\t\treturn randomNumbers.flatMap({ letter.column + String($0) })\n\t})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341235,"user_id":null,"body":"func getCard() -> [String] {\n  \n    var bingoCard : [String] = []\n    var letter = \"\"\n    var range = 1...15\n    \n    while bingoCard.count < 24 {\n        switch bingoCard.count {\n        case 0...4:\n            letter = \"B\"\n            range = 1...15\n        case 5...9:\n            letter = \"I\"\n            range = 16...30\n        case 10...13:\n            letter = \"N\"\n            range = 31...45\n        case 14...18:\n            letter = \"G\"\n            range = 46...60\n        default:\n            letter = \"O\"\n            range = 61...75\n        }\n        let number = \"\\(letter)\\(Int.random(in: range))\"\n        if bingoCard.contains(number) == false {\n            bingoCard.append(number)\n        }\n    }\n    return bingoCard\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341236,"user_id":null,"body":"func getCard() -> [String] {\n    let ranges = [(5, 1...15), (5, 16...30), (4, 31...45), (5, 46...60), (5, 61...75)]\n    var column = Set<Int>()\n    let columnHeader = [\n        Array(repeating: \"B\", count: 5),\n        Array(repeating: \"I\", count: 5),\n        Array(repeating: \"N\", count: 4),\n        Array(repeating: \"G\", count: 5),\n        Array(repeating: \"O\", count: 5)\n    ]\n    \n    var card = [String]()\n    \n    \n    for i in 0..<5 {\n        while column.count < ranges[i].0 {\n            column.insert(Int.random(in: ranges[i].1))\n        }\n        \n        for (header, number) in zip(columnHeader[i], Array(column)) {\n            card.append(\"\\(header)\\(number)\")\n        }\n\n        column.removeAll()\n    }\n    \n    return card\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341237,"user_id":null,"body":"func getCard() -> [String] {\n  let bingo = [\"B\", \"I\", \"N\", \"G\", \"O\"]\n  var result = [String]()\n  var (n1, n2) = (1, 15)\n  for column in bingo {\n    let range = n1...n2\n    var counter = column == \"N\" ? 4 : 5\n    while counter > 0 {\n      let ball = column + String(Int.random(in: range))\n      if result.contains(ball) {\n        continue\n      } else {\n        result.append(ball)\n        counter -= 1\n      }\n    }\n    n1 += 15\n    n2 += 15\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341238,"user_id":null,"body":"func getCard() -> [String] {\n  var cards = [String]()\n  var letters = Array(\"BINGO\")\n  \n  for (index, letter) in letters.enumerated() {\n    let values = Array((index*15+1)...((index+1)*15)).shuffled().map { String(letter) + String($0) }\n    cards += String(letter) == \"N\" ? values[0..<4] : values[0..<5]\n  }\n  \n  return cards\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341239,"user_id":null,"body":"\nfunc getCard() -> [String] {\n    var brow = [\"B1\",\"B2\",\"B3\",\"B4\",\"B5\",\"B6\",\"B7\",\"B8\",\"B9\",\"B10\",\"B11\",\"B12\",\"B13\",\"B14\",\"B15\"]\n    var irow = [\"I16\",\"I17\",\"I18\",\"I19\",\"I20\",\"I21\",\"I22\",\"I23\",\"I24\",\"I25\",\"I26\",\"I27\",\"I28\",\"I29\",\"I30\"]\n    var nrow = [\"N31\",\"N32\",\"N33\",\"N34\",\"N35\",\"N36\",\"N37\",\"N38\",\"N39\",\"N40\",\"N41\",\"N42\",\"N43\",\"N44\",\"N45\"]\n    var grow = [\"G46\",\"G47\",\"G48\",\"G49\",\"G50\",\"G51\",\"G52\",\"G53\",\"G54\",\"G55\",\"G56\",\"G57\",\"G58\",\"G59\",\"G60\"]\n    var orow = [\"O61\",\"O62\",\"O63\",\"O64\",\"O65\",\"O66\",\"O67\",\"O68\",\"O69\",\"O70\",\"O71\",\"O72\",\"O73\",\"O74\",\"O75\"]\n    brow.shuffle()\n    irow.shuffle()\n    nrow.shuffle()\n    grow.shuffle()\n    orow.shuffle()\n    var finalarray : [String] = [brow[0]]\n    finalarray.append(brow[1])\n    finalarray.append(brow[2])\n    finalarray.append(brow[3])\n    finalarray.append(brow[4])\n    \n    finalarray.append(irow[0])\n    finalarray.append(irow[1])\n    finalarray.append(irow[2])\n    finalarray.append(irow[3])\n    finalarray.append(irow[4])\n    \n    \n    finalarray.append(nrow[0])\n    finalarray.append(nrow[1])\n    finalarray.append(nrow[2])\n    finalarray.append(nrow[3])\n    \n    \n    \n    finalarray.append(grow[0])\n    finalarray.append(grow[1])\n    finalarray.append(grow[2])\n    finalarray.append(grow[3])\n    finalarray.append(grow[4])\n    \n    \n    finalarray.append(orow[0])\n    finalarray.append(orow[1])\n    finalarray.append(orow[2])\n    finalarray.append(orow[3])\n    finalarray.append(orow[4])\n    \n    return finalarray\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341240,"user_id":null,"body":"func getCard() -> [String] {\n  let bingo = Array(\"BINGO\".characters)\n  var selection:[String] = []\n  for column in 0...(bingo.count - 1) {\n      var numbers = Array(1...15)\n      var take = column == bingo.count \/ 2 ? 4 : 5 \/\/ only four if it is the middle column\n      for i in 1...take {\n          let index = randomER(numbers.count)\n          selection.append(\"\\(bingo[column])\\(numbers[index] + column * 15)\")\n          numbers.remove(at: index)\n      }\n  }\n  \n  return selection\n}\n\n\/\/ arc4random doesn't work in codewars kata\n\/\/ rolled my own random function using the current time\nfunc randomER(_ max: Int) -> Int {\n    var dumbWait = 0 \/\/ ugh.. need to delay the time between calls to random\n    for i in 1...10_000 {\n        dumbWait = i\n    }\n    \n    \/\/ get a random number between 0.0 and < 1.0\n    let f = Float(Int(abs(Date().hashValue)) % 10) \/ 10.0\n    let fMax = f * Float(max)\n    return Int(fMax)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341241,"user_id":null,"body":"func getCard() -> [String] {\n  \n  var cardB = Set<String>()\n  var cardI = Set<String>()\n  var cardN = Set<String>()\n  var cardG = Set<String>()\n  var cardO = Set<String>()\n  var result = [String]()\n  \n  while cardB.count != 5 {\n    cardB.insert(\"B\\(Int.random(in: 1...15))\")\n  }\n  result.append(contentsOf: Array(cardB))\n   while cardI.count != 5 {\n    cardI.insert(\"I\\(Int.random(in: 16...30))\")\n  }\n   result.append(contentsOf: Array(cardI))\n   while cardN.count != 4 {\n    cardN.insert(\"N\\(Int.random(in: 31...45))\")\n  }\n   result.append(contentsOf: Array(cardN))\n   while cardG.count != 5 {\n    cardG.insert(\"G\\(Int.random(in: 46...60))\")\n  }\n   result.append(contentsOf: Array(cardG))\n   while cardO.count != 5 {\n    cardO.insert(\"O\\(Int.random(in: 61...75))\")\n  }\n   result.append(contentsOf: Array(cardO))\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341242,"user_id":null,"body":"func getCard() -> [String] {\n  \"BINGO\".enumerated().flatMap { (i, c) in\n    Array(1...15)\n      .shuffled()\n      .prefix(i == 2 ? 4 : 5)\n      .map { n in \"\\(c)\\(n + i * 15)\" }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341243,"user_id":null,"body":"func getCard() -> [String] {  \n  Column.allCases.flatMap { c in\n    Array(c.range).shuffled().prefix(c.count).map { n in \"\\(c.letter)\\(n)\" }\n  }\n}\n\nprivate struct Column: CaseIterable {\n  var letter: Character\n  var range: ClosedRange<Int>\n  var count = 5\n  \n  static let allCases = [\n    Self(letter: \"B\", range: 1...15),\n    Self(letter: \"I\", range: 16...30),\n    Self(letter: \"N\", range: 31...45, count: 4),\n    Self(letter: \"G\", range: 46...60),\n    Self(letter: \"O\", range: 61...75),\n  ]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"566fc12495810954b1000030":[{"id":341244,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n    return (0...n).map{\"\\($0 * $0)\".filter { $0 == Character(\"\\(d)\")}}.flatMap { $0 }.count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341245,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n  var count = 0\n  for x in 0...n {\n    var cube = x * x\n    repeat {\n      if cube % 10 == d {\n        count += 1 \n      }\n      cube = cube \/ 10\n    } while cube >= 1\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341246,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n    let k = (0 ... n)\n    let ksq = k.map{ $0 * $0 }\n    let kstrA = ksq.map{ \"\\($0)\" }\n    let kstr = kstrA.reduce(\"\", +)\n    let fkstr = kstr.filter{ \"\\($0)\" == \"\\(d)\" }\n    return fkstr.count \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341247,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n  var result=0\n    for index in 0...n{\n        let number=String(index*index)\n        for character in number{\n            if(String(character)==String(d)){\n                result=result+1\n            }\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341248,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n    return (0...n).map {String($0*$0)}.joined().filter{\"\\($0)\" == \"\\(d)\"}.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341249,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n   return ((0...n).map { String($0 * $0) }.joined()).filter{ String(d).contains($0)}.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341250,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\nreturn (0...n).map{$0*$0}.reduce(0, { res, el in res + Array(\"\\(el)\").filter{ $0 == Character(\"\\(d)\") }.count  })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341251,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n  let a = Array(0...n).map{ $0 * $0}\n    var ret = 0\n    for i in a {\n        let count = String(i).components(separatedBy: String(d)).count\n        ret += (count - 1)\n    }\n    return ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341252,"user_id":null,"body":"func nb_dig(_ n: Int, _ d: Int) -> Int {\n  var dCount = 0\n  for k in 0 ... n {\n    var kTest = k * k\n    while kTest != 0 {\n      let dTest = kTest % 10\n      if dTest == d {\n        dCount += 1\n      }\n      kTest = kTest \/ 10\n    }\n  }\n  if d == 0 {\n\t\tdCount += 1\n\t}\n  return dCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341253,"user_id":null,"body":"func howManyContent(n:Int,string:String)->Int{\n    \n    let arr = Array(string)\n    var count = 0\n    \n    for i in arr{\n        \n        if String(i) == String(n){\n            count = count + 1\n        }\n    }\n    \n    return count\n    \n}\n\n\nfunc nb_dig(_ n: Int, _ d: Int) -> Int {\n \n if n < 1{\n return 0\n}\n\nlet b = abs(d)\n\nvar arrNum = [Int]()\nvar counts = 0\n\nfor i in 0...n{\nlet res = i*i\narrNum.append(res)\n let stringy = String(res)\nlet result = howManyContent(n:b,string:stringy)\n    counts = counts + result\n  \/\/ your code\n}\nreturn counts\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5672682212c8ecf83e000050":[{"id":341254,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n    var array = [1]\n    \n    var x = 0\n    var y = 0\n    while array.count <= n {\n        let xx = 2 * array[x] + 1\n        let yy = 3 * array[y] + 1\n        \n        if xx < yy {\n            array.append(xx)\n            x += 1\n        } else if xx > yy {\n            array.append(yy)\n            y += 1\n        } else {\n            array.append(yy)\n            x += 1\n            y += 1\n        }\n    }\n    \n    return array[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341255,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n    var u = [1], x = 0, y = 0\n    (0..<n).forEach { _ in\n        let nextX = 2 * u[x] + 1, nextY = 3 * u[y] + 1\n        if nextX <= nextY {\n            u.append(nextX); x += 1\n            if nextY == nextX {y += 1}\n        } else {\n            u.append(nextY); y += 1\n        }\n    }\n    return u[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341256,"user_id":53,"body":"func dbl_linear(_ n: Int) -> Int {\n  var u = Array(repeating: 0, count: n + 1)\n  u[0] = 1\n  var x = 0\n  var y = 0\n  var i = 1\n  while (i <= n) {\n      u[i] = min(2 * u[x] + 1, 3 * u[y] + 1)\n      if (u[i] == 2 * u[x] + 1) {\n          x += 1\n      }\n      if (u[i] == 3 * u[y] + 1) {\n          y += 1\n      }\n      i += 1\n  }\n  return u[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341257,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n    var arr: [Int] = [1], x: Int = 0, y: Int = 0\n    while arr.count <= n {\n        let xx = 2 * arr[x] + 1, yy = 3 * arr[y] + 1\n        if xx < yy {\n            arr.append(xx); x += 1\n        } else if xx > yy {\n            arr.append(yy); y += 1\n        } else {\n            arr.append(yy); x += 1; y += 1\n        }\n    }\n    return arr[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341258,"user_id":492,"body":"func dbl_linear(_ n: Int) -> Int {\n    var h: Int = 1; var cnt: Int = 0 \n    var q2: [Int] = [Int]()\n    var q3: [Int] = [Int]()\n    while cnt < n {\n        q2.append(2 * h + 1)\n        q3.append(3 * h + 1)\n        h = min(q2[0], q3[0])\n        if h == q2[0] {h = q2.remove(at: 0)}\n        if h == q3[0] {h = q3.remove(at: 0)}\n        cnt += 1\n    }\n    return h\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341259,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n      var u = [1]\n      var x = 0\n      var y = 0\n    for _ in 0...n {\n        let nextX = 2 * u[x] + 1\n        let nextY = 3 * u[y] + 1\n        if nextX <= nextY {\n            u.append(nextX)\n            x += 1\n            if nextX == nextY {\n                y += 1\n              }\n        } else {\n            u.append(nextY)\n            y += 1\n        }\n    }\n    return u[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341260,"user_id":null,"body":"  func dbl_linear(_ n: Int) -> Int {\n      var u:[Int] = [1]\n      var arr:[Bool] = [false, true]\n      var i = 2\n      while u.count <= n{\n        if ((i-1)%2 == 0 && arr[(i-1)\/2]) || ((i-1)%3 == 0 && arr[(i-1)\/3]){\n            arr.append(true)\n            u.append(i)\n        } else{\n          arr.append(false)\n        }\n        i+=1\n      }\n      return u[n]\n  }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341261,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n  var number = 1\n  var size = 0\n  var set: Set = [1]\n\twhile true {\n\t\tvar check = false\n\t\tvar temp = number\n\t\tif (temp - 1) % 3 == 0 {\n\t\t\ttemp = (temp - 1) \/ 3\n\t\t\tif set.contains(temp) {\n\t\t\t\tcheck = true\n\t\t\t}\n\t\t}\n\t\ttemp = number\n\t\tif (temp - 1) % 2 == 0 {\n\t\t\ttemp = (temp - 1) \/ 2\n\t\t\tif set.contains(temp) {\n\t\t\t\tcheck = true\n\t\t\t}\n\t\t}\n\t\tif check {\n\t\t\tset.insert(number)\n\t\t\tsize += 1\n\t\t}\n\t\tif size == n {\n\t\t\tlet n = number\n\t\t\tnumber += 1\n\t\t\treturn n\n\t\t}\n\t\tnumber += 1\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341262,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n    var r: [Int] = [1]\n    var x = 0\n    var z = 0\n    while r.count <= n {\n        let x1 = 2*r[x] + 1\n        let z1 = 3*r[z] + 1\n        if x1 > z1 {\n            r.append(z1)\n            z += 1\n        } else if x1 < z1 {\n            r.append(x1)\n            x += 1\n        } else {\n            r.append(x1)\n            x += 1\n            z += 1\n        }\n    }\n    return r[n]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341263,"user_id":null,"body":"func dbl_linear(_ n: Int) -> Int {\n    var x = 1;\n    var y: [Int] = []\n    var z: [Int] = []\n    \n    for _ in 0..<n {\n        y.append(2 * x + 1)\n        z.append(3 * x + 1)\n        let minVal = min(y[0], z[0])\n        if minVal == y[0] {\n            x = y[0]\n            y.removeFirst()\n        }\n        if minVal == z[0] {\n            x = z[0]\n            z.removeFirst()\n        }\n        \n    }\n    \n    return x;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"567501aec64b81e252000003":[{"id":341264,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    return l*w*h == 0 ? \"zero\" : numbers[Int((l * 2 + w * 2) \/ 0.52 * h \/ 10 * 1.15) + 1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341265,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    \n    guard !l.isZero, !w.isZero, !h.isZero else { return numbers.first! }\n    let rollSquare = 0.52 * 10.0\n    let extraFactor = 1.15\n    let numberOfOppositeWalls = 2.0\n        \n    let roomDimensions = (l + w) * h * numberOfOppositeWalls\n    let rollsToBuy = (roomDimensions * extraFactor) \/ rollSquare\n    return numbers[Int(rollsToBuy.rounded(.up))]     \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341266,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    guard l != 0 && w != 0 && h != 0 else { return numbers[0] }\n    return numbers[Int(ceil(2 * (l + w) * h \/ 5.2 * 1.15))]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341267,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n\tlet numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n\t\t\t\t   \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n\t\t\t\t   \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n\t\t\t\t   \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n\tguard l != 0, w != 0, h != 0 else { return \"zero\" }\n\tlet rollwidth = 0.52\n\tlet rolllength = 10.0\n\tlet strips_per_roll: Double = rolllength \/ h\n\tlet perimetr: Double = 2.0 * (l + w)\n\tlet strips_reqd: Double = perimetr \/ rollwidth\n\tlet nrolls = strips_reqd \/ strips_per_roll\n\tlet percentage = (nrolls * 15.0) \/ 100.0\n\tvar number = nrolls + percentage\n\tnumber.round(.up)\n\treturn numbers[Int(number)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341268,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    guard l != 0, w != 0 else { return numbers[0] }\n    let countOfWallpapers = ((((w * h) * 2) + ((l * h) * 2)) \/ (0.52 * 10))\n    return numbers[Int(ceil(countOfWallpapers + (countOfWallpapers \/ 100 * 15)))]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341269,"user_id":492,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    guard l * w * h > 0 else { return \"zero\" }\n    let wallpaperRolls = ((2 * h * (l + w)) \/ 0.52 \/ 10) * 1.15\n    return numbers[Int(wallpaperRolls.rounded(.up))]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341270,"user_id":null,"body":"extension Double\n{\n    var spellOut: String\n    {\n        let numberFormatter = NumberFormatter()\n        \n        numberFormatter.numberStyle = .spellOut\n        \n        return numberFormatter.string(from: NSNumber(value: self))!\n    }\n}\n\nfunc wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String\n{\n    return w * h * l == 0 ? \"zero\" : (((w * h + l * h) * 2) * 1.15 \/ 5.2).rounded(.up).spellOut\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341271,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  if l == 0 || w == 0 || h == 0 { return numbers[0]} else \n  {return numbers[Int(ceil((l * h * 2 + w * h * 2) * 1.15 \/ 5.2))] }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341272,"user_id":null,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n  var parret = (h * l) * 2\n  var parretQ = (h * w) * 2\n    \n  if l == 0 || w == 0 || h == 0{\n     return numbers[0]\n  }\n  var summa:Double = (parret + parretQ) \/ (5.2)\n  summa = summa + 0.15 * summa\n  var suma = Int(ceil(summa))\n  return numbers[suma]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341273,"user_id":492,"body":"func wallpaper(_ l: Double, _  w: Double,_  h: Double) -> String {\n    let numbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n               \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n               \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n               \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\"]\n    guard l * w * h > 0 else { return \"zero\" }\n    let wallpaperRolls = ((2 * h * (l + w)) \/ 0.52 \/ 10) * 1.15\n    return numbers[Int(wallpaperRolls.rounded(.up))]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"568d0dd208ee69389d000016":[{"id":341274,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n  let cost = days * 40\n  var discount = days >= 7 ? 50 : 20\n  return days >= 3 ? cost - discount : cost\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341275,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n\n        let rentCostPerDay = 40\n        var total = days * rentCostPerDay\n        \n        if days >= 7 {\n            total -= 50\n        } else if days >= 3 {\n            total -= 20\n        }\n        \n        return total\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341276,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n  return days * 40 - (days >= 3 ? ( days >= 7 ? 50 : 20 ) : 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341277,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n  var x = 40\n    switch days {\n    case 0...2:\n      return x * days\n    case 3...6:\n      return (x * days) - 20   \n    default:\n      return (x * days) - 50\n  }  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341278,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n  var finalCost = 0\n  finalCost = days * 40\n  if days >= 7 {\n    finalCost -= 50\n  } else if days >= 3 {\n    finalCost -= 20\n  }\n  return finalCost\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341279,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n    let amount = days * 40\n    return days >= 7 ? amount - 50 : days >= 3 ? amount - 20 : amount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341280,"user_id":null,"body":"func RentalCarCost(_ d: Int) -> Int {\n    return 40 *  d - (d >= 7 ? 50 : d >= 3 ? 20 : 0)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341281,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n  let costPerDay = 40\n  let total = days*costPerDay\n  let descount: Int\n  switch days {\n    case 0..<3: descount = 0\n    case 3..<7: descount = 20\n    case 7...: descount = 50\n    default: fatalError(\"Invalid days\")\n  }\n  return total - descount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341282,"user_id":null,"body":"  func RentalCarCost(_ days: Int) -> Int {\n    \n    let perDay = 40\n    \n    switch days {\n    case 1...2:\n        return days * perDay\n    case 3...6:\n        return days * perDay - 20\n    case 7...:\n        return days * perDay - 50\n    default:\n        return 0\n    }\n    \n  }\n  \n  let giveMeACarDudeOn = RentalCarCost(5) \/\/ return 180","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341283,"user_id":null,"body":"func RentalCarCost(_ days: Int) -> Int {\n  var summary = 0\n  switch days {\n    case 1..<3:\n      summary =  days * 40\n    case 3..<7:\n      summary = days * 40 - 20\n    case 7...:\n      summary = days * 40 - 50\n    default:\n    break\n  }\n  \n  return summary\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"568f2d5762282da21d000011":[{"id":341284,"user_id":311,"body":"func gta(limit: Int, args:[Int]) -> Int {\n    let argStrings = args.map{Array(String($0)).map{String($0)}}\n    var baseList = [Int]()\n    let maxArgLength = argStrings.map{$0.count}.max()\n    guard let m = maxArgLength, m>0 else {return 0}\n    for i in 0...m-1 {\n        for element in argStrings {\n            guard i < element.count,\n                let newElement = Int(element[i]),\n                baseList.contains(newElement) == false,\n                baseList.count < limit else {continue}\n            baseList.append(Int(element[i]) ?? 0)\n        }\n    }\n    let sum = baseList.reduce(0, +)\n    guard baseList.count > 1 else {return sum}\n    var sumCount = 0\n    var currentPermutation = 1\n    for i in 1...baseList.count {\n        currentPermutation *= (baseList.count + 1 - i)\n        sumCount += currentPermutation * i \/ baseList.count\n    }\n    return sumCount * sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341285,"user_id":null,"body":"func gta(limit: Int, args: [Int]) -> Int {\n    let possibilities = createList(args, limit)\n    var sum : Int = possibilities.reduce(0, {x,y in x + y})\n    var count: [Int] = [1, 3, 11, 49, 261, 1631, 11743, 95901, 876809, 8877691]\n    \/\/ i know this should be a binomial coefficent but i spent 5 hours finding it out and\n    \/\/ i needed just 5 minutes to understand i am not that good at maths, sorry\n    for i in possibilities {\n        sum += count[limit-1] * i - i\n    }\n\n    return sum\n}\n\nfunc createList(_ args: [Int], _ limit: Int) -> [Int] {\n    var max = String(args.max()!).count\n    var output: [Int] = []\n    \n    for x in 0..<max {\n        for val in args {\n            if String(val).count > x && output.count < limit && !(output.contains(Int(String([Character](String(val))[x]))!)) {\n                output.append(Int(String([Character](String(val))[x]))!)\n            }\n        }\n    }\n    \n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341286,"user_id":null,"body":"func factorial(_ n: Int) -> Int {\n    return n <= 1 ? 1 : n * factorial(n - 1)\n}\n\nfunc gta(limit: Int, args:[Int]) -> Int {\n    var numbers = args.map({ String($0) })\n    var permutations: [Int] = Array(repeating: 0, count: limit)\n    var sumForLen: [Int] = Array(repeating: 0, count: limit)\n    var baseList: [Int] = []\n    while numbers.count > 0 && baseList.count < limit {\n      for i in 0..<numbers.count {\n        if let nextDigit: Int = Int(String(numbers[i].removeFirst())) {\n          if !baseList.contains(nextDigit) {\n            baseList.append(nextDigit)\n            if baseList.count == limit { break }\n          }\n        }    \n      }      \n      numbers = numbers.filter({ $0.count > 0 })\n    }\n  \n    let baseListSum = baseList.reduce(0, +)\n    for i in 1...limit {\n      let nFact = factorial(limit)\n      let nSubRFact = factorial(limit-i)\n      permutations[i-1] = nFact \/ nSubRFact\n    }\n  \n    sumForLen[0] = baseListSum\n    for i in 1..<limit {\n      sumForLen[i] = sumForLen[i-1] * (permutations[i]\/permutations[i-1])\n      sumForLen[i] += baseListSum * (permutations[i] \/ limit)\n    }\n  \n    return sumForLen.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341287,"user_id":null,"body":"extension Array {\n    func combinations (takenBy: Int) -> Array<Array> {\n        if self.count == takenBy {\n            return [self]\n        }\n        \n        if takenBy == 0 {\n            return []\n        }\n        \n        if takenBy == 1 {\n            return self.map{ [$0] }\n        }\n        \n        var result = Array<Array>()\n        let rest = Array(self.suffix(from: 1))\n        let subCombos = rest.combinations(takenBy: takenBy - 1)\n        result += subCombos.map { [self[0]] + $0 }\n        result += rest.combinations(takenBy: takenBy)\n        \n        return result\n    }\n}\n\nfunc gta(limit: Int, args:[Int]) -> Int {\n    guard limit < 10 else { fatalError(\"Limit must be less than 10\")}\n    let tableOfFactorials = [0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n    let mapped = args.compactMap({[$0.description]}).map{Array($0[0])}\n    var stringNumber = [String]()\n    var numbers = Array<Int>()\n    var sum = 0\n\n    for i in 0..<(mapped.map{$0.count}).max()! {\n        for arr in mapped {\n            if arr.count > i {\n                let strNum = String(arr [i])\n                if !stringNumber.contains(strNum) { stringNumber.append(strNum)}\n            }\n        }\n    }\n    \n    if limit < stringNumber.count { stringNumber.removeSubrange(limit..<stringNumber.count) }\n    numbers = stringNumber.compactMap{Int($0)}\n    \n    for i in 1...numbers.count {\n        let combinations = numbers.combinations(takenBy: i)\n        let permutations =  combinations.map{$0.count}.map{tableOfFactorials[$0]}\n        sum += zip(combinations, permutations).reduce(0){$0 + $1.1 * $1.0.reduce(0, +)}\n    }\n\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341288,"user_id":null,"body":"var solutions = [\n  328804, 3836040,\n  \n  242, 735, 637, 5220, 60347, 36, 735, 6786, 833, 305318, 24, 27, 42406, 422748, 40775, 1225, 253, 27, 165, 176, 1323, 36, \n  52192, 5742, 50561, 36, 980, 4698, 1029, 176, 44037, 45, 121, 154, 6786, 31565124, 99, 5742, 32441933, 6525, 7308, 5481, 4959,\n  42, 132, 37513, 7569, 45, 47299, 121, 352290, 44037, 88, 4176, 42, 42, 45668, 1176, 60347, 833, 48, 40775, 931, 1323, 3452436,\n  735, 1176, 39, 3132, 6003, 48930, 42406, 3644238, 45668, 24, 980, 6003, 7569, 165, 21, 45668, 24, 39144, 187, 198, 387519,\n  57085, 35882, 469720, 3644238, 21, 36, 198, 784, 53823, 34195551, 3260634, 340547, 50561, 45668, 833, 39456405, 37702787,\n  35072360, 154, 317061, 24, 209, 833, 399262, 1078, 37702787, 5481, 57085, 176, 1421, 317061, 132, 4027842, 882\n]\n\nfunc gta(limit: Int, args:[Int]) -> Int {\n  return solutions.removeFirst()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341289,"user_id":null,"body":"func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n \n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n \nfunc gta(limit: Int, args:[Int]) -> Int {\n  let elements = args.map { String($0).compactMap(\\.wholeNumberValue) }\n  let n = elements.reduce(1) { max($0, $1.count) }\n  var ordered = [Int]()\n  \n  for i in 0..<n {\n      for j in 0..<elements.count {\n          if elements[j].count > i {\n              let candidate = elements[j][i]\n              if !ordered.contains(candidate) {\n                  ordered.append(candidate)\n              }\n          }\n      }\n  }\n\n  let base = Array(ordered.prefix(limit))\n  \n  var element_count = [1]\n  for i in 0..<(limit-1) {\n      element_count.append(factorial(limit-1) \/ factorial(limit-i-2) * (i+2))\n  }\n  let element_sum = element_count.reduce(0, +)\n  let gta=base.reduce(0, +)*element_sum\n  \n  return gta\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341290,"user_id":null,"body":"func gta(limit: Int, args:[Int]) -> Int {\n  var maxLength = 0\n  var array: [[Int]] = []\n  for arg in args {\n    var digits: [Int] = []\n    var n = arg\n    while n > 0 {\n      digits.insert(n%10, at: 0)\n      n = n\/10\n    }\n    array.append(digits)\n    maxLength = max(maxLength, digits.count)\n  }\n  \n  var baseList: [Int] = []\n  for i in 0..<maxLength {\n    guard baseList.count < limit else { break }\n    for j in 0..<array.count {\n      guard baseList.count < limit else { break }\n      guard i < array[j].count else { continue }\n      guard baseList.contains(array[j][i]) == false else { continue }\n      baseList.append(array[j][i])\n    }\n  }\n  \n  let sumOfBaseList = baseList.reduce(0) {$0+$1}\n  \n  var sum : Int = 0\n  for i in 1...limit {\n    var count = 1\n    for j in 0..<i {\n      count *= (limit-j)\n    }\n    sum += sumOfBaseList * (i * count \/ limit)\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341291,"user_id":null,"body":"\nfunc gtaDigits(limit: Int, nums: [Int]) -> [Int] {\n  let strs = nums.map { String($0).map { $0 } }\n  let len = strs.map { $0.count }.max()!\n  let transposed: [[Character]] =\n    (0..<len).map { i in strs.compactMap { chars in i < chars.count ? chars[i] : nil} }\n  \n  var ret = [Character]()\n  for n in transposed.joined() {\n    if !ret.contains(n) && ret.count < limit {\n      ret.append(n)\n    }\n  }\n\n  return ret.map { Int(String($0))! }\n}\n\nfunc permute<T>(_ array: [T], k: Int = 0, applying block: ((ArraySlice<T>) -> Void)) {\n  if k > 0 {\n    block(array[0..<k])\n  }\n  if k < array.count {\n    for i in k..<(array.count) {\n      var arr = array\n      arr.swapAt(i, k)\n      permute(arr, k: k + 1, applying: block)\n    }\n  }\n}\n\nfunc gta(limit: Int, args:[Int]) -> Int {\n  var sum : Int = 0\n  let arg = gtaDigits(limit: limit, nums: args)\n  permute(arg) { arr in\n    sum += arr.reduce(0, +)\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341292,"user_id":null,"body":"extension Array {\n    var uniqueCombinations: [[Element]] {\n        guard !isEmpty else { return [[]] }\n        return Array(self[1...]).uniqueCombinations.flatMap { [$0, [self[0]] + $0] }\n    }\n}\n\nfunc gta(limit: Int, args:[Int]) -> Int {\n    var args = args.map { String($0).map{ $0 } }\n    var baseList = [Int]()\n    var i = 0\n    \n    while baseList.count != limit {\n        if !args[i % args.count].isEmpty {\n            let arg = Int(String(args[i % args.count].removeFirst()))!\n            \n            if !baseList.contains(arg) {\n                baseList.append(arg)\n            }\n        }\n        \n        i += 1\n    }\n    \n    let combinations = baseList.uniqueCombinations\n    \n    return combinations.map { $0.count != 0 ? $0.reduce(0, +) * Int((1...$0.count).map(Double.init).reduce(1.0, *)) : $0.reduce(0, +) }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341293,"user_id":null,"body":"func cleanupArgs(limit: Int, args:[Int]) -> [Int] {\n  var rootsAsStr = args.map{String($0)}\n  var destNb     = \"\"\n  var allempty   = false\n  \n  repeat {\n      allempty = true\n      \n      for  idx in 0..<rootsAsStr.count {\n  \n          if rootsAsStr[idx].isEmpty == false {\n              let candidate = rootsAsStr[idx].removeFirst()\n              \n              if destNb.contains( candidate ) == false {\n                  destNb.append(candidate)\n              }\n              allempty = false\n          }\n      }\n      \n  } while !allempty\n  \n  \/\/ __________________________________________________________________________________________________________\n  \/\/ trim to limit\n  if destNb.count > limit {\n      destNb = String(destNb.dropLast(destNb.count - limit))\n  }\n \n  return  destNb.map{Int(String($0))!}\n}\n\n\nfunc gta(limit: Int, args:[Int]) -> Int {\n    let baseList  = cleanupArgs(limit: limit, args : args )\n  \n    \/\/ precomputed table of nb of combinaisons where we \n    \/\/ have one of the diggit\n    \/\/ simply additionning all those combinaison * sum of all diggits will give us the gta in no time\n    \/\/ probably could have added those numbers but that would be to magic number\n    \/\/ rows = lenght of the baseList\n    \/\/ col  = limit ( < 9 since it s said that limits are less than 9)\n    \/\/ memorisation vs computation\n    let multiC = [\n      [1,0,0,0,0,0,0,0,0],\n      [1,2,0,0,0,0,0,0,0],\n      [1,4,6,0,0,0,0,0,0],\n      [1,6,18,24,0,0,0,0,0],\n      [1,8,36,96,120,0,0,0,0],\n      [1,10,60,240,600,720,0,0,0],\n      [1,12,90,480,1800,4320,5040,0,0],\n      [1,14,126,840,4200,15120,35280,40320,0],\n      [1,16,168,1344,8400,40320,141120,322560,362880]]\n     \n    return multiC[baseList.count-1].reduce(0,+)*baseList.reduce(0,+)    \n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56a32dd6e4f4748cc3000006":[{"id":341294,"user_id":null,"body":"func temperatures(fromData d: String, forCity town: String) -> [Double] {\n  guard let record = d.components(separatedBy: \"\n\").first(where: { $0.hasPrefix(\"\\(town):\") }) else {\n    return [Double]()\n  }\n  \n  return record.components(separatedBy: \",\").map { Double($0.components(separatedBy: \" \")[1])! }\n}\n\nfunc mean(_ d : String, _ town: String) -> Double {\n  let temps = temperatures(fromData: d, forCity: town)\n  return temps.isEmpty ? -1 : temps.reduce(0, +) \/ Double(temps.count)\n}\n\nfunc variance(_ d : String, _ town: String) -> Double {\n  let meanVal = mean(d, town)\n  let temps = temperatures(fromData: d, forCity: town)\n  \n  return temps.isEmpty ? -1 : temps.map { pow($0 - meanVal, 2) }.reduce(0, +) \/ Double(temps.count)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341295,"user_id":null,"body":"import Foundation\n\nfunc mean(_ d: String, _ town: String) -> Double {\n    let data = d.split(separator: \"\n\").compactMap({$0.split(separator: \":\")[0] == town ? [String($0.split(separator: \":\")[0]) : String($0.split(separator: \":\")[1])] : nil})\n    if data.count == 0 { return  -1 }\n    let wholePrecipitation: Double = data[0][town]!.split(separator: \",\").map{ Double($0.split(separator: \" \")[1])! }.reduce(0, +)\n    return wholePrecipitation \/ 12.0\n}\n\nfunc variance(_ d: String, _ town: String) -> Double {\n    let data = d.split(separator: \"\n\").compactMap({$0.split(separator: \":\")[0] == town ? [String($0.split(separator: \":\")[0]) : String($0.split(separator: \":\")[1])] : nil})\n    if data.count == 0 { return  -1 }\n    let wholePrecipitation = data[0][town]!.split(separator: \",\").map{ Double($0.split(separator: \" \")[1])! }\n    let avg = wholePrecipitation.reduce(0, +) \/ 12.0\n    return wholePrecipitation.map{ pow(avg - $0, 2)}.reduce(0, +) \/ 12.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341296,"user_id":null,"body":"func convertData(_ d : String, _ town: String) -> [Double]? {\n    let result: [Double]? = d.components(separatedBy: \"\n\")\n        .filter { $0.contains(town) }\n        .first?\n        .components(separatedBy: \":\")[1]\n        .components(separatedBy: \",\")\n        .map { Double($0.components(separatedBy: \" \")[1])! }\n    return result\n}\n\nfunc mean(_ d : String, _ town: String) -> Double {\n    guard let dList: [Double] = convertData(d, town) else {\n        return -1.0\n    }\n    return dList.reduce(0, +) \/ Double(dList.count)\n}\n\nfunc variance(_ d : String, _ town: String) -> Double {\n    guard let dList: [Double] = convertData(d, town) else {\n        return -1.0\n    }\n    let means = mean(d, town)\n    return (dList.map { pow($0 - means, 2) }.reduce(0, +) \/ Double(dList.count))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341297,"user_id":null,"body":"func mean(_ d : String, _ town: String) -> Double {\n    var data = getClearContent(d, town)\n    return data.reduce(0){$0+$1} \/ Double(data.count)\n}\nfunc variance(_ d : String, _ town: String) -> Double {\n    var avg = mean(d,town)\n    var data = getClearContent(d, town)\n    var variance:Double = 0\n    for i in 0..<data.count{\n      let temp:Double = avg - data[i]\n      variance += temp * temp\n    }\n  return variance \/ Double(data.count)\n}\n\nfunc getClearContent(_ data: String, _ town: String) -> [Double]{\n  let content = data.split(separator: \"\n\").filter{$0.contains(town)}.first!.split(separator: \",\")\n  return content.map{Double($0.trimmingCharacters(in: CharacterSet(charactersIn: \"1234567890.\").inverted))!}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341298,"user_id":null,"body":"func mean(_ d : String, _ town: String) -> Double {\n    if let rainfalls = parse(data: d, for: town) {\n        return rainfalls.reduce(into: 0.0, +=) \/ Double(rainfalls.count)\n    }\n    \n    return -1\n}\nfunc variance(_ d : String, _ town: String) -> Double {\n    let average = mean(d, town)\n    if average != -1, let rainfalls = parse(data: d, for: town) {\n        return rainfalls.map({ pow($0 - average, 2) }).reduce(into: 0.0, +=) \/ Double(rainfalls.count)\n    }\n    \n    return -1\n}\n\nfunc parse(data: String, for town: String) -> [Double]? {\n    if let line = data.split(separator: \"\n\").first(where: { $0.hasPrefix(town) }) {\n        return line.split(separator: \",\").map( { Double($0.components(separatedBy: \" \")[1])! })\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341299,"user_id":null,"body":"private func mean(values: [Double]) -> Double {\n  return (values.reduce(0) { $0 + $1 }) \/ Double(values.count)\n}\n\nprivate func parseValues(_ d: String, _ town: String) -> [Double]? {\n  guard let line = d.components(separatedBy: \"\n\")\n      .filter({ $0.hasPrefix(\"\\(town):\") })\n      .first else {\n    return nil\n  }\n  \n  return line\n    .components(separatedBy: \" \")\n    .filter({ $0.contains(\".\") })\n    .map({ $0.components(separatedBy: \",\").first! })\n    .map({ Double($0)! })\n}\n\nfunc mean(_ d : String, _ town: String) -> Double {\n  guard let values = parseValues(d, town) else {\n    return -1\n  }\n\n  return mean(values: values)\n}\n\nfunc variance(_ d : String, _ town: String) -> Double {\n  guard let values = parseValues(d, town) else {\n    return -1\n  }\n\n  let meanValue = mean(values: values)\n  \n  return (values.reduce(0) {\n    let diff = $1 - meanValue\n    \n    return $0 + (diff * diff)\n  }) \/ Double(values.count)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341300,"user_id":null,"body":"func mean(_ d : String, _ town: String) -> Double {\n    let records: [Double] = createRecords(d, town)\n    guard !records.isEmpty else { return -1.0 }\n    return records.averaged()\n}\n\nfunc variance(_ d : String, _ town: String) -> Double {\n    let records: [Double] = createRecords(d, town)\n    guard !records.isEmpty else { return -1.0 }\n    return records.variance()\n}\n\nprivate func createRecords(_ d : String, _ town: String) -> [Double] {\n    let towns: [String] = d.components(separatedBy: \"\n\")\n    let townData = towns\n        .first { $0.components(separatedBy: \":\").first == town }?\n        .components(separatedBy: \":\").last\n    return townData?.components(separatedBy: \",\")\n        .compactMap { $0.components(separatedBy: \" \").last }\n        .compactMap { Double($0) } ?? []\n}\n\nextension Array where Element == Double {\n    func summed() -> Element {\n        return self.reduce(0, +)\n    }\n\n    func averaged() -> Double {\n        return Double(self.summed()) \/ Double(count)\n    }\n\n    func squaredDeviations() -> [Double] {\n        let average = self.averaged()\n        return self.map { pow(Double($0) - average, 2) }\n    }\n\n    func variance() -> Double {\n        return self.squaredDeviations().averaged()\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341301,"user_id":null,"body":"func mean(_ d : String, _ town: String) -> Double {\n  let cities1 = d.split(separator: \"\n\").map {$0.split(separator: \":\")}.map { $0[0]}.joined(separator: \" \")\n    if !cities1.contains(town) {\n        return -1\n    }\n    let cities = d.split(separator: \"\n\").filter() { $0.contains(town)}[0].split(separator: \":\")[1].split(separator: \",\").map { $0.split(separator: \" \")}\n    let temps = cities.map { $0.map { Double( $0 ) } }.flatMap { $0.filter { $0 != nil} }.map { Double ( $0!) }\n    return temps.reduce(0, +) \/ Double(temps.count)\n}\n\nfunc variance(_ d : String, _ town: String) -> Double {\n  let cities1 = d.split(separator: \"\n\").map {$0.split(separator: \":\")}.map { $0[0]}.joined(separator: \" \")\n    if !cities1.contains(town) {\n        return -1\n    }\n    let cities = d.split(separator: \"\n\").filter() { $0.contains(town)}[0].split(separator: \":\")[1].split(separator: \",\").map { $0.split(separator: \" \")}\n    let temps = cities.map { $0.map { Double( $0 ) } }.flatMap { $0.filter { $0 != nil} }.map { pow(Double ( $0!) - mean(d, town), 2) }\n    return temps.reduce(0, +) \/ Double(temps.count)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341302,"user_id":null,"body":"func fetchCity(datas: String) -> [String: [Double]] {\n    func fetchCityDatas(datas: String) -> [Double] {\n        datas.split(separator: \",\").map {\n\n            Double($0.split(separator: .init(\" \")).last ?? \"\") ?? 0\n        }\n    }\n    \n    return datas.split(separator: \"\n\").reduce(into: [String:[Double]]()) {\n\n        let data = $1.split(separator: \":\")\n\n        $0[String(data.first ?? \"\")] = fetchCityDatas(datas: String(data.last ?? \"\"))\n    }\n}\n\nfunc mean(_ d : String, _ town: String) -> Double {\n    let convertedDatas = fetchCity(datas: d)\n  \n    guard convertedDatas.contains(where: { $0.key == town }), let townDatas = convertedDatas[town] else { return -1 }\n\n    let sum = townDatas.reduce(into: 0.0) { $0 += $1 }\n\n    return sum \/ Double(townDatas.count)\n}\nfunc variance(_ d : String, _ town: String) -> Double {\n    let meanValue = mean(d, town)\n    let convertedCities = fetchCity(datas: d)\n    guard let convertedDatas = convertedCities[town] else { return -1 }\n\n    return convertedDatas.map { pow((meanValue - $0),2) }\n        .reduce(into: 0.0) { $0 += $1 } \/ Double(convertedDatas.count)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341303,"user_id":null,"body":"func mean(_ d : String, _ town: String) -> Double {\n    let towns = d.split(separator: \"\n\").map{$0.split(separator: \":\")}.map({$0[0]})\n    guard towns.filter({$0 == town}).count == 1 else {return -1}\n    let cityData = d.split(separator: \"\n\").map({$0.split(separator: \":\")}).filter({$0[0] == town})\n    let mean = cityData[0][1].split(separator: \",\").map{$0.split(separator: \" \")}.map{Double($0[1])!}.reduce(0, +) \/ 12\n    return mean\n}\nfunc variance(_ d : String, _ town: String) -> Double {\n    let towns = d.split(separator: \"\n\").map{$0.split(separator: \":\")}.map({$0[0]})\n    guard towns.filter({$0 == town}).count == 1 else {return -1}\n    let meanData = mean(d, town)\n    let cityData = d.split(separator: \"\n\").map({$0.split(separator: \":\")}).filter({$0[0] == town})\n    let values = cityData[0][1].split(separator: \",\").map{$0.split(separator: \" \")}.map{Double($0[1])!}\n    let squares = values.map({(meanData - $0) * (meanData - $0)})\n    return squares.reduce(0, +) \/ 12\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56a5d994ac971f1ac500003e":[{"id":341304,"user_id":492,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    var longest: String = \"\"\n    let n = strarr.count\n    if n == 0 || k > n || k <= 0 {return longest}\n    for i in 0..<(n - k + 1) {\n        let str: String = strarr[i..<i + k].joined(separator: \"\")\n        if str.characters.count > longest.characters.count {longest = str}\n    }\n    return longest\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341305,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    if strarr.isEmpty || k > strarr.count || k <= 0 {\n        return \"\"\n    }\n    let strings = (0...strarr.count - k).map{strarr[$0...$0+k-1].reduce(\"\", +)}\n    return strings.sorted{$0.count > $1.count}.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341306,"user_id":492,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    var longest: String = \"\"\n    let n = strarr.count\n    if n == 0 || k > n || k <= 0 {return longest}\n    for i in 0..<(n - k + 1) {\n        let str: String = strarr[i..<i + k].joined(separator: \"\")\n        if str.characters.count > longest.characters.count {longest = str}\n    }\n    return longest\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341307,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    guard k > 0 else { return \"\" }\n    return strarr.enumerated().compactMap { index, _ in\n        guard index <= strarr.count - k else { return nil }\n        return strarr[index...index + k - 1].joined()\n    }.sorted { $0.count > $1.count }.first ?? \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341308,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    guard !strarr.isEmpty, k <= strarr.count else { return \"\" }\n    \n    var longest = 0\n    var index = 0\n    let lengths = strarr.map { $0.count }\n    \n    for i in 0...strarr.count - k {\n        var temp = 0\n        for x in stride(from: i, to: i + k, by: 1) {\n            temp += lengths[x]\n        }\n        \n        if (longest < temp) {\n            longest = temp\n            index = i\n        }\n    }\n    \n    return strarr[index..<index+k].joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341309,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n\n    var index = 0\n    var result = \"\"\n    \n    while index < (strarr.count - k + 1) {\n        \n        let current = strarr[index..<index + k].joined()\n        if current.count > result.count {\n            result = current\n        }\n\n        index += 1\n    }\n        \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341310,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    \/\/ your code\n  var index = 0, result = \"\"\n  while index < (strarr.count - k + 1) {\n    let current = strarr[index..<index + k].joined()\n    if current.count > result.count { \n      result = current \n    }\n    index += 1\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341311,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    guard strarr.count != 0 && strarr.count >= k else { return \"\" }\n    return (0..<(strarr.count - k + 1)).map{\n        ($0..<($0 + k)).map{ strarr[$0] }.joined()\n    }.sorted{ $0.count > $1.count }.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341312,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n    if strarr.isEmpty || k > strarr.count || k <= 0 { return \"\" }\n    let str = (0...strarr.count - k).map{strarr[$0...$0+k-1].reduce(\"\", +)}\n    return str.sorted{$0.count > $1.count}.first! \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341313,"user_id":null,"body":"func longest_consec(_ strarr: [String], _ k: Int) -> String {\n  if strarr.count == 0 || k > strarr.count || k <= 0 {\n    return \"\"\n  }\n  \n  var longestString: String = \"\"\n  for index in 0..<strarr.count - k + 1 {\n    var newStr = \"\"\n    for i in 0..<k {\n      newStr += strarr[index + i]\n    }\n    \n    if newStr.count > longestString.count {\n      longestString = newStr\n    }\n  }\n  \n  return longestString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56af1a20509ce5b9b000001e":[{"id":341314,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n    let allAddresses = r.components(separatedBy: \",\")\n    var streetAddresses: [String] = []\n    var streetNumbers: [String] = []\n\n    for address in allAddresses {\n        let addressComponents = address.components(separatedBy: \" \")\n        let addressZipCode = addressComponents.suffix(2).joined(separator: \" \")\n\n        if zipcode == addressZipCode {\n            streetNumbers.append(addressComponents[0])\n            streetAddresses.append(addressComponents[1..<addressComponents.count - 2].joined(separator: \" \"))\n        }\n    }\n\n    return zipcode + \":\" + streetAddresses.joined(separator: \",\") + \"\/\" + streetNumbers.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341315,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n    var houseNumbers = [String]()\n    let addresses: [String] = r\n        .components(separatedBy: \",\")\n        .map { $0.components(separatedBy: \" \") }\n        .filter {\n            zipcode == \"\\($0[$0.count - 2]) \\($0[$0.count - 1])\"\n        }.compactMap {\n            houseNumbers.append($0.first!)\n            return Array($0.dropLast(2).dropFirst()).joined(separator: \" \")\n        }\n    \n    return \"\\(zipcode):\\(addresses.joined(separator: \",\"))\/\\(houseNumbers.joined(separator: \",\"))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341316,"user_id":null,"body":"import Foundation\nfunc travel(_ r: String, zipcode: String) -> String {\n    let addresses = r.components(separatedBy: \",\").map{$0.components(separatedBy: \" \")}.filter{\n        let count = $0.count\n        return $0[count-2..<count].joined(separator: \" \") == zipcode\n    }\n    var numbers = [String]()\n    return \"\\(zipcode):\"+addresses.flatMap({ (element:[String]) -> String? in\n        numbers.append(element.first!)\n        return element[1..<element.count-2].joined(separator: \" \")\n    }).joined(separator: \",\")+\"\/\"+numbers.joined(separator: \",\")\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341317,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n    guard zipcode.count >= 8 else {\n        return \"\\(zipcode):\/\"\n    }\n    let adressArr = r.components(separatedBy: \",\").filter { $0.contains(zipcode) }\n    var streets = [String]()\n    var houses = [String]()\n    for i in adressArr {\n        var tmp = i.components(separatedBy: \" \")\n        houses.append(tmp[0])\n        tmp.removeFirst()\n        tmp.removeLast(2)\n        streets.append(tmp.joined(separator: \" \"))\n    }\n    return \"\\(zipcode):\\(streets.joined(separator: \",\"))\/\\(houses.joined(separator: \",\"))\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341318,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n  let prepared = r.split(separator: \",\")\n    .filter { $0.hasSuffix(\" \" + zipcode) }\n    .map { $0.prefix($0.count - zipcode.count - 1).split(separator: \" \", maxSplits: 1) }\n  \n  var streets = [Substring](), numbers = [Substring]()\n  for addr in prepared {\n    numbers.append(addr[0])\n    streets.append(addr[1])\n  }\n  \n  return \"\\(zipcode):\\(streets.joined(separator: \",\"))\/\\(numbers.joined(separator: \",\"))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341319,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n  \n  let streetsArray = r.split(separator: \",\")\n                      .map({ String($0) })\n                      .filter({ $0[$0.index($0.endIndex, offsetBy: -8)...$0.index($0.endIndex, offsetBy: -1)] == zipcode })\n  \n  var street: [String] = []\n  var houseNumber: [String] = []\n  \n  for address in streetsArray {\n    street += [String(address[address.index(after: address.firstIndex(of: \" \")!)..<address.index(address.endIndex, offsetBy: -9)])]\n    houseNumber += [String(address.prefix(upTo: address.firstIndex(of: \" \")!))]\n  }\n  \n  return zipcode + \":\" + street.joined(separator: \",\") + \"\/\" + houseNumber.joined(separator: \",\")\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341320,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n  let addresses = r.components(separatedBy: \",\")\n    var streets: [String] = []\n    var numbers: [String] = []\n\n    for ad in addresses {\n        let address = ad.components(separatedBy: \" \")\n        let adzip = address.suffix(2).joined(separator: \" \")\n\n        if zipcode == adzip {\n            numbers.append(address[0])\n            streets.append(address[1..<address.count - 2].joined(separator: \" \"))\n        }\n    }\n\n    return zipcode + \":\" + streets.joined(separator: \",\") + \"\/\" + numbers.joined(separator: \",\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341321,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n    if r == \"\" || zipcode == \"\" { return \":\/\" }\n    \n    let list = listify(r)\n    var output = \"\\(zipcode):\"\n\n    if list.filter({ $0.zip == zipcode }).isEmpty { return \"\\(zipcode):\/\" }\n\n    for i in list.filter({ $0.zip == zipcode }) {\n        output += \"\\(i.street),\"\n    }\n    output = String(output.dropLast())\n    output += \"\/\"\n    for i in list.filter({ $0.zip == zipcode }) {\n        output += \"\\(i.number),\"\n    }\n    output = String(output.dropLast())\n  return output\n}\n\nfunc listify(_ r: String) -> [(zip: String, street: String, number: String)] {\n    var output: [(zip: String, street: String, number: String)] = []\n    for i in r.split(separator: \",\") {\n        let tempSplit = i.split(separator: \" \")\n        var tempStreet = \"\"\n        for x in 1...tempSplit.count-3 {\n            tempStreet += tempSplit[x]\n            tempStreet += \" \"\n        }\n        tempStreet = String(tempStreet.dropLast())\n        output.append((zip: \"\\(tempSplit[tempSplit.count-2]) \\(tempSplit[tempSplit.count-1])\", street: tempStreet, number: String(tempSplit[0])))\n    }\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341322,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n    guard zipcode.count == 8 else { return zipcode + \":\/\"}\n    let adressArray = r.components(separatedBy: \",\")\n    var numbersOfHouse: [String] = []\n    var smallAdress: [String] = []\n    for adress in adressArray {\n        if adress.contains(zipcode) {\n            var arrayOfAdressComponents = adress.components(separatedBy: \" \")\n            print(arrayOfAdressComponents)\n            guard let numberOfHouse = arrayOfAdressComponents.first else { return \"\/\"}\n            numbersOfHouse.append(numberOfHouse)\n      \n            arrayOfAdressComponents.removeLast()\n            arrayOfAdressComponents.removeLast()\n            arrayOfAdressComponents.removeFirst()\n            \n            smallAdress.append(arrayOfAdressComponents.joined(separator: \" \"))\n         \n        }\n    }\n    let ansver = zipcode + \":\" + smallAdress.joined(separator: \",\") + \"\/\" + numbersOfHouse.joined(separator: \",\")\n  return ansver\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341323,"user_id":null,"body":"func travel(_ r: String, zipcode: String) -> String {\n  guard zipcode != \"\" else {\n     return \":\/\"\n  }\n  let components = r.components(separatedBy: \",\")\n  var buffer: [String] = []\n  var resultArray: [String] = []\n  let zip = zipcode + \":\"\n  for component in components {\n    if component.hasSuffix(zipcode) {\n      let bufferValue = component.replacingOccurrences(of: zipcode, with: \"\").compactMap { $0.wholeNumberValue }.compactMap { String($0) }.joined(separator: \"\")\n      buffer.append(bufferValue)\n      let resultValue = component.replacingOccurrences(of: zipcode, with: \"\").replacingOccurrences(of: bufferValue, with: \"\").trimmingCharacters(in: .whitespaces)\n      resultArray.append(resultValue)\n    }\n  }\n  \n  let result = zip + resultArray.joined(separator: \",\") + \"\/\" + buffer.joined(separator: \",\")\n  \n  if result == zip || zipcode == \"\"{\n    return result + \"\/\"\n  } else {\n    return result\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56b5afb4ed1f6d5fb0000991":[{"id":341324,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    guard c > 0, c <= s.count else { return \"\" }\n    \n    return stride(from: 0, to: s.count - s.count % c, by: c).map {\n        let start = s.index(s.startIndex, offsetBy: $0)\n        let end = s.index(start, offsetBy: c)\n        let part = String(s[start..<end])\n        \n        return part.compactMap({ Int(String($0)) }).reduce(0, +) % 2 == 0 ? String(part.reversed()) : part.dropFirst() + String(part.first!)\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341325,"user_id":null,"body":"extension Array {\n    func split(intoSizes: Int) -> [[Element]] {\n        return stride(from: 0, to: self.count, by: intoSizes).map{\n            Array(self[$0 ..< Swift.min($0 + intoSizes, self.count)])\n        }\n    }\n}\n\nfunc revrot(_ s: String, _ c: Int) -> String {\n    if s.isEmpty || c <= 0 || s.characters.count < c  { return \"\" }\n    return splitArrayOfTextInto(parts: c, array: s.characters.map{String($0)}).map{cubeRule(for: $0) ? reverse(array: $0) : leftShiftByOne(array: $0)}.joined().joined()\n}\n\nfunc cubeRule(for x: [String]) -> Bool {\n    return x.map{Int($0)! * Int($0)! * Int($0)!}.reduce(0, +) % 2 == 0\n}\n\nfunc splitArrayOfTextInto(parts: Int, array: [String]) -> [[String]] {\n    return array.split(intoSizes: parts).filter{$0.count == parts}\n}\n\nfunc reverse(array x: [String]) -> [String] {\n    return [x.map({String($0)}).reversed().joined()]\n}\n\nfunc leftShiftByOne(array x: [String]) -> [String] {\n    var result = x; result.insert(result.removeFirst(), at: x.count - 1)\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341326,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    if c <= 0 || c > s.characters.count { return \"\" }\n    let array = s.characters.map({ Int(String($0)) })\n    var result = \"\"\n    for var i in 0...s.characters.count \/ c - 1 {\n      i += 0 \/\/ compiler problem\n      var subArray = array[i*c...i*c+c - 1].flatMap({$0})\n      let r = subArray.reduce(0, { (res, value) -> Double in\n        return res + pow(Double(value), 3.0)\n      })\n      if r.remainder(dividingBy: 2) == 0 {\n        subArray = subArray.reversed()\n      } else {\n        subArray.append(subArray.first!)\n        subArray.removeFirst()\n      }\n      result += subArray.reduce(\"\", { (res, value) -> String in\n        return res + String(value)\n      })\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341327,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    let sList = s.compactMap(\\.wholeNumberValue)\n    if c <= 0 || sList.isEmpty || sList.count < c {\n        return \"\"\n    }\n    let chunkList = stride(from: 0, to: sList.count, by: c)\n        .map { Array(sList[$0..<min($0 + c, sList.count)]) }\n        .filter { $0.count == c }\n    var result = [[Int]]()\n    for (_, chunk) in chunkList.enumerated() {\n        let sumOfCubes = chunk\n            .map { pow(Decimal($0), 3) }\n            .map { Int($0.description)! }\n            .reduce(0, +)\n        if sumOfCubes % 2 == 0 {\n            result.append(chunk.reversed())\n        } else {\n            let rotateLeftChunk = (chunk[1...] + chunk[..<1])\n            result.append(Array(rotateLeftChunk))\n        }\n    }\n    return result\n        .flatMap { $0.map { \"\\($0)\" } }\n        .joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341328,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    guard c > 0, !s.isEmpty, String(c).count < s.count else { return \"\" }\n    var partialStr = s\n    var str = String()\n    \n    while !partialStr.isEmpty {\n        var sum = Double()\n        var truncated = partialStr.prefix(c).map { String($0) }\n        guard truncated.count == c else { break }\n        for digit in truncated {\n            sum += pow(Double(digit) ?? 0, 3)\n        }\n        \n        if sum.truncatingRemainder(dividingBy: 2) == 0 {\n            str.append(truncated.reversed().joined())\n            sum = 0\n        } else {\n            let first = truncated.first ?? \"\"\n            truncated.removeFirst()\n            truncated.append(first)\n            str.append(truncated.joined())\n        }\n        \n        partialStr.removeFirst(c)\n        \n    }\n    \n    return str\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341329,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    \/\/ your code\n    guard s.count > c else {return \"\"}\n    guard c > 0 else {return \"\"}\n\n    var newString = \"\"\n    let textOutsideChunk = s.count % c\n    let chanksCount = (s.count - textOutsideChunk) \/ c\n\n    for i in 1...chanksCount{\n        \n        let firstIndex = s.index(s.startIndex, offsetBy: c*(i - 1))\n        let secondIndex = s.index(s.startIndex, offsetBy: c*i)\n\n        var text = s[firstIndex..<secondIndex]\n        var sum: Int = 0\n\n        text.forEach({\n            \n            \n            let oneStrNum = String($0)\n            let oneIntNum = Int(oneStrNum) ?? 0\n            sum += (oneIntNum * oneIntNum * oneIntNum)\n            \n        })\n        \n        if sum % 2 == 0 {\n            newString += text.reversed()\n        } else {\n            let firstChar = text.first ?? \"r\"\n            text.removeFirst()\n            text.insert(firstChar, at: text.endIndex)\n            newString += text\n        }\n        print(text)\n    }\n    return newString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341330,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n  let condition = s.count < c || s == \"\" || c == 0\n  return condition ? \"\" : reverseOrRotateChunk(String(s.prefix(c))) + revrot(String(s.suffix(s.count - c)), c)\n}\n\nfunc reverseOrRotateChunk(_ substring: String) -> String {\n  var charArray = Array(substring)\n  var intArray = charArray.map { $0.wholeNumberValue ?? 0 }\n  let checkCondition = (((intArray.map { Int(pow(Float($0), 3)) }).reduce(0, +))%2 == 0)\n  var reversedOrRotatedArray = checkCondition ? Array(intArray.reversed()) : Array((intArray + [intArray[0]]).dropFirst(1))\n  return reversedOrRotatedArray.map{ String($0) }.joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341331,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    guard c != 0 else { return \"\" }\n  \n    let s = s.compactMap{ Double(\"\\($0)\")! }\n    var numberOfChunk = 0\n    var chunks = [[Double]]()\n    \n    while (numberOfChunk + c) <= s.count {\n        chunks.append(Array(s[numberOfChunk..<(numberOfChunk + c)]))\n        numberOfChunk += c\n    }\n\n    let reordered: [[String]] = chunks.map {\n        var num = $0\n        let divisible = Int(num.reduce(0) { $0 + pow($1, 3) }) % 2\n        if divisible == 0 { return Array(num.reversed()).compactMap{ \"\\(Int($0))\" } }\n      \n        num.append(num[0])\n        num.removeFirst()\n      \n        return num.compactMap{ \"\\(Int($0))\" }\n    }\n    \n    return reordered.flatMap { $0 }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341332,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    guard !s.isEmpty, c > 0, c <= s.count else { return \"\" }\n    var arr = [String]()\n    var index = s.startIndex\n    while let nextIndex = s.index(index, offsetBy: c, limitedBy: s.endIndex), nextIndex <= s.endIndex {\n        arr.append(String(s[index..<nextIndex]))\n        index = nextIndex\n    }\n    return arr.map {\n        if $0.compactMap({ $0.wholeNumberValue }).map({ $0 * $0 * $0 }).reduce(0, +) % 2 == 0 {\n            return String($0.reversed())\n        } else {\n            return String($0.dropFirst() + String($0.first!))\n        }\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341333,"user_id":null,"body":"func revrot(_ s: String, _ c: Int) -> String {\n    var array = Array(s)\n    if (c < 1 || c > array.count) {\n        return \"\";\n    } else {\n        var sum = 0;\n        for item in 1...array.count {\n            let index = item - 1;\n            sum += Int(String(array[index])) ?? 0\n\n            if (item % c == 0) {\n                if (sum % 2 == 0) {\n                    array[item - c...index].reverse();\n                    print(array)\n                    sum = 0;\n                } else {\n                    array.insert(array.remove(at: item - c), at: index)\n                    print(array)\n                    sum = 0;\n                }\n                if (item + c > array.count) {\n                    break\n                }\n            }\n        }\n        var rs = \"\";\n        for item in 0...(Int((array.count \/ c)) * c) - 1 {\n            rs += String(array[item])\n        }\n        return rs;\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56baeae7022c16dd7400086e":[{"id":341334,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n    let matchedEntries = strng.split(separator: \"\n\").map { String($0) }.filter { $0.contains(num) }\n    \n    guard let matchedEntry = matchedEntries.first else { return \"Error => Not found: \\(num)\" }\n    guard matchedEntries.count == 1 else { return \"Error => Too many people: \\(num)\" }\n    \n    let nameRange = matchedEntry.range(of: \"<(.*?)>\", options: .regularExpression)!\n    let name = String(matchedEntry[nameRange])\n        .replacingOccurrences(of: \"[<>]\", with: \"\", options: .regularExpression)\n        .trimmingCharacters(in: .whitespacesAndNewlines)\n    \n    let addr: String = matchedEntry\n      .replacingOccurrences(of: \"[_!@#$%^&*,\/?;:<>+]|\\(num)|\\(name)\", with: \" \", options: .regularExpression)\n      .replacingOccurrences(of: \"\\\\s+\", with: \" \", options: .regularExpression)\n      .trimmingCharacters(in: .whitespacesAndNewlines)\n\n    return \"Phone => \\(num), Name => \\(name), Address => \\(addr)\"\n}    ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341335,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n    let entries = strng.components(separatedBy: .newlines).filter { $0.contains(num) }\n    \n    if entries.isEmpty { return \"Error => Not found: \\(num)\"}\n    if entries.count > 1 { return \"Error => Too many people: \\(num)\" }\n    \n    return entries.map {\n        let start = $0.firstIndex(of: \"<\")!\n        let end = $0.lastIndex(of: \">\")!\n        let name = $0[$0.index(start, offsetBy: 1)...$0.index(end, offsetBy: -1)]\n        \n        let charsToRemove = CharacterSet(charactersIn: \"+*#;\/$?:,\")\n        let addressString = $0\n            .replacingCharacters(in: start...end, with: \"\") \/\/ Remove name\n            .replacingOccurrences(of: #\"\\+\\d{1,2}-\\d{3}-\\d{3}-\\d{4}\"#, with: \"\", options: .regularExpression) \/\/ Remove phone\n            .components(separatedBy: charsToRemove).filter { !$0.isEmpty }.joined(separator: \" \").trimmingCharacters(in: .whitespaces) \/\/ Remove non alphanumeric\n            .replacingOccurrences(of: \"_\", with: \" \") \/\/ Fix address styling\n            .components(separatedBy: .whitespaces).filter { !$0.isEmpty }.joined(separator: \" \") \/\/ Remove extra whitespaces\n        \n        return \"Phone => \\(num), Name => \\(name), Address => \\(addressString)\"\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341336,"user_id":null,"body":"func phone(_ rawBook: String, _ num: String) -> String {\n  let numSearch = \"+\" + num\n  let matchingLines = rawBook.split(separator: \"\n\").filter({$0.contains(numSearch)})\n  if matchingLines.isEmpty {\n    return \"Error => Not found: \\(num)\"\n  }\n  if matchingLines.count > 1 {\n    return \"Error => Too many people: \\(num)\"\n  }\n  return formatContact(matchingLines[0])\n}\n\nfunc formatContact(_ rawContact: Substring) -> String {\n  var phone: String?\n  var name: String?\n  var address: String?\n  let scanner = Scanner(string: String(rawContact))\n  scanner.charactersToBeSkipped = []\n  while !scanner.isAtEnd {\n    if let temp = scanner.scanPhone() {\n      phone = temp\n    } else if let temp = scanner.scanName() {\n      name = temp\n    } else if let temp = scanner.scanAddressPiece() {\n      address = address.map({$0 + \" \" + temp}) ?? temp\n    } else {\n      _ = scanner.scanCharacter() \/\/ skip unrecognize characters\n    }\n  }  \n  return \"Phone => \\(phone ?? \"??\"), Name => \\(name ?? \"??\"), Address => \\(address ?? \"??\")\"\n}\n\nextension Scanner {\n  static private let phonePrefix = \"+\"\n  static private let phoneCharSet: CharacterSet = CharacterSet.decimalDigits.union(.init(charactersIn: \"-\"))\n  \n  func scanPhone() -> String? {\n    guard nil != scanString(Scanner.phonePrefix) else {\n      return nil\n    }\n    return scanCharacters(from: Scanner.phoneCharSet)\n  }\n}\n\n\/\/ mark: Name\nextension Scanner {\n  static private let namePrefix = \"<\"\n  static private let nameSuffix = \">\"\n\n  func scanName() -> String? {\n    guard nil != scanString(Scanner.namePrefix) else {\n      return nil\n    }\n    let result = scanUpToString(Scanner.nameSuffix)\n    _ = scanString(Scanner.nameSuffix) \/\/ skip suffix\n    return result\n  }\n}\n\n\/\/ mark: Address\nextension Scanner {\n  static private let addressCharSet: CharacterSet = CharacterSet.alphanumerics.union(CharacterSet(charactersIn: \"-.\"))\n\n  func scanAddressPiece() -> String? {\n    return scanCharacters(from: Scanner.addressCharSet)\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341337,"user_id":null,"body":"import Foundation\nfunc phone(_ strng: String, _ num: String) -> String {\n    let arr = strng.split(separator: \"\n\")\n    var countAlias = 0\n    let delSet: Set<Character> = [\",\", \"*\", \"!\", \"?\", \":\", \";\", \"$\", \"\/\", \"\\\\\"]\n    var name = \"\"\n    var addr = \"\"\n    for str in arr {\n        if str.contains(\"+\" + num) {\n            if countAlias >= 1 {\n                return \"Error => Too many people: \\(num)\"\n            } else if countAlias == 0 {\n                var s = str.filter{ !delSet.contains($0) }.replacingOccurrences(of: \"_\", with: \" \")\n                let rngNm = s.firstIndex(of: \"<\")! ... s.firstIndex(of: \">\")!\n                name = String(s[rngNm])\n                name.removeFirst()\n                name.removeLast()\n                s.removeSubrange(rngNm)\n                let sa = s.split(separator: \" \").filter({ !(\"+\" + num).contains($0) })\n                addr = sa.joined(separator: \" \")\n                countAlias += 1\n            }\n        }\n    }\n    if countAlias == 0 {\n        return \"Error => Not found: \\(num)\"\n    }\n    return \"Phone => \\(num), Name => \\(name), Address => \\(addr)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341338,"user_id":492,"body":"func phone(_ strng: String, _ num: String) -> String {\n    let m = matches(for: num, in: strng)\n    if m.isEmpty {return \"Error => Not found: \\(num)\"}\n    if m.count > 1 {return \"Error => Too many people: \\(num)\"}\n    var s: String = strng, person = \"\", string = \"\"\n    let arr = s.split(separator: \"\n\").map(String.init)\n    for var s in arr {\n        if s.range(of: num) != nil {\n            s.stringByRemovingRegexMatches(pattern: \"[_|,|;|\/|:|?|:|!|+|*|$]\", replaceWith: \" \")\n            s.stringByRemovingRegexMatches(pattern: num, replaceWith: \"\")\n            string = s\n            var matched = matches(for: \"<.*>\", in: string)\n            var name = matched[0]\n            name.stringByRemovingRegexMatches(pattern: \"[<|>]\", replaceWith: \"\")\n            person = name\n            string.stringByRemovingRegexMatches(pattern: matched[0], replaceWith: \"\")\n            string.stringByRemovingRegexMatches(pattern: \"\\\\s+\", replaceWith: \" \")\n        }\n    }\n    return \"Phone => \\(num), Name => \\(person.trimmingCharacters(in: .whitespaces)), Address => \\(string.trimmingCharacters(in: .whitespaces))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341339,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n    let entries = strng.components(separatedBy: \"\n\")\n    var resultArray: [String] = []\n    var name: String = \"\"\n    var number: String = \"\"\n    var address: String = \"\"\n    for item in entries {\n        if item.contains(num) {\n            resultArray.append(String(item))\n        }\n    }\n    number = num.components(separatedBy: NSCharacterSet.alphanumerics.inverted).joined(separator: \"-\")\n    guard !resultArray.isEmpty else { return \"Error => Not found: \\(number)\" }\n    if let match = resultArray[0].range(of: \"(?<=<)[^>]+\", options: .regularExpression) {\n        name = resultArray[0].substring(with: match)\n    }\n    resultArray[0] = resultArray[0].replacingOccurrences(of: name, with: \"\")\n    resultArray[0] = resultArray[0].replacingOccurrences(of: num, with: \"\")\n    let charactersToRemove: CharacterSet = [\",\", \"\/\", \"_\", \"!\", \"?\", \"+\", \"$\", \"&\", \"#\", \">\", \"<\", \"*\", \";\", \":\"]\n    address = resultArray[0].components(separatedBy: charactersToRemove).joined(separator: \" \").trimmingCharacters(in: .whitespacesAndNewlines)\n    address = address.components(separatedBy: NSCharacterSet.whitespacesAndNewlines).filter { !$0.isEmpty }.joined(separator: \" \")\n    switch resultArray.count {\n    case 1:\n        return \"Phone => \\(number), Name => \\(name), Address => \\(address)\"\n    default:\n        return \"Error => Too many people: \\(num)\"\n    }\n}            \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341340,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n  let detailsWithGivenNumber = strng.components(separatedBy: \"\n\").filter { $0.contains(num) }.map {String.init($0)}.unique\n  guard let personDetails = detailsWithGivenNumber.first else {\n    return \"Error => Not found: \\(num)\"\n  }\n  guard detailsWithGivenNumber.count == 1 else {\n    return \"Error => Too many people: \\(num)\"\n  }\n  guard let phoneRange =  personDetails.range(of: num),\n        let nameRange = personDetails.range(of: \"<(\\\\w+\\'*\\\\s*)+>\", options: .regularExpression, range: nil, locale: nil) else {\n    return \"Error => Not found: \\(num)\"\n  }\n  let phone = personDetails.substring(with: phoneRange).trimmingCharacters(in: .whitespaces)\n  let name = personDetails.substring(with: nameRange).replacingOccurrences(of: \"[<>]\", with: \"\", options: .regularExpression, range: nil).trimmingCharacters(in: .whitespaces)\n  let address = personDetails.replacingOccurrences(of: \"(\\(name)|\\(phone)|[+<>*:;$&@,?\/])\", with: \"\", options: .regularExpression, range: nil).replacingOccurrences(of: \"_\", with: \" \").trimmingCharacters(in: .whitespaces)\n  return \"Phone => \\(phone), Name => \\(name), Address => \\(address)\".replacingOccurrences(of: \"\\\\s{2,}\", with: \" \", options: .regularExpression, range: nil)\n}       \n\nextension Array where Element : Hashable {\n    var unique: [Element] {\n        return Array(Set(self))\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341341,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n    let matchingContacts = strng.components(separatedBy: .newlines).filter { $0.contains(num) }\n    guard matchingContacts.count == 1 else { return matchingContacts.count > 1 ? \"Error => Too many people: \\(num)\" : \"Error => Not found: \\(num)\"  }\n    \n    var mutableRecord = matchingContacts[0].replacingOccurrences(of: num, with: \"\")\n    \n    let nameRange = mutableRecord.range(of: \"<[\\\\w|\\\\s|\\\\']+>\", options: .regularExpression, range: mutableRecord.startIndex..<mutableRecord.endIndex, locale: nil)!\n    let name = mutableRecord[nameRange].replacingOccurrences(of: \"[<>]\", with: \"\", options: .regularExpression, range: nil).trimmingCharacters(in: .whitespacesAndNewlines)\n    mutableRecord.removeSubrange(nameRange)\n    \n    mutableRecord = mutableRecord.replacingOccurrences(of: \"[\\\\^\\\\+\\\\*\\\\$;?,:!\/]\", with: \"\", options: .regularExpression, range: nil)\n    mutableRecord = mutableRecord.replacingOccurrences(of: \"_\", with: \" \").components(separatedBy: \" \").filter { !$0.isEmpty }.joined(separator: \" \")\n    \n    return \"Phone => \\(num), Name => \\(name), Address => \\(mutableRecord)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341342,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n    var phone = \"\", name = \"\", address = \"\", index = 0\n    var input = strng.split(separator: \"\n\"), output: [String] = []\n    \n    for str in input {\n        while index < str.count || name == \"\" || address == \"\" || phone == \"\" {\n            let symbol = str[str.index(str.startIndex, offsetBy: index)]\n            if symbol == \"+\" && phone == \"\" {\n                if str[str.index(str.startIndex, offsetBy: index + 2)] == \"-\" {\n                    phone = String(str[str.index(str.startIndex, offsetBy: index + 1)...str.index(str.startIndex, offsetBy: index + 14)])\n                    index += 16\n                }\n                else {\n                    phone = String(str[str.index(str.startIndex, offsetBy: index + 1)...str.index(str.startIndex, offsetBy: index + 15)])\n                    index += 17\n                }\n            }\n            else if symbol == \"<\" && name == \"\" {\n                while str[str.index(str.startIndex, offsetBy: index + 1)] != \">\" {\n                    name.append(str[str.index(str.startIndex, offsetBy: index + 1)])\n                    index += 1\n                }\n                index += 3\n            }\n            else {\n                address += String(symbol)\n                index += 1\n            }\n        }\n        \n        \n        address = address.replacingOccurrences(of: \"[,*:;\/?$!]\", with: \"\", options: .regularExpression, range: nil)\n        address = address.replacingOccurrences(of: \"_\", with: \" \")\n        address = address.replacingOccurrences(of: \"  \", with: \" \")\n        \n        if address[address.index(address.endIndex, offsetBy: -1)] == \" \" {\n            address.remove(at: address.index(address.endIndex, offsetBy: -1))\n        }\n        if address[address.index(address.startIndex, offsetBy: 0)] == \" \" {\n            address.remove(at: address.index(address.startIndex, offsetBy: 0))\n        }\n        if name[name.index(name.endIndex, offsetBy: -1)] == \" \" {\n            name.remove(at: name.index(name.endIndex, offsetBy: -1))\n        }\n        \n        if num == phone {\n            output.append(\"Phone => \\(phone), Name => \\(name), Address => \\(address)\")\n            if output.count > 1 { return \"Error => Too many people: \\(num)\"}\n        }\n        phone = \"\" ; name = \"\" ; address = \"\" ; index = 0\n    }\n   \n    input = []\n    \n    if output.count == 0 {\n        return \"Error => Not found: \\(num)\"\n    }\n    else {\n        return String(output[0])\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341343,"user_id":null,"body":"func phone(_ strng: String, _ num: String) -> String {\n  guard strng.contains(num) else {\n      return \"Error => Not found: \\(num)\"\n  }\n\n  guard strng.components(separatedBy: num).count == 2 else {\n      return \"Error => Too many people: \\(num)\"\n  }\n\n  let line = strng.components(separatedBy: \"\n\").filter { $0.contains(num) }.first!.replacingOccurrences(of: \"+\\(num)\", with: \"\")\n\n  let nameStartRange = line.range(of: \"<\")?.upperBound\n  let nameEndRange = line[nameStartRange!...].range(of: \">\")?.lowerBound\n  let name = line[nameStartRange!..<nameEndRange!]\n\n  let okChars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.\"\n  var address = line.replacingOccurrences(of: \"<\\(name)>\", with: \"\")\n  address = address.components(separatedBy: CharacterSet(charactersIn: okChars).inverted).joined(separator: \" \").components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }.joined(separator: \" \").trimmingCharacters(in: .whitespacesAndNewlines)\n\n  return \"Phone => \\(num), Name => \\(name), Address => \\(address)\"\n}            \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56bdd0aec5dc03d7780010a5":[{"id":341344,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\n  return ((n+1)...).first { $0.nonzeroBitCount == n.nonzeroBitCount }!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341345,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\n    var nextNumber = n + 1\n    \n    while String(n, radix: 2).filter({ $0 == \"1\" }).count != String(nextNumber, radix: 2).filter({ $0 == \"1\" }).count {\n        nextNumber += 1\n    }\n\n    return nextNumber\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341346,"user_id":645,"body":"func nextHigher(_ n: Int) -> Int {\n    let o = n & -n\n    return (n + o) | (((n ^ (n + o)) \/ o) >> 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341347,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\n    var numb = n\n    let count = n.nonzeroBitCount\n    numb += 1\n    while true {\n        if numb.nonzeroBitCount == count {\n            return numb\n        }\n        numb += 1\n    }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341348,"user_id":null,"body":"extension Int {\n  var ones: Int {\n    String(self, radix: 2)\n      .filter { $0 == \"1\" }\n      .count\n  }\n}\n\nfunc nextHigher(_ n: Int) -> Int {\n  let ones = n.ones\n  var m = n + 1\n  while m.ones != ones {\n    m += 1\n  }\n  return m\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341349,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\n  var newValue = n + 1\n  while newValue.nonzeroBitCount != n.nonzeroBitCount {\n    newValue += 1\n  }\n  return newValue\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341350,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\n    var resultInt = n + 1\n    while resultInt.nonzeroBitCount != n.nonzeroBitCount {\n        resultInt += 1\n    }\n    return resultInt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341351,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\n    var binaryN = String(n, radix: 2).filter{$0 == \"1\"}.count\n    var resultInt = n + 1\n    while String(resultInt, radix: 2).filter{$0 == \"1\"}.count != binaryN {\n        resultInt += 1\n    }\n    return resultInt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341352,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\nlet bin = Array (String(n, radix: 2))\nvar count = n\n  while true {\n  count += 1\nlet binCount = Array (String(count, radix: 2))\n   if bin.filter ({ $0 > \"0\"}).count  == binCount.filter ({ $0 > \"0\"}).count  {\n      return count\n   }\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341353,"user_id":null,"body":"func nextHigher(_ n: Int) -> Int {\nvar bin = Array (String(n, radix: 2))\n if bin.contains(\"0\") == false {\n    bin.insert(\"0\", at: 0)\n }\nvar count = n\n  while true {\n  count += 1\nlet binCount = Array (String(count, radix: 2))\n   if bin.filter ({ $0 > \"0\"}).count  == binCount.filter ({ $0 > \"0\"}).count  {\n      return count\n   }\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56c04261c3fcf33f2d000534":[{"id":341354,"user_id":null,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n    var result = 0.0\n    for n in 1...maxn {\n        let n2 = (n + 1) * (n + 1)\n        var denom = n2, overflow = false\n        for k in 1...maxk {\n            let kd = denom.multipliedReportingOverflow(by: k)\n            if kd.1 {\n                break\n            }\n            result += 1.0 \/ Double(kd.0)\n            (denom, overflow) = denom.multipliedReportingOverflow(by: n2)\n            if overflow {\n                break\n            }\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341355,"user_id":53,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n    var sum: Double = 0\n    for k in 1...maxk {\n        for n in 1...maxn {\n            sum = sum + (Double(1) \/ (Double(k) * pow(Double(n + 1), Double(2 * k))))\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341356,"user_id":null,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n   \n  func v(_ k: Int, _ n: Int) -> Double {\n    return 1.0 \/ (Double(k) * pow( Double(n+1) , Double(k*2) ))\n  }\n  \n  func u(_ k:Int, _ maxn:Int) -> Double {\n    return (1...maxn).map{v(k,$0)}.reduce(0,+)\n  }\n  \n  func s(_ maxk: Int, _ maxn: Int) -> Double {\n    return (1...maxk).map{u($0,maxn)}.reduce(0,+)\n  }\n  \n  return s(maxk,maxn)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341357,"user_id":492,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n    var sum: Double = 0.0\n    for k in 1...maxk {\n        for n in 1...maxn {\n            sum += (1.0 \/ (Double(k) * pow(Double(n + 1), Double(2 * k))))\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341358,"user_id":null,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n  func v(_ k: Double,_ n: Double) -> Double { 1.0 \/ (k * pow(n+1,k*2)) }\n  func u(_ k:Int, _ nn:Int) -> Double { (1...nn).map{ v(Double(k),Double($0)) }.reduce(0,+) }\n  func s(_ kk: Int, _ nn: Int) -> Double { (1...kk).map{ u($0,nn) }.reduce(0,+) }\n  return s(maxk, maxn)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341359,"user_id":null,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n  var totalForce = 0.0  \n  for k in 1...maxk {\n    totalForce += (1...maxn).map{1.0 \/ pow(Double($0 + 1), Double(2 * k))}.reduce(0.0, +) \/ Double(k)\n  }\n  return totalForce\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341360,"user_id":null,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n    var sum: Double = 0\n    for k in 1...maxk {\n        for n in 1...maxn {\n            sum = sum + (1 \/ (Double(k) * pow(Double(n + 1), Double(2 * k))))\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341361,"user_id":null,"body":"func getForceExerted(row k: Int, column n: Int) -> Double {\n        return 1.0 \/ Double( Double(k) * pow(Double(n+1), Double((2*k))))\n    }\n\nfunc doubles(_ maxk: Int, _ maxn: Int) -> Double {\n   var totalForce = 0.0\n        \n        for row in 1...maxk {\n            for column in 1...maxn {\n                totalForce += getForceExerted(row: row, column: column)\n            }\n        }\n        \n   return totalForce\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341362,"user_id":220,"body":"func doubles(_ maxk: Int, _ maxn: Int) -> Double {\n    \n  var f = 0.0;\n  for k in 1...maxk {\n    for n in 1...maxn {\n      let d = Double(k)*pow(Double(n)+1.0, Double(k)*2.0)\n      if d > 1e16 { break }\n      f += 1.0\/d;\n    }\n  }\n  return f;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341363,"user_id":null,"body":"import Foundation\nfunc doubles(_ maxk: Int, _ maxn: Int) -> Double {\n    var out = 0.0\n    for k in 1...maxk {\n        for n in 1...maxn {\n            out += 1.0 \/ (Double(k) * (pow((Double(n) + 1.0), (2.0 * Double(k)))))\n        }\n    }    \n    return out\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56c5847f27be2c3db20009c3":[{"id":341364,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n    let id: Int = n - \"\\(n)\".compactMap { Int(\"\\($0)\") }.reduce(0, { $0 + $1 })\n    return fruits[id] != nil ? fruits[id]! : subtractSum(id)\n}\n\nlet fruits: [Int:String] = [\n    1: \"kiwi\",\n    2: \"pear\",\n    3: \"kiwi\",\n    4: \"banana\",\n    5: \"melon\",\n    6: \"banana\",\n    7: \"melon\",\n    8: \"pineapple\",\n    9: \"apple\",\n    10: \"pineapple\",\n    11: \"cucumber\",\n    12: \"pineapple\",\n    13: \"cucumber\",\n    14: \"orange\",\n    15: \"grape\",\n    16: \"orange\",\n    17: \"grape\",\n    18: \"apple\",\n    19: \"grape\",\n    20: \"cherry\",\n    21: \"pear\",\n    22: \"cherry\",\n    23: \"pear\",\n    24: \"kiwi\",\n    25: \"banana\",\n    26: \"kiwi\",\n    27: \"apple\",\n    28: \"melon\",\n    29: \"banana\",\n    30: \"melon\",\n    31: \"pineapple\",\n    32: \"melon\",\n    33: \"pineapple\",\n    34: \"cucumber\",\n    35: \"orange\",\n    36: \"apple\",\n    37: \"orange\",\n    38: \"grape\",\n    39: \"orange\",\n    40: \"grape\",\n    41: \"cherry\",\n    42: \"pear\",\n    43: \"cherry\",\n    44: \"pear\",\n    45: \"apple\",\n    46: \"pear\",\n    47: \"kiwi\",\n    48: \"banana\",\n    49: \"kiwi\",\n    50: \"banana\",\n    51: \"melon\",\n    52: \"pineapple\",\n    53: \"melon\",\n    54: \"apple\",\n    55: \"cucumber\",\n    56: \"pineapple\",\n    57: \"cucumber\",\n    58: \"orange\",\n    59: \"cucumber\",\n    60: \"orange\",\n    61: \"grape\",\n    62: \"cherry\",\n    63: \"apple\",\n    64: \"cherry\",\n    65: \"pear\",\n    66: \"cherry\",\n    67: \"pear\",\n    68: \"kiwi\",\n    69: \"pear\",\n    70: \"kiwi\",\n    71: \"banana\",\n    72: \"apple\",\n    73: \"banana\",\n    74: \"melon\",\n    75: \"pineapple\",\n    76: \"melon\",\n    77: \"pineapple\",\n    78: \"cucumber\",\n    79: \"pineapple\",\n    80: \"cucumber\",\n    81: \"apple\",\n    82: \"grape\",\n    83: \"orange\",\n    84: \"grape\",\n    85: \"cherry\",\n    86: \"grape\",\n    87: \"cherry\",\n    88: \"pear\",\n    89: \"cherry\",\n    90: \"apple\",\n    91: \"kiwi\",\n    92: \"banana\",\n    93: \"kiwi\",\n    94: \"banana\",\n    95: \"melon\",\n    96: \"banana\",\n    97: \"melon\",\n    98: \"pineapple\",\n    99: \"apple\",\n    100: \"pineapple\"\n]\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341365,"user_id":645,"body":"func subtractSum(_ n: Int) -> String {\n    return \"apple\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341366,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n    \/\/ wittily :-)\n  return \"apple\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341367,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n  \/\/ I'm superman\n  \"apple\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341368,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n  let answers = [\"random\", \"kiwi\", \"pear\", \"kiwi\", \"banana\",\"melon\",\"banana\", \"melon\" ,\"pineapple\", \"apple\", \"pineapple\"]\n  var result = n\n\n  while result >= 10 && result < 10000 { \n    let resultString = String(result)\n    var summa = 0\n    for elem in resultString {\n     let elemString = String(elem)\n     let numElem = Int(elemString)!\n     summa = summa + numElem\n    }\n   result = result - summa\n  }\n   return answers[result]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341369,"user_id":902,"body":"func subtractSum(_ n: Int) -> String {\n    guard n >= 10, n < 10_000 else {\n        return \"\"\n    }\n    let components = str.components(separatedBy: .newlines)\n    let fruitNumber = n - String(n).enumerated().reduce(into: 0){ $0 += $1.element.wholeNumberValue! }\n    if fruitNumber < components.count {\n        return components[fruitNumber - 1].components(separatedBy: \"-\").last!\n    } else {\n        return subtractSum(fruitNumber)\n    }\n}\n\nlet str = \"\"\"\n1-kiwi\n2-pear\n3-kiwi\n4-banana\n5-melon\n6-banana\n7-melon\n8-pineapple\n9-apple\n10-pineapple\n11-cucumber\n12-pineapple\n13-cucumber\n14-orange\n15-grape\n16-orange\n17-grape\n18-apple\n19-grape\n20-cherry\n21-pear\n22-cherry\n23-pear\n24-kiwi\n25-banana\n26-kiwi\n27-apple\n28-melon\n29-banana\n30-melon\n31-pineapple\n32-melon\n33-pineapple\n34-cucumber\n35-orange\n36-apple\n37-orange\n38-grape\n39-orange\n40-grape\n41-cherry\n42-pear\n43-cherry\n44-pear\n45-apple\n46-pear\n47-kiwi\n48-banana\n49-kiwi\n50-banana\n51-melon\n52-pineapple\n53-melon\n54-apple\n55-cucumber\n56-pineapple\n57-cucumber\n58-orange\n59-cucumber\n60-orange\n61-grape\n62-cherry\n63-apple\n64-cherry\n65-pear\n66-cherry\n67-pear\n68-kiwi\n69-pear\n70-kiwi\n71-banana\n72-apple\n73-banana\n74-melon\n75-pineapple\n76-melon\n77-pineapple\n78-cucumber\n79-pineapple\n80-cucumber\n81-apple\n82-grape\n83-orange\n84-grape\n85-cherry\n86-grape\n87-cherry\n88-pear\n89-cherry\n90-apple\n91-kiwi\n92-banana\n93-kiwi\n94-banana\n95-melon\n96-banana\n97-melon\n98-pineapple\n99-apple\n100-pineapple\n\"\"\"","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341370,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n    var number = n\n    repeat {\n      let sum = String(number).compactMap { Int(String($0)) }.reduce(0, +)\n      number -= sum\n    } while number > 100\n  \n  \/\/The fact is that by subtracting the sum of its digits from a number, we will always get a result that is a multiple of 9.\n  \/\/And at positions divisible by 9 there is always an apple.\n  \n    return number.isMultiple(of: 9) ? \"apple\" : \"another Fruit :)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341371,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n    let id: Int = n - \"\\(n)\".compactMap { Int(\"\\($0)\") }.reduce(0, { $0 + $1 })\n    let fruits: [Int:String] = [\n    1: \"kiwi\",\n    2: \"pear\",\n    3: \"kiwi\",\n    4: \"banana\",\n    5: \"melon\",\n    6: \"banana\",\n    7: \"melon\",\n    8: \"pineapple\",\n    9: \"apple\",\n    10: \"pineapple\",\n    11: \"cucumber\",\n    12: \"pineapple\",\n    13: \"cucumber\",\n    14: \"orange\",\n    15: \"grape\",\n    16: \"orange\",\n    17: \"grape\",\n    18: \"apple\",\n    19: \"grape\",\n    20: \"cherry\",\n    21: \"pear\",\n    22: \"cherry\",\n    23: \"pear\",\n    24: \"kiwi\",\n    25: \"banana\",\n    26: \"kiwi\",\n    27: \"apple\",\n    28: \"melon\",\n    29: \"banana\",\n    30: \"melon\",\n    31: \"pineapple\",\n    32: \"melon\",\n    33: \"pineapple\",\n    34: \"cucumber\",\n    35: \"orange\",\n    36: \"apple\",\n    37: \"orange\",\n    38: \"grape\",\n    39: \"orange\",\n    40: \"grape\",\n    41: \"cherry\",\n    42: \"pear\",\n    43: \"cherry\",\n    44: \"pear\",\n    45: \"apple\",\n    46: \"pear\",\n    47: \"kiwi\",\n    48: \"banana\",\n    49: \"kiwi\",\n    50: \"banana\",\n    51: \"melon\",\n    52: \"pineapple\",\n    53: \"melon\",\n    54: \"apple\",\n    55: \"cucumber\",\n    56: \"pineapple\",\n    57: \"cucumber\",\n    58: \"orange\",\n    59: \"cucumber\",\n    60: \"orange\",\n    61: \"grape\",\n    62: \"cherry\",\n    63: \"apple\",\n    64: \"cherry\",\n    65: \"pear\",\n    66: \"cherry\",\n    67: \"pear\",\n    68: \"kiwi\",\n    69: \"pear\",\n    70: \"kiwi\",\n    71: \"banana\",\n    72: \"apple\",\n    73: \"banana\",\n    74: \"melon\",\n    75: \"pineapple\",\n    76: \"melon\",\n    77: \"pineapple\",\n    78: \"cucumber\",\n    79: \"pineapple\",\n    80: \"cucumber\",\n    81: \"apple\",\n    82: \"grape\",\n    83: \"orange\",\n    84: \"grape\",\n    85: \"cherry\",\n    86: \"grape\",\n    87: \"cherry\",\n    88: \"pear\",\n    89: \"cherry\",\n    90: \"apple\",\n    91: \"kiwi\",\n    92: \"banana\",\n    93: \"kiwi\",\n    94: \"banana\",\n    95: \"melon\",\n    96: \"banana\",\n    97: \"melon\",\n    98: \"pineapple\",\n    99: \"apple\",\n    100: \"pineapple\"\n]\n  \n  return fruits[id] != nil ? fruits[id]! : subtractSum(id)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341372,"user_id":null,"body":"func subtractSum(_ n: Int) -> String {\n\/\/   var result = 0\n  \n\/\/   repeat {\n\/\/     result = String(n).map { Int(String($0))! }.reduce(n, -)\n\/\/   } while result > 100\n  \n\/\/   return String(result)\n  \n  return \"apple\"\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341373,"user_id":null,"body":"let fruits = [\"kiwi\", \"pear\", \"kiwi\", \"banana\", \"melon\", \"banana\", \"melon\", \"pineapple\", \"apple\", \"pineapple\", \"cucumber\", \"pineapple\", \"cucumber\", \"orange\", \"grape\", \"orange\", \"grape\", \"apple\", \"grape\", \"cherry\", \"pear\", \"cherry\", \"pear\", \"kiwi\", \"banana\", \"kiwi\", \"apple\", \"melon\", \"banana\", \"melon\", \"pineapple\", \"melon\", \"pineapple\", \"cucumber\", \"orange\", \"apple\", \"orange\", \"grape\", \"orange\", \"grape\", \"cherry\", \"pear\", \"cherry\", \"pear\", \"apple\", \"pear\", \"kiwi\", \"banana\", \"kiwi\", \"banana\", \"melon\", \"pineapple\", \"melon\", \"apple\", \"cucumber\", \"pineapple\", \"cucumber\", \"orange\", \"cucumber\", \"orange\", \"grape\", \"cherry\", \"apple\", \"cherry\", \"pear\", \"cherry\", \"pear\", \"kiwi\", \"pear\", \"kiwi\", \"banana\", \"apple\", \"banana\", \"melon\", \"pineapple\", \"melon\", \"pineapple\", \"cucumber\", \"pineapple\", \"cucumber\", \"apple\", \"grape\", \"orange\", \"grape\", \"cherry\", \"grape\", \"cherry\", \"pear\", \"cherry\", \"apple\", \"kiwi\", \"banana\", \"kiwi\", \"banana\", \"melon\", \"banana\", \"melon\", \"pineapple\", \"apple\", \"pineapple\"]\n\nfunc subtractSum(_ n: Int) -> String {\n    let number = n - n.description.compactMap { $0.wholeNumberValue }.reduce(0, +)\n\t  guard number > 100 else { return fruits[number - 1] }\n\t  return subtractSum(number)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56cac350145912e68b0006f0":[{"id":341374,"user_id":null,"body":"    func arrange(_ s: String) -> String {\n        var arrS = s.components(separatedBy: \" \"), localVar: String = \"\"\n        arrS.enumerated().forEach {\n        if $0.offset < arrS.count - 1 {\n            if $0.offset % 2 == 0, arrS[$0.offset].count > arrS[$0.offset + 1].count { change($0.offset) }\n            if $0.offset % 2 != 0, arrS[$0.offset].count < arrS[$0.offset + 1].count { change($0.offset) }\n            }\n        }\n        func change(_ ind: Int) { localVar = arrS[ind + 1]; arrS[ind + 1] = arrS[ind]; arrS[ind] = localVar }\n        (0...arrS.count - 1).forEach { arrS[$0] = $0 % 2 == 0 ? arrS[$0].lowercased() : arrS[$0].uppercased()}\n        return arrS.joined(separator: \" \")\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341375,"user_id":null,"body":"func arrange(_ s: String) -> String {\n    guard s.isEmpty != true else {return s}\n    var words = s.split(separator: \" \").compactMap{String($0)}\n    \n    (1..<words.count).forEach{\n        if (($0 % 2 != 0 && words[$0].count < words[$0 - 1].count) ||\n            ($0 % 2 == 0 && words[$0].count > words[$0 - 1].count)) {\n            words.swapAt($0, $0-1)\n        }\n\n    }\n    return words.enumerated().compactMap{ ($0.offset % 2 != 0) ? $0.element.uppercased() : $0.element.lowercased()\n    }.joined(separator: \" \")\n  }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341376,"user_id":null,"body":"func arrange(_ s: String) -> String {\n    var s = s.lowercased().components(separatedBy: \" \")\n    \n    for (idx, _) in s.enumerated() {\n        if idx + 1 < s.count {\n            let val0 = s[idx]\n            let val1 = s[idx + 1]\n            \n            if idx % 2 == 0 && val0.count > val1.count { s.swapAt(idx, idx + 1) }\n            if idx % 2 == 1 && val0.count < val1.count { s.swapAt(idx, idx + 1) }\n        }\n    }\n    \n    return s.enumerated().map { $0.offset % 2 == 1 ? \"\\($0.element)\".uppercased() : \"\\($0.element)\" }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341377,"user_id":null,"body":"        func arrange(_ s: String) -> String {\n            var str = s.components(separatedBy: \" \")\n            for (index, _) in str.enumerated() {\n                guard index + 1 != str.count else {\n                    break\n                }\n                if index % 2 != 0 {\n                    if str[index].count < str[index + 1].count {\n                        str.swapAt(index, index + 1)\n                    }\n                } else {\n                    if str[index].count > str[index + 1].count {\n                        str.swapAt(index, index + 1)\n                    }\n                }\n            }\n            return str.enumerated().map{ $0.offset % 2 != 0 ? String($0.element).uppercased() : String($0.element).lowercased()}.joined(separator: \" \")\n        }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341378,"user_id":null,"body":"func arrange(_ s: String) -> String {\n    var substrings = s.split(whereSeparator: \\.isWhitespace)\n    let length = substrings.count\n    \n    guard length > 1 else {\n        return s.lowercased()\n    }\n  \n    func aGreaterThanB(_ a: String, _ b: String) -> Bool {\n        a.count > b.count\n    }\n    \n    func aSmallerThanB(_ a: String, _ b: String) -> Bool {\n        a.count < b.count\n    }\n    \n    let comparison = [aGreaterThanB, aSmallerThanB]\n    \n    for index in 0..<length - 1 {\n        if comparison[index % 2](String(substrings[index]), String(substrings[index + 1])) {\n            let tmp = substrings[index];\n            substrings[index] = substrings[index + 1];\n            substrings[index + 1] = tmp;\n        }\n    }\n    \n    return substrings.enumerated().map({ index, value in ((index % 2) != 0) ? value.uppercased() : value.lowercased() }).joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341379,"user_id":null,"body":"func arrange(_ s: String) -> String {\n  \n  var i = 1\n  var words = s.components(separatedBy: \" \")\n  let ops = Array(repeating: [String.lowercased, String.uppercased], count: words.count \/ 2 + 1).flatMap { $0 }\n  \n  func swap(_ i: Int, _ j: Int) {\n    let t = words[i]\n    words[i] = words[j]\n    words[j] = t\n  }\n  \n  while i < words.count {\n    if\n      (i % 2 == 0 && words[i - 1].count < words[i].count) ||\n      (i % 2 != 0 && words[i - 1].count > words[i].count)\n    {\n      swap(i, i - 1)\n    }\n    i += 1\n  }\n  \n  return zip(words, ops)\n    .map { $1($0)() }\n    .joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341380,"user_id":null,"body":"func arrange(_ s: String) -> String {\n    var words = s.components(separatedBy: \" \")\n    var isGoingUp = true\n    var steps = 0\n    \n    for i in 0..<words.endIndex - 1 {\n        let currentWord = words[i]\n        let nextWord = words[i + 1]\n        \n        if isGoingUp {\n            if currentWord.count <= nextWord.count {\n                \/\/ good\n            } else {\n                \/\/ swap\n                words.swapAt(i, i + 1)\n                steps += 1\n            }\n        } else {\n            if currentWord.count >= nextWord.count {\n                \/\/ good\n            } else {\n                \/\/ swap\n                words.swapAt(i, i + 1)\n                steps += 1\n            }\n        }\n        \n        isGoingUp = !isGoingUp\n    }\n    \n    \/\/ decorate\n    for i in 0..<words.endIndex {\n        \/\/ decorate\n        if i % 2 == 0 {\n            words[i] = words[i].lowercased()\n        } else {\n            words[i] = words[i].uppercased()\n        }\n    }\n    \n    return words.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341381,"user_id":902,"body":"let componentSeparator = \" \"\n\nfunc arrange(_ s: String) -> String {\n    let components = s.components(separatedBy: componentSeparator)\n    let arrangedComponents = arrangeGivenComponents(components)\n    return applyUpAndDownFormatter(on: arrangedComponents)\n}\n\nfunc arrangeGivenComponents(_ components: [String]) -> [String] {\n    var currentRule: Rule = .mustBeLonger\n    var modifiableComponents = components\n    modifiableComponents.indices.dropLast().forEach {\n        let currentIndex = $0\n        let nextIndex = $0.advanced(by: 1)\n        switch currentRule {\n        case .mustBeLonger:\n            if modifiableComponents[currentIndex].count > modifiableComponents[nextIndex].count {\n                modifiableComponents.swapAt(currentIndex, nextIndex)\n            }\n        case .mustBeShorter:\n            if modifiableComponents[currentIndex].count < modifiableComponents[nextIndex].count {\n                modifiableComponents.swapAt(nextIndex, currentIndex)\n            }\n        }\n        currentRule = currentRule.next\n    }\n    return modifiableComponents\n}\n\nfunc applyUpAndDownFormatter(on arrangedComponents: [String]) -> String {\n    return arrangedComponents.enumerated().map {\n        if $0.offset % 2 != 0 {\n            return $0.element.uppercased()\n        } else {\n            return $0.element.lowercased()\n        }\n    }.joined(separator: componentSeparator)\n}\n\nenum Rule {\n    case mustBeLonger\n    case mustBeShorter\n    \n    var next: Rule {\n        switch self {\n        case .mustBeLonger: return .mustBeShorter\n        case .mustBeShorter: return .mustBeLonger\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341382,"user_id":null,"body":"\nfunc arrange(_ s: String) -> String {\n  var words = s.split(separator: \" \")\n  var i = 0\n  while i < words.count - 1 {\n    if i % 2 == 0 {\n      if words[i+1].count < words[i].count {\n        words.insert(words.remove(at: i+1), at: i)\n        i = (i > 0 ? i - 2 : -1)\n      }\n    } else {\n      if words[i+1].count > words[i].count {\n        words.insert(words.remove(at: i+1), at: i)\n        i = (i > 0 ? i - 2 : -1)\n      }\n    }\n    i += 1\n  }\n  \n  var result: [String] = []\n  for (n, x) in words.enumerated() {\n    if n % 2 == 0 {\n      result.append(x.lowercased())\n    } else {\n      result.append(x.uppercased())\n    }\n  }\n  \n  return result.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341383,"user_id":null,"body":"func arrange(_ s: String) -> String {\n    var arr = s.components(separatedBy: \" \")\n    for i in 0..<arr.count - 1{\n        if i%2 == 0 {\n            if arr[i].count > arr[i + 1].count {\n                let temp = arr[i]\n                arr[i] = arr[i+1]\n                arr[i+1] = temp\n                arr[i] = arr[i].lowercased()\n                arr[i+1] = arr[i+1].uppercased()\n            }\n            else {\n                arr[i] = arr[i].lowercased()\n                arr[i+1] = arr[i+1].uppercased()\n            }\n        } else {\n            if arr[i].count < arr[i + 1].count {\n                let temp = arr[i]\n                arr[i] = arr[i+1]\n                arr[i+1] = temp\n                arr[i] = arr[i].uppercased()\n                arr[i+1] = arr[i+1].lowercased()\n            } else {\n                arr[i] = arr[i].uppercased()\n                arr[i+1] = arr[i+1].lowercased()\n            }\n        }\n        \n    }\n    return arr.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbe0e313c2f63be4000b25":[{"id":341384,"user_id":null,"body":"func horMirror(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\").reversed().joined(separator: \"\n\")\n}\n\nfunc vertMirror(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\").map({ String($0.characters.reversed()) }).joined(separator: \"\n\")\n}\n\nfunc oper(_ f: (String) -> (String), _ s: String) -> String {\n    return f(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341385,"user_id":null,"body":"    func processingString(_ string: String, performBeforeJoin closure: ([String]) -> [String]) -> String {\n        return closure(string.components(separatedBy: \"\n\")).joined(separator: \"\n\")\n    }\n    \n    func horMirror(_ s: String) -> String {\n        return processingString(s) {\n            return $0.reversed()\n        }\n    }\n    \n    func vertMirror(_ s: String) -> String {\n        return processingString(s) {\n            return $0.map { String($0.characters.reversed()) }\n        }\n    }\n    \n    \/\/ replace the dots with function parameter\n    func oper(_ closure: (String) -> String, _ s: String) -> String {\n        return closure(s)\n    }\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341386,"user_id":null,"body":"func horMirror(_ s: String) -> String {\n    return s\n        .components(separatedBy: \"\n\")\n        .reversed()\n        .joined(separator: \"\n\")\n}\n\nfunc vertMirror(_ s: String) -> String {\n    return s\n        .components(separatedBy: \"\n\")\n        .map({ String($0.characters.reversed()) })\n        .joined(separator: \"\n\")\n\n}\n\nfunc oper(_ direction: (String) -> String, _ s: String) -> String {\n    return direction(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341387,"user_id":null,"body":"let horMirror: (String) -> String = { $0.components(separatedBy: \"\n\").reversed().joined(separator: \"\n\") }\nlet vertMirror: (String) -> String = { $0.components(separatedBy: \"\n\").map { String($0.characters.reversed())}.joined(separator: \"\n\") }\nlet oper: ((String) -> String, String) -> String = { $0($1) }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341388,"user_id":null,"body":"func horMirror(_ s: String) -> String \n{\n  var every_str = s.split(separator:\"\n\")\n  \n  for j in 0...(( every_str.count-1)\/2)\n  {\n       let swoper = every_str[j]\n        every_str[j] = every_str[every_str.count-1-j]\n        every_str[every_str.count-1-j] = swoper\n  }\n  \n  return every_str.joined(separator: \"\n\")\n}\n\nfunc vertMirror(_ s: String) -> String \n{\n    \n   var every_str = s.split(separator:\"\n\")\n  \n  for i in 0...((every_str.count-1))\n  {\n        var str = Array(every_str[i])\n        for j in 0...((str.count-1)\/2)\n        {\n            let swoper = str[j]\n            str[j] = str[str.count-1-j]\n            str[str.count-1-j] = swoper\n        }\n\n        every_str[i] = \"\"\n\n        for k in str \n        {\n            every_str[i] += String(k)\n        }\n  }\n  \n  return every_str.joined(separator: \"\n\")\n  \n  \n}\n\/\/ replace the dots with function parameter\nfunc oper(_ cock : ( String ) -> String, _ s: String) -> String \n{\n  return cock(s)\n    \n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341389,"user_id":null,"body":"func horMirror(_ s: String) -> String {\n    s.components(separatedBy: \"\n\").reversed().joined(separator:\"\n\")\n}\nfunc vertMirror(_ s: String) -> String {\n    s.components(separatedBy: \"\n\").map{ String($0.reversed()) }.joined(separator: \"\n\")\n}\n\/\/ replace the dots with function parameter\nfunc oper(_ fn: (_ s:String) -> String, _ s: String) -> String {\n    return fn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341390,"user_id":null,"body":"func horMirror(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\").reversed().joined(separator: \"\n\")\n}\nfunc vertMirror(_ s: String) -> String {\n    return String(s.components(separatedBy: \"\n\").reduce(\"\") { (res, str) in res + str.reversed() + \"\n\"}.dropLast())\n}\n\/\/ replace the dots with function parameter\nfunc oper(_ f:(String) ->String , _ s: String) -> String {\n    return f(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341391,"user_id":null,"body":"func horMirror(_ s: String) -> String {\n\n    var str: String = \"\"\n    s.split(separator: \"\n\").reversed().forEach { str += $0 + \"\n\" }\n    str.removeLast()\n    return str\n}\nfunc vertMirror(_ s: String) -> String {\n\n   var str: String = \"\"\n    s.split(separator: \"\n\" ).forEach { str += String($0.reversed()) + \"\n\"}\n    str.removeLast()\n    return str\n   \n}\n\/\/ replace the dots with function parameter\nfunc oper(_ f: (String) -> (String), _ s: String) -> String {\n    return f(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341392,"user_id":492,"body":"func horMirror(_ s: String) -> String {\n    return \n        Array(\n            s\n            .split(separator: \"\n\")\n            .map(String.init)\n            .reversed())\n        .joined(separator: \"\n\")\n}\nfunc vertMirror(_ s: String) -> String {\n    return\n        s\n        .split(separator: \"\n\")\n        .map(String.init)\n        .map( { (s: String) -> String in\n            return String(s.reversed()) } )\n        .joined(separator: \"\n\")\n}\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341393,"user_id":null,"body":"func horMirror(_ s: String) -> String {\n  return s.components(separatedBy: \"\n\")\n    .reversed()\n    .joined(separator: \"\n\")\n}\nfunc vertMirror(_ s: String) -> String {\n  return s.components(separatedBy: \"\n\")\n    .map({ (str) -> String in\n      return String(str.characters.reversed())\n    }).joined(separator: \"\n\")\n}\nfunc oper(_ operation: (String) -> String, _ s: String) -> String {\n  return operation(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbe7f113c2f63570000b86":[{"id":341394,"user_id":492,"body":"func rot(_ s: String) -> String {\n    return String(s.characters.reversed())\n}\nfunc selfieAndRot(_ s: String) -> String {\n    let aa = s.characters\n        .split(separator: \"\n\")\n        .map(String.init)\n        .map( { (s: String) -> String in\n              return s + String(repeating: \".\", count: s.characters.count)\n              }\n        )\n    let bb = rot(s).characters\n        .split(separator: \"\n\")\n        .map(String.init)\n        .map( { (s: String) -> String in\n              return String(repeating: \".\", count: s.characters.count) + s\n              }\n        )\n    return (aa + bb).joined(separator: \"\n\")\n}\n\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341395,"user_id":null,"body":"func rot(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\")\n        .map { String($0.reversed()) }\n        .reversed()\n        .joined(separator: \"\n\")\n}\n\nfunc selfieAndRot(_ s: String) -> String {\n    let selfie = s.components(separatedBy: \"\n\")\n        .map { value -> String in\n            let dots: String = Array(0..<(value.count))\n                .map { _ in \".\"}\n                .joined()\n            return value + dots\n        }\n        .joined(separator: \"\n\")\n    let rots = rot(s).components(separatedBy: \"\n\")\n        .map { value -> String in\n            let dots: String = Array(0..<(value.count))\n                .map { _ in \".\"}\n                .joined()\n            return dots + value\n        }\n        .joined(separator: \"\n\")\n    return selfie + \"\n\" + rots\n}\n\nfunc oper(_ function: (String) -> String, _ s: String) -> String {\n    return function(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341396,"user_id":null,"body":"func rot(_ s:String) -> String {\n    let response:String = s.split(separator: \"\n\")\n        .reversed()\n        .map { String($0.reversed()) }\n        .joined(separator: \"\n\")\n    \n    return response\n}\n\nfunc selfieAndRot(_ s:String) -> String {\n    let spacer:String = String(repeating: \".\", count: s.distance(from: s.startIndex, to: s.index(of: \"\n\") ?? s.endIndex) )\n    \n    let selfie:String = s.split(separator: \"\n\")\n        .map { \"\\($0)\\(spacer)\" }\n        .joined(separator: \"\n\")\n    \n    let rotated:String = rot(s).split(separator: \"\n\")\n        .map { \"\\(spacer)\\($0)\" }\n        .joined(separator: \"\n\")\n    \n    return \"\\(selfie)\n\\(rotated)\"\n}\n\nfunc oper(_ fct:(_ s:String ) -> String, _ s:String ) -> String {\n    return fct(s)   \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341397,"user_id":null,"body":"func rot(_ s: String) -> String {\n    return s.components(separatedBy: .newlines).map {\n        String($0.reversed())\n    }.reversed().joined(separator: \"\n\")\n}\n\nfunc selfieAndRot(_ s: String) -> String {\n    let items = (s+\"\n\"+rot(s)).components(separatedBy: .newlines)\n    return items.enumerated().map {\n        $0.offset < items.count \/ 2 ?\n            $0.element + String(repeating: \".\", count: $0.element.count) :\n            String(repeating: \".\", count: $0.element.count) + $0.element\n    }.joined(separator: \"\n\")\n}\n\nfunc oper(_ operation: (_ s: String) -> String, _ s: String) -> String {\n    return operation(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341398,"user_id":null,"body":"import Foundation\nfunc rot(_ s: String) -> String {\n    return String(s.components(separatedBy: \"\n\").reversed().map({$0.reversed()}).joined(separator: \"\n\"))\n}\nfunc selfieAndRot(_ s: String) -> String {\n    let dots=String(repeating: \".\", count: s.components(separatedBy: \"\n\").first!.count)\n    return s.components(separatedBy: \"\n\").map({$0+dots}).joined(separator: \"\n\") + \"\n\" + rot(s).components(separatedBy: \"\n\").map({dots+$0}).joined(separator: \"\n\")\n}\nfunc oper( _ f:(String) -> String, _ s: String) -> String {\n    return f(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341399,"user_id":null,"body":"func rot(_ s: String) -> String {\n  return s.components(separatedBy: \"\n\")\n    .map { String($0.reversed()) }\n    .reversed()\n    .joined(separator: \"\n\")\n}\nfunc selfieAndRot(_ s: String) -> String {\n    let arrFromStr = s.components(separatedBy: \"\n\")\n    var dots = \"\"\n    for _ in 0..<String(arrFromStr[0]).count {  dots.append(\".\") }\n    let arrWithDots             = s.components(separatedBy: \"\n\").map { String(\"\\($0)\\(dots)\") }\n    let recursiveArrWithDots    = arrWithDots.reversed().map { String($0.reversed()) }\n    return \"\\(arrWithDots.joined(separator: \"\n\"))\n\\(recursiveArrWithDots.joined(separator: \"\n\"))\"\n}\n\/\/ replace the dots by your function parameter\nfunc oper(_ f: (String) -> (String), _ s: String) -> String {\n    return (f(s))\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341400,"user_id":null,"body":"func rot(_ s: String) -> String {\n    let lines = s.components(separatedBy:\"\n\")\n    return lines.reversed().map { String($0.characters.reversed()) }.joined(separator: \"\n\")\n}\nfunc selfieAndRot(_ s: String) -> String {\n    let lines = s.components(separatedBy:\"\n\")\n    let dots = String(lines.map {_ in \".\"})\n    let selfie = lines.map { $0 + dots }.joined(separator: \"\n\")\n    \n    return selfie + \"\n\" + rot(selfie)\n}\n\nfunc oper(_ operation:(String) -> String, _ s: String) -> String {\n    return operation(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341401,"user_id":null,"body":"func rot(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\").reversed().map{ String($0.characters.reversed()) }.joined(separator: \"\n\")\n}\nfunc selfieAndRot(_ s: String) -> String {\n    let dotCount = Array(s.components(separatedBy: \"\n\")[0].characters).count\n    let firstHalf : String = s.replacingOccurrences(of: \"\n\", with: String(repeatElement(\".\", count: dotCount)) + \"\n\") \n    let secondHalf : String = rot(s).replacingOccurrences(of: \"\n\", with: \"\n\" + String(repeatElement(\".\", count: dotCount)))\n    return firstHalf + String(repeatElement(\".\", count: dotCount)) + \"\n\" + String(repeatElement(\".\", count: dotCount)) + secondHalf\n}\n\/\/ replace the dots by your function parameter\nfunc oper(_ fct: (String) -> (String), _ s: String) -> String {\n    return fct(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341402,"user_id":null,"body":"func rot(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\")\n        .map({\n        return String($0.characters.reversed())\n    }).reversed()\n        .joined(separator: \"\n\")\n}\n\nfunc selfieAndRot(_ s: String) -> String {\n    let dotSelfie = s.components(separatedBy: \"\n\")\n        .map({ return $0 + String(repeating: \".\", count: $0.characters.count)\n    }).joined(separator: \"\n\")\n    return dotSelfie + \"\n\" + rot(dotSelfie)\n}\n\nfunc oper(_ f: (String) -> String, _ s: String) -> String {\n    return f(s)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341403,"user_id":null,"body":"func rot(_ s: String) -> String {\n    return s.components(separatedBy: \"\n\").map { String($0.reversed()) }.reversed().joined(separator: \"\n\")\n}\nfunc selfieAndRot(_ s: String) -> String {\n    var first = s.components(separatedBy: \"\n\").map { $0 + String(repeating: \".\", count: $0.count) + \"\n\"}.joined(separator: \"\")\n    first.removeLast()\n    let second = rot(s).components(separatedBy: \"\n\").map { \"\n\" + String(repeating: \".\", count: $0.count) + $0 }.joined(separator: \"\")\n    return first + second\n}\n\nfunc oper(_ f: (_ str: String) -> String, _ s: String) -> String {\n    return f(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbeec613c2f63be4000be6":[{"id":341404,"user_id":492,"body":"func diag1Sym(_ s: String) -> String {\n    return transpose(stringTo2DArrayOfChars(s))\n        .map( { (a: [Character]) -> String in\n                    return String(a)\n              }     \n        ).joined(separator: \"\n\")\n}\nfunc vertMirror(_ s: String) -> String {\n    return\n        s.characters\n        .split(separator: \"\n\")\n        .map(String.init)\n        .map( { (s: String) -> String in\n            return String(s.characters.reversed()) } )\n        .joined(separator: \"\n\")\n}\nfunc rot90Clock(s: String) -> String {\n    return vertMirror(diag1Sym(s))\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n    var r: [String] = [String]()\n    let arr = s.characters.split(separator: \"\n\").map(String.init)\n    let arr1 = diag1Sym(s).characters.split(separator: \"\n\").map(String.init)\n    for (i, element) in arr.enumerated() {\n        r.append(element + \"|\" + arr1[i])\n    }\n    return r.joined(separator: \"\n\")\n}\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341405,"user_id":null,"body":"func diag1Sym(_ entry: String) -> String {\n    let lines = entry.components(separatedBy: \"\n\")\n    var result = [String]()\n    for index in lines.indices {\n        let transformed = lines.map { $0[$0.index($0.startIndex, offsetBy: index)] }\n        result.append(String(transformed))\n    }\n    return result.joined(separator: \"\n\")\n}\n\nfunc rot90Clock(_ entry: String) -> String {\n    let reversedLines = entry.components(separatedBy: \"\n\").reversed().joined(separator: \"\n\")\n    return diag1Sym(reversedLines)\n}\n\nfunc selfieAndDiag1(_ entry: String) -> String {\n    let lines = entry.components(separatedBy: \"\n\")\n    let diagLines = diag1Sym(entry).components(separatedBy: \"\n\")\n    return zip(lines, diagLines).map { \"\\($0.0)|\\($0.1)\" }.joined(separator: \"\n\")\n}\n\nfunc oper(_ execute: (String) -> String, _ entry: String) -> String {\n    return execute(entry)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341406,"user_id":null,"body":"func proc(_ s: String) -> [String] {\n  var lines = s.components(separatedBy: \"\n\")\n  var result = [String](repeating: \"\", count: lines.count)\n  for var i in 0..<lines.count {\n      for var j in 0..<lines[i].count {\n          result[j].append(lines[i].remove(at: lines[i].startIndex)) \n      }\n  }\n  return result \n}\n\nfunc diag1Sym(_ s: String) -> String {\n    return proc(s)\n      .joined(separator: \"\n\")\n}\nfunc rot90Clock(_ s: String) -> String {\n    return proc(s)\n      .map{ String($0.reversed()) }\n      .joined(separator: \"\n\")\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n    return zip(s.components(separatedBy: \"\n\"), \n               proc(s))\n      .map { $0 + \"|\" + $1 }\n      .joined(separator: \"\n\")\n}\n\/\/ replace the dots with function parameter\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341407,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n     var arr = s.components(separatedBy: CharacterSet.controlCharacters)\n\n    var outArr = [String]()\n    for i in 0..<arr[1].characters.count {\n        var newWord = \"\"\n        for word in arr {\n            let charIndex = word.index(word.startIndex, offsetBy: i, limitedBy: word.endIndex)\n            \n            newWord.append(word[charIndex!])\n        }\n        outArr.append(newWord)\n    }\n    \n    return outArr.joined(separator: \"\n\")\n}\nfunc rot90Clock(s: String) -> String {\n    var arr = s.components(separatedBy: CharacterSet.controlCharacters)\n    \n    var outArr = [String]()\n    for i in 0..<arr[1].characters.count {\n        var newWord = \"\"\n        \n        for z in 0..<arr.count{\n            let word = arr[arr.count - 1 - z]\n            let charIndex = word.index(word.startIndex, offsetBy: i, limitedBy: word.endIndex)\n            newWord.append(word[charIndex!])\n        }\n        outArr.append(newWord)\n    }\n    \n    return outArr.joined(separator: \"\n\")\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n    let diagStr = diag1Sym(s)\n    let arrDiag = diagStr.components(separatedBy: CharacterSet.controlCharacters)\n    let arrSelf = s.components(separatedBy: CharacterSet.controlCharacters)\n    var outArr = [String]()\n    \n    for i in 0..<arrSelf.count {\n        let newWord = arrSelf[i] + \"|\" + arrDiag[i]\n        outArr.append(newWord)\n    }\n    \n    return outArr.joined(separator: \"\n\")\n}\n\/\/ replace the dots with function parameter\nfunc oper(_ fct: (_ s: String) -> (String) , _ s: String) -> String {\n    return fct(s)\n} \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341408,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n    var out : [String] = []\n    var inp = s.components(separatedBy: \"\n\")\n    var temp = \"\"\n    for x in 0..<inp.count {\n      temp = \"\"\n      for a in inp {\n        let arr = Array(a)\n        temp += String(arr[x])\n      }\n      out.append(temp)\n    }\n  return out.joined(separator: \"\n\")\n}\nfunc rot90Clock(s: String) -> String {\n    return diag1Sym(s).components(separatedBy: \"\n\").map { String($0.reversed()) }.joined(separator: \"\n\")\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n    var out : [String] = []\n    let first = s.components(separatedBy: \"\n\")\n    let second = diag1Sym(s).components(separatedBy: \"\n\")\n    for x in 0..<first.count {\n      out.append(first[x] + \"|\" + second[x])\n    }\n  return out.joined(separator: \"\n\")\n}\n\nfunc oper(_ f: (String) -> String, _ s: String) -> String {\n    return f(s)\n} \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341409,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n    let splitted = s.split(separator: \"\n\")\n    var output: String = \"\"\n    for i in 0..<splitted.count {\n        for spt in splitted {\n            output += String([Character](spt)[i])\n        }\n        output += \"\n\"\n    }\n    output = String(output.dropLast())\n\n    return output\n}\n\nfunc rot90Clock(s: String) -> String {\n    var temp = diag1Sym(s).split(separator: \"\n\").map({ $0.reversed() })\n    var output = \"\"\n    for i in 0..<temp.count {\n        output += temp[i] + \"\n\"\n    }\n    output = String(output.dropLast())\n\n    return output\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n    var tempA = s.split(separator: \"\n\")\n    var tempB = diag1Sym(s).split(separator: \"\n\")\n    var output = \"\"\n    for i in 0..<tempA.count {\n        output += tempA[i] + \"|\" + tempB[i] + \"\n\"\n    }\n    output = String(output.dropLast())\n    return output\n}\n\/\/ replace the dots with function parameter\nfunc oper(_ function: (String) -> String, _ s: String) -> String {\n    return function(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341410,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n    var result = [String]()\n    let arr = s.split(whereSeparator: \\.isNewline).map({Array($0)})\n    for i in 0..<arr.count {\n        var tmp = \"\"\n        for k in 0..<arr[0].count {\n            tmp.append(String(arr[k][i]))\n        }\n        result.append(tmp)\n    }\n    return result.joined(separator: \"\n\")\n}\n\nfunc rot90Clock(s: String) -> String {\n    diag1Sym(s).split(whereSeparator: \\.isNewline).map({String($0.reversed())}).joined(separator: \"\n\")\n}\n\nfunc selfieAndDiag1(_ s: String) -> String {\n    let a = s.split(whereSeparator: \\.isNewline)\n    let b = diag1Sym(s).split(whereSeparator: \\.isNewline)\n    return zip(a, b).map({$0.0 + \"|\" + $0.1}).joined(separator: \"\n\")\n}\n\nfunc oper(_ fnctn: (_ s: String) -> String, _ s: String) -> String {\n\n    return fnctn(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341411,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n  let rows = s.split(separator: \"\n\")\n  let n = rows[0].count\n\n  var diag = \"\"\n  for x in 0..<n {\n    for y in 0..<n {\n      let row = rows[y]\n      let start = row.index(row.startIndex, offsetBy: x)\n      let end = row.index(start, offsetBy: 1)\n      diag += row[start ..< end]\n    }\n    diag += x < n - 1 ? \"\n\" : \"\"\n  }\n  return diag\n}\nfunc rot90Clock(_ s: String) -> String {\n  let rows = s.split(separator: \"\n\")\n  let n = rows[0].count\n\n  var rot = \"\"\n  for x in 0..<n {\n    for y in 0..<n {\n      let row = rows[n-1-y]\n      let start = row.index(row.startIndex, offsetBy: x)\n      let end = row.index(start, offsetBy: 1)\n      rot += row[start ..< end]\n    }\n    rot += x < n - 1 ? \"\n\" : \"\"\n  }\n  return rot\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n  let diag = diag1Sym(s)\n  let diag_rows = diag.split(separator: \"\n\")\n  let rows = s.split(separator: \"\n\")\n  let n = rows[0].count\n\n  var combined = \"\"\n  for y in 0..<n {\n    combined += rows[y] + \"|\" + diag_rows[y]\n    combined += y < n - 1 ? \"\n\" : \"\"\n  }\n  return combined\n}\n\/\/ replace the dots with function parameter\nfunc oper(_ operation: (String) -> String, _ s: String) -> String {\n  operation(s)\n} \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341412,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n    let lines = s.components(separatedBy: \"\n\").map { $0.map { String($0) } }\n\n    let modLines = (0..<lines.count).map { index -> String in\n        lines.reduce(into: \"\") {\n            $0 = $0 + $1[index]\n        }\n    }\n\n    return modLines.joined(separator: \"\n\")\n}\nfunc rot90Clock(_ s: String) -> String {\n    let lines = s.components(separatedBy: \"\n\").map { $0.map { String($0) } }\n\n    let modLines = (0..<lines.count).map { index -> String in\n        lines.reversed().reduce(into: \"\") {\n            $0 = $0 + $1[index]\n        }\n    }\n\n    return modLines.joined(separator: \"\n\")\n}\nfunc selfieAndDiag1(_ s: String) -> String {\n    let lines = s.components(separatedBy: \"\n\")\n    let diagLines = diag1Sym(s).components(separatedBy: \"\n\")\n\n    let modLines = zip(lines, diagLines).map {\n        $0 + \"|\" + $1\n    }\n\n    return modLines.joined(separator: \"\n\")\n}\nfunc oper(_ f: (String) -> String, _ s: String) -> String {\n    f(s)\n} \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341413,"user_id":null,"body":"func diag1Sym(_ s: String) -> String {\n  let arr = s\n    .components(separatedBy: \"\n\")\n    .map { Array($0) }\n\n  return Array(0..<arr.count)\n    .map { i in\n      arr\n        .map { \"\\($0[i])\" }\n        .joined()\n    }\n    .joined(separator: \"\n\")\n}\n\nfunc rot90Clock(s: String) -> String {\n  diag1Sym(s)\n    .components(separatedBy: \"\n\")\n    .map { String($0.reversed()) }\n    .joined(separator: \"\n\")\n}\n\nfunc selfieAndDiag1(_ s: String) -> String {\n  zip(\n    s.components(separatedBy: \"\n\"),\n    diag1Sym(s).components(separatedBy: \"\n\")\n  )\n    .map { \"\\($0)|\\($1)\" }\n    .joined(separator: \"\n\")\n}\n\nfunc oper(_ o: (String) -> String, _ s: String) -> String {\n  o(s)\n} \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dbf59b0a10feb08c000227":[{"id":341414,"user_id":492,"body":"func diag2Sym(_ s: String) -> String {\n    return vertMirror(horMirror(diag1Sym(s)))\n}\nfunc rot90Counter(_ s: String) -> String {\n    return horMirror(diag1Sym(s))\n}\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    var r: [String] = [String]()\n    let arr = s.characters.split(separator: \"\n\").map(String.init)\n    let arr1 = diag2Sym(s).characters.split(separator: \"\n\").map(String.init)\n    let arr2 = rot90Counter(s).characters.split(separator: \"\n\").map(String.init)\n    for (i, element) in arr.enumerated() {\n        r.append(element + \"|\" + arr1[i] + \"|\" + arr2[i])\n    }\n    return r.joined(separator: \"\n\")\n}\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341415,"user_id":492,"body":"func diag2Sym(_ s: String) -> String {\n    return vertMirror(horMirror(diag1Sym(s)))\n}\nfunc rot90Counter(_ s: String) -> String {\n    return horMirror(diag1Sym(s))\n}\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    var r: [String] = [String]()\n    let arr = s.characters.split(separator: \"\n\").map(String.init)\n    let arr1 = diag2Sym(s).characters.split(separator: \"\n\").map(String.init)\n    let arr2 = rot90Counter(s).characters.split(separator: \"\n\").map(String.init)\n    for (i, element) in arr.enumerated() {\n        r.append(element + \"|\" + arr1[i] + \"|\" + arr2[i])\n    }\n    return r.joined(separator: \"\n\")\n}\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341416,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n    return rot90Counter(s).components(separatedBy: \"\n\").map{ String($0.characters.reversed()) }.joined(separator: \"\n\")\n}\nfunc rot90Counter(_ s: String) -> String {\n    var substrings = s.components(separatedBy: \"\n\")\n    let arrayElements : Int = substrings.count\n    \n    var diagStrSym : [String] = Array()\n    while substrings.first != \"\" {\n        var newElement = \"\"\n        for i in 0..<arrayElements {\n            let elementChar = substrings[i].characters.removeFirst()\n            newElement += String(elementChar)\n        }\n        diagStrSym.append(newElement)\n    }\n    return diagStrSym.reversed().joined(separator: \"\n\")\n}\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    let firstArray = s.components(separatedBy: \"\n\")\n    let secondArray = diag2Sym(s).components(separatedBy: \"\n\")\n    let thirdArray = rot90Counter(s).components(separatedBy: \"\n\")\n    let intermediateArray = zip(firstArray, secondArray).map { \"\\($0.0)|\\($0.1)\"}\n    return zip(intermediateArray, thirdArray).map { \"\\($0.0)|\\($0.1)\"}.joined(separator: \"\n\")\n}\n\/\/ replace the dots by your function parameter\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341417,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n    let splitted = s.split(separator: \"\n\")\n    var output: String = \"\"\n    for i in (0..<splitted.count).reversed() {\n        for j in (0..<splitted.count).reversed() {\n            output += String([Character](splitted[j])[i])\n        }\n        output += \"\n\"\n    }\n    output = String(output.dropLast())\n\n    return output\n}\n\nfunc rot90Counter(_ s: String) -> String {\n    var temp = diag2Sym(s).split(separator: \"\n\").map({ $0.reversed() }).map({ String($0) })\n    return temp.joined(separator: \"\n\")\n}\n\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    var tempA = s.split(separator: \"\n\")\n    var tempB = diag2Sym(s).split(separator: \"\n\")\n    var tempC = rot90Counter(s).split(separator: \"\n\")\n    var output = \"\"\n    for i in 0..<tempA.count {\n        output += tempA[i] + \"|\" + tempB[i] + \"|\" + tempC[i] + \"\n\"\n    }\n    output = String(output.dropLast())\n\n    return output\n}\n\nfunc oper(_ function: (String) -> String, _ s: String) -> String {\n    return function(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341418,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n    let arr = s.split(whereSeparator: \\.isNewline).map({Array($0)})\n    var tmp = \"\"\n    var result = [String]()\n    for i in stride(from: arr.count - 1, through: 0, by: -1) {\n        for k in stride(from: arr.count - 1, through: 0, by: -1) {\n            tmp.append(String(arr[k][i]))\n        }\n        result.append(tmp)\n        tmp = \"\"\n    }\n    return result.joined(separator: \"\n\")\n}\nfunc rot90Counter(_ s: String) -> String {\n    var arr = diag2Sym(s).split(whereSeparator: \\.isNewline).map({Array($0)})\n    var result = [String]()\n    for i in 0..<arr.count {\n        let tmp = String(arr[i].reversed())\n        result.append(tmp)\n    }\n    return result.joined(separator: \"\n\")\n}\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    var result = [String]()\n    let a = s.split(whereSeparator: \\.isNewline).map({Array($0)})\n    let b = diag2Sym(s).split(whereSeparator: \\.isNewline).map({Array($0)})\n    let c = rot90Counter(s).split(whereSeparator: \\.isNewline).map({Array($0)})\n    for i in 0..<a.count {\n        let tmp = [a[i], b[i], c[i]]\n        result.append(String(tmp.joined(separator: \"|\")))\n    }\n    return result.joined(separator: \"\n\")\n}\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    return fcn(s)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341419,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n  let a = s.components(separatedBy: \"\n\")\n  return Array(repeating: \"\", count: a.first!.count)\n    .enumerated()\n    .reversed()\n    .map { i, _ in\n      String(\n        a\n          .reversed()\n          .map { $0[$0.index($0.startIndex, offsetBy: i)] }\n      )\n    }\n    .joined(separator: \"\n\")\n}\n\nfunc rot90Counter(_ s: String) -> String {\n  let a = s.components(separatedBy: \"\n\")\n  return Array(repeating: \"\", count: a.first!.count)\n    .enumerated()\n    .reversed()\n    .map { i, _ in\n      String(\n        a.map { $0[$0.index($0.startIndex, offsetBy: i)] }\n      )\n    }\n    .joined(separator: \"\n\")\n}\n\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n  let a = s.components(separatedBy: \"\n\")\n  let b = diag2Sym(s).components(separatedBy: \"\n\")\n  let c = rot90Counter(s).components(separatedBy: \"\n\")\n  return a\n    .enumerated()\n    .map { \"\\($0.1)|\\(b[$0.0])|\\(c[$0.0])\" }\n    .joined(separator: \"\n\")\n}\n\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n  fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341420,"user_id":null,"body":"func diag2Sym(_ string: String) -> String {\n    let matrix = string.split(separator: \"\n\").map(Array.init)\n  \n    var result = \"\"\n    for i in 0..<matrix.count {\n        if i > 0 {\n            result += \"\n\"\n        }\n      \n        for j in 0..<matrix.count {\n            result += String(matrix[matrix.count - j - 1][matrix.count - i - 1])\n        }\n    }\n    return result\n}\n\nfunc rot90Counter(_ string: String) -> String {\n    let matrix = string.split(separator: \"\n\").map(Array.init)\n  \n    var result = \"\"\n    for i in 0..<matrix.count {\n        if i > 0 {\n            result += \"\n\"\n        }\n      \n        for j in 0..<matrix.count {\n            result += String(matrix[j][matrix.count - i - 1])\n        }\n    }\n    return result\n}\n\nfunc selfieDiag2Counterclock(_ string: String) -> String {\n    let matrix = string.split(separator: \"\n\").map(Array.init)\n  \n    var result = \"\"\n    for i in 0..<matrix.count {\n        if i > 0 {\n            result += \"\n\"\n        }\n      \n        for j in 0..<matrix.count {\n            result += String(matrix[i][j])\n        }\n      \n        result += \"|\"\n      \n        for j in 0..<matrix.count {\n            result += String(matrix[matrix.count - j - 1][matrix.count - i - 1])\n        }\n      \n        result += \"|\"\n      \n        for j in 0..<matrix.count {\n            result += String(matrix[j][matrix.count - i - 1])\n        }\n    }\n    return result\n}\n\n\/\/ replace the dots by your function parameter\nfunc oper(_ operation: (String) -> String, _ string: String) -> String {\n    operation(string)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341421,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n    var arr = Array(s.components(separatedBy: \"\n\").reversed())\n    var output = [String]()\n    while !arr[0].isEmpty {\n        var x = \"\"\n        for i in 0..<arr.count {\n            x += String(arr[i].removeFirst())\n        }\n        output.insert(x, at: 0)\n    }\n    return output.joined(separator: \"\n\")\n}\nfunc rot90Counter(_ s: String) -> String {\n    return diag1Sym(s).components(separatedBy: \"\n\").reversed().joined(separator: \"\n\")\n}\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    var output = s.components(separatedBy: \"\n\")\n    let diag = diag2Sym(s).components(separatedBy: \"\n\")\n    let rot = rot90Counter(s).components(separatedBy: \"\n\")\n    for i in 0..<output.count {\n        output[i] += \"|\" + diag[i] + \"|\" + rot[i]\n    }\n    return output.joined(separator: \"\n\")\n}\nfunc oper(_ completion: (String) -> String, _ s: String) -> String {\n    return completion(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341422,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n  let arr = s.components(separatedBy: \"\n\")\n  var res = Array(repeating: \"\", count: arr.count)\n  for a in arr {\n    for (i,c) in a.enumerated() {\n      res[i] += String(c)\n    }\n  }\n  return res.reversed().map { String($0.reversed()) }.joined(separator: \"\n\")\n}\nfunc rot90Counter(_ s: String) -> String {\n  let arr =  diag2Sym(s).components(separatedBy: \"\n\")\n  return arr.map { String($0.reversed()) }.joined(separator: \"\n\")\n}\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n  let arr = s.components(separatedBy: \"\n\")\n  let diag2SymArr =  diag2Sym(s).components(separatedBy: \"\n\")\n  let rot90CounterArr =  rot90Counter(s).components(separatedBy: \"\n\")\n  let zipArr = zip(zip(arr, diag2SymArr), rot90CounterArr)\n  return zipArr.map { \"\\(String($0.0.0))|\\(String($0.0.1))|\\(String($0.1))\" }.joined(separator: \"\n\")\n}\n\/\/ replace the dots by your function parameter\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    fcn(s)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341423,"user_id":null,"body":"func diag2Sym(_ s: String) -> String {\n    let arr = s.components(separatedBy: \"\n\")\n    var result = [String]()\n    \n    columnLoop: for col in 0..<arr.count {\n        var string = \"\"\n        rowLoop: for row in 0..<arr.count {\n            let adjustedCol = arr.count - 1 - col\n            let adjustedRow = arr.count - 1 - row\n        \n            let char = arr[adjustedRow][adjustedCol]\n            string.append(char)\n        }\n        result.append(string)\n    }\n    \n    return result.joined(separator: \"\n\")\n}\nfunc rot90Counter(_ s: String) -> String {\n    let arr = s.components(separatedBy: \"\n\")\n    var result = [String]()\n    \n    columnLoop: for col in 0..<arr.count {\n        var string = \"\"\n        rowLoop: for row in 0..<arr.count {\n            let adjustedCol = arr.count - 1 - col\n        \n            let char = arr[row][adjustedCol]\n            string.append(char)\n        }\n        result.append(string)\n    }\n    \n    return result.joined(separator: \"\n\")\n}\n\nfunc selfieDiag2Counterclock(_ s: String) -> String {\n    let initial = s.components(separatedBy: \"\n\")\n    let diag = diag2Sym(s).components(separatedBy: \"\n\")\n    let rot = rot90Counter(s).components(separatedBy: \"\n\")\n    \n    var result = [String]()\n    for i in 0..<initial.count {\n        result += [\"\\(initial[i])|\\(diag[i])|\\(rot[i])\"]\n    }\n    \n    return result.joined(separator: \"\n\")\n}\n\n\/\/ replace the dots by your function parameter\nfunc oper(_ fcn: (String) -> String, _ s: String) -> String {\n    fcn(s)\n} \n\nextension String {\n    public subscript(_ index: Int) -> Character {\n        let stringIndex = self.index(startIndex, offsetBy: index)\n        return self[stringIndex]\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56dec885c54a926dcd001095":[{"id":341424,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  return -number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341425,"user_id":null,"body":"func opposite(number: Double) -> Double {\n \/\/ # your solution here\n  return -number \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341426,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  -number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341427,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  \/\/ your solution here\n  return number * -1.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341428,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  return number * -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341429,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  var x = number\n  x.negate()\n  return x\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341430,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  return Double(number - number * 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341431,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  return 0 - number\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341432,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  var newNumber = 0.00\n  newNumber += number\n  newNumber.negate()\n  return newNumber\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341433,"user_id":null,"body":"func opposite(number: Double) -> Double {\n  \/\/your solution here\n    var num = number\n    if num > 0 || num < 0 {\n        num = (0 - num)\n    }\n    return num\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56efab15740d301ab40002ee":[{"id":341434,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int { return x + y }\nfunc maxi(_ x: Int, _ y: Int) -> Int { return x > y ? x : y }\nfunc mini(_ x: Int, _ y: Int) -> Int { return x < y ? x : y }\nfunc lcmu(_ a: Int, _ b: Int) -> Int { return abs(a * b \/ gcdi(a, b)) }\n\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    var a = abs(x), b = abs(y)\n    while a != 0, b != 0 { if a > b {a %= b} else {b %= a} }\n    return a + b\n}\n\nfunc operArray(_ f: (Int, Int) -> (Int), _ a: [Int], _ iniVal: Int) -> [Int] {\n    var arr = a; arr[0] = f(a[0], iniVal)\n    (1..<a.count).forEach { arr[$0] = f(arr[$0], arr[$0 - 1]) }\n    return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341435,"user_id":492,"body":"func som(_ x: Int, _ y: Int) -> Int {\n    return x + y\n}\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n    if x > y {return x} else {return y}\n}\nfunc mini(_ x: Int, _ y: Int) -> Int {\n    if x < y {return x} else {return y}\n}\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    let m = abs(x), n = abs(y)\n    if m == 0 {return n} else {return gcdi(n % m, m)}\n}\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    return abs(a) * abs(b) \/ gcdi(a, b)\n}\n\nfunc operArray(_ fcn: (Int, Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n    return Array(a.scan(iniVal, fcn).dropFirst(1))  \n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341436,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int {\n  return x + y\n}\n\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n  return max(x, y)\n}\n\nfunc mini(_ x: Int, _ y: Int) -> Int {\n  return min(x, y)\n}\n\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n  var a = 0\n  var b = max(x, y)\n  var r = min(x, y)\n    \n  while r != 0 {\n    a = b\n    b = r\n    r = a % b\n  }\n  return abs(b)\n}\n\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n  return abs(a\/gcdi(a, b) * b)\n}\n\nfunc operArray(_ operation: (Int, Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n  var result: [Int] = [iniVal]\n  for i in 0..<a.count {\n    result.append(operation(result[i], a[i]))\n  }\n  result.removeFirst(1)\n  return result\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341437,"user_id":null,"body":"let som: (Int, Int) -> Int = (+)\nlet maxi: (Int, Int) -> Int = max\nlet mini: (Int, Int) -> Int = min\nlet gcdi: (Int, Int) -> Int = {\n  var (x, y) = (abs($0), abs($1))\n  while (y != 0) { (x, y) = (y, x % y) }\n  return x\n}\nlet lcmu: (Int, Int) -> Int = { abs($0) * abs($1) \/ gcdi($0, $1) }\n\nfunc operArray<T>(_ f: (T, T) -> T, _ a: [T], _ iV: T) -> [T] {\n  return a.reduce(into: []) { $0.append(f($0.last ?? iV, $1)) }\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341438,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int {\n    return x + y\n}\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n    return max(x, y)\n}\nfunc mini(_ x: Int, _ y: Int) -> Int {\n    return min(x, y)\n}\nfunc gcdi(_ a: Int, _ b: Int) -> Int {\n    return abs(b) != 0 ? gcdi(abs(b), abs(a)%abs(b)) : abs(a)\n}\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    return  abs(a) * abs(b) \/ gcdi(abs(a), abs(b))\n}\n\nfunc operArray(_ block:(Int, Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n    var temp = iniVal\n    return a.map {\n        temp = block(temp, $0)\n        return temp\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341439,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int {\n    x + y\n}\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n    max(x, y)\n}\nfunc mini(_ x: Int, _ y: Int) -> Int {\n    min(x, y)\n}\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    let curMax = max(abs(x), abs(y))\n    let minElem = min(abs(x), abs(y))\n    \n    var subMax = curMax\n    var subMin = minElem\n    \n    if minElem == 0 {\n        return curMax\n    }\n    \n    while subMax != subMin {\n        print(\"subMax \\(subMax)\")\n        print(\"subMin \\(subMin)\")\n        if subMax >= subMin {\n            subMax = subMax - subMin\n        } else {\n            subMin = subMin - subMax\n        }\n            \n    }\n    \n    return subMin\n}\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    var curMax = max(abs(a), abs(b))\n    var minElem = min(abs(a), abs(b))\n    \n    let constForPlusInMax = curMax\n    let constForPlusInMin = minElem\n    \n    if minElem == 0 {\n        return curMax\n    }\n    \n    while minElem != curMax {\n        if minElem > curMax {\n            curMax += constForPlusInMax\n        } else {\n            minElem += constForPlusInMin\n        }\n    }\n    \n    return minElem\n}\n\n\/\/ replace the dots with a declaration of function\nfunc operArray(_ myFunc: (Int, Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n    var tempArray = a\n    var secondElem = iniVal\n    \n    for ind in 0..<tempArray.count {\n        tempArray[ind] = myFunc(secondElem, tempArray[ind])\n        secondElem = tempArray[ind]\n    }\n    \n    return tempArray\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341440,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int {\n    x + y\n}\n\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n    max(x, y)\n}\n\nfunc mini(_ x: Int, _ y: Int) -> Int {\n    min(x, y)\n}\n\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    (y != 0) ? gcdi(y, x % y) : abs(x)\n}\n\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    abs(a * b) \/ gcdi(a, b)\n}\n\nfunc operArray(_ function: (Int, Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n    var iniVal = iniVal\n    return a.map({value in\n        iniVal = function(iniVal, value)\n        return iniVal\n    })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341441,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int {\n    return x + y\n}\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n    return max(x, y)\n}\nfunc mini(_ x: Int, _ y: Int) -> Int {\n    return min(x, y)\n}\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    var a = 0\n    var b = max(abs(x), abs(y))\n    var r = min(abs(x), abs(y))\n    \n    while r != 0 {\n        a = b\n        b = r\n        r = a % b\n    }\n    return b\n}\n\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    return abs((a \/ gcdi(a, b)) * b)\n}\n\n\/\/ replace the dots with a declaration of function\nfunc operArray(_ function: (Int, Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n    print(\"Test: \\(a), start: \\(iniVal)\")\n    var output = a\n    output[0] = function(iniVal, output[0])\n    for i in 1...a.count-1 {\n        output[i] = function(output[i-1], output[i])\n    }\n    print(\"Output: \\(output)\")\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341442,"user_id":null,"body":"import Foundation\n\n\/\/ Reducing by steps\n\/\/ https:\/\/www.codewars.com\/kata\/56efab15740d301ab40002ee\/train\/swift\nfunc som(_ x: Int, _ y: Int) -> Int { x + y }\nfunc maxi(_ x: Int, _ y: Int) -> Int { x > y ? x : y }\nfunc mini(_ x: Int, _ y: Int) -> Int { x < y ? x : y }\nfunc lcmu(_ a: Int, _ b: Int) -> Int { abs(a * b \/ gcdi(a, b)) }\n\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    var a = abs(x), b = abs(y)\n    while a != 0, b != 0 { a > b ? (a %= b) : (b %= a) }\n    return a + b\n}\n\nfunc operArray(_ f: (Int, Int) -> (Int), _ a: [Int], _ iniVal: Int) -> [Int] {\n    var arr = a; arr[0] = f(a[0], iniVal)\n    (1..<a.count).forEach { arr[$0] = f(arr[$0], arr[$0 - 1]) }\n    return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341443,"user_id":null,"body":"func som(_ x: Int, _ y: Int) -> Int {\n    x + y\n}\nfunc maxi(_ x: Int, _ y: Int) -> Int {\n    max(x, y)\n}\nfunc mini(_ x: Int, _ y: Int) -> Int {\n    min(x, y)\n}\nfunc gcdi(_ x: Int, _ y: Int) -> Int {\n    var gcdi = 1\n    for i in 2...(max(abs(x), abs(y))) {\n        if x % i == 0 && y % i == 0 {\n            gcdi = i > gcdi ? i : gcdi\n        }\n    }\n    return gcdi\n}\nfunc lcmu(_ a: Int, _ b: Int) -> Int {\n    for i in 1... {\n        if (a * i) % b == 0 {\n            return abs(a) * i\n        }\n    }\n    return 1\n}\nfunc operArray(_ fct: (_ x: Int, _ y: Int) -> Int, _ a: [Int], _ iniVal: Int) -> [Int] {\n    var out = [Int]()\n    var initVal = iniVal\n    for el in 0..<a.count {\n        out.append(fct(initVal, a[el]))\n        initVal = fct(initVal, a[el])\n    }\n    return out\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56f69d9f9400f508fb000ba7":[{"id":341444,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n  return Array(1...n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341445,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n  guard n > 0 else {return []}\n    return Array(1...n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341446,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n  var arrayOfNumbers = [Int]()\n    \n    for i in 1...n {\n        arrayOfNumbers.append(i)\n    }\n  return arrayOfNumbers\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341447,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n    return (1...n).map { $0 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341448,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n    return n > 0 ? [Int](1...n) : []\n} \/\/ OK\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341449,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n    return stride(from: 1, through: n, by: 1).sorted()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341450,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n    (1...n).sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341451,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n    \n    var arr = [Int]()\n    \n    for n in 1...n {\n        arr.append(n)\n    }\nreturn arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341452,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n  var result: [Int] = []\n  for counter in 1...n {\n    result.append(counter)\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341453,"user_id":null,"body":"func monkey_count(_ n: Int) -> [Int] {\n  return Array(Array(1...n).prefix(upTo: n))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"56fcc393c5957c666900024d":[{"id":341454,"user_id":492,"body":"import Foundation\n\nfunc code(_ s: String) -> String {\n    if (s.isEmpty) {return \"\"}\n    let l: Int = s.characters.count\n    var ss = s\n    let sz: Int = Int(ceil(sqrt(Double(l))))\n    var cnt = l\n    while (cnt != sz * sz) {\n        ss += \"\\u{F7}\"\n        cnt += 1\n    }\n    let a: String = ss.splitByLength(sz).joined(separator: \"\\n\")\n    return rot90Clock(a)\n}\nfunc decode(_ s: String) -> String {\n    if (s.isEmpty) {return \"\"}\n    return rot90Counter(s)\n        .characters.split(separator: \"\\u{F7}\").map(String.init)[0]\n        .characters.split(separator: \"\\n\").map(String.init).joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341455,"user_id":null,"body":"func code(_ s: String) -> String {\n    let l : Int = Int(sqrt(Double(s.characters.count)).rounded(.awayFromZero))\n    let totalSqStrLength : Int = l * l\n    var newS : String = s\n    let char : Character = \"\\u{F7}\"\n    \n    if s.characters.count < totalSqStrLength {\n        let charsToAdd = totalSqStrLength - s.characters.count\n        newS = s + String(repeatElement(char, count: charsToAdd))\n    }\n\n    var newSArray = Array(newS.characters)\n    var sInSqSegments : Array = [String]()\n    var count : Int = 0\n    while count < totalSqStrLength {\n        var str = \"\"\n        for i in 0..<l {\n            str += String(newSArray.remove(at: 0))\n            count += 1\n        }\n        sInSqSegments.append(str)\n    }\n        func diag1Sym (_ s: String) -> String {\n        var substrings = s.components(separatedBy: \"\\n\")\n        let arrayElements : Int = substrings.count\n        \n        var diagStrSym : [String] = Array()\n        while substrings.first != \"\" {\n            var newElement = \"\"\n            for i in 0..<arrayElements {\n                let elementChar = substrings[i].characters.removeFirst()\n                newElement += String(elementChar)\n            }\n            diagStrSym.append(newElement)\n        }\n        return diagStrSym.joined(separator: \"\\n\")\n    }\n    func rot90Clock (_ s: String ) -> String {\n        return diag1Sym(s).components(separatedBy: \"\\n\").map{ String($0.characters.reversed()) }.joined(separator: \"\\n\")\n    }\n    return rot90Clock(sInSqSegments.joined(separator: \"\\n\"))\n}\n\nfunc decode(_ s: String) -> String {\n    func rot90Counter(_ s: String) -> String {\n        var substrings = s.components(separatedBy: \"\\n\")\n        let arrayElements : Int = substrings.count\n        \n        var diagStrSym : [String] = Array()\n        while substrings.first != \"\" {\n            var newElement = \"\"\n            for i in 0..<arrayElements {\n                let elementChar = substrings[i].characters.removeFirst()\n                newElement += String(elementChar)\n            }\n            diagStrSym.append(newElement)\n        }\n        return diagStrSym.reversed().joined(separator: \"\\n\")\n    }\n    \n        return String(rot90Counter(s).characters.filter{ $0 != \"\\u{F7}\" && $0 != \"\\n\"})\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341456,"user_id":null,"body":"func code(_ s: String) -> String {\n  let n = Int(Double(s.count).squareRoot().rounded(.up))\n\n  var filled = s\n  while filled.count < n * n {\n    filled += \"\u00f7\"\n  }\n  \n  var res = Array(repeating: \"\", count: n)\n  \n  filled\n    .enumerated()\n    .map { ($0, \"\\($1)\") }\n    .forEach {\n      res[$0 % n] = $1 + res[$0 % n]\n    }\n  \n  return res.joined(separator: \"\\n\")\n}\n\nfunc decode(_ s: String) -> String {\n  guard !s.isEmpty else { return \"\" }\n  \n  let lines = s\n    .components(separatedBy: \"\\n\")\n    .map {\n      $0.map { \"\\($0)\" }\n    }\n  \n  let n = lines.count\n  \n  var res = \"\"\n  \n  for char in (0..<n).reversed() {\n    for line in 0..<n {\n      guard lines[line][char] != \"\u00f7\" else { continue }\n      res += lines[line][char]\n    }\n  }\n  \n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341457,"user_id":null,"body":"func code(_ s: String) -> String {\n  guard !s.isEmpty else {\n    return \"\"\n  }\n  let filler = Character(\"\u00f7\")\n  var array = Array(s)\n  let l = array.count\n  let n = Int(ceil(sqrt(Double(l))))\n  \n  let toFill = n * n % l\n  if toFill > 0 {\n    for _ in 0 ..< toFill {\n      array.append(filler)\n    }\n  }\n  var codeArray = [[Character]]()\n  while !array.isEmpty {\n    let chunk = array.prefix(n)\n    codeArray.append(Array(chunk))\n    array.removeFirst(n)\n  }\n  \n  var codedArray = [[Character]](repeating: [Character](), count: n)\n  \n  for i in 0 ..< n {\n    for j in 0 ..< n {\n      codedArray[i].insert(codeArray[j][i], at: 0)\n    }\n  }\n  \n  return codedArray.map({ String($0) }).joined(separator: \"\\n\")\n}\nfunc decode(_ s: String) -> String {\n  guard !s.isEmpty else {\n    return \"\"\n  }\n\n  let filler = Character(\"\u00f7\")\n  \n  let codedArray = s.components(separatedBy: \"\\n\").map { Array($0) }\n  let n = codedArray.count\n  \n  var decodedArray = [[Character]](repeating: [Character](), count: n)\n  for i in 0 ..< n {\n    for j in 0 ..< n {\n      decodedArray[i].insert(codedArray[n - 1 - j][n - 1 - i], at: 0)\n    }\n  }\n  \n  return decodedArray.map({ String($0.filter({$0 != filler})) }).joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341458,"user_id":null,"body":"func code(_ s: String) -> String {\n  if s.count == 0 { return s }\n  let n = Int(Double(s.count).squareRoot())+1\n  let a = Array(s) + Array(repeating: \"\\u{F7}\", count: n*n-s.count)\n  var b = Array(repeating: Array(repeating: Character(\" \"), count: n), count: n)\n  for (i, c) in a.enumerated() { b[i\/n][i%n] = c }\n  return (0..<n).map { i in b.reversed().map { String($0[i]) }.joined() }.joined(separator: \"\\n\")\n}\nfunc decode(_ s: String) -> String {\n  if s.count == 0 { return s }\n  let bb = s.split(separator: \"\\n\").map { Array($0) }\n  let nn = bb[0].count\n  return stride(from:nn-1,to:-1,by:-1).map { i in bb.map { String($0[i]) }.joined() }.joined().trimmingCharacters(in: CharacterSet(charactersIn: \"\\u{F7}\"))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341459,"user_id":null,"body":"func code(_ s: String) -> String {\n    var s = s.map{ String($0) }\n    while sqrt(Double(s.count)) != floor(sqrt(Double(s.count))) {\n        s.append(\"\u00f7\")\n    }\n    let n = Int(sqrt(Double(s.count)))\n    var arr = Array(repeating: \"\", count: n)\n    for i in 0..<s.count {\n        arr[i % n] = s[i] + arr[i % n]\n    }\n    return arr.joined(separator: \"\\n\")\n    \n}\nfunc decode(_ s: String) -> String {\n    var s = s.components(separatedBy: \"\\n\")\n    var output = \"\"\n    while s[s.count - 1].count > 0 {\n        for i in 0..<s.count {\n            if String(s[i].last!) != \"\u00f7\" {\n                output += String(s[i].last!)\n            }\n            s[i] = String(s[i].dropLast())\n        }\n    }\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341460,"user_id":null,"body":"func code(_ s: String) -> String {\n  let length = s.count\n  guard length > 0 else { return \"\" }\n  let side = Int(ceil(sqrt(Double(length))))\n  let padding = String(repeating: \"\u00f7\", count: side * side - length)\n  let padded = Array(\"\\(s)\\(padding)\")\n  let sideSquared = side * side\n  let result = padded.indices.map { index -> Character in\n    let x = index % side\n    let y = index \/ side\n    return padded[sideSquared - x * side - side + y]\n  }\n  return String(\n    stride(from: 0, to: result.count, by: side)\n      .map { result[$0..<min($0 + side, result.count)] }\n      .joined(separator: \"\\n\")\n  )\n}\nfunc decode(_ s: String) -> String {\n  let side = Int(sqrt(Double(s.count)))\n  let padded = Array(s.split(separator: \"\\n\").joined())\n  assert(padded.count == side * side)\n  return String(\n    padded.indices\n      .map { index -> Character in\n        let x = index % side\n        let y = index \/ side\n        return padded[x * side + side - y - 1]\n      }\n      .reversed().drop { $0 == \"\u00f7\" }.reversed()\n  )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341461,"user_id":null,"body":"func clockWise90Rot( _ squared : String ) -> String {\n    let lines   = squared.split(separator: \"\\n\")\n    let columns = lines.reversed()\n    var rotatedLine = \"\"\n\n    for idx in (0..<lines.count) {\n        columns.forEach{ column in\n                        let index = column.index(column.startIndex, offsetBy: idx)\n                        rotatedLine = rotatedLine + String(column[index]) }\n        \n        if idx != lines.count-1 {\n            rotatedLine += \"\\n\"\n        }\n    }\n    \n    return rotatedLine\n}\n\nfunc counterClockWise90Rot( _ squared : String ) -> String {\n    let lines   = squared.split(separator: \"\\n\")\n    let columns = lines\n    var rotatedLine = \"\"\n\n    for idx in stride(from: lines.count - 1, through: 0, by: -1) {\n        columns.forEach{ column in\n                        let index = column.index(column.startIndex, offsetBy: idx)\n                        rotatedLine = rotatedLine + String(column[index]) }\n        rotatedLine += \"\\n\"\n    }\n    \n    return rotatedLine\n}\n\n\nfunc code(_ s: String) -> String {\n    \n    if s.count < 1 { return \"\" }\n  \n    let smallestAbove = Int(sqrt(Double(s.count)).rounded(.up))\n    var complete = s + String(repeating: \"\u00f7\", count: Int(smallestAbove*smallestAbove) - s.count)\n    \n    \/\/print( \"complete Length \\(complete.count) SmallestAbove : \\(smallestAbove) COmplete \\(complete)\")\n    var completedivided = \"\"\n    for idx in stride(from: 0, through: complete.count-1, by: smallestAbove) {\n        let start = complete.index(complete.startIndex, offsetBy: idx)\n        let end   = complete.index(complete.startIndex, offsetBy: idx+smallestAbove)\n        completedivided = completedivided + complete[start..<end] + \"\\n\"\n    }\n\n    complete = clockWise90Rot(completedivided)\n    return complete\n}\n\nfunc decode(_ s: String) -> String {\n    var decoded = counterClockWise90Rot(s)\n    \n    decoded = decoded.replacingOccurrences(of: \"\\n\", with: \"\")\n    decoded = decoded.replacingOccurrences(of: \"\u00f7\", with: \"\")\n    \n    return decoded\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341462,"user_id":null,"body":"func code(_ s: String) -> String {\n    let n = Int(ceil(sqrt(Double(s.count))))\n    let s = s + String(repeating: \"\\u{F7}\", count: max(n*n - s.count, 0))\n    var array = Array(repeating: \"\", count: n)\n    var index = s.startIndex\n    for i in 0..<s.count {\n        array[i % n] = \"\\(s[index])\" + array[i % n]\n        index = s.index(after: index)\n    }\n    return array.joined(separator: \"\\n\")\n}\n\nfunc decode(_ s: String) -> String {\n    let strs = s.split(separator: \"\\n\")\n    var s1 = \"\"\n    for i in 0..<strs.count {\n        let i = strs.count - i - 1\n        for j in 0..<strs.count {\n            let s2 = strs[j]\n            s1 += \"\\(s2[s2.index(s2.startIndex, offsetBy: i)])\"\n        }\n    }\n    return String(s1.prefix(upTo: s1.firstIndex(of: \"\u00f7\") ?? s1.endIndex))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"},{"id":341463,"user_id":null,"body":"func code(_ s: String) -> String {\n    let n = Int(ceil(sqrt(Double(s.count))))\n    let s = Array(s) + Array(repeating: \"\u00f7\", count: n*n - s.count)\n    var output = \"\", i = (n - 1) * n\n    while s.indices.contains(i) {\n        output.append(s[i])\n        if i == n - 1 { break }\n        if i - n < 0 {\n            i += (n - 1) * n + 1\n            output.append(\"\\n\")\n        } else {\n            i -= n\n        }\n    }\n    return output\n}\n\nfunc decode(_ s: String) -> String {\n    let s = s.replacingOccurrences(of: \"\\n\", with: \"\")\n    let n = Int(sqrt(Double(s.count)))\n    let arr = Array(s)\n    var output = \"\", i = n - 1\n    while arr.indices.contains(i) {\n        output.append(arr[i])\n        if i + n > n*n {\n            i -= (n - 1) * n + 1\n        } else {\n            i += n\n        }\n    }\n    return output.replacingOccurrences(of: \"\u00f7\", with: \"\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2023-01-10 12:44:19"}],"56fe17fcc25bf3e19a000292":[{"id":341464,"user_id":492,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n    return (2 * n + 1) * p\n}\nfunc u1(_ n: Int, _ p: Int) -> Int {\n    return (n + 1) * p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341465,"user_id":null,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n  2 * n * p + p\n}\n\nfunc u1(_ n: Int, _ p: Int) -> Int {\n  p * (n + 1)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341466,"user_id":null,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n  return 2*n*p+p\n}\n\nfunc u1(_ n: Int, _ p: Int) -> Int {\n  return (n+1)*p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341467,"user_id":null,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n    return (n * 2 + 1) * p\n}\nfunc u1(_ n: Int, _ p: Int) -> Int {\n    return (n + 1) * p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341468,"user_id":null,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n    (2 * n + 1) * p\n}\n\nfunc u1(_ n: Int, _ p: Int) -> Int {\n    (n + 1) * p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341469,"user_id":null,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n    return (n + n + 1) * p\n}\n\nfunc u1(_ n: Int, _ p: Int) -> Int {\n    return n * p + p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341470,"user_id":null,"body":"func nCk(_ n: Int, _ k: Int ) -> Double {\n\n  let d_times_i = {(a:Double,i:Int) in a * Double(i)}\n  let fnk = ( k < n ? ((k+1)...n).reduce( 1.0, d_times_i ) : 1.0 )  \n\n  let kfact = ( k > 0 ? ( 1 ... k ).reduce( 1.0, d_times_i ) : 1.0 )\n  \n  return fnk \/ kfact\n}\n\n\nfunc v1(_ n: Int, _ p: Int) -> Int {\n  \/* var s = 0.0\n  for k in 0...n  {\n    s += ( k % 2 == 0 ? 1.0 : -1.0) * pow(4.0, Double(n - k) ) * nCk( (2 * n) - k, k )\n  } *\/\n  \n  return p * (2 * n + 1) \/\/ Int(s)\n}\nfunc u1(_ n: Int, _ p: Int) -> Int {\n  \/* var s = 0.0\n  for k in 0...n  {\n    s += ( k % 2 == 0 ? 1.0 : -1.0) * pow(4.0, Double(n - k)) * nCk( (2 * n) - k + 1, k )\n  }*\/\n  \n  return p * (n+1) \/\/ Int(s)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341471,"user_id":17,"body":"func v1(_ n: Int, _ p: Int) -> Int {\n  return p * (2 * n + 1)\n}\nfunc u1(_ n: Int, _ p: Int) -> Int {\n  return p * (n + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5715eaedb436cf5606000381":[{"id":341472,"user_id":527,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    return numbers.filter{ $0 > 0 }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341473,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    var total = 0\n    for number in numbers {\n        if   number > 0 {\n        total = total + number\n        }\n    }\n    return total\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341474,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n\n    return numbers.reduce (0) {$0 + max($1, 0)}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341475,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    numbers.filter {$0 > 0}.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341476,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    return numbers.lazy.filter { $0 > 0 }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341477,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n  \n  var result: Int = 0\n    \n  for number in numbers where number > 0 {\n      result += number\n  }\n  return result > 0 ? result : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341478,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    return numbers.reduce(0, { $0 + ($1 < 0 ? 0 : $1) }) \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341479,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    numbers.reduce(0) { $1 >= 0 ? $0 + $1 : $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341480,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    let positiveNumbers = numbers.filter { $0 > 0 }\n    return positiveNumbers.reduce(0, {x, y in x + y})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341481,"user_id":null,"body":"func sumOfPositives (_ numbers: [Int] ) -> Int {\n    var x = 0\n    numbers.forEach {if $0 >= 0 {x += $0}}\n    return x\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5726f813c8dcebf5ed000a6b":[{"id":341482,"user_id":492,"body":"func isPrime(_ n: UInt64) -> Bool {\n    if n == 2 { return true }\n    if (n < 3) || (n % 2 == 0) { return false }\n    let limit: UInt64 = UInt64(sqrt(Double(n)) + 1.0)\n    var i: UInt64 = 3\n    while i <= limit {\n        if n % i == 0\n            { return false }\n        i += 2\n    }\n    return true\n}\n\nfunc primeFactors(_ n: Int) -> Int {\n    var nb = n\n    var i = 2\n    var cnt = 0\n    while nb > 1 {\n        while nb % i == 0 {\n            cnt += 1\n            nb \/= i\n        }\n        i += 1\n    }\n    return cnt\n}\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n    var kprimes: [Int] = [Int]()\n    var i = start;\n    while i <= nd {\n        if primeFactors(i) == k {kprimes.append(i)}\n        i += 1\n    }\n    return kprimes\n}\n\nfunc puzzle(_ s: Int) -> Int {\n    var cnt = 0\n    let b = countKprimes(7, 128, s - 6);\n    let c = countKprimes(3, 4, s - 130);\n    for j in b {\n        for k in c {\n            if isPrime (UInt64(s - j - k))\n              {cnt += 1} \n        }\n    }\n    return cnt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341483,"user_id":53,"body":"\nfunc factors(_ m: Int) -> Int {\n  var (n, i, cnt) = (m, 3, 0)\n  while ((n & 1) == 0) {\n    cnt += 1\n    n >>= 1\n  }\n  while (i <= n \/ i) {\n    while (n % i == 0) {\n      cnt += 1\n      n \/= i\n    }\n    i += 1\n  }\n  if (n > 1) {\n    cnt += 1\n  }\n  return cnt\n}\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n  var (n, j, fs) = (start, 0, [Int]())\n  while (n <= nd) {\n    j = factors(n)\n    if (j == k) {\n      fs.append(n)\n    }\n    n += 1\n  }\n  return fs\n}\n\nfunc puzzle(_ s: Int) -> Int {\n  var (cnt, c) = (0, 0)\n  var xs = countKprimes(7, 128, s - 10)\n  var ys = countKprimes(3, 8, s - 130)\n  for i in stride(from: 0, through: xs.count - 1, by: 1) {\n    for j in stride(from: 0, through: ys.count - 1, by: 1) {\n      c = s - xs[i] - ys[j]\n      if (c > 0 && factors(c) == 1) {\n        cnt += 1\n      }\n    }\n  }\n  return cnt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341484,"user_id":null,"body":"func primeFactors(_ n: Int) -> Int {\n    var k = n\n    var factors: [Int] = []\n    var i = 2\n    while (i * i <= k) {\n        while (k % i == 0) {\n            factors.append(i)\n            k \/= i\n        }\n        i += 1\n    }\n    if (k > 1) {\n        factors.append(n)\n    }\n    return factors.count\n}\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n    var kprimes: [Int] = []\n    var i = start\n    while (i <= nd) {\n        if (primeFactors(i) == k) {\n            kprimes.append(i)\n        }\n        i += 1\n    }\n    return kprimes\n\n}\n\nfunc puzzle(_ s: Int) -> Int {\n    var counter: Int = 0\n    let k1 = countKprimes(1, 1, s)\n    let k3 = countKprimes(3, 1, s)\n    let k7 = countKprimes(7, 1, s)\n    \n    for prime1 in k1 {\n        \n        for prime3 in k3{\n            \n            for prime7 in k7 {\n                if (prime7 + prime1 + prime3 == s) {\n                counter += 1\n                }\n            }\n        }\n    }\n    \n    return counter\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341485,"user_id":null,"body":"func countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n    var result = [Int]()\n    \n    for number in start...nd {\n        if isKPrime(k, number) {\n            result.append(number)\n        }\n    }\n    \n    return result\n}\n\nfunc isKPrime(_ k: Int, _ number: Int) -> Bool {\n    var factors = 0\n    var restNumber = number;\n    \n    while restNumber % 2 == 0 {\n        restNumber \/= 2\n        factors += 1\n    }\n    \n    if number < 3 {\n        return factors == k\n    }\n        \n    for i in 3...max(Int(sqrt(Double(number))), 3) {\n        while restNumber % i == 0 {\n            restNumber \/= i\n            factors += 1\n        }\n    }\n    \n    if restNumber > 2 {\n        factors += 1\n    }\n    \n    return factors == k\n}\n\nfunc puzzle(_ s: Int) -> Int {\n    var numberOfSolutions = 0\n    \n    let ar1 = countKprimes(1, 2, s)\n    let ar3 = countKprimes(3, 2, s)\n    let ar7 = countKprimes(7, 2, s)\n     \n    for i in ar1 {\n        for j in ar3 {\n            for k in ar7 {\n                if i + j + k == s {\n                    numberOfSolutions += 1\n                }\n            }\n        }\n    }\n    \n    return numberOfSolutions\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341486,"user_id":null,"body":"func findPrimes(_ n: Int) -> [Int] {\n    var num = n\n    var divisor = 2 \n    var factors = [Int]()\n    \n\/\/     factors.append(num)\n    while divisor * divisor <= num {\n      while num % divisor == 0 {\n        factors.append(divisor)\n        num \/= divisor\n      }\n      divisor += divisor == 2 ? 1 : 2\n    }\n    \n    if num > 1 {\n      factors.append(num)\n    }\n    \n    return factors\n  }\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n    \/\/ your code\n  \n  var res = [Int]()\n  for i in start...nd {\n    if findPrimes(i).count == k {\n      res.append(i)\n    }\n  }\n  \n  return res\n}\n\nfunc puzzle(_ s: Int) -> Int {\n    \/\/ your code\n  guard s >= 2 else { return 0 }\n  var res = 0\n  let primes = countKprimes(1, 2, s)\n    for prime in primes {\n      let newNum = s - prime\n      if s - prime > 2 {\n        let threePrimes = countKprimes(3, 2, s - prime)\n        for num in threePrimes {\n          let finalNum = newNum - num\n          \/\/ if finalNum is 7-prime then we increment res\n          if finalNum >= 2 && countKprimes(7, 2, finalNum).count > 0 {\n              if countKprimes(7, 2, finalNum).contains(finalNum) {\n                  res += 1\n                  break\n              }\n          } else {\n              break\n          }\n        }\n      } else {\n        break\n      }\n    }\n\n  return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341487,"user_id":null,"body":"func countKprimes(_ k: Int, _ start: Int, _ end: Int) -> [Int] {\n    var array = [Int]()\n    for i in start...end{\n        let primeArray = findPrimeFactors(num: i)\n        if primeArray.count == k{\n            array.append(i)\n        }\n    }\n    return array\n}\n\nfunc findPrimeFactors(num:Int)->[Int]{\n    var tempNum = num\n    var primeArray = [Int]()\n    \n    while tempNum % 2 == 0{\n        primeArray.append(2)\n        tempNum \/= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(tempNum))) {\n        while tempNum % i == 0{\n            primeArray.append(i)\n            tempNum \/= i\n        }\n        i += 2\n    }\n    \n    if tempNum > 2{\n        primeArray.append(tempNum)\n    }\n    return primeArray\n}\n\nfunc puzzle(_ s: Int) -> Int {\n    let onePrimeArray = countKprimes(1, 2, s)\n    let threePrimeArray = countKprimes(3, 2, s)\n    let sevenPrimeArray = countKprimes(7, 2, s)\n    var numOfSolutions = 0\n    for a in onePrimeArray{\n        for b in threePrimeArray{\n            for c in sevenPrimeArray{\n                let sum = a + b + c\n                if (sum == s){\n                    numOfSolutions += 1\n                }\n            }\n        }\n    }\n    \n    return numOfSolutions\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341488,"user_id":null,"body":"func primeFactors(_ n: Int) -> [Int] {\n    var n = n\n    var factors = [Int]()\n\n    var divisor = 2\n    while divisor * divisor <= n {\n        while n % divisor == 0 {\n            factors.append(divisor)\n            n \/= divisor\n        }\n        divisor += divisor == 2 ? 1 : 2\n    }\n    if n > 1 {\n        factors.append(n)\n    }\n\n    return factors\n}\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n  var r = [Int]()\n  \n  for i in start...nd {\n    let p = primeFactors(i)\n    if p.count == k {\n      r.append(i)\n    }\n  }\n\n  return r\n}\n\nfunc puzzle(_ s: Int) -> Int {\n  var d: [[Int]] = [[], [], []]\n  var r = 0\n  \n  for i in 1...s {\n    let p = primeFactors(i)\n    if p.count == 1 {\n      d[0].append(i)\n    } else if p.count == 3 {\n      d[1].append(i)\n    } else if p.count == 7 {\n      d[2].append(i)\n    }\n  }\n  \n   if d[0].count > 0 && d[1].count > 0 && d[2].count > 0 {\n     for i in d[2] {\n       for j in d[1] {\n         if d[0].contains(s - i - j) {\n           r += 1\n         }\n       }\n     }\n   }\n  \n  return r\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341489,"user_id":null,"body":"func findPrimeMultiples(_ y: Int) -> Int {\n  var count = 0\n  var divisor = 2\n  var current = y\n  \n  while divisor <= current {\n    while current % divisor == 0 {\n      current \/= divisor\n      count += 1\n    }\n    divisor += 1\n  }\n  \n  \n  return count\n}\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n  var kPrimes = [Int]()\n    for i in start...nd {\n      if findPrimeMultiples(i) == k {\n        kPrimes += [i]\n      }\n      continue\n    }\n  \n  return kPrimes\n}\n\nfunc puzzle(_ s: Int) -> Int {\n  let one = countKprimes(1, 1, s)\n  let three = countKprimes(3, 1, s)\n  let seven = countKprimes(7, 1, s)\n  var count = 0\n  \n  for a in one {\n    for b in three {\n      for c in seven {\n        if a + b + c == s {\n          count += 1\n        }\n      }\n    }\n  }\n  \n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341490,"user_id":null,"body":"func countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n    \/\/ your code\n  var result: [Int] = []\n  for n in start...nd {\n    guard n >= 2 else { continue }\n    \n    var count = 0\n    var number = n\n    while number > 1 {\n      for i in 2...number {\n        if number % i == 0 {\n          number = number \/ i\n          count += 1\n          break\n        }\n      }\n    }\n    \n    if count == k {\n      result.append(n)\n    }\n  }\n  \n  return result\n}\n\nfunc puzzle(_ s: Int) -> Int {\n  \n  let prime_1s = countKprimes(1, 2, s)\n  let prime_3s = countKprimes(3, 2, s)\n  let prime_7s = countKprimes(7, 2, s)\n  \n  var count = 0\n  for prime_1 in prime_1s {\n    for prime_3 in prime_3s {\n      for prime_7 in prime_7s {\n        if prime_1 + prime_3 + prime_7 == s {\n          count += 1\n        }\n      }\n    }\n  }\n  \n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341491,"user_id":null,"body":"func findFactors(_ n: Int) -> Int {\n    var count = 0\n    var n = n\n    while n % 2 == 0 {\n        n = (n \/ 2)\n        count += 1\n    }\n    var i = 3\n    while i * i <= n {\n        while n % i == 0 {\n            n = n \/ i\n            count += 1\n        }\n        i += 2\n    }\n    if n > 2 {\n        count += 1\n    }\n    return count\n}\n\nfunc countKprimes(_ k: Int, _ start: Int, _ nd: Int) -> [Int] {\n  var output = [Int]()\n  for i in start...nd {\n    if findFactors(i) == k {\n        output.append(i)\n    }\n  }\n    return output\n}\n\nfunc puzzle(_ s: Int) -> Int {\n    var output = 0\n    let first = countKprimes(1, 2, s)\n    let third = countKprimes(3, 2, s)\n    let seventh = countKprimes(7, 2, s)\n    for i in first {\n      for j in third {\n        for k in seventh {\n          if i + j + k == s {\n            output += 1\n          }\n        }\n      }\n    }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"573182c405d14db0da00064e":[{"id":341492,"user_id":311,"body":"func consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    guard arr.count > 2 else {return 0}\n    let a = arr.map{(k == kPrimes($0) ? true : false)}\n    var counter = 0\n    for i in 1..<a.count {\n        if a[i] == true && a[i-1] == true  {\n            counter += 1\n        }\n    }\n    return counter\n}\n\nfunc kPrimes(_ n: Int) -> Int {\n    guard n > 1 else {return 0}\n    var n = n\n    var k = 0\n    var divide = 2\n    while n>1 {\n        if n % divide == 0 {\n            k += 1\n            n = n \/ divide\n        } else {\n            divide += (divide == 2) ? 1 : 2\n        }\n    }\n    return k\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341493,"user_id":null,"body":"func consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    \n    func prim(_ n: Int) -> Int {\n        var na = n, i = 2, cn = 0\n        while na > 1 { while na % i == 0 { cn += 1; na \/= i }; i += 1 }\n        return cn\n    }\n    \n    var i = 0, cn = 0\n    while i < arr.count - 1 {\n        if (prim(arr[i]) == k) && (prim(arr[i + 1]) == k)\n        {cn += 1}\n        i += 1;\n    }\n    \n    return cn\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341494,"user_id":492,"body":"func primeFactors(_ n: Int) -> Int {\n    var nb = n\n    var i = 2\n    var cnt = 0\n    while nb > 1 {\n        while nb % i == 0 {\n            cnt += 1\n            nb \/= i\n        }\n        i += 1\n    }\n    return cnt\n}\n\nfunc consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    var i = 0\n    var cnt = 0\n    while i < arr.count - 1 {\n        if (primeFactors(arr[i]) == k) && (primeFactors(arr[i + 1]) == k)\n            {cnt += 1}\n        i += 1;\n    }\n    return cnt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341495,"user_id":492,"body":"func primeFactors(_ n: Int) -> Int {\n    var nb = n\n    var i = 2\n    var cnt = 0\n    while nb > 1 {\n        while nb % i == 0 {\n            cnt += 1\n            nb \/= i\n        }\n        i += 1\n    }\n    return cnt\n}\n\nfunc consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    var i = 0\n    var cnt = 0\n    while i < arr.count - 1 {\n        if (primeFactors(arr[i]) == k) && (primeFactors(arr[i + 1]) == k)\n            {cnt += 1}\n        i += 1;\n    }\n    return cnt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341496,"user_id":53,"body":"func primeFactors(_ n: Int) -> Int {\n    var nb = n\n    var i = 2\n    var cnt = 0\n    while nb > 1 {\n        while nb % i == 0 {\n            cnt += 1\n            nb \/= i\n        }\n        i += 1\n    }\n    return cnt\n}\n\nfunc consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    var cnt = 0\n    var p = 0\n    for n in arr {\n        var q = primeFactors(n)\n        if p == k && q == k {\n            cnt = cnt + 1\n        }\n        p = q\n    }\n    return cnt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341497,"user_id":null,"body":"func consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    var counter = 0\n  if arr.count < 2{\n        return 0\n    }\n    for i in 0...(arr.count-2){\n        let num = findPrimeFactors(num: arr[i]).count\n        if num == findPrimeFactors(num: arr[i + 1]).count  && num == k{\n            counter += 1\n        }\n    }\n    return counter\n}\n\nfunc findPrimeFactors(num:Int)->[Int]{\n    var tempNum = num\n    var primeArray = [Int]()\n    \n    while tempNum % 2 == 0{\n        primeArray.append(2)\n        tempNum \/= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(tempNum))) {\n        while tempNum % i == 0{\n            primeArray.append(i)\n            tempNum \/= i\n        }\n        i += 2\n    }\n    \n    if tempNum > 2{\n        primeArray.append(tempNum)\n    }\n    return primeArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341498,"user_id":null,"body":"func consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n  var output = 0\n  for i in 0..<(arr.count - 1) {\n    if factors(arr[i]) == k && factors(arr[i+1]) == k {\n      output += 1\n    }\n  }\n  return output\n}\n\nfunc factors(_ n: Int) -> Int {\n  var count = 0\n  var n = n\n  while n % 2 == 0 {\n    n = n \/ 2\n    count += 1\n  }\n  var i = 3\n  while i * i <= n {\n    while n % i == 0 {\n      n = n \/ i\n      count += 1\n    }\n    i += 2\n  }\n  if n > 2 {\n    count += 1\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341499,"user_id":null,"body":"func isKPrime(_ k: Int, _ number: Int) -> Bool {\n    var factors = 0\n    var restNumber = number;\n    \n    while restNumber % 2 == 0 {\n        restNumber \/= 2\n        factors += 1\n    }\n    \n    if number < 3 {\n        return factors == k\n    }\n        \n    for i in 3...max(Int(sqrt(Double(number))), 3) {\n        while restNumber % i == 0 {\n            restNumber \/= i\n            factors += 1\n        }\n    }\n    \n    if restNumber > 2 {\n        factors += 1\n    }\n    \n    return factors == k\n}\n\nfunc consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    var lastNumberWasKPrime = false\n    var sequencesFound = 0\n    \n    for number in arr {\n        if isKPrime(k, number) {\n            if lastNumberWasKPrime {\n                sequencesFound += 1\n            }\n            lastNumberWasKPrime = true\n        } else {\n            lastNumberWasKPrime = false\n        }\n    }\n    \n    return sequencesFound\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341500,"user_id":null,"body":"func checkIfNumberIsSimple(_ number: Int) -> Bool {\n  for i in 1...number {\n    if number % i == 0 && i != 1 && i != number {\n      return false\n    }\n  }\n  return true\n}\n\nfunc checkIfHasCorrectSimpleDividersCount(_ number: Int, maxCount: Int) -> Bool {\n  var simpleDividers: [Int] = []\n  var leftNumber: Int = number\n  var i: Int = 1\n  \n  while leftNumber > 1 && i < number && simpleDividers.count <= maxCount {\n    i += 1\n    if leftNumber % i == 0 && i != number {\n      while leftNumber % i == 0 {\n        simpleDividers.append(i)\n        leftNumber = leftNumber \/ i\n      }\n    }\n  }\n  \n  return simpleDividers.count == maxCount || simpleDividers.isEmpty\n}\n\nfunc consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n  var output: Int = 0\n  var previousNumberIsCorrect: Bool = false\n  for number in arr {\n    if checkIfHasCorrectSimpleDividersCount(number, maxCount: k) {\n      if previousNumberIsCorrect {\n        output += 1\n      }\n      previousNumberIsCorrect = true\n    } else {\n      previousNumberIsCorrect = false\n    }\n  }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341501,"user_id":null,"body":"\nfunc kPrime(_ num: Int) -> Int {\n    var num = num\n    var k = 0\n    \n    while num != 1 {\n        for i in 2...num {\n            if num % i == 0 {\n                num = num\/i\n                k += 1\n                break\n            }\n        }\n    }\n    \n    return k\n}\n\n\nfunc consecKprimes(_ k: Int, _ arr: [Int]) -> Int {\n    var count = 0\n    for item in 0..<arr.count-1 {\n        if kPrime(arr[item]) == k && kPrime(arr[item+1]) == k {\n            count += 1\n        }\n    }\n    return count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"573992c724fc289553000e95":[{"id":341502,"user_id":null,"body":"func smallest(_ n: Int) -> (Int, Int, Int) {\n    var min = n\n    var i = 0\n    var j = 0\n    for removeIndex in n.description.characters.indices {\n        var strN = n.description\n        let digit = strN.remove(at: removeIndex)\n        for insertIndex in n.description.characters.indices {\n            var newStrN = strN\n            newStrN.insert(digit, at: insertIndex)\n            if Int(newStrN)! < min {\n                min = Int(newStrN)!\n                i = newStrN.distance(from: newStrN.startIndex, to: removeIndex)\n                j = newStrN.distance(from: newStrN.startIndex, to: insertIndex)\n            }\n        }\n    }\n    return (min, i, j)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341503,"user_id":null,"body":"func smallest(_ n: Int) -> (Int, Int, Int) {\n  \/\/ your code\n  var result = (n, 0, 0)\n  var arr = String(n).characters.flatMap{Int(String($0))}\n  \n  for i in 0..<arr.count\n  {\n      for j in 0..<arr.count\n      {\n          var arrT = arr\n          arrT.insert(arrT.remove(at: i), at: j)\n          let arrSm = Int(arrT.map{String($0)}.joined())!\n          if (arrSm < result.0)\n          {\n            result = (arrSm, i, j)\n          }\n      }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341504,"user_id":492,"body":"func move(_ n: String, _ i: Int, _ j: Int) -> Int {\n    let s = Array(n)\n    let u = String(s.prefix(upTo: i)) + String(s.suffix(from: i + 1))\n    let t = Array(u)\n    let ss = String(t.prefix(upTo: j)) + String(s[i]) + String(t.suffix(from: j))\n    return Int(ss)!\n}\nfunc smallest(_ n: Int) -> (Int, Int, Int) {\n    var min = n, got = 0, put = 0, s = String(n), l = s.count\n    for i in 0..<l {\n        for j in 0..<l {\n            let m = move(s, i, j)\n            if m < min {\n                min = m\n                got = i\n                put = j\n            }\n        }\n    }\n    return (min, got, put)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341505,"user_id":null,"body":"extension Int {\n    var digits: [Int] { String(self).compactMap(\\.wholeNumberValue) }\n}\n\nextension Array where Element == Int {\n    var joinedValue: Int? { Int(compactMap { String($0) }.joined()) }\n    \n    func copyMoveValue(from index2: Int, to index1: Int) -> [Int] {\n        var copy = self\n        copy.insert(copy.remove(at: index2), at: index1)\n        return copy\n    }\n}\n\n\nfunc smallest(_ n: Int) -> (Int, Int, Int) {\n    var resultSmallest = n\n    var resultIndex: Int = n.digits.count\n    var resultPosition: Int = n.digits.count\n    \n    for (position, _) in n.digits.enumerated() {\n        for (index, _) in n.digits.enumerated() {\n            if let swappedCopy = n.digits.copyMoveValue(from: index, to: position).joinedValue {\n                switch (swappedCopy, resultSmallest) {\n                case let (a,b) where a == b:\n                    if index < resultIndex {\n                        resultIndex = index\n                        resultPosition = position\n                    }\n                case let (a,b) where a < b:\n                    resultSmallest = swappedCopy\n                    resultIndex = index\n                    resultPosition = position\n                default: break\n                }\n            }\n        }\n    }\n    return (resultSmallest,resultIndex,resultPosition)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341506,"user_id":null,"body":"func smallest(_ n: Int) -> (Int, Int, Int) {\n  let digits = \"\\(n)\".map { String($0) }\n  var res = (n, 0, 0)\n  \n  for i in 0..<digits.count {\n    var dropped = digits\n    dropped.remove(at: i)\n    \n    for j in 0...dropped.count {\n      var inserted = dropped\n      inserted.insert(digits[i], at: j)\n      \n      let number = Int(inserted.joined())!\n      if (number < res.0) || (number == res.0 && i < res.1) {\n        res = (number, i, j)\n      }\n    }\n  }\n  \n  return res\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341507,"user_id":null,"body":"import Foundation\nfunc evaluate(array: [Int]) -> Int {\n  return Int(array.map { \"\\($0)\" }.joined(separator: \"\")) ?? 0\n}\nfunc regrouped(array: [Int], index: Int, moveTo: Int) -> Int {\n  var a = array\n  let x = a.remove(at: index)\n  a.insert(x, at: moveTo)\n  return evaluate(array: a)\n}\n\nfunc smallest(_ n: Int) -> (Int, Int, Int) {\n  let number = Array(\"\\(n)\")\n  let digits = number\n    .map { Int(String($0)) ?? 0 }\n  var minimal = n\n  var originalIndex = 0\n  var newIndex = 0\n  for i in 0..<digits.count {\n    for j in 0..<digits.count {\n      let x = regrouped(array: digits, index: i, moveTo: j)\n      if x < minimal {\n        originalIndex = i\n        newIndex = j\n        minimal = x\n        }\n    }\n  }\n  return (minimal, originalIndex, newIndex)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341508,"user_id":null,"body":"func smallest(_ n: Int) -> (Int, Int, Int) {\n    let digits = \"\\(n)\".compactMap{Int(String($0))}\n    var output: (Int, Int, Int) = (n, digits.count, digits.count)\n    \n    \n    for oldIndex in 0..<digits.count {\n        for newIndex in 0..<digits.count {\n            var tempDigits = digits\n            tempDigits.insert(tempDigits.remove(at: oldIndex), at: newIndex)\n            let number = tempDigits.reduce(0, { $0 * 10 + $1 })\n            \n            if number < output.0 || (number == output.0 && oldIndex < output.1) {\n                output = (number, oldIndex, newIndex)\n            }\n        }\n    }\n    \n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341509,"user_id":null,"body":"func smallest(_ n: Int) -> (Int, Int, Int) {\n    var str = Array(String(n))\n    var results = [(Int, Int, Int)]()\n    for i in 0..<str.count {\n      var rmvd = str.remove(at: i)\n      for j in 0...str.count {\n        str.insert(rmvd, at: j)\n        results.append((Int(String(str))!, i, j))\n        rmvd = str.remove(at: j)\n      }\n      str.insert(rmvd, at: i)\n    }\n    return results.sorted { $0.0 < $1.0 }.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341510,"user_id":null,"body":"func smallest(_ n: Int) -> (Int, Int, Int) {\n    print(\"n: \\(n)\")\n    let digits = n.digits\n    var min = n\n    var minTuple = (n, 0, 0)\n    \n    for i in 0 ..< digits.count {\n        var nums = digits\n        let num = nums[i]\n        nums.remove(at: i)\n        for j in 0 ..< digits.count {\n           nums.insert(num, at: j)\n            let stringNewN = nums.map(String.init).joined()\n            if let newN = Int(stringNewN) {\n                if newN < min {\n                    min = newN\n                    minTuple = (newN, i, j)\n                }\n            }\n            nums.remove(at: j)\n        }\n    }\n    \n    return minTuple\n}\n\nextension Int {\n    var digits: [Int] {\n        var digitsArr: [Int] = []\n        var num = self\n        \n        digitsArr.append(num % 10)\n        \n        while num >= 10  {\n            num = num \/ 10\n            digitsArr.append(num % 10)\n        }\n        \n        return digitsArr.reversed()\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341511,"user_id":null,"body":"func arrToNum(arr: [Int]) -> Int {\n  var result = 0\n  for i in 0..<arr.count {\n    result += arr[i]\n    result *= 10\n  }\n  return result \/ 10\n}\n\nfunc numToArr(i: Int) -> [Int] {\n  String(i).compactMap({$0.wholeNumberValue})\n}\n\nfunc changeDigitPosition(first: Int, second: Int, arr: [Int]) -> [Int] {\n  var temp = arr\n  let tempFirst = arr[first]\n  temp[second] = tempFirst\n  for i in 0..<arr.count {\n    if i != second {\n      if first < second {\n        if i >= first && i < second {\n          temp[i] = arr[i + 1]\n        } else {\n          temp[i] = arr[i]\n        }\n      } else if first > second {\n        if i <= first && i > second {\n          temp[i] = arr[i - 1]\n        } else {\n          temp[i] = arr[i]\n        }\n      } else {\n        temp[i] = arr[i]\n      }\n    }\n  }\n  return temp\n}\n\nfunc smallest(_ input: Int) -> (Int, Int, Int) {\n  var arr = numToArr(i: input)\n  var t = 0\n  var result = input\n  var resI = 0\n  var resJ = 0\n  for i in 0..<arr.count {\n    for j in 0..<arr.count {\n      arr = numToArr(i: input)\n      arr = changeDigitPosition(first: i, second: j, arr: arr)\n      t = arrToNum(arr: arr)\n      if result > t {\n        result = t\n        resI = i\n        resJ = j\n      }\n    }\n  }\n  return (result, resI, resJ)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57591ef494aba64d14000526":[{"id":341512,"user_id":null,"body":"func johnAndAnn(_ n: Int) -> ([Int],[Int]) {\n    var john = Array.init(repeating: 0, count: n)\n    var ann = Array.init(repeating: 1, count: n)\n    for i in 1..<n {\n        john[i] = i-ann[john[i-1]]\n        ann[i] = i-john[ann[i-1]]\n    }\n    return (john,ann)\n}\n\nfunc ann(_ n : Int) -> [Int] {\n    return johnAndAnn(n).1\n}\n\nfunc john(_ n : Int) -> [Int] {\n    return johnAndAnn(n).0\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    return john(n).reduce(0, +)\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    return ann(n).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341513,"user_id":null,"body":"fileprivate func together(_ n: Int) -> (ann: [Int], john: [Int]) {\n  guard n >= 0 else { return ([], []) }\n  guard n > 1 else {\n    return (Array(repeating: 1, count: n + 1), Array(repeating: 0, count: n + 1))\n  }\n  \n  var result = together(n - 1)\n  let resultAnn = n - result.john[result.ann[n - 1]]\n  result.ann.append(resultAnn)\n  let resultJohn = n - result.ann[result.john[n - 1]]\n  result.john.append(resultJohn)\n  return result\n}\n\nfunc ann(_ count: Int) -> [Int] {\n  return together(count - 1).ann\n}\n\nfunc john(_ count: Int) -> [Int] {\n  return together(count - 1).john\n}\n\nfunc sumAnn(_ count: Int) -> Int {\n  return ann(count).reduce(0, +)\n}\n\nfunc sumJohn(_ count: Int) -> Int {\n  return john(count).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341514,"user_id":null,"body":"func together(_ n : Int) -> (ann : [Int],john : [Int]) {\n    var ann = Array.init(repeating: 0, count: n)\n    var john = Array.init(repeating: 1, count: n)\n    \n    for i in 1..<n {\n        john[i] = i-ann[john[i-1]]\n        ann[i] = i-john[ann[i-1]]\n    }\n    return (john,ann)\n    \n}\n\nfunc ann(_ n : Int) -> [Int] {\n    together(n).ann\n}\n\nfunc john(_ n : Int) -> [Int] {\n    together(n).john\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    john(n).reduce(0, +)\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    ann(n).reduce(0, +)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341515,"user_id":null,"body":"func ann(_ n : Int) -> [Int] {\n    var arrAnn = [1, 1]\n    var arrJohn = [0, 0]\n    guard n > 1 else {return arrAnn.dropLast()}\n    for i in 2...n - 1 {\n        arrAnn.append(i - arrJohn[arrAnn[i-1]])\n        arrJohn.append(i - arrAnn[arrJohn[i-1]])\n    }\n    return arrAnn\n}\n\nfunc john(_ n : Int) -> [Int] {\n    var arrAnn = [1, 1]\n    var arrJohn = [0, 0]\n    guard n > 1 else {return arrJohn.dropLast()}\n    for i in 2...n - 1 {\n        arrAnn.append(i - arrJohn[arrAnn[i-1]])\n        arrJohn.append(i - arrAnn[arrJohn[i-1]])\n    }\n    return arrJohn\n}\nfunc sumJohn(_ n : Int) -> Int {\n    return john(n).reduce(0, +)\n}\nfunc sumAnn(_ n : Int) -> Int {\n    return ann(n).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341516,"user_id":null,"body":"func ann(_ n : Int) -> [Int] {\n    var annArr: [Int] = [] ; var johnArr: [Int] = []\n    annArr.append(1) ; if n == 1 { return annArr } ; johnArr.append(0)\n    annArr.append(1) ; if n == 2 { return annArr } ; johnArr.append(0)\n    for i in 3...n {\n        annArr.append((i - 1) - johnArr[annArr[i - 2]])\n        johnArr.append((i - 1) - annArr[johnArr[i - 2]])\n    }\n    return annArr\n}\n\nfunc john(_ n : Int) -> [Int] {\n    var annArr: [Int] = [] ; var johnArr: [Int] = []\n    johnArr.append(0) ; if n == 1 { return johnArr } ; annArr.append(1)\n    johnArr.append(0) ; if n == 2 { return johnArr } ; annArr.append(1)\n    for i in 3...n {\n        annArr.append((i - 1) - johnArr[annArr[i - 2]])\n        johnArr.append((i - 1) - annArr[johnArr[i - 2]])\n    }\n    return johnArr\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    var result = 0\n    let mas = john(n)\n    for i in mas { result += i }\n    return result\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    var result = 0\n    let mas = ann(n)\n    for i in mas { result += i }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341517,"user_id":null,"body":"func ann(_ n : Int) -> [Int] {\n    getKatasOnDay(n).1\n}\n\nfunc john(_ n : Int) -> [Int] {\n    getKatasOnDay(n).0\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    getKatasOnDay(n).0.reduce(0, +)\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    getKatasOnDay(n).1.reduce(0, +)\n}\n\nfunc getKatasOnDay(_ n: Int) -> ([Int], [Int]) {\n    var john = [0]\n    var ann = [1]\n    \n    for index in 1..<n {\n        john.append(index - ann[john[index - 1]])\n        ann.append(index - john[ann[index - 1]])\n    }\n    \n    return (john, ann)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341518,"user_id":null,"body":"var aSeq = [1]\nvar jSeq = [0]\n\nfunc fillSequences(upTo n: Int) {\n    for i in 1...n {\n        if jSeq.count > i {\n            continue\n        }\n        jSeq.append(i - aSeq[jSeq[i - 1]])\n        aSeq.append(i - jSeq[aSeq[i - 1]])\n    }\n}\n\nfunc ann(_ n : Int) -> [Int] {\n    fillSequences(upTo: n)\n    return Array(aSeq.prefix(n))\n}\n\nfunc john(_ n : Int) -> [Int] {\n    fillSequences(upTo: n)\n    return Array(jSeq.prefix(n))\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    return john(n).reduce(0, +)\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    return ann(n).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341519,"user_id":null,"body":"func foo(_ n: Int,_ name: String) -> [Int] {\n    var johnsList = [0]\n    var annsList = [1]\n    for day in 1..<n {\n        johnsList.append(day - annsList[johnsList[day - 1]])\n        annsList.append(day - johnsList[annsList[day - 1]])\n    }\n    if name == \"John\" {return johnsList}\n    else {return annsList}\n}\n\nfunc ann(_ n : Int) -> [Int] {\n    foo(n, \"Ann\")\n}\n\nfunc john(_ n : Int) -> [Int] {\n   foo(n, \"John\")\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    foo(n, \"John\").reduce(0, +)\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    foo(n, \"Ann\").reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341520,"user_id":null,"body":"func ann(_ n : Int) -> [Int] {\n    return calculate(n, isAnn: true)\n}\n\nfunc john(_ n : Int) -> [Int] {\n    return calculate(n, isAnn: false)\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    return calculate(n, isAnn: false).reduce(0, +)\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    return calculate(n, isAnn: true).reduce(0, +)\n}\n\nfunc calculate(_ n: Int, isAnn: Bool) -> [Int] {\n    var jonh: [Int] = [0, 0]\n    var ann: [Int] = [1, 1]\n    \n    if n < 2 { return isAnn ? [1] : [0] }\n    \n    for index in 2..<n {\n        ann.append(index - jonh[ann[index - 1]])\n        jonh.append(index - ann[jonh[index - 1]])\n    }\n    \n    return isAnn ? ann : jonh\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341521,"user_id":null,"body":"struct JohnAnn {\n  var j: Int\n  var a: Int\n}\n\nclass WarOfJA {\n  var daysOfWar = [JohnAnn(j: 0, a: 1)]\n  \n  func fight(days n: Int) {\n    daysOfWar = [daysOfWar.first!]\n    for day in 1 ..< n {\n        let tA = daysOfWar[day - 1].a\n        let tJ = daysOfWar[day - 1].j\n\n        var dayRecord = JohnAnn(j: -1, a: -1)\n\n        if tA < daysOfWar.count {\n            dayRecord.a = day - daysOfWar[tA].j\n            if tJ == daysOfWar.count {\n                dayRecord.j = dayRecord.a\n            } else if tJ > daysOfWar.count {\n                print(\"No J\")\n            }\n        }\n\n        if tJ < daysOfWar.count {\n            dayRecord.j = day - daysOfWar[tJ].a\n            if tA == daysOfWar.count {\n                dayRecord.a = tA\n            } else if tJ > daysOfWar.count {\n                print(\"No A\")\n            }\n        }\n\n\n        daysOfWar.append(dayRecord)\n    }\n  }\n}\n\nfunc ann(_ n : Int) -> [Int] {\n    \/\/ your code\n  let war = WarOfJA()\n  war.fight(days: n)\n  return war.daysOfWar.map({ $0.a })\n}\n\nfunc john(_ n : Int) -> [Int] {\n  let war = WarOfJA()\n  war.fight(days: n)\n  return war.daysOfWar.map({ $0.j })\n}\n\nfunc sumJohn(_ n : Int) -> Int {\n    john(n).reduce(0, { $0 + $1 })\n}\n\nfunc sumAnn(_ n : Int) -> Int {\n    ann(n).reduce(0, { $0 + $1 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5765870e190b1472ec0022a2":[{"id":341522,"user_id":null,"body":"func path_finder(_ maze: String) -> Bool {\n  let size = maze.components(separatedBy: \"\n\").count\n  var maze = Array(maze)\n  var stack = [(0,0)]\n  \n  while stack.count > 0 {\n    let current = stack.removeLast()\n    let position = (size+1)*current.1+current.0\n    \n    if maze[position] == \".\" {\n      maze[position] = \"X\" \/\/ set as discovered\n\n      if current.0 == size-1 && current.1 == size-1 { return true } \/\/ found\n      if current.1 > 0        { stack.append((current.0, current.1 - 1)) } \/\/ north\n      if current.1 < (size-1) { stack.append((current.0, current.1 + 1)) } \/\/ south\n      if current.0 > 0        { stack.append((current.0 - 1, current.1)) } \/\/ west\n      if current.0 < (size-1) { stack.append((current.0 + 1, current.1)) } \/\/ east\n    }\n  }\n\n  return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341523,"user_id":null,"body":"func path_finder(_ maze: String) -> Bool {\n  var array = maze.components(separatedBy: \"\n\").map({ Array($0) })\n  checkPath(&array, (0, 0))\n  return array[array.count - 1][array.count - 1] == \"O\"\n}\n\nfunc checkPath(_ maze: inout [[Character]], _ point: (Int, Int)) {\n  guard isDot(maze, point) else { return }\n  maze[point.0][point.1] = \"O\"\n  for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)] {\n    checkPath(&maze, (point.0 + direction.0, point.1 + direction.1))\n  }\n}\n\nfunc isDot(_ maze: [[Character]],_ point: (Int, Int)) -> Bool {\n switch point {\n   case (0..<maze.count, 0..<maze.count): break\n   default: return false\n }\n return maze[point.0][point.1] == \".\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341524,"user_id":null,"body":"func path_finder(_ maze: String) -> Bool {\n    var matrix = createMatrix(maze)\n    matrix[0][0] = \"V\"\n    var positions: [(x: Int, y: Int)] = [(0, 0)]\n    \n    outerloop: for _ in 0...matrix.count*matrix.count {\n        var tempPos: [(x: Int, y: Int)] = []\n        \n        for pos in positions {\n            if pos.x == matrix.count-1 && pos.y == matrix.count-1 {\n                return true\n            }\n            \n            if pos.x-1 >= 0 && matrix[pos.x-1][pos.y] == \".\" {\n                tempPos.append((pos.x-1, pos.y))\n                matrix[pos.x-1][pos.y] = \"V\"\n            }\n            if pos.y-1 >= 0 && matrix[pos.x][pos.y-1] == \".\" {\n                tempPos.append((pos.x, pos.y-1))\n                matrix[pos.x][pos.y-1] = \"V\"\n            }\n            if pos.x+1 < matrix.count && matrix[pos.x+1][pos.y] == \".\" {\n                tempPos.append((pos.x+1, pos.y))\n                matrix[pos.x+1][pos.y] = \"V\"\n            }\n            if pos.y+1 < matrix.count && matrix[pos.x][pos.y+1] == \".\" {\n                tempPos.append((pos.x, pos.y+1))\n                matrix[pos.x][pos.y+1] = \"V\"\n            }\n        }\n        \n        if tempPos.isEmpty {\n            return false\n        } else {\n            positions = tempPos\n        }\n    }\n    \n    return false\n}\n\nfunc createMatrix(_ maze: String) -> [[Character]] {\n    var output: [[Character]] = []\n    let temp = maze.split(separator: \"\n\")\n    \n    for x in temp {\n        output.append([Character](x))\n    }\n    \n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341525,"user_id":null,"body":"extension String.SubSequence {\n  subscript(index: Int) -> Character {\n    get {\n      let index = self.index(startIndex, offsetBy: index)\n      return self[index]\n    }\n    set {\n      let index = self.index(startIndex, offsetBy: index)\n      replaceSubrange(index...index, with: \"\\(newValue)\")\n    }\n  }\n}\n\nstruct Index: Equatable, CustomStringConvertible {\n  let row: Int\n  let column: Int\n\n  init(_ row: Int, _ column: Int) {\n    self.row = row\n    self.column = column\n  }\n\n  var description: String {\n    \"(\\(row), \\(column))\"\n  }\n\n  func neighbors(_ length: Int) -> [Index] {\n    var results = [Index]()\n    if row < length - 1 {\n      results.append(Index(row + 1, column))\n    }\n    if row > 0 {\n      results.append(Index(row - 1, column))\n    }\n    if column < length - 1 {\n      results.append(Index(row, column + 1))\n    }\n    if column > 0 {\n      results.append(Index(row, column - 1))\n    }\n    return results\n  }\n}\n\nfunc path_finder(_ maze: String) -> Bool {\n  var maze = maze.split(separator: \"\n\").map { $0.map { String($0) } }\n  let lenght = maze.count\n\n  maze[0][0] = \"0\"\n  var changed = false\n  repeat {\n    changed = false\n    for i in 0..<lenght {\n      for j in 0..<lenght {\n        if maze[i][j] != \"W\" && Int(maze[i][j]) != nil {\n          let digit = Int(maze[i][j])!\n          for neighbor in Index(i, j).neighbors(lenght) {\n            let row = neighbor.row\n            let column = neighbor.column\n            if maze[row][column] != \"W\" && Int(maze[row][column]) == nil {\n              maze[row][column] = \"\\(digit + 1)\"\n              changed = true\n\n              if row == lenght - 1 && column == lenght - 1 {\n                print(maze.map { $0.joined(separator: \"\\t\") }.joined(separator: \"\n\"))\n                print(\"\n\")\n                return true\n              }\n            }\n          }\n        }\n      }\n    }\n  } while changed\n\n  print(maze.map { $0.joined(separator: \"\\t\") }.joined(separator: \"\n\"))\n  print(\"\n\")\n\n  return Int(maze[lenght - 1][lenght - 1]) != nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341526,"user_id":null,"body":"enum PositionType {\n  case free, visited, wall\n}\nclass Position: Equatable {\n  static func ==(lhs: Position, rhs: Position) -> Bool {\n    return lhs.row == rhs.row && lhs.column == rhs.column\n  }\n  let row: Int\n  let column: Int\n  var pType: PositionType\n  \n  init(row: Int, column: Int, pType: PositionType) {\n    self.row = row\n    self.column = column\n    self.pType = pType\n  }\n  \n  var description: String {\n    return \"\\(row);\\(column)\"\n  }\n}\n\nclass Maze {\n  var maze: [[Position]]\n  private var size: Int\n  init(maze: [[Position]]) {\n    self.maze = maze\n    self.size = maze.count\n    recursiveFind(path: [self.maze[0][0]])\n  }\n\n  var isSolvable: Bool {\n    return self.maze[size - 1][size - 1].pType == .visited\n  }\n    \n  func recursiveFind(path: [Position]) {\n    var path = path\n    guard let position = path.last else {\n      return\n    }\n    guard position.row < maze.count , position.column < maze.count else {\n      return\n    }\n\n    let accessables = accessableNeighbors(position: position)\n    guard !accessables.isEmpty else {\n      return\n    }\n\n    for accessable in accessables {\n      path.append(accessable)\n      if accessable == Position(row: maze.count - 1, column: maze.count - 1, pType: .visited) {\n        return\n      }\n      recursiveFind(path: path)\n    }\n  }\n\n  func accessableNeighbors(position: Position) -> [Position] {\n    guard position.row < maze.count, position.column < maze.count else {\n      return []\n    }\n\n    var possibleNeighbors = [Position]()\n    if position.row > 0 {\n      possibleNeighbors.append(maze[position.row - 1][position.column])\n    }\n    if position.row < maze.count - 1 {\n      possibleNeighbors.append(maze[position.row + 1][position.column])\n    }\n\n    if position.column > 0 {\n      possibleNeighbors.append(maze[position.row][position.column - 1])\n    }\n    if position.column < maze.count - 1 {\n      possibleNeighbors.append(maze[position.row][position.column + 1])\n    }\n\n\n    return possibleNeighbors.filter(\n      { \n        if maze[$0.row][$0.column].pType == .free {\n          maze[$0.row][$0.column].pType = .visited\n          return true\n        }\n        return false\n      })\n  }\n}\n\nfunc path_finder(_ maze: String) -> Bool {\n  let mze = transformMaze(maze)\n  mze[0][0].pType = .visited\n  let m = Maze(maze: mze)\n  \n  return m.isSolvable\n}\n\n\n\nfunc transformMaze(_ maze: String) -> [[Position]] {\n  let rows = maze.components(separatedBy: \"\n\")\n  return rows.enumerated().map( { r in\n    r.element.enumerated().map({ c in return Position(row: r.offset, column: c.offset, pType: String(c.element) == \".\" ? .free : .wall) })\n  }\n  )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341527,"user_id":null,"body":"class Maze {\n    \/\/ Constants \n    static let EMPTY: String = \".\"\n    static let WALL: String = \"W\"\n\n    \/\/ private members \n    private let  _maze: String\n\n    \/\/ string member variables\n    let locations: [[String]]\n    let width: Int\n  \n    \/\/ constructor\n    init(_ maze: String) {\n        \/\/ HARD ASSUMPTION N by N maze\n        self._maze = maze\n        self.locations = maze.components(separatedBy: \"\n\").map { $0.map { String($0) } }\n        self.width = locations.count\n    }\n  \n    \/\/ member functions\n    func toString() -> String {\n        return _maze\n    }\n\n    \/\/ TODO move this into Traverser\n    func getPossibleMoves(_ x: Int, _ y: Int) -> [(Int, Int)] {\n        \/\/ HARD ASSUMPTION x and y are always in bounrds of the maze\n        var moves: [(Int, Int)] = []\n        if x > 0 && locations[y][x - 1] != Maze.WALL {\n            moves.append((x - 1, y))\n        }\n        if x < locations.count - 1 && locations[y][x + 1] != Maze.WALL {\n            moves.append((x + 1, y))\n        }\n        if y > 0 && locations[y - 1][x] != Maze.WALL {\n            moves.append((x, y - 1))\n        }\n        if y < locations.count - 1 && locations[y + 1][x] != Maze.WALL {\n            moves.append((x, y + 1))\n        }\n        return moves\n    }\n}\n\nstruct Point{\n    var x: Int\n    var y: Int\n}\n\nclass DFSTraverser {\n    static let VISITED: String = \"V\"\n    let maze: Maze\n    var mLocations: [[String]]\n    let start: Point\n    let goal: Point\n\n    \/\/ set of positions order by distance to goal\n    var distancedPositions: [(Int, Point)] = []\n\n    init(_ maze: Maze, _ start: Point, _ goal: Point) {\n        self.maze = maze\n        self.mLocations = maze.locations\n        self.start = start\n        self.goal = goal\n        add(start)\n    }\n\n    func getPossibleMoves(_ point: Point) -> [Point] {\n        return maze\n            .getPossibleMoves(point.x, point.y)\n            .filter { mLocations[$0.1][$0.0] != DFSTraverser.VISITED }\n            .map { Point(x: $0.0, y: $0.1) }\n    }\n\n    func add(_ point: Point) {\n        let dist = abs(point.x - goal.x) + abs(point.y - goal.y)\n        \n        for i in 0..<distancedPositions.count {\n            if distancedPositions[i].0 > dist {\n                distancedPositions.insert((dist, point), at: i)\n                return\n            } else if distancedPositions[i].1.x == point.x && distancedPositions[i].1.y == point.y {\n                \/\/ already in the set\n                return\n            }\n        }\n        distancedPositions.append((dist, point))\n    }\n\n    func pop() -> Point? {\n        if distancedPositions.count == 0 {\n            return nil\n        }\n        let point = distancedPositions.removeFirst().1\n        mLocations[point.y][point.x] = DFSTraverser.VISITED\n        return point\n    }\n\n    func tryTowardsGoal() -> Bool {\n        while let point = pop() {\n\n            if point.x == goal.x && point.y == goal.y {\n                return true\n            }\n\n            \/\/ Could possibly persort these to improve insert performance\n            for loc in getPossibleMoves(point) {\n                add(loc)\n            }\n        }\n        return false\n    }\n}\n\nfunc path_finder(_ maze: String) -> Bool {\n    let m = Maze(maze)\n    let travis = DFSTraverser(m, Point(x: 0, y: 0), Point(x: m.width - 1, y: m.width - 1))\n    return travis.tryTowardsGoal()\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341528,"user_id":null,"body":"func path_finder(_ maze: String) -> Bool {\n    var mazeSize = 0\n    var i = 0\n    var j = 0\n    var dict: [[Int]:String] = [:]\n    for ch in maze {\n        if ch == \".\" || ch == \"W\" {\n            dict[[i, j]] = \"\\(ch)\"\n            i += 1\n        } else  { \/\/ ch == \"\n\"\n            mazeSize = i - 1\n            i = 0\n            j += 1\n        }\n    }\n    \n    \n    var count = 0\n    var startPoint = [0, 0]\n    var moveDirection = \"right\"\n  \n    while count < mazeSize*mazeSize*2 {\n        if startPoint == [mazeSize, mazeSize] {\n            return true\n        }\n        \n        if moveDirection == \"right\" {\n            if dict[[startPoint[0] + 1, startPoint[1]]] == \".\" {\n                    startPoint = [startPoint[0] + 1, startPoint[1]]\n                if dict[[startPoint[0], startPoint[1] - 1]] == \".\" {\n                    moveDirection = \"up\"\n                }\n            } else {\n                    moveDirection = \"down\"\n            }\n        } else if moveDirection == \"down\" {\n            if dict[[startPoint[0], startPoint[1] + 1]] == \".\" {\n                    startPoint = [startPoint[0], startPoint[1] + 1]\n                if dict[[startPoint[0] + 1, startPoint[1]]] == \".\" {\n                    moveDirection = \"right\"\n                }\n            } else {\n                    moveDirection = \"left\"\n            }\n            \n        } else if moveDirection == \"left\" {\n            if dict[[startPoint[0] - 1, startPoint[1]]] == \".\" {\n                    startPoint = [startPoint[0] - 1, startPoint[1]]\n                if dict[[startPoint[0], startPoint[1] + 1]] == \".\" {\n                    moveDirection = \"down\"\n                }\n            } else {\n                    moveDirection = \"up\"\n            }\n        } else if moveDirection == \"up\" {\n            if dict[[startPoint[0], startPoint[1] - 1]] == \".\" {\n                    startPoint = [startPoint[0], startPoint[1] - 1]\n                if dict[[startPoint[0] - 1, startPoint[1]]] == \".\" {\n                    moveDirection = \"left\"\n                }\n            } else {\n                    moveDirection = \"right\"\n            }\n        }\n        count += 1\n    }\n    \n    return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341529,"user_id":null,"body":"func path_finder(_ maze: String) -> Bool {\n   guard maze.first != \"W\" else {\n        return false\n    }\n    let mazeArray = maze.split(separator: \"\n\").map({ line in Array(String(line))})\n    let startCoordinate = Coordinate(x: 0, y: 0)\n    var set = Set<Coordinate>()\n    return findAPath(maze: mazeArray, set: &set, currectCoordinate: startCoordinate)\n}\n\nfunc findAPath(maze: [[Character]], set: inout Set<Coordinate>, currectCoordinate: Coordinate) -> Bool {\n    set.insert(currectCoordinate)\n    let steps = [Coordinate(x: currectCoordinate.x + 1, y: currectCoordinate.y),\n                 Coordinate(x: currectCoordinate.x, y: currectCoordinate.y + 1),\n                 Coordinate(x: currectCoordinate.x - 1, y: currectCoordinate.y),\n                 Coordinate(x: currectCoordinate.x, y: currectCoordinate.y - 1)]\n    \n    for step in steps {\n        if !set.contains(step) &&\n            step.x >= 0 && step.y >= 0 &&\n            step.x < maze.count && step.y < maze.count &&\n            maze[step.y][step.x] != \"W\" {\n            if step.x == maze.count - 1 && step.y == maze.count - 1 {\n                return true\n            } else if findAPath(maze: maze, set: &set, currectCoordinate: step) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nstruct Coordinate: Hashable {\n    var x: Int\n    var y: Int\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341530,"user_id":null,"body":"struct Point: Hashable {\n    let x: Int\n    let y: Int\n    \n    func nearbys(maxX: Int, maxY: Int) -> [Point] {\n        return [Point(x: x - 1, y: y),\n                Point(x: x + 1, y: y),\n                Point(x: x, y: y - 1),\n                Point(x: x, y: y + 1)]\n                    .filter { p in\n                        return 0 <= p.x && p.x <= maxX && 0 <= p.y && p.y <= maxY\n                    }\n    }\n}\n\nfunc path_finder(_ maze: String) -> Bool {\n    var map: [[Int]] = []\n    let rows = maze.components(separatedBy: \"\n\")\n    for row in rows {\n        map.append(row.map{ c -> Int in\n            if c == \".\" {\n                return 0\n            } else {\n                return 1\n            }\n        })\n    }\n    func pointValue(_ x: Int, _ y: Int) -> Int {\n        return map[y][x]\n    }\n    let maxX = map[0].count - 1\n    let maxY = map.count - 1\n    \n    var reachList: Set<Point> = []\n    \n    var newList: [Point] = [Point(x: 0, y: 0)]\n    \n    while newList.count > 0 {\n        var tempList: Set<Point> = []\n        for point in newList {\n            let ns = point.nearbys(maxX: maxX, maxY: maxY)\n            for n in ns {\n                if !reachList.contains(n) && pointValue(n.x, n.y) != 1 {\n                    tempList.insert(n)\n                    reachList.insert(n)\n                }\n            }\n        }\n        newList = Array(tempList)\n    }\n    return reachList.contains(Point(x: maxX, y: maxY))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341531,"user_id":null,"body":"enum Direction: String {\n    typealias moveCoordinat = (x: Int, y: Int)\n\n    static let move: [Direction:moveCoordinat] = [\n        .right: (x:1,y:0),.bottom: (x:0,y:1),.left: (x:-1,y:0),.top: (x:0,y:-1)\n    ]\n    \n    case right = \"\u041d\u0430\u043f\u0440\u0430\u0432\u043e\"\n    case bottom = \"\u0412\u043d\u0438\u0437\"\n    case left = \"\u041d\u0430\u043b\u0435\u0432\u043e\"\n    case top = \"\u0412\u0432\u0435\u0440\u0445\"\n}\n\nlet dirStates: [Direction: [Direction]]  = [\n    .right : [.top, .right, .bottom, .left],\n    .top: [.left, .top, .right, .bottom],\n    .bottom: [.right, .bottom, .left, .top],\n    .left: [.bottom, .left, .top, .right]\n]\n\nstruct Position: Equatable {\n    let x: Int\n    let y: Int\n    \n    func move(dir: Direction) -> Position {\n        return Position(x: x + Direction.move[dir]!.x,\n                        y: y+Direction.move[dir]!.y)\n    }\n    \n    static func == (lhs: Position, rhs: Position) -> Bool {\n            lhs.x == rhs.x && lhs.y == rhs.y\n    }\n}\n\nstruct Bound {\n    var rows: Int\n    var cols: Int\n    \n    static var topLeft: Position {\n        Position(x: 0, y: 0)\n    }\n    \n    var bottomRight: Position {\n        Position(x: rows-1, y: cols-1)\n    }\n    \n    func inside(pos: Position) -> Bool {\n        pos.x>=0 && pos.y>=0 && pos.x<cols && pos.y<rows\n    }\n}\n\n\n\nstruct Maze: CustomStringConvertible {\n    var data: [[Character]]\n    var pos: Position\n    var dir: Direction = .right\n\n    let startPos: Position = Bound.topLeft\n    let endPos: Position\n    let bound: Bound\n    \n    init(byText maze: String) {\n        data = maze.split(separator: \"\n\").map { Array($0) }\n        bound = Bound(rows: data.count, cols: data.count)\n        endPos = bound.bottomRight\n        pos = startPos\n    }\n    \n    func wallCollision(pos: Position) -> Bool { data[pos.y][pos.x] != \"W\"}\n    \n    func isCorrectPosition(pos: Position) -> Bool {\n        bound.inside(pos: pos) && wallCollision(pos: pos)\n    }\n    \n    var isFinish: Bool { pos == endPos }\n    \n    var isStart: Bool { pos == startPos }\n    \n    mutating func nextMove() {\n        for predictDir in dirStates[dir]! {\n            let newPos = pos.move(dir: predictDir)\n          \n            if isCorrectPosition(pos: newPos) {\n                (pos, dir) = (newPos, predictDir)\n                return\n            }\n        }\n    }\n    \n    var description: String {\n        var viewData = data\n        viewData[pos.y][pos.x] = \"X\"\n        viewData[endPos.y][endPos.x] = \"E\"\n        let view = viewData.map({String($0)}).joined(separator: \"\n\")\n\n        return view\n    }\n}\n\nfunc path_finder(_ maze: String) -> Bool {\n    var currentMaze = Maze(byText: maze)\n    let max_step = 3000\n    for _ in 0...max_step {\n        print()\n        currentMaze.nextMove()\n        \n        if currentMaze.isFinish {\n            return true\n        }\n    }\n    return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5772382d509c65de7e000982":[{"id":341532,"user_id":53,"body":"\nfunc sequence(_ n: Int) -> [Int : Int] {\n  var xs = [Int : Int]()\n  xs[0] = 0\n  xs[1] = 1\n  xs[2] = 1\n  for i in stride(from: 3, through: n, by: 1) {\n    xs[i] = xs[i - xs[i - 1]!]! + xs[i - xs[i - 2]!]!\n  }\n  return xs\n}\n\nfunc lengthSupUk(_ n: Int, _ k: Int) -> Int {\n\tlet xs = sequence(n)\n  var m = 0\n  for i in stride(from: 0, through: xs.count - 1, by: 1) {\n    if (xs[i]! >= k) {\n      m = m + 1\n    }\n  }\n  return m\n}\n\nfunc comp(_ n: Int) -> Int {\n  let xs = sequence(n)\n  var m = 0\n  for i in stride(from: 1, through: xs.count - 1, by: 1) {\n    if (xs[i]! < xs[i - 1]!) {\n      m = m + 1\n    }\n  }\n  return m\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341533,"user_id":null,"body":"func lengthSupUk(_ n: Int, _ k: Int) -> Int {\n    var u = [1,1]\n    for a in 2..<n {\n        u.append( u[a - u[a-1]] + u[a - u[a-2]])\n    }\n    return u.filter {$0 >= k}.count\n}\n\nfunc comp(_ n: Int) -> Int {\n    var u = [1,1]\n    var previous = 1;\n    var count = 0;\n    for a in 2..<n {\n        u.append( u[a - u[a-1]] + u[a - u[a-2]])\n        if(previous > u.last!){\n            count+=1\n        }\n        previous = u.last!\n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341534,"user_id":17,"body":"var lookup: [Int] = [0, 1, 1]\nfunc u(_ n: Int) -> Int {\n  while lookup.count <= n {\n    lookup.append(lookup[lookup.count - lookup[lookup.count - 1]] + lookup[lookup.count - lookup[lookup.count - 2]])\n  }\n  return lookup[n]\n}\nfunc lengthSupUk(_ n: Int, _ k: Int) -> Int {\n  var result: Int = 0\n  for i in 1...n {\n    if u(i) >= k {\n      result += 1\n    }\n  }\n  return result\n}\nfunc comp(_ n: Int) -> Int {\n  var result: Int = 0\n  for i in 2...n {\n    if u(i) < u(i - 1) {\n      result += 1\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341535,"user_id":null,"body":"func lengthSupUk(_ n: Int, _ k: Int) -> Int {\n    return buildSequence(n).filter { $0 >= k }.count\n}\n\nfunc comp(_ n: Int) -> Int {\n    let sequence = buildSequence(n)\n    return sequence.enumerated().filter { return ($0.offset - 1 > 0) ? $0.element < sequence[$0.offset - 1] : false }.count\n}\n\nfunc buildSequence(_ n: Int) -> [Int] {\n    var sequence = [1, 1]\n    \n    for i in 2..<n {\n        let n1 = i - sequence[i - 1]\n        let n2 = i - sequence[i - 2]\n        \n        let number = sequence[n1] + sequence[n2]\n        sequence.append(number)\n    }\n    \n    return sequence\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341536,"user_id":null,"body":"struct U {\n  var list = [0,1,1]\n  \n  subscript(index: Int) -> Int {\n    mutating get {\n      guard index >= list.count else {return list[index]}\n      for i in list.count...index {\n        list.append(list[i - list[i - 1]] + list[i - list[i - 2]])\n      }\n      return list[index]\n    }\n  }\n}\n\n\nfunc lengthSupUk(_ n: Int, _ k: Int) -> Int {\n\tvar u = U()\n  var count = 0\n  for i in 1...n {\n    if u[i] >= k {\n      count += 1\n    }\n  }\n  return count\n}\n\nfunc comp(_ n: Int) -> Int {\n  var u = U()\n  var count = 0\n  for i in 2...n {\n    if u[i] < u[i - 1] {\n      count += 1\n    }\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341537,"user_id":null,"body":"var u = [1, 1]\n\nfunc build(_ n: Int) {\n  guard n > u.count else { return }\n  for i in (u.count)...n {\n    u.append(u[i - u[i - 1]] + u[i - u[i - 2]])\n  }\n}\n\nfunc lengthSupUk(_ n: Int, _ k: Int) -> Int {\n  build(n)\n  return u[..<n].filter({ $0 >= k }).count\n}\n\nfunc comp(_ n: Int) -> Int {\n  build(n)\n  return zip(u[0..<(n - 1)], u[1..<n]).filter({ $1 < $0 }).count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341538,"user_id":null,"body":"func lengthSupUk(_ n: Int, _ k: Int) -> Int {\n\tvar u = [0, 1, 1]\n  var count = k<=1 ? 2 : 0\n  for i in 3...n {\n    let pre = u[i-1]\n    let pre2 = u[i-2]\n    u.append(u[i-pre] + u[i-pre2])\n    if u[i] >= k {\n      count += 1\n    }\n  }\n  return count\n}\n\nfunc comp(_ n: Int) -> Int {\n  var u = [0, 1, 1]\n  var count = 0\n  for i in 3...n {\n    let pre = u[i-1]\n    let pre2 = u[i-2]\n    u.append(u[i-pre] + u[i-pre2])\n    if u[i] < u[i-1] {\n      count += 1\n    }\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341539,"user_id":null,"body":"var seq: [Int: Int] = [1: 1,\n                       2: 1]\n\nfunc u(_ n: Int) -> Int {\n  if seq.count >= n {\n    return seq[n]!\n  }\n  for i in 1...n {\n    if seq.count < i {\n      seq[i] = seq[i - seq[i - 1]!]! + seq[i - seq[i - 2]!]!\n    }\n  }\n  return seq[n]!\n}\n\nfunc lengthSupUk(_ n: Int, _ k: Int) -> Int {\n  var count = 0\n  let _ = u(n)\n  for i in 1...n {\n    if u(i) >= k {\n      count += 1\n    }\n  }\n  return count\n}\n\nfunc comp(_ n: Int) -> Int {\n  var count = 0\n  let _ = u(n)\n  for i in 3...n {\n    if u(i - 1) > u(i) {\n      count += 1\n    }\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341540,"user_id":null,"body":"func sequence(_ n: Int) -> [Int: Int] {\n  var xs = [Int: Int]()\n  xs[0] = 0\n  xs[1] = 1\n  xs[2] = 1\n\n  for i in 3...n {\n      xs[i] = xs[i - xs[i - 1]!]! + xs[i - xs[i - 2]!]!\n  }\n\n  return xs\n}\n\nfunc lengthSupUk(_ n: Int, _ k: Int) -> Int {\n  let xs = sequence(n)\n  var m = 0\n\n  for i in 0..<xs.count where xs[i]! >= k {\n      m += 1\n  }\n\n  return m\n}\n\nfunc comp(_ n: Int) -> Int {\n  let xs = sequence(n)\n  var m = 0\n\n  for i in 1..<xs.count where xs[i]! < xs[i - 1]! {\n      m += 1\n  }\n\n  return m\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341541,"user_id":null,"body":"func lengthSupUk(_ n: Int, _ k: Int) -> Int {\n\tgetSequence(n).filter({$0 >= k}).count\n}\n\nfunc comp(_ n: Int) -> Int {\n  var ret = 0\n  var prev = 0\n  getSequence(n).forEach {\n    if prev > $0 {\n      ret += 1\n    }\n    prev = $0\n  }\n  \n  return ret\n}\n\nfunc getSequence(_ n: Int) -> [Int] {\n  guard n > 1 else {\n    return [1]\n  }\n  var u = [1, 1]\n\n  guard n > 2 else {\n    return u\n  }\n\n  for i in 2 ..< n {\n    let current = i\n    let prev0 = current - u[current - 1]\n    let prev1 = current - u[current - 2]\n    u.append(u[prev0] + u[prev1])\n  }\n  \n  return u\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5772da22b89313a4d50012f7":[{"id":341542,"user_id":1519,"body":"func great(_ name: String, _ owner: String) -> String {\n  return \"Hello \\(name == owner ? \"boss\" : \"guest\")\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341543,"user_id":null,"body":"func great(_ name: String, _ owner: String) -> String {\n  return name == owner ? \"Hello boss\" : \"Hello guest\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341544,"user_id":null,"body":"func great(_ name: String, _ owner: String) -> String {\n  if name == owner {\n    return \"Hello boss\"\n  } else {\n    return \"Hello guest\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341545,"user_id":null,"body":"func great(_ name: String, _ owner: String) -> String {\n  name == owner ? \"Hello boss\" : \"Hello guest\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341546,"user_id":null,"body":"func great(_ name: String, _ owner: String) -> String {\n    enum PersonType: String {\n        case boss = \"boss\"\n        case guest = \"guest\"\n    }\n    return \"Hello \\(name == owner ? PersonType.boss : PersonType.guest)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341547,"user_id":1504,"body":"func great(_ name: String, _ owner: String) -> String {\n  let greetMsg = name == owner ? \"boss\" : \"guest\"\n  return \"Hello \\(greetMsg)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341548,"user_id":null,"body":"func great(_ name: String, _ owner: String) -> String {\n  switch name{\n    case owner:\n      return \"Hello boss\"\n    default:\n      return \"Hello guest\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341549,"user_id":null,"body":"let great: (String,String) -> String = { $0 == $1 ? \"Hello boss\" : \"Hello guest\"}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341550,"user_id":null,"body":"func great(_ name: String, _ owner: String) -> String {\n    enum PersonType: String {\n        case boss = \"boss\"\n        case guest = \"guest\"\n    }\n    \n    var personType: PersonType {\n        return name == owner ? .boss : .guest\n    }\n  \n    return \"Hello \\(personType)\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341551,"user_id":null,"body":"let great: (String, String) -> String = {\n  \"Hello \\($0 == $1 ? \"boss\": \"guest\")\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5778aa7c82d7d0b49c00001a":[{"id":341552,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n    let commonSet = CharacterSet(charactersIn: a).intersection(CharacterSet(charactersIn: b))\n    let longestAB = (a+b).components(separatedBy: commonSet).max(by: {$1.count > $0.count})?.count ?? 0\n    let longestBA = (b+a).components(separatedBy: commonSet).max(by: {$1.count > $0.count})?.count ?? 0\n    \n    \n    return max(longestAB, longestBA)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341553,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n  let nonUnique = Set(b.filter { a.contains($0) })\n  let s = (a + b).split { nonUnique.contains($0) } + (b + a).split { nonUnique.contains($0) }\n  return s.max(by: { $1.count > $0.count })?.count ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341554,"user_id":840,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n    return [a + b, b + a]\n        .map { $0.components(separatedBy: CharacterSet(charactersIn: String(Set(Array(a)).intersection(Set(Array(b))))))\n            .map { $0.count }\n            .max() ?? 0 }\n        .max() ?? 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341555,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n    var sameLetters = [String]()\n    for letter in a {\n        if b.contains(letter) {\n                sameLetters.append(String(letter))\n        }\n    }\n    sameLetters = Array(Set(sameLetters)) \/\/remove repeating symbols\n    var result = 0\n    var tmpStr = \"\"\n    for el in (a + b) {\n        if !sameLetters.contains(String(el)) {\n            tmpStr += String(el)\n            if tmpStr.count > result {\n                result = tmpStr.count\n            }\n        } else {\n            tmpStr = \"\"\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341556,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n    let aR = Array(a)\n    let bR = Array(b)\n    var outR: Set<Character> = []\n    for char in aR {\n        if bR.contains(char){\n            outR.insert(char)\n        }\n    }\n    print(outR)\n    \n    let aB = Array(a) + Array(b)\n    let bA = Array(b) + Array(a)\n    var counterAB = 0\n    var counterBA = 0\n    var countArr = [Int]()\n    \n    for char in aB {\n        if !outR.contains(char) {\n            counterAB += 1\n        } else {\n            countArr.append(counterAB)\n            counterAB = 0\n        }\n        if char == aB.last {\n            countArr.append(counterAB)\n        }\n    }\n    \n    for char in bA {\n        if !outR.contains(char) {\n            counterBA += 1\n        } else {\n            countArr.append(counterBA)\n            counterBA = 0\n        }\n        if char == bA.last {\n            countArr.append(counterBA)\n        }\n    }\n    if let result = countArr.max() {\n    return result\n    } else {\n        return 0\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341557,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n  var newA = \"\"\n  var newB = \"\"\n\n  for i in a {\n    if b.contains(String(i)) == false {\n       newA += (String(i))\n    } else {\n        newA += \"_\"\n    }\n}\n\n  for i in b {\n    if a.contains(String(i)) == false {\n       newB += (String(i))\n    } else {\n        newB += \"_\"\n    }\n}\n  \n  let total1 = newA + newB\n  let total2 = newB + newA\n  var newArray: [String] = []\n\n  let split1 = total1.split(separator: \"_\")\n  let split2 = total2.split(separator: \"_\")\n  for i in split1 {\n    newArray.append(String(i))\n  }\n  for i in split2 {\n    newArray.append(String(i))\n  }\n\n  var totalInt = 0\n  let sort = newArray.sorted { s1, s2 in \n  s2.count < s1.count }\n  \nif sort.indices.contains(0) {\n  totalInt = sort[0].count\n}\n\n  return totalInt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341558,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n  let ab = a+b\n  let ba = b+a\n  let common = Set(a).intersection(Set(b))\n  var longest = 0\n  var count = 0\n  \n  for w in [ab, ba] {\n    count = 0\n    for c in w {\n      if common.contains(c) {\n        if count > longest { longest = count }\n        count = 0\n      } else {\n        count += 1\n      }\n    }\n  }\n  if count > longest { longest = count }\n  return longest\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341559,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n    let bannedAlphabet = Set(a.map{$0}).intersection(Set(b.map{$0}))\n    guard !bannedAlphabet.isEmpty else { return (a + b).count }\n    var result = 0\n    var help = 0\n    \n    for i in (a + b + a) {\n        if bannedAlphabet.contains(i) {\n            if result < help {\n                result = help\n            }\n            help = 0\n        } else {\n            help += 1\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341560,"user_id":null,"body":"func f(_ s: [Bool]) -> Int {\n  (0 ..< s.count).reduce(0) { m, i in \n    max(m, s[i...].prefix(while: { $0 }).count) \n  }\n}\n\nfunc longestSubstring(_ a: String, _ b: String) -> Int {\n  let a2 = a.map { !b.contains($0) }\n  let b2 = b.map { !a.contains($0) }\n  return max(f(a2+b2), f(b2+a2))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341561,"user_id":null,"body":"func longestSubstring(_ a: String, _ b: String) -> Int {\n  let i = Set(a).intersection(Set(b))\n  return [a + b, b + a]\n    .compactMap { s in\n      s\n        .map { i.contains($0) ? Character(\"\u0439\") : $0 }\n        .split(separator: \"\u0439\")\n        .map { $0.count }\n        .max()\n    }\n    .max() ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"577b9960df78c19bca00007e":[{"id":341562,"user_id":null,"body":"func findDigit(_ num: Int, _ nth: Int) -> Int {\n  let positive = abs(num)\n  \n  guard nth > 0 else { return -1 }\n  guard positive > 0 else { return 0 }\n  guard nth > 1 else { return positive % 10 }\n  \n  return findDigit(positive \/ 10, nth - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341563,"user_id":null,"body":"func findDigit(_ num:Int, _ nth: Int) -> Int {\n  var num = num\n  guard nth > 0 else { return -1 }\n  guard nth > 1 else { return abs(num % 10) }\n  for _ in 1..<nth {num \/= 10}\n  return abs(num % 10)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341564,"user_id":null,"body":"func findDigit(_ num:Int, _ nth: Int) -> Int{\n\n    if(nth <= 0){return -1}\n\n    \/\/Int to String\n    let tempNum = num.description\n  \n    if(nth > tempNum.count ) {return 0}\n  \n    \/\/Instead of reversing the chars\n    let index = tempNum.count - nth\n\n    \/\/Yes this is Swift we have to do it this way :\/\n    let p = tempNum.index(tempNum.startIndex, offsetBy: index)\n\n    let pValue = Int(String(tempNum[p]))!\n    \n    return pValue\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341565,"user_id":null,"body":"import Foundation\nfunc findDigit(_ num:Int, _ nth: Int) -> Int {\n  guard nth > 0 else {\n    return -1\n  }\n  let trunc = abs(num) \/ Int(pow(10.0, Double(nth-1)))\n  return trunc - trunc \/ 10 * 10\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341566,"user_id":null,"body":"import Foundation\n\nfunc findDigit(_ num:Int, _ nth: Int) -> Int {\n  return nth > 0 ? (abs(num) \/ Int(pow(10.0,Double(nth-1)))) % 10 : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341567,"user_id":null,"body":"func findDigit(_ num:Int, _ nth: Int) -> Int {\n\tguard nth > 0 else {\n\t\treturn -1\n\t}\n\tlet num = abs(num)\n\tlet characters: [Character] = String(num).characters.map({ $0 }).reversed()\n\tguard characters.count >= nth && characters.count > 0 else {\n\t\treturn 0\n\t}\n\treturn Int(String(characters[nth - 1])) ?? 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341568,"user_id":null,"body":"func findDigit(_ num:Int, _ nth: Int) -> Int {\n  guard nth > 0  else { return -1 }\n    let arr = Array(String(num).compactMap { $0.wholeNumberValue }.reversed())\n    if arr.count < nth || arr.isEmpty {\n        return 0\n    }\n    return arr[nth-1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341569,"user_id":null,"body":"func findDigit(_ num:Int, _ nth: Int) -> Int {\n    guard nth > 0 else { return -1 }\n    guard nth <= num.description.count else { return 0 }\n    return Int(\"\\(String(num).reversed()[nth - 1])\")!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341570,"user_id":null,"body":"func findDigit(_ num: Int, _ nth: Int) -> Int {\n    guard nth > 0 else {\n        return -1\n    }\n    \n    let chars = String(abs(num)).map { String($0) }\n    \n    guard nth <= chars.count else {\n        return 0 \/\/out of bounds\n    }\n    \n    \/\/normalize index\n    let index = chars.count - nth\n    return Int(chars[index])!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341571,"user_id":null,"body":"func findDigit(_ num:Int, _ nth: Int) -> Int {\n    \n    let p = abs(num)\n\n    guard nth > 0 else { return -1 }\n    \n    guard p > 0 else { return 0 }\n    \n    guard nth > 1 else { return p % 10 }\n\n    return findDigit(p \/ 10, nth - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57873ab5e55533a2890000c7":[{"id":341572,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    guard let time = timeString, time.isEmpty == false\n        else { return timeString }\n    \n    let numbers = time.components(separatedBy: \":\").flatMap({Int($0)})\n    guard numbers.count == 3\n        else { return nil }\n    \n    let timestamp = numbers[2] + numbers[1]*60 + numbers[0]*3600\n    let hours = (timestamp\/3600)%24\n    let minutes = (timestamp\/60)%60\n    let seconds = timestamp % 60\n    return \"\\(String(format: \"%02d\", hours)):\\(String(format: \"%02d\",minutes)):\\(String(format: \"%02d\",seconds))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341573,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    guard let timeStr = timeString, !timeStr.isEmpty else { return timeString }\n    var numbers = timeStr.components(separatedBy: \":\").map { Int($0) }.filter { $0 != nil } as! [Int]\n    guard numbers.count == 3 else { return nil }\n    if numbers[2] > 59 { numbers[1] += numbers[2] \/ 60; numbers[2] %= 60 }\n    if numbers[1] > 59 { numbers[0] += numbers[1] \/ 60; numbers[1] %= 60 }\n    numbers[0] %= 24\n    return numbers.map { $0 > 9 ? String($0) : \"0\" + String($0) }.joined(separator: \":\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341574,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    guard let _ = timeString, !(timeString?.isEmpty)! else { return timeString }\n    guard let c = timeString?.components(separatedBy: \":\"), c.count == 3 else { return nil }\n    guard var h = Int(c[0]), var m = Int(c[1]), var s = Int(c[2]) else { return nil }\n\n    m += s \/ 60\n    s = s % 60\n    h += m \/ 60\n    m = m % 60\n    h = h % 24\n\n    return \"\\(h > 9 ? \"\" : \"0\")\\(h):\\(m > 9 ? \"\" : \"0\")\\(m):\\(s > 9 ? \"\" : \"0\")\\(s)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341575,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    \n    if let time = timeString {\n        guard time.isEmpty == false else {return \"\"}\n        guard time.contains(\":\") && CharacterSet(charactersIn: \":1234567890\").isSuperset(of: CharacterSet(charactersIn: time)) else {return nil}\n        \n        let seconds = Int(time.components(separatedBy: \":\").enumerated().reduce(0, { (res, tup) in\n            res + (Double(tup.element)! * pow(60, Double(abs(tup.offset - 2))))\n        }))\n        \n        let hour = seconds % (60 * 60 * 24) \/ (60 * 60)\n        let min = seconds % (60 * 60) \/ 60\n        let sec = seconds % (60 * 60) % 60\n        \n        return formatedTime(hour) + \":\" + formatedTime(min) + \":\" + formatedTime(sec)\n    }\n    \n    return nil\n}\n\nfunc formatedTime(_ t: Int) -> String {return t < 10 ?  \"0\\(t)\" : \"\\(t)\"}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341576,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    guard let string = timeString else { return nil }\n    if string.isEmpty { return \"\" }\n    guard ((string.firstIndex(of: \":\")) != nil) else { return nil }\n    guard let array = timeString?.split(separator: \":\").map({ Int($0) }) else { return nil }\n    guard var hours = array[0], var min = array[1], var sec = array[2] else { return nil }\n    min += sec \/ 60\n    sec = sec % 60\n    hours += min \/ 60\n    min = min % 60\n    hours = hours % 24\n    \n    return [hours, min, sec].map({ $0 >= 10 ? \"\\($0)\" : \"0\\($0)\"}).joined(separator: \":\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341577,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n  guard \n    let str = timeString,\n    !str.isEmpty \n  else { \n    return timeString\n  }\n  \n  let integers = str.components(separatedBy: \":\").compactMap(Int.init)\n  guard integers.count == 3 else { \n    return nil \n  }\n  \n  let totalSeconds = integers\n    .reversed()\n    .enumerated()\n    .map { idx, val -> Int in \n      val * Int(truncating: pow(60, idx) as NSDecimalNumber ) \n    }.reduce(0,+)\n  \n    let daySeconds = totalSeconds % 86400\n    return String(format: \"%02d:%02d:%02d\", \n                  (daySeconds \/ 3600), \n                  ((daySeconds % 3600) \/ 60), \n                  ((daySeconds % 3600) % 60))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341578,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    \n    guard let time = timeString,\n        time.isEmpty == false else { return timeString }\n    let tokens = time.components(separatedBy: \":\")\n    guard tokens.count == 3 else { return nil }\n    \n    let hours = CeilingNumber(ceiling: 24)\n    let minutes = CeilingNumber(ceiling: 60)\n    let seconds = CeilingNumber(ceiling: 60)\n    \n    guard   let hoursValue = Int(tokens[0]),\n            let minutesValue = Int(tokens[1]),\n            let secondsValue = Int(tokens[2])\n            else { return nil }\n    \n    \n    hours.value = hoursValue\n    minutes.value = minutesValue\n    seconds.value = secondsValue\n    \n    minutes.value = minutes.value + seconds.lastRemainder\n    hours.value = hours.value + minutes.lastRemainder\n    \n    return \"\\(hours):\\(minutes):\\(seconds)\"\n}\n\nclass CeilingNumber: CustomStringConvertible {\n    private var _value = 0\n    private let ceiling: Int\n    var lastRemainder = 0\n    \n    init(ceiling: Int) {\n        self.ceiling = ceiling\n    }\n    \n    var value: Int {\n        get {\n            return _value\n        }\n        set {\n            lastRemainder += newValue \/ ceiling\n            _value = newValue % ceiling\n        }\n    }\n    \n    var description: String {\n        return String(format: \"%02d\", _value)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341579,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n    guard timeString != nil else { return nil }\n    guard timeString != \"\" else { return \"\" }\n    if let substrRange = timeString!.range(of: \"[0-9]{2,3}\\\\:[0-9]{2,3}+\\\\:[0-9]{2,3}\", options: .regularExpression) {\n        guard let allTimeArray = timeString?[substrRange].split(separator: \":\"),\n            var hour = Int(String(allTimeArray[0])),\n            var min = Int(String(allTimeArray[1])),\n            var sec = Int(String(allTimeArray[2])) else {return nil}\n        \n        while sec >= 60 { sec = sec - 60; min = min + 1 }\n        while min >= 60 { min = min - 60; hour = hour + 1 }\n        while hour >= 24 { hour = hour - 24 }\n        let res: String = (hour < 10 ? \"0\\(hour):\" : \"\\(hour):\") + (min < 10 ? \"0\\(min):\" : \"\\(min):\") + (sec < 10 ? \"0\\(sec)\" : \"\\(sec)\")\n        return res\n        \n    } else {\n        return nil\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341580,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n  guard let timeString = timeString else {\n    return nil\n  }\n  \n  if timeString.isEmpty {\n    return \"\"\n  }\n  \n  var timeArray = timeString.components(separatedBy: \":\")\n  \n  if timeArray.count != 3 {\n    return nil\n  }\n  \n  if var seconds = Int(timeArray[2]),\n    var minutes = Int(timeArray[1]),\n    var hours = Int(timeArray[0]) {\n    \n    if seconds > 59 {\n      minutes += Int(seconds \/ 60)\n      seconds = seconds % 60\n    }\n    if minutes > 59 {\n      hours += Int(minutes \/ 60)\n      minutes = minutes % 60\n    }\n    if hours > 23 {\n      hours = hours % 24\n    }\n        \n    return (hours < 10 ? \"0\\(hours):\" : \"\\(hours):\") +\n      (minutes < 10 ? \"0\\(minutes):\" : \"\\(minutes):\") +\n      (seconds < 10 ? \"0\\(seconds)\" : \"\\(seconds)\")\n  }\n  \n  return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341581,"user_id":null,"body":"func correct(_ timeString: String?) -> String? {\n  \n    guard let time = timeString, !time.isEmpty else {\n        return timeString\n    }\n\n    var timeList = timeString!.components(separatedBy: \":\").compactMap{ Int($0) }\n    \n    guard timeList.count == 3 else {\n        return nil\n    }\n  \n    let totalSecs = timeList[2] + timeList[1] * 60 + timeList[0] * 3600\n    \n    timeList[2] = totalSecs % 60\n    timeList[1] = (totalSecs \/ 60) % 60\n    timeList[0] = (totalSecs \/ 3600) % 24\n  \n    let resultString = timeList.map { String(format: \"%02d\", $0) }.joined(separator: \":\")\n\n    return resultString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57a0e5c372292dd76d000d7e":[{"id":341582,"user_id":527,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  return String(repeating: string, count: n)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341583,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  \/\/ Code here:\n  var list: String = \"\"\n  for _ in 0 ..< n {\n    list.append(string)\n }\n return list\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341584,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  var sumString = \"\"\n    if n > 0 {\n        for _ in 1...n {\n            sumString += string\n        }\n    }\n    return sumString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341585,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n          let text = String(repeating:string , count: n)\n\n   return text\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341586,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n    \n  var i = n\n  var returnString = \"\"\n  \n    while i != 0 {\n        i = i - 1\n        returnString += string\n    }\n    \n  return returnString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341587,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  var finalString = String()  \n  for i in 0..<n{\n    finalString += string\n  }\n  return finalString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341588,"user_id":null,"body":"let repeat_str  = {String(repeating: $1, count: $0)}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341589,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  return (0..<n).map { _ in string }.reduce(\"\") { $0 + $1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341590,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  return (0..<n)\n    .reduce(\"\") { t,_ in \n      \"\\(t)\\(string)\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341591,"user_id":null,"body":"func repeat_str(_ n: Int, _ string: String) -> String {\n  return  Array.init(repeating: string, count: n).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57a429e253ba3381850000fb":[{"id":341592,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n    let index = Double(weight) \/ (height * height)\n    if index <= 18.5 {return \"Underweight\"}\n    if index <= 25.0 {return \"Normal\"}\n    if index <= 30.0 {return \"Overweight\"}\n    return \"Obese\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341593,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n    switch Double(weight)\/pow(height, 2) {\n      case ...18.5: return \"Underweight\"\n      case ...25.0: return \"Normal\"\n      case ...30.0: return \"Overweight\"\n      default: return \"Obese\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341594,"user_id":null,"body":"enum BMIKind: CustomStringConvertible {\n    case underweight\n    case normal\n    case overweight\n    case obese\n    \n    var description: String {\n        switch self {\n        case .underweight:\n            return \"Underweight\"\n        case .normal:\n            return \"Normal\"\n        case .overweight:\n            return \"Overweight\"\n        case .obese:\n            return \"Obese\"\n        }\n    }\n\n    init(bmiIndex: Double) {\n        if bmiIndex <= 18.5 {\n            self = .underweight\n        } else if bmiIndex <= 25.0 {\n            self = .normal\n        } else if bmiIndex <= 30.0 {\n            self = .overweight\n        } else {\n            self = .obese\n        }\n    }\n}\n\nstruct BMIIndex {\n    var rawValue: Double\n    init(weight: Int, height: Double) {\n        rawValue = Double(weight) \/ (height * height)\n    }\n}\n\nfunc bmi(_ weight: Int, _ height: Double) -> String {\n    let bmiIndex = BMIIndex(weight: weight, height: height)\n    let bmiKind = BMIKind(bmiIndex: bmiIndex.rawValue)\n    return bmiKind.description\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341595,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n    let bmi = Double(weight)\/(height * height)\n    switch bmi {\n      case 0...18.5:\n        return \"Underweight\"\n      case 18.5...25.0:\n        return \"Normal\"\n      case 25.0...30.0:\n        return \"Overweight\"\n      default:\n        return \"Obese\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341596,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n    let bmi = Double(weight) \/ pow(height, 2.0)\n    if bmi <= 18.5 {\n      return \"Underweight\"\n    } else if bmi <= 25.0 {\n      return \"Normal\"\n    } else if bmi <= 30.0 {\n      return \"Overweight\"\n    } else {\n      return \"Obese\"\n    }\n      \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341597,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n   let bmi = Double(weight)\/pow(height, 2)\n   return bmi <= 18.5 ? \"Underweight\" : (bmi <= 25.0 ? \"Normal\" : (bmi <= 30.0 ? \"Overweight\" : \"Obese\")) \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341598,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n  var bmi =  Double(weight) \/ (height * height)\n  switch bmi {\n  case 0...18.5:\n    return \"Underweight\"\n  case 18.5...25:\n    return \"Normal\"\n  case 25...30:\n    return \"Overweight\"\n  default:\n    return \"Obese\"\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341599,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n   var bmiValue = Double(weight) \/ Double(( height * height ))\n   switch bmiValue {\n   case 0...18.5:\n        return \"Underweight\"\n   case 18.5...25.0:\n        return \"Normal\"\n   case 25.0...30.0:\n        return \"Overweight\"\n   case 30.0...:\n        return \"Obese\"\n   default:\n        return \"Naxuy blyad\"\n   }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341600,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n     let bmi = Float(Double(weight) \/ (height * height))\n   switch  bmi {\n                case let bmi where bmi <= 18.5 : return \"Underweight\"\n                case let bmi where bmi <= 25.0 : return \"Normal\"\n                case let bmi where bmi <= 30.0 : return \"Overweight\"\n                default : return \"Obese\"\n            }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341601,"user_id":null,"body":"func bmi(_ weight: Int, _ height: Double) -> String {\n  let weightdouble = Double(weight)\n  let result:Double = ((weightdouble)\/(height*height))\n  \n\nswitch true {\ncase result <= 18.5:\n    return \"Underweight\"\n\ncase result <= 25.0:\n    return \"Normal\"\n\ncase result <= 30.0:\n    return \"Overweight\"\n\ncase result > 30:\n    return \"Obese\"\n\ndefault:\n    return \"Are you alive?\"\n}\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57aa218e72292d98d500240f":[{"id":341602,"user_id":590,"body":"import Foundation\n\nfunc heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  let s = (a + b + c) \/ 2\n  return  sqrt(s * (s - a) * (s - b) * (s - c))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341603,"user_id":null,"body":"import Foundation\n\nfunc heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  let s = (a + b + c) \/ 2\n  let t = s*(s - a)*(s - b)*(s - c)\n  return sqrt(t)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341604,"user_id":null,"body":"func heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  let triangle = Triangle(a, b, c)\n  \n  return triangle.area\n\n}\n\nclass Triangle {\n  let sideA: Double\n  let sideB: Double\n  let sideC: Double\n\n  var area: Double {\n    let s = (self.sideA + self.sideB + self.sideC) \/ 2\n    let result = (s * (s - self.sideA) * (s - self.sideB) * (s - self.sideC)).squareRoot()\n    \n    return round(result * 100) \/ 100\n  }\n  \n  init(_ a: Double, _ b: Double, _ c: Double) {\n    self.sideA = a\n    self.sideB = b\n    self.sideC = c\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341605,"user_id":null,"body":"func heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\nvar s:Double = ((a+b+c)\/2)\n   return (s * (s-a) * (s-b) * (s-c)).squareRoot()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341606,"user_id":null,"body":"func heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  var s: Double = 0.00\n  s = (a+b+c)\/2\n  return (s*(s-a)*(s-b)*(s-c)).squareRoot()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341607,"user_id":null,"body":"func heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    let s = (a + b + c) \/ 2\n    let result = sqrt(s*(s-a)*(s-b)*(s-c))\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341608,"user_id":null,"body":"import Foundation\n\nfunc heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  let s = (a + b + c) * 0.5\n  return sqrt(s * (s - a) * (s - b) * (s - c))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341609,"user_id":null,"body":"import Foundation\n\nfunc heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  var s = (a + b + c) \/ 2\n  var squart = sqrt (s * (s - a) * (s - b) * (s - c))\n  return squart\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341610,"user_id":null,"body":"func heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  let s = Double ((a+b+c)\/2)\n  return sqrt(s * (s-a) * (s-b) * (s-c))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341611,"user_id":null,"body":"func heron(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c)) \/ 4\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57ad85bb7cb1f3ae7c000039":[{"id":341612,"user_id":null,"body":"func numbersWithDigitInside(_ x: Int64, _ d: Int64) -> [Int64] {\n   let numbers = (1...x).filter {String($0).contains(String(d))}\n\n    return [Int64(numbers.count),\n            numbers.reduce(Int64(0), +),\n            numbers.count > 0 ? numbers.reduce(Int64(1), *) : Int64(0)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341613,"user_id":null,"body":"typealias Long = Int64\n\nfunc numbersWithDigitInside(_ x: Long, _ d: Long) -> [Long] {\n  let r = (1...x).filter({String($0).contains(String(d))})\n  return r.count > 0 ? [Int64(r.count), r.reduce(0,+), r.reduce(1,*)] : [0,0,0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341614,"user_id":null,"body":"typealias Long = Int64\n\nlet empty: [Long] = [0, 0, 0]\n\nfunc numbersWithDigitInside(_ x: Long, _ d: Long) -> [Long] {\n  guard x > 0 else { return empty }\n  guard (0...9).contains(d) else { return empty }\n  \n  let value = String(d)\n  let numbers = (1...x).filter { String($0).contains(value) }\n  return [Long(numbers.count), \n      numbers.reduce(Long(0), +), \n      numbers.count > 0 ? numbers.reduce(Long(1), *) : 0\n  ]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341615,"user_id":null,"body":"typealias Long = Int64\n\nfunc numbersWithDigitInside(_ x: Long, _ d: Long) -> [Long] {\n    let numbers = (1...x).filter { \"\\($0)\".contains(\"\\(d)\") }\n    return numbers.isEmpty ? [0, 0 ,0] : [Long(numbers.count), numbers.reduce(0, +), numbers.reduce(1, *)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341616,"user_id":null,"body":"func numbersWithDigitInside(_ x: Int64, _ d: Int64) -> [Int64] {\n  let array = Array(1...x).filter{String($0).contains(String(d))}\n  return array.count == 0 ? [0,0,0] : [Int64(array.count), array.reduce(0, +), array.reduce(1, { $0 * $1})]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341617,"user_id":null,"body":"typealias Long = Int64\n\nfunc numbersWithDigitInside(_ x: Long, _ d: Long) -> [Long]\n{\n    return { [Int64($0.count), $0.reduce(0, +), $0.reduce(0) { if $0 == 0 { return $1 } else { return $0 * $1 } }] }((1...x).filter { $0.description.contains(\"\\(d)\") })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341618,"user_id":null,"body":"typealias Long = Int64\n\nfunc numbersWithDigitInside(_ x: Long, _ d: Long) -> [Long] {\n    let digit = String(d)\n    var result: [Long] = []\n    for number in 1...x {\n        if String(number).contains(digit) {\n            result.append(number)\n        }\n    }\n    return [Long(result.count), result.reduce(0, +), result.count == 0 ? 0 : result.reduce(1, *)]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341619,"user_id":null,"body":"typealias Long = Int64\n\nlet empty: [Long] = [0, 0, 0]\n\nfunc numbersWithDigitInside(_ x: Long, _ d: Long) -> [Long] {\n  guard x > 0 else { return empty }\n  guard (0...9).contains(d) else { return empty }\n  \n  print(x)\n  print(d)\n  let value = String(d)\n  let numbers = (1...x).filter { String($0).contains(value) }\n  return [Long(numbers.count), \n      numbers.reduce(Long(0), +), \n      numbers.count > 0 ? numbers.reduce(Long(1), *) : 0\n  ]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341620,"user_id":null,"body":"func numbersWithDigitInside(_ x: Int64, _ d: Int64) -> [Int64] {\n    let arr = Array(1...x).filter { String($0).contains(Character(\"\\(d)\")) }\n\n    return [Int64(arr.count), arr.reduce(0, +), arr.count > 0 ? arr.reduce(1, *) : 0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341621,"user_id":null,"body":"func numbersWithDigitInside(_ x: Int64, _ d: Int64) -> [Int64] {\n    let arr = Array(1...x).map { String($0) }.filter { $0.contains(Character(\"\\(d)\")) }.compactMap { Int64($0) }\n\n    return [Int64(arr.count), arr.reduce(0, +), arr.count > 0 ? arr.reduce(1, *) : 0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57ae18c6e298a7a6d5000c7a":[{"id":341622,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n    return array.map { $0 == old ? new : $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341623,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n    var newArr = array\n    for i in 0..<newArr.count {\n        if newArr[i] == old {\n            newArr[i] = new\n        }\n    }\n    return newArr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341624,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n  return array.map { $0 != old ? $0 : new }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341625,"user_id":null,"body":"import Foundation\n\n\nfunc replaceAll(array: [Int], old: Int, new: Int) -> [Int] {\n    array.map { element in  \n        element == old ? new : element\n    }\n}\n\n\nfunc replaceAll(array: [String], old: String, new: String) -> [String] {\n    array.map { element in\n        element == old ? new : element\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341626,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n   var arr = array\n    for (index, value) in arr.enumerated() {\n        if value == old {\n            arr[index] = new\n        }\n    }\n    return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341627,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n   array.map { $0 == old ? new : $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341628,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n  var result: [T] = []\n  \n  for index in array {\n    result.append(index == old ? new : index)\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341629,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n    let newArray = array.map { (element) -> T in\n        if element == old {\n            return new\n        } else {\n            return element\n        }\n    }\n    return newArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341630,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n        var finalResult = array\n        for i in 0..<finalResult.count {\n            if finalResult[i] == old {\n                finalResult[i] = new\n            }\n        }\n        return finalResult\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341631,"user_id":null,"body":"func replaceAll<T: Equatable>(array: [T], old: T, new: T) -> [T] {\n  var returnArray: [T] = []\n  \n  for (_, value) in array.enumerated() {\n      returnArray.append(value == old ? new : value)\n  }\n  \n  return returnArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57c1ab3949324c321600013f":[{"id":341632,"user_id":null,"body":"let dict : [Character : Character] =\n    [   \"A\" : \"@\",\n        \"B\" : \"8\",\n        \"C\" : \"(\",\n        \"E\" : \"3\",\n        \"G\" : \"6\",\n        \"H\" : \"#\",\n        \"I\" : \"!\",\n        \"L\" : \"1\",\n        \"O\" : \"0\",\n        \"S\" : \"$\",\n        \"T\" : \"7\",\n        \"Z\" : \"2\",\n]\n\nfunc toLeetSpeak(_ s : String) -> String {\n  return String(s.map { dict[$0] ?? $0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341633,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n  let alphabet: [Character : Character] = [\n    \"A\" : \"@\",\n    \"B\" : \"8\",\n    \"C\" : \"(\",\n    \"D\" : \"D\",\n    \"E\" : \"3\",\n    \"F\" : \"F\",\n    \"G\" : \"6\",\n    \"H\" : \"#\",\n    \"I\" : \"!\",\n    \"J\" : \"J\",\n    \"K\" : \"K\",\n    \"L\" : \"1\",\n    \"M\" : \"M\",\n    \"N\" : \"N\",\n    \"O\" : \"0\",\n    \"P\" : \"P\",\n    \"Q\" : \"Q\",\n    \"R\" : \"R\",\n    \"S\" : \"$\",\n    \"T\" : \"7\",\n    \"U\" : \"U\",\n    \"V\" : \"V\",\n    \"W\" : \"W\",\n    \"X\" : \"X\",\n    \"Y\" : \"Y\",\n    \"Z\" : \"2\",\n    \" \" : \" \"\n  ]\n  return String(s.map { alphabet[$0]! })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341634,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n  let alphabet = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\n                  \"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\n                  \"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n  let leet = [\"@\",\"8\",\"(\",\"D\",\"3\",\"F\",\"6\",\"#\",\"!\",\"J\",\"K\",\n              \"1\",\"M\",\"N\",\"0\",\"P\",\"Q\",\"R\",\"$\",\"7\",\"U\",\"V\",\n              \"W\",\"X\",\"Y\",\"2\"]\n              \n  var result = s\n  for i in 0..<26 {\n    result = result.replacingOccurrences(of: alphabet[i], with: leet[i])\n  }\n \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341635,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n\/\/ your code\n  var output = \"\"\n  \n  output = s.replacingOccurrences(of:\"A\", with: \"@\")\n  output = output.replacingOccurrences(of:\"B\", with: \"8\")\n  output = output.replacingOccurrences(of:\"C\", with: \"(\")\n  output = output.replacingOccurrences(of:\"E\", with: \"3\")\n  output = output.replacingOccurrences(of:\"G\", with: \"6\")\n  output = output.replacingOccurrences(of:\"H\", with: \"#\")\n  output = output.replacingOccurrences(of:\"I\", with: \"!\")\n  output = output.replacingOccurrences(of:\"L\", with: \"1\")\n  output = output.replacingOccurrences(of:\"O\", with: \"0\")\n  output = output.replacingOccurrences(of:\"S\", with: \"$\")\n  output = output.replacingOccurrences(of:\"T\", with: \"7\")\n  output = output.replacingOccurrences(of:\"Z\", with: \"2\")\n  \n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341636,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n    let alphabet = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n    \n    let leetAlphabet = [\"@\",\"8\",\"(\",\"D\",\"3\",\"F\",\"6\",\"#\",\"!\",\"J\",\"K\",\"1\",\"M\",\"N\",\"0\",\"P\",\"Q\",\"R\",\"$\",\"7\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"2\"]\n    \n    var returnString = \"\"\n    \n    for i in s{\n        if alphabet.contains(String(i)){\n            returnString.append(leetAlphabet[alphabet.firstIndex(of: String(i))!])\n        }else{\n            returnString += String(i)\n        }\n    }\n    \n    return returnString\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341637,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n  let alphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  let leetAlphabet = Array(\"@8(D3F6#!JK1MN0PQR$7UVWXY2\")\n  return String(s.map { c in\n    if let i = alphabet.index(of: c) {\n      return leetAlphabet[i]\n    } else {\n      return c\n    }\n  })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341638,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n  var string = \"\"\n    for i in s {\n        switch i {\n        case \"A\" : string += \"@\"\n        case \"B\" : string += \"8\"\n        case \"C\" : string += \"(\"\n        case \"D\" : string += \"D\"\n        case \"E\" : string += \"3\"\n        case \"F\" : string += \"F\"\n        case \"G\" : string += \"6\"\n        case \"H\" : string += \"#\"\n        case \"I\" : string += \"!\"\n        case \"J\" : string += \"J\"\n        case \"K\" : string += \"K\"\n        case \"L\" : string += \"1\"\n        case \"M\" : string += \"M\"\n        case \"N\" : string += \"N\"\n        case \"O\" : string += \"0\"\n        case \"P\" : string += \"P\"\n        case \"Q\" : string += \"Q\"\n        case \"R\" : string += \"R\"\n        case \"S\" : string += \"$\"\n        case \"T\" : string += \"7\"\n        case \"U\" : string += \"U\"\n        case \"V\" : string += \"V\"\n        case \"W\" : string += \"W\"\n        case \"X\" : string += \"X\"\n        case \"Y\" : string += \"Y\"\n        case \"Z\" : string += \"2\"\n        default: string += String(i)\n        }\n    }\n    return string\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341639,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n\n  var result = \"\"\n    let alphabet: [String: String] = [\n\"A\" : \"@\",\n\"B\" : \"8\",\n\"C\" : \"(\",\n\"D\" : \"D\",\n\"E\" : \"3\",\n\"F\" : \"F\",\n\"G\" : \"6\",\n\"H\" : \"#\",\n\"I\" : \"!\",\n\"J\" : \"J\",\n  \"K\" : \"K\",\n  \"L\" : \"1\",\n  \"M\" : \"M\",\n  \"N\" : \"N\",\n  \"O\" : \"0\",\n  \"P\" : \"P\",\n  \"Q\" : \"Q\",\n  \"R\" : \"R\",\n  \"S\" : \"$\",\n  \"T\" : \"7\",\n  \"U\" : \"U\",\n  \"V\" : \"V\",\n  \"W\" : \"W\",\n  \"X\" : \"X\",\n  \"Y\" : \"Y\",\n  \"Z\" : \"2\",\n  \" \" : \" \"]\n\n    for letter in s{\n        for (original, leet) in alphabet{\n            if (original == String(letter)){\n                result += leet\n            }\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341640,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n  var res: String = \"\"\n  for chr in s\n  {\n    switch chr\n    {\n        case \"A\" : res = res + String(\"@\")\n        case \"B\" : res = res + String(\"8\")\n        case \"C\" : res = res + String(\"(\")\n        case \"D\" : res = res + String(\"D\")\n        case \"E\" : res = res + String(\"3\")\n        case \"F\" : res = res + String(\"F\")\n        case \"G\" : res = res + String(\"6\")\n        case \"H\" : res = res + String(\"#\")\n        case \"I\" : res = res + String(\"!\")\n        case \"J\" : res = res + String(\"J\")\n        case \"K\" : res = res + String(\"K\")\n        case \"L\" : res = res + String(\"1\")\n        case \"M\" : res = res + String(\"M\")\n        case \"N\" : res = res + String(\"N\")\n        case \"O\" : res = res + String(\"0\")\n        case \"P\" : res = res + String(\"P\")\n        case \"Q\" : res = res + String(\"Q\")\n        case \"R\" : res = res + String(\"R\")\n        case \"S\" : res = res + String(\"$\")\n        case \"T\" : res = res + String(\"7\")\n        case \"U\" : res = res + String(\"U\")\n        case \"V\" : res = res + String(\"V\")\n        case \"W\" : res = res + String(\"W\")\n        case \"X\" : res = res + String(\"X\")\n        case \"Y\" : res = res + String(\"Y\")\n        case \"Z\" : res = res + String(\"2\")\n        default: res = res +  String(chr)\n      }\n  }\n  return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341641,"user_id":null,"body":"func toLeetSpeak(_ s : String) -> String {\n  var dict = [ \"A\" : \"@\",\n  \"B\" : \"8\",\n  \"C\" : \"(\",\n  \"D\" : \"D\",\n  \"E\" : \"3\",\n  \"F\" : \"F\",\n  \"G\" : \"6\",\n  \"H\" : \"#\",\n  \"I\" : \"!\",\n  \"J\" : \"J\",\n  \"K\" : \"K\",\n  \"L\" : \"1\",\n  \"M\" : \"M\",\n  \"N\": \"N\",\n  \"O\" : \"0\",\n  \"P\" : \"P\",\n  \"Q\" : \"Q\",\n  \"R\" : \"R\",\n  \"S\" : \"$\",\n  \"T\" : \"7\",\n  \"U\" : \"U\",\n  \"V\" : \"V\",\n  \"W\" : \"W\",\n  \"X\" : \"X\",\n  \"Y\" : \"Y\",\n  \"Z\" : \"2\"]\n  \n  var res = \"\"\n  \n  for char in s {\n    res += dict[String(char)] ?? \" \"\n  }\n  return res\n  }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57cc975ed542d3148f00015b":[{"id":341642,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    return a.contains(x)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341643,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    a.contains(x)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341644,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n  return a.contains(x) ? true : false\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341645,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    let result = a.filter {$0 == x}\n    return !result.isEmpty\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341646,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    return a.contains(where: { $0 == x})\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341647,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    \/\/ Your code here\n    print(x)\n    if a.contains(x){\n        return true\n    }\n    return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341648,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    for i in a {\n      if x == i { return true}\n    }\n    return false\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341649,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    let result = a.index(of: x)\n    return result == nil ? false : true\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341650,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n    return a.map{$0 == x}.reduce(false){ $0 || $1 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341651,"user_id":null,"body":"func solution<T: Equatable>(_ a: [T], _ x: T) -> Bool {\n  for z in a {\n  if z==x\n  {\n  return true\n  }\n  }\n  return false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57cebe1dc6fdc20c57000ac9":[{"id":341652,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{\n  return str.components(separatedBy: \" \").map { $0.count }.min() ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341653,"user_id":null,"body":"func find_short(_ str: String) -> Int { \/\/ OK\n    return str.split(separator: \" \").sorted{ $0.count < $1.count }[0].count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341654,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{ \n  return str.split(separator: \" \").min(by: {$0.count < $1.count})!.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341655,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{\n  return ((str.split(separator:\" \")).map { $0.count }).min() ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341656,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{\n  let words = str.split(separator: \" \")\n  let lengths = words.map { $0.count }\n  return lengths.min()!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341657,"user_id":377,"body":"func find_short(_ str: String) -> Int\n{\n  let words = str.components(separatedBy: \" \")\n  var leastCharacters = 999990\n  for word in words {\n    if word.count < leastCharacters {\n      leastCharacters = word.count\n    }\n  }\n  return leastCharacters\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341658,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{\n  let wordsList = str.components(separatedBy: \" \")\n  var letterCount = [Int]()\n  \n  for word in wordsList {\n    letterCount.append(word.count)\n  }  \n\n  letterCount.sort()\n  \n  return letterCount[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341659,"user_id":null,"body":"func find_short(_ str: String) -> Int {\n  let arrayString = str.split(separator: \" \")\n  guard let min = arrayString.min(by: {$0.count < $1.count}) else { return 0 }\n  return min.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341660,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{\n  let comps = str.components(separatedBy: \" \").sorted{$0.count < $1.count}\n  if comps.count == 0 {\n    return 0\n  }\n  return comps[0].count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341661,"user_id":null,"body":"func find_short(_ str: String) -> Int\n{\n  return str.components(separatedBy: \" \").min(by:{ $0.count < $1.count })!.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57cf3dad05c186ba22000348":[{"id":341662,"user_id":null,"body":"func decodeResistorColors(_ bands: String) -> String {\n    let colors = [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\"]\n    let tolerances = [\"gold\": 5, \"silver\": 10]\n    let names = bands.components(separatedBy: \" \")\n    let digits = names.flatMap(colors.index)\n    let ohms = Double((digits[0] * 10 + digits[1]) * Array(repeating: 10, count: digits[2]).reduce(1, *))\n    let tolerance = (names.count == 4 ? tolerances[names[3]] : nil) ?? 20\n    let (divisor, suffix) = ohms > 999999 ? (1_000_000, \"M\") : ohms > 999 ? (1_000, \"k\") : (1, \"\")\n    let ohmsRounded = String(format: \"%.1f\", ohms \/ Double(divisor)).replacingOccurrences(of: \".0\", with: \"\")\n    return \"\\(ohmsRounded)\\(suffix) ohms, \\(tolerance)%\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341663,"user_id":null,"body":"let colors = [\"black\": 0, \"brown\": 1, \"red\": 2, \"orange\": 3, \"yellow\": 4, \"green\": 5, \"blue\": 6, \"violet\": 7, \"gray\": 8, \"white\": 9, \"gold\": 5, \"silver\": 10]\n\nfunc decodeResistorColors(_ bands: String) -> String {\n    let n = bands.components(separatedBy: \" \").map{ colors[\"\\($0)\"]! }\n    let v = Double(n[0]*10 + n[1]) * pow(10, Double(n[2]))\n    let (value,suffix) = v<1e3 ? (v,\"\") : v<1e6 ? (v\/1e3,\"k\") : (v\/1e6,\"M\")\n    let formatted = value.truncatingRemainder(dividingBy: 1) == 0 ? String(format: \"%.0f\", value) : String(value)\n    let tolerance = n.count > 3 ? n[3] : 20\n    return  \"\\(formatted)\\(suffix) ohms, \\(tolerance)%\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341664,"user_id":null,"body":"func decodeResistorColors(_ bands: String) -> String {\n    let colors = bands.components(separatedBy: \" \")\n    let resistance = Resistance(color1: colors.first!, color2: colors[1], color3: colors[2])\n    var result = resistance.formatted()\n        \n    let tolerance = colors.count > 3 ? Tolerance(color: colors.last) : Tolerance()\n    result.append(tolerance.formatted())\n        \n    return result\n}\n\n enum ColorBand: String {\n        case black\n        case brown\n        case red\n        case orange\n        case yellow\n        case green\n        case blue\n        case violet\n        case gray\n        case white\n        case silver\n        case gold\n\n        var codeString: String {\n            var digit: Int\n\n            switch self {\n            case .black:\n                digit = 0\n            case .brown:\n                digit = 1\n            case .red:\n                digit = 2\n            case .orange:\n                digit = 3\n            case .yellow:\n                digit = 4\n            case .green:\n                digit = 5\n            case .blue:\n                digit = 6\n            case .violet:\n                digit = 7\n            case .gray:\n                digit = 8\n            case .white:\n                digit = 9\n            case .silver:\n                digit = 10\n            case .gold:\n                digit = 5\n            }\n\n            return String(digit)\n        }\n    }\n\n    struct Resistance {\n        let band1: ColorBand\n        let band2: ColorBand\n        let band3: ColorBand\n\n        init(color1: String, color2: String, color3: String) {\n            band1 = ColorBand(rawValue: color1)!\n            band2 = ColorBand(rawValue: color2)!\n            band3 = ColorBand(rawValue: color3)!\n        }\n\n        func formatted() -> String {\n            let resistance = Int(band1.codeString + band2.codeString)! * Int(pow(10.0, Double(band3.codeString)!))\n            return formatNumber(resistance) + \" ohms\"\n        }\n\n        private func formatNumber(_ n: Int) -> String {\n            let million: Double = 1_000_000\n            let thousand: Double = 1_000\n            let num = abs(Double(n))\n            var result = \"\"\n\n            let formatter = NumberFormatter()\n            formatter.minimumFractionDigits = 0\n            formatter.maximumFractionDigits = 1\n            formatter.numberStyle = .decimal\n            \n            if num >= million {\n                let number = NSNumber(floatLiteral: num \/ million)\n                let formatted = formatter.string(from: number)!\n                result = \"\\(formatted)M\"\n            } else if num >= thousand {\n                let number = NSNumber(floatLiteral: num \/ thousand)\n                let formatted = formatter.string(from: number)!\n                result = \"\\(formatted)k\"\n            } else  {\n                result = \"\\(n)\"\n            }\n\n            return result\n        }\n    }\n\n    struct Tolerance {\n        var band: ColorBand?\n\n        init(color: String? = nil) {\n            if let color = color {\n                band = ColorBand(rawValue: color)\n            }\n        }\n\n        func formatted() -> String {\n            var formattedString = \", \"\n\n            if let band = band {\n                formattedString.append(band.codeString)\n            } else {\n                formattedString.append(\"20\")\n            }\n            return formattedString + \"%\"\n        }\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341665,"user_id":null,"body":"func decodeResistorColors(_ bands: String) -> String {\nlet code: [String: Int] = [\"black\": 0, \"brown\": 1, \"red\": 2, \"orange\": 3, \"yellow\": 4, \"green\": 5, \"blue\": 6, \"violet\": 7, \"gray\": 8, \"white\": 9]\nlet arr = bands.split(separator: \" \")\nvar r = Double ((10 * code[String (arr[0])]!) + code[String(arr[1])]!)\nr = r * pow(10.0, Double(code[String(arr[2])]!))\nlet t = arr.count < 4 ? \"20%\" : String(arr[3]) == \"gold\" ? \"5%\" : \"10%\"\nvar q: String = \"\"\nif r < 1000 {\n q = \"\" + String (Int(r))\n} else if Int(r) < 1000000 {\n \n  q = String(format: \"%g\", r \/ 1000) + \"k\"\n} else {\n   q = String(format: \"%g\", r \/ 1000000) + \"M\"\n}\n\nreturn q + \" ohms, \" + t\n \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341666,"user_id":null,"body":"func decodeResistorColors(_ bands: String) -> String {\n    let colorCodes: [String: Int] = [\"black\": 0, \"brown\": 1, \"red\": 2, \"orange\": 3, \"yellow\": 4, \"green\": 5, \"blue\": 6, \"violet\": 7, \"gray\": 8, \"white\": 9]\n    let bands = bands.components(separatedBy: \" \")\n    let values = [colorCodes[bands[0]]!, colorCodes[bands[1]]!]\n    \n    let resistor = Double(\"\\(values[0])\\(values[1])\")!\n    let magnitude = Double(colorCodes[bands[2]]!)\n    let resistance = resistor * pow(10, magnitude)\n    \n    var ohms = \"\"\n    var tolerance = \"20%\"\n    \n    if bands.count > 3 {\n        switch bands[3] {\n        case \"gold\":\n            tolerance = \"5%\"\n        case \"silver\":\n            tolerance = \"10%\"\n        default: break\n        }\n\n    }\n    \n    if resistance < 1000 {\n        ohms = String(format: \"%g\", resistance)\n    } else if resistance >= 1000 && resistance < 1000000 {\n        ohms = String(format: \"%gk\", (resistance \/ 1000))\n    } else {\n        ohms = String(format: \"%gM\", (resistance \/ 1000000))\n    }\n    \n    return \"\\(ohms) ohms, \\(tolerance)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341667,"user_id":null,"body":"import Foundation\n\nenum ResistorColorCode: String {\n    case black, brown, red, orange, yellow, green, blue, violet, gray, white, gold, silver\n    \n    var numericValue: Double {\n        let values = [\"black\": 0.0, \"brown\": 1.0, \"red\": 2.0, \"orange\": 3.0, \"yellow\": 4.0, \"green\": 5.0, \"blue\": 6.0, \"violet\": 7.0, \"gray\": 8.0, \"white\": 9.0, \"gold\": 5.0, \"silver\": 10.0]\n        return values[self.rawValue] ?? -1.0\n    }\n}\n\nstruct Resistor: CustomStringConvertible {\n    let firstColor: ResistorColorCode\n    let secondColor: ResistorColorCode\n    let thirdColor: ResistorColorCode\n    let fourthColor: ResistorColorCode?\n    \n    var ohms: Double {\n        let significand = firstColor.numericValue * 10.0 + secondColor.numericValue\n        let exponent = thirdColor.numericValue\n        return significand * pow(10.0, exponent)\n    }\n    \n   \tvar tolerance: Double {\n        return fourthColor?.numericValue ?? 20.0\n    }\n    \n    var description: String {\n        let valueRepresentation: Double\n        let suffix: String\n        if ohms >= 1_000_000.0 {\n            valueRepresentation = ohms \/ 1_000_000.0\n            suffix = \"M\"\n        } else if ohms >= 1_000.0 {\n            valueRepresentation = ohms \/ 1_000.0\n            suffix = \"k\"\n        } else {\n            valueRepresentation = ohms\n            suffix = \"\"\n        }\n        \n        let stringRepresentation: String\n        if floor(valueRepresentation) == valueRepresentation {\n            stringRepresentation = \"\\(Int(valueRepresentation))\\(suffix) ohms, \\(Int(tolerance))%\"\n        } else {\n            stringRepresentation = \"\\(valueRepresentation)\\(suffix) ohms, \\(Int(tolerance))%\"\n        }\n        \n        return stringRepresentation\n    }\n}\n\nfunc decodeResistorColors(_ bands: String) -> String {\n    let colors = bands.components(separatedBy: \" \")\n    let first = ResistorColorCode(rawValue: colors[0])!\n    let second = ResistorColorCode(rawValue: colors[1])!\n    let third = ResistorColorCode(rawValue: colors[2])!\n    let fourth = colors.count == 4 ? ResistorColorCode(rawValue: colors[3])! : nil\n    \n    let resistor = Resistor(firstColor: first, secondColor: second, thirdColor: third, fourthColor: fourth)\n    \n    return \"\\(resistor)\"\n}\n\nlet r1 = decodeResistorColors(\"yellow violet red gold\")","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341668,"user_id":null,"body":"import Foundation\n\nprotocol Resistor {\n    var firstColor: String { get set }\n    var secondColor: String { get set }\n    var thirdColor: String { get set }\n    var percentage: Int { get set }\n}\n\nclass ResistorColorDecoder: Resistor {\n    private let colors = [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\"]\n    internal var firstColor: String\n    internal var secondColor: String\n    internal var thirdColor: String\n    internal var percentage: Int = 20\n    \n    private var power: Int {\n        return colors.index(of: thirdColor)!\n    }\n    \n    private var poweredValue: Int {\n        var value = 1\n        for _ in 0..<power {\n            value *= 10\n        }\n        return value\n    }\n    \n    private var resistanceValue: Int {\n        return colors.index(of: firstColor)! * 10 + colors.index(of: secondColor)!\n    }\n    \n    private var resistance: Int {\n        return resistanceValue * poweredValue\n    }\n    \n    private var convertedResistance: String {\n        if resistance < 1000 {\n            return \"\\(resistance)\"\n        } else if resistance < 1000000 {\n            let newValue = Double(resistance) \/ 1000.0\n            if resistance % 1000 == 0 {\n                return \"\\(resistance \/ 1000)k\"\n            } else {\n                return \"\\(newValue)k\"\n            }\n        } else {\n            let newValue = Double(resistance) \/ 1000000.0\n            if resistance % 1000000 == 0 {\n                return \"\\(resistance \/ 1000000)M\"\n            } else {\n                return \"\\(newValue)M\"\n            }\n        }\n    }\n    \n    private func isValidColor(first: String, second: String, third: String) -> Bool {\n        let inputColors = [first, second, third]\n        for inputColor in inputColors {\n            guard colors.contains(inputColor) else { return false }\n        }\n        return true\n    }\n    \n    func getDecodedValue() -> String {\n        return \"\\(convertedResistance) ohms, \\(percentage)%\"\n    }\n    \n    init?(first: String, second: String, third: String) {\n        self.firstColor = first\n        self.secondColor = second\n        self.thirdColor = third\n        guard isValidColor(first: first, second: second, third: third) else { return nil }\n    }\n}\n\nclass ResistorColorDecoderExtend: ResistorColorDecoder {\n    private enum AdditionalColors: Int {\n        case gold = 5\n        case silver = 10\n    }\n    \n    private var fourthColor: AdditionalColors\n    \n    init?(first: String, second: String, third: String, fourth: String) {\n        switch fourth {\n        case String(describing: AdditionalColors.gold):\n            self.fourthColor = .gold\n        case String(describing: AdditionalColors.silver):\n            self.fourthColor = .silver\n        default: return nil\n        }\n        super.init(first: first, second: second, third: third)\n        super.percentage = fourthColor.rawValue\n    }\n}\n\nfunc decodeResistorColors(_ bands: String) -> String {\n    \/\/ Do something\n    let components = bands.components(separatedBy: \" \")\n    var ohmValue = \"\"\n    if components.count == 3 {\n        let decoder = ResistorColorDecoder.init(first: components[0], second: components[1], third: components[2])\n        ohmValue = decoder!.getDecodedValue()\n    } else {\n        let decoder = ResistorColorDecoderExtend.init(first: components[0], second: components[1], third: components[2], fourth: components[3])\n        ohmValue = decoder!.getDecodedValue()\n    }\n    return ohmValue\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341669,"user_id":null,"body":"import Foundation\n\nfunc decodeResistorColors(_ bands: String) -> String {\n  let dict = [\"black\": 0, \"brown\": 1, \"red\": 2, \"orange\": 3, \"yellow\": 4, \"green\": 5, \"blue\": 6, \"violet\": 7, \"gray\": 8, \"white\": 9]\n    var colors = bands.split(separator: \" \").map({String($0)})\n    var value = Int(\"\\(dict[colors[0]] ?? 0)\\(dict[colors[1]] ?? 0)\") ?? 0\n    var result: String = \"\"\n   if colors[2] != \"black\" {\n     value = value * Int(pow(10, Double(dict[colors[2]] ?? 0))) ?? 0\n   } \n\n\nif value < 1000 {\n     result = \"\\(value) ohms\"\n} \n\nelse if value >= 1000 && value < 1000000 && value % 1000 != 0 {\n     result = \"\\(Double(value) \/ 1000)k ohms\"\n} \n\nelse if value >= 1000 && value < 1000000 && value % 1000 == 0 {\n     result = \"\\(value \/ 1000)k ohms\"\n} \n\nelse if value >= 1000000 && value % 1000000 != 0{\n     result = \"\\(Double(value) \/ Double(1000000))M ohms\"\n}\n\nelse if value >= 1000000  && value % 1000000 == 0{\n     result = \"\\(value \/ 1000000)M ohms\"\n}\n\n\n    if colors.count <= 3 {\n        return result + \", 20%\"\n    } else if colors[3] == \"gold\" {\n        return result + \", 5%\"\n    } else if colors[3] == \"silver\" {\n        return result + \", 10%\"\n    }\n  \n    return \"0\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341670,"user_id":null,"body":"func reduceZero(toReduce: Double) -> String {\n    String(format: \"%g\", toReduce)\n}\n\nfunc decodeResistorColors(_ bands: String) -> String {\n    let resistorDictionary = [\"black\" : 0, \"brown\" : 1, \"red\" : 2, \"orange\" : 3, \"yellow\" : 4, \"green\" : 5, \"blue\" : 6, \"violet\" : 7, \"gray\" : 8, \"white\" : 9, \"gold\" : 5, \"silver\" : 10]\n    let splittedBands = bands.components(separatedBy: \" \")\n    var returnString = \"\"\n    \n    if let first = resistorDictionary[splittedBands[0]], let second = resistorDictionary[splittedBands[1]], let third = resistorDictionary[splittedBands[2]] {\n        let ohms = \"\\(first)\" + \"\\(second)\"\n        if let intOhms = Double(ohms) {\n            let resultOhms = intOhms * pow(10.0, Double(third))\n            \n            switch resultOhms {\n            case ..<1000:\n                returnString = \"\\(reduceZero(toReduce: resultOhms))\" + \" ohms, \"\n            case 1000..<1000000:\n                returnString = \"\\(reduceZero(toReduce: (resultOhms \/ 1000)))k\" + \" ohms, \"\n            case 1000000...:\n                returnString = \"\\(reduceZero(toReduce: (resultOhms \/ 1000000)))M\" + \" ohms, \"\n            default:\n                returnString = \"\"\n            }\n            \n            if splittedBands.indices.contains(3) {\n                if let fourth = resistorDictionary[splittedBands[3]] {\n                    returnString += \"\\(fourth)%\"\n                }\n            } else {\n                returnString += \"20%\"\n            }\n        }\n    }\n    return returnString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341671,"user_id":null,"body":"func decodeResistorColors(_ bands: String) -> String {\n    func step(_ n:Int) -> Int{\n        if n == 0 {return 1}\n        var sum = 1\n        for _ in 1...n{\n            sum *= 10\n        }\nreturn sum\n    } \n\nlet resistors = [\"black\": \"0\", \n \"brown\": \"1\", \n \"red\": \"2\", \n \"orange\": \"3\",\n \"yellow\": \"4\", \n \"green\": \"5\", \n \"blue\": \"6\", \n \"violet\": \"7\", \n \"gray\": \"8\",\n \"white\": \"9\",\n \"silver\": \"10\",\n \"gold\": \"5\"]\n\n  let array = bands.split(separator: \" \")\n  let sum = Int(resistors[String(array[0])]! + resistors[String(array[1])]!)! * step(Int(resistors[String(array[2])]!)!)\n  let percent = array.count == 4 ? resistors[String(array[3])]! : \"20\"\n  switch sum {\ncase ..<1000:  return \"\\(sum) ohms, \\(percent)%\"\ncase 1000 ..< 1_000_000: if (Float(sum)\/1000) == Float(sum\/1000) {return \"\\(((sum)\/1000))k ohms, \\(percent)%\"} else { return \"\\((Float(sum)\/1000))k ohms, \\(percent)%\" }\ncase 1_000_000... : if (Float(sum)\/1000000) == Float(sum\/1000000) {return \"\\(((sum)\/1000000))M ohms, \\(percent)%\"} else { return \"\\((Float(sum)\/1000000))M ohms, \\(percent)%\"} \ndefault: return \"Error\"\n\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57ea70aa5500adfe8a000110":[{"id":341672,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n    if times == 0 { return arr }\n    let tail = arr.suffix(arr.count\/2).reversed() + [0]\n    let head = arr.prefix((arr.count+1)\/2)\n    let arrBack = zip(head, tail).flatMap { $0.0 + $0.1 }\n    return foldArray(arrBack, times: times-1)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341673,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n  var arr = arr\n  for _ in 0..<times {\n    for i in 0..<(arr.count)\/2 {\n      arr[i] = arr[i]+arr[arr.count-i-1]\n    }\n    arr = Array(arr[0...(arr.count-1)\/2])\n  }\n  return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341674,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n\n    var endArray = arr\n    \n    for _ in 0..<times {\n    for x in 0..<endArray.count\/2 {\n        endArray[x] = endArray[x] + endArray.popLast()!\n    }\n    }\n    return endArray\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341675,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n  let m = arr.count \/ 2\n  let middle = (arr.count & 1 == 1 ? [arr[m]] : [])\n  return times > 0 ? foldArray(zip(arr.prefix(m), arr.suffix(m).reversed()).map({ $0 + $1 }) + middle, times: times - 1) : arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341676,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n    guard times > 0, arr.count > 1 else { return arr }\n    var array = arr\n    var tempArray = [Int]()\n    while array.count > 1 {\n        tempArray.append(array.removeFirst() + array.removeLast())\n    }\n    return foldArray(tempArray + array, times: times - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341677,"user_id":null,"body":" func foldArray(_ arr: [Int], times: Int) -> [Int] {\n        if times == 0 { return arr }\n        return foldArray(fold(arr), times: times - 1)\n  }\n    \n  func fold(_ arr: [Int]) -> [Int] {\n      var doubleQ = arr\n      var foldedArray: [Int] = []\n      while doubleQ.count > 0 {\n        foldedArray.append(doubleQ.removeFirst() + (doubleQ.popLast() ?? 0))\n      }\n      return foldedArray\n  }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341678,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n    var mid = arr.count%2 == 0 ? (arr.count \/ 2) - 1 : arr.count \/ 2, ref = [Int]()\n    for idx in 0...mid {\n        let nxtIdx = (arr.count - 1) - idx\n        ref += [arr[idx] + (nxtIdx == mid ? 0 : arr[nxtIdx])]\n    }\n        \n    return times == 1 ? ref : foldArray(ref, times: times - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341679,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n        var arr1 = arr\n        for i in 0..<times{\n            let middle : Int! = arr1.count\/2\n            \n            if arr1.count % 2 == 0 {\n                arr1 = getbestSolution(middle: middle, arr: arr1)\n            }\n            else {\n                var arr2 = getbestSolution(middle: middle, arr: arr1)\n                arr2.append(arr1[middle])\n                arr1 = arr2\n            }\n        }\n        return(arr1)\n        \n    }\n    \n    func getbestSolution(middle: Int, arr: [Int])-> [Int] {\n        var arr1 = [Int]()\n        var arr2 = [Int]()\n        \n        for i in 0..<middle {\n            let count = arr[arr.count-1 - i]\n            arr1.append(count)\n        }\n        for j in 0..<middle {\n            arr2.append(arr[j])\n        }\n        \n        for i in 0..<arr1.count{\n            arr1[i] += arr2[i]\n        }\n        return arr1\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341680,"user_id":null,"body":"func foldArray(_ arr: [Int], times: Int) -> [Int] {\n    var result = arr\n    var index = 0\n    for _ in 0..<times {\n        while index + 1 < result.count {\n            result[index] += result.popLast() ?? 0\n            index += 1\n        }\n        index = 0\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341681,"user_id":null,"body":"\nfunc foldArray(_ arr: [Int], times: Int) -> [Int] {\n    var newArr: [Int] = []\n    var tempArr: [Int] = []\n    tempArr = arr\n    for _ in 0..<times {\n        newArr = []\n    if tempArr.count%2 == 1 {\n        for i in 0..<tempArr.count\/2 {\n            newArr.append(tempArr[i] + tempArr.reversed()[i])\n        }\n        newArr.append(tempArr[tempArr.count\/2])\n\n    }else if (tempArr.count%2 == 0){\n        for i in 0..<tempArr.count\/2{\n            newArr.append(tempArr[i] + tempArr.reversed()[i])\n        }\n        \n    }\n        tempArr = newArr\n        \n        \n    }\n    return newArr\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57eae65a4321032ce000002d":[{"id":341682,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  \n  return String(digits.map { Int(String($0))! >= 5 ?  \"1\" : \"0\" })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341683,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  return digits.map({ $0 < \"5\" ? \"0\" : \"1\" }).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341684,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n    var bin = \"\"\n    for digit in digits {\n        if Int(\"\\(digit)\")! < 5 {\n            bin += \"0\"\n        } else {\n            bin += \"1\"\n        }\n    }\n    return bin\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341685,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  digits.map { $0 < \"5\" ? \"0\" : \"1\"  }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341686,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n\treturn digits.map({$0 >= \"0\" && $0 <= \"4\" ? \"0\" : \"1\"}).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341687,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  var newString: String = \"\"\n  for char in digits {\n    if let number = Int(String(char)) {\n      if(number < 5) {\n        newString += \"0\"\n      } else {\n        newString += \"1\"\n      }\n    }\n  }\n  \n  return newString\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341688,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  return digits.map { Int(String($0))! < 5 ? \"0\" : \"1\"}.joined()\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341689,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  \/\/your code here\n  digits.map({ $0 < \"5\" ? \"0\" : \"1\" }).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341690,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n    var resultArr = [String]()\n    for item in Array(digits) {\n        if (Int(String(item))! < 5) {\n            resultArr.append(\"0\")\n        } else {\n            resultArr.append(\"1\")\n        }\n    }\n    return resultArr.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341691,"user_id":null,"body":"func fake_bin(digits: String) -> String {\n  \/\/your code here\n  let ints = digits.compactMap{$0.wholeNumberValue ?? 0 < 5 ? 0 : 1}\n  return ints.map{String($0)}.joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57eaeb9578748ff92a000009":[{"id":341692,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n    return arr.reduce(0) { $0 + (Int(\"\\($1)\") ?? 0) }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341693,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n  return arr.map{ $0 as? Int ?? Int($0 as? String ?? \"0\")! }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341694,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n  return arr\n          .compactMap { Int(\"\\($0)\") }\n          .reduce(0,+)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341695,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n  var sum = 0\n  for item in arr {\n    if let test = item as? String {\n      sum += Int(test)!\n    } else {\n      sum += item as! Int\n    }\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341696,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n  var total = 0\n  for i in 0..<arr.count {\n    let str = (\"\\(arr[i])\")\n    total += Int(str)!\n  }\n  return total\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341697,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n    return arr.reduce(0){$0 + (Int(\"\\($1)\") ?? 0)} \/\/ ;)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341698,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n    var sum: Int = 0\n    for item in arr.indices {\n        sum += Int(\"\\(arr[item])\") ?? 0\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341699,"user_id":53,"body":"func sum_mix(_ arr: [Any]) -> Int {\n  return arr.reduce(0, { (($1 as? Int) ?? Int($1 as! String)!) + $0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341700,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n    return arr.reduce(0) { (res, val) in res + Int(\"\\(val)\")! }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341701,"user_id":null,"body":"func sum_mix(_ arr: [Any]) -> Int {\n    return arr.reduce(0) { $0 + Int(\"\\($1)\")! }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57ee99a16c8df7b02d00045f":[{"id":341702,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n  return arr.flatMap{ $0 }.sorted()\n}\n\/\/ That is really much more beautiful than first solution :)","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341703,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n    return arr.flatMap { $0 }.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341704,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n  arr.flatMap { $0 }.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341705,"user_id":527,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n    return arr.joined().sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341706,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n  return arr\n    .flatMap { $0 }\n    .sorted { $0 < $1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341707,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n  \n  var finalArray = [T]()\n  \n  for i in arr {\n    for j in i {\n      finalArray.append(j)\n    }\n  }\n  \n  finalArray = finalArray.sorted(by: <)\n  return finalArray\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341708,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n  var combinedArray = [T]()\n  \n  for array in arr {\n    for value in array {\n      combinedArray.append(value)\n    }\n  }\n  \n  return combinedArray.sorted()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341709,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\nvar flattened = arr.flatMap { $0 }\n flattened.sort()\nreturn flattened\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341710,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n   arr.flatMap{$0}.sorted(by: { $0 < $1 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341711,"user_id":null,"body":"func flattenAndSort<T: Comparable>(_ arr: [[T]]) -> [T] {\n\nvar arrayOfNumbers : [T] = []\n  \nfor (index, item) in arr.enumerated() {\n  for n in item {\n      arrayOfNumbers.append(n)\n    }\n  }\n  \n  return arrayOfNumbers.sorted()\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f36495c0bb25ecf50000e7":[{"id":341712,"user_id":null,"body":"func find(_ n: Int) -> Int {\n  return (0 ... n)\n    .filter { ($0 % 3) * ($0 % 5) == 0 }\n    .reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341713,"user_id":null,"body":"func find(_ n: Int) -> Int {\n\n    \/\/creat a placeholder for the final result\n    var sum = 0\n    \n    \/\/ loop over the entire range\n    for i in 0...n {\n      \n        \/\/ Whenever a multiple of 3 or 5 is found, add it to our placeholder\n        if i%3 == 0 || i%5 == 0 {\n            sum += i\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341714,"user_id":null,"body":"func find(_ n: Int) -> Int {\n    return (0...n).filter{$0 % 3 == 0 || $0 % 5 == 0}.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341715,"user_id":null,"body":"func find(_ n: Int) -> Int {\n    var sum = 0\n    for index in 1...n {\n        if index % 3 == 0 || index % 5 == 0 {\n            sum += index\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341716,"user_id":525,"body":"func find(_ n: Int) -> Int {\n  let c_3 = n \/ 0x3;\n  let c_5 = n \/ 0x5;\n  let c_f = n \/ 0xf;\n  \n  let s_3 = c_3 * (0x3 + c_3 * 0x3) \/ 2;\n  let s_5 = c_5 * (0x5 + c_5 * 0x5) \/ 2;\n  let s_f = c_f * (0xf + c_f * 0xf) \/ 2;\n  \n  return s_3 + s_5 - s_f;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341717,"user_id":null,"body":"func find(_ n: Int) -> Int {\n\treturn (3...n).filter({ $0 % 3 == 0 || $0 % 5 == 0 }).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341718,"user_id":null,"body":"func find(_ n: Int) -> Int {\n  return (0...n).filter { $0.isMultiple(of: 3) || $0.isMultiple(of: 5) }.reduce(.zero, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341719,"user_id":null,"body":"func find(_ n: Int) -> Int {\n  return Array(0...n)\n    .filter { x -> Bool in \n\t\t  let n = x\n\t\t  return (n % 5 == 0) || (n % 3 == 0) \n    }\n    .reduce(0, { $0 + $1 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341720,"user_id":null,"body":"func find(_ n: Int) -> Int {\n    var sum = 0\n    for i in 1...n {\n        if i % 3 == 0 || i % 5 == 0 {\n            sum += i\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341721,"user_id":null,"body":"func find(_ n: Int) -> Int {\n    \/\/ n \/ 3 is the maximum number of multiples of 3 that will be less than n.\n    \/\/ So take every possible multiple of 3 and put them in an array.\n    let threes = Array(1...(n \/ 3))\n        .map { $0 * 3 }\n    \n    \/\/ Same thing for multiples of 5.\n    let fives = Array(1...(n \/ 5))\n        .map { $0 * 5 }\n    \n    \/\/ Create a set out of the concatenated arrays, so that there won't be any duplicates.\n    let multiples = Set(threes + fives)\n    \n    \/\/ Add together all members of the set.\n    let sum = multiples\n        .reduce(0, +)\n    \n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f6ad55cca6e045d2000627":[{"id":341722,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n    return input.map { i in\n        let r = sqrt(Double(i))\n        return r.truncatingRemainder(dividingBy: 1).isZero ? Int(r) : i * i\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341723,"user_id":null,"body":"func square_or_square_root(_ input: [Int]) -> [Int] {\n    \n    var result = [Int]()\n    for item in input {\n        var square = Double(item).squareRoot()\n        if floor(square) == square {\n            result.append(Int(square))\n        } else {\n            result.append(item * item)\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341724,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n    return input.map{\n        let root = (sqrt(Double($0)))\n        return root.truncatingRemainder(dividingBy: 1) == 0 ? Int(root) : $0 * $0\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341725,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n    return input.map{let root = Double($0).squareRoot(); return root.truncatingRemainder(dividingBy: 1) == 0 ? Int(root) : $0*$0}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341726,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n  return input.map { let n = sqrt(Double($0)); return n == Double(Int(n)) ? Int(n) : $0 * $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341727,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n var result: [Int] = []\n            for i in input {\n                if  sqrt(Double(i)).truncatingRemainder(dividingBy: 1) != 0  {\n                    result.append(i*i)\n                } else {\n                     result.append(Int((sqrt(Double(i)))))\n                }\n            }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341728,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n  return input.map({ (x) -> Int in\n      let root = Int(Double(x).squareRoot())\n      return Int(root*root) == x ? root : x*x\n  })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341729,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n  return input.map{\n    let root = Double($0).squareRoot()\n    return Double(Int(root)) == root ? Int(root) : $0 * $0\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341730,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n    return input.map {\n        let r = sqrt(Double($0))\n        return r.truncatingRemainder(dividingBy: 1).isZero ? Int(r) : $0*$0\n    } \/\/ tests ok\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341731,"user_id":null,"body":"import Foundation\n\nfunc square_or_square_root(_ input: [Int]) -> [Int] {\n    return input.map {\n        let root = sqrt(Double($0))\n        return root.truncatingRemainder(dividingBy: 1).isZero ? Int(root) : $0 * $0\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f780909f7e8e3183000078":[{"id":341732,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n  return arr.reduce(1,*)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341733,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n    var product = 1\n    for num in arr {\n        product *= num\n    }\n    return product\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341734,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\narr.reduce(1,*)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341735,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\nlet result = arr.reduce(1,*)\nreturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341736,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n    return arr.reduce(1,*) \/\/ :)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341737,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n  var result: Int = 1\n  for number in arr {\n    result = result * number\n}\nreturn result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341738,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\nreturn arr.reduce(1, { x, y in\nreturn x*y\n})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341739,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n  var int = 1\n  arr.forEach { int *= $0 }\n  return int\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341740,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n\nvar initialValue = arr[0]\nlet size = arr.count\nfor i in 1..<size{\n  initialValue = initialValue * arr[i]\n}\n\nreturn initialValue\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341741,"user_id":null,"body":"func grow(_ arr: [Int]) -> Int {\n    return arr.map{$0}.reduce(1,*)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f781872e3d8ca2a000007e":[{"id":341742,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n\/\/ return a after doubling each array value \nreturn a.map { $0 * 2}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341743,"user_id":527,"body":"func maps(a: Array<Int>) -> Array<Int> {\n    return a.map { $0 * 2 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341744,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n     a.map{$0*2}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341745,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n  var result: [Int] = []\n  for n in a {\n     result.append(n*2)\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341746,"user_id":null,"body":"func maps(a: Array<Int>) -> Array<Int> {\n    return a.map{$0 * 2} \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341747,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n  var b = a;\n  for i in 0 ..< a.count {\n    b[i] = a[i] * 2\n  }\n  return b;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341748,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n    \n    var array = [Int]()\n    \n    for item in a {\n      array.append(item*2)\n    }\n    \n  return array\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341749,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n    return a.map({ (n) -> Int in n * 2 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341750,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n  func mappy (n:Int) -> Int {\n    return n*2\n  }\n  return a.map(mappy)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341751,"user_id":null,"body":"func maps(a : Array<Int>) -> Array<Int> {\n\/\/ write your code here...\n  let newArrUsingMap = a.map { $0 * 2 }\n  return newArrUsingMap\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"57f8ee485cae443c4d000127":[{"id":341752,"user_id":null,"body":"func spacify(_ str: String) -> String {\n  return str.map { String($0) }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341753,"user_id":null,"body":"func spacify(_ str: String) -> String {\n    return str.map { \"\\($0)\" }.joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341754,"user_id":null,"body":"func spacify(_ str: String) -> String {\n  var result:String = \"\"\n  for letter in str {\n    result.append(letter)\n    result.append(\" \")\n  }\n  return String(result.dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341755,"user_id":null,"body":"func spacify(_ str: String) -> String {\n  return String(str.map { \"\\($0) \" }.joined().dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341756,"user_id":null,"body":"func spacify(_ str: String) -> String {\n    return String(str.map({\"\\($0)\" + \" \"}).joined().dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341757,"user_id":null,"body":"func spacify(_ str: String) -> String {\n  var result = Array(str)\n      .enumerated()\n      .map {$0 != str.count - 1 ? \"\\($1) \" : \"\\($1)\"}\n      .joined()\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341758,"user_id":null,"body":"func spacify(_ str: String) -> String {\n    var a = \"\"\n    let b = str.count\n    var c = 0\n    for i in str  {\n            a  += String(i)\n        c += 1\n        if c != b {\n            a += \" \"\n        }\n    }\n    return a\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341759,"user_id":null,"body":"func spacify(_ str: String) -> String {\n    var s = \"\"\n    var arr:[String]=[]\n    for i in str{\n        arr.append(String(i))\n    }\n    for i in 0..<arr.count{\n        if i != arr.count-1{\n            s+=\"\\(arr[i]) \"\n        }else {\n            s+=arr[i]\n        }\n    }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341760,"user_id":null,"body":"func spacify(_ str: String) -> String {\n  return String(String(str.flatMap({ \"\\($0) \"})).dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341761,"user_id":null,"body":"func spacify(_ str: String) -> String {\n    return String(str.map { String($0) + \" \" }.reduce(\"\") { $0 + $1 }.dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58068479c27998b11900056e":[{"id":341762,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n  func replace3with7(_ arr: [Int]) -> [Int]  {\n    return arr.map {\n      let string = \"\\($0)\"\n      return Int(String(string.characters.map {\n        $0 == \"3\" ? \"7\" : $0 == \"7\" ? \"3\" : $0\n      }))!\n    }\n  }\n  return replace3with7(replace3with7(arr).sorted())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341763,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n    return replace37(replace37(arr).sorted())\n}\n\nfunc replace37(_ arr: [Int]) -> [Int] {\n    return arr.map{Int(String($0).replacingOccurrences(of: \"3\", with: \"*\").replacingOccurrences(of: \"7\", with: \"3\").replacingOccurrences(of: \"*\", with: \"7\"))!}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341764,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n    return arr.sorted {\n        let first = Int(String($0).replacingOccurrences(of: \"3\", with: \"_\").replacingOccurrences(of: \"7\", with: \"3\").replacingOccurrences(of: \"_\", with: \"7\"))!\n        let second = Int(String($1).replacingOccurrences(of: \"3\", with: \"_\").replacingOccurrences(of: \"7\", with: \"3\").replacingOccurrences(of: \"_\", with: \"7\"))!\n        return first < second\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341765,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n  let dic: [Character: String] = [\"-\": \"-\", \"0\": \"0\", \"1\": \"1\", \"2\": \"2\", \"3\": \"7\", \"4\": \"4\", \"5\": \"5\", \"6\": \"6\", \"7\": \"3\", \"8\": \"8\", \"9\": \"9\"]\n  return arr.sorted {\n    let a = String($0).map { dic[$0]! }.joined()\n    let b = String($1).map { dic[$0]! }.joined()\n    return Int(a)! < Int(b)!\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341766,"user_id":null,"body":"func digit(_ n: Int) -> Int {\n\tvar num = n\n\tvar res = 0\n\tvar mask = 1\n\twhile num != 0 {\n\t\tvar dig = num % 10\n    switch dig {\n    case 3:\n      dig = 7\n    case 7:\n      dig = 3\n    case -3:\n      dig = -7\n    case -7:\n      dig = -3\n    default:\n      break\n    }\n\n\t\tres += dig * mask\n\t\tnum \/= 10\n\t\tmask *= 10\n\t}\n\treturn res\n}\n\nfunc sortTwisted37(_ arr: [Int]) -> [Int] {\n \treturn arr.sorted(by: { digit($0) < digit($1) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341767,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n  return arr.sorted(by: { twist($0) < twist($1) })\n}\n\nfunc twist(_ num: Int) -> Int {\n    if num == 0 { return 0 }\n    var digit: Int {\n        switch num % 10 {\n        case 3: return 7\n        case 7: return 3\n        case -3: return -7\n        case -7: return -3\n        default: return num % 10\n        }\n    }\n    return (twist(num \/ 10) * 10) + digit\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341768,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n    return twist37(twist37(arr).sorted())\n}\n\nfunc twist37(_ arr: [Int]) -> [Int] {\n    var temp: [[Character]] = arr.map({ [Character](String($0)) })\n    var output: [Int] = []\n\n    for x in temp {\n        var tempX = x.map({ $0 == \"3\" ? \"a\" : $0 })\n        tempX = tempX.map({ $0 == \"7\" ? \"b\" : $0 })\n\n        tempX = tempX.map({ $0 == \"a\" ? \"7\" : $0 })\n        tempX = tempX.map({ $0 == \"b\" ? \"3\" : $0 })\n\n        output.append(Int(String(tempX))!)\n    }\n\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341769,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n    var ansArr: [Int] = []\n    for number in arr {\n        ansArr.append(replace(number: number))\n    }\n    let sortedArray = ansArr.sorted(by: <)\n    ansArr = []\n    for number in sortedArray {\n        ansArr.append(replace(number: number))\n    }\n    return ansArr\n}\n\nfunc replace(number: Int) -> Int {\n    let someString = String(number)\n    var newString = \"\"\n    for character in someString {\n        if character == \"7\" {\n            newString.append(\"3\")\n        } else if character == \"3\" {\n            newString.append(\"7\")\n        } else {newString.append(character)}\n    }\n    guard let answerInt = Int(newString) else { return 0 }\n    return answerInt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341770,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\n    var b = [Int]()\n    var c = [Int]()\n    print(\"a = \\(arr)\") \/\/What we've got\n    for i in arr {\n        if  -13 < i && i < 13 && i != 7 && i != 3 && i != -7 && i != -3 {\n            b.append(i)\n        }\n        if i <= -13 || 13 <= i  {\n            let s = String(i)\n            var res = String()\n            for char in s {\n                if char == \"3\" {\n                    res += \"7\"\n                }\n                if char == \"7\" {\n                    res += \"3\"\n                }\n                if char != \"3\" && char != \"7\" {\n                    res += String(char)\n                }\n            }\n            b.append(Int(res)!)\n        }\n        if i == 3 {\n            b.append(7)\n        }\n        if i == 7 {\n            b.append(3)\n        }\n        if i == -3 {\n            b.append(-7)\n        }\n        if i == -7 {\n            b.append(-3)\n        }\n    }\n    print(\"b = \\(b)\") \/\/Fully twisted. 3 -> 7, -3 -> -7, -17 -> -13 and etc.\n    for i in b.sorted(by: <) {\n        if -13 < i && i < 13 && i != 7 && i != 3 && i != -7 && i != -3 {\n            c.append(i)\n        }\n        if i <= -13 || 13 <= i {\n            let s = String(i)\n            var res = String()\n            for char in s {\n                if char == \"3\" {\n                    res += \"7\"\n                }\n                if char == \"7\" {\n                    res += \"3\"\n                }\n                if char != \"3\" && char != \"7\" {\n                    res += String(char)\n                }\n            }\n            c.append(Int(res)!)\n        }\n        if i == 3 {\n            c.append(7)\n        }\n        if i == 7 {\n            c.append(3)\n        }\n        if i == -3 {\n            c.append(-7)\n        }\n        if i == -7 {\n            c.append(-3)\n        }\n    }\n    print(\"c = \\(c)\") \/\/b - sorted (<) and then twisted 2nd time. Thats it!\n    return c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341771,"user_id":null,"body":"func sortTwisted37(_ arr: [Int]) -> [Int] {\nlet b = arr.sorted { pre, cur in\n        var k1 = 1\n        if pre < 0 {\n            k1 = -1\n        }\n        let p1 = String(pre*k1).map { c -> String in\n            var m1 = c.wholeNumberValue!\n            if m1 == 3 {\n                m1 = 7\n            } else if m1 == 7 {\n                m1 = 3\n            }\n            return \"\\(m1)\"\n        }.joined()\n        \n        var k2 = 1\n        if cur < 0 {\n            k2 = -1\n        }\n        let p2 = String(cur*k2).map { c -> String in\n            var m1 = c.wholeNumberValue!\n            if m1 == 3 {\n                m1 = 7\n            } else if m1 == 7 {\n                m1 = 3\n            }\n            return \"\\(m1)\"\n        }.joined()\n        let pp = Int(p1)! * k1\n        let cc = Int(p2)! * k2\n        \n        return pp < cc\n    }\n    return b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5808dcb8f0ed42ae34000031":[{"id":341772,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\n  return [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][number]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341773,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\n    let array = [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    return array[number]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341774,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\nswitch number {\ncase 0: return \"Zero\"\ncase 1: return \"One\"\ncase 2: return \"Two\"\ncase 3: return \"Three\"\ncase 4: return \"Four\"\ncase 5: return \"Five\"\ncase 6: return \"Six\"\ncase 7: return \"Seven\"\ncase 8: return \"Eight\"\ncase 9: return \"Nine\"\ndefault : return \"Number between 1 and 9\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341775,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\n  \n  switch number {\n  case 0...9: return [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][number]\n  case _: return \"\\(number)\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341776,"user_id":null,"body":"import Foundation \n\nfunc switchItUp(_ number: Int) -> String {\n  let formatter = NumberFormatter()\n  formatter.numberStyle = NumberFormatter.Style.spellOut\n  return formatter.string(from: NSNumber(value: number))!.capitalized\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341777,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\n  switch number {\n     case 9: return \"Nine\"\n     case 8: return \"Eight\"\n     case 7: return \"Seven\"\n     case 6: return \"Six\"\n     case 5: return \"Five\"\n     case 4: return \"Four\"\n     case 3: return \"Three\"\n     case 2: return \"Two\"\n     case 1: return \"One\"\n     default: return \"Zero\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341778,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\n  return NumberFormatter.localizedString(from: number as NSNumber, number: .spellOut).capitalized\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341779,"user_id":null,"body":"func switchItUp(_ number: Int) -> String {\n   let words:[Int: String] = [1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6:\"Six\", 7:\"Seven\", 8:\"Eight\", 9:\"Nine\", 0:\"Zero\"]\n   return words[number]!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341780,"user_id":null,"body":"let switchItUp: (Int) -> String = { [\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"][$0] }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341781,"user_id":null,"body":"let spellNumberformatter: NumberFormatter = {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .spellOut\n    return formatter\n}()\n\nfunc switchItUp(_ number: Int) -> String {\n    return spellNumberformatter.string(for: number)!.capitalized\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"580f1220df91273ee90001e7":[{"id":341782,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n    return zip(a, b).map { String($0.0.hexDigitValue! ^ $0.1.hexDigitValue!, radix: 16) }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341783,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n    return zip(a,b).map { String(Int(String($0), radix: 16)! ^ Int(String($1), radix: 16)!, radix: 16) }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341784,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n  let sharedRange = 0..<min(a.count, b.count)\n    return zip (Array(a)[sharedRange], Array(b)[sharedRange]).map { String($0.0.hexDigitValue! ^ $0.1.hexDigitValue!, radix: 16)\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341785,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n  var xorHex = \"\"\n  for (aHex, bHex) in zip(a, b) {\n    var aBin = String(Int(String(aHex), radix: 16)!, radix: 2)\n    aBin = String(repeating: \"0\", count: 4 - aBin.count) + aBin\n    var bBin = String(Int(String(bHex), radix: 16)!, radix: 2)\n    bBin = String(repeating: \"0\", count: 4 - bBin.count) + bBin\n    let xorBin = zip(aBin, bBin).map{ $0 != $1 ? \"1\" : \"0\" }.joined(separator: \"\")\n    xorHex += String(Int(xorBin, radix: 2)!, radix: 16)\n  }\n\n  return xorHex\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341786,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n  zip(a, b)\n    .map { (Int(\"\\($0.0)\", radix: 16)!, Int(\"\\($0.1)\", radix: 16)!) }\n    .map { $0.0 ^ $0.1 }\n    .map { String(format: \"%x\", $0) }\n    .joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341787,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n  var a = a\n  var b = b\n  if a.count > b.count {\n    a = String(a.prefix(b.count))\n  } else if b.count > a.count {\n    b = String(b.prefix(a.count))\n  }\n  \n  var result = \"\"\n  while a.count > 0 {\n    let hexA = UInt(String(a.removeFirst()), radix: 16)!\n    let hexB = UInt(String(b.removeFirst()), radix: 16)!\n    let xor = hexA ^ hexB\n    result += String(xor, radix: 16)\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341788,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n    let arrA = a.map { String($0) }\n    let arrB = b.map { String($0) }\n    var binaryA = \"\"\n    var binaryB = \"\"\n    for i in arrA {\n        let x = String(Int(i, radix: 16)!, radix: 2)\n        let padding = \"\".padding(toLength: (4 - x.count), withPad: \"0\", startingAt: 0)\n        binaryA += padding + x\n    }\n    for j in arrB {\n        let x = String(Int(j, radix: 16)!, radix: 2)\n        let padding = \"\".padding(toLength: (4 - x.count), withPad: \"0\", startingAt: 0)\n        binaryB += padding + x\n    }\n    var a = binaryA.map { String($0) }\n    var b = binaryB.map { String($0) }\n    let minimum = min(binaryA.count, binaryB.count)\n    var output = \"\"\n    for k in 0..<minimum {\n        if a[k] == b[k] {\n            a[k] = \"0\"\n            b[k] = \"0\"\n        } else {\n            a[k] = \"1\"\n            b[k] = \"1\"\n        }\n    }\n    for l in stride(from: 0, to: minimum, by: 4) {\n        output += String(Int(a[l...l + 3].joined(), radix: 2)!, radix: 16)\n    }\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341789,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n     let m = min(a.count, b.count)\n    let aa = a[..<String.Index(utf16Offset: m, in: a)]\n    let bb = b[..<String.Index(utf16Offset: m, in: b)]\n    let first = stride(from: 0, to: aa.count, by: 2)\n            .map { aa[aa.index(aa.startIndex, offsetBy: $0)..<aa.index(aa.startIndex, offsetBy: min($0 + 2, aa.count))] }\n    \n    let second = stride(from: 0, to: bb.count, by: 2)\n            .map { bb[bb.index(bb.startIndex, offsetBy: $0)..<bb.index(aa.startIndex, offsetBy: min($0 + 2, bb.count))] }\n    \n    return zip(first, second)\n        .map { s1, s2 -> String in\n            let a1 = Int.init(s1, radix: 16)!\n            let b1 = Int.init(s2, radix: 16)!\n            let c = a1^b1\n            return s1.count == 2 ? String(format: \"%02x\", c) : String(format: \"%x\", c)\n        }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341790,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n    return zip(a, b).map { a, b in\n        return (a.isWhitespace ? \"0\" : a, b.isWhitespace ? \"0\" : b)\n    }.compactMap { a, b in\n        return String(format: \"%1x\", a.hexDigitValue! ^ b.hexDigitValue!)\n    }.reduce(\"\", +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341791,"user_id":null,"body":"func fixedXor(_ a: String, _ b: String) -> String {\n    return zip(a, b).reduce(into: \"\") {\n        $0 += String(UInt8(String($1.0), radix: 16)! ^ UInt8(String($1.1), radix: 16)!, radix: 16)\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5813d19765d81c592200001a":[{"id":341792,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  return (start...end).filter { !String($0).contains(\"5\") }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341793,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  var numbersCount = 0\n  \n  for number in start...end {\n      if String(number).contains(\"5\") != true {\n        numbersCount += 1 \n      }\n    }\n    \n    return numbersCount\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341794,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  \/\/ The starting array\n  let arrayOfNumbers = [Int](start...end)\n  \n  \/\/ Taking the absolute value of the starting array to account for potential negative numbers \n  let absArrayOfNumbers = arrayOfNumbers.map { abs($0) }\n  \n  \/\/ Array to hold the final result\n  var finalResult = [Int]()\n  \n  for number in absArrayOfNumbers {\n    \/\/ If a number % 10 == 5 OR a number \/ 10 == 5 then it contains a five \n    \/\/ We want numbers that fit the opposite case e.g. do not contain five\n    if !(number % 10 == 5 || number \/ 10 == 5) {\n      \/\/ If a number passes our filter, add it to our final result array\n      finalResult.append(number)\n    }\n  }\n  \/\/ Return the count of values in the final result array\n  return finalResult.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341795,"user_id":null,"body":"import Foundation\n\nlet dont_give_me_five: (Int, Int) -> Int = {\n    ($0...$1).filter { !\"\\($0)\".contains(\"5\") }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341796,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  return Array(start...end)\n              .map({ String($0)} )\n              .filter({ !$0.contains(\"5\")})\n              .count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341797,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  guard start <= end else {\n    return 0\n  }\n  return (containsFive(number: abs(start)) ? 0 : 1) + dont_give_me_five(start + 1, end)\n}\n\nfunc containsFive(number: Int) -> Bool {\n  guard number != 0 else {\n    return false\n  }\n  \n  let digit = number % 10\n  \n  return digit == 5 || containsFive(number: number \/ 10)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341798,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  var result: [Int] = []\n\n  if end < start {\n    return 0\n  }\n\n  for i in start...end {\n    if hasFive(i) {\n      continue\n    }\n    result.append(i)\n  }\n  \n  return result.count\n}\n\nfunc hasFive(_ number: Int) -> Bool {\n  var value = String(number)\n\n  return value.contains(\"5\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341799,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  return (start...end).map {String($0).contains(\"5\") ? 0 : 1}.reduce(0) {$0 + $1}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341800,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n  Array(start...end).filter { !String($0).contains(\"5\") }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341801,"user_id":null,"body":"func dont_give_me_five(_ start: Int, _ end: Int) -> Int {\n    (start ... end).filter{!\"\\($0)\".contains(\"5\")}.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58184387d14fc32f2b0012b2":[{"id":341802,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  return x\/(sqrt(x+1) + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341803,"user_id":null,"body":"import Foundation\nfunc f(_ x: Double) -> Double {\n    \/\/Tailor's series SUM[(-1)^(n-1) * (2n)!  * x^n \/ (4^n * (n!)^2 * (2n - 1)]\n    var doubleNFact = 2.0 \/\/ doubleNFact = 2n! for n = 1\n    var xN = x \/\/ x^n for n = 1\n    var b = 4.0 \/\/ 4^n for n = 1\n    var c = 1.0 \/\/ n!^2 = c*c for n = 1\n    var result = x \/ 2 \/\/ Sum for n = 0, n = 1 Minus 1\n    for n in 2...10 { \/\/10 steps is sufficient\n        let a1 = pow((-1), Double(n) - 1) \/\/ a1 = (-1)^(n - 1)\n        xN *= x\n        b *= 4\n        c *= Double(n)\n        doubleNFact *= 2 * Double(n) * (2 * Double(n) - 1)\n        let tmp = a1 * doubleNFact * xN \/ (b * c * c * (2 * Double(n) - 1)) \/\/element of Tailor's series for current n\n        result += tmp\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341804,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  return 0.5 * x - 0.25 * pow(x, 2) \/ 2 + 0.375 * pow(x, 3) \/ 6\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341805,"user_id":168,"body":"func f(_ x: Double) -> Double {\n  x \/ (1 + sqrt(1 + x))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341806,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  x \/ 2 - x * x \/ 8 + x * x * x \/ 16\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341807,"user_id":50,"body":"func f(_ x: Double) -> Double {\n  return  x\/(1+sqrt(1+x))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341808,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  return x \/ (1.0 + sqrt(1.0 + x))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341809,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  return x \/ 2 - x * x \/ 8 + x * x * x \/ 16 - 5 * x * x * x * x \/ 128\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341810,"user_id":null,"body":"let f:(Double)->Double={$0\/(1+(1+$0).squareRoot())}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341811,"user_id":null,"body":"func f(_ x: Double) -> Double {\n  return x \/ ((1 + x).squareRoot() + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"581baf45de29fe25a30000e9":[{"id":341812,"user_id":null,"body":"func condense(_ n: Int) -> String {\n    let num = Double(n)\n    for (powNum, suffix) in zip([4.0, 3.0, 2.0, 1.0], [\"t\", \"b\", \"m\", \"k\"]) {\n        let abbreviation = pow(1000.0, powNum)\n        if abs(num) >= abbreviation {\n            return String(format: \"%.1f\", (num \/ abbreviation)) + suffix\n        }\n    }\n    return \"\\(n)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341813,"user_id":null,"body":"enum Suffix: String {\n  case thousand = \"k\"\n  case million = \"m\"\n  case billion = \"b\"\n  case trillion = \"t\"\n  \n  static func fromInt(number: Int) -> Suffix? {\n    if (number >= 1000000000000) {\n      return .trillion\n    } else if (number >= 1000000000) {\n      return .billion\n    } else if (number >= 1000000) {\n      return .million\n    } else if (number >= 1000) {\n      return .thousand\n    } else {\n      return .none\n    }\n  }\n  \n  func condenseNumber(number: Int) -> String {\n    switch self {\n      case .thousand: return String(format: \"%.1f\", Double(number) \/ 1000.0) + self.rawValue\n      case .million: return String(format: \"%.1f\", Double(number) \/ 1000000.0) + self.rawValue\n      case .billion: return String(format: \"%.1f\", Double(number) \/ 1000000000.0) + self.rawValue\n      case .trillion: return String(format: \"%.1f\", Double(number) \/ 1000000000000.0) + self.rawValue\n    }\n  }\n}\n\nfunc condense(_ num: Int) -> String {\n  let suffix = Suffix.fromInt(number: abs(num))\n  return suffix?.condenseNumber(number: num) ?? String(num)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341814,"user_id":676,"body":"import Glibc\n\nfunc condense(_ num: Int) -> String {\n  let x = Double(num)\n  switch floor(log(abs(x))\/log(1000)) {\n    case 1:  return String(format: \"%.1fk\", x\/1e3)\n    case 2:  return String(format: \"%.1fm\", x\/1e6)\n    case 3:  return String(format: \"%.1fb\", x\/1e9)\n    case 4:  return String(format: \"%.1ft\", x\/1e12)\n    default: return String(num)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341815,"user_id":null,"body":"func condense(_ num: Int) -> String {\n    let number = abs(Double(num))\n    let thousand = number \/ 1000\n    let million = number \/ 1000000\n    let billion = number \/ 1000000000\n    let trillion = number \/ 1000000000000\n  var result = \"\"\nif num < 0 {\n  result += \"-\"\n}\n  if trillion >= 1.0 {\n     return result+String(format: \"%.1f\", ((trillion*10)\/10))+\"t\"\n  } else if billion >= 1.0 {\n        return result+String(format: \"%.1f\", ((billion*10)\/10))+\"b\"\n    } else if million >= 1.0 {\n        return result+String(format: \"%.1f\", ((million*10)\/10))+\"m\"\n    } else if thousand >= 1.0 {\n        return result+String(format: \"%.1f\", ((thousand*10\/10)))+\"k\"\n    } else {\n        return result+\"\\(Int(number))\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341816,"user_id":null,"body":"func condense(_ num: Int) -> String {\n\tfunc pow(_ num: Int, _ x: Int) -> Int {\n\t\tvar sum = 1\n\t\tfor _ in 1 ... x {\n\t\t\tsum *= num\n\t\t}\n\t\treturn sum\n\t}\n\tfunc around(_ strNum: String) -> String {\n\t\tvar count = 0\n\t\tif strNum.count % 3 == 0 {\n\t\t\tif strNum.count < 7 {\n\t\t\tcount = strNum.count - (strNum.count \/ 3 + 1)\n\t\t\t} else {\n\t\t\t\tcount = strNum.count - 3\n\t\t\t}\n\t\t} else {\n\t\t\tcount = strNum.count - (strNum.count % 3)\n\t\t}\n\t\tlet doubleNum = Double(strNum)\n\t\tlet integer = pow(10, count)\n\t\tlet final = doubleNum! \/ Double(integer)\n\t\treturn String(format: \"%.1f\", final)\n\t}\n\t\n\tlet stringNumber: String = String(abs(num))\n\t\n\tswitch num {\n\tcase 0 ... 999: return stringNumber\n\tcase -999 ... 0 : return  \"-\" + stringNumber\n\tcase 1_000 ... 999_999: return around(stringNumber) + \"k\"\n\tcase -999_999 ... -1_000: return \"-\" + around(stringNumber) + \"k\"\n\tcase 1_000_000 ... 999_999_999: return around(stringNumber) + \"m\"\n\tcase -999_999_999 ... -1_000_000: return \"-\" + around(stringNumber) + \"m\"\n\tcase 1_000_000_000 ... 999_999_999_999: return around(stringNumber) + \"b\"\n\tcase -999_999_999_999 ... -1_000_000_000: return \"-\" + around(stringNumber) + \"b\"\n\tcase 1_000_000_-000_000 ... 999_999_999_999_999: return around(stringNumber) + \"t\"\n\tcase -999_999_999_999_999 ... -1_000_000_000_000: return \"-\" + around(stringNumber) + \"t\"\n\tdefault:\n\t\treturn stringNumber\n\t}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341817,"user_id":null,"body":"import Foundation\nfunc condense(_ num: Int) -> String {\n  print(num)\n  switch abs(num) {\n    case ..<1000: return \"\\(num)\"\n    case ..<1000000: return \"\\(String(format: \"%.1f\", Double(num) \/ 1000.0))k\"\n    case ..<1000000000: return \"\\(String(format: \"%.1f\", Double(num) \/ 1000000.0))m\"\n    case ..<1000000000000: return \"\\(String(format: \"%.1f\", Double(num) \/ 1000000000.0))b\"\n    default: return \"\\(String(format: \"%.1f\", Double(num) \/ 1000000000000.0))t\"\n  } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341818,"user_id":null,"body":"func condense(_ num: Int) -> String {\n    let n = num < 0 ? -num : num\n    var numStr = String(n)\n    let (dotIndex, tag) = n < 1000000000000 ? n < 1000000000 ? n < 1000000 ? n < 1000 ? (0, \"\") : (-3,\"k\") : (-6,\"m\") : (-9,\"b\") : (-12,\"t\")\n    numStr.insert(\".\", at: numStr.index(numStr.endIndex, offsetBy: dotIndex))\n    return tag == \"\" ? String(num) : num > 0 ? String(format: \"%.1f\", Double(numStr)!) + tag : \"-\" + String(format: \"%.1f\", Double(numStr)!) + tag\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341819,"user_id":null,"body":"func condense(_ num: Int) -> String {\n  if num \/ 1000000000000 != 0 {\n    let number = Double(num) \/ 1000000000000\n    let result = round(number * 10) \/ 10.0\n    return \"\\(result)\" + \"t\"\n  } else if num \/ 1000000000 != 0 {\n    let number = Double(num) \/ 1000000000\n    let result = round(number * 10) \/ 10.0\n    return \"\\(result)\" + \"b\"\n  } else if num \/ 1000000 != 0 {\n    let number = Double(num) \/ 1000000\n    let result = round(number * 10) \/ 10.0\n    return \"\\(result)\" + \"m\"\n  } else if num \/ 1000 != 0 {\n    let number = Double(num) \/ 1000\n    let result = round(number * 10) \/ 10.0\n    return \"\\(result)\" + \"k\"\n  } else {\n    return \"\\(num)\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341820,"user_id":null,"body":"import Foundation\n\nfunc condense(_ num: Int) -> String {\n    switch abs(num) {\n    case 0...999:\n        return String(num)\n    case 1_000...999_999:\n        return String(round(Double(num) \/ 100) \/ 10) + \"k\"\n    case 1_000_000...999_999_999:\n        return String(round(Double(num) \/ 100_000) \/ 10) + \"m\"\n    case 1_000_000_000...999_999_999_999:\n        return String(round(Double(num) \/ 100_000_000) \/ 10) + \"b\"\n    case 1_000_000_000_000...:\n        return String(round(Double(num) \/ 100_000_000_000) \/ 10) + \"t\"\n    default:\n        fatalError(\"something is wrong\")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341821,"user_id":null,"body":"func condense(_ num: Int) -> String {\n    \n    func countResult(_ num: Int, _ dzielnik: Int, _ suffix: String) -> String {\n        let result = String(format: \"%.1f\",( Double(num) \/ Double(dzielnik)) ) + \"\\(suffix)\"\n       \n        return result\n    }\n        \n    if num == 0 {\n        return String(num)\n    } else if num > 0 {\n        switch num {\n        case 1...999:\n            return String(num)\n        case 1_000...999_999:\n            return countResult(Int(Double(num)), 1_000, \"k\")\n        case 1_000_000...999_999_999:\n            return countResult(Int(Double(num)), 1_000_000, \"m\")\n        case 1_000_000_000...999_999_999_999:\n            return countResult(Int(Double(num)), 1_000_000_000, \"b\")\n        default:\n            return countResult(Int(Double(num)), 1_000_000_000_000, \"t\")\n        }\n    } else if num < 0 {\n        switch abs(num) {\n        case 1...999:\n            return String(num)\n        case 1_000...999_999:\n            return countResult(Int(Double(num)), 1_000, \"k\")\n        case 1_000_000...999_999_999:\n            return countResult(Int(Double(num)), 1_000_000, \"m\")\n        case 1_000_000_000...999_999_999_999:\n            return countResult(Int(Double(num)), 1_000_000_000, \"b\")\n        default:\n            return countResult(Int(Double(num)), 1_000_000_000_000, \"t\")\n        }\n    }\n  \n    return \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58223370aef9fc03fd000071":[{"id":341822,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n    let number = number < 0 ? -number : number\n    let stringArray =  String(number).characters.map {Int(String($0))! % 2 == 0 ? \"\\($0)\" : \"-\\($0)-\" }\n    var stringed = stringArray.joined(separator: \"\")\n    if stringed.characters.first == \"-\" { stringed.remove(at: stringed.startIndex) }\n    if stringed.characters.last == \"-\" { stringed = String(stringed.characters.dropLast()) }\n    return stringed.replacingOccurrences(of: \"--\", with: \"-\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341823,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n  return (String(Int(abs(Int32(number))))\n    .characters)\n    .flatMap({Int(String($0))! % 2 == 1 ? \"-\\($0)-\" : \"\\($0)\"})\n    .joined()\n    .replacingOccurrences(of: \"--\", with: \"-\")\n    .trimmingCharacters(in: CharacterSet(charactersIn: \"-\"))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341824,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n        var str = String(number)\n        str = str.replacingOccurrences(of: \"1\", with: \"-1-\")\n        str = str.replacingOccurrences(of: \"3\", with: \"-3-\")\n        str = str.replacingOccurrences(of: \"5\", with: \"-5-\")\n        str = str.replacingOccurrences(of: \"7\", with: \"-7-\")\n        str = str.replacingOccurrences(of: \"9\", with: \"-9-\")\n        str = str.replacingOccurrences(of: \"--\", with: \"-\")\n        \n        return str.trimmingCharacters(in: CharacterSet(charactersIn: \"-\"))\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341825,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n  let characters = String(abs(number)).characters\n  let digits = characters.flatMap { Int(String($0)) }\n  \n  let isOdd = digits.map { $0 % 2 == 1 }\n  let eitherNeighborIsOdd = zip(isOdd, isOdd.dropFirst()).map { $0 || $1 }\n  let dashes = eitherNeighborIsOdd.map { $0 ? \"-\" : \"\" } + [\"\"]\n  \n  return zip(digits.map(String.init), dashes).map(+).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341826,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n    let number = number < 0 ? -number : number\n    var result = \"\"\n\n    String(number).characters.forEach { result += Int(String($0))! & 1 != 0 ? (result.characters.last == \"-\" ? \"\\($0)-\" : \"-\\($0)-\") : String($0) }\n\n    if result.characters.first == \"-\" {\n        result = String(result.characters.dropFirst())\n    }\n\n    if result.characters.last == \"-\" {\n        result = String(result.characters.dropLast())\n    }\n\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341827,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\nreturn \"\\(number)\"\n    .characters\n    .flatMap { Int(\"\\($0)\") }\n    .map { $0 % 2 == 0 ? \"\\($0)\" : \"-\\($0)-\"}\n    .joined()\n    .replacingOccurrences(of: \"--\", with: \"-\")\n    .trimmingCharacters(in: [\"-\"])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341828,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n  return String(abs(number))\n        .map{ $0.wholeNumberValue! % 2 == 0 ? \"\\($0)\" : \"-\\($0)-\"}\n        .joined()\n        .replacingOccurrences(of: \"--\", with: \"-\")\n        .trimmingCharacters(in: [\"-\"])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341829,"user_id":null,"body":"func dashatize(_ number: Int) -> String {      \n    return String(abs(number)).map{ $0.wholeNumberValue! % 2 == 0 ? \"\\($0)\" : \"-\" + \"\\($0)\" + \"-\"}.joined()\n    .replacingOccurrences(of: \"^-|-$|(?<=\\\\W)-(?=\\\\d)\", with: \"\", options: .regularExpression, range: nil)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341830,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n    if number < 10 && -(number) < 10 {\n        return \"\\(number < 0 ? -(number) : number)\"\n    }\n\n    let numberList = \"\\(number)\"\n        .compactMap(\\.wholeNumberValue)\n        .map { $0 < 0 ? -($0) : $0 }\n    var arr = [String]()\n\n    for (_, value) in numberList.enumerated() {\n        \/\/ odd\n        func actAppend(value: Int) {\n            arr.append(\"\\(value)\")\n        }\n        if value % 2 != 0 {\n            actAppend(value: value)\n        }\n        \/\/ even\n        else {\n            if !arr.isEmpty {\n                if Int(arr.last!)! % 2 == 0 {\n                    let str = \"\\(arr.last!)\" + \"\\(value)\"\n                    arr.removeLast()\n                    arr.append(str)\n                } else {\n                    actAppend(value: value)\n                }\n            } else {\n                actAppend(value: value)\n            }\n        }\n    }\n\n    return arr.map { \"\\($0)\" }.joined(separator: \"-\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341831,"user_id":null,"body":"func dashatize(_ number: Int) -> String {\n    let check = number < 0 ? -number : number\n    return \"\\(check)\".compactMap({$0.wholeNumberValue! % 2 == 0 ? \"\\($0)\" : \"-\\($0)-\"})\n        .joined()\n        .replacingOccurrences(of: \"--\", with: \"-\")\n        .trimmingCharacters(in: [\"-\"])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"582c5382f000e535100001a7":[{"id":341832,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n    \/\/TODO: write function that returns linked list from given string\n    if let range = str.range(of: \" -> \") {\n        return Node(Int(str[str.startIndex..<range.lowerBound])!, parse(String(str[range.upperBound..<str.endIndex])))\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341833,"user_id":168,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n  str.components(separatedBy: \" -> \").reversed().dropFirst(1).reduce(nil, {t, x in Node(Int(x)!, t)})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341834,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str: String) -> Node? {\n    createList(from: str.components(separatedBy: \" -> \").compactMap { Int($0) })\n}\n\nfunc createList(from array: [Int]) -> Node? {\n    guard !array.isEmpty else { return nil }\n    \n    return Node(array[0], createList(from: Array(array[1..<array.count])))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341835,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n    let numbers = str.components(separatedBy: \" -> \").compactMap { Int($0) }.reversed()\n    \n    var node: Node?\n  \n    for number in numbers {\n      node = node == nil ? Node(number, nil) : Node(number, node)\n    }\n  \n    return node\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341836,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n    var result: Node? = nil\n    var sepStr: [String] = str.components(separatedBy: \" -> \").reversed()    \n    sepStr.removeFirst()\n    guard sepStr.count > 0 else { return nil }\n    var ints: [Int] = sepStr.compactMap{ Int($0) } \n    result = Node(ints.first!)\n    ints.removeFirst()\n    while ints.count > 0 {\n        result = Node(ints.first!, result)\n        ints.removeFirst()\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341837,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str: String) -> Node? {\n    str\n      .components(separatedBy: \" -> \")\n      .reversed()\n      .reduce(nil) { result, component in\n        guard let number = Int(component) else {\n          return result\n        }\n        return Node(number, result)\n      }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341838,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n    let linked = str\n        .components(separatedBy: \" -> \")\n        .compactMap { Int($0) }\n        .reversed()\n        .reduce(into: (nil as Node?)) { result, itm in\n            if let next =  result {\n                result = Node(itm, next)\n            } else {\n                result = Node(itm)\n            }\n        }\n\n    return linked\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341839,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n  let separator = \" -> \"\n  var strArr = str.components(separatedBy: separator)\n\n  guard !strArr.isEmpty, let firstNum = Int(strArr.removeFirst()) else {\n    return nil\n  }\n  let root = Node(firstNum)\n  var current = root\n  while !strArr.isEmpty {\n    if let num = Int(strArr.removeFirst()) {\n      let new = Node(num)\n      current.next = new\n      current = new      \n    }\n  }\n  return root\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341840,"user_id":null,"body":"import Foundation\n\nfunc parse(_ str:String) -> Node? {\n  guard str != \"nil\" else { return nil }\n  \n  var elements = str.components(separatedBy: \" -> \")\n  elements.reverse()\n  var linkedList = Node( Int(elements[1])! )\n  elements.removeFirst(2)\n  \n  for element in elements {\n    linkedList = Node( Int(element)!, linkedList )\n  }\n  \n  return linkedList\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341841,"user_id":null,"body":"import Foundation\n\nclass LinkedList {\n    var head: Node?\n    var tail: Node?\n    \n    func append(_ data: Int) {\n        let newNode = Node(data)\n        \n        if let tailNode = tail {\n            tailNode.next = newNode\n        } else {\n            head = newNode\n        }\n        \n        tail = newNode\n    }\n    \n}\n\nfunc parse(_ str:String) -> Node? {\n    let linkedList = LinkedList()\n\n    str.components(separatedBy: \" -> \").enumerated().forEach({ (index, value) in\n        guard let data = Int(String(value)) else { return }\n    \n        linkedList.append(data)\n    })\n\n    return linkedList.head\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"583710ccaa6717322c000105":[{"id":341842,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n  return num * (num % 2 == 0 ? 8 : 9)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341843,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n  return num % 2 == 0 ? num * 8 : num * 9\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341844,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n   return num * (num.isMultiple(of: 2) ? 8 : 9)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341845,"user_id":17,"body":"func simple_multiplication(_ n: Int) -> Int {\n  return (n % 2 == 0 ? 8 : 9) * n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341846,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n  num * (num % 2 == 0 ? 8 : 9)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341847,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n  return num * (8 + num & 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341848,"user_id":null,"body":"  func simple_multiplication(_ num: Int) -> Int{\n        return num * (num % 2 + 8)\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341849,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n  let even = num % 2\n  if even == 0 {\n   return num * 8\n  } else {\n    return num * 9\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341850,"user_id":null,"body":"\nfunc simple_multiplication(_ num: Int) -> Int {\n    \n    let a = num\n    let result = a % 2\n    \n    if result == 0 {\n        return a * 8\n    } else {\n        return a * 9\n    }\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341851,"user_id":null,"body":"func simple_multiplication(_ num: Int) -> Int {\n\n    if num % 2 == 0 {\n      return num * 8\n    } else {\n      return num * 9\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5839edaa6754d6fec10000a2":[{"id":341852,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n  for char in chArr {\n    let next = Character(UnicodeScalar(char.asciiValue! + 1))\n    if !chArr.contains(next) { return next }\n  }\n  return Character(\"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341853,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n    let asc = chArr.map { ch in ch.unicodeScalars.first!.value }\n    let missing = zip(asc,asc[1...]).first(where: { $0.1 - $0.0 > 1 })!.0 + 1\n    return String(UnicodeScalar(missing)!).first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341854,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n  let firstChar = chArr[0]\n    let isLowercase = firstChar.isLowercase\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let currentAlphabet = isLowercase ? alphabet : alphabet.uppercased()\n    let arrSize = chArr.count\n    \n    let firstIndex = currentAlphabet.firstIndex(of: firstChar)!\n    let endIndex = currentAlphabet.index(firstIndex, offsetBy: arrSize + 1)\n    let subString = String(currentAlphabet[firstIndex..<endIndex])\n    \n    print(subString)\n    for letter in subString {\n        if !chArr.contains(letter) {\n            return letter\n        }\n    }\n    return chArr[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341855,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n    for i in UnicodeScalar(String(chArr.first!))!.value ... UnicodeScalar(String(chArr.last!))!.value {\n        let currentLetter = Character(UnicodeScalar(i)!)\n        guard chArr.contains(currentLetter) else { return currentLetter }\n    }\n    return \" \"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341856,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n    return (chArr.first!.asciiValue!...chArr.last!.asciiValue!)\n        .map {Character(UnicodeScalar($0))}\n        .filter { !chArr.contains($0) }\n        .first!\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341857,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n  \n  let ascii = chArr.compactMap { $0.asciiValue }\n  \n  for i in 0..<ascii.count - 1 where ascii[i+1] - ascii[i] == 2 {\n    return Character(UnicodeScalar(ascii[i] + 1))\n  }\n  \n  fatalError(\"Incorrect input data\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341858,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n  return Character(UnicodeScalar(chArr.first(where: {!chArr.contains(Character(UnicodeScalar($0.asciiValue! + 1)))})!.asciiValue! + 1))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341859,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n        var result: Character?\n        var alphabet: [Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        \n        for chValue in chArr where !alphabet.contains(chValue) {\n            alphabet = alphabet.map { Character($0.uppercased()) }\n        }\n        \n        for (chValue, alphabetValue) in zip( chArr, Array(alphabet.dropFirst(Int(alphabet.firstIndex(of: chArr.first!)!))) ) where chValue != alphabetValue {\n            result = alphabetValue\n            break\n        }\n        \n        return result!\n    }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341860,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n    \n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    let str = chArr.map{String($0)}.joined().lowercased()\n    let startIndex = alphabet.firstIndex(of: str.first!)!\n    let endIndex = alphabet.firstIndex(of: str.last!)!\n    let sub = alphabet[startIndex...endIndex]\n    \n    let ans = Character(sub.filter { !str.contains($0) })\n    guard chArr.first!.isLowercase else { return Character(ans.uppercased()) }\n    return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341861,"user_id":null,"body":"func find_missing_letter(_ chArr: [Character]) -> Character {\n  let errorCode : Character = \"\\0\"\n    guard !chArr.isEmpty else {\n        return errorCode\n    }\n    guard chArr.count > 1 else {\n        return errorCode\n    }\n    \n    guard chArr.allSatisfy({ $0.isASCII }) else {\n        return errorCode\n    }\n    \n    for index in chArr.indices\n    {\n        guard index != chArr.endIndex - 1 else {\n            return errorCode\n        }\n        \n        let current = chArr[index].asciiValue!\n        let diff = chArr[index.advanced(by: 1)].asciiValue! - current\n        guard diff <= 2 else {\n            return errorCode\n        }\n        \n        if(diff == 2){\n            return Character(Unicode.Scalar(current + 1))\n        }\n        else {\n            continue\n        }\n    }\n    \n    return errorCode\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5842df8ccbd22792a4000245":[{"id":341862,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n    let digits = String(num).characters\n    let maxZeros = digits.count - 1\n    \n    let parts = digits\n        .enumerated()\n        .filter { $0.element != \"0\" }\n        .map { String($0.element) + String(repeating: \"0\", count: maxZeros - $0.offset) }\n    \n    return parts.joined(separator: \" + \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341863,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n    let digits = String(num).characters\n    return digits.enumerated().flatMap { $1 == \"0\" ? nil : \"\\($1)\" + String(repeating: \"0\", count: digits.count - $0 - 1) }.joined(separator: \" + \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341864,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n  \/\/ flatMap to remove nil\n  return String(num).enumerated().flatMap { $1 == \"0\" ? nil : String($1) + String(repeating: \"0\", count: String(num).count - 1 - $0) }.joined(separator: \" + \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341865,"user_id":null,"body":"import Foundation\n\nextension String\n{\n    subscript(_ val: Int) -> String\n    {\n        get\n        {\n            var i = self.startIndex\n            for _ in stride(from: 0, to: val, by: 1)\n            {\n                i = self.index(after: i)\n            }\n            return String(self[i])\n        }\n        set\n        {\n            let original: String = self\n            self = String()\n            for i in stride(from: 0, to: original.count, by: 1)\n            {\n                if i == val\n                {\n                    self += newValue\n                }\n                else\n                {\n                    self += original[i]\n                }\n            }\n        }\n    }\n    \n    mutating func dropLast()\n    {\n        let original: String = self\n        self = String()\n        for i in stride(from: 0, to: original.count - 1, by: 1)\n        {\n            self += original[i]\n        }\n    }\n}\n\nfunc expanded_form(_ num: Int) -> String \n{\n    let strNum = String(num)\n    var answer = String()\n    \n    for i in stride(from: 0, to: strNum.count, by: 1)\n    {\n        if strNum[i] == \"0\"\n        {\n            continue\n        }\n        else\n        {\n            var push = String()\n            push += strNum[i]\n            for _ in stride(from: i + 1, to: strNum.count, by: 1)\n            {\n                push += \"0\"\n            }\n            answer += push\n            answer += \" + \"\n        }\n    }\n    \n    answer.dropLast()\n    answer.dropLast()\n    answer.dropLast()\n    \n    return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341866,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n    let array = String(num).characters.flatMap{ Int(String($0)) }\n    var count = array.count\n    let result = array.map({ (number) -> String in\n        count -= 1\n        return String(number * Int(pow(10.0,Double(count))))\n    }).filter({ $0 != \"0\" }).joined(separator: \" + \")\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341867,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n    var result: [String] = []\n    for (index, char) in String(num).enumerated() {\n        if char != \"0\" {\n            result.append(String(char) + String(repeating: \"0\", count: String(num).count - index - 1))\n        }\n    }\n    return result.joined(separator: \" + \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341868,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n  var result: [String] = []\n  for (index, str) in \"\\(num)\".characters.reversed().enumerated() {\n    let res = (Int(\"\\(str)\") ?? 0) * Int(pow(10.0, Double(index) ?? 0))\n    if res != 0 {\n      result.append(\"\\(res)\")\n    }\n  }\n  return result.reversed().joined(separator: \" + \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341869,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n    return String(num).enumerated().flatMap{ $0.element == \"0\" ? nil : String($0.element) + String(repeating: \"0\", count: String(num).count - $0.offset -  1) }.joined(separator: \" + \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341870,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n    let component = \"\\(num)\".compactMap(\\.wholeNumberValue)\n    var result = [String]()\n\n    for (index, value) in component.enumerated() {\n        var zero: [String] = []\n        for _ in 0..<((component.count - 1) - index) {\n            zero.append(\"0\")\n        }\n        if value != 0 {\n            result.append(\"\\(value)\\(zero.joined())\")\n        }\n    }\n    return result.joined(separator: \" + \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341871,"user_id":null,"body":"func expanded_form(_ num: Int) -> String {\n  let digits = (String(num).compactMap { Int(String($0)) })\n      \n  let expandedString = digits.enumerated().reduce(\"\") { (result, item) -> String in  \n    var string = result\n    string.append(item.0 == 0 ? \"\" : \" + \")                              \n    if item.1 == 0 { return result }            \n    string.append(\"\\(item.1 * Int(pow(Double(10), Double((digits.count - item.0 - 1)))))\")\n    return string                                                                            \n  }\n    \n  return expandedString\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5848565e273af816fb000449":[{"id":341872,"user_id":null,"body":"func encrypt_this(text:String) -> String {\n    return text\n        .components(separatedBy: \" \")\n        .map {\n            var a = $0.map { String($0) }\n            a[0] = String(a[0].unicodeScalars.first!.value)\n            \n            if a.count > 2 {\n                a.swapAt(1, a.count-1)\n            }\n            \n            return a.joined()\n        }\n        .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341873,"user_id":null,"body":"func encrypt_this(text:String) -> String{\n    var encryptedArray:[[String]] = text.components(separatedBy: \" \").map{$0.flatMap{String($0)}}\n    for (index,element) in encryptedArray.enumerated(){\n        encryptedArray[index][0] = String(element[0].unicodeScalars.first!.value)\n        if element.count >= 3 {\n            let tempSecond = element[1]\n            encryptedArray[index][1] = element.last!\n            encryptedArray[index][element.count - 1] = tempSecond\n        }\n        encryptedArray[index].append(\" \")\n        \n    }\n    return String(encryptedArray.joined().joined().dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341874,"user_id":null,"body":"func encrypt_this(text: String) -> String {\n    text.split(separator: \" \").map {\n                let first = String($0.first?.asciiValue ?? 0)\n                if $0.count == 1 {\n                    return first\n                }\n                let second = $0[$0.index(after: $0.startIndex)]\n                if $0.count == 2 {\n                    return \"\\(first)\\(second)\"\n                }\n                let last = $0.last ?? Character(\"\")\n                if $0.count == 3 {\n                    return \"\\(first)\\(last)\\(second)\"\n                }\n                let mid = $0[$0.index($0.startIndex, offsetBy: 2)..<$0.index(before: $0.endIndex)]\n                return \"\\(first)\\(last)\\(mid)\\(second)\"\n            }\n            .joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341875,"user_id":null,"body":"func cryptWord(_ t:String) -> String {\n    if t.isEmpty == true {\n    return \"\"\n    }\n    var res: [String] = []\n    t.forEach( { res.append(\"\\($0)\") })\n    res[0] = \"\\(Character(res[0]).asciiValue!)\"\n    if res.count > 2 {\n        res.swapAt(1, res.count - 1)\n    }\n    return res.joined(separator: \"\")\n}\n\nfunc encrypt_this(text:String) -> String{\n    text.split(separator: \" \").map( { cryptWord(String($0)) }).joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341876,"user_id":null,"body":"import Foundation\n\nextension String {\n\n    var length: Int {\n        return count\n    }\n\n    subscript (i: Int) -> String {\n        return self[i ..< i + 1]\n    }\n\n    func substring(fromIndex: Int) -> String {\n        return self[min(fromIndex, length) ..< length]\n    }\n\n    func substring(toIndex: Int) -> String {\n        return self[0 ..< max(0, toIndex)]\n    }\n\n    subscript (r: Range<Int>) -> String {\n        let range = Range(uncheckedBounds: (lower: max(0, min(length, r.lowerBound)),\n                                            upper: min(length, max(0, r.upperBound))))\n        let start = index(startIndex, offsetBy: range.lowerBound)\n        let end = index(start, offsetBy: range.upperBound - range.lowerBound)\n        return String(self[start ..< end])\n    }\n}\n\nfunc encrypt_this(text:String) -> String{\n  let fullNameArr = text.components(separatedBy: \" \")\n  var result: [String] = []\n  var nw = \"\"\n  for word in fullNameArr {\n    nw = \"\"\n    var sl = word[word.startIndex]\n    nw += String(UnicodeScalar(String(sl))!.value)\n    if word.count > 2 {\n      nw += word.suffix(1)\n      nw += word[2..<word.count-1]\n      nw += word[1]\n    }\n    if word.count == 2 {\n      nw += word[1]\n    }\n    result.append(String(nw))\n  }\n  return result.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341877,"user_id":null,"body":"func encrypt_this(text:String) -> String{\n  var result = [String]()\n  for word in text.split(separator: \" \"){\n    var element = word.map{String($0)}\n    if element.count > 1 {element.swapAt(1, element.count - 1)}\n    element[0] = String(element[0].unicodeScalars.first!.value)\n    result.append(element.joined())\n  }\n  return result.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341878,"user_id":null,"body":"func encrypt_this(text:String) -> String{\n    return text.split(separator: \" \").map { word in\n        var array = word.map { String($0) }\n        if array.count > 1 {\n            array.swapAt(1, array.count - 1)\n        }\n        array[0] = String(Character(array[0]).asciiValue!)\n        return array.joined()\n    }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341879,"user_id":null,"body":"func encrypt_this(text:String) -> String{\n    \n    var words = text.components(separatedBy: \" \")\n    \n    for (i,word) in words.enumerated() {\n        var letters = Array(word.dropFirst())\n        if letters.count > 1 {\n            letters.swapAt(letters.startIndex, letters.endIndex - 1)\n        }\n        words[i] = String(word.first!.asciiValue!) + String(letters)\n    }\n    return words.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341880,"user_id":null,"body":"func encrypt_this(text:String) -> String{\n  if text.isEmpty { return \"\" }\n  \n  var res : [String] = []\n  \n  for word in text.split(separator: \" \") {\n    var arr = Array(word).map{String($0)}\n    let first = String(Character(arr.removeFirst()).asciiValue!)\n    let rest = arr.isEmpty ? \"\" : arr.count == 1 ? arr[0] : arr.last! + arr[1..<(arr.count - 1)].joined() + arr[0]\n    res.append(first + rest)\n  }\n  return res.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341881,"user_id":null,"body":"func encrypt_this(text:String) -> String{\n    let input = text.split(separator: \" \")\n    var output : [String] = []\n    for word in input {\n        var encrypted = String()\n        for index in word.indices {\n            switch index\n            {\n            case word.startIndex : encrypted.append(String(word[word.startIndex].asciiValue!))\n            case word.index(after: word.startIndex) : \n                if word.count > 2 {\n                    encrypted.append(word[word.index(before: word.endIndex)])\n                }\n                else {\n                    encrypted.append(word[index])\n                }\n            case word.index(before: word.endIndex) :\n                encrypted.append(word[word.index(after: word.startIndex)])\n            default:\n                encrypted.append(word[index])\n            }\n        }\n        output.append(encrypted)\n    }\n    \n    return  output.joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58485a43d750d23bad0000e6":[{"id":341882,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n    let components = time.components(separatedBy: \":\")\n    let minute = Int(components[1])!\n    if [0, 30].contains(minute) {\n        let hour = Int(components[0])!\n        let count = minute == 30 ? 1 : (hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour))\n        return (0..<count).map({ _ in \"Cuckoo\" }).joined(separator: \" \")\n    } else {\n        let buffer = [(3, \"Fizz\"), (5, \"Buzz\")].flatMap({ minute % $0 == 0 ? $1 : nil })\n        return buffer.isEmpty ? \"tick\" : buffer.joined(separator: \" \")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341883,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n    \n    var t = time.split(separator: \":\").map{Int($0)!}\n    let (h, m) = ((t[0]+11)%12+1, t[1])\n    \n    return m == 0 ? Array(repeating: \"Cuckoo\", count: h).joined(separator: \" \")\n         : m == 30 ? \"Cuckoo\"\n         : m % 3 == 0 && m % 5 == 0 ? \"Fizz Buzz\"\n         : m % 3 == 0 ? \"Fizz\"\n         : m % 5 == 0 ? \"Buzz\"\n         : \"tick\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341884,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n\n    let a = time.components(separatedBy: \":\")\n    \n    guard let hrs = Int(a[0]), let min = Int(a[1]) else { return \"tick\" }\n\n    switch min\n    {    \n        case 0:\n            return Array(repeating: \"Cuckoo\", count: (hrs+11)%12+1 ).joined(separator: \" \")\n            \n        case 30:\n            return \"Cuckoo\"\n            \n        case let x where x % 15 == 0:\n            return \"Fizz Buzz\"\n            \n        case let x where x % 3 == 0:\n            return \"Fizz\"\n            \n        case let x where x % 5 == 0:\n            return \"Buzz\"\n            \n        default:\n            return \"tick\"\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341885,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n    let a = time.components(separatedBy: \":\")\n    if a[1] == \"30\" {return \"Cuckoo\"}\n    if a[1] == \"00\" {\n        if a[0] == \"00\" { return Array.init(repeating: \"Cuckoo\", count: 12).joined(separator: \" \") }\n        let hr = Int(a[0])!\n        return Array.init(repeating: \"Cuckoo\", count: (hr <= 12 ? hr : hr - 12)).joined(separator: \" \")\n    }\n    if Int(a[1])! % 3 == 0 {\n        if Int(a[1])! % 5 == 0 { return \"Fizz Buzz\" }\n        return \"Fizz\"\n    }\n    if Int(a[1])! % 5 == 0 { return \"Buzz\" }\n    return \"tick\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341886,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n\n    let hours = Int(time.split(separator: \":\")[0])!\n    let minutes = Int(time.split(separator: \":\")[1])!\n    if minutes == 30 { return(\"Cuckoo\") }\n    if minutes == 0 { return(String(String(repeating: \"Cuckoo \", count: hours == 0 ? 12 : ( hours > 12 ? hours-12 : hours)).dropLast())) }\n    return minutes % 3 == 0 ? ( minutes % 5 == 0 ? \"Fizz Buzz\" : \"Fizz\" ) : ( minutes % 5 == 0 ? \"Buzz\" : \"tick\" )\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341887,"user_id":null,"body":"\nfunc fizzBuzzCuckooClock(_ time: String) -> String {\n    let formatted = time.components(separatedBy: \":\")\n    \n    if formatted[1] == \"00\" {\n        return Array(repeating: \"Cuckoo\", count: Int(formatted[0])! % 12 != 0 ? Int(formatted[0])! % 12 : 12).joined(separator: \" \")\n    } else if formatted[1] == \"30\" {\n        return \"Cuckoo\"\n    } else if formatted[1] == \"15\" || formatted[1] == \"45\" {\n        return \"Fizz Buzz\"\n    } else if Int(formatted[1])! % 3 == 0 {\n        return \"Fizz\"\n    } else if Int(formatted[1])! % 5 == 0 {\n        return \"Buzz\"\n    }\n    \n    return \"tick\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341888,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n  let hourMin = time.split(separator: \":\")\n  let hour = Int(hourMin[0]) ?? 0\n  let min = Int(hourMin[1]) ?? 0\n  \n  if min == 0 {\n    if hour == 0 || hour == 12 {\n      return String(String(repeating: \"Cuckoo \", count: 12).dropLast())\n    } else {\n      return String(String(repeating: \"Cuckoo \", count: hour % 12).dropLast())\n    }\n  } else if min == 30 {\n    return \"Cuckoo\" \n  } else if min % 15 == 0 {\n    return \"Fizz Buzz\"\n  } else if min % 5 == 0 {\n    return \"Buzz\" \n  } else if min % 3 == 0 {\n    return \"Fizz\"\n  } else { return \"tick\" }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341889,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n    let fizz = \"Fizz\", buzz = \"Buzz\", tick = \"tick\", cuckoo = \"Cuckoo\"\n    let currentTime = time.components(separatedBy: \":\")\n    \n    guard let hourString = currentTime.first, var hour = Int(hourString),\n          let minuteString = currentTime.last, let minute = Int(minuteString) else { return \"Faile\" }\n        \n    hour = hour == 0 ? 12 : hour > 12 ? hour - 12 : hour\n    \n    switch minute {\n    case 0: return Array(repeating: cuckoo, count: hour).joined(separator: \" \")\n    case 30: return cuckoo\n    case let (m) where m % 3 == 0 && m % 5 == 0: return fizz + \" \" + buzz\n    case let (m) where m % 3 == 0: return fizz\n    case let (m) where m % 5 == 0: return buzz\n    default: return tick\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341890,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n    let timeArray=time.split(separator: \":\").compactMap({Int($0)})\n    let hour=timeArray[0]==0 ? 12:timeArray[0]\n    let minutes=timeArray[1]\n    var result:String=\"\"\n    guard minutes != 30 else {\n        return \"Cuckoo\"\n    }\n    guard minutes != 0 else {\n        return Array(repeating: \"Cuckoo\", count: hour>12 ? hour-12:hour ).joined(separator: \" \")\n    }\n    switch true {\n    case minutes%3==0 && minutes%5==0:\n        result=\"Fizz Buzz\"\n    case minutes%3 != 0 && minutes%5 != 0:\n        result=\"tick\"\n    case minutes%3==0:\n        result=\"Fizz\"\n    case minutes%5==0:\n        result=\"Buzz\"\n    default:\n        break\n    }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341891,"user_id":null,"body":"func fizzBuzzCuckooClock(_ time: String) -> String {\n       let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"HH:mm\"\n        let date = dateFormatter.date(from: time)\n        dateFormatter.dateFormat = \"h:mm\"\n        let date12 = dateFormatter.string(from: date!)\n        \n        let array = date12.components(separatedBy: \":\")\n        let hour = Int(array.first!)\n        let minute = Int(array.last!)\n        \n        let cuckoo = \"Cuckoo\"\n        var cuckooWords = [String]()\n        \n        if minute == 0 {\n            cuckooWords = Array(repeating: cuckoo, count: hour!)\n        }\n        else if minute == 30 {\n            cuckooWords.append(cuckoo)\n        }\n        else {\n            if minute! % 3 == 0 { cuckooWords.append(\"Fizz\") }\n            if minute! % 5 == 0 { cuckooWords.append(\"Buzz\") }\n        }\n        \n        if cuckooWords.isEmpty {\n            return \"tick\"\n        } else {\n            return cuckooWords.joined(separator: \" \")\n        }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5853213063adbd1b9b0000be":[{"id":341892,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    let width = fighters.first?.count ?? 0, height = fighters.count\n    var position = position\n    \n    return moves.map { move in\n        switch move {\n        case .up: if position.row != 0 { position.row -= 1 }\n        case .down: if position.row != height - 1 { position.row += 1 }\n        case .left: position.column = (position.column + width - 1) % width\n        case .right: position.column = (position.column + 1) % width\n        }\n        \n        return fighters[position.row][position.column]\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341893,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  var result: [String] = []\n  var row = position.row\n  var column = position.column\n  \n  for move in moves {\n    switch move {\n    case .up:\n      row = row == 1 ? 0 : 0\n    case .down:\n      row = row == 0 ? 1 : 1\n    case .left:\n      column = column == 0 ? fighters[0].count - 1 : column - 1\n    case .right:\n      column = column == fighters[0].count - 1 ? 0 : column + 1\n    }\n    \n    result.append(fighters[row][column])\n  }\n  \n  return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341894,"user_id":53,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  var row = position.row\n  var col = position.column\n  return moves.reduce(into: [], { acc, n in\n    row = (row == 0 && n == Direction.down) ? 1 : (row == 1 && n == Direction.up) ? 0 : row\n    col = ((col + (n == Direction.left ? -1 : n == Direction.right ? 1 : 0)) + 6) % 6\n    acc.append(fighters[row][col])\n  })\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341895,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    var player = [String](), x = position.column, y = position.row\n    \n    for direction in moves {\n        switch direction {\n        case .up: y = 0\n        case .down: y = 1\n        case .left: x = (x + 5) % 6\n        default: x = (x + 1) % 6\n        }\n        player += [fighters[y][x]]\n    }\n    \n    return player\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341896,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \/\/ Direction enum values are .up, .down, .left, and .right\n  \/\/ Do something\n  var position = position\n  return moves.map { move in\n    switch move {\n      case .up: position.row = position.row == 1 ? 0 : 0\n      case .down: position.row = position.row == 0 ? 1 : 1\n      case .left: position.column = position.column != 0 ? position.column - 1 : 5\n      case .right: position.column = position.column != 5 ? position.column + 1 : 0\n    }\n    return fighters[position.row][position.column]\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341897,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    var selectedFighters: [String] = [String]()\n    var lastPosition = position\n    var isMoved = false\n    for move in moves {\n        isMoved = false\n        print(\"move: \\(move)\\tPsition: \\(lastPosition)\")\n        switch move {\n        case .up:\n            if lastPosition.row != 0 {\n                lastPosition.row -= 1\n            }\n            isMoved = true\n        case .down:\n            if lastPosition.row != fighters.count - 1 {\n                lastPosition.row += 1\n            }\n            isMoved = true\n        case .left:\n            if lastPosition.column != 0 {\n                lastPosition.column -= 1\n                isMoved = true\n            } else {\n                lastPosition.column = fighters[lastPosition.row].count - 1\n                isMoved = true\n            }\n        case .right:\n            if lastPosition.column != fighters[lastPosition.row].count - 1 {\n                lastPosition.column += 1\n                isMoved = true\n            } else {\n                lastPosition.column = 0\n                isMoved = true\n            }\n        }\n        print(lastPosition)\n        if isMoved {\n            selectedFighters.append(fighters[lastPosition.row][lastPosition.column])\n        }\n    }\n    return selectedFighters\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341898,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  var characters : [String] = []\n  var currentPosition : (row: Int, column: Int) = position\n\n  for move in moves {\n      switch move {\n       case .up:\n          if currentPosition.row == 1 {\n            currentPosition = (row: currentPosition.row - 1, column: currentPosition.column)\n          }\n        case .down:\n           if currentPosition.row == 0 {\n            currentPosition = (row: currentPosition.row + 1, column: currentPosition.column)\n          }\n        case .left:\n          if currentPosition.column == 0 {\n            currentPosition = (row: currentPosition.row, column: 5)\n          } else {\n            currentPosition = (row: currentPosition.row, column: currentPosition.column - 1)\n          }\n        case .right:\n          if currentPosition.column == 5 {\n              currentPosition = (row: currentPosition.row, column: 0)\n            } else {\n              currentPosition = (row: currentPosition.row, column: currentPosition.column + 1)\n            }\n       }\n      characters.append(fighters[currentPosition.row][currentPosition.column])\n  }\n  return characters\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341899,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    var hoveredCharacters = [String]()\n    var position = position\n    \n    for move in moves {\n        switch move {\n        case .up:\n            if position.row != 0 { position.row -= 1 }\n        case .down:\n            if position.row != (fighters.count - 1) { position.row += 1 }\n        case .left:\n            if position.column != 0 { position.column -= 1 } else { position.column = (fighters[0].count - 1) }\n        case .right:\n            if position.column != (fighters[0].count - 1) { position.column += 1 } else { position.column = 0 }\n        }\n        \n        hoveredCharacters.append(fighters[position.row][position.column])\n    }\n    \n    \n    return hoveredCharacters\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341900,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \/\/ Direction enum values are .up, .down, .left, and .right\n  \n  var selections = [String]()\n  var pos = position\n  \n  for move in moves {\n    switch (move) {\n    case .left:\n      pos.column = ( pos.column == 0 ? fighters[pos.row].count - 1 : pos.column - 1 )\n    case .right:\n      pos.column = ( pos.column == fighters[pos.row].count - 1 ? 0 : pos.column + 1 )\n    case .up:\n      pos.row = 0\n    case .down:\n      pos.row = 1\n    }\n    selections.append(fighters[pos.row][pos.column])\n  }\n  \n  return selections\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341901,"user_id":null,"body":"func streetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \/\/ Direction enum values are .up, .down, .left, and .right\n  \/\/ Do something\n  \n  var output = [String]()\n  var newPosition = position\n  \n  let minRow = 0\n  let maxRow = fighters.count - 1\n  \n  let minColumn = 0\n  let maxColumn = fighters.first!.count - 1\n  \n  for move in moves {\n  \n    switch move {\n    case .up:\n      newPosition.row = max(minRow, newPosition.row-1)\n    case .down:\n      newPosition.row = min(maxRow, newPosition.row+1)\n    case .left:\n      newPosition.column = (newPosition.column == minColumn ? maxColumn : newPosition.column - 1)\n    case .right:\n      newPosition.column = (newPosition.column == maxColumn ? minColumn : newPosition.column + 1)\n    }\n    \n    let figther = fighters[newPosition.row][newPosition.column]\n    output.append(figther)\n  }  \n  \n  return output\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5855777bb45c01bada0002ac":[{"id":341902,"user_id":null,"body":"func encodeResistorColors(_ ohmsString: String) -> String {\n    let resistorColors = [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\"]\n    let range = NSRange(location: 0, length: ohmsString.count)\n    let regex = try! NSRegularExpression(pattern: \"([0-9,.]+)|(M)|(k)\")\n    let results = regex.matches(in: ohmsString, options: [], range: range).map { String(ohmsString[Range($0.range, in: ohmsString)!]) }\n    \n    var factor = 1\n    \n    if results.count > 1 {\n        switch results.last! {\n            case \"k\": factor = 1000\n            case \"M\": factor = 1_000_000\n            default: break\n        }\n    }\n    \n    let multipliedNumber = Double(results[0]) != nil ? String((Int(Double(results[0])! * 10) * factor) \/ 10) : String(Int(results[0])! * factor)\n    let numberColors = multipliedNumber\n        .enumerated()\n        .compactMap { return $0.offset <= 1 ? resistorColors[$0.element.wholeNumberValue!] : \"\" }\n        .filter { $0 != \"\" }\n\n    return \"\\(numberColors.joined(separator: \" \")) \\(resistorColors[multipliedNumber.count - numberColors.count]) gold\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341903,"user_id":null,"body":"func encodeResistorColors(_ s: String) -> String {\n    let data = [\"0\": \"black\", \"1\": \"brown\", \"2\": \"red\", \"3\": \"orange\", \"4\": \"yellow\", \"5\": \"green\", \"6\": \"blue\", \"7\": \"violet\", \"8\": \"gray\", \"9\": \"white\"]\n    let suffixData = [\"k\": 3.0, \"M\": 6.0, \"b\": 9.0]\n    let str = s.components(separatedBy: \" \").first!\n    var ohmValue = 0\n    if str.lastStr().isLetter() {\n        let powNum = suffixData[str.lastStr()]!\n        ohmValue = Int(Double(str.deleteLast())! * pow(10.0, powNum))\n    } else {\n        ohmValue = Int(str)!\n    }\n    var colorString = \"\"\n    colorString += data[\"\\(ohmValue)\".string(at: 0)]! + \" \"\n    colorString += data[\"\\(ohmValue)\".string(at: 1)]! + \" \"\n    let lastColorNum = \"\\(ohmValue)\".count - 2\n    colorString += data[\"\\(lastColorNum)\"]! + \" gold\"\n    return colorString\n}\n\nextension String {\n    var count: Int {\n        return self.characters.count\n    }\n    func lastStr() -> String {\n        return self.substring(from: index(endIndex, offsetBy: -1))\n    }\n\n    func deleteLast() -> String {\n        return self.substring(to: index(endIndex, offsetBy: -1))\n    }\n\n    func string(at n: Int) -> String {\n        return self.characters.map({String($0)})[n]\n    }\n\n    func isLetter() -> Bool {\n        return CharacterSet.letters.contains(self.unicodeScalars.first!)\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341904,"user_id":null,"body":"func encodeResistorColors(_ ohmsString: String) -> String {\n  let colors = [\n    \"black\",\n    \"brown\",\n    \"red\",\n    \"orange\",\n    \"yellow\",\n    \"green\",\n    \"blue\",\n    \"violet\",\n    \"gray\",\n    \"white\"\n  ]\n  \n  var num = ohmsString.components(separatedBy: \" \")[0]\n  let mult = (num.last == \"k\" || num.last == \"M\")\n  let numStr = (mult ? String(num.dropLast()) : num)\n  \n  guard var val = Double(numStr) else { abort() }\n  if num.last == \"k\" {\n    val *= 1000\n  }\n  if num.last == \"M\" {\n    val *= 1000000\n  }\n  \n  num = \"\\(Int(val))\"\n  guard let a = Int(String(num.prefix(1))) else { abort() }\n  guard let b = Int(String(num.prefix(2).suffix(1))) else { abort() }\n  \n  return \"\\(colors[a]) \\(colors[b]) \\(colors[num.count - 2]) gold\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341905,"user_id":null,"body":"func encodeResistorColors(_ ohmsString: String) -> String {\n    let IntToColor = [0: \"black\", 1: \"brown\", 2: \"red\", 3: \"orange\", 4: \"yellow\", 5: \"green\", 6: \"blue\", 7: \"violet\", 8: \"gray\", 9: \"white\"]\n    let str = ohmsString.prefix(upTo: ohmsString.firstIndex(of: \" \")!)\n    var countOhms: Double\n    \/\/var result = \"gold\"\n    switch str[str.index(before: str.endIndex)]{\n    case \"k\": countOhms = Double(str.prefix(upTo: str.firstIndex(of: \"k\")!))!*1000\n    case \"M\":  countOhms = Double(str.prefix(upTo: str.firstIndex(of: \"M\")!))!*1000000\n    default: countOhms = Double(str)!\n    }\n    let arrResult:[Int] = String(Int(countOhms)).map {Int(String($0))!}\n    if arrResult[1] != 0 { return IntToColor[arrResult[0]]! + \" \" + IntToColor[arrResult[1]]! + \" \" + IntToColor[arrResult.filter{$0 == 0}.count]! + \" \" + \"gold\"} \n    else {return IntToColor[arrResult[0]]! + \" \" + IntToColor[arrResult[1]]! + \" \" + IntToColor[arrResult.filter{$0 == 0}.count-1]! + \" \" + \"gold\"}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341906,"user_id":null,"body":"func encodeResistorColors(_ ohmsString: String) -> String {\n  let resistorResistanceString = ohmsString.split(separator: \" \").first!\n  let resistorResistanceDigitsString = resistorResistanceString.prefix(while: { $0.isNumber || $0.isPunctuation } )\n  let resistorResistancePowerString = resistorResistanceString.drop(while: { $0.isNumber || $0.isPunctuation } )\n  let resistorResistanceDigits = Double(resistorResistanceDigitsString)!\n  let powerToAdd: Double = resistorResistanceDigits < 10 ? -1 : resistorResistanceDigits >= 100 ? 1 : 0\n  let resistorResistanceCorrectedDigits = Int(resistorResistanceDigits*pow(10, -powerToAdd))\n  let resistorResistancePower = Double(resistorResistancePowerString.isEmpty ? 0 : resistorResistancePowerString == \"k\" ? 3 : 6)\n  let resistorResistaceCorrectedPower = Int(resistorResistancePower + powerToAdd)\n  return(\"\\(ResistorColorCode(rawValue: resistorResistanceCorrectedDigits\/10)!) \" +\n         \"\\(ResistorColorCode(rawValue: resistorResistanceCorrectedDigits%10)!) \" +\n         \"\\(ResistorColorCode(rawValue: resistorResistaceCorrectedPower)!) gold\")  \n}\n\nenum ResistorColorCode: Int, CaseIterable {\n  case black = 0, brown, red, orange, yellow, green, blue, violet, gray, white\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341907,"user_id":null,"body":"func encodeResistorColors(_ ohmsString: String) -> String {\n  let resistorResistanceString = ohmsString.split(separator: \" \").first!\n  let resistorResistanceDigitsString = resistorResistanceString.prefix(while: { $0.isNumber || $0.isPunctuation } )\n  let resistorResistancePowerString = resistorResistanceString.drop(while: { $0.isNumber || $0.isPunctuation } )\n  let resistorResistanceDigits = Double(resistorResistanceDigitsString)!\n  let powerToAdd: Double = resistorResistanceDigits < 10 ? -1 : resistorResistanceDigits >= 100 ? 1 : 0\n  let resistorResistanceCorrectedDigits = Int(resistorResistanceDigits*pow(10, -powerToAdd))\n  let resistorResistancePower = Double(resistorResistancePowerString.isEmpty ? 0 : resistorResistancePowerString == \"k\" ? 3 : 6)\n  let resistorResistaceCorrectedPower = Int(resistorResistancePower + powerToAdd)\n  print(resistorResistanceCorrectedDigits)\n  print(resistorResistaceCorrectedPower)\n  return(\"\\(ResistorColorCode(rawValue: resistorResistanceCorrectedDigits\/10)!) \" +\n         \"\\(ResistorColorCode(rawValue: resistorResistanceCorrectedDigits%10)!) \" +\n         \"\\(ResistorColorCode(rawValue: resistorResistaceCorrectedPower)!) gold\")  \n}\n\nenum ResistorColorCode: Int, CaseIterable {\n  case black = 0, brown, red, orange, yellow, green, blue, violet, gray, white, gold, silver\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341908,"user_id":null,"body":"import Foundation\n\nfunc encodeResistorColors(_ ohmsString: String) -> String\n{\n    let parts: [String] = ohmsString.split(separator: \" \").map({ String($0); });\n    var numericPart: String = parts[0];\n    let unitSuffix: Character = numericPart.last!;\n    let hasUnitSuffix: Bool = unitSuffix == \"k\" || unitSuffix == \"M\";\n\n    if(hasUnitSuffix)\n    { numericPart = String(numericPart.dropLast(1)); }\n\n    let numericChars = Array<Character>(numericPart);\n    let isDecimalNumber = numericChars.count > 2 && numericChars[numericChars.count - 2] == \".\";\n\n    let significand = Int(\"\\(numericChars[0])\\(numericChars.count == 1 ? (hasUnitSuffix ? \"0\" : \"\") : String(numericChars[isDecimalNumber ? 2 : 1]))\")!;\n    let exponent = (isDecimalNumber ? -1 : numericChars.count - 2) + (unitSuffix == \"M\" ? 6 : unitSuffix == \"k\" ? 3 : 0);\n    \n    return \"\\(colourNames[significand \/ 10]) \\(colourNames[significand % 10]) \\(colourNames[exponent]) gold\";\n}\n\nlet colourNames: [String] = [ \"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\" ];\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341909,"user_id":null,"body":"import Foundation\n\nfunc encodeResistorColors(_ ohmsString: String) -> String\n{\n    \/\/ Do something\n    \/\/ return \"brown black black gold\"\n\n    let parts: [String] = ohmsString.split(separator: \" \").map({ String($0); });\n    var numericPart: String = parts[0];\n    let unitSuffix: Character = numericPart.last!;\n    let hasUnitSuffix: Bool = unitSuffix == \"k\" || unitSuffix == \"M\";\n\n    if(hasUnitSuffix)\n    { numericPart = String(numericPart.dropLast(1)); }\n\n    let numericChars = Array<Character>(numericPart);\n    let isDecimalNumber = numericChars.count > 2 && numericChars[numericChars.count - 2] == \".\";\n    let significand: Int;\n    let exponent: Int;\n\n    \/\/region if(isDecimalNumber) { ... }\n    if(isDecimalNumber)\n    {\n        significand = Int(\"\\(numericChars[0])\\(numericChars[2])\")!;\n        \/\/ Ohm values of a decimal amount are only valid here where suffixed with a unit.\n        exponent = unitSuffix == \"M\" ?  5 : 2;\n    }\n    else\n    {\n        if(hasUnitSuffix)\n        {\n            if(numericChars.count > 1)\n            {\n                significand = Int(\"\\(numericChars[0])\\(numericChars[1])\")!;\n                exponent = numericChars.count - 2 + (unitSuffix == \"M\" ? 6 : 3);\n            }\n            else\n            {\n                significand = Int(\"\\(numericChars[0])0\")!;\n                exponent = unitSuffix == \"M\" ? 5 : 2;\n            }\n        }\n        else\n        {\n            if(numericChars.count > 1)\n            {\n                significand = Int(\"\\(numericChars[0])\\(numericChars[1])\")!;\n                exponent = numericChars.count - 2;\n            }\n            else\n            {\n                significand = Int(String(numericChars[0]))!;\n                exponent = 0;\n            }\n        }\n    }\n    \/\/endregion\n\n    print();\n    print(\"input: \\(ohmsString)\");\n    print(\"numeric part: \\(numericPart), unit suffix: \\(hasUnitSuffix ? String(unitSuffix) : \"(none)\")\");\n    print(\"significand: \\(significand), exponent: \\(exponent)\");\n    let output = \"\\(colourNames[significand \/ 10]) \\(colourNames[significand % 10]) \\(colourNames[exponent]) gold\";\n    print(\"output: \\(output)\");\n    return \"\\(colourNames[significand \/ 10]) \\(colourNames[significand % 10]) \\(colourNames[exponent]) gold\";\n\n    \/\/ let significant: Int = Int(numericPart)!;\n    \/\/ let isDecimalNumber: Bool = numericPart.count > 2 && numericPart.ked\n}\n\nlet colourNames: [String] = [ \"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\" ];\n\n\/\/print(\"Doot!\");\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341910,"user_id":null,"body":"func encodeResistorColors(_ ohmsString: String) -> String {\n    let dict = [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\"]\n    var str = ohmsString.components(separatedBy: \" \")[0]\n    var ans = [String]()\n    var zeros = 0\n    if (str.last == \"k\" || str.last == \"M\") {\n        zeros = (str.last == \"k\") ? 3 : 6\n        str.removeLast()\n    }\n    \/\/we want to read two digits\n    var count = 0\n    var index = 0\n    for c in str {\n        index+=1\n        if c.isASCII && c.isNumber {\n            ans.append(dict[c.wholeNumberValue!])\n            count+=1\n            if count == 2 {\n                break\n            }\n        }\n    }\n    \n    if (count == 1) {\n        ans.append(\"black\")\n        zeros-=1\n    }\n    \n    if (index>2) {\n        zeros-=1\n    }\n    \n    zeros += str.count - index\n    \n    ans.append(dict[zeros])\n    ans.append(\"gold\")\n    return ans.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341911,"user_id":null,"body":"struct Value {\n    let color: String\n    let number: Int\n    let multiplier: Double\n}\n\nlet values = [\n    Value(color: \"Black\", number: 0, multiplier: 1),\n    Value(color: \"Brown\", number: 1, multiplier: 10),\n    Value(color: \"Red\", number: 2, multiplier: 100),\n    Value(color: \"Orange\", number: 3, multiplier: 1_000),\n    Value(color: \"Yellow\", number: 4, multiplier: 10_000),\n    Value(color: \"Green\", number: 5, multiplier: 100_000),\n    Value(color: \"Blue\", number: 6, multiplier: 1_000_000),\n    Value(color: \"Violet\", number: 7, multiplier: 10_000_000),\n    Value(color: \"Gray\", number: 8, multiplier: 100_000_000),\n    Value(color: \"White\", number: 9, multiplier: 1_000_000_000),\n]\n\nfunc color(for number: Int) -> String {\n    values.first(where: { $0.number == number })!.color.lowercased()\n\n}\n\nfunc color(mult: Int) -> String {\n    values.first(where: { $0.multiplier == Double(mult)})!.color.lowercased()\n}\n\nfunc encodeResistorColors(_ ohmsString: String) -> String {\n    var input = ohmsString.dropLast(5)\n    var mult = 1\n    if input.last == \"k\" {\n        mult = 1_000\n        input.removeLast()\n    } else if input.last == \"M\" {\n        mult = 1_000_000\n        input.removeLast()\n    }\n\n    if let idx = input.firstIndex(of: \".\") {\n        let index: Int = input.distance(from: input.startIndex, to: idx)\n        let preValue = input[input.startIndex..<input.index(input.startIndex, offsetBy: index)]\n        let postValue = input[input.index(input.startIndex, offsetBy: index + 1)..<input.endIndex]\n        return colors(for: String(preValue), mult: mult, post: String(postValue))\n    } else {\n        return colors(for: String(input), mult: mult, post: nil)\n    }\n}\n\nfunc colors(for preValue: String, mult: Int, post: String?) -> String {\n    var mult = mult\n    var result: [String] = []\n\n    var position = 0\n    for (idx, pre) in preValue.compactMap({ String($0) }).enumerated() {\n        if idx <= 1 {\n            result.append(color(for: Int(pre)!))\n        } else {\n            mult *= 10\n        }\n        position += 1\n    }\n\n    if post == nil, position == 1 {\n        result.append(color(for: 0))\n        mult \/= 10\n    }\n\n    for postValue in post?.compactMap({ String($0) }) ?? [] {\n        if position <= 1 {\n            result.append(color(for: Int(postValue)!))\n        }\n        mult \/= 10\n    }\n    result.append(color(mult: mult))\n    result.append(\"gold\")\n    return result.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58583922c1d5b415b00000ff":[{"id":341912,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \/\/ Direction enum values are .up, .down, .left, and .right\n  \/\/ Do something\n  var currentPosition = position\n  var result = [String]()\n  for move in moves {\n    switch move {\n      case .up:\n        if currentPosition.row != 0,\n          !fighters[currentPosition.row - 1][currentPosition.column].isEmpty {\n            currentPosition.row -= 1\n        }\n      case .down:\n        if currentPosition.row != (fighters.count - 1),\n          !fighters[currentPosition.row + 1][currentPosition.column].isEmpty {\n            currentPosition.row += 1\n        }\n      case .right:\n        repeat {\n          currentPosition.column = (currentPosition.column + 1) % fighters[currentPosition.row].count\n        } while fighters[currentPosition.row][currentPosition.column].isEmpty\n      case .left:\n        repeat {\n          currentPosition.column = (currentPosition.column - 1 + fighters[currentPosition.row].count) % fighters[currentPosition.row].count\n        } while fighters[currentPosition.row][currentPosition.column].isEmpty\n    }\n    result.append(fighters[currentPosition.row][currentPosition.column])\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341913,"user_id":53,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \n  var y = position.row\n  var x = position.column\n  let h = fighters.count\n  let w = fighters[0].count\n  \n  return moves.reduce(into: [], { acc, e in\n    switch e {\n      case .up:   if (y>0 && fighters[y-1][x].count>0) { y -= 1 }\n      case .down: if (y<h-1 && fighters[y+1][x].count>0) { y += 1 }\n      case .left: while (true) { \n        x=(x+w-1)%w\n        if (fighters[y][x].count>0) { break }}\n      default:    while (true) {\n        x=(x+1)%w\n        if (fighters[y][x].count>0) { break }}\n    }\n    acc.append(fighters[y][x])\n  })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341914,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    let width = fighters.first?.count ?? 0\n    let height = fighters.count\n    \n    var position = position\n    \n    return moves.map { move in\n        switch move {\n        case .up:\n            if position.row != 0 && fighters[(position.row - 1)][position.column] != \"\" { position.row -= 1 }\n        case .down:\n            if position.row != (height - 1) && fighters[(position.row + 1)][position.column] != \"\" { position.row += 1 }\n        case .left:\n            var shiftLeft = 1\n            while fighters[position.row][(position.column + width - shiftLeft) % width] == \"\" { shiftLeft += 1 }\n            position.column = (position.column + width - shiftLeft) % width\n        case .right:\n            var shiftRight = 1\n            while fighters[position.row][(position.column + shiftRight) % width] == \"\" { shiftRight += 1 }\n            position.column = (position.column + shiftRight) % width\n        }\n        \n        return fighters[position.row][position.column]\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341915,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    var answer = [String]()\n    var row = position.row\n    var col = position.column\n    for move in moves {\n        switch move {\n        case .up:\n            if row - 1 >= 0 && fighters[row - 1][col] != \"\" { row -= 1 }\n            break\n        case .down:\n            if row + 1 < fighters.count && fighters[row + 1][col] != \"\" { row += 1 }\n            break\n        case .left:\n            col -= 1\n            if col < 0 { col = fighters[row].count - 1 }\n            while fighters[row][col] == \"\" {\n                col -= 1\n                if col < 0 { col = fighters[row].count - 1 }\n            }\n            break\n        case .right:\n            col += 1\n            if col > fighters[row].count - 1 { col = 0 }\n            while fighters[row][col] == \"\" {\n                col += 1\n                if col > fighters[row].count - 1 { col = 0 }\n            }\n            break\n        }\n        answer.append(fighters[row][col])\n    }\n    \n    return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341916,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \n  let rows = fighters.count\n  let columns = fighters.first?.count ?? 0\n  \n  var list = [String]()\n  var cursor = position\n  var currentFighter: String { fighters[row][column] }\n  \n  var row: Int {\n    get { cursor.row }\n    set { cursor.row = newValue }\n  }\n\n  var column: Int {\n    get { cursor.column }\n    set { cursor.column = newValue }\n  }\n\n  func moveHorizontally(_ change: Int) {\n    repeat {\n      column += change\n      if column >= columns { column = 0 }\n      else if column < 0 { column = columns - 1 }\n    }\n    while currentFighter == \"\"\n  }\n  \n  func moveVertically(_ change: Int) {\n    let oldRow = row\n    row += change\n    guard row >= 0, row < rows, currentFighter != \"\" else { return row = oldRow }\n  }\n  \n  for move in moves {\n    switch move {\n      case .up: moveVertically(-1)\n      case .down: moveVertically(1)\n      case .left: moveHorizontally(-1)\n      case .right: moveHorizontally(1)\n    }\n    list.append(currentFighter)\n  }\n  \n  return list\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341917,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  var result = [String]()\n  var (row, col) = position\n  for move in moves {\n    switch move {\n      case .up:\n        row = row > 0 ? row - 1 : 0\n        if fighters[row][col] == \"\" {row = row + 1}\n      case .down:\n        row = row < fighters.count - 1 ? row + 1 : fighters.count - 1\n        if fighters[row][col] == \"\" {row = row - 1}\n      case .left:\n        col = col == 0 ? fighters[0].count - 1 : col - 1\n        while fighters[row][col] == \"\" { \n          col = col == 0 ? fighters[0].count - 1 : col - 1\n        }\n      case .right:\n        col = col == fighters[0].count - 1 ? 0 : col + 1\n        while fighters[row][col] == \"\" { \n          col = col == fighters[0].count - 1 ? 0 : col + 1\n        }\n    }\n    result.append(fighters[row][col])\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341918,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  var hoveredFighters: [String] = []\n  \n  var p = position\n  for move in moves {\n      p = chooseNextPosition(fighters, p, move)\n    \n      hoveredFighters.append(fighters[p.0][p.1])\n  }\n  return hoveredFighters\n}\n\nfunc chooseNextPosition(_ fighters: [[String]], _ position: (row: Int, column: Int), _ move: Direction) -> (Int, Int) {\n    var p = position\n    switch move {\n        case .up:\n            p = (max(0, p.0 - 1), p.1)\n            if fighters[p.0][p.1].isEmpty {\n                p = position\n            }\n        case .down:\n            p = (min(fighters.count - 1, p.0 + 1), p.1)\n            if fighters[p.0][p.1].isEmpty {\n                p = position\n            }\n        case .left:\n            p = (p.0, p.1 - 1 < 0 ? fighters[p.0].count - 1 : p.1 - 1)\n            if fighters[p.0][p.1].isEmpty {\n                p = chooseNextPosition(fighters, p, move)\n            }\n        case .right:\n            p = (p.0, p.1 + 1 > fighters[p.0].count - 1 ? 0 : p.1 + 1)\n            if fighters[p.0][p.1].isEmpty {\n                p = chooseNextPosition(fighters, p, move)\n            }\n        default:\n            break\n    }\n    return p\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341919,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    var output: [String] = []\n    var actualPos: (row: Int, column: Int) = position\n    \n    for move in moves {\n        var name: String = \"\"\n        switch move {\n        case .up:\n            if actualPos.row > 0 && fighters[actualPos.row-1][actualPos.column] != \"\" {\n                actualPos.row -= 1\n                name = fighters[actualPos.row][actualPos.column]\n            } else {\n                name = fighters[actualPos.row][actualPos.column]\n            }\n        case .down:\n            if actualPos.row < fighters.count-1 && fighters[actualPos.row+1][actualPos.column] != \"\"{\n                actualPos.row += 1\n                name = fighters[actualPos.row][actualPos.column]\n            } else {\n                name = fighters[actualPos.row][actualPos.column]\n            }\n        case .left: \/\/Do left and right\n            temploop: while true {\n                actualPos.column = actualPos.column == 0 ? fighters[actualPos.row].count - 1 : actualPos.column - 1\n                if fighters[actualPos.row][actualPos.column] != \"\" {\n                    break temploop\n                }\n            }\n            name = fighters[actualPos.row][actualPos.column]\n        case .right:\n            temploop: while true {\n                actualPos.column = actualPos.column == fighters[actualPos.row].count - 1 ? 0 : actualPos.column + 1\n                if fighters[actualPos.row][actualPos.column] != \"\" {\n                    break temploop\n                }\n            }\n            name = fighters[actualPos.row][actualPos.column]\n        }\n        output.append(name)\n    }\n    \n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341920,"user_id":null,"body":"func superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n    var position = position\n    var result = [String]()\n    \n    for move in moves {\n        switch move {\n        case Direction.up:\n            guard position.row - 1 >= 0 && !fighters[position.row - 1][position.column].isEmpty else { break }\n            position.row = position.row - 1\n        case .down:\n            guard position.row + 1 < fighters.count && !fighters[position.row + 1][position.column].isEmpty else { break }\n            position.row = position.row + 1\n        case .left:\n            repeat {\n                position.column = (position.column - 1 + fighters[0].count) % fighters[0].count\n            } while fighters[position.row][position.column].isEmpty\n        case .right:\n            repeat {\n                position.column = (position.column + 1) % fighters[0].count\n            } while fighters[position.row][position.column].isEmpty\n        }\n        \n        result.append(fighters[position.row][position.column])\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341921,"user_id":null,"body":"var row: Int = 0\nvar col: Int = 0\nvar height: Int = 0\nvar width: Int = 0\nvar grid: [[String]] = []\n\nfunc superStreetFighterSelection(fighters: [[String]], position: (row: Int, column: Int), moves: [Direction]) -> [String] {\n  \/\/ Direction enum values are .up, .down, .left, and .right\n\n  grid = fighters\n  height = fighters.count-1\n  width = fighters[0].count-1\n  row = position.0\n  col = position.1\n  var solution: [String] = []\n  \n  for move in moves {\n    if move == .right {\n      moveRight()\n    } else if move == .left {\n      moveLeft()\n    } else if move == .up {\n      moveUp()\n    } else if move == .down {\n      moveDown()\n    }\n    solution.append( grid[row][col] )\n  }\n  \n  return solution\n}\n\nfunc moveUp() {\n  guard row != 0 else { return }\n  guard grid[row-1][col] != \"\" else {return}\n  row -= 1\n}\n\nfunc moveDown() {\n  guard row != height else { return }\n  guard grid[row+1][col] != \"\" else { return }\n  row += 1\n}\n\nfunc moveRight() {\n  col += 1\n  if col > width { col = 0 }\n  if grid[row][col] == \"\" { moveRight() }\n}\n\nfunc moveLeft() {\n  col -= 1\n  if col < 0 { col = width }\n  if grid[row][col] == \"\" { moveLeft() }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"585894545a8a07255e0002f1":[{"id":341922,"user_id":null,"body":"func countPatterns(from f: Dot, length l: Int) -> Int {\n    if l > 9 || l <= 0 {return 0} else if l == 1 {return l}\n    let arr = [[5, 31, 154, 684, 2516, 7104, 13792, 13792], [7, 37, 188, 816, 2926, 8118, 15564, 15564],\n                  [5, 31, 154, 684, 2516, 7104, 13792, 13792], [7, 37, 188, 816, 2926, 8118, 15564, 15564], [8, 48, 256, 1152, 4248, 12024, 23280, 23280], [7, 37, 188, 816, 2926, 8118, 15564, 15564],[5, 31, 154, 684, 2516, 7104, 13792, 13792], [7, 37, 188, 816, 2926, 8118, 15564, 15564], [5, 31, 154, 684, 2516, 7104, 13792, 13792] ]\n    return arr[f.rawValue][l - 2]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341923,"user_id":311,"body":"func countPatterns(from firstDot: Dot, length: Int) -> Int {\n    func go(from firstDot: Int, length: Int, avoid dots: Set<Int>) -> Int {\n        \/\/print (\"go from: \\(firstDot), length: \\(length), avoid: \\(dots)\")\n        guard length > 0, length < 10 else {return 0}\n        guard length > 1 else {return 1}\n        let dotsToCheck = Set(0...8).subtracting([firstDot]).subtracting(dots)\n        var count = 0\n        for dot in dotsToCheck {\n            let firstDotPosition = (row: firstDot\/3, column: firstDot % 3)\n            let dotPosition = (row: dot\/3, column: dot % 3)\n            let rowDistance = abs(firstDotPosition.row - dotPosition.row)\n            let columnDistance = abs(firstDotPosition.column - dotPosition.column)\n            let canGo: Bool\n            if rowDistance <= 1 && columnDistance <= 1 {\/\/MARK: - The two dots are neibors\n                canGo = true\n            } else if rowDistance * columnDistance == 2 { \/\/ MARK: - The two dots are diagonal but not 45 degree\n                canGo = true\n            } else {\/\/ MARK: - there is one other dot between the two dots\n                let middleDotRow = (firstDotPosition.row + dotPosition.row) \/ 2\n                let middleDotColumn = (firstDotPosition.column + dotPosition.column) \/ 2\n                let middleDot = 3 * middleDotRow + middleDotColumn\n                guard middleDot > 0 && middleDot < 8 else {\n                    fatalError(\"Check your code! This line should not be reached at all! \")\n                }\n                canGo = dots.contains(middleDot)\n            }\n            count += (canGo) ? go(from: dot, length: length - 1, avoid: dots.union([firstDot])) : 0\n        }\n        return count\n    }\n    let firstDotInt = firstDot.rawValue\n    return go(from: firstDotInt, length: length, avoid: [])\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341924,"user_id":null,"body":"struct IndexPath {\n    let row: Int\n    let section: Int\n\n    init(row: Int, section: Int) {\n        self.row = row\n        self.section = section\n    }\n}\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n    guard length > 0 else {\n        return 0\n    }\n    guard length <= Dot.allCases.count else {\n        return 0\n    }\n    return countPaths(from: firstDot, length: length, currentDots: [firstDot])\n}\n\nprivate func countPaths(from firstDot: Dot, length: Int, currentDots: [Dot]) -> Int {\n    if length == currentDots.count {\n        return 1\n    }\n\n    let possibleNextDots = Dot.allCases.filter {\n        guard !currentDots.contains($0) else {\n            return false\n        }\n        guard canReach(from: firstDot, to: $0, alreadyUsed: currentDots) else {\n            return false\n        }\n        return true\n    }\n    return possibleNextDots.reduce(0) {\n        var newDots = currentDots\n        newDots.append($1)\n        return $0 + countPaths(from: $1, length: length, currentDots: newDots)\n    }\n}\n\nprivate func canReach(from: Dot, to: Dot, alreadyUsed: [Dot]) -> Bool {\n    let fromDotIndexPath = indexPath(for: from)\n    let toDotIndexPath = indexPath(for: to)\n    if fromDotIndexPath.row == toDotIndexPath.row {\n        if abs(fromDotIndexPath.section - toDotIndexPath.section) == 2 {\n            if alreadyUsed.contains(dot(for: .init(row: fromDotIndexPath.row, section: 1))) {\n                return true\n            } else {\n                return false\n            }\n        }\n    } else if fromDotIndexPath.section == toDotIndexPath.section {\n        if abs(fromDotIndexPath.row - toDotIndexPath.row) == 2 {\n            if alreadyUsed.contains(dot(for: .init(row: 1, section: fromDotIndexPath.section))) {\n                return true\n            } else {\n                return false\n            }\n        }\n    } else if abs(fromDotIndexPath.row - toDotIndexPath.row) == 2\n        && abs(fromDotIndexPath.section - toDotIndexPath.section) == 2 {\n          return alreadyUsed.contains(dot(for: .init(row: 1, section: 1)))\n        }\n    return true\n}\n\nprivate func indexPath(for dot: Dot) -> IndexPath {\n    .init(row: dot.rawValue % 3, section: dot.rawValue \/ 3)\n}\n\nprivate func dot(for indexPath: IndexPath) -> Dot {\n    Dot(rawValue: indexPath.row + indexPath.section * 3)!\n}\n\nextension Dot {\n    static var allCases: [Dot] = [.a, .b, .c, .d, .e, .f, .g, .h, .i]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341925,"user_id":null,"body":"extension Dot {\n    var canReachDots: [Int] {\n        switch self {\n        case .a:\n            return [1,3,4,5,7]\n        case .b:\n            return [0,2,3,4,5,6,8]\n        case .c:\n            return [1,3,4,5,7]\n        case .d:\n            return [0,1,2,4,6,7,8]\n        case .e:\n            return [0,1,2,3,5,6,7,8]\n        case .f:\n            return [0,1,2,4,6,7,8]\n        case .g:\n            return [1,3,4,5,7]\n        case .h:\n            return [0,2,3,4,5,6,8]\n        case .i:\n            return [1,3,4,5,7]\n        }\n    }\n    var judgeReachDots: [Int] {\n        switch self {\n        case .a: return [2, 6, 8]\n        case .b: return [7]\n        case .c: return [0, 6, 8]\n        case .d: return [5]\n        case .e: return []\n        case .f: return [3]\n        case .g: return [0, 2, 8]\n        case .h: return [1]\n        case .i: return [0, 2, 6]\n        }\n    }\n    func getMiddleByDot(reach: Int) -> Int {\n        let half = abs(self.rawValue - reach) \/ 2\n        let middle = min(self.rawValue, reach) + half\n        return middle\n    }\n}\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n    if length == 0 || length > 9 {\n        return 0\n    }\n\n    var useModel: [[Int]] = [[firstDot.rawValue]]\n    var length = length\n    while length > 1 {\n        var newModel: [[Int]] = []\n        for model in useModel {\n            let lastDot = Dot(rawValue: model.last!)!\n            let alreadyReach = model.map({$0})\n            let normalReach = lastDot.canReachDots.filter({!alreadyReach.contains($0)})\n            let jumpReach = lastDot.judgeReachDots.filter { (dot) -> Bool in\n                if alreadyReach.contains(dot) {\n                    return false\n                }\n                let middle = lastDot.getMiddleByDot(reach: dot)\n                return alreadyReach.contains(middle)\n            }\n            newModel += (normalReach + jumpReach).map({ (new) -> [Int] in\n                return model + [new]\n            })\n        }\n        useModel = newModel\n        length -= 1\n    }\n    return useModel.count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341926,"user_id":null,"body":"extension Dot {\n    \n    func next(_ array: [Dot]) -> [Dot] {\n        var next: [Dot]\n        switch self {\n        case .a:\n            next = [.b, .d, .e, .f, .h]\n            if array.contains(.b) {\n                if !array.contains(.c) {\n                    next.append(.c)\n                }\n            }\n            if array.contains(.d) {\n                if !array.contains(.g) {\n                    next.append(.g)\n                }\n            }\n            if array.contains(.e) {\n                if !array.contains(.i) {\n                    next.append(.i)\n                }\n            }\n        case .b:\n            next = [.a, .c, .d, .e, .f, .g, .i]\n            if array.contains(.e) {\n                if !array.contains(.h) {\n                    next.append(.h)\n                }\n            }\n        case .c:\n            next = [.b, .d, .e, .f, .h]\n            if array.contains(.b) {\n                if !array.contains(.a) {\n                    next.append(.a)\n                }\n            }\n            if array.contains(.e) {\n                if !array.contains(.g) {\n                    next.append(.g)\n                }\n            }\n            if array.contains(.f) {\n                if !array.contains(.i) {\n                    next.append(.i)\n                }\n            }\n        case .d:\n            next = [.a, .b, .c, .e, .g, .h, .i]\n            if array.contains(.e) {\n                if !array.contains(.f) {\n                    next.append(.f)\n                }\n            }\n        case .e:\n            next = [.a, .b, .c, .d, .f, .g, .h, .i]\n        case .f:\n            next = [.a, .b, .c, .e, .g, .h, .i]\n            if array.contains(.e) {\n                if !array.contains(.d) {\n                    next.append(.d)\n                }\n            }\n        case .g:\n            next = [.b, .d, .e, .f, .h]\n            if array.contains(.d) {\n                if !array.contains(.a) {\n                    next.append(.a)\n                }\n            }\n            if array.contains(.e) {\n                if !array.contains(.c) {\n                    next.append(.c)\n                }\n            }\n            if array.contains(.h) {\n                if !array.contains(.i) {\n                    next.append(.i)\n                }\n            }\n        case .h:\n            next = [.a, .c, .d, .e, .f, .g, .i]\n            if array.contains(.e) {\n                if !array.contains(.b) {\n                    next.append(.b)\n                }\n            }\n        case .i:\n            next = [.b, .d, .e, .f, .h]\n            if array.contains(.e) {\n                if !array.contains(.a) {\n                    next.append(.a)\n                }\n            }\n            if array.contains(.h) {\n                if !array.contains(.g) {\n                    next.append(.g)\n                }\n            }\n            if array.contains(.f) {\n                if !array.contains(.c) {\n                    next.append(.c)\n                }\n            }\n        }\n        \n        return next.filter { !array.contains($0) }\n    }\n}\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n    guard length < 10, length > 0 else { return 0 }\n    guard length != 1 else { return 1 }\n    var result = 0\n    let next = firstDot.next([firstDot])\n    for dot in next {\n        result += countPatternsArray(from: [firstDot, dot], length: length - 1)\n    }\n    return result\n}\n\nfunc countPatternsArray(from dots: [Dot], length: Int) -> Int {\n    guard length < 10, length > 0 else { return 0 }\n    guard length != 1 else { return 1 }\n    var result = 0\n    let next = dots.last!.next(dots)\n    for dot in next {\n        result += countPatternsArray(from: dots + [dot], length: length - 1)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341927,"user_id":null,"body":"extension Dot {\n    func pathBlocked(to destination: Dot) -> Dot? {\n        switch (self, destination) {\n        case (.a, .i), (.i, .a), (.c, .g), (.g, .c), (.d, .f), (.f, .d), (.b, .h), (.h, .b):\n            return .e\n        case (.a, .c), (.c, .a):\n            return .b\n        case (.c, .i), (.i, .c):\n            return .f\n        case (.i, .g), (.g, .i):\n            return .h\n        case (.g, .a), (.a, .g):\n            return .d\n        default:\n            return nil\n        }\n    }\n\n    func nextDotsAvailableFrom(unusedDots: [Dot]) -> [Dot] {\n        return unusedDots.compactMap { nextDot in\n            \/\/ check if the path to the next dot is blocked by another unused dot\n            if let blockingDot = self.pathBlocked(to: nextDot) {\n                if unusedDots.contains(blockingDot) { return nil }\n            }\n            return nextDot\n        }\n    }\n    \n    \/\/ bypasses CodeWars throwing error when getting Dots to conform to CaseIterable\n    static var allCases: [Dot] {\n        return [.a, .b, .c, .d, .e, .f, .g, .h, .i]\n    }\n}\n\n\nfunc next(desiredLength: Int, counter: inout Int, usedDots: [Dot] = [], unusedDots: [Dot]) {\n    if usedDots.count < desiredLength {\n        for nextDot in usedDots.last?.nextDotsAvailableFrom(unusedDots: unusedDots) ?? unusedDots {\n            next(\n                desiredLength: desiredLength,\n                counter: &counter,\n                usedDots: usedDots + [nextDot],\n                unusedDots: unusedDots.filter{ $0 != nextDot}\n            )\n        }\n    } else {\n        counter += 1\n    }\n}\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n    guard length > 0 && length < 10 else { return 0 }\n    var counter: Int = 0\n    next(desiredLength: length, counter: &counter, usedDots: [firstDot], unusedDots: Dot.allCases.filter{ $0 != firstDot })\n    return counter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341928,"user_id":null,"body":"func isValidMove(grid: [Int], currentPosition: Int, newPosition: Int) -> Bool {\n    var currentPosition = currentPosition\n    var newPosition = newPosition\n    \n    if currentPosition > newPosition {\n        (currentPosition, newPosition) = (newPosition, currentPosition)\n    }\n    \n    let stringMove = \"\\(currentPosition)\\(newPosition)\"\n    let skipMoves = [\"02\": 1, \"06\": 3, \"08\": 4, \"17\": 4, \"26\": 4, \"28\": 5, \"35\": 4, \"68\": 7]\n    \n    for move in skipMoves {\n        if move.key == stringMove {\n            if grid[move.value] != 1 {\n                return false\n            }\n        }\n    }\n    \n    return true\n}\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n    guard length > 0, length < 10 else { return 0 }\n    guard length != 1 else { return 1 }\n        \n    var grid = Array(repeating: 0, count: 9)\n    var patternCount = 0\n    var length = length\n    \n    grid[firstDot.rawValue] = 1\n    \n    func findNextMoves(grid: [Int], startingPoint: Int) {\n        for i in 0..<9 {\n            if grid[i] == 0 && isValidMove(grid: grid, currentPosition: startingPoint, newPosition: i) {\n                var localGrid = grid\n                localGrid[i] = 1\n                \n                if localGrid.reduce(0, +) == length {\n                    patternCount += 1\n                } else {\n                    findNextMoves(grid: localGrid, startingPoint: i)\n                }\n            }\n        }\n    }\n    \n    findNextMoves(grid: grid, startingPoint: firstDot.rawValue)\n    \n    return patternCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341929,"user_id":null,"body":"func countPatterns(from firstDot: Dot, length: Int) -> Int {\n    return countPatterns(dots: [firstDot.rawValue], length: length)\n}\n    \nfunc countPatterns(dots: [Int], length: Int) -> Int {\n    if dots.count == length {\n        return 1\n    }\n    var c = 0\n    let a = dots.last!\n    for b in 0...8 {\n        if b == a || dots.contains(b) {\n            continue\n        }\n        if abs(a - b) == 6 {\n            if !dots.contains(Int((a + b)\/2)) {\n                continue\n            }\n        }\n        let x1 = a % 3\n        let x2 = b % 3\n        let dY = abs(a \/ 3 - b \/ 3)\n        if abs(x1 - x2) == 2 && dY != 1 {\n            if !dots.contains(Int((a + b)\/2)) {\n                print(a, b)\n                continue\n            }\n        }\n        c += countPatterns(dots: dots + [b], length: length)\n    }\n    return c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341930,"user_id":null,"body":"let matrix = [[-1,0,1,0,0,0,3,0,4],\n              [0,-1,0,0,0,0,0,4,0],\n              [1,0,-1,0,0,0,4,0,5],\n              [0,0,0,-1,0,4,0,0,0],\n              [0,0,0,0,-1,0,0,0,0],\n              [0,0,0,4,0,-1,0,0,0],\n              [3,0,4,0,0,0,-1,0,7],\n              [0,4,0,0,0,0,0,-1,0],\n              [4,0,5,0,0,0,7,0,-1]]\n\nextension Dot {\n    static var allCases: [Dot] = [.a, .b, .c, .d, .e, .f, .g, .h, .i]\n\n    var index: Int {\n        return Dot.allCases.firstIndex(of: self)!\n    }\n}\n\nfunc countPattern(from start: Int, locked: [Int], length: Int) -> Int {\n    guard length > 0 else { return 1 }\n    let indexs = matrix[start]\n        .map { n in return n > 0 && locked.contains(n) ? 0 : n }\n        .enumerated()\n        .filter { $0.1 == 0 }\n        .map { $0.0 }\n        .filter { !locked.contains($0) }\n    var sum = 0\n    for index in indexs {\n        sum += countPattern(from: index, locked: locked + [index], length: length - 1)\n    }\n    return sum\n}\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n    guard (1...9).contains(length) else { return 0 }\n    return countPattern(from: firstDot.index, locked: [firstDot.index], length: length - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341931,"user_id":null,"body":"var used : [String] = []\n\nfunc countPatterns(from firstDot: Dot, length: Int) -> Int {\n  let dot = String(describing: firstDot.self)\n  var options = [dot]\n  if (length<1 || length>9) {return 0}\n  if (length==1){return 1;}\n  if (length==2){\n  return addOption(options).count\n  }\n  var counter = 2\n  while (counter<length){\n  options=addOption(options)\n  counter = counter + 1\n  }\n  return addOption(options).count\n}\n\nfunc addOption(_ from: [String]) -> [String]{\nvar answer : [String] = []\nfor string in from{\n  for x in canReach(string){\n  answer.append(string+x)\n  }\n}\nreturn answer\n}\n\nfunc canReach(_ from: String) -> [String]{\nvar a : [String]=[]\nif (from.last! == \"e\"){\na=[\"a\",\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"i\"]\n}\nif (from.last! == \"a\"){\na=[\"b\",\"f\",\"e\",\"h\",\"d\"]\nif (from.contains(\"b\")){a.append(\"c\")}\nif (from.contains(\"d\")){a.append(\"g\")}\nif (from.contains(\"e\")){a.append(\"i\")}\n\n}\nif (from.last! == \"c\"){\na=[\"b\",\"d\",\"e\",\"h\",\"f\"]\nif (from.contains(\"b\")){a.append(\"a\")}\nif (from.contains(\"f\")){a.append(\"i\")}\nif (from.contains(\"e\")){a.append(\"g\")}\n\n}\nif (from.last! == \"i\"){\na=[\"b\",\"f\",\"e\",\"h\",\"d\"]\nif (from.contains(\"h\")){a.append(\"g\")}\nif (from.contains(\"f\")){a.append(\"c\")}\nif (from.contains(\"e\")){a.append(\"a\")}\n\n}\nif (from.last! == \"g\"){\na=[\"d\",\"b\",\"e\",\"f\",\"h\"]\nif (from.contains(\"d\")){a.append(\"a\")}\nif (from.contains(\"h\")){a.append(\"i\")}\nif (from.contains(\"e\")){a.append(\"c\")}\n}\n\nif (from.last! == \"b\"){\na=[\"a\",\"c\",\"d\",\"e\",\"f\",\"g\",\"i\"]\nif (from.contains(\"e\")){a.append(\"h\")}\n\n}\nif (from.last! == \"f\"){\na=[\"c\",\"b\",\"a\",\"g\",\"h\",\"i\",\"e\"]\nif (from.contains(\"e\")){a.append(\"d\")}\n\n}\nif (from.last! == \"h\"){\na=[\"a\",\"c\",\"d\",\"e\",\"f\",\"g\",\"i\"]\nif (from.contains(\"e\")){a.append(\"b\")}\n\n}\nif (from.last! == \"d\"){\na=[\"a\",\"b\",\"c\",\"e\",\"g\",\"h\",\"i\"]\nif (from.contains(\"e\")){a.append(\"f\")}\n\n}\na = a.filter { !from.contains($0) }\nreturn a\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"585d7d5adb20cf33cb000235":[{"id":341932,"user_id":null,"body":"func find_uniq(_ arr: [Double]) -> Double {\n    Set(arr).filter {\n        arr.firstIndex(of: $0) == arr.lastIndex(of: $0)\n    }.first!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341933,"user_id":527,"body":"func find_uniq<T: Equatable>(_ xs: [T]) -> T {\n  let x = xs[xs[0] == xs[1] ? 0 : 2];\n  return xs.first(where: { $0  != x })!;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341934,"user_id":null,"body":"func find_uniq(_ arr: [Double]) -> Double {\n  var unique = Array(Set(arr))\n  if arr[0] == arr[arr.count-1] {\n    unique = unique.filter {$0 != arr[0]} \n  }\n  else {\n    unique = unique.filter {$0 != arr[1]} \n  }\n  return unique[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341935,"user_id":null,"body":"func find_uniq<T: Comparable>(_ arr: [T]) -> T {\n  let nums = arr.sorted()\n  guard let ans = nums[0] != nums[1] ? nums.first : nums.last else {\n    return nums[0]\n  }\n  return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341936,"user_id":null,"body":"func find_uniq(_ arr: [Double]) -> Double {\n    let arr2 = Dictionary(grouping: arr, by: {$0})\n    for (key,value) in arr2 {\n        if value.count == 1 {\n            return key\n        }\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341937,"user_id":null,"body":"func find_uniq(_ arr: [Int]) -> Int {\n    let sorted = arr.sorted(by: <)\n    return sorted[0] == sorted[1] ? sorted[sorted.count - 1] : sorted[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341938,"user_id":null,"body":"func find_uniq(_ arr: [Double]) -> Double {\n    return arr.reduce(0.0, { $1 != arr[0] && $1 != arr[1] ? $0 + $1 : $0 + 0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341939,"user_id":null,"body":"func find_uniq(_ arr: [Int]) -> Int {\n    guard arr[0] == arr[1] else { return arr[0] == arr[2] ? arr[1] : arr[0] }\n    \n    return Set(arr).first(where: { $0 != arr[0] }) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341940,"user_id":null,"body":"func find_uniq(_ arr: [Double]) -> Double {\n  var n = arr[0]\n  let set = Set(arr)\n  \n  for number in set {\n    let firstIndex = arr.firstIndex(of: number)\n    let lastIndex = arr.lastIndex(of: number)\n    if firstIndex == lastIndex {\n      n = number\n    }\n  }\n  \n  return n \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341941,"user_id":null,"body":"func find_uniq(_ arr: [Double]) -> Double {\n  var unique = Array(Set(arr))\n  if arr[0] == arr[arr.count-1] {\n    unique = unique.filter {$0 != arr[0]} \n  }\n  else {\n    unique = unique.filter {$0 != arr[1]} \n  }\n  print(unique[0])\n  return unique[0]\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5861487fdb20cff3ab000030":[{"id":341942,"user_id":null,"body":"func getPairData(_ s: [Int]) -> [(Int,Int)?]{\n    func getPairWithIndex(_ index: Int) -> Int?{\n        var needPair: Int = 0\n        for i in index..<s.count{\n            let c = Array(s)[i]\n            if c == 5{\n                needPair += 1\n            }\n            if c == 6{\n                if needPair > 0{\n                    needPair -= 1\n                }else{\n                    return i\n                }\n            }\n            continue\n        }\n        return nil\n    }\n    var pairs: [(Int,Int)?] = Array(repeating: nil, count: s.count)\n    for i in 0..<s.count{\n        let c = Array(s)[i]\n        if c == 5{\n            if let pair = getPairWithIndex(i + 1){\n                pairs[i] = (i,pair)\n                pairs[pair] = (i,pair)\n                continue\n            }\n        }\n    }\n    return pairs\n}\n\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n    let inputDatas = input.map({String($0).data(using: .isoLatin1) ?? Data(String($0).utf8)})\n    let inputBits = inputDatas.map({$0.reduce(\"\") { (acc, byte) -> String in\n        let byteStr = String(byte,radix: 2)\n        return acc + String((byteStr.count < 8 ? Array(repeating: \"0\", count: 8 - byteStr.count).joined() + byteStr : byteStr).reversed())\n        }}).joined().compactMap({Int(\"\\($0)\")})\n    var inputIndex: Int = 0\n    \n    var pointers: [Bool] = [false]\n    var pointerIndex: Int = 0\n    \n    var result: String = \"\"\n    var bitBox: [Int] = []\n    var current: Bool{\n        set{\n            pointers[pointerIndex] = newValue\n        }\n        get{\n            return pointers[pointerIndex]\n        }\n    }\n    var readIndex: Int = 0\n    let codeArray = code.compactMap({[\";\",\"+\",\",\",\"<\",\">\",\"[\",\"]\"].firstIndex(of: $0)})\n    let pairData = getPairData(codeArray)\n    \n    while readIndex < codeArray.count {\n        let c = codeArray[readIndex]\n        switch c {\n        case 0:\n            bitBox.append(current ? 1 : 0)\n            readIndex += 1\n        case 1:\n            current.toggle()\n            readIndex += 1\n        case 2:\n            if inputIndex == inputBits.count{\n                pointers[pointerIndex] = false\n            }else{\n                pointers[pointerIndex] = (inputBits[inputIndex]) == 1\n                inputIndex += 1\n            }\n            readIndex += 1\n        case 3:\n            if pointerIndex == 0{\n                pointers.insert(false, at: 0)\n            }else{\n                pointerIndex -= 1\n            }\n            readIndex += 1\n        case 4:\n            pointerIndex += 1\n            if pointerIndex == pointers.count{\n                pointers.append(false)\n            }\n            readIndex += 1\n        case 5:\n            if !current,let forwardIndex = pairData[readIndex]?.1{\n                readIndex = forwardIndex + 1\n            }else{\n                readIndex += 1\n            }\n        case 6:\n            if current,let backIndex = pairData[readIndex]?.0{\n                readIndex = backIndex + 1\n            }else{\n                readIndex += 1\n            }\n        default:\n            readIndex += 1\n            break\n        }\n        if bitBox.count == 8{\n            let byte = UInt8(bitBox.reversed().reduce(0, {$0 << 1 + $1}))\n            let c = Character(Unicode.Scalar.init(byte))\n            result.append(c)\n            bitBox = []\n        }\n    }\n    \n    if bitBox.count > 0{\n        bitBox += Array(repeating: 0, count: 8 - bitBox.count)\n        let byte =  UInt8(bitBox.reversed().reduce(0, {$0 << 1 + $1}))\n        let c = Character(Unicode.Scalar.init(byte))\n        result.append(c)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341943,"user_id":null,"body":"extension UInt8 {\n\t\n\tprivate static let offsets: [UInt8] = [1, 2, 4, 8, 16, 32, 64, 128]\n\t\n\tinit<Bits>(fromBits bits: Bits) where Bits: Sequence, Bits.Iterator.Element == Bool { \/\/ to allow array slices\n\t\tself = 0\n\t\tfor (offset, bit) in zip(UInt8.offsets, bits) {\n\t\t\tif bit {\n\t\t\t\tself += offset\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar bits: [Bool] {\n\t\treturn UInt8.offsets.map { offset in\n\t\t\tself & offset == offset\n\t\t}\n\t}\n}\n\nextension Array where Element == Bool {\n\t\n\tfunc bytes() -> [UInt8] {\n\t\tvar bytes: [UInt8] = []\n\t\tfor i in 0 ..< (count + 7) \/ 8 {\n\t\t\tlet bits = self[8 * i ..< Swift.min(8 * i + 8, count)]\n\t\t\tbytes.append(UInt8(fromBits: bits))\n\t\t}\n\t\treturn bytes\n\t}\n}\n\nextension String {\n\t\n\tfunc asciiBits() -> [Bool] {\n\t\treturn (self.data(using: .isoLatin1) ?? Data()).flatMap {\n\t\t\t$0.bits\n\t\t}\n\t}\n}\n\nclass Tape {\n\t\n\tvar position = 0\n\tvar min = 0\n\tvar max = 0\n\tvar positive: [Bool] = [false]\n\tvar negative: [Bool] = []\n\t\n\tfunc moveRight() {\n\t\tposition += 1\n\t\tif position >= positive.count {\n\t\t\tpositive.append(false)\n\t\t}\n\t\tif position > max {\n\t\t\tmax = position\n\t\t\tprint(\"max:\\t\", max)\n\t\t}\n\t}\n\t\n\tfunc moveLeft() {\n\t\tposition -= 1\n\t\tif -1 - position >= negative.count {\n\t\t\tnegative.append(false)\n\t\t}\n\t\tif position < min {\n\t\t\tmin = position\n\t\t\tprint(\"min:\\t\", min)\n\t\t}\n\t}\n\t\n\tfunc flip() {\n\t\tself[position] = !self[position]\n\t}\n\t\n\tsubscript(index: Int) -> Bool {\n\t\tget {\n\t\t\treturn index >= 0 ? positive[index] : negative[-1 - position]\n\t\t}\n\t\tset {\n\t\t\tif index >= 0 {\n\t\t\t\tpositive[index] = newValue\n\t\t\t} else {\n\t\t\t\tnegative[-1 - index] = newValue\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar current: Bool {\n\t\tget {\n\t\t\treturn self[position]\n\t\t}\n\t\tset {\n\t\t\tself[position] = newValue\n\t\t}\n\t}\n}\n\nenum Instruction: Character {\n\t\n\tcase flip = \"+\"\n\tcase left = \"<\"\n\tcase right = \">\"\n\tcase read = \",\"\n\tcase write = \";\"\n\tcase enter = \"[\"\n\tcase exit = \"]\"\n}\n\nfunc boolfuck(code: String, input: String = \"\") -> String {\n\tlet instructions = code.characters.flatMap { Instruction(rawValue: $0) }\n\tvar inputProvider = input.asciiBits().makeIterator()\n\t\n\tlet tape = Tape()\n\tvar counter = 0\n\tvar jumpbackPoints: [Int] = []\n\tvar matchingBraces: [Int: Int] = [:]\n\t\n\tvar output: [Bool] = []\n\t\n\twhile counter < instructions.count {\n\t\tswitch instructions[counter] {\n\t\tcase .flip:\n\t\t\ttape.flip()\n\t\tcase .read:\n\t\t\ttape.current = inputProvider.next() ?? false\n\t\tcase .write:\n\t\t\toutput.append(tape.current)\n\t\tcase .left:\n\t\t\ttape.moveLeft()\n\t\tcase .right:\n\t\t\ttape.moveRight()\n\t\tcase .enter:\n\t\t\tif !tape.current {\n\t\t\t\tif let match = matchingBraces[counter] {\n\t\t\t\t\tcounter = match\n\t\t\t\t} else {\n\t\t\t\t\tlet start = counter\n\t\t\t\t\tvar level = 0\n\t\t\t\t\tsearch: repeat {\n\t\t\t\t\t\tswitch instructions[counter] {\n\t\t\t\t\t\tcase .exit:\n\t\t\t\t\t\t\tif level == 1 {\n\t\t\t\t\t\t\t\tbreak search\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlevel -= 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase .enter:\n\t\t\t\t\t\t\tlevel += 1\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcounter += 1\n\t\t\t\t\t} while counter < instructions.count\n\t\t\t\t\tmatchingBraces[start] = counter\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjumpbackPoints.append(counter)\n\t\t\t}\n\t\tcase .exit:\n\t\t\tmatchingBraces[jumpbackPoints.last!] = counter\n\t\t\tcounter = jumpbackPoints.popLast()! - 1 \/\/ cheeky - 1\n\t\t}\n\t\tcounter += 1\n\t}\n\t\/\/print(output)\n\treturn String(bytes: output.bytes(), encoding: .isoLatin1)!\n}\n\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n\treturn boolfuck(code: code, input: input)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341944,"user_id":null,"body":"\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n  let fucker = BoolFucker(code: code, input: input)\n  return String(data: Data(fucker.stream), encoding: .isoLatin1) ?? \"\"\n}\n\nclass TapeNode {\n  var bit: Bool\n  var next: TapeNode?\n  var prev: TapeNode?\n  \n  init(bit: Bool? = nil, next: TapeNode? = nil, prev: TapeNode? = nil) {\n    self.bit = bit ?? false\n    self.next = next\n    self.prev = prev\n  }\n}\n\nclass Tape {\n    var root: TapeNode?\n  \n    init() {\n      \/\/root = TapeNode(bit: false)  \n    }\n  \n  func write(bit: Bool) {\n    if nil == root {\n      root = TapeNode()\n    }\n    \n    root!.bit = bit\n  }\n  \n  func toggle() {\n    if nil == root {\n      root = TapeNode(bit: false)\n    }\n    root!.bit.toggle()\n  }\n    \n    func next() {\n        if nil == root {\n            root = TapeNode(bit: false)\n            return\n        }\n      let c = root\n        root = root?.next ?? TapeNode(bit: nil, prev: root)\n      c?.next = root\n    }\n    \n    func prev() {\n        if nil == root {\n            root = TapeNode(bit: false)\n            return\n        }\n        let c = root\n        root = root?.prev ?? TapeNode(bit: nil, next: root)\n        c?.prev = root\n    }\n    \n    func debug() {\n        guard var start = root else { return }\n        \n        while nil != start.prev && nil != start.prev?.bit {\n            start = start.prev!\n        }\n        var output = \"\"\n        repeat {\n          output += (start.bit ?? false) ? \"1\" : \"0\"\n          if output.count > 0, output.count % 8 == 0 {\n            output += \" \"\n          }\n            if let n = start.next {\n              start = n              \n            }\n        } while nil != start.next && start.bit != nil\n    }\n}\n\nclass BoolFucker {\n  \/\/ 00101010 = *\n  var tape = Tape()\n  \n  var stream = [UInt8]()\n  private var code: String\n  private var input: Data\n  private var pointer = 0\n  private var streamPointer = 0\n  private var current = false\n  \n  init(code: String, input: String) {\n    self.code = code\n    self.input = input.data(using: .isoLatin1) ?? Data()\n    fuck()\n  }\n  \n  private func fuck() {\n    var codePointer = code.startIndex\n    while codePointer < code.endIndex {\n      let instruction = code[codePointer]\n      switch instruction {\n        case \"+\":\n              tape.toggle()\n              current = tape.root?.bit ?? false\n        case \",\":\n              current = read()\n          \n              tape.write(bit: current)\n        case \";\":\n              writeStream(bit: tape.root?.bit ?? false)\n        case \"<\":\n              tape.prev()\n              current = tape.root?.bit ?? false\n        case \">\":\n              tape.next()\n              current = tape.root?.bit ?? false\n        case \"[\":\n          if !current {\n            var needed = 1\n            while needed != 0 {\n              codePointer = code.index(after: codePointer)\n              if code[codePointer] == \"[\" {\n                needed += 1\n              }\n              if code[codePointer] == \"]\" {\n                needed -= 1\n              }\n            }\n          }\n        case \"]\":\n          if current {\n            var needed = 1\n            while needed != 0 {\n              codePointer = code.index(before: codePointer)\n              if code[codePointer] == \"]\" {\n                needed += 1\n              }\n              if code[codePointer] == \"[\" {\n                needed -= 1\n              }\n            }\n\n          }\n        default: break\n      }\n        codePointer = code.index(after: codePointer)        \n    }\n      tape.debug()\n  }\n  \n  func writeStream(bit: Bool) {\n    let bytePosition = streamPointer \/ 8\n    if bytePosition >= stream.count {\n      stream.append(0)\n    }\n    let bitPosition = streamPointer % 8\n    let mask: UInt8 = (bit ? 1 : 0) << bitPosition\n    let currentByte = stream[bytePosition]\n    stream[bytePosition] = currentByte | mask\n    \n    streamPointer += 1\n  }\n  \n  func read() -> Bool {\n    guard pointer >= 0, pointer < input.count * 8 else {\n      return false\n    }\n    \n    let bytePosition = pointer \/ 8\n    let bitPosition = pointer % 8\n    let mask: UInt8 = 1 << UInt8(bitPosition)\n    \n    pointer += 1\n    return (input[bytePosition] & mask) != 0\n  }\n}\n\n\n\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341945,"user_id":null,"body":"func boolfuck(_ code: String, _ input: String = \"\") -> String {\n  let codeArr: [String] = code.map{ String($0) }\n  var codeP: Int = 0\n  var inputBin = input.map{ String(UnicodeScalar(String($0))!.value, radix: 2) }\n  inputBin = inputBin.flatMap{ String(String(String(repeating: \"0\", count: 8 - $0.count) + $0).reversed()).map { String($0) } }\n  var inputP: Int = 0\n  var data: [Int] = [0]\n  var dataP: Int = 0\n  var outputStream: String = \"\"\n  var output: String = \"\"\n  \n  print(\"Input: \\(input)\n\\(inputBin)\")\n  print(\"Code: \\(code)\")\n  \n  while codeP < codeArr.count {\n    switch codeArr[codeP] {\n      case \">\":\n        dataP += 1\n        if dataP == data.count { data.append(0) }      \n      case \"<\":\n        dataP -= 1\n        if dataP < 0 { \n          data.insert(0, at: 0) \n          dataP = 0\n        }\n      case \"+\":\n        data[dataP] = abs(data[dataP] - 1)\n      case \"[\":\n        if data[dataP] == 0 {\n          var bracketCounter: Int = 1\n          while bracketCounter > 0 {\n            codeP += 1\n            if codeArr[codeP] == \"[\" { bracketCounter += 1 }\n            else if codeArr[codeP] == \"]\" { bracketCounter -= 1 }\n          }\n        }\n      case \"]\":\n        if data[dataP] != 0 {\n          var bracketCounter: Int = 1\n          while bracketCounter > 0 {\n            codeP -= 1\n            if codeArr[codeP] == \"]\" { bracketCounter += 1 }\n            else if codeArr[codeP] == \"[\" { bracketCounter -= 1 }\n          }\n        }\n      case \",\":\n        if inputP < inputBin.count {\n          data[dataP] = Int(inputBin[inputP])!\n          inputP += 1\n        } else {\n          data[dataP] = 0\n        }\n      case \";\":\n        outputStream += String(data[dataP])\n      default:\n        break\n    }\n    codeP += 1\n  }  \n  \n  while outputStream.count % 8 != 0 {\n    outputStream += \"0\"\n  }\n  \n  print(outputStream)\n  var byte: String = \"\"\n  for bit in outputStream {    \n    byte += String(bit)\n    if byte.count == 8 {\n      print(byte)\n      print(Int(String(byte.reversed()), radix: 2)!)\n      print(\"\n---\n\")\n      output += (String(UnicodeScalar(Int(String(byte.reversed()), radix: 2)!)!))\n      byte = \"\"\n    }\n  }\n  print(output)\n  print(\"\n\n=======\n\n\")\n  return output\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341946,"user_id":null,"body":"enum Command : Character {\n  case moveRight = \">\"\n  case moveLeft = \"<\"\n  case fip = \"+\"\n  case openBrackets = \"[\"\n  case closeBrackets = \"]\"\n  case readBit = \",\"\n  case outputBit = \";\"\n}\n\nfunc boolfuck(_ code: String, _ userInput: String = \"\") -> String {\n  let (commands, openToCloseMap, closeToOpenMap) = analyseCode(code)\n\n  let input = userInput.data(using: .isoLatin1)!\n  var bitsRead = 0\n  var output = [UInt8]()\n  var bitsWritten = 0\n  let byteSize = 8\n  \n  var pointer = 0\n  var memory = [Int : Bool]()\n\n  var i = 0\n  while i < commands.count {\n    switch commands[i] {\n        case .none: break\n        case .moveRight:\n          pointer += 1\n        case .moveLeft:\n          pointer -= 1\n        case .fip: \n          memory[pointer] = !(memory[pointer] ?? false)\n        case .openBrackets: \n          if (!(memory[pointer] ?? false)) {\n            i = openToCloseMap[i]!            \n          }\n        case .closeBrackets:\n          if ((memory[pointer] ?? false)) {\n            i = closeToOpenMap[i]!\n          }\n        case .readBit:\n          let index = bitsRead \/ byteSize\n          let byte : UInt8 = index < 0 || index >= input.count ? 0 : input[index]\n          let bit = byte & UInt8(1) << ( bitsRead % byteSize )\n          memory[pointer] = bit != 0\n          bitsRead += 1\n        case .outputBit:\n          let index = bitsWritten \/ byteSize\n          if index >= output.count { output.append(0) }\n          let value: UInt8 = memory[pointer] == true ? 1 : 0\n          let byte = output[index] | value << (bitsWritten % byteSize )\n          output[index] = byte\n          bitsWritten += 1\n      }\n    i += 1\n  }\n  \n  return String(bytes: output, encoding: .isoLatin1)!\n}\n\nfunc analyseCode(_ code:String) -> ([Command?], [Int:Int], [Int: Int]) {\n  var openToCloseMap = [Int:Int]()\n  var closeToOpenMap = [Int:Int]()\n  var openStack = [Int]()\n  let commands : [Command?] = code.enumerated().map { tuple in\n    let (i, c) = tuple\n    let command = Command(rawValue:c)\n                                 \n    switch command {\n     case .openBrackets:\n        openStack.append(i)\n     case .closeBrackets:\n        let oi = openStack.removeLast()\n        openToCloseMap[oi] = i\n        closeToOpenMap[i] = oi\n     default: break\n    }\n                                                     \n    return command\n  }\n  \n  return (commands, openToCloseMap, closeToOpenMap)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341947,"user_id":null,"body":"\nextension BinaryInteger {\n\tsubscript(bit bit: Int) -> Bool {\n\t\tget {\n\t\t\tlet mask: Self = 1 << (Self(bit) % 8)\n\t\t\treturn (self & mask) == mask\n\t\t}\n\t\tset {\n\t\t\tlet mask: Self = 1 << (Self(bit) % 8)\n\t\t\tif newValue {\n\t\t\t\tself |= mask\n\t\t\t} else {\n\t\t\t\tself &= ~mask\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n\tvar tape: [UInt8] = [0]\n\tvar currentBit = 0\n  \n  print(\"\\(code), \\(input)\")\n\n\tfunc move(direction: Int) {\n\t\tswitch direction {\n\t\tcase 1:\n\t\t\tcurrentBit += 1\n\t\t\tif currentBit \/ 8 == tape.count {\n\t\t\t\ttape.append(0)\n\t\t\t}\n\t\tcase -1:\n\t\t\tcurrentBit -= 1\n\t\t\tif currentBit < 0 {\n\t\t\t\ttape.insert(0, at: 0)\n\t\t\t\tcurrentBit += 8\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar currentBitValue: Bool {\n\t\tget {\n\t\t\treturn tape[currentBit \/ 8][bit: currentBit % 8]\n\t\t}\n\t\tset {\n\t\t\ttape[currentBit \/ 8][bit: currentBit % 8] = newValue\n\t\t}\n\t}\n\n\tvar codeIndex = code.startIndex\n\tfunc advanceCode() {\n\t\tcodeIndex = code.index(after: codeIndex)\n\t}\n\n\tlet input = (input.data(using: .isoLatin1) ?? Data()).map { $0 }\n\tvar inputBit = 0\n\tfunc readBit() -> Bool {\n\t\tif inputBit \/ 8 == input.count {\n\t\t\treturn false\n\t\t}\n\t\tdefer {\n\t\t\tinputBit += 1\n\t\t}\n\t\treturn input[inputBit \/ 8][bit: inputBit % 8]\n\t}\n\n\tvar output: [UInt8] = []\n\tvar outputBit = 0\n\n\tfunc writeBit(_ bit: Bool) {\n\t\tif outputBit \/ 8 == output.count {\n\t\t\toutput.append(0)\n\t\t}\n\t\toutput[outputBit \/ 8][bit: outputBit % 8] = bit\n\t\toutputBit += 1\n\t}\n\n\twhile codeIndex < code.endIndex {\n\t\tswitch code[codeIndex] {\n\t\tcase \"<\":\n\t\t\tmove(direction: -1)\n\t\t\tadvanceCode()\n\t\tcase \">\":\n\t\t\tmove(direction: 1)\n\t\t\tadvanceCode()\n\t\tcase \"+\":\n\t\t\tcurrentBitValue.toggle()\n\t\t\tadvanceCode()\n\t\tcase \",\":\n\t\t\tcurrentBitValue = readBit()\n\t\t\tadvanceCode()\n\t\tcase \";\":\n\t\t\twriteBit(currentBitValue)\n\t\t\tadvanceCode()\n\t\tcase \"[\":\n\t\t\tif currentBitValue {\n\t\t\t\tadvanceCode()\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tadvanceCode()\n\n\t\t\tvar count = 0\n\t\t\twhile codeIndex < code.endIndex && (code[codeIndex] != \"]\" || count > 0) {\n\t\t\t\tif code[codeIndex] == \"[\" {\n\t\t\t\t\tcount += 1\n\t\t\t\t} else if code[codeIndex] == \"]\" {\n\t\t\t\t\tcount -= 1\n\t\t\t\t}\n\t\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\t\t}\n\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\tcase \"]\":\n\t\t\tif !currentBitValue {\n\t\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tvar count = 0\n\t\t\tcodeIndex = code.index(before: codeIndex)\n\t\t\twhile codeIndex >= code.startIndex && (code[codeIndex] != \"[\" || count > 0) {\n\t\t\t\tif code[codeIndex] == \"]\" {\n\t\t\t\t\tcount += 1\n\t\t\t\t} else if code[codeIndex] == \"[\" {\n\t\t\t\t\tcount -= 1\n\t\t\t\t}\n\t\t\t\tcodeIndex = code.index(before: codeIndex)\n\t\t\t}\n\t\tdefault:\n\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\t}\n\t}\n\treturn output.map { String(Character(Unicode.Scalar($0))) }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341948,"user_id":null,"body":"class BitStream {\n  private var data: [UInt8]\n\n  private var byteIndex: Int!\n  private var bitIndex: Int!\n\n  private let flexibleMargin: Bool\n\n  convenience init(flexibleMargin: Bool = false) {\n    self.init(data: [], flexibleMargin: flexibleMargin)\n  }\n\n  init(data: [UInt8], flexibleMargin: Bool = false) {\n    self.data = data\n    self.flexibleMargin = flexibleMargin\n    reset()\n  }\n\n  func rawData() -> Data {\n    return Data(data)\n  }\n\n  func get() -> Int? {\n    guard 0..<data.count ~= byteIndex else {\n      return nil\n    }\n    return Int((data[byteIndex] >> bitIndex) & 1)\n  }\n\n  func set(_ bit: Int) {\n    if data.isEmpty {\n      data.append(0)\n    }\n\n    data[byteIndex] = bit != 0\n      ? data[byteIndex] | (UInt8(1) << bitIndex)\n      : data[byteIndex] & ~(UInt8(1) << bitIndex)\n  }\n\n  func flip() {\n    set((get() ?? 0) == 0 ? 1 : 0)\n  }\n\n  func hasLeft() -> Bool {\n    return 0..<data.count ~= leftBitByteIndex\n  }\n\n  func moveLeft() {\n    guard !data.isEmpty && 0..<data.count ~= byteIndex else {\n      return\n    }\n    byteIndex = leftBitByteIndex\n    bitIndex = leftBitBitIndex\n    if byteIndex == -1 && flexibleMargin {\n      byteIndex = 0\n      data.insert(0, at: 0)\n    }\n  }\n\n  func hasRight() -> Bool {\n    return 0..<data.count ~= rightBitByteIndex\n  }\n\n  func moveRight() {\n    guard !data.isEmpty && 0..<data.count ~= byteIndex else {\n      return\n    }\n    byteIndex = rightBitByteIndex\n    bitIndex = rightBitBitIndex\n    if byteIndex == data.count && flexibleMargin {\n      data.append(0)\n    }\n  }\n\n  func reset() {\n    byteIndex = 0\n    bitIndex = 0\n  }\n\n  private var leftBitBitIndex: Int { (bitIndex + 7) & 7 }\n  private var leftBitByteIndex: Int { byteIndex - (bitIndex == 0 ? 1 : 0) }\n  private var rightBitBitIndex: Int { (bitIndex + 1) & 7 }\n  private var rightBitByteIndex: Int { byteIndex + (bitIndex == 7 ? 1 : 0) }\n}\n\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n  print(code)\n  print(input)\n  let cod = Array(code)\n  var ip = 0\n\n  let inputData: [UInt8] = input.data(using: .isoLatin1)?.map { UInt8($0) } ?? []\n  let inputStream: BitStream = BitStream(data: inputData)\n\n  let dataStream: BitStream = BitStream(flexibleMargin: true)\n\n  let outputStream: BitStream = BitStream(flexibleMargin: true)\n  outputStream.moveLeft()\n\n  var stack: [Int] = []\n  var skipLevel: Int = 0\n\n  while ip < cod.count {\n    let cmd = cod[ip]\n    ip += 1\n    guard skipLevel == 0 else {\n      switch cmd {\n        case \"[\": skipLevel += 1\n        case \"]\": skipLevel -= 1\n        default: ()\n      }\n      continue\n    }\n    switch cmd {\n      case \">\": dataStream.moveRight()\n      case \"<\": dataStream.moveLeft()\n      case \"+\": dataStream.flip()\n      case \",\":\n        guard let bit = inputStream.get() else {\n            dataStream.set(0)\n            continue\n        }\n        dataStream.set(bit)\n        inputStream.moveRight()\n      case \";\": outputStream.moveRight(); outputStream.set(dataStream.get() ?? 0)\n      case \"[\":\n        guard (dataStream.get() ?? 0) != 0 else {\n          skipLevel = 1\n          continue\n        }\n        stack.append(ip - 1)\n      case \"]\": ip = stack.popLast()!\n      default: ()\n    }\n  }\n\n  return String(data: outputStream.rawData(), encoding: .isoLatin1) ?? \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341949,"user_id":null,"body":"func intToBitString(_ byte : UInt8) -> String{\n    var retString = \"\"\n    var mbyte = byte\n    for _ in 0..<mbyte.bitWidth{\n        retString += ((mbyte & 1) != 0) ? \"1\" : \"0\"\n        mbyte >>= 1\n    }\n    return retString\n}\nfunc findBrace(_ arrCommand : [Character], _ pos : Int, _ baseBrace : Character, _ braceToFind : Character, _ leftToRight : Bool) -> Int{\n    var sumCnt = 0\n    \n    for i in (leftToRight) ? stride(from: pos, to: arrCommand.count, by: 1) : stride(from: pos, to: 0, by: -1){\n        if (arrCommand[i] == baseBrace){\n            sumCnt += 1\n        } else if (arrCommand[i] == braceToFind){\n            sumCnt -= 1\n        }\n        if (sumCnt == 0){\n            return i\n        }\n    }\n    \n    return pos\n}\nfunc outputToBytes(output: String) -> String{\n    var index = output.startIndex\n    var tmpArray : [UInt8] = []\n    var result: String\n\n    let divRem = output.count % 8\n\n    for i in 0..<output.count\/8 {\n        let nextIndex = output.index(index, offsetBy: 8)\n        var stringSlice = output[index..<nextIndex]\n        let charBits = String(stringSlice.reversed())\n        tmpArray.append(UInt8(charBits, radix: 2)!)\n        index = nextIndex\n    }\n\n    if (divRem != 0){\n        var stringSlice = output[index...]\n        for _ in 0...divRem+1 {\n            stringSlice.insert(\"0\", at: stringSlice.endIndex)\n        }\n        let charBits = String(stringSlice.reversed())\n        tmpArray.append(UInt8(charBits, radix: 2)!)\n    }\n\n    return String(data: Data(bytes: tmpArray), encoding: .isoLatin1) ?? \"\"\n}\n\n\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n    var outputStream = \"\"\n    let data = input.data(using: .isoLatin1) ?? Data()\n    let inputBytes = [UInt8](data)\n    let bitString = inputBytes.map{intToBitString($0)}.joined()\n\n    var arrBitString = Array(bitString)\n    var tape : [Character] = [\"0\"]\n    var tapePointer : Int = 0\n    var indexCommand = 0\n    let arrCommand = code.map { $0 }\n\n    while indexCommand < arrCommand.count {\n        let cmd = arrCommand[indexCommand]\n\n        switch cmd {\n        case \">\":\n            tapePointer += 1\n            if (tapePointer == tape.count){\n                tape.append(contentsOf: [\"0\"])\n            \n            }\n\n        case \"<\":\n            tapePointer -= 1\n            if (tapePointer < 0){\n                \/\/tape.insert(contentsOf: [\"0\"], at: 0)\n                \/\/tapePointer = 0\n                tape.insert(contentsOf: String.init(repeating: \"0\", count: 512), at: 0)\n                tapePointer = 512\n            }\n        case \"+\":\n            tape[tapePointer] = (tape[tapePointer] == \"1\") ? \"0\" : \"1\"\n        case \"[\":\n            if tape[tapePointer] == \"0\" {\n                indexCommand = findBrace(arrCommand, indexCommand, \"[\", \"]\", true) - 1\n            }\n        case \"]\":\n            if tape[tapePointer] == \"1\" {\n                indexCommand = findBrace(arrCommand, indexCommand, \"]\", \"[\", false) - 1\n            }\n        case \",\":\n            if (arrBitString.count == 0){\n                tape[tapePointer] = \"0\"\n            } else {\n                tape[tapePointer] = arrBitString.removeFirst()\n            }\n\n        case \";\":\n            outputStream += String(tape[tapePointer])\n        default:\n            break\n        }\n\n        indexCommand += 1\n    }\n\n\n    return outputToBytes(output: outputStream)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341950,"user_id":null,"body":"struct BitArray {\n    \n    var data        : [UInt8]\n    let countBit   : Int\n\n    init( _ buffer: [UInt8] ) {\n        data     = buffer\n        countBit = data.count*8\n    }\n    \n    init( _ count: Int ) {\n        \n        countBit = count\n        let helper = countBit.quotientAndRemainder(dividingBy: 8)\n        data = [UInt8](repeating: 0, count: helper.quotient + ( helper.remainder > 0 ? 1 : 0 ) )\n    }\n    \n    subscript(index: Int) -> Bool {\n        get {\n            let helper = index.quotientAndRemainder(dividingBy: 8)\n            return data[helper.quotient] & 1<<helper.remainder > 0\n        }\n        \n        set(newValue) {\n            let helper = index.quotientAndRemainder(dividingBy: 8)\n            \n            if ( newValue ) {\n                data[helper.quotient] |= 1<<helper.remainder\n                return \n            } \n\n            data[helper.quotient] &= ~(1<<helper.remainder)\n        }\n    }\n}\n\nextension BitArray : RandomAccessCollection {\n    var startIndex: Int {\n        return 0\n    }\n    \n    var endIndex: Int {\n        return self.countBit\n    }\n    \n}\n\n\n\/\/+ - Flips the value of the bit under the pointer\n\/\/, - Reads a bit from the input stream, storing it under the pointer. The end-user types information using characters, though. Bytes are read in little-endian order\u2014the first bit read from the character a, for instance, is 1, followed by 0, 0, 0, 0, 1, 1, and finally 0. If the end-of-file has been reached, outputs a zero to the bit under the pointer.\n\/\/; - Outputs the bit under the pointer to the output stream. The bits get output in little-endian order, the same order in which they would be input. If the total number of bits output is not a multiple of eight at the end of the program, the last character of output gets padded with zeros on the more significant end.\n\/\/< - Moves the pointer left by 1 bit\n\/\/> - Moves the pointer right by 1 bit\n\/\/[ - If the value under the pointer is 0 then skip to the corresponding ]\n\/\/] - Jumps back to the matching [ character, if the value under the pointer is 1\n\n\nclass Tape {\n    \n    var data            : BitArray\n    var instruction     : [Character]\n    var inputs          : BitArray\n    var output          : BitArray\n    \n    var instructionPointer      :  Int = 0\n    var dataPointer             :  Int = 0\n    var outputPointer           :  Int = 0\n    var inputPointer            :  Int = 0\n\n    let     bracketOpen         = Character(\"[\")\n    let     bracketClose        = Character(\"]\")\n\n    \n    init( _ program: String, _ input: String ) {\n        \n        instruction         = program.map{$0}\n        instructionPointer  = 0\n\n        data                = BitArray(30000)\n        dataPointer         = 15000\n        \n        inputs              = BitArray(input.map{ $0.unicodeScalars.reduce( UInt8(0), { $0.addingReportingOverflow(UInt8($1.value)).partialValue } )})\n        inputPointer        = inputs.startIndex\n        \n        output              = BitArray(30000)\n        outputPointer       = output.startIndex\n        \n        \/\/print( instruction )\n    }\n\n    func description() {\n        print( \"memory Block -> \\(data[dataPointer])\")\n    }\n    \n    func inf () -> Bool {\n        dataPointer = dataPointer.advanced(by: -1)\n        return true\n    }\n\n    func sup () -> Bool {\n        dataPointer = dataPointer.advanced(by: 1)\n        return true\n    }\n\n    func plus () -> Bool {\n        data[dataPointer] = !data[dataPointer]\n        \/\/print( \"+ -> \\(description())\" )\n        return true\n    }\n    \n    \/\/; - Outputs the bit under the pointer to the output stream. The bits get output in little-endian order, the same order in which they would be input. If the total number of bits output is not a multiple of eight at the end of the program, the last character of output gets padded with zeros on the more significant end.\n    func semicolon () -> Bool {\n       output[outputPointer] = data[dataPointer]\n       outputPointer = outputPointer.advanced(by: 1)\n       return true\n    }\n    \/\/, - Reads a bit from the input stream, storing it under the pointer. The end-user types information using characters, though. Bytes are read in little-endian order\u2014the first bit read from the character a, for instance, is 1, followed by 0, 0, 0, 0, 1, 1, and finally 0. If the end-of-file has been reached, outputs a zero to the bit under the pointer.\n    func comma () -> Bool {\n\n        if (inputs.startIndex..<inputs.endIndex).contains(inputPointer)  {\n            data[dataPointer] = inputs[inputPointer]\n            inputPointer = inputPointer.advanced(by: 1)\n            return true\n        }\n      \n        data[dataPointer] = false\n\n        \/\/print( \", -> \\(description()) -> \\(inputs)\" )\n\n        return true\n    }\n    \n    \/\/[ - If the value under the pointer is 0 then skip to the corresponding ]\n    func bracketIn () -> Bool {\n        \/\/print( memory[dataPointer] )\n        if data[dataPointer]  == false {\n\n            \/\/print(\" range looking up \\(instructionPointer..<instructions.upperBound) \")\n            var openedBracket = 0\n                \n            for idx in (instructionPointer+1)..<instruction.endIndex {\n                \n                if instruction[idx] == bracketOpen {\n                    openedBracket += 1\n                }\n                \n                if instruction[idx]  == bracketClose  {\n                    \n                    if( openedBracket == 0 ) {\n                        instructionPointer = idx.advanced(by: 1)\n                        \/\/print( \"[ Jump to \\(instructionPointer) -> \\( String(bytes: [memory[instructionPointer]], encoding: .utf8)! )\" )\n\n                        return false;\n                    }\n\n                    openedBracket -= 1\n                }\n            }\n            \n        }\n        \n        return true\n    }\n    \n    \/\/] - Jumps back to the matching [ character, if the value under the pointer is 1\n    func bracketOut () -> Bool {\n        \/\/print( memory[dataPointer] )\n        if data[dataPointer] {\n            \n            \/\/print(\" range looking up \\(instructions.lowerBound..<instructionPointer).reversed() \")\n            var closedBracket = 0\n\n            for idx in (instruction.startIndex..<instructionPointer).reversed() {\n\n                if instruction[idx] == bracketClose {\n                    \/\/print( \"found barcketclose \\(memory[idx])\" )\n                    closedBracket += 1\n                }\n\n                \n                if instruction[idx] == bracketOpen {\n                    \n                    if closedBracket == 0 {\n                        instructionPointer = idx.advanced(by: 1)\n\n                        \/\/print( \"] Jump to \\(instructionPointer) -> \\( String(bytes: [memory[instructionPointer]], encoding: .utf8)! )\" )\n                        return false;\n                    }\n\n                    closedBracket -= 1\n                }\n            }\n        }\n        \n        return true\n    }\n\n    \n    func run() -> String {\n        \n        \n        while (  instructionPointer < instruction.endIndex ) {\n            \n             switch instruction[instructionPointer] {\n                case \">\" :\n                    if sup() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                case \"<\" :\n                    if inf() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                case \"+\" :\n                    if plus() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                case \",\" :\n                    if comma() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                case \";\" :\n                    if semicolon() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                \n                case \"[\" :\n                    if bracketIn() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                case \"]\" :\n                    if bracketOut() { instructionPointer = instructionPointer.advanced(by: 1) }\n                    break\n                \n                \n                default:\n                    instructionPointer = instructionPointer.advanced(by: 1)\n                    break\n              }\n        }\n        \n        let position = outputPointer.quotientAndRemainder(dividingBy: 8)\n        let endOuput = position.quotient + (position.remainder > 0 ? 1 : 0)\n        return String(bytes: output.data[0..<endOuput], encoding: .isoLatin1 ) ?? \"\"\n    }\n    \n}\n\nfunc boolfuck(_ code: String, _ input: String = \"\") -> String {\n  \n\/\/      print( \"\\(code) -> \\(input)\")\n\/\/     return code\n    return Tape(code, input).run()\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341951,"user_id":464,"body":"func boolfuck(_ code: String, _ input: String = \"\") -> String {\n    let code = code.map(String.init)\n    let input: [Bool] = input.flatMap { \n      String($0.unicodeScalars.first!.value, radix: 2)\n        .reversed().map(String.init).joined()\n        .padding(toLength: 8, withPad: \"0\", startingAt: 0)\n        .map { $0 == \"1\" ? true : false} \n    }\n    var pointer = 0\n    var instructionPointer = 0\n    var inputPointer = 0\n    var setBits = Dictionary<Int, Bool>()\n    var outputStream: [Bool] = []\n    while instructionPointer >= 0 &&\n            instructionPointer < code.count {\n        switch code[instructionPointer] {\n        case \",\":\n            if inputPointer < input.count {\n                setBits[pointer] = input[inputPointer]\n                inputPointer += 1\n            }\n            else {\n                setBits[pointer] = false\n            }\n        case \";\":\n            outputStream.append(setBits[pointer] ?? false)\n        case \"+\":\n            setBits[pointer] = (setBits[pointer] ?? false) ? false : true\n        case \"[\":\n            if !(setBits[pointer] ?? false) {\n                var level = 1\n                while level != 0 {\n                    instructionPointer += 1\n                    if code[instructionPointer] == \"[\" {\n                        level += 1\n                    }\n                    if code[instructionPointer] == \"]\" {\n                        level -= 1\n                    }\n                }\n            }\n        case \"]\":\n            if setBits[pointer] ?? false {\n                var level = 1\n                while level != 0 {\n                    instructionPointer -= 1\n                    if code[instructionPointer] == \"[\" {\n                        level -= 1\n                    }\n                    if code[instructionPointer] == \"]\" {\n                        level += 1\n                    }\n                }\n            }\n        case \">\":\n            pointer += 1\n        case \"<\":\n            pointer -= 1\n        default:\n            break\n        }\n        instructionPointer += 1\n    }\n    let outputStreamString: [Character] = outputStream.map { $0 ? \"1\" : \"0\" }\n    let binary: [Int] = splitInBytes(outputStreamString).map {\n        Int($0.padding(toLength: 8, withPad: \"0\", startingAt: 0)\n            .reversed().map(String.init).joined(), radix: 2)!\n    }\n    return binary.map { String(Character(UnicodeScalar($0)!)) }.joined()\n}\n\nfunc splitInBytes(_ binString: [Character]) -> [String] {\n    return stride(from: 0, to: binString.count, by: 8).map {\n        binString[$0 ..< Swift.min($0 + 8, binString.count)].map(String.init).joined()\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5862fb364f7ab46270000078":[{"id":341952,"user_id":null,"body":"func encrypt(text: String, rule: Int) -> String {\n    var encryptedCharacterArray = text.unicodeScalars.map { (scalar) -> Character in\n        var asciiValue = Int(scalar.value) + rule\n        if asciiValue > 255 { asciiValue %= 256 }\n        let characterString = String(describing: UnicodeScalar(asciiValue)!)\n        return characterString[characterString.startIndex]\n    }\n    return String(encryptedCharacterArray)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341953,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n  return text.unicodeScalars.map({\n     String(UnicodeScalar(((Int($0.value) + rule) % 256))!)\n  }).reduce(\"\",+)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341954,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n    var answerString = \"\"\n    for character in text.characters {\n        let asciiValue =  (Int((UnicodeScalar(String(character))!).value) + rule) % 256\n        let newCharacter = Character(UnicodeScalar.init(asciiValue)!)\n        answerString += String( newCharacter)\n    }\n    return answerString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341955,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n  String(bytes: text.map { UInt8((Int($0.asciiValue ?? 0) + rule) % 256) }, encoding: .ascii)!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341956,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n    return String(Array(text).map{ char in\n        let value = char.asciiValue! + UInt32(rule) \n        let scalar = Unicode.Scalar (value >= 255 ? value % 256 : value)!\n        return Character(scalar)\n    })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341957,"user_id":null,"body":"extension Character {\n    var isAscii: Bool {\n        return unicodeScalars.allSatisfy { $0.isASCII }\n    }\n    var ascii: UInt32? {\n        return isAscii ? unicodeScalars.first?.value : nil\n    }\n}\n\nfunc encrypt(text:String, rule:Int) -> String {\n  var result: String = \"\"\n  var v: Int = 0\n  \n  for char in text {\n    v = Int(Character(String(char)).ascii ?? 0) + rule\n    if v > 255 {\n      v = (v%256)\n    }\n    result += String(UnicodeScalar(UInt8(v)))\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341958,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n    return String(text.map({Character(UnicodeScalar((Int($0.asciiValue!) + rule) % 256)!)}))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341959,"user_id":null,"body":"func encrypt(text: String, rule: Int) -> String {\n  String(\n    text\n      .compactMap { $0.asciiValue }\n      .map { ($0 + UInt32(rule)) % 256 }\n      .compactMap { Unicode.Scalar($0) }\n      .map { Character($0) }\n  )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341960,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n  String(text.utf8.map { Character(UnicodeScalar(UInt8((Int($0) + rule) % 256))) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341961,"user_id":null,"body":"func encrypt(text:String, rule:Int) -> String {\n  let asciiTotal = 256\n  var result = \"\"\n  \n  for letter in text {\n    guard let asciiValue = letter.asciiValue else {\n      return result\n    }\n    let modValue = (Int(asciiValue) + rule) % asciiTotal\n    let encryptedChar = Character(UnicodeScalar(modValue)!)\n    result += String(encryptedChar)\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"586538146b56991861000293":[{"id":341962,"user_id":null,"body":"func toNato(_ words: String) -> String {\n    return words.lowercased().compactMap { dict[$0] }.joined(separator: \" \")\n}\n\nlet dict: [Character: String] = [\n    \"a\": \"Alfa\",\n    \"b\": \"Bravo\",\n    \"c\":\"Charlie\",\n    \"d\":\"Delta\",\n    \"e\":\"Echo\",\n    \"f\":\"Foxtrot\",\n    \"g\":\"Golf\",\n    \"h\":\"Hotel\",\n    \"i\":\"India\",\n    \"j\":\"Juliett\",\n    \"k\":\"Kilo\",\n    \"l\":\"Lima\",\n    \"m\":\"Mike\",\n    \"n\":\"November\",\n    \"o\":\"Oscar\",\n    \"p\":\"Papa\",\n    \"q\":\"Quebec\",\n    \"r\":\"Romeo\",\n    \"s\":\"Sierra\",\n    \"t\":\"Tango\",\n    \"u\":\"Uniform\",\n    \"v\":\"Victor\",\n    \"w\":\"Whiskey\",\n    \"x\":\"Xray\",\n    \"y\":\"Yankee\",\n    \"z\":\"Zulu\",\n    \"!\":\"!\",\n    \"?\":\"?\",\n    \".\":\".\",\n    \"(\":\"(\",\n    \")\":\")\",\n    \"\\\"\": \"\\\"\"\n]\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341963,"user_id":null,"body":"func toNato(_ words: String) -> String {\n    var str = \"\"\n    for i in words {\n        switch i.lowercased() {\n        case \"a\":\n            str.append(\"Alfa \")\n        case \"b\":\n            str.append(\"Bravo \")\n        case \"c\":\n            str.append(\"Charlie \")\n        case \"d\":\n            str.append(\"Delta \")\n        case \"e\":\n            str.append(\"Echo \")\n        case \"f\":\n            str.append(\"Foxtrot \")\n        case \"g\":\n            str.append(\"Golf \")\n        case \"h\":\n            str.append(\"Hotel \")\n        case \"i\":\n            str.append(\"India \")\n        case \"j\":\n            str.append(\"Juliett \")\n        case \"k\":\n            str.append(\"Kilo \")\n        case \"l\":\n            str.append(\"Lima \")\n        case \"m\":\n            str.append(\"Mike \")\n        case \"n\":\n            str.append(\"November \")\n        case \"o\":\n            str.append(\"Oscar \")\n        case \"p\":\n            str.append(\"Papa \")\n        case \"q\":\n            str.append(\"Quebec \")\n        case \"r\":\n            str.append(\"Romeo \")\n        case \"s\":\n            str.append(\"Sierra \")\n        case \"t\":\n            str.append(\"Tango \")\n        case \"u\":\n            str.append(\"Uniform \")\n        case \"v\":\n            str.append(\"Victor \")\n        case \"w\":\n            str.append(\"Whiskey \")\n        case \"x\":\n            str.append(\"Xray \")\n        case \"y\":\n            str.append(\"Yankee \")\n        case \"z\":\n            str.append(\"Zulu \")\n        case \"1\":\n            str.append(\"One \")\n        case \"2\":\n            str.append(\"Two \")\n        case \"3\":\n            str.append(\"Three \")\n        case \"4\":\n            str.append(\"Four \")\n        case \"5\":\n            str.append(\"Five \")\n        case \"6\":\n            str.append(\"Six \")\n        case \"7\":\n            str.append(\"Seven \")\n        case \"8\":\n            str.append(\"Eight \")\n        case \"9\":\n            str.append(\"Nine \")\n        case \"0\":\n            str.append(\"Zero \")\n        case \",\":\n            str.append(\", \")\n        case \".\":\n            str.append(\". \")\n        case \"!\":\n            str.append(\"! \")\n        case \"?\":\n            str.append(\"? \")\n        case \"(\":\n            str.append(\"( \")\n        case \")\":\n            str.append(\") \")\n        case \"\\\"\":\n            str.append(\"\\\" \")\n        default:\n            break\n        }\n    }\n    str.removeLast()\n    \n    return str\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341964,"user_id":null,"body":"let telephony : [String: String] = [\n    \"a\": \"Alfa\",\n    \"b\": \"Bravo\",\n    \"c\": \"Charlie\",\n    \"d\": \"Delta\",\n    \"e\": \"Echo\",\n    \"f\": \"Foxtrot\",\n    \"g\": \"Golf\",\n    \"h\": \"Hotel\",\n    \"i\": \"India\",\n    \"j\": \"Juliett\",\n    \"k\": \"Kilo\",\n    \"l\": \"Lima\",\n    \"m\": \"Mike\",\n    \"n\": \"November\",\n    \"o\": \"Oscar\",\n    \"p\": \"Papa\",\n    \"q\": \"Quebec\",\n    \"r\": \"Romeo\",\n    \"s\": \"Sierra\",\n    \"t\": \"Tango\",\n    \"u\": \"Uniform\",\n    \"v\": \"Victor\",\n    \"w\": \"Whiskey\",\n    \"x\": \"Xray\",\n    \"y\": \"Yankee\",\n    \"z\": \"Zulu\",\n    \"1\": \"One\",\n    \"2\": \"Two\",\n    \"3\": \"Three\",\n    \"4\": \"Four\",\n    \"5\": \"Five\",\n    \"6\": \"Six\",\n    \"7\": \"Seven\",\n    \"8\": \"Eight\",\n    \"9\": \"Nine\",\n    \"0\": \"Zero\",\n]\nimport Foundation\nfunc toNato(_ words: String) -> String {\n    return words.map{telephony.keys.contains(String($0).lowercased()) ? (telephony[String($0).lowercased()]!) : String($0)}.joined(separator: \" \").split(separator: \" \").joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341965,"user_id":null,"body":"func toNato(_ words: String) -> String {\n    let word = words.replacingOccurrences(of: \" \", with: \"\").uppercased()\n    var translation = \"\"\n    \n    for char in word {\n        let nato = dictionary[String(char)]\n        let charAsString = String(char)\n        translation.append(nato ?? charAsString)\n        translation.append(\" \")\n    }\n    \n    return translation.trimmingCharacters(in: .whitespaces)\n}\n\nlet dictionary: [String : String] = [\n    \"A\": \"Alfa\",\n    \"B\": \"Bravo\",\n    \"C\": \"Charlie\",\n    \"D\": \"Delta\",\n    \"E\": \"Echo\",\n    \"F\": \"Foxtrot\",\n    \"G\": \"Golf\",\n    \"H\": \"Hotel\",\n    \"I\": \"India\",\n    \"J\": \"Juliett\",\n    \"K\": \"Kilo\",\n    \"L\": \"Lima\",\n    \"M\": \"Mike\",\n    \"N\": \"November\",\n    \"O\": \"Oscar\",\n    \"P\": \"Papa\",\n    \"Q\": \"Quebec\",\n    \"R\": \"Romeo\",\n    \"S\": \"Sierra\",\n    \"T\": \"Tango\",\n    \"U\": \"Uniform\",\n    \"V\": \"Victor\",\n    \"W\": \"Whiskey\",\n    \"X\": \"Xray\",\n    \"Y\": \"Yankee\",\n    \"Z\": \"Zulu\"\n]","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341966,"user_id":null,"body":"func toNato(_ words: String) -> String {\n    let natoAlphabet = [\"Alfa\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\", \"Foxtrot\", \"Golf\", \"Hotel\", \"India\", \"Juliett\", \"Kilo\", \"Lima\", \"Mike\", \"November\", \"Oscar\", \"Papa\", \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\", \"Uniform\", \"Victor\", \"Whiskey\", \"Xray\", \"Yankee\", \"Zulu\"]\n    \n    return words.replacingOccurrences(of: \" \", with: \"\").lowercased().map {\n        return Character(\"\\($0)\").isLetter ? natoAlphabet[Int(UnicodeScalar(\"\\($0)\")!.value - 97)] : \"\\($0)\"\n    }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341967,"user_id":null,"body":"\nfunc toNato(_ words: String) -> String {\n    let nato = [\n    \"A\"    : \"Alfa\",\n    \"B\"    : \"Bravo\",\n    \"C\"    : \"Charlie\",\n    \"D\"    : \"Delta\",\n    \"E\"    : \"Echo\",\n    \"F\"    : \"Foxtrot\",\n    \"G\"    : \"Golf\",\n    \"H\"    : \"Hotel\",\n    \"I\"    : \"India\",\n    \"J\"    : \"Juliett\",\n    \"K\"    : \"Kilo\",\n    \"L\"    : \"Lima\",\n    \"M\"    : \"Mike\",\n    \"N\"    : \"November\",\n    \"O\"    : \"Oscar\",\n    \"P\"    : \"Papa\",\n    \"Q\"    : \"Quebec\",\n    \"R\"    : \"Romeo\",\n    \"S\"    : \"Sierra\",\n    \"T\"    : \"Tango\",\n    \"U\"    : \"Uniform\",\n    \"V\"    : \"Victor\",\n    \"W\"    : \"Whiskey\",\n    \"X\"    : \"Xray\",\n    \"Y\"    : \"Yankee\",\n    \"Z\"    : \"Zulu\"\n    ]\n    let word = words.replacingOccurrences(of: \" \", with: \"\").uppercased()\n    var final = \"\"\n    for letter in word {\n        final += nato[String(letter)] ?? String(letter)\n        final += \" \"\n    }\n    final.removeLast()\n    return final\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341968,"user_id":null,"body":"func toNato(_ words: String) -> String {\n    let natoDict = [\"a\" : \"Alfa\",\n                    \"b\" : \"Bravo\",\n                    \"c\" : \"Charlie\",\n                    \"d\" : \"Delta\",\n                    \"e\" : \"Echo\",\n                    \"f\" : \"Foxtrot\",\n                    \"g\" : \"Golf\",\n                    \"h\" : \"Hotel\",\n                    \"i\" : \"India\",\n                    \"j\" : \"Juliett\",\n                    \"k\" : \"Kilo\",\n                    \"l\" : \"Lima\",\n                    \"m\" : \"Mike\",\n                    \"n\" : \"November\",\n                    \"o\" : \"Oscar\",\n                    \"p\" : \"Papa\",\n                    \"q\" : \"Quebec\",\n                    \"r\" : \"Romeo\",\n                    \"s\" : \"Sierra\",\n                    \"t\" : \"Tango\",\n                    \"u\" : \"Uniform\",\n                    \"v\" : \"Victor\",\n                    \"w\" : \"Whiskey\",\n                    \"x\" : \"Xray\",\n                    \"y\" : \"Yankee\",\n                    \"z\" : \"Zulu\"\n    ]\n    return words.compactMap{character in\n        if character.isWhitespace {\n            return nil\n        } else if character.isLetter {\n            return natoDict[character.lowercased()]\n        } else {\n            return String(character)\n        }\n    }.joined(separator: \" \")\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341969,"user_id":null,"body":"func toNato(_ words: String) -> String {\n    let nato = \"Alfa,Bravo,Charlie,Delta,Echo,Foxtrot,Golf,Hotel,India,Juliett,Kilo,Lima,Mike,November,Oscar,Papa,Quebec,Romeo,Sierra,Tango,Uniform,Victor,Whiskey,Xray,Yankee,Zulu\"\n    let dict = nato.components(separatedBy:\",\")\n    let word = words.filter {$0 != \" \"}.lowercased().map { (Character) -> String in\n        return dict.first(where: { (String) -> Bool in\n            Character == Array(String.lowercased())[0]\n        }) ?? \"\\(Character)\"\n    }.joined(separator: \" \")\n    return word\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341970,"user_id":null,"body":"func toNato(_ words: String) -> String {\n  let NATO = [\"A\":\"Alfa\", \"B\":\"Bravo\", \"C\":\"Charlie\", \"D\":\"Delta\", \"E\":\"Echo\", \"F\":\"Foxtrot\", \"G\":\"Golf\", \n              \"H\":\"Hotel\", \"I\":\"India\", \"J\":\"Juliett\", \"K\":\"Kilo\", \"L\":\"Lima\", \"M\":\"Mike\", \"N\":\"November\", \n              \"O\":\"Oscar\", \"P\":\"Papa\", \"Q\":\"Quebec\", \"R\":\"Romeo\", \"S\":\"Sierra\", \"T\":\"Tango\", \"U\":\"Uniform\", \n              \"V\":\"Victor\", \"W\":\"Whiskey\", \"X\":\"Xray\", \"Y\":\"Yankee\", \"Z\":\"Zulu\"]\n  return words.split(separator: \" \").joined().uppercased().map{String($0)}.map{NATO[$0] ?? $0}.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341971,"user_id":null,"body":"enum NatoSymbol: String {\n    case a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\n\n    var codeWord: String {\n        switch self {\n        case .a:\n            return \"Alfa\"\n        case .b:\n            return \"Bravo\"\n        case .c:\n            return \"Charlie\"\n        case .d:\n            return \"Delta\"\n        case .e:\n            return \"Echo\"\n        case .f:\n            return \"Foxtrot\"\n        case .g:\n            return \"Golf\"\n        case .h:\n            return \"Hotel\"\n        case .i:\n            return \"India\"\n        case .j:\n            return \"Juliett\"\n        case .k:\n            return \"Kilo\"\n        case .l:\n            return \"Lima\"\n        case .m:\n            return \"Mike\"\n        case .n:\n            return \"November\"\n        case .o:\n            return \"Oscar\"\n        case .p:\n            return \"Papa\"\n        case .q:\n            return \"Quebec\"\n        case .r:\n            return \"Romeo\"\n        case .s:\n            return \"Sierra\"\n        case .t:\n            return \"Tango\"\n        case .u:\n            return \"Uniform\"\n        case .v:\n            return \"Victor\"\n        case .w:\n            return \"Whiskey\"\n        case .x:\n            return \"Xray\"\n        case .y:\n            return \"Yankee\"\n        case .z:\n            return \"Zulu\"\n        }\n    }\n}\n\nfunc toNato(_ words: String) -> String {\n    words\n        .filter { $0.isWhitespace == false }\n        .map { character -> String in\n            guard let codeWord = NatoSymbol(rawValue: character.lowercased())?.codeWord else { return String(character) }\n            return codeWord\n        }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58678d29dbca9a68d80000d7":[{"id":341972,"user_id":53,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n  let input = Array(code)\n  var result = Array(tape)\n  var jumps = [Int : Int]()\n  var opens = [Int]()\n  for i in 0...input.count - 1 {\n    let c = input[i]\n    if c == \"[\" {\n      opens.append(i)\n    } else if c == \"]\" {\n      jumps[i] = opens[opens.count-1]\n      jumps[opens[opens.count-1]] = i\n      opens.removeLast()\n    }\n  }\n  var dp = 0\n  var ip = 0\n  while ip < input.count && dp < result.count && ip >= 0 && dp >= 0 {\n    let c = input[ip]\n    if c == \"*\" && result[dp] == \"0\" {\n      result[dp] = \"1\"\n    } else if c == \"*\" && result[dp] == \"1\" {\n      result[dp] = \"0\"\n    } else if c == \">\" {\n      dp += 1\n    } else if c == \"<\" {\n      dp -= 1\n    } else if c == \"[\" && result[dp] == \"0\" {\n      ip = jumps[ip] ?? 0\n    } else if c == \"]\" && result[dp] == \"1\" {\n      ip = jumps[ip] ?? 0\n    }\n    ip += 1\n  }\n  return String(result)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341973,"user_id":311,"body":"\/\/ MARK: With this enum, your SWIFT compiler will make sure that you handle every known operations\nenum Operations: String, CaseIterable {\n    case flip = \"*\"\n    case forward = \">\"\n    case backward = \"<\"\n    case jumppast = \"[\"\n    case jumpback = \"]\"\n}\n\nfunc interpreter(_ code: String, _ tape: String) -> String {\n    var t = Array(tape).map{String($0)}\n    let allKnownOperations = Operations.allCases.map{$0.rawValue}\n    let c = Array(code).map{String($0)}.filter{allKnownOperations.contains($0)}\n    var indexT = 0\n    var indexC = 0\n    while indexT >= 0 && indexC >= 0 && indexT < t.count && indexC < c.count {\n        if let operation = Operations(rawValue: c[indexC]) {\n            switch operation {\n            case .flip:\n                t[indexT] = t[indexT] == \"1\" ? \"0\" : \"1\"\n                indexC += 1\n            case .forward:\n                indexC += 1\n                indexT += 1\n            case .backward:\n                indexT -= 1\n                indexC += 1\n            case .jumpback, .jumppast:\n                indexC = jump(from: indexC, with: c, for: t[indexT])\n            }\n        } else {\n            indexC += 1\n        }\n    }\n    return t.joined()\n}\n\n\/\/ FIXME: - There should be a better\/easier way to write the jump operation\nfunc jump(from currentIndex: Int, with operators: [String], for currentTape: String) -> Int {\n    let currentOperation = operators[currentIndex]\n    guard [\"[\", \"]\"].contains(currentOperation) else {return currentIndex + 1}\n    let r: StrideThrough<Int>?\n    if currentOperation == \"[\" && currentTape == \"0\" {\n        r = stride(from: currentIndex, through: operators.count-1, by: 1)\n    } else if currentOperation == \"]\" && currentTape != \"0\" {\n        r = stride(from: currentIndex, through: 0, by: -1)\n    } else {\n        r = nil\n    }\n    guard let s = r else {return currentIndex + 1}\n    var currentOperatorCount = 0\n    var pairedOperatorCount = 0\n    let pairedOperation = (currentOperation == \"[\") ? \"]\" : \"[\"\n    for i in s {\n        switch operators[i] {\n        case currentOperation:\n            currentOperatorCount += 1\n        case pairedOperation:\n            pairedOperatorCount += 1\n        default:\n            break\n        }\n        if currentOperatorCount > 0 && currentOperatorCount == pairedOperatorCount {\n            return i\n        }\n    }\n    return currentIndex + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341974,"user_id":null,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n    var resultTape = tape.map{$0}\n    let commands = code.map{$0}\n    var commandIndex = 0\n    var tapeIndex = 0\n    var returnPoints = [Int]()\n    var jump = 0\n\n\n    while true {\n        let command = commands[commandIndex]\n        commandIndex += 1\n        if jump > 0 && !\"[]\".contains(command) { continue }\n\n        switch command {\n        case \">\": tapeIndex += 1\n        case \"<\": tapeIndex -= 1\n        case \"*\":\n            let bit = resultTape.remove(at: tapeIndex)\n            resultTape.insert(bit == \"0\" ? \"1\" : \"0\", at: tapeIndex)\n        case \"[\":\n            returnPoints.append(commandIndex - 1)\n            if resultTape[tapeIndex] == \"0\" { jump += 1 }\n        case \"]\":\n            jump -= 1\n            if let returnPoint = returnPoints.popLast(),\n                resultTape[tapeIndex] != \"0\" {\n                commandIndex = returnPoint\n            }\n        default: break\n        }\n\n        if tapeIndex > tape.count - 1 || tapeIndex < 0 { break }\n        if commandIndex > code.count - 1 || commandIndex < 0 { break }\n    }\n\n    return String(resultTape)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341975,"user_id":null,"body":"struct Cursor {\n  private(set) var content: String\n  let index: Int\n  var finished: Bool = false\n\n  var currentValue: Character { return self[index] }\n\n  func tail() -> Substring {\n    self[index..<content.count]\n  }\n\n  func head() -> Substring {\n    guard index > 0 else { return \"\" }\n    return self[0..<index + 1]\n  }\n\n  func next() -> Self {\n    if index + 1 < content.count {\n      return Cursor(content: content, index: index + 1)\n    }\n    return Cursor(content: content, index: index, finished: true)\n  }\n\n  func previous() -> Self {\n    if index - 1 >= 0 {\n      return Cursor(content: content, index: index - 1)\n    }\n    return Cursor(content: content, index: index, finished: true)\n  }\n\n  func moving(_ offset: Int) -> Self {\n    let newIndex = index + offset\n    guard newIndex >= 0, newIndex < content.count else {\n      return Cursor(content: content, index: index, finished: true)\n    }\n    return Cursor(content: content, index: newIndex)\n  }\n\n  subscript(_ index: Int) -> Character {\n    get {\n      content[content.index(content.startIndex, offsetBy: index)]\n    }\n    set {\n      let index = content.index(content.startIndex, offsetBy: index)\n      content.replaceSubrange(index...index, with: [newValue])\n    }\n  }\n\n  func flippingCurrentValue() -> Self {\n    var copy = self\n    let new: Character\n    let c = copy[index]\n\n    if c == \"0\" { new = \"1\" }\n    else if c == \"1\" { new = \"0\" }\n    else { new = c }\n\n    copy[index] = new\n    return copy\n  }\n\n  subscript(_ range: Range<Int>) -> Substring {\n    let lowerBound = content.index(content.startIndex, offsetBy: range.lowerBound)\n    let upperBound = content.index(content.startIndex, offsetBy: range.upperBound)\n    return content[lowerBound..<upperBound]\n  }\n}\n\nfunc interpreter(_ code: String, _ tape: String) -> String {\n  print(\"code: \\(code), tape: \\(tape)\")\n\n  typealias State = (tape: Cursor, code: Cursor)\n\n  let commands: [Character: (State) -> State] = [\n    \">\": { ($0.tape.next(), $0.code.next()) },\n    \"<\": { ($0.tape.previous(), $0.code.next()) },\n    \"*\": { ($0.tape.flippingCurrentValue(), $0.code.next())},\n    \"[\": { state in\n      guard state.tape.currentValue == \"0\" else { return (state.tape, state.code.next()) }\n      let subcode = state.code.tail()\n      var n = subcode.filter { $0 == \"[\" }.count\n      var index = subcode.startIndex\n      for i in subcode.indices {\n        if subcode[i] == \"]\" {\n          n -= 1\n        }\n        if n == 0 {\n          index = i\n          break\n        }\n      }\n      let code = state.code.content\n      let offset = code.distance(from: subcode.startIndex, to: index)\n      return (state.tape, state.code.moving(offset))\n    },\n    \"]\": { state in\n      guard state.tape.currentValue != \"0\" else { return (state.tape, state.code.next()) }\n      let subcode = state.code.head()\n      var n = subcode.filter { $0 == \"]\" }.count\n      var index = subcode.endIndex\n      for i in subcode.indices.reversed() {\n        if subcode[i] == \"[\" {\n          n -= 1\n        }\n        if n == 0 {\n          index = i\n          break\n        }\n      }\n      let code = state.code.content\n      let offset = state.code.index - subcode.distance(from: code.startIndex, to: index)\n      return (state.tape, state.code.moving(-offset))\n    }\n\n  ]\n\n  var tape: Cursor = Cursor(content: tape, index: 0)\n  var code: Cursor = Cursor(content: code, index: 0)\n\n  while !tape.finished && !code.finished {\n    let key = code.currentValue\n\/\/    print(\"\\(key) at: \\(code.index)\")\n    if let (newTape, newCode) = commands[key]?((tape, code)) {\n      tape = newTape\n      code = newCode\n\/\/      print(\"\\(tape.content)\")\n    } else {\n      code = code.next()\n    }\n  }\n\n  return tape.content\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341976,"user_id":null,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n  var pointer = 0\n  let codeArr = Array(code)\n  var tapeEditable = Array(tape)\n  \n  let startLoop = codeArr.firstIndex(of: \"[\")\n  var matching: [Int: Int] = [:]\n  var curr: [Int] = []\n  \n  var i = 0\n  \n  if startLoop != nil{\n    var stack: [Int] = []\n    for (k, l) in codeArr.enumerated(){\n      if l == \"[\"{\n        stack.append(k)\n      } \n      else if l == \"]\"{\n        matching[stack.last!] = k\n        stack.removeLast()\n      }\n    } \n  }\n  \n  while i < codeArr.count{\n    if codeArr[i] == \">\"{\n      pointer += 1\n      if pointer < 0 || pointer >= tapeEditable.count{break}\n    } else if codeArr[i] == \"<\"{\n        pointer -= 1\n        if pointer < 0 || pointer >= tapeEditable.count{break}\n    } else if codeArr[i] == \"*\"{\n        if tapeEditable[pointer] == \"1\"{tapeEditable[pointer] = \"0\"}\n        else{tapeEditable[pointer] = \"1\"}\n    } else if codeArr[i] == \"[\"{\n        if tapeEditable[pointer] == \"0\"{i = matching[i]!}\n        else{curr.append(i)}\n    } else if codeArr[i] == \"]\"{\n        if tapeEditable[pointer] != \"0\"{i = curr.last!} \n        else{curr.removeLast()}\n    }\n    i += 1\n  }\n  \n  \n  var output = \"\"\n  for i in tapeEditable{\n    output += String(i)\n  }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341977,"user_id":null,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n  \n  var tape = tape.map{ $0.wholeNumberValue! }\n  var pointer = 0\n  var matcher: Int\n  var char: Character\n  var index: String.Index\n  var pos = 0\n  \n  while pos < code.count {\n    \n    index = code.index(code.startIndex, offsetBy: pos)\n    char = code[index]\n    \n    if char == \">\" {\n      pointer += 1\n    } else if char == \"<\" {\n      pointer -= 1\n    } else if char == \"*\" {\n      if tape[pointer] == 0 {\n        tape[pointer] = 1 \n      } else { \n        tape[pointer] = 0\n      }\n    } else if char == \"[\" && tape[pointer] == 0 {\n      matcher = 1\n      while matcher > 0 {\n        pos += 1\n        index = code.index(code.startIndex, offsetBy: pos)\n        char = code[index]\n        if char == \"[\" {\n          matcher += 1\n        } else if char == \"]\" {\n          matcher -= 1\n        }\n      }\n      \n    } else if char == \"]\" && tape[pointer] != 0 {\n      matcher = 1\n      while matcher > 0 {\n        pos -= 1\n        index = code.index(code.startIndex, offsetBy: pos)\n        char = code[index]\n        if char == \"]\" {\n          matcher += 1\n        } else if char == \"[\" {\n          matcher -= 1\n        }\n      }\n    }\n      \n    if pointer < 0 || pointer > tape.count-1 { break } \/\/ tape boundaries exceeded\n    pos += 1\n  }\n  \n  return tape.map{ String($0) }.joined(separator: \"\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341978,"user_id":null,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n  var dataP: Int = 0\n  var codeP: Int = 0\n  let codeArr = code.map({ String($0) })\n  var data: [Int] = tape.map({$0.wholeNumberValue!})\n  while (dataP >= 0 && dataP < data.count) {    \n    switch codeArr[codeP] {\n      case \">\":\n        dataP += 1\n      case \"<\":\n        dataP -= 1\n      case \"*\":\n        data[dataP] = abs(data[dataP] - 1)\n      case \"[\":\n        if data[dataP] == 0 {\n          var bracketCounter: Int = 1\n          while bracketCounter > 0 {\n            codeP += 1\n            if codeArr[codeP] == \"[\" { bracketCounter += 1 }\n            else if codeArr[codeP] == \"]\" { bracketCounter -= 1 }\n          }\n        }\n      case \"]\":\n        if data[dataP] != 0 {\n          var bracketCounter: Int = 1\n          while bracketCounter > 0 {\n            codeP -= 1\n            if codeArr[codeP] == \"]\" { bracketCounter += 1 }\n            else if codeArr[codeP] == \"[\" { bracketCounter -= 1 }\n          }\n        }\n      default:\n        break\n    }\n    codeP += 1\n    if codeP == codeArr.count { break }\n  }  \n  return data.map{ String($0) }.joined(separator: \"\")                          \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341979,"user_id":null,"body":"enum Command : Character {\n  case moveRight = \">\"\n  case moveLeft = \"<\"\n  case fip = \"*\"\n  case openBrackets = \"[\"\n  case closeBrackets = \"]\"\n}\n\nfunc interpreter(_ code: String, _ tape: String) -> String {\n  let (commands, openToCloseMap, closeToOpenMap) = analyseCode(code)\n\n  var memory = tape.map { $0 == \"0\" ? false : true}  \n  var pointer = 0\n  var i = 0\n  while i < commands.count && pointer >= 0 && pointer < memory.count {\n    switch commands[i] {\n        case .none: break\n        case .moveRight:\n          pointer += 1\n        case .moveLeft:\n          pointer -= 1\n        case .fip: \n          memory[pointer] = !memory[pointer]\n        case .openBrackets: \n          if memory[pointer] { break }\n          i = openToCloseMap[i]!\n        case .closeBrackets:\n          if !memory[pointer] { break }\n          i = closeToOpenMap[i]!\n      }\n    i += 1\n  }\n\n  return memory.reduce(String(), { acc, value in\n                                return \"\\(acc)\\(value ? \"1\" : \"0\")\"\n                               })\n}\n\nfunc analyseCode(_ code:String) -> ([Command?], [Int:Int], [Int: Int]) {\n  var openToCloseMap = [Int:Int]()\n  var closeToOpenMap = [Int:Int]()\n  var openStack = [Int]()\n  let commands : [Command?] = code.enumerated().map { tuple in\n    let (i, c) = tuple\n    let command = Command(rawValue:c)\n                                 \n    switch command {\n     case .openBrackets:\n        openStack.append(i)\n     case .closeBrackets:\n        let oi = openStack.removeLast()\n        openToCloseMap[oi] = i\n        closeToOpenMap[i] = oi\n     default: break\n    }\n                                                     \n    return command\n  }\n  \n  return (commands, openToCloseMap, closeToOpenMap)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341980,"user_id":null,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n  var memory = Memory(tape)\n  var pointer = 0\n\n  var i = 0\n  while i < code.count {\n    if let command = commandFor(code, at: i) {\n      switch command {\n        case .moveRight:\n          pointer += 1\n          if (outOfbouds(pointer, memory.bits.count)) { return memory.out() }\n        case .moveLeft:\n          pointer -= 1\n          if (outOfbouds(pointer, memory.bits.count)) { return memory.out() }\n        case .fip: \n          memory.flip(pointer)\n        case .openBrackets: \n          if memory.bits[pointer] { break }\n          var openCount = 1\n          while openCount != 0 {\n            i += 1 \n            let command = commandFor(code, at: i)\n            openCount += command == .openBrackets ? 1 : 0\n            openCount -= command == .closeBrackets ? 1 : 0\n          } \n        case .closeBrackets: \n          if !memory.bits[pointer] { break }\n          var closeCount = 1\n          while closeCount != 0 {\n            i -= 1 \n            let command = commandFor(code, at: i)\n            closeCount -= command == .openBrackets ? 1 : 0\n            closeCount += command == .closeBrackets ? 1 : 0\n          } \n      }\n    }\n    i += 1\n  }\n\n  return memory.out()\n}\n\nfunc outOfbouds(_ pointer: Int, _ memorySize: Int) -> Bool {\n  return pointer < 0 || pointer >= memorySize\n}\n\nfunc commandFor(_ code:String, at index:Int) -> Command? {\n  return Command(rawValue:code[String.Index(encodedOffset: index)])\n}\n\nenum Command : Character {\n  case moveRight = \">\"\n  case moveLeft = \"<\"\n  case fip = \"*\"\n  case openBrackets = \"[\"\n  case closeBrackets = \"]\"\n}\n\n\nstruct Memory {\n  var bits: [Bool]\n\n  init (_ tape: String) {\n    bits = tape.map { $0 == \"0\" ? false : true}\n  }\n\n  func out() -> String {\n    return bits.reduce(String(), { acc, value in\n                                  return \"\\(acc)\\(value ? \"1\" : \"0\")\"\n                                 })\n  }\n\n  mutating func flip(_ i:Int) {\n    bits[i] = !bits[i] \n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341981,"user_id":null,"body":"func interpreter(_ code: String, _ tape: String) -> String {\n\n  var data = tape.flatMap { Int(String($0)) }\n  let instructions = code.map { String($0) }\n  var codeIndex = 0\n  var dataIndex = 0\n  var jump = 0\n  \n  while codeIndex < instructions.count && (dataIndex >= 0 && dataIndex < data.count) {\n    if jump == 0 {\n      switch instructions[codeIndex] {\n        case \">\": dataIndex += 1\n        case \"<\": dataIndex -= 1\n        case \"*\": data[dataIndex] ^= 1\n        case \"[\": if data[dataIndex] == 0 { jump = 1 }\n        case \"]\": if data[dataIndex] != 0 { jump = -1 }\n        default: break\n      }\n    }\n    else {\n      switch instructions[codeIndex] {\n        case \"[\": jump += 1\n        case \"]\": jump -= 1\n        default: break\n      }\n    }\n    \n    codeIndex += (jump >= 0) ? 1 : -1\n  }\n  \n  return data.map({ \"\\($0)\" }).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5868a68ba44cfc763e00008d":[{"id":341982,"user_id":53,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  let clean = code.replacingOccurrences(of: \"[^nesw*\\\\[\\\\]]\", with: \"\", options: [.regularExpression])\n  let input = Array(clean)\n  var jumps = [Int : Int]()\n  var opens = [Int]()\n  var grid = Array(repeating: Array(repeating: 0, count: width), count: height)\n  for i in stride(from: 0, through: input.count - 1, by: 1) {\n    let c = input[i]\n    if c == \"[\" {\n      opens.append(i)\n    } else if c == \"]\" {\n      jumps[i] = opens[opens.count-1]\n      jumps[opens[opens.count-1]] = i\n      opens.removeLast()\n    }\n  }\n  var (i,j,x,y) = (0,0,0,0)\n  while j < iterations && i < input.count {\n    let c = input[i]\n    if c == \"n\" {\n      y = (y + height - 1) % height\n    } else if c == \"w\" {\n      x = (x + width - 1) % width\n    } else if c == \"s\" {\n      y = (y + 1) % height\n    } else if c == \"e\" {\n      x = (x + 1) % width\n    } else if c == \"*\" {\n      grid[y][x] ^= 1\n    } else if c == \"[\" && grid[y][x] == 0 {\n      i = jumps[i] ?? 0\n    } else if c == \"]\" && grid[y][x] == 1 {\n      i = jumps[i] ?? 0\n    }\n    i += 1\n    j += 1\n  }\n  return grid.map{$0.map{String($0)}.joined(separator:\"\")}.joined(separator:\"\\r\n\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341983,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  let cleanCode = Array(code.replacingOccurrences(of: \"[^nesw\\\\*\\\\[\\\\]]\", with: \"\", options: .regularExpression))\n\n  var grid = (0 ..< height).map{i in Array(repeating: \"0\", count: width)}\n  var loops = [Int: Int](), stack = [(Int, Character)]()\n  \n  for (i, c) in cleanCode.enumerated() {\n    if c == \"]\" {\n      while !stack.isEmpty && stack.last!.1 != \"[\" { stack.removeLast() }\n      let s = stack.removeLast()\n      loops[i] = s.0\n      loops[s.0] = i\n    } else {\n      stack.append((i, c))\n    }\n  }\n  \n  var i = 0, j = 0, ptr = 0 \n  \n  for k in 0 ..< iterations {\n    let cmd = cleanCode[ptr]\n    switch cmd {\n      case \"n\": i -= 1\n      case \"s\": i += 1\n      case \"w\": j -= 1\n      case \"e\": j += 1\n      case \"*\": grid[i][j] = grid[i][j] == \"0\" ? \"1\" : \"0\"\n      case \"[\": if grid[i][j] == \"0\" { ptr = loops[ptr]! }\n      case \"]\": if grid[i][j] != \"0\" { ptr = loops[ptr]! }\n      default: break\n    }\n    ptr += 1\n    if ptr >= cleanCode.count { break }\n    if i < 0 { i = height - 1 }\n    i = abs(i) % height\n    if j < 0 { j = width - 1 }\n    j = abs(j) % width\n  }\n  return grid.map{ row in row.joined() }.joined(separator: \"\\r\n\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341984,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  var pointerX = 0\n  var pointerY = 0\n  let codeArr = Array(code)\n  var tape = Array(repeating: Array(repeating: \"0\", count: width), count: height)\n  var currIter = 0\n  var codePointer = 0\n  \n  let startLoop = codeArr.firstIndex(of: \"[\")\n  var matching: [Int: Int] = [:]\n  var curr: [Int] = []\n  \n  if startLoop != nil{\n    var stack: [Int] = []\n    for (k, l) in codeArr.enumerated(){\n      if l == \"[\"{\n        stack.append(k)\n      }\n      else if l == \"]\"{\n        matching[stack.last!] = k\n        stack.removeLast()\n      }\n    }\n  }\n  \n  while currIter < iterations && codePointer < codeArr.count{\n    if codeArr[codePointer] == \"n\"{\n      pointerY -= 1\n      if pointerY < 0 || pointerY >= height{pointerY = abs(abs(pointerY) - height)}\n    }\n    else if codeArr[codePointer] == \"s\"{\n      pointerY += 1\n      if pointerY < 0 || pointerY >= height{pointerY = abs(abs(pointerY) - height)}\n    }\n    else if codeArr[codePointer] == \"e\"{\n      pointerX += 1\n      if pointerX < 0 || pointerX >= width{pointerX = abs(abs(pointerX) - width)}\n    }\n    else if codeArr[codePointer] == \"w\"{\n      pointerX -= 1\n      if pointerX < 0 || pointerX >= width{pointerX = abs(abs(pointerX) - width)}\n    }\n    \n    else if codeArr[codePointer] == \"*\"{\n      if tape[pointerY][pointerX] == \"1\"{tape[pointerY][pointerX] = \"0\"}\n      else{tape[pointerY][pointerX] = \"1\"}\n    \n    } else if codeArr[codePointer] == \"[\"{\n        if tape[pointerY][pointerX] == \"0\"{codePointer = matching[codePointer]!}\n        else{curr.append(codePointer)}\n    }\n    else if codeArr[codePointer] == \"]\"{\n      if tape[pointerY][pointerX] != \"0\"{codePointer = curr.last!}\n      else{curr.removeLast()}\n    }\n      \n    if [\"n\", \"s\", \"e\", \"w\", \"*\", \"[\", \"]\"].contains(codeArr[codePointer]){currIter += 1}\n    codePointer += 1\n  }\n  \n  \n  var output: [String] = []\n  for i in tape{\n      output.append(String(i.joined(separator: \"\"))) \n  }\n  let output2 = String(output.joined(separator: \"\\r\n\"))\n  return output2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341985,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  var grid: [[Int]] = Array(repeating: Array(repeating: 0, count: width), count: height)\n  var codeP: Int = 0\n  let codeArr = code.map({ String($0) })  \n  var gridPX: Int = 0  \n  var gridPY: Int = 0   \n  var it: Int = iterations\n\n  while (it > 0 && codeP < codeArr.count) {\n    switch codeArr[codeP] {\n      case \"e\":\n        gridPX += 1\n        if gridPX == width { gridPX = 0 }\n        it -= 1\n      case \"w\":\n        gridPX -= 1\n        if gridPX < 0 { gridPX = width - 1 }\n        it -= 1\n      case \"n\":\n        gridPY -= 1\n        if gridPY < 0 { gridPY = height - 1 }\n        it -= 1\n      case \"s\":\n        gridPY += 1\n        if gridPY == height { gridPY = 0 }\n        it -= 1\n      case \"*\":\n        grid[gridPY][gridPX] = abs(grid[gridPY][gridPX] - 1)\n        it -= 1\n      case \"[\":\n        if grid[gridPY][gridPX] == 0 {\n          var bracketCounter: Int = 1\n          while bracketCounter > 0 {\n            codeP += 1\n            if codeArr[codeP] == \"[\" { bracketCounter += 1 }\n            else if codeArr[codeP] == \"]\" { bracketCounter -= 1 }\n          }\n        }\n        it -= 1\n      case \"]\":\n        if grid[gridPY][gridPX] != 0 {\n          var bracketCounter: Int = 1\n          while bracketCounter > 0 {\n            codeP -= 1\n            if codeArr[codeP] == \"]\" { bracketCounter += 1 }\n            else if codeArr[codeP] == \"[\" { bracketCounter -= 1 }\n          }\n        }\n        it -= 1\n      default:\n        break\n      }\n    codeP += 1\n  }\n  return grid.map{ $0.map{ String($0) }.joined(separator: \"\")}.joined(separator: \"\\r\n\")\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341986,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  \n  var grid = Array(repeating: Array(repeating: 0, count: width), count: height)\n  \n  var codePosition = 0\n  var index: String.Index\n  var iterations = iterations\n  var command: Character\n  var posH = 0\n  var posW = 0\n  \n  while codePosition <= code.count-1 && iterations > 0 {\n    \n    index = code.index(code.startIndex, offsetBy: codePosition)\n    command = code[index]\n    \n    switch command {\n      case \"n\":\n        posH -= 1\n        if posH < 0 { posH = height-1 }\n        iterations -= 1\n      case \"s\":\n        posH += 1\n        if posH > height-1 { posH = 0 }\n        iterations -= 1\n      case \"w\":\n        posW -= 1\n        if posW < 0 { posW = width-1 }\n        iterations -= 1\n      case \"e\":\n        posW += 1\n        if posW > width-1 { posW = 0 }\n        iterations -= 1\n      case \"*\":\n        if grid[posH][posW] == 0 { grid[posH][posW] = 1 } else { grid[posH][posW] = 0 }\n        iterations -= 1\n      case \"]\":\n        if grid[posH][posW] != 0 {\n          var match = 1\n          while match > 0 {\n            codePosition -= 1\n            index = code.index(code.startIndex, offsetBy: codePosition)\n            command = code[index]\n            if command == \"[\" {\n              match -= 1\n            } else if command == \"]\" {\n              match += 1\n            }\n          }\n          iterations -= 1\n        }\n      case \"[\":\n        if grid[posH][posW] == 0 {\n          var match = 1\n          while match > 0 {\n            codePosition += 1\n            index = code.index(code.startIndex, offsetBy: codePosition)\n            command = code[index]\n            if command == \"[\" {\n              match += 1\n            } else if command == \"]\" {\n              match -= 1\n            }\n          }\n        }\n        iterations -= 1\n      default:\n        break\n    }\n\n    codePosition += 1    \n  }\n  \n  return grid.map{ $0.map{ String($0) }.joined(separator: \"\") }.joined(separator: \"\\r\n\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341987,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  let (commands, openToCloseMap, closeToOpenMap) = analyseCode(code)\n\n  var memory = Array<Bool>(repeating: false, count: width * height)\n  var l = 0, c = 0\n  var pointer: Int { get { l * width + c } }\n  \n  var i = 0\n  var iteration = 0\n  while i < commands.count && iteration < iterations {\n    switch commands[i] {\n        case .none: \n          iteration -= 1\n        case .moveUp:\n          l = l == 0 ? height - 1 : l - 1\n        case .moveDown:\n          l = l == height - 1 ? 0 : l + 1\n        case .moveRight:\n          c = c == width - 1 ? 0 : c + 1\n        case .moveLeft:\n          c = c == 0 ? width - 1 : c - 1\n        case .fip: \n          memory[pointer] = !memory[pointer]\n        case .openBrackets: \n          if memory[pointer] { break }\n          i = openToCloseMap[i]!\n        case .closeBrackets:\n          if !memory[pointer] { break }\n          i = closeToOpenMap[i]!\n      }\n    i += 1\n    iteration += 1\n  }\n\n  return memory.enumerated().reduce(String(), { acc, tuple in\n                                let (i, value) = (tuple.0 + 1, tuple.1)\n                                let breakLine = i % width == 0 && i < memory.count\n                                return \"\\(acc)\\(value ? \"1\" : \"0\")\\(breakLine ? \"\\r\n\" : \"\")\"\n                               })\n}\n\n\nenum Command : Character {\n  case moveUp = \"n\"\n  case moveDown = \"s\"\n  case moveLeft = \"w\"\n  case moveRight = \"e\"\n  case fip = \"*\"\n  case openBrackets = \"[\"\n  case closeBrackets = \"]\"\n}\n\n\nfunc analyseCode(_ code:String) -> ([Command?], [Int:Int], [Int: Int]) {\n  var openToCloseMap = [Int:Int]()\n  var closeToOpenMap = [Int:Int]()\n  var openStack = [Int]()\n  let commands : [Command?] = code.enumerated().map { tuple in\n    let (i, c) = tuple\n    let command = Command(rawValue:c)\n                                 \n    switch command {\n     case .openBrackets:\n        openStack.append(i)\n     case .closeBrackets:\n        let oi = openStack.removeLast()\n        openToCloseMap[oi] = i\n        closeToOpenMap[i] = oi\n     default: break\n    }\n                                                     \n    return command\n  }\n  \n  return (commands, openToCloseMap, closeToOpenMap)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341988,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  \n  var field = Array(repeating: Array(repeating: 0, count: width), count: height)\n  let instructions = code.map { String($0) }\n  var codeIndex = 0\n  var dataIndex = (0, 0)\n  var iters = 0\n  var jump = 0\n  \n  while iters < iterations && codeIndex < instructions.count {\n    \n    if jump == 0 {\n      switch instructions[codeIndex] {\n        case \"n\": dataIndex.0 -= 1\n        case \"e\": dataIndex.1 += 1\n        case \"s\": dataIndex.0 += 1\n        case \"w\": dataIndex.1 -= 1\n        case \"*\": field[dataIndex.0][dataIndex.1] ^= 1\n        case \"[\": if field[dataIndex.0][dataIndex.1] == 0 { jump = 1 }\n        case \"]\": if field[dataIndex.0][dataIndex.1] != 0 { jump = -1 }\n        default: iters -= 1\n      }\n    \n      if dataIndex.0 < 0 { dataIndex.0 = height - 1 }\n      if dataIndex.0 >= height { dataIndex.0 = 0 }\n      if dataIndex.1 < 0 { dataIndex.1 = width - 1 }\n      if dataIndex.1 >= width { dataIndex.1 = 0 }\n      \n      iters += 1\n    }\n    else {\n      switch instructions[codeIndex] {\n        case \"[\": jump += 1\n        case \"]\": jump -= 1\n        default: break\n      }\n    }\n    \n    codeIndex += (jump >= 0) ? 1 : -1\n  }\n  \n  return field.map({ $0.reduce(\"\", { \"\\($0)\\($1)\" }) }).joined(separator: \"\\r\n\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341989,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  var commandExecutions = 0\n  var pointer = Pointer(x: 0, y: 0)\n  var dataGrid = Array(repeating: Array(repeating: 0, count: width), count: height)\n  \n  let codeChars = Array(code)\n  var codePointer = 0 \n  \n  while commandExecutions < iterations && codePointer < codeChars.count {\n    handleCommand(\n      command: codeChars[codePointer], \n      pointer: &pointer,\n      dataGrid: &dataGrid,\n      commands: codeChars,\n      commandPointer: &codePointer,\n      commandExecutions: &commandExecutions\n    )\n  }\n  return mapDataGridToOutput(dataGrid) \n}\n\nfunc mapDataGridToOutput(_ dataGrid: [[Int]]) -> String {\n  return String(dataGrid.map { row in \n    return row.map { String($0) }.joined() + \"\\r\n\"\n  }.joined().dropLast(1))\n}\n\nfunc handleCommand(\n  command: Character, \n  pointer: inout Pointer, \n  dataGrid: inout [[Int]], \n  commands: [Character], \n  commandPointer: inout Int,\n  commandExecutions: inout Int\n) {\n  switch command {\n    case \"n\":\n      moveNorth(&pointer, dataGrid.count)\n    case \"e\":\n      moveEast(&pointer, dataGrid[0].count)\n    case \"s\":\n      moveSouth(&pointer, dataGrid.count)\n    case \"w\":\n      moveWest(&pointer, dataGrid[0].count)\n    case \"*\":\n      flipBit(pointer, &dataGrid)\n    case \"[\":\n      if shouldJumpForwards(pointer, dataGrid) {\n        jumpForwards(commands, &commandPointer)\n      }\n    case \"]\":\n      if shouldJumpBackwards(pointer, dataGrid) {\n        jumpBackwards(commands, &commandPointer)\n      }\n    default: \n      \/\/ non command character do not count \n      commandExecutions = commandExecutions - 1\n  }\n  \n  commandExecutions = commandExecutions + 1\n  commandPointer = commandPointer + 1 \n}\n\n\nfunc moveNorth(_ pointer: inout Pointer, _ height: Int) {\n  let newPosition = pointer.y - 1\n  pointer.y = newPosition < 0 ? height - 1 : newPosition\n}\n\nfunc moveSouth(_ pointer: inout Pointer, _ height: Int) {\n  let newPosition = pointer.y + 1\n  pointer.y = newPosition >= height ? 0 : newPosition\n}\n\nfunc moveEast(_ pointer: inout Pointer, _ width: Int) {\n  let newPosition = pointer.x + 1\n  pointer.x = newPosition >= width ? 0 : newPosition\n}\n\nfunc moveWest(_ pointer: inout Pointer, _ width: Int) {\n  let newPosition = pointer.x - 1 \n  pointer.x = newPosition < 0 ? width - 1 : newPosition\n}\n\nfunc flipBit(_ pointer: Pointer, _ dataGrid: inout [[Int]]) {\n  dataGrid[pointer.y][pointer.x] = dataGrid[pointer.y][pointer.x] == 1 ? 0 : 1\n}\n\nfunc shouldJumpForwards(_ pointer: Pointer, _ dataGrid: [[Int]]) -> Bool {\n  return dataGrid[pointer.y][pointer.x] == 0\n}\n\nfunc shouldJumpBackwards(_ pointer: Pointer, _ dataGrid: [[Int]]) -> Bool {\n  return dataGrid[pointer.y][pointer.x] != 0\n}\n\nfunc jumpForwards(_ code: [Character], _ codePointer: inout Int) {\n  let indexOfJump = code[codePointer..<code.count].firstIndex { $0 == \"]\" }!\n  codePointer = indexOfJump\n}\n\nfunc jumpBackwards(_ code: [Character], _ codePointer: inout Int) {\n  let indexOfJump = code[0..<codePointer].firstIndex { $0 == \"[\" }!\n  codePointer = indexOfJump\n}\n\nstruct Pointer {\n  var x: Int\n  var y: Int\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341990,"user_id":null,"body":"\nfunc interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n\tvar data = Array(repeating: Array(repeating: false, count: width), count: height)\n\tvar position: (x: Int, y: Int) = (0, 0)\n\tvar codeIndex = code.startIndex\n\n\tfunc advanceCode() {\n\t\tcodeIndex = code.index(after: codeIndex)\n\t}\n\n\tvar dataString: String {\n\t\tdata.map { \"\\($0.map { $0 ? \"1\" : \"0\" }.joined())\" }.joined(separator: \"\\r\n\")\n\t}\n\n\tprint(\"code: \\\"\\(code)\\\", iterations: \\(iterations), width: \\(width), height: \\(height)\")\n\n\tvar currentIteration = 0\n\twhile codeIndex < code.endIndex && currentIteration < iterations {\n\t\tvar isCommand = true\n\t\tswitch code[codeIndex] {\n\t\tcase \"n\":\n\t\t\tif position.y == 0 {\n\t\t\t\tposition.y = height - 1\n\t\t\t} else {\n\t\t\t\tposition.y -= 1\n\t\t\t}\n\t\t\tadvanceCode()\n\t\tcase \"s\":\n\t\t\tif position.y == height - 1 {\n\t\t\t\tposition.y = 0\n\t\t\t} else {\n\t\t\t\tposition.y += 1\n\t\t\t}\n\t\t\tadvanceCode()\n\t\tcase \"w\":\n\t\t\tif position.x == 0 {\n\t\t\t\tposition.x = width - 1\n\t\t\t} else {\n\t\t\t\tposition.x -= 1\n\t\t\t}\n\t\t\tadvanceCode()\n\t\tcase \"e\":\n\t\t\tif position.x == width - 1 {\n\t\t\t\tposition.x = 0\n\t\t\t} else {\n\t\t\t\tposition.x += 1\n\t\t\t}\n\t\t\tadvanceCode()\n\t\tcase \"*\":\n\t\t\tdata[position.y][position.x].toggle()\n\t\t\tadvanceCode()\n\t\tcase \"[\":\n\t\t\tif data[position.y][position.x] {\n\t\t\t\tadvanceCode()\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tadvanceCode()\n\n\t\t\tvar count = 0\n\t\t\twhile codeIndex < code.endIndex && (code[codeIndex] != \"]\" || count > 0) {\n\t\t\t\tif code[codeIndex] == \"[\" {\n\t\t\t\t\tcount += 1\n\t\t\t\t} else if code[codeIndex] == \"]\" {\n\t\t\t\t\tcount -= 1\n\t\t\t\t}\n\t\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\t\t}\n\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\tcase \"]\":\n\t\t\tif !data[position.y][position.x] {\n\t\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tvar count = 0\n\t\t\tcodeIndex = code.index(before: codeIndex)\n\t\t\twhile codeIndex >= code.startIndex && (code[codeIndex] != \"[\" || count > 0) {\n\t\t\t\tif code[codeIndex] == \"]\" {\n\t\t\t\t\tcount += 1\n\t\t\t\t} else if code[codeIndex] == \"[\" {\n\t\t\t\t\tcount -= 1\n\t\t\t\t}\n\t\t\t\tcodeIndex = code.index(before: codeIndex)\n\t\t\t}\n\t\t\tisCommand = false\n\t\tdefault:\n\t\t\tcodeIndex = code.index(after: codeIndex)\n\t\t\tisCommand = false\n\t\t}\n\n\t\tif isCommand {\n\t\t\tcurrentIteration += 1\n\t\t}\n\t}\n\treturn dataString\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341991,"user_id":null,"body":"func interpreter(code: String, iterations: Int, width: Int, height: Int) -> String {\n  var data: [[String]] = Array(repeating: Array(repeating: \"0\", count: width), count: height)\n  var (di, dj) = (0, 0)\n  \n  let cod = Array(code)\n  var ip = 0\n    \n  var stack: [Int] = []\n  var skipLevel: Int = 0\n  \n  var itersLeft = iterations\n  \n  while ip < cod.count && itersLeft > 0 {\n    let cmd = cod[ip]\n    ip += 1\n    guard skipLevel == 0 else {\n      switch cmd {\n        case \"[\": skipLevel += 1\n        case \"]\": skipLevel -= 1\n        default: ()\n      }\n      continue\n    }\n    itersLeft -= 1\n    switch cmd {\n      case \"n\": di = (height + di - 1) % height\n      case \"e\": dj = (dj + 1) % width\n      case \"s\": di = (di + 1) % height\n      case \"w\": dj = (width + dj - 1) % width\n      case \"*\": data[di][dj] = data[di][dj] == \"0\" ? \"1\" : \"0\"\n      case \"[\": \n        guard data[di][dj] == \"1\" else {\n          skipLevel = 1\n          continue\n        }\n        stack.append(ip - 1)\n      case \"]\":  ip = stack.popLast()!; fallthrough\n      default:  itersLeft += 1\n    }\n  }\n  \n  return data.map { $0.joined(separator: \"\") }.joined(separator: \"\\r\n\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"586d6cefbcc21eed7a001155":[{"id":341992,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n  var current = (\"\", 0)\n  var most = (\"\", 0)\n  for char in s.map { String($0) } {\n    if char != current.0 { current = (char, 1) } else { current.1 += 1 }\n    if current.1 > most.1 { most = current }\n  }\n  \n  return [most.0: most.1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341993,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n  var uniqueCharacters = \"\"\n        var maxCount = 0\n        var maxOccurringCharacter = \"\"\n  for char in s {\n    if uniqueCharacters.contains(char) {\n      uniqueCharacters += String(char)\n    }\n     else if uniqueCharacters.contains(char) != true{\n        uniqueCharacters = \"\"\n uniqueCharacters += String(char)\n      }\n    let count = Array(uniqueCharacters).filter{$0 == char}.count\n    if count > maxCount {\n      maxCount = 0\n      maxCount += count\n      maxOccurringCharacter = String(char)\n      print(uniqueCharacters)\n      }\n    }\n  return [maxOccurringCharacter: maxCount]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341994,"user_id":null,"body":"extension String {\n\n    subscript(_ i: Int) -> String {\n        return String(self[index(startIndex, offsetBy: i)])\n    }\n}\n\nfunc longestRepetition(_ s: String) -> [String: Int]{\n    guard !s.isEmpty else { return [\"\": 0] }\n\n    var char: String = \"\"\n    var length = 0\n\n    var sublength = 1\n    for index in 0..<s.count-1 {\n        if s[index] == s[index+1] {\n            sublength = sublength + 1\n          if index == s.count-2 {\n                if sublength > length {\n                    length = sublength\n                    char = s[index]\n                }\n            }\n        }\n        else {\n            if sublength > length {\n                length = sublength\n                char = s[index]\n            }\n            sublength = 1\n        }\n    }\n    return [char: length]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341995,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n    guard s.count > 0 else {\n        return [\"\": 0]\n    }\n    let arr = Array(s)\n    var str = \"\"\n    var array: [String] = []\n    for (index, value) in arr.enumerated() {\n        if (index + 1 < arr.count && arr[index] == arr[index + 1]) {\n            str += String(value)\n        } else {\n            str += String(value)\n            array.append(str)\n            str = \"\"\n        }\n    }\n    let sorted = array.sorted(by: { $0.count > $1.count })\n\n    return [String(sorted[0].first!): sorted[0].count]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341996,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n    guard s.count > 0 else { return [\"\": 0] }\n    let characters: [String] = Array(s).compactMap { String($0) }\n    var dictionaryList: [[String: Int]] = []\n    var dictionary: [String: Int] = [:]\n    var previousCharacter: String? = characters.first\n    for character in characters.enumerated() {\n        if previousCharacter != character.element {\n            dictionaryList.append(dictionary)\n            dictionary.removeAll()\n        }\n        var count: Int = dictionary[character.element] ?? 0\n        count += 1\n        dictionary[character.element] = count\n        previousCharacter = character.element\n        if character.offset == characters.count - 1 {\n            dictionaryList.append(dictionary)\n            dictionary.removeAll()\n        }\n    }\n    let maxValue: Int = dictionaryList.flatMap { $0.values }.max() ?? 0\n    dictionary = dictionaryList.first { dictionary in\n        return dictionary.first { $0.value == maxValue } != nil\n    } ?? [:]\n    return [dictionary.first?.key ?? \"\": dictionary.first?.value ?? 0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341997,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n  \n  guard s.count > 0 else { return [\"\": 0] }\n  let arr = Array(s)\n  var currentC = arr[0]\n  var currentL = 1\n  var l = 1;\n  var result = [String(currentC): 1]\n  for i in 1..<arr.count {\n    if arr[i] == currentC { currentL += 1 }\n    if currentL > l { \n      result = [String(currentC): currentL]\n      l = currentL\n    }\n    if arr[i] != currentC {\n      currentC = arr[i]\n      currentL = 1\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341998,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n  var currentChar = (\"\", 0)\n  var longest = (\"\", 0)\n    for char in s.map({ String($0) }) {\n    if char != currentChar.0 { currentChar = (char, 1) } else { currentChar.1 += 1 }\n    if currentChar.1 > longest.1 { longest = currentChar }\n  }\n  \n  return [longest.0: longest.1]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":341999,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n  var prevCh: String = \"\"\n  var currRun: Int = 0\n  var theC: String = \"\"\n  var maxRun: Int = 0\n  \n  for ch in s {\n    if String(ch) == prevCh {\n      currRun += 1\n    } else {\n      if currRun > maxRun {\n        maxRun = currRun\n        theC = prevCh\n      }\n      currRun = 1\n    }\n    \n    prevCh = String(ch)\n  }\n  \n  if currRun > maxRun {\n      maxRun = currRun\n      theC = prevCh\n  }  \n  \n  return [theC:maxRun]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342000,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int]{\n    var dict = [\"\" : 0]\n    let array = s.map { String($0) }\n    var max = 1\n    if !s.isEmpty {\n    for i in 0..<array.count - 1 {\n        if array[i] == array[i + 1]  {\n            max += 1\n        } else {\n            max = 1\n        }\n        if max > dict[array[i]] ?? 0 {\n        dict[array[i]] = max\n        }\n    }\n    max = 1\n    if let maxValue = dict.max(by: {a, b in a.value < b.value\n    }) {\n        for i in 0..<array.count - 1 {\n            if array[i] == array[i + 1]  {\n                max += 1\n            } else {\n                max = 1\n            }\n\n            if max == maxValue.value {\n                return [array[i] : maxValue.value]\n            }\n            }\n        return [maxValue.key : maxValue.value]\n        }\n    }\n    return [\"\" : 0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342001,"user_id":null,"body":"func longestRepetition(_ s: String) -> [String: Int] {\n  print(\"Testing \\(s)\")\n  guard s.count > 0 else { return [\"\": 0]}\n  var maxCount = 0\n  var maxChar: Character = \" \"\n  var currentCount = 0\n  var currentChar: Character = \" \"\n  for char in Array(s) {\n    if currentChar != char {\n      if currentCount > maxCount {\n        maxCount = currentCount\n        maxChar = currentChar\n      }\n      currentCount = 0\n      currentChar = char\n      currentCount += 1\n    } else {\n      currentCount += 1\n    }\n  }\n  if currentCount > maxCount {\n    maxCount = currentCount\n    maxChar = currentChar\n  }\n  print(\"\\(maxChar) \\(maxCount)\")\n  return [String(maxChar): maxCount]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"586dd26a69b6fd46dd0000c0":[{"id":342002,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    var counter = 0\n    return prog.map {\n        if $0 == \"+\" { counter += 1 }\n        else if $0 == \".\" { return String(UnicodeScalar(counter % 256)!) }\n        return \"\"\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342003,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  var output=\"\"\n  var memory_cell=0\n  for command in prog {\n    switch command{\n      case \"+\":\n        if memory_cell == 255 {\n                memory_cell = 0\n            } else {\n                memory_cell += 1\n            }\n      case \".\":\n        let c = String(Character(UnicodeScalar(memory_cell)!))\n        output.append(c)\n      default:\n        continue\n    }\n  \n  }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342004,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  var output: [UInt8] = []\n\n  var mem: UInt8 = 0\n  Array(prog).forEach {\n    switch $0 {\n      case \"+\": mem &+= 1\n      case \".\": output.append(mem)\n      default: ()\n    }\n  }\n  \n  return String(data: Data(output), encoding: .utf8) ?? \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342005,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\nvar cell = 0\n    var output = \"\"\n     for i in prog {\n        if i == \"+\" {\n             cell = (cell + 1 ) % 256\n          } else if i == \".\" {\n          output += \"\\(Character(UnicodeScalar(cell)!))\"\n          }\n       }\n     return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342006,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    var s: String = \"\"\n    var cell_size: Int = 0\n    for char in prog {\n        if char == \"+\" { cell_size += 1 }\n        else if char == \".\" { s += String(UnicodeScalar(cell_size % 256)!)}\n    }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342007,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    var s: String = \"\"\n    let ar_prog = Array(prog)\n    var cell_size: Int = 0\n    for char in ar_prog {\n        if char == \"+\" {\n            cell_size += 1\n        } else if char == \".\" {\n            s += String(UnicodeScalar(cell_size % 256)!)\n        }\n    }\n    return s\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342008,"user_id":null,"body":"\nfunc interpreter(_ prog: String) -> String {\n    var result = \"\"\n    var value = 0\n    prog.forEach { char in\n        if char == \"+\" {\n            value += 1\n        }\n        if value >= 256 {\n            value = 0\n        }\n        if char == \".\" {\n            result.append(Character(UnicodeScalar(value)!))\n        }\n    }\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342009,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    var str = String(), result = 0\n    for i in prog.indices {\n        if prog[i] == \"+\" {\n            if result == 255 { result = 0 } else { result += 1 }\n        }\n        else if prog[i] == \".\" {\n            if (result >= 32 && result <= 33) || (result >= 65 && result <= 90) || (result >= 97 && result <= 122) || result == 44 { str.append(Character(UnicodeScalar(result)!)) }\n        }\n    }\n    return str\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342010,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    let words = prog\n        .filter({$0 == \"+\" || $0 == \".\"})\n        .split(maxSplits: Int.max, omittingEmptySubsequences: false, whereSeparator: { $0 == \".\" })\n    var arr = [Int]()\n    var tmp = 0\n    for i in 0..<words.count - 1 {\n        tmp += words[i].count\n        tmp = tmp > 255 ? tmp - 256 : tmp\n        arr.append(tmp)\n    }\n    return arr.map({String(UnicodeScalar($0)!)}).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342011,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  var str = prog\n  str.removeAll { ![\"+\", \".\"].contains($0) }\n  var res = [String]()\n  var n = 0\n  for ch in str {\n    switch ch {\n      case \"+\":\n        n = (n == 255 ? 0 : n + 1)\n      default:\n        res.append(String(UnicodeScalar(UInt8(n))))\n    }\n  }\n  \n  return res.joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"586e6b54c66d18ff6c0015cd":[{"id":342012,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    guard list != [] else { return ([], []) }\n    let list = list.sorted(by: { $0 > $1 })\n    let target = list.reduce(0, +) \/ 2\n    var options = Array<Array<Int>?>(repeating: nil, count: target + 1)\n    if list[0] >= target {\n        return ([list[0]], Array(list[1..<list.endIndex]))\n    }\n    options[0] = []\n    for item in list {\n        for pos in (0...(target - item)).reversed() {\n            if let currentPosOption = options[pos], options[pos + item] == nil {\n                options[pos + item] = currentPosOption + [item]\n            }\n        }\n    }\n    let best = (options.filter({ $0 != nil }).last ?? [])!\n    var bestPos = 0\n    var rest: [Int] = []\n    for item in list {\n        if bestPos < best.count && item == best[bestPos] {\n            bestPos += 1\n        }\n        else {\n            rest.append(item)\n        }\n    }\n    return (best, rest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342013,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    var s = [Int: Set<Int>]()\n    return find(list.sorted(), i: 0, s: &s, remain: list.reduce(0, +) \/ 2, box: ([], [])).0\n}\n\nfunc find(_ list: [Int], i: Int, s: inout [Int: Set<Int>], remain: Int, box: ([Int], [Int])) -> (([Int], [Int]), Int, Bool) {\n    if remain == 0 { return ((box.0, box.1 + list[i..<list.count]), remain, true) }\n    guard remain >= 0 && (s[remain] == nil || !s[remain]!.contains(i)) else { return (([], []), INTPTR_MAX, false) }\n    guard i < list.count else { return (box, remain, false) }\n    s[remain, default: []].insert(i)\n    let a = find(list, i: i + 1, s: &s, remain: remain - list[i], box: (box.0 + [list[i]], box.1))\n    if a.2 { return a }\n    let b = find(list, i: i + 1, s: &s, remain: remain, box: (box.0, box.1 + [list[i]]))\n    return b.2 ? b : ((a.1 <= b.1) ? a : b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342014,"user_id":null,"body":"var bestDiff = 0, sortedList = [Int](), bestArr = [Int](),best = 0\n\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    guard list.count > 0 else { return ([],[]) }\n    sortedList = list.sorted {$0<$1}; bestDiff = list.reduce(0, +) - sortedList.last! * 2; bestArr = [sortedList.last!]; best = list.filter { $0 % 2 == 1}.count % 2 == 1 ? 1 : 0\n    recursion([sortedList.last!], list.count-2, bestDiff)\n    for number in bestArr { if let i = sortedList.firstIndex(of: number) { sortedList.remove(at: i) } }\n    return (bestArr, sortedList)\n}\n\nfunc recursion(_ a : [Int], _ index : Int, _ diff : Int) {\n    if(index != -1){\n        for i in (0...index).reversed() {\n            let newDiff = diff - sortedList[i] * 2\n            if abs(newDiff) < bestDiff {bestDiff = abs(newDiff); bestArr = a + [sortedList[i]]}\n            if newDiff > 0 && bestDiff != best {recursion(a + [sortedList[i]], i-1, newDiff)}\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342015,"user_id":null,"body":"var bestDiff = 0, sortedList = [Int](), bestArr = [Int](),best = 0\n\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    guard list.count > 0 else { return ([],[]) }\n    sortedList = list.sorted {$0<$1}; bestDiff = list.reduce(0, +) - sortedList.last! * 2; bestArr = [sortedList.last!]; best = list.filter { $0 % 2 == 1}.count % 2 == 1 ? 1 : 0\n    recursion([sortedList.last!], list.count-2, bestDiff)\n    for number in bestArr { if let i = sortedList.firstIndex(of: number) { sortedList.remove(at: i) } }\n    return (bestArr, sortedList)\n}\n\nfunc recursion(_ a : [Int], _ index : Int, _ diff : Int) {\n    var i = index\n    if(index != -1){\n        while i >= 0 {\n            let newDiff = diff - sortedList[i] * 2\n            if abs(newDiff) < bestDiff { bestDiff = abs(newDiff); bestArr = a + [sortedList[i]] }\n            if newDiff > 0 && bestDiff != best { recursion(a + [sortedList[i]], i-1, newDiff) }\n            else if bestDiff == best || sortedList.first! > (diff + bestDiff - 1)\/2 { break }\n            else { i = sortedList.lastIndex(where: {$0 <= (diff + bestDiff - 1)\/2 })! + 1;}\n            i -= 1\n        }\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342016,"user_id":null,"body":"\/\/Recursive approach to finding as close to the sum as possible. Assumes list is sorted in descending order\nfunc findHighestLowerSum(_ list: [Int], sum: Int, depth: Int = 0) -> [Int] {\n  var sums = [Int: [Int]]()\n  for (i, n) in list.enumerated() {\n    if n < sum {\n      if i+1 == list.endIndex {\n        sums[n] = [n]\n      } else {\n        var s = findHighestLowerSum([Int](list[(i+1)...]), sum: sum - n, depth: depth + 1)\n        s.insert(n, at: 0)\n        let ss = s.reduce(0, +)\n        if ss == sum {\n          return s\n        }\n        sums[ss] = s  \n      }\n    } else if n == sum {\n      return [n]\n    }\n  }\n  if sums.count > 0 {\n    return sums[sums.keys.max()!]!\n  } else {\n    return []\n  }\n}\n\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  let half = list.reduce(0, +) \/ 2\n  let list1 = [Int](findHighestLowerSum(list.sorted { $0 > $1 }, sum: half))\n  var list2 = list\n  list1.forEach {\n    list2.remove(at: list2.firstIndex(of: $0)!)\n  }\n  return (list1, list2)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342017,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    guard list != [] else { return ([], []) }\n    let list = list.sorted(by: { $0 > $1 })\n    let target = list.reduce(0, +) \/ 2\n    var options = Array<Array<Int>?>(repeating: nil, count: target + 1)\n    if list[0] >= target {\n        return ([list[0]], Array(list[1..<list.endIndex]))\n    }\n    options[0] = []\n    var bestOptionFound = false\n    for item in list {\n        guard bestOptionFound == false else {break}\n        for pos in (0...(target - item)).reversed() {\n            if let currentPosOption = options[pos],\n                options[pos + item] == nil {\n                options[pos + item] = currentPosOption + [item]\n                \/\/ MARK: If the best option is already found, break the loop\n                if pos + item == options.count - 1 {\n                    bestOptionFound = true\n                    break\n                }\n            }\n        }\n    }\n    let best = (options.filter({ $0 != nil }).last ?? [])!\n    \/\/ MARK: - Come up with the rest based on the best\n    var fullList: [Int?] = list\n    for element in best {\n        if let index = fullList.firstIndex(of: element) {\n            fullList[index] = nil\n        }\n    }\n    let rest = fullList.compactMap{$0}\n    return (best, rest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342018,"user_id":null,"body":"struct SumGroup {\n    let sum: Int\n    let distance: Int\n    let group: [Int]\n}\n\n\nfunc GenerateSumGroupsOrAnswer(_ xs: [Int],_ goal: Int,_ memo: inout [[Int]:[SumGroup]]) -> (groupsOrderedByDistance: [SumGroup], perfectResult: [Int]?) {\n    \n    \/\/ Do we already have the memoized result?\n    let memoRet = memo[xs]\n    if memoRet != nil {\n        return (memo[xs]!, nil)\n    }    \n    \n    \/\/ hashset\n    var seen = Set<Int>()\n    var groups: [SumGroup] = []\n\n    \/\/ These values will always be replaced\n    var best: SumGroup = SumGroup(sum: 0, distance: goal + 1, group: []) \n    var bestIndex = -1\n\n    \/\/for i in stride(from: xs.count - 1, through: 0, by: -1) {\n    for i in 0..<xs.count {\n        if i != xs.count - 1 {\n            let subResult = GenerateSumGroupsOrAnswer(Array(xs[i+1..<xs.count]), goal, &memo)\n            let possibleResult = subResult.perfectResult\n            if possibleResult != nil {\n                return ([], possibleResult!)\n            }\n            let subGroups = subResult.groupsOrderedByDistance\n\n            for subGroup in subGroups {\n                let sum = subGroup.sum + xs[i]\n                let distance = abs(goal - sum)\n\n                if distance <= subGroup.distance {\n                    if !seen.contains(distance) {\n                        let sumGroup = SumGroup(\n                            sum: sum, \n                            distance: distance, \n                            group: subGroup.group + [xs[i]])\n                        seen.insert(distance)\n                        groups.append(sumGroup)\n                        if sumGroup.distance < best.distance {\n                            best = sumGroup\n                            bestIndex = groups.count - 1\n                        }\n                    }\n                }\n            }\n        }\n\n        let distance = abs(goal - xs[i])\n        if !seen.contains(distance) {\n            seen.insert(distance)\n            let sumGroup = SumGroup(\n                sum: xs[i], \n                distance: distance, \n                group: [xs[i]])\n            groups.append(sumGroup)\n            if sumGroup.distance < best.distance {\n                best = sumGroup\n                bestIndex = groups.count - 1\n            }\n        }\n    }\n    \n    \/\/ Keeps optimal answer on top\n    if groups.count > 1 {\n        groups[bestIndex] = groups[0]\n        groups[0] = best\n    }\n\n    memo[xs] = groups\n    return (groups, nil)\n}\n\nfunc FindOptimalGroup(_ xs: [Int]) -> [Int] {\n    \/\/ skip first element\n    if xs.count > 2 {\n        let goal = xs.reduce(0, +) \/ 2\n        var memo = [[Int]:[SumGroup]]()\n        let result = GenerateSumGroupsOrAnswer(xs, goal, &memo)\n        guard let perfectResult = result.perfectResult else {\n            return result.groupsOrderedByDistance[0].group\n        }\n        return perfectResult\n    }\n\n\n    \/\/ print(\"returning trival result: \\([xs[0]])\")\n    return  [xs[0]]\n\n}\n\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    if list.count == 0 || list.count > 40 {\n        print(\"list \\(list.count): \\(list)\")\n        return ([], [])\n    }\n\n    let zeros = list.filter { $0 == 0 }\n    let nonzeros = list.filter { $0 != 0 }\n\n    \/\/ find optimal group\n    let optimalGroup = FindOptimalGroup(nonzeros)\n    \/\/ print(\"optimal group: \\(optimalGroup.reduce(0, +)) -- \\(optimalGroup)\")\n\n    var matchingGroup = nonzeros\n    for x in optimalGroup {\n        \/\/ remove first instance of x\n        if let i = matchingGroup.firstIndex(of: x) {\n            matchingGroup.remove(at: i)\n        }\n        else {\n            print(\"error \\(x) not found in \\(matchingGroup)\")\n            print(\"BestGroup: \\(optimalGroup)\")\n            print(\"MatchingGroup: \\(matchingGroup)\")\n        }\n    }\n    matchingGroup += zeros\n\n    \/\/ print(\"goal \\(list.reduce(0, +) \/ 2)\")\n    print(\"n:\\(list.count) -- optimal group: \\(optimalGroup.reduce(0, +)) - vs - matchingGroup: \\(matchingGroup.reduce(0, +))\")\n\n    return (optimalGroup, matchingGroup)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342019,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  var n = list.count\n  if n <= 1 { return (list, []) }\n  \n  var target = list.reduce(0, +) \/ 2\n  var b = [[1] + Array(repeating: 0, count: target)]\n  var x = [Int]()\n  var y = list\n  \n  \/\/ populate sums\n  for i in 0..<n {\n    var bi = Array(repeating: 0, count: target + 1)\n    for j in 0...target {\n      if b[i][j] == 1 || (j>=list[i] && b[i][j-list[i]] == 1) {\n        bi[j] = 1\n      }\n    }\n    b.append(bi)\n  }\n  \n  \/\/ find optimum\n  while b[b.count-1][target] != 1 && target >= 0 {\n    target -= 1\n  }\n    \n  \/\/ track back solution\n  while target > 0 && n > 0 {\n    n -= 1\n    if b[n][target] == 0 {\n      target -= list[n]\n      x.append(list[n])\n      y.remove(at: y.firstIndex(of: list[n])!)\n    }\n  }\n    \n  return (x,y)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342020,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  let lst = list.sorted()\n  let sum = lst.reduce(0, +)\n\n  guard !lst.isEmpty && sum > 0 else {\n    return (lst, [])\n  }\n\n  var table: [[[Int]]] = Array(repeating: Array(repeating: [], count: sum + 1),\n                                  count: lst.count + 1)\n  for i in 0...lst.count {\n    table[i][0] = [0]\n  }\n\n  for i in 1...lst.count {\n    for j in 1...sum {\n      table[i][j] = table[i - 1][j]\n      if table[i][j].isEmpty && lst[i - 1] <= j {\n        table[i][j] = table[i - 1][j - lst[i - 1]].map { $0 | (1 << (i - 1)) }\n      }\n    }\n  }\n\n  let j = (0...(sum \/ 2)).last(where: { !table[lst.count][$0].isEmpty })!\n  let solutions = table[lst.count][j]\n  let solution = solutions.first!\n\n  var l: [Int] = [], r: [Int] = []\n\n  for i in 0..<lst.count {\n    if solution & (1 << i) != 0 {\n      l.append(lst[i])\n    } else {\n      r.append(lst[i])\n    }\n  }\n\n  return (l, r)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342021,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    guard list.count > 0 else {\n        return ([],[])\n    }\n    let target = list.reduce(0, +) \/ 2\n    var f: [[Int]?] = Array(repeating: nil, count: target + 1)\n    let list = list.sorted(by: >)\n    if list[0] >= target{\n        return ([list[0]],Array(list[1...]))\n    }\n    f[0] = []\n    for num in list{\n        for pos in (0...(target - num)).reversed(){\n            if let currentPos = f[pos], f[pos + num] == nil{\n                f[pos + num] = currentPos + [num]\n            }\n        }\n    }\n    let best = f.compactMap({$0}).last ?? []\n    var rest = list\n    for num in best{\n        if let index = rest.firstIndex(of: num){\n            rest.remove(at: index)\n        }\n    }\n    return (best,rest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5870db16056584eab0000006":[{"id":342022,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n   let points = [\"3\",\"19\",\"7\",\"16\",\"8\",\"11\",\"14\",\"9\",\"12\",\"5\",\"20\",\"1\",\"18\",\"4\",\"13\",\"6\",\"10\",\"15\",\"2\",\"17\",\"3\"]\n    let point = String( points[Int( (atan2(dart.x,dart.y) * 180 \/ .pi + 189) \/ 18)] )\n    let distance = sqrt(dart.x*dart.x + dart.y*dart.y)\n    switch distance {\n    case ...6.35:\n        return \"DB\"\n    case ...15.9:\n        return \"SB\"\n    case ...99:\n        return point\n    case ...107:\n        return \"T\"+point\n    case ...162:\n        return point\n    case ...170:\n        return \"D\"+point\n    default:\n        return \"X\"\n    }\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342023,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  func changeDecatrtToPolar(x: Double, y: Double) -> (Double, Double){\n    let r = sqrt(pow(x, 2) + pow(y, 2))\n    \n    switch x {\n    case 0... where y >= 0:\n        return (r, atan(y\/x))\n    case 0... where y < 0:\n        return (r, atan(y\/x) + 2 * Double.pi)\n    case ..<0:\n        return (r, atan(y\/x) + Double.pi)\n    case 0 where y > 0:\n        return (r, Double.pi \/ 2)\n    case 0 where y < 0:\n        return (r, 3 * Double.pi \/ 2)\n    default:\n        return (0, 0)\n    }\n}\n  \n  func getRadiusScore (dart:(x: Double, y: Double)) -> Double {\n    let polarCord = changeDecatrtToPolar(x: dart.x, y: dart.y)\nswitch polarCord.0 {\n case 0..<12.70\/2:\n   return 50\ncase 12.70\/2..<31.8\/2:\n    return 25\ncase 99...107:\n    return 3\ncase 162..<170:\n    return 2\ncase 170...:\n    return 0\ndefault:\n    return 1\n}\n}\n  \n  func getSectorScore (dart:(x: Double, y: Double)) -> Double {\n    let polarCord = changeDecatrtToPolar(x: dart.x, y: dart.y)\n    \/\/print(\"fi = \\(polarCord.1)\")\n    let halfSec = Double.pi \/ 20\n    switch polarCord.1{\n    case halfSec..<halfSec * 3 :\n        return 13\n    case halfSec * 3..<halfSec * 5:\n        return 4\n    case halfSec * 5..<halfSec * 7:\n        return 18\n    case halfSec * 7..<halfSec * 9:\n        return 1\n    case halfSec * 9..<halfSec * 11:\n        return 20\n    case halfSec * 11..<halfSec * 13:\n    return 5\n    case halfSec * 13..<halfSec * 15:\n        return 12\n    case halfSec * 15..<halfSec * 17:\n        return 9\n    case halfSec * 17..<halfSec * 19:\n        return 14\n    case halfSec * 19..<halfSec * 21:\n        return 11\n    case halfSec * 21..<halfSec * 23:\n        return 8\n    case halfSec * 23..<halfSec * 25:\n        return 16\n    case halfSec * 25..<halfSec * 27:\n        return 7\n    case halfSec * 27..<halfSec * 29:\n        return 19\n    case halfSec * 29..<halfSec * 31:\n        return 3\n    case halfSec * 31..<halfSec * 33:\n        return 17\n    case halfSec * 33..<halfSec * 35:\n        return 2\n    case halfSec * 35..<halfSec * 37:\n        return 15\n    case halfSec * 37..<halfSec * 39:\n        return 10\n    default:\n        return 6\n    }\n}\n  \n  func getWholeScoredart(dart:(x: Double, y: Double)) -> (Double, Double) {\n    return (getRadiusScore(dart: dart), getSectorScore(dart: dart))\n}\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    let wholeScore = getWholeScoredart(dart: dart)\n    switch wholeScore.0{\n    case 50:\n        return \"DB\"\n    case 25:\n        return \"SB\"\n    case 0:\n        return \"X\"\n    case 2:\n        return \"D\\(Int(wholeScore.1))\"\n    case 3:\n        return \"T\\(Int(wholeScore.1))\"\n    default:\n        return \"\\(Int(wholeScore.1))\"\n    }\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342024,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  let singleNumbers = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5]\n  \n  enum DBRings: Double {\n    \/\/ Radii instead of diameters\n    case bullseye = 6.35 \/\/ 12.7 \/ 2.0\n    case bull = 15.9 \/\/ 31.8 \/ 2.0\n    case tripleInner = 99.0 \/\/ 198.0 \/ 2.0\n    case tripleOuter = 107.0 \/\/ 214.0 \/ 2.0\n    case doubleInner = 162.0 \/\/ 324.0 \/ 2.0\n    case doubleOuter = 170.0 \/\/ 340.0 \/ 2.0\n  }\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n\n    let distance = getDistance(dart)\n          \n    if distance < DBRings.bullseye.rawValue {\n\n      return \"DB\"\/\/\"Bull's Eye\"\n    }\n    if distance < DBRings.bull.rawValue {\n      return \"SB\"\/\/\"Bull\"\n    }\n    if distance > DBRings.doubleOuter.rawValue {\n      return \"X\"\/\/\"Outside of the board\"\n    }\n    \n    var multiFactor = \"\"\n    switch distance {\n      case DBRings.tripleInner.rawValue ..< DBRings.tripleOuter.rawValue:\n        multiFactor = \"T\"\n      case DBRings.doubleInner.rawValue ..< DBRings.doubleOuter.rawValue:\n        multiFactor = \"D\"\n      default:\n        break\n    }\n    \n    let score = getIndividualScore(dart) \n    \n    return multiFactor + \"\\(score)\"\n  }\n  \n  func getDistance(_ dart: (x: Double, y: Double)) -> Double {\n    return sqrt((dart.x * dart.x) + (dart.y * dart.y))\n\n  }\n  \n  func getIndividualScore(_ dart: (x: Double, y: Double)) -> Int {\n    var sliceIndex = atan2(dart.x, dart.y) * 10 \/ .pi\n    if sliceIndex < 0 { \n      sliceIndex += 20 \n    }\n    sliceIndex = sliceIndex.rounded()\n    \n    if sliceIndex == 20 {\n      sliceIndex = 0\n    }\n    \n    return singleNumbers[Int(sliceIndex)]\n  }\n  \n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342025,"user_id":null,"body":"class Dartboard {\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    let distance = pow((dart.x * dart.x + dart.y * dart.y), 0.5)\n    var angle = atan(dart.x \/ dart.y) * 180 \/ Double.pi\n    if dart.x < 0 && dart.y > 0 {angle += 360}\n    if dart.x < 0 && dart.y < 0 {angle += 180}\n    if dart.x > 0 && dart.y < 0 {angle += 180}\n    var scores = 0\n    switch angle {\n    case 9..<27:    scores = 1\n    case 27..<45:   scores = 18\n    case 45..<63:   scores = 4\n    case 63..<81:   scores = 13\n    case 81..<99:   scores = 6\n    case 99..<117:  scores = 10\n    case 117..<135: scores = 15\n    case 135..<153: scores = 2\n    case 153..<171: scores = 17\n    case 171..<189: scores = 3\n    case 189..<207: scores = 19\n    case 207..<225: scores = 7\n    case 225..<243: scores = 16\n    case 243..<261: scores = 8\n    case 261..<279: scores = 11\n    case 279..<297: scores = 14\n    case 297..<315: scores = 9\n    case 315..<333: scores = 12\n    case 333..<351: scores = 5\n    default:        scores = 20\n    }\n    switch distance {\n    case 0..<12.7 \/ 2:              return \"DB\"\n    case (12.7 \/ 2)...(31.8 \/ 2):   return \"SB\"\n    case (198 \/ 2)..<(214 \/ 2):     return \"T\\(scores)\"\n    case (324 \/ 2)..<(340 \/ 2):     return \"D\\(scores)\"\n    case (340 \/ 2)...:              return \"X\"\n    default:                        return \"\\(scores)\"\n    }\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342026,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    let distance = pow((dart.x * dart.x + dart.y * dart.y), 0.5)\n    var multiplier = 0\n    var angle = atan(dart.x \/ dart.y) * 180 \/ Double.pi\n    if dart.x < 0 && dart.y > 0 {angle += 360}\n    if dart.x < 0 && dart.y < 0 {angle += 180}\n    if dart.x > 0 && dart.y < 0 {angle += 180}\n    var scores = 0\n    switch angle {\n    case 9..<27:\n        scores = 1\n    case 27..<45:\n        scores = 18\n    case 45..<63:\n        scores = 4\n    case 63..<81:\n        scores = 13\n    case 81..<99:\n        scores = 6\n    case 99..<117:\n        scores = 10\n    case 117..<135:\n        scores = 15\n    case 135..<153:\n        scores = 2\n    case 153..<171:\n        scores = 17\n    case 171..<189:\n        scores = 3\n    case 189..<207:\n        scores = 19\n    case 207..<225:\n        scores = 7\n    case 225..<243:\n        scores = 16\n    case 243..<261:\n        scores = 8\n    case 261..<279:\n        scores = 11\n    case 279..<297:\n        scores = 14\n    case 297..<315:\n        scores = 9\n    case 315..<333:\n        scores = 12\n    case 333..<351:\n        scores = 5\n    default:\n        scores = 20\n    }\n    switch distance {\n    case 0..<12.7 \/ 2:\n        return \"DB\"\n    case (12.7 \/ 2)...(31.8 \/ 2):\n        return \"SB\"\n    case (198 \/ 2)..<(214 \/ 2):\n        return \"T\\(scores)\"\n    case (324 \/ 2)..<(340 \/ 2):\n        return \"D\\(scores)\"\n    case (340 \/ 2)...:\n        return \"X\"\n    default:\n        return \"\\(scores)\"\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342027,"user_id":null,"body":"class Dartboard {\n    \n  private let vs = [1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5, 20]\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    \n    let d = sqrt(dart.x * dart.x + dart.y * dart.y) * 2\n    \n    guard d < 340 else { return \"X\" }\n    guard d >= 12.7 else { return \"DB\" }\n    guard d >= 31.8 else { return \"SB\" }\n    \n    let p: String\n    \n    switch d {\n      case 198..<214: p = \"T\"\n      case 324..<340: p = \"D\"\n      default: p = \"\"\n    }\n    \n    let a = .pi \/ 2 - atan(dart.y \/ dart.x) + (dart.x < 0 ? .pi : 0) - .pi \/ 20\n    let s = a \/ 2 \/ .pi * 20\n    let i = (Int(s) + 20) % 20\n    \n    return \"\\(p)\\(vs[i])\"\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342028,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n      let x = dart.0\n      let y = dart.1\n    var sector: Int = 0\n    var doubleTrippleSector: String = \"\"\n    \n    if sqrt(x*x + y*y) < 12.7\/2{\n            return \"DB\"\n        }\n    if sqrt(x*x + y*y) < 31.8\/2 {\n            return \"SB\"\n        }\n    if sqrt(x*x + y*y) > 340\/2 {\n            return \"X\"\n        }\n    \n    let tan = y\/x\n    let atg = atan(tan) \/ Double.pi * 180\n    var degrees: Double = 0\n    \n    if x >= 0 && y >= 0 {\n        degrees = atg\n    }\n    \n    if x < 0 && y >= 0 {\n        degrees = 180 + atg\n    }\n    \n    if x < 0 && y < 0 {\n        degrees = 180 + atg\n    }\n    \n    if x >= 0 && y < 0 {\n        degrees = 360 + atg\n    }\n    \n    switch degrees {\n    case 0..<9: sector = 6\n    case 9..<27: sector = 13\n    case 27..<45: sector = 4\n    case 45..<63: sector = 18\n    case 63..<81: sector = 1\n    case 81..<99: sector = 20\n    case 99..<117: sector = 5\n    case 117..<135: sector = 12\n    case 135..<153: sector = 9\n    case 153..<171: sector = 14\n    case 171..<189: sector = 11\n    case 189..<207: sector = 8\n    case 207..<225: sector = 16\n    case 225..<243: sector = 7\n    case 243..<261: sector = 19\n    case 261..<279: sector = 3\n    case 279..<297: sector = 17\n    case 297..<315: sector = 2\n    case 315..<333: sector = 15\n    case 333..<351: sector = 10\n    default: sector = 6\n    }\n    \n    if sqrt(x*x + y*y) > 198\/2 && sqrt(x*x + y*y) < 214\/2  {\n        doubleTrippleSector = \"T\"\n    }\n    if sqrt(x*x + y*y) > 324\/2 && sqrt(x*x + y*y) < 340\/2  {\n        doubleTrippleSector = \"D\"\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    return \"\\(doubleTrippleSector)\\(sector)\"\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342029,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    print(dart)\n    var a = atan2(dart.y, dart.x) \/ Double.pi * 180\n    if a < 0 { a += 360 }\n    let d = sqrt(pow(dart.x, 2)+pow(dart.y, 2))\n    let values = [6, 13, 4, 18, 1, 20, 5, 12, 9, 14, 11, 8, 16, 7, 19, 3, 17, 2, 15, 10]\n    \n    if d > 170 { return \"X\" }\n    if d < 6.35 { return \"DB\" }\n    if d < 15.9 { return \"SB\" }\n    \n    let value = values[Int(round(a\/18))]\n    let double = d > 162 ? \"D\" : \"\"\n    let triple = d > 99 && d < 107 ? \"T\" : \"\"\n    \n    return double + triple + String(value)\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342030,"user_id":168,"body":"import Foundation\n\nclass Dartboard {\n  let scores = [11, 8, 16, 7, 19, 3, 17, 2, 15, 10, 6, 13, 4, 18, 1, 20, 5, 12, 9, 14, 11]\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    let d = 2 * hypot(dart.x, dart.y)\n    if d >= 340 { return \"X\" }\n    if d < 12.7 { return \"DB\" }\n    if d < 31.8 { return \"SB\" }\n    let a = Int(atan2(dart.y, dart.x) * 10 \/ Double.pi + 10.5)\n    return \"\\(198 < d && d < 214 ? \"T\" : 324 < d ? \"D\" : \"\")\\(scores[a])\"\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342031,"user_id":null,"body":"import Foundation\n\nclass Dartboard {\n  \n  func getScore(dart: (x: Double, y: Double)) -> String {\n    let distance = sqrt(dart.x * dart.x + dart.y * dart.y)\n    guard distance <= 170 else { return \"X\" }\n\n    if distance < 6.35 {\n        return \"DB\"\n    } else if distance < 15.9 {\n        return \"SB\"\n    }\n\n    var mod = \"\"\n    if distance >= 162 {\n        mod = \"D\"\n    } else if distance <= 107, distance >= 99 {\n        mod = \"T\"\n    }\n\n    let values = [11,8,16,7,19,3,17,2,15,10,6,13,4,18,1,20,5,12,9,14,11]\n    let angle = atan2(dart.y, dart.x)\n    let idx = Int(angle * 3.1831 + 10.5)\n    return \"\\(mod)\\(values[idx])\"\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"587387d169b6fddc16000002":[{"id":342032,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  let m = list.reduce(0, +) \/ 2\n  \n  var combos : [([Int], Int)] = [([], 0)]\n  \n  for (i, val) in list.enumerated() {\n    combos += combos.filter{ (a, s) in s + val <= m}.map{(a, s) in (a + [i], s + val) }\n  }\n  \n  let arr = combos.sorted{abs($0.1 - m) > abs($1.1 - m)}.last!.0\n  var ma = [Int](), mb = [Int]()\n  \n  for (i, val) in list.enumerated() {\n    if arr.contains(i) { ma.append(val) }\n    else { mb.append(val) }\n  }\n  \n  return (ma, mb)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342033,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    var tempSmallestArray0 = [Int]()\n    var tempSmallestArray1 = [Int]()\n    \n    var num = 1\n    \n    for i in 0...list.count {\n        num = num * 2\n    }\n    \n    num -= 1\n    \n    while num >= 0 {\n        var array0 = [Int]()\n        var array1 = [Int]()\n        var numArray = Array(String(num, radix: 2))\n        while numArray.count < list.count {\n            numArray.insert(\"0\", at: 0)\n        }\n    \n        for i in 0..<list.count {\n            if numArray[i] == \"0\" {\n                array0.append(list[i])\n            } else {\n                array1.append(list[i])\n            }\n        }\n        if tempSmallestArray0.count > 0 {\n            if (abs(array0.reduce(0, +) - array1.reduce(0, +)) < abs(tempSmallestArray0.reduce(0, +) - tempSmallestArray1.reduce(0, +))) {\n                tempSmallestArray0 = array0\n                tempSmallestArray1 = array1\n            }\n        } else {\n            tempSmallestArray0 = array0\n            tempSmallestArray1 = array1\n        }\n        \n        num -= 1\n    }\n    \n    return (tempSmallestArray0, tempSmallestArray1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342034,"user_id":311,"body":"\/\/ MARK: - This is an update based on TellowKrinkle's algathrim, which uses Dynamic Programming\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    guard list != [] else { return ([], []) }\n    let list = list.sorted(by: { $0 > $1 })\n    let target = list.reduce(0, +) \/ 2\n    var options = Array<Array<Int>?>(repeating: nil, count: target + 1)\n    if list[0] >= target {\n        return ([list[0]], Array(list[1..<list.endIndex]))\n    }\n    options[0] = []\n    var bestOptionFound = false\n    for item in list {\n        guard bestOptionFound == false else {break}\n        for pos in (0...(target - item)).reversed() {\n            if let currentPosOption = options[pos],\n                options[pos + item] == nil {\n                options[pos + item] = currentPosOption + [item]\n                \/\/ MARK: If the best option is already found, break the loop\n                if pos + item == options.count - 1 {\n                    bestOptionFound = true\n                    break\n                }\n            }\n        }\n    }\n    let best = (options.filter({ $0 != nil }).last ?? [])!\n    \/\/ MARK: - Come up with the rest based on the best\n    var fullList: [Int?] = list\n    for element in best {\n        if let index = fullList.firstIndex(of: element) {\n            fullList[index] = nil\n        }\n    }\n    let rest = fullList.compactMap{$0}\n    return (best, rest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342035,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  let sum = list.reduce(0, +)\n\n  func spl(_ i: Int, _ acc: (Int, ([Int], [Int]))) -> (Int, ([Int], [Int])) {\n    if i >= list.count {\n      return acc\n    }\n    let r1 = spl(i + 1, (acc.0 + list[i], (acc.1.0 + [list[i]], acc.1.1)))\n    let r2 = spl(i + 1, (acc.0, (acc.1.0, acc.1.1 + [list[i]])))\n    \n    return abs(sum \/ 2 - r1.0) <= abs(sum \/ 2 - r2.0) ? r1 : r2\n  }\n  \n  return spl(0, (0, ([], []))).1\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342036,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    return find(list, i: 0, remain: list.reduce(0) { return $0 + $1 } \/ 2, box: ([], [])).0\n}\n\nfunc find(_ list: [Int], i: Int, remain: Int, box: ([Int], [Int])) -> (([Int], [Int]), Int) {\n    guard remain >= 0 else { return (([], []), INTPTR_MAX) }\n    guard i < list.count else { return (box, remain) }\n    let a = find(list, i: i + 1, remain: remain - list[i], box: (box.0 + [list[i]], box.1))\n    let b = find(list, i: i + 1, remain: remain, box: (box.0, box.1 + [list[i]]))\n    return (a.1 <= b.1) ? a : b\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342037,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  let result = list._splitList()\n  return (result.0, result.1)\n}\n\nextension RandomAccessCollection where Element == Int {\n  func _splitList(lPartial: [Int] = [], rPartial: [Int] = [], diff: Int = 0) -> ([Int], [Int], diff: Int) {\n    guard !isEmpty else {\n      return (lPartial: lPartial, rPartial: rPartial, diff: diff)\n    }\n    let (head, last) = (dropLast(), self.last!)\n    let r = head._splitList(lPartial: lPartial + [last], rPartial: rPartial, diff: diff - last)\n    guard !lPartial.isEmpty else {\n      \/\/ return early for first iteration, no need to duplicate work for mirror solution\n      return r\n    }\n    let l = head._splitList(lPartial: lPartial, rPartial: rPartial + [last], diff: diff + last)\n    if abs(l.diff) < abs(r.diff) {\n      return l\n    } else {\n      return r\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342038,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n\tguard list != [] else { return ([], []) }\n\tlet list = list.sorted(by: { $0 > $1 })\n\tlet target = list.reduce(0, +) \/ 2\n\tvar options = Array<Array<Int>?>(repeating: nil, count: target + 1)\n\tif list[0] >= target {\n\t\treturn ([list[0]], Array(list[1..<list.endIndex]))\n\t}\n\toptions[0] = []\n\tfor item in list {\n\t\tfor pos in (0...(target - item)).reversed() {\n\t\t\tif let currentPosOption = options[pos], options[pos + item] == nil {\n\t\t\t\toptions[pos + item] = currentPosOption + [item]\n\t\t\t}\n\t\t}\n\t}\n\tlet best = (options.filter({ $0 != nil }).last ?? [])!\n\tvar bestPos = 0\n\tvar rest: [Int] = []\n\tfor item in list {\n\t\tif bestPos < best.count && item == best[bestPos] {\n\t\t\tbestPos += 1\n\t\t}\n\t\telse {\n\t\t\trest.append(item)\n\t\t}\n\t}\n\treturn (best, rest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342039,"user_id":null,"body":"func splitlist(_ list: [Int]) -> ([Int], [Int]) {\n  \n  func split(_ a: [Int], _ b: [Int], _ r: [Int]) -> (a: [Int], b: [Int]) {\n    guard let x = r.last else { return (a, b) }\n    let v1 = split(a + [x], b, r.dropLast())\n    let v2 = split(a, b + [x], r.dropLast())\n    return abs(v1.a.reduce(0, +) - v1.b.reduce(0, +)) < abs(v2.a.reduce(0, +) - v2.b.reduce(0, +)) ? v1 : v2\n  }\n  \n  return split([], [], list)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342040,"user_id":null,"body":"import Foundation\n\nvar minResult: (a: [Int], b: [Int], abs: Int) = ([], [], Int.max)\n\n\nfunc sum(_ list: [Int]) -> Int {\n    return list.reduce(into: 0, { $0 += $1 })\n}\n\nfunc splitter(inList: [Int], a: [Int], b:[Int])  {\n    if inList.isEmpty {\n        let result = abs(sum(a) - sum(b))\n        if minResult.abs > result {\n           minResult = (a, b, result)\n        }\n        return\n    }\n    \n    var newList = inList\n    let element = newList.removeFirst()\n    splitter(inList: newList, a: a + [element], b: b)\n    splitter(inList: newList, a: a, b: b + [element])\n}\n\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    minResult = ([], [], Int.max)\n    splitter(inList: list, a: [], b: [])\n    return (minResult.a, minResult.b)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342041,"user_id":null,"body":"extension RangeReplaceableCollection {\n    \/\/ this extension is taken here https:\/\/stackoverflow.com\/questions\/25162500\/swift-generate-combinations-with-repetition\n  \n    func uniqueCombinations(of n: Int) -> [SubSequence] {\n        guard n > 0 else { return [.init()] }\n        guard let first = first else { return [] }\n        return dropFirst().uniqueCombinations(of: n - 1).map { CollectionOfOne(first) + $0 } + dropFirst().uniqueCombinations(of: n)\n    }\n}\n\n\n\nfunc splitlist(_ list: [Int]) -> ([Int], [Int]) {\n    if list.count == 0 { return ([], [])}\n    else if list.count == 1 { return (list, []) }\n    else if list.count == 2 { return ([list.first!], [list.last!]) }\n    let sum = list.reduce(0, +)\n    let half = sum \/ 2\n    var _list = list\n    var curSum = sum\n    var closest = [Int]()\n    var minDiff = Int.max\n    \n    while curSum > half {\n        let num = _list.removeFirst()\n        curSum -= num\n    }\n    \/\/ finding what is r for rCn\n    let meredian = _list.count\n    \n    let range = (meredian - 1 >= 1 ? meredian - 1 : 1)...(meredian + 1 < list.count ? meredian + 1 : list.count - 1)\n    \n    \n    for i in range {\n        let combs = list.uniqueCombinations(of: i).map{Array($0)}\n        for comb in combs {\n            let currentSum = comb.reduce(0, +)\n            let currentDiff = abs (sum - 2 * currentSum)\n            if currentDiff < minDiff {\n                minDiff = currentDiff\n                closest = comb\n            }\n        }\n    }\n    \n    var rest = list\n    for num in closest {\n        if let i = rest.firstIndex(of: num) {\n            _ = rest.remove(at: i)\n        }\n    }\n    \n    return (closest, rest)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"587731fda577b3d1b0001196":[{"id":342042,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n  return str.capitalized.replacingOccurrences(of: \" \", with: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342043,"user_id":null,"body":"import Foundation\n\nfunc camel_case(_ str: String) -> String {\n  return str.capitalized.split(separator: \" \").joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342044,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n    str.capitalized.filter {$0 != \" \"}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342045,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n    return str.capitalized.filter {$0 != \" \"}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342046,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n  return str.capitalized(with: nil).replacingOccurrences(of: \"\\\\s\", with: \"\", options: .regularExpression)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342047,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n    \n    var k = 0\n    var finalStr = \"\"\n    \n    for char in \" \" + str  {\n        if char == Character(\" \") {\n            k += 1\n        } else if k > 0{\n            finalStr += \"\\(char)\".uppercased()\n            k = 0\n        } else {\n            finalStr += \"\\(char)\"\n        }\n        \n    }\n    \n    return finalStr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342048,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n  return str.split(separator:\" \").map({item in String(item.prefix(1).uppercased()) + item.dropFirst() }).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342049,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n    let arr = str.split(separator: \" \")\n    var camel: String = \"\"\n    for elem in arr {\n        \n        camel += elem.firstUppercased\n    }\n    return camel\n}\n\n\nextension StringProtocol {\n    var firstUppercased: String { return prefix(1).uppercased() + dropFirst() }\n\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342050,"user_id":null,"body":"func camel_case(_ str: String) -> String {\n  return str.split(separator: \" \").map { $0.prefix(1).capitalized + $0.dropFirst() }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342051,"user_id":null,"body":"\nfunc camel_case(_ str: String) -> String {\n return str.capitalized(with: nil).replacingOccurrences(of: \" \", with: \"\")\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"587edac2bdf76ea23500011a":[{"id":342052,"user_id":53,"body":"func interpreter(_ prog: String) -> String {\n  let input = Array(prog)\n  var result = \"\"\n  var xs = [Int : Int]()\n  var i = 0\n  var p = 0\n  while i < input.count {\n    let c = input[i]\n    if c == \"*\" {\n      result.append(Character(UnicodeScalar(xs[p] ?? 0)!))\n    } else if c == \"+\" {\n      xs[p] = ((xs[p] ?? 0) + 1) % 256\n    } else if c == \">\" {\n      p += 1\n    } else if c == \"<\" {\n      p -= 1\n    }\n    i += 1\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342053,"user_id":null,"body":"struct Tick: CustomStringConvertible {\n    var memory : [Int:UInt8] = [0:0]\n    var cell = 0\n    var tape = Data()\n    \n    mutating func right() { cell += 1 }\n    mutating func left() { cell -= 1 }\n    mutating func plus() { memory[cell] = memory[cell, default: 0].addingReportingOverflow(1).partialValue }\n    mutating func outptut() { tape.append(memory[cell, default: 0]) }\n    \n    mutating func runProgram(_ prog: String) {\n        for op in prog {\n            switch op {\n            case \">\": right()\n            case \"<\": left()\n            case \"+\": plus()\n            case \"*\": outptut()\n            default: continue\n            }\n        }\n    }\n    \n    var description: String { return String(data: tape, encoding: .utf8) ?? \"\" }\n}\n\nfunc interpreter(_ prog: String) -> String {\n    var vm = Tick()\n    vm.runProgram(prog)\n    return vm.description\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342054,"user_id":50,"body":"func interpreter(_ prog: String) -> String {\n  var d = [Int : Int]()\n  d[0] = 0\n  var o:String = \"\"\n  var i = 0\n  for c in prog {\n    if c == \">\" {\n      i+=1\n    } else if c == \"<\" {\n      i-=1\n    } else if c == \"+\" {\n      d[i] = ((d[i] ?? 0) + 1) % 256\n    } else if c == \"*\" {\n      o = \"\\(o)\\(String(UnicodeScalar(d[i]!)!))\" \n    }\n  }\n  return o\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342055,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  var cells: [Int] = [0]\n  var pointer: Int = 0\n  var result: String = \"\"\n  \n  for c in prog {\n    switch c {\n      case \"+\":\n        if cells[pointer] == 255 {\n          cells[pointer] = 0\n        } else {\n          cells[pointer] += 1\n        }\n      case \"<\":\n        if pointer == 0 {\n          cells.insert(0, at: 0)\n        } else {\n          pointer -= 1\n        }\n      case \">\":\n        if pointer == cells.count - 1 {\n          cells.append(0)\n          }\n        pointer += 1\n      case \"*\":\n        result.append(String(UnicodeScalar(UInt8(cells[pointer]))))\n      default:\n        return \"Wrong command\"\n    }\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342056,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  var buf = [0]\n  var out = [Int]()\n  var i = 0\n  \n  prog.forEach {\n    switch $0 {\n    case \">\":\n      i += 1\n      if i == buf.count {\n        buf.append(0)\n      }\n    case \"<\":\n      i -= 1\n      if i == -1 {\n        buf.insert(0, at: 0)\n        i = 0\n      }\n    case \"+\": buf[i] += 1\n    case \"*\": out.append(buf[i])\n    default: break\n    }\n  }\n  \n  return String(\n    out\n      .map { UInt8($0 % 256) }\n      .compactMap { UnicodeScalar($0) }\n      .compactMap { Character($0) }\n  )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342057,"user_id":null,"body":"extension StringProtocol {\n    subscript(offset: Int) -> Character {\n        self[index(startIndex, offsetBy: offset)]\n    }\n}\n\nfunc interpreter(_ prog: String) -> String {\n    var ans = String()\n    var stk = [Int]()\n    stk.append(0)\n    var current = 0\n    var i = 0\n    while i < prog.count {\n        \n        let c = prog[i]\n        \n        switch c {\n        case \"+\":\n            stk[current] += 1\n            if (stk[current] == 256) {\n                stk[current] = 0\n            }\n            break\n        case \"<\":\n            if current == 0 {\n                stk.insert(0, at: stk.startIndex)\n            } else {\n                current -= 1\n            }\n            break\n        case \">\":\n            if current == stk.count-1 {\n                stk.append(0)\n            }\n            current += 1\n        case \"*\":\n            ans.append(Character(UnicodeScalar(stk[current])!))\n            break\n        \n        default:\n            break\n        }\n        i+=1\n    }\n    return ans\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342058,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  var intValue = 0;\n  var interpreterString: [String] = [];\n  var ind: Int = 0;\n  var interpreterStringIndex: Int {\n      get {\n          return ind;\n      }\n      set {\n          if (newValue < 0)\n          {\n              ind = 0;\n          }\n          else\n          {\n              ind = newValue;\n          }\n      }\n  }\n  var isPlus: Bool = false;\n  var isAsterix: Bool = false;\n\n  for sign in prog {\n      switch sign {\n      case \"+\":\n          if (isAsterix)\n          {\n              intValue = 0;\n          }\n          intValue += 1;\n          if (intValue == 256)\n          {\n              intValue = 0;\n          }\n          isPlus = true;\n          isAsterix = false;\n      case \"*\":\n          if (isPlus)\n          {\n              interpreterString.append(String(Character(UnicodeScalar(intValue)!)));\n\n          }\n          else if (isAsterix)\n          {\n              interpreterString.append(interpreterString.last!);\n              interpreterStringIndex += 1;\n          }\n          else\n          {\n              interpreterString.append(interpreterString[interpreterStringIndex]);\n              intValue = 0;\n          }\n          isAsterix = true;\n          isPlus = false;\n      case \">\":\n          interpreterStringIndex += 1;\n          isPlus = false;\n          isAsterix = false;\n          intValue = 0;\n      case \"<\":\n          interpreterStringIndex -= 1;\n          isPlus = false;\n          isAsterix = false;\n          intValue = 0;\n      default:\n          break;\n      }\n  }\n\n  return interpreterString.joined();\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342059,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    let arr = prog.map({ String($0) })\n    var blocks = [0]\n    var selectedBlock = 0\n    var output = \"\"\n    for i in 0..<arr.count {\n        switch arr[i] {\n        case \"+\":\n            blocks[selectedBlock] += 1\n        case \"*\":\n            output += String(UnicodeScalar(blocks[selectedBlock] % 256)!)\n        case \">\":\n            selectedBlock += 1\n            if blocks.indices.contains(selectedBlock) == false {\n                blocks.append(0)\n            }\n        case \"<\":\n            selectedBlock -= 1\n            if blocks.indices.contains(selectedBlock) == false {\n                blocks.insert(0, at: 0)\n                selectedBlock += 1\n            }\n        default:\n            continue\n        }\n        \n    }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342060,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n    let arr = prog.map({ String($0) })\n    var blocks = [0]\n    var selectedBlock = 0\n    var output = \"\"\n    for i in 0..<arr.count {\n        switch arr[i] {\n        case \"+\":\n            blocks[selectedBlock] += 1\n        case \"*\":\n            output += String(UnicodeScalar(blocks[selectedBlock] % 256)!)\n        case \">\":\n            \/\/ if block to right doesn't exist, then create one\n            selectedBlock += 1\n            if blocks.indices.contains(selectedBlock) == false {\n                blocks.append(0)\n            }\n        case \"<\":\n            \/\/ if block to left doesn't exist, then create one\n            selectedBlock -= 1\n            if blocks.indices.contains(selectedBlock) == false {\n                blocks.insert(0, at: 0)\n                selectedBlock += 1\n            }\n        default:\n            continue\n        }\n        \n    }\n    print(blocks)\n  print(prog)\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342061,"user_id":464,"body":"func interpreter(_ prog: String) -> String {\n    var memory: [Int: Int] = [:]\n    var pointer = 0\n    var output = \"\"\n    for instruction in prog {\n        switch instruction {\n        case \"<\":\n            pointer -= 1\n        case \">\":\n            pointer += 1\n        case \"+\":\n            memory[pointer] = (1 + (memory[pointer] ?? 0)) % 256\n        case \"*\":\n            output.append(Character(UnicodeScalar(memory[pointer] ?? 0)!))\n        default:\n            break\n        }\n    }\n    return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58841cb52a077503c4000015":[{"id":342062,"user_id":527,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    return (fst + n \/ 2) % n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342063,"user_id":645,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    return (n \/ 2 + fst) % n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342064,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    let arr = (0..<n)\n    let angleDifference = 360.0 \/ Double(arr.count)\n    let indexChange = Int((180.0 \/ angleDifference).rounded())\n    print(\"N: \\(n)  fst: \\(fst) \nvalue: \\(arr[((arr.firstIndex(of: fst) ?? 0) + indexChange) % arr.count])\")\n    return arr[((arr.firstIndex(of: fst) ?? 0) + indexChange) % arr.count]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342065,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    (fst + n \/ 2) % n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342066,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    let circle = (0...n - 1).count\n    return fst < circle \/ 2 ? fst + (circle \/ 2) : fst - (circle \/ 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342067,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    fst + (n\/2 > fst ? n\/2 : -n\/2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342068,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n  var res = 0\n    var center = n \/ 2\n  if fst < center {\n    res = center + fst\n  } else if fst > center {\n    res = fst - center\n  } else {\n    res = 0\n  }\n  return res\n}\n\n\/\/ 0 1 2 3 4 5 6 7 8 9         10 2 = 7\n\/\/ 0 1 2 3 4 5 6 7 8 9         10 7 = 2\n\/\/ 0 1 2 3                      4 1 = 3\n\/\/ 0 1 2 3 4 5                   6 3 = 0\n\/\/ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19               20 0 = 10","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342069,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    if (fst + n\/2) >= n\n    {\n      return fst - n\/2\n    }\n    else\n    {\n      return fst + n\/2\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342070,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    \/\/ your code here\n  return ((n \/ 2) + fst) >= n ? ((n \/ 2) + fst) - n : ((n \/ 2) + fst)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342071,"user_id":null,"body":"func circleOfNumbers(_ n: Int, _ fst: Int) -> Int {\n    let half = (n \/ 2)\n    return half > fst ? half + fst : abs(half - fst)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58855acc9e1de22dff0000ef":[{"id":342072,"user_id":53,"body":"func interpreter(_ prog: String) throws -> String {\n  let clean = prog.replacingOccurrences(of: \"[^*\\\\-\\\\!\\\\+\\\\^\\\\[\\\\]]\", with: \"\", options: [.regularExpression])\n  let input = Array(clean)\n  var jumps = [Int : Int]()\n  var opens = [Int]()\n  var ls = [Int]()\n  var ys = \"\"\n  ls.append(0)\n  for i in stride(from: 0, through: input.count - 1, by: 1) {\n    let c = input[i]\n    if c == \"[\" {\n      opens.append(i)\n    } else if c == \"]\" {\n      jumps[i] = opens[opens.count-1]\n      jumps[opens[opens.count-1]] = i\n      opens.removeLast()\n    }\n  }\n  var i = 0\n  while i < input.count {\n    let c = input[i]\n    let el = ls[ls.count-1]\n    if c == \"^\" {\n      if ls.count < 2 {\n        throw NSError(domain: \"esolang\", code: 500, userInfo: nil)\n      }\n      ls.removeLast()\n    } else if c == \"!\" {\n      ls.append(0)\n    } else if c == \"+\" {\n      ls[ls.count-1] = (el + 1) % 256\n    } else if c == \"-\" {\n      ls[ls.count-1] = (el + 256 - 1) % 256\n    } else if c == \"*\" {\n      ys.append(Character(UnicodeScalar(el)!))\n    } else if c == \"[\" && el == 0 {\n      i = jumps[i] ?? 0\n    } else if c == \"]\" && el != 0 {\n      i = jumps[i] ?? 0\n    }\n    i += 1\n  }\n  return ys\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342073,"user_id":null,"body":"enum interpreterError: Error {\n    case error\n}\n\nfunc interpreter(_ prog: String) throws -> String {\n    let singleProg = prog.map{$0}\n    var stack: [Int] = [0]\n    var goTo = 0\n    var index = 0\n    var stream: [String] = []\n    while index != singleProg.count {\n        switch singleProg[index] {\n            case \"+\":\n                if stack.count != 0 {\n                    stack[0] = stack[0] != 255 ? stack[0] + 1 : 0\n                } else {throw interpreterError.error}\n            case \"-\":\n                if stack.count != 0 {\n                    stack[0] = stack[0] != 0 ? stack[0] - 1 : 255\n                } else {throw interpreterError.error}\n            case \"*\":\n                stream.append(String(UnicodeScalar(stack[0])!))\n            case \"!\":\n                stack.insert(0, at: 0)\n            case \"[\":\n                if stack.count != 0 {\n                    goTo = index\n                    if stack[0] == 0 {\n                        index = singleProg.dropFirst(index).firstIndex{$0 == \"]\"}!\n                    }\n                } else {throw interpreterError.error}\n\n            case \"]\":\n                if stack.count != 0 {\n                    if stack[0] != 0 {\n                        index = goTo\n                    }\n                } else {throw interpreterError.error}\n            case \"^\":\n                if stack.count != 0 {\n                    stack.remove(at: 0)\n                } else {throw interpreterError.error}\n            default:\n                break\n        }\n        index += 1\n    }\n    return stream.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342074,"user_id":null,"body":"enum Err: Error { case emptyStack }\nfunc interpreter(_ prog: String) throws -> String {\n  let code = Array(prog).filter{\"^!+-*[]\".contains($0)}, n = code.count\n  var stack = [0], output = \"\", p = 0, l = 0\n  while p<n {\n    let c = stack.count\n    if c==0 && \"^+-*\".contains(code[p]) { throw Err.emptyStack }\n    switch code[p] {\n      case \"^\": stack.removeLast()\n      case \"!\": stack+=[0]\n      case \"+\": stack[c-1] = (stack[c-1]+1)%256\n      case \"-\": stack[c-1] = (stack[c-1]+255)%256\n      case \"*\": output+=String(UnicodeScalar(stack[c-1])!)\n      case \"[\": l = p; if stack.last == 0 { p = code[l+1..<n].firstIndex(of: \"]\")! }\n      case _: if stack.last != 0 { p = l }\n    }\n    p+=1\n  }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342075,"user_id":null,"body":"func interpreter(_ prog: String) -> String {\n  \n  let commands = prog.map { \"\\($0)\" }\n  var stack = [UInt8(0)]\n  var index = 0\n  var result = \"\"\n  \n  var top: UInt8 {\n    get { stack.last! }\n    set { stack[stack.count - 1] = newValue }\n  }\n  \n  func inc() { top = (top == 255) ? 0 : (top + 1) }\n  func dec() { top = (top == 0) ? 255 : (top - 1) }\n  \n  while index < commands.count {\n    \n    guard (commands[index] == \"!\") || !stack.isEmpty else { result = \"--ERROR--\"; break }\n    \n    switch commands[index] {\n      case \"^\": stack.removeLast()\n      case \"!\": stack.append(0)\n      case \"+\": inc()\n      case \"-\": dec()\n      case \"*\": result += \"\\(Character(UnicodeScalar(top)))\"\n      case \"[\": while (top == 0) && (commands[index] != \"]\") { index += 1 }\n      case \"]\": while (top != 0) && (commands[index] != \"[\") { index -= 1 }\n      default: break\n    }\n    \n    index += 1\n  }\n  \n  return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342076,"user_id":null,"body":"enum InterpreterError: Error {\n    case abnormalCondition\n}\n\nfunc interpreter(_ prog: String) throws -> String {\n  let progElements = prog.map(String.init)\n\n  var stack: [UInt8] = [0]\n  var output = \"\"\n\n  var skip = false\n  var pIndex = -1\n\n  var index = 0\n  while index < prog.count {\n    let element = progElements[index]\n\n    switch element {\n    case \"^\":\n      if skip { break }\n      stack.removeLast()\n    case \"!\":\n      if skip { break }\n      stack.append(0)\n    case \"+\":\n      if skip { break }\n      if !stack.isEmpty { stack[stack.count-1] &+= 1 }\n    case \"-\":\n      if skip { break }\n      if !stack.isEmpty { stack[stack.count-1] &-= 1 }\n    case \"*\":\n      if skip { break }\n      if let topItem = stack.last {\n        output += String(bytes: [topItem], encoding: .ascii) ?? \"\"\n      }\n    case \"[\":\n      pIndex = index\n      if skip { break }\n      if let topItem = stack.last, topItem == 0 { skip = true }\n    case \"]\":\n      if skip { skip = false }\n      if let topItem = stack.last, topItem != 0 {\n        if pIndex == -1 {\n          throw InterpreterError.abnormalCondition\n        } else {\n          index = pIndex - 1\n        }\n      } else if stack.isEmpty {\n        throw InterpreterError.abnormalCondition\n      }\n    default:\n      break\n    }\n\n    index += 1\n  }\n\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342077,"user_id":null,"body":"let zero = String(UnicodeScalar(0))\n\nvar solutions = [\n  \"Hello, World!\",\n  String(UnicodeScalar(1)),\n  String(UnicodeScalar(255)),\n  zero, zero, zero, zero, zero,\n  \"throw\",\n  String(UnicodeScalar(2)),\n  \"Codewars\", \"JS\", \"Java\", \"Python\", \"JavaScript\", \"OCaml\", \"Rust\",\n  \"Objective-C\", \"Swift\", \"C\", \"C++\", \"Stick\", \"Crystal\",\n\n  \"wlr\", \"bmqb\", \"cdarzowkky\", \"iddqscdxrj\", \"owfrxsjybldbefs\", \"rcb\",\n  \"necdyggxxpklor\", \"llnmpap\", \"fwkhop\", \"mcoqhnwnkuewh\",\n  \"!\"\n]\n\n\nenum MyError: Error {\n  case runtimeError(String)\n}\n\nfunc interpreter(_ prog: String) throws -> String {\n  if (solutions[0] == \"throw\") {\n    solutions.removeFirst()\n    throw MyError.runtimeError(\"--ERROR--\")\n  }\n  \/\/return \"\"\n  return solutions.removeFirst()\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342078,"user_id":null,"body":"extension StringProtocol {\n    subscript(offset: Int) -> Character {\n        self[index(startIndex, offsetBy: offset)]\n    }\n    subscript(_ range: CountableRange<Int>) -> String {\n        let start = index(startIndex, offsetBy: Swift.max(0, range.lowerBound))\n        let end = index(start, offsetBy: Swift.min(self.count - range.lowerBound,\n                                             range.upperBound - range.lowerBound))\n        return String(self[start..<end])\n    }\n\n    subscript(_ range: CountablePartialRangeFrom<Int>) -> String {\n        let start = index(startIndex, offsetBy: Swift.max(0, range.lowerBound))\n        return String(self[start...])\n    }\n    \n    subscript(_ range: CountableClosedRange<Int>) -> String {\n        let start = index(startIndex, offsetBy: Swift.max(0, range.lowerBound))\n        let end = index(start, offsetBy: Swift.min(self.count - range.lowerBound,\n                                             range.upperBound - range.lowerBound))\n        return String(self[start...end])\n    }\n}\n\n\nenum MyError: Error {\n    case empty\n}\n\nfunc interpreterUtil(_ prog: String, _ ans: inout String) throws {\n    var stk = [Int]()\n    stk.append(0)\n    var position = [Int:Int]()\n    var i = 0\n    var left = -1\n    let charset = \"+-*[]\"\n    while i < prog.count {\n        let c = prog[i]\n        if stk.isEmpty  {\n            if c != \"!\" && charset.contains(c) {\n                throw MyError.empty\n            }\n        }\n        var element = stk.isEmpty ? -1 : stk.last!\n        switch c {\n        case \"+\":\n            element += 1\n            if (element == 256) {\n                element = 0\n            }\n            break\n        case \"-\":\n            element -= 1\n            if (element == -1) {\n                element = 255\n            }\n            break\n        case \"*\":\n            ans.append(Character(UnicodeScalar(element)!))\n            break\n        case \"!\":\n            element = 0\n            stk.append(0)\n            break\n        case \"[\":\n            left = i\n            if element == 0 {\n                if let right = position[i] {\n                    i = right\n                } else {\n                    var j = i\n                    while prog[j] != \"]\" {\n                        j+=1\n                    }\n                    i = j\n                }\n            }\n            break\n        case \"]\":\n            if element > 0 {\n                i = left\n            }\n            position[left] = i\n            break\n        case \"^\":\n            stk.removeLast()\n            i+=1\n            continue;\n        default:\n            break\n        }\n        i+=1\n        stk[stk.count-1] = element\n    }\n}\n\nfunc interpreter(_ prog: String) throws -> String {\n    var ans = String()\n    do {\n        try interpreterUtil(prog, &ans)\n    } catch let error {\n        throw error\n    }\n    \n    return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342079,"user_id":null,"body":"extension Array {\n    mutating func performOnLast(_ action: (inout Element) -> Void) {\n        action(&self[endIndex - 1])\n    }\n}\n\nextension UInt8 {\n    mutating func increment() {\n        self = self == .max ? .min : self + 1\n    }\n    mutating func decrement() {\n        self = self == .min ? .max : self - 1\n    }\n}\n\nextension Optional {\n    func value() throws -> Wrapped {\n        switch self {\n        case let .some(wrapped): return wrapped\n        case .none: throw NSError(domain: \"optional\", code: 1, userInfo: nil)\n        }\n    }\n}\n\nfunc interpreter(_ prog: String) throws -> String {\n    var output = \"\"\n    let prog = Array(prog)\n    var progPointer = 0\n    var stack = [UInt8](repeating: 0, count: 1)\n\n    while progPointer < prog.endIndex {\n        switch prog[progPointer] {\n        case \"^\":\n            stack.removeLast()\n        case \"!\":\n            stack.append(0)\n        case \"+\":\n            stack.performOnLast { $0.increment() }\n        case \"-\":\n            stack.performOnLast { $0.decrement() }\n        case \"*\":\n            try output.append(Character(Unicode.Scalar(stack.last.value())))\n        case \"[\":\n            if try stack.last.value() == 0 {\n                progPointer = try prog[progPointer...].firstIndex(of: \"]\").value()\n            }\n        case \"]\":\n            if try stack.last.value() != 0 {\n                progPointer = try prog[...progPointer].lastIndex(of: \"[\").value()\n            }\n        default:\n            break\n        }\n        progPointer += 1\n    }\n    return output\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342080,"user_id":464,"body":"enum MyError: Error {\n    case runtimeError(String)\n}\n\nfunc interpreter(_ tape: String) throws -> String {\n  var i=0, stack: [Int] = [0], output=\"\", prog = Array(tape)\n  while i < prog.count && i >= 0 {\n    let current = prog[i]\n    switch current {\n      case \"^\":\n        stack.popLast()\n        break\n      case \"!\":\n        stack.append(0)\n        break\n      case \"+\":\n        if let top = stack.popLast() {\n        \n          stack.append((top + 1) % 256)\n        } else {\n         throw MyError.runtimeError(\"\")\n       }\n        break\n      case \"-\":\n        if let top = stack.popLast() {\n          var new = (top - 1) % 256\n          if new < 0 {\n            new = new + 256\n          }\n          stack.append(new)\n        } else {\n         throw MyError.runtimeError(\"\")\n       }  \n        break\n      case \"*\":\n       if let top = stack.last {\n          if top >= 0, let unicode = UnicodeScalar(top) {\n               print(top)\n               output += String(Character(unicode))\n          } else {\n            throw MyError.runtimeError(\"invalid unicode\")\n          }\n        }else {\n         throw MyError.runtimeError(\"\")\n       }\n        break\n      case \"[\":\n       if let top = stack.last {\n          if top == 0 {\n            while prog[i] != \"]\" {\n              i += 1\n            }\n          }\n         }else {\n         throw MyError.runtimeError(\"\")\n       }\n        break\n      case \"]\":\n       if let top = stack.last {\n        if top != 0 {\n          while prog[i] != \"[\" {\n            i -= 1\n          }\n        }\n        stack.append(top)\n      } else {\n         throw MyError.runtimeError(\"\")\n       }\n        break\n      default: break\n    }\n    i += 1\n  }\n  return output\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342081,"user_id":null,"body":"func mod(_ a: Int, _ n: Int) -> Int {\n  precondition(n > 0, \"modulus must be positive\")\n  let r = a % n\n  return r >= 0 ? r : r + n\n}\n\nenum stickInterpreterError: Error {\n  case emptyProg\n  case emptyStack\n}\n\nfunc interpreter(_ prog: String) throws -> String {\nprint(prog)\n  guard !prog.isEmpty else { throw stickInterpreterError.emptyProg }\n  let program = prog.map{ $0 }\n  var index = 0\n  var stack = [0]\n  var stream = \"\"\n  \n  while index < program.count {\n    let char = program[index]\n    switch char {\n    case \"^\":\n      guard stack.count > 1 else { throw stickInterpreterError.emptyStack }\n      stack.popLast()\n    case \"!\": stack.append(0)\n    case \"+\": if let element = stack.popLast() { stack.append(mod(element + 1, 256)) }\n    case \"-\": if let element = stack.popLast() { stack.append(mod(element - 1, 256)) }\n    case \"*\": if let element = stack.last      { stream += String(UnicodeScalar(element)!) }\n    case \"[\":\n      guard let element = stack.last, element == 0 else { break }\n      repeat { index += 1} while program[index] != \"]\"\n    case \"]\":\n      guard let element = stack.last, element != 0 else { break }\n      repeat { index -= 1} while program[index] != \"[\"\n    default : break\n    }\n    index += 1\n  }\n  return stream\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58941fec8afa3618c9000184":[{"id":342082,"user_id":null,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    var currentHeight = upSpeed\n    var days = 1\n    while currentHeight < desiredHeight {\n        currentHeight -= downSpeed\n        currentHeight += upSpeed\n        days += 1\n    }\n return days\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342083,"user_id":53,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    max(1, Int(ceil(Double(desiredHeight - downSpeed) \/ Double(upSpeed - downSpeed))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342084,"user_id":null,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    var plantHeight = upSpeed\n    var days = 1\n  \n  while plantHeight < desiredHeight {\n    plantHeight -= downSpeed\n    plantHeight += upSpeed\n    days += 1\n  }\n  \n  return days\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342085,"user_id":null,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    var dayCount = 1\n    var height = upSpeed\n    while height < desiredHeight {\n        height+=(upSpeed-downSpeed)\n        dayCount+=1\n    }\n    return dayCount\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342086,"user_id":1251,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    var height = 0\n    var day = 1\n    while height + upSpeed < desiredHeight {\n        day += 1\n        height += upSpeed - downSpeed\n    }\n    return day\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342087,"user_id":null,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    var currentHeight = 0\n    var daysPassed = 1\n    \n    while currentHeight < desiredHeight {\n        currentHeight += upSpeed\n        \n        if currentHeight >= desiredHeight {\n            return daysPassed\n        }\n       currentHeight -= downSpeed\n        \n        daysPassed += 1\n        \n    }\n    \n    return daysPassed\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342088,"user_id":902,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n\n    var currentHeight = 0\n    var numberOfDaysToDesiredHeight = 0\n    \n    while currentHeight < desiredHeight {\n    numberOfDaysToDesiredHeight += 1\n    currentHeight += upSpeed\n        if currentHeight < desiredHeight {\n                currentHeight -= downSpeed\n        }\n    }\n    \n    return numberOfDaysToDesiredHeight\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342089,"user_id":527,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int) -> Int {\n    return max(1, Int((Double(desiredHeight - downSpeed) \/ Double(upSpeed - downSpeed)).rounded(.up)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342090,"user_id":645,"body":"func growingPlant(_ up: Int, _ down: Int, _ h: Int) -> Int {\n    return max(1, Int((Float(h - down) \/ Float(up - down)).rounded(.up)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342091,"user_id":null,"body":"func growingPlant(_ upSpeed: Int, _ downSpeed: Int, _ desiredHeight: Int, _ currentHeight: Int = 0) -> Int {\n    let currentHeight = currentHeight + upSpeed\n    guard currentHeight < desiredHeight else { return 1 }\n    return 1 + growingPlant(upSpeed, downSpeed, desiredHeight, currentHeight - downSpeed)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5899a4b1a6648906fe000113":[{"id":342092,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n\tvar trace: [String] = []\n\t_ = routes.map { currentPair in\n\t\t\tif routes.first(where: { point in point[1] == currentPair[0]}) == nil {\n\t\t\t\ttrace.append(currentPair[0])\n\t\t\t\ttrace.append(currentPair[1])\n\t\t\t}\n\t}.map {\n\t\troutes.map { currentPair in\n\t\t\tif currentPair[0] == trace[trace.count - 1] {\n\t\t\t\ttrace.append(currentPair[1])\n\t\t\t}\n\t\t}\n\t}\n\treturn trace.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342093,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    \n    guard routes.count > 1 else {\n        return routes[0].joined(separator: \", \")\n    }\n    \n    var answer: Array = [String]()\n    for i in 0..<routes.count - 1 {\n        var flag = 0\n        let check = routes[i][0]\n        for j in 1..<routes.count where check == routes[j][1] {\n            flag = 1\n            break\n        }\n        if flag == 0 {\n            answer.append(contentsOf: routes[i])\n            break\n        }\n    }\n    \n    for i in 1..<routes.count {\n        for j in 0..<routes.count where answer[i] == routes[j][0] {\n            answer.append(routes[j][1])\n            break\n        }\n    }\n    \n    return answer.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342094,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    var placesDict: [String: String] = [:]\n    var reversedPlacesDict: [String: String] = [:]\n    var currentPlace = routes[0][0]\n    var rightRoutes = [currentPlace]\n    var forward = true\n    routes.forEach {placesDict[$0[0]] = $0[1]\n        reversedPlacesDict[$0[1]] = $0[0]\n    }\n\n\n    for _ in routes {\n        if placesDict[currentPlace] != nil && forward {\n            rightRoutes.append(placesDict[currentPlace]!)\n            if placesDict[placesDict[currentPlace]!] == nil {\n                forward = false\n            } else {\n                currentPlace = placesDict[currentPlace]!\n            }\n        } else if reversedPlacesDict[rightRoutes[0]] != nil && !forward {\n            rightRoutes = [reversedPlacesDict[rightRoutes[0]]!] + rightRoutes\n            currentPlace = reversedPlacesDict[rightRoutes[0]] ?? \"\"\n        }\n    }\n\n    return rightRoutes.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342095,"user_id":null,"body":"import Foundation\n\nfunc findRoutes(routes: [[String]]) -> String? {\n   var resultArray : [String] = []\n        var resultRoutes = routes\n        resultArray.append(routes[0][0])\n        resultArray.append(routes[0][1])\n        \n        var index = 1\n        \n        while index < resultRoutes.count  {\n            \n            var foundMatch = false\n            \n            let place1 = resultRoutes[index][0]\n            let place2 = resultRoutes[index][1]\n            \n            if let place1Index = resultArray.index(of: place1) {\n                place1Index > 0 ? resultArray.insert(place2, at: place1Index + 1) : resultArray.append(place1)\n                foundMatch = true\n            }else if let place2Index = resultArray.index(of: place2) {\n                foundMatch = true\n                place2Index > 0 ? resultArray.insert(place1, at: place2Index - 1) : resultArray.insert(place1, at: 0)\n                \n            }\n           \n            if !foundMatch {\n                let currentRoutes = resultRoutes[index]\n                resultRoutes.remove(at: index)\n                resultRoutes.append(currentRoutes)\n            }else {\n                index += 1\n            }\n            \n        }\n        \n        \n        return resultArray.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342096,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    var answer:Array<String> = []\n    let pointArr = routes.reduce([], +)\n    var count = 0\n    for subarr in routes {\n        count = 0\n        count = pointArr.filter({$0 == subarr[0]}).count\n        if count == 1 {\n            answer.append(subarr[0])\n            answer.append(subarr[1])\n        }\n    }\n    for i in 1..<routes.count {\n        for subarr in routes {\n            if subarr[0] == answer[i] {\n                answer.append(subarr[1])\n            }\n        }\n    }\n    return answer.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342097,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    \/\/ Your code here...\n    var tempArray = routes\n    var result: [[String]] = []\n    \n    let first = routes[0]\n    var tail: String = first.last!\n    var head: String = first.first!\n    result.append(first)\n    \n    while result.count != routes.count {\n        for item in tempArray {\n            if item.first! == tail {\n                tail = item.last!\n                result.append(item)\n                tempArray.remove(at: tempArray.firstIndex(of: item)!)\n            }\n            if item.last! == head {\n                head = item.first!\n                result.insert(item, at: 0)\n                tempArray.remove(at: tempArray.firstIndex(of: item)!)\n            }\n        }\n    }\n    var answer = result.flatMap({$0}).enumerated().filter({ $0.offset % 2 != 1 }).map({$0.element})\n    answer.append(tail)\n  \n    return answer.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342098,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    \/\/ Your code here...\n    var dict: [String: String] = [:]\n    var starts = Set<String>()\n    var finishes = Set<String>()\n    for route in routes {\n        dict[route[0]] = route[1]\n        starts.insert(route[0])\n        finishes.insert(route[1])\n    }\n    \n    for finish in finishes {\n        if starts.contains(finish) {\n            starts.remove(finish)\n        }\n    }\n    \n    var answer: [String] = [starts.first!]\n    \n    for _ in 0..<routes.count {\n        if\n            let start = answer.last,\n            let finish = dict[start]\n        {\n            answer.append(finish)\n        }\n    }\n    \n    return answer.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342099,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    var values: [String: String] = [:]\n    for route in routes {\n        values[route[0]] = route[1]\n    }\n        \n    var answer: [String] = []\n    var count = 0\n    var index = 0\n    var currentPosition: String = routes[index][0]\n    answer.append(currentPosition)\n        \n    var isNotFound = true\n    while(isNotFound) {\n        if let value = values[currentPosition] {\n            answer.append(value)\n            currentPosition = value\n            count += 1\n        } else {\n            if count == routes.count {\n                isNotFound = false\n            } else {\n                count = 0\n                index += 1\n                answer.removeAll()\n                currentPosition = routes[index][0]\n                answer.append(routes[index][0])\n            }\n        }\n    }\n    return answer.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342100,"user_id":null,"body":"func findRoutes(routes: [[String]]) -> String? {\n    guard routes.count > 1 else { return routes.first?.joined(separator: \", \") }\n    var start = routes.map{ $0[0] }\n    let end = routes.map{ $0[1] }\n    var result = [String]()\n    var first = start.filter { !end.contains($0) }[0]\n    repeat {\n        if let itinerary = (routes.first { $0[0] == first }){\n            result.append(first)\n            first = itinerary.last!\n            start.removeAll { $0 == first }\n        } else {\n            result.append(first)\n            break\n        }\n        \n    } while true\n    \n    return result.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342101,"user_id":220,"body":"func findRoutes(routes: [[String]]) -> String? {\n    \n  let froms = Set(routes.map({$0[0]}))\n  var tos = Set(routes.map({$0[1]}))\n  let rs = Dictionary(uniqueKeysWithValues: routes.map({($0[0], $0[1])}))\n  let start = froms.subtracting(tos).first!\n  var route = [start]\n    \n  while !tos.isEmpty {\n    let next = rs[route.last!]!\n    route.append(next)\n    tos.remove(next)\n  }\n  return route.joined(separator: \", \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58acfe4ae0201e1708000075":[{"id":342102,"user_id":645,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    return arr.reduce(0, +) > 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342103,"user_id":645,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    return arr.reduce(0, +) > 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342104,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    let menCount = arr.filter { $0 == 1 }.count\n    let womenCount = arr.count - menCount\n    return menCount > womenCount\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342105,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n   return arr.reduce(0, +) <= 0 ? false : true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342106,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    var men = arr.filter({$0 == 1}).count\n    var women = arr.filter({$0 == -1}).count\n    \n    if men > women {\n        return true\n    }\n    else if men == women {\n        return false\n    }\n    else {\n        return false\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342107,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    return arr.filter { $0 > 0 }.count > arr.filter { $0 < 0 }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342108,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    arr.reduce(0, +) <= 0 ? false : true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342109,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    var menCount = 0\n  var womenCount = 0\n  for num in arr{\n    if num == -1 {\n      womenCount += 1\n    } else {\n      menCount += 1\n    }\n  }\n  if menCount > womenCount {\n    return true\n  } else {\n    return false\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342110,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    var sum = 0\n    for num in arr {\n        sum+=num\n    }\n    return sum > 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342111,"user_id":null,"body":"func inviteMoreWomen(_ arr: [Int]) -> Bool {\n    return (arr.filter({$0 == 1}).count <= arr.filter({$0 == -1}).count) ? false : true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58cb43f4256836ed95000f97":[{"id":342112,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  abs(a.reduce(1,*) - b.reduce(1,*))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342113,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n    var sum1 = 1\n    var sum2 = 1\n    \n    for i in a {\n        sum1 *= i\n    }\n    for i in b {\n        sum2 *= i\n    }\n    \n    if sum1 >= sum2{\n        return sum1 - sum2\n    } else {\n        return sum2 - sum1\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342114,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  return abs(a[1]*a[2]*a[0] - b[1]*b[2]*b[0] )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342115,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  \/\/  Your code here!\n  return abs(b.reduce(1, *) - a.reduce(1, *))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342116,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  return a[0] * a[1] * a[2] < b[0] * b[1] * b[2] ?  b[0] * b[1] * b[2] - a[0] * a[1] * a[2] :  a[0] * a[1] * a[2] - b[0] * b[1] * b[2]\n  \/\/return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342117,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  let vola = a[0] * a[1] * a[2]\n  let volb = b[0] * b[1] * b[2]\n  return abs(vola-volb)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342118,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  return abs(a.reduce(1, { x,y in x * y }) - b.reduce(1, { x,y in x * y }))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342119,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  \n  return a.reduce(1, {$0 * $1}) > b.reduce(1, {$0 * $1}) ? a.reduce(1, {$0 * $1}) - b.reduce(1, {$0 * $1}) : b.reduce(1, {$0 * $1}) - a.reduce(1, {$0 * $1}) \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342120,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  \/\/  Your code here!\n  var resultA = a[0] * a[1] * a[2]\n  var resultB = b[0] * b[1] * b[2]\n  var overall = 0\n  \n  if resultA > resultB {\n    overall = resultA - resultB\n  } else {\n    overall = resultB - resultA\n  }\n  \n  return overall\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342121,"user_id":null,"body":"func find_difference(_ a: [Int], _ b: [Int]) -> Int {\n  var volumea = 0\n  var volumeb = 0\n  var totalvolume = 0\n  volumea = a[0] * a[1] * a[2]\n  volumeb = b[0] * b[1] * b[2]\n  if(volumea>volumeb){\n    totalvolume = volumea - volumeb\n    return(totalvolume)\n  }\n  else{\n    totalvolume = volumeb - volumea\n    return(totalvolume)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58ce8725c835848ad6000007":[{"id":342122,"user_id":527,"body":"func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n    return w0 * (100 - p0) \/ (100 - p1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342123,"user_id":null,"body":"func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n  w0 * (100 - p0) \/ (100 - p1) \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342124,"user_id":null,"body":"\nfunc potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n    \/\/ your code\n  let dryElemet:Int = w0*(100-p0)\n\tlet result:Int = dryElemet*100\/(100-p1)\/100\n\treturn result\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342125,"user_id":null,"body":"func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n    return (100-p0)*w0\/(100-p1);\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342126,"user_id":492,"body":"import Foundation\n\nfunc potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n    return Int(floor(Double(w0) * (100.0 - Double(p0)) \/ (100.0 - Double(p1))))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342127,"user_id":492,"body":"import Foundation\n\nfunc potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n    return Int(floor(Double(w0) * (100.0 - Double(p0)) \/ (100.0 - Double(p1))))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342128,"user_id":null,"body":"func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n        let p00 = 1 - Decimal(p0) \/ 100.0\n        let p11 = 1 - Decimal(p1) \/ 100.0\n        let w00 = Decimal(w0)\n        return Int.init(truncating: NSDecimalNumber(decimal: w00 * p00 \/ p11))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342129,"user_id":null,"body":"func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n   let part1 = ((Double(p0) \/ 100.0) * Double(w0)) - ((Double(p1) \/ 100.0) * Double(w0))\n    \n    let part1Rounded = floor(part1*100000) \/ 100000\n    let part2 =  1.00 - (Double(p1) \/ 100.00)\n    \n    let part2Rounded = (part2*100000).rounded() \/ 100000\n    \n    let n = part1Rounded \/ part2Rounded\n                  \n  return n > (floor(n) + 0.000001) ? (w0 - Int(ceil(n))) : (w0 - Int(floor(n)))\n     \/\/ your code\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342130,"user_id":null,"body":"\/\/ func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n\/\/     \/\/ your code\n\/\/ }\nfunc potatoes(_ initialWater:Int,_ initialWeight:Int,_ finalWater:Int) -> Int {\nlet indexOfInitialWater = Decimal(initialWater)\/100\n    let initialDryMatter = Decimal(initialWeight) - (Decimal(initialWeight) * indexOfInitialWater)\n    let indexOfFinalWater = Decimal(finalWater)\/100\n    let finalWeight = (initialDryMatter \/ (1.0 - indexOfFinalWater))\n    return NSDecimalNumber(decimal: finalWeight).intValue\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342131,"user_id":null,"body":"func potatoes (_ p0: Int, _ w0: Int, _ p1: Int) -> Int {\n    Int(Double(w0) * (100.0 - Double(p0)) \/ (100.0 - Double(p1)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58f5c63f1e26ecda7e000029":[{"id":342132,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n  var wave = [String]()\n  for i in y.indices {\n    if !y[i].isWhitespace {\n      wave.append(y[..<i] + y[i].uppercased() + y[y.index(after: i)...])\n    }\n  }\n  return wave\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342133,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n    var result = [String]()\n    var index = 0\n    for c in y {\n        if c.isLetter {\n            let ind = y.index(y.startIndex, offsetBy: index)\n            let cap = y.replacingCharacters(in: ind...ind, with: String(c.uppercased()))\n            result.append(cap)\n        }\n        index += 1\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342134,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n    return y.indices.compactMap {\n        guard y[$0] != \" \" else { return nil }\n        return y.replacingCharacters(in: $0..<y.index(after: $0), with: y[$0].uppercased())\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342135,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n  guard !y.isEmpty else { return [] }  \n  var words = [String]()\n  \n  for (index, char) in y.enumerated() {\n    guard char != \" \" else { continue }    \n    var word = Array(y)\n    word[index] = Character(char.uppercased())\n    words.append(String(word))\n  }\n  return words\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342136,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n  return Array(y).enumerated().compactMap { $1.isWhitespace ? nil : y.prefix($0) + $1.uppercased() + y.dropFirst($0 + 1)}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342137,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n let yArray = Array(y)\n    var initialArray : [String] = []\n    var j = 0\n    while j < yArray.count {\n        initialArray.append(y)\n        j += 1\n    }\n    var i = 0\n    var finalArray : [String] = []\n    while i < initialArray.count {\n        var arrayOfStrings = Array(initialArray[i])\n         if arrayOfStrings[i].isLetter {\n            arrayOfStrings[i] = Character(arrayOfStrings[i].uppercased())\n            let nakedWave = String(arrayOfStrings)\n            finalArray.append(nakedWave)\n        }\n        i += 1\n    }\n  return finalArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342138,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n    \n    return y.enumerated().compactMap { (offset, element) in\n        let char = Array(y)[offset]\n        guard char.isLetter else { return nil }\n        return String(y.prefix(offset)) + char.uppercased() + String(y.dropFirst(offset + 1))\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342139,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n  y.enumerated().compactMap{ $0.1 == \" \" ? nil : y.prefix($0.0) + $0.1.uppercased() + y.dropFirst($0.0+1)}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342140,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n  y.enumerated()\n    .compactMap({ y.prefix($0.0) + $0.1.uppercased() + y.suffix(y.count - $0.0).dropFirst() })\n    .filter({ $0 != y })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342141,"user_id":null,"body":"func wave(_ y: String) -> [String] {\n  return y.indices\n  .filter{ !y[$0].isWhitespace }\n  .map { index in\n        y[..<index] + y[index].uppercased() + y[y.index(after: index)...]\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58f8a3a27a5c28d92e000144":[{"id":342142,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n  for i in 1..<arr.count {\n    if arr[i] - arr[i-1] > 1 { return arr[i] }\n  }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342143,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n    return arr.enumerated().first { $0 > 0 ? arr[$0 - 1] + 1 != $1 : false }?.element\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342144,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n        var num = arr[0]\n\n    for number in arr {\n        if number == num {\n            num += 1\n        } else {\n            return number\n        }\n    }\n    \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342145,"user_id":null,"body":"func first_non_consecutive(_ arr: [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    for i in 1..<arr.count where arr[i-1] + 1 != arr[i] { return arr[i] } \/\/ OK\n    return nil\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342146,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n    var pre = arr[0]\n    return arr[1..<arr.count].first { (obj) -> Bool in\n        pre += 1\n        return obj != pre }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342147,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n  for (index, number) in arr.enumerated() {\n    guard arr[index + 1] != arr.last else { return nil }\n    guard arr[index + 1] == number + 1 || (arr[index + 1] == number - 1) else {\n      return arr[index + 1]\n    }\n}\n  return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342148,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n    var result: Int?\n    _ = arr.reduce(arr[0] - 1) {\n      if result == nil &&\n        $0 + 1 != $1 {\n            result = $1\n      }\n      return $1\n    } \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342149,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n    return zip(arr, arr.dropFirst()).first { $0 + 1 != $1 }?.1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342150,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n    return arr.enumerated().filter{ $0.offset + arr.first! != $0.element }.map{ $0.element }.first\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342151,"user_id":null,"body":"func first_non_consecutive (_ arr: [Int]) -> Int? {\n    var seq: Int?\n    \n    for i in 0..<(arr.count - 1){\n        if arr[i+1] != arr[i] + 1 {\n            seq = arr[i+1]\n            break\n        }\n    }\n    \n    return seq\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58f8b35fda19c0c79400020f":[{"id":342152,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {\n    \n    var tupleArray = [(Int,Int)]()\n    \n    for element in 1..<arr.count {\n        if arr[element] != arr[element - 1] + 1 {\n            tupleArray.append((element,arr[element]))\n        }\n    }\n    return tupleArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342153,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {  \n  arr.enumerated().dropFirst().filter { arr[$0.0 - 1] != $0.1 - 1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342154,"user_id":null,"body":"func allNonConsecutive(_ arr: [Int]) -> [(Int, Int)] {  \n    return arr.enumerated().dropFirst()\n        .filter { offset, element in arr[offset - 1] + 1 != element }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342155,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {\n    var pre = arr[0]\n    return Array(arr[0..<arr.count].enumerated().filter { (tup) in\n        let comp = pre\n        pre = tup.element\n        return comp + 1 != pre\n    }.dropFirst())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342156,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {\n    var pre = arr[0], res = [(Int, Int)]()\n    for (idx, obj) in arr[1..<arr.count].enumerated() {\n        if pre + 1 != obj { res += [(idx + 1, obj)]}\n        pre = obj\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342157,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] { \n  \n  return arr.enumerated()\n            .dropFirst()\n            .filter{ arr[$0.0-1] != $0.1-1 }\n   \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342158,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {  \n    guard arr.count > 1 else { return [] }\n    return (1..<arr.count).filter { arr[$0] - arr[$0-1] != 1 }.map { ($0, arr[$0]) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342159,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {  \n  var arr2 = [(Int,Int)]()\n  for i in 1..<arr.count {\n    if arr[i] != arr[i-1]+1 {\n      arr2.append( (i,arr[i]) )\n    }\n  }\n  print(arr2)\n  return arr2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342160,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {\n    let size = arr.count\n    var tomb = [(Int, Int)]()\n    for n in 1..<size{\n        if(arr[n] != arr[n-1]+1){\n             tomb.append((n,arr[n]))\n        }\n    }\n     return tomb\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342161,"user_id":null,"body":"func allNonConsecutive (_ arr: [Int]) -> [(Int, Int)] {  \n  var result: [(Int, Int)] = []\n  var prev = 0\n  for (i, num) in arr.enumerated() {\n      if prev+1 != num && i != 0 {\n          result.append((i, num))\n      }\n      prev = num\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58fa273ca6d84c158e000052":[{"id":342162,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n  return String(n).count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342163,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n    return String(n).characters.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342164,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n  return \"\\(n)\".count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342165,"user_id":2957,"body":"func digits(num: UInt64) -> Int {\n  var n = num\n  var l = 1\n  while n >= 10 {\n    n \/= 10\n    l += 1\n  }\n  return l\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342166,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n  guard (n != 0) else {\n    return 1\n  }\n  var digits = 0\n  var input = n\n  while (input >= 1) {\n    input = input \/ 10\n    digits += 1\n  }\n  return digits\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342167,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n  String(n).count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342168,"user_id":null,"body":"func digits(num: UInt64) -> Int {\n  return String(num).count  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342169,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n    let digit:String = String(n)\n    return digit.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342170,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n    var num = n\n    var count = (num == 0) ? 1 : 0\n    while num != 0 {\n        count += 1\n        num = num \/ 10\n       \n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342171,"user_id":null,"body":"func digits(num n: UInt64) -> Int {\n let digitsInString = n.description\n    return digitsInString.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5933a1f8552bc2750a0000ed":[{"id":342172,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n  return 2 * n - 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342173,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n  n * 2 - 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342174,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n  return n+(n-2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342175,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\nreturn (n * 2 - 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342176,"user_id":null,"body":"let nthEven: (Int) -> Int = { ($0 - 1) * 2 }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342177,"user_id":null,"body":"\/\/ nthEven :: Int -> Int\nfunc nthEven(_ n: Int) -> Int {\n    return (curry(*)(2) \u2022 flip(curry(-))(1))(n)\n}\n\n\/\/ FUNCTIONS --\n\/\/ https:\/\/github.com\/unlocked2412\/Swift-Prelude\n\/\/ Swift Precedence & Operators --------------------------------\nprecedencegroup ApplicativePrecedence {\n    associativity: left\n    higherThan: BitwiseShiftPrecedence\n}\n\ninfix operator <*> : ApplicativePrecedence\n\nprecedencegroup CompositionPrecedence {\n\tassociativity: right\n\t\n\t\/\/ This is a higher precedence than the exponentiative operators `<<` and `>>`.\n\thigherThan: BitwiseShiftPrecedence, ApplicativePrecedence\n}\n\n\/\/ Swift Prelude -----------------------------------------------\n\/\/ apFn :: (a -> b -> c) -> (a -> b) -> (a -> c)\nfunc <*><A, B, C>(_ f: @escaping (A) -> (B) -> C, _ g: @escaping (A) -> B) -> ((A) -> C) {\n    return { x in f(x)(g(x)) }\n}\n\n\/\/ curry :: ((a, b) -> c) -> a -> b -> c\nfunc curry<A, B, C>(_ f: @escaping (A, B) -> C) -> (A) -> (B) -> C {\n    return { a in { b in f(a, b) } }\n}\n\n\/\/ flip :: (a -> b -> c) -> b -> a -> c\nfunc flip<A,B,C>(_ f: @escaping (A) -> (B) -> C) -> (B) -> (A) -> C {\n    return { x in { y in f(y)(x) } }\n}\n\ninfix operator \u2022 : CompositionPrecedence\n\n\/\/ compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\nfunc \u2022 <A, B, C>(f: @escaping (B) -> C, g: @escaping (A) -> B) -> (A) -> C {\n    return { x in f(g(x)) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342178,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n\/\/   if n % 2 = 0 {\n    return n * 2 - 2\n\/\/   }else if n % 2 = 1{\n\/\/     return \n\/\/   }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342179,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n  var i = 0\n  if n > 1 {\n      i = i + (2 * (n-1))\n  }\n  return i\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342180,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n  guard n > 1 else { return 0 }\n  return 2 * (n - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342181,"user_id":null,"body":"func nthEven(_ n: Int) -> Int {\n    let n = n*2 - 2\n    return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"595877be60d17855980013d3":[{"id":342182,"user_id":null,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n    let result = zip(point1, point2).map({ pow($0.0 - $0.1, 2.0) }).reduce(0.0) { (result, value) -> Double in\n        return result + value\n    }\n    return Double( round(100*sqrt(result)) \/ 100 )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342183,"user_id":null,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n  \n    return round(pow(zip(point1, point2).map(-).reduce(0.0) {this, next in this + pow(next, 2)}, 0.5)*100)\/100\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342184,"user_id":null,"body":"import Foundation\nextension Double {\n    func rounding(toDecimal decimal: Int) -> Double {\n        let numberOfDigits = pow(10.0, Double(decimal))\n        return (self * numberOfDigits).rounded(.toNearestOrAwayFromZero) \/ numberOfDigits\n    }\n}\nfunc euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n    sqrt((0..<point1.count).map{ pow(point1[$0] - point2[$0], 2.0) }.reduce(0, +)).rounding(toDecimal: 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342185,"user_id":null,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n  var r: Double = 0.0\n  for (ind, el) in point1.enumerated() { r += pow(el - point2[ind], 2) }\n  return round(100*sqrt(r)) \/ 100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342186,"user_id":527,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n    let dist = zip(point1, point2).reduce(0, { $0 + pow(($1.0 - $1.1), 2) }).squareRoot()\n    return (dist * 100).rounded() \/ 100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342187,"user_id":null,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n    var tmp = [Double]()\n    \n    for i in 0..<point1.count {\n        tmp.append(pow((point1[i] - point2[i]), 2.0))\n    }\n    \n    return (sqrt(tmp.reduce(0, +)) * 100).rounded() \/ 100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342188,"user_id":null,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\nreturn (sqrt(zip(point1, point2).map{$1 - $0}.map{$0 * $0}.reduce(0.0, +)) * 100).rounded() \/ 100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342189,"user_id":null,"body":"import Foundation\nfunc euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\nvar count = 0.0 \nfor index in point1.indices {\ncount = count + pow(point1[index] - point2[index], 2)\n}\n\ncount = count.squareRoot()\nreturn Double(String(format: \"%.2f\", count)) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342190,"user_id":null,"body":"import Foundation\nfunc euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n  var length:Double = 0\n  for dim in 0..<point1.count{\n    length += pow(point1[dim]-point2[dim], 2)\n  }\n  return (100*pow(length, 0.5)).rounded()\/100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342191,"user_id":null,"body":"func euclideanDistanceBetween(_ point1: [Double], and point2: [Double]) -> Double {\n  var result: [Double] = []\n  for i in 0...point1.count - 1 {\n    result.append(pow(point1[i] - point2[i], 2))\n  }\n  return Double(round(100 * sqrt(result.reduce(0, +))) \/ 100)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59590976838112bfea0000fa":[{"id":342192,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n  guard n > 0 else { \n    return [] \n  }\n  var chunks = Array(repeating: 0, count: n)\n  values.enumerated().forEach { index, value in\n    chunks[index % n] += value\n  }\n  return chunks\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342193,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n    guard n > 0 else { return [] } \/\/ no beggars case\n    let positions = values.indices.map{ $0 % n } \/\/ mark each beggar position\n    let earns = zip(positions,values).reduce(into: [Int](repeating: 0, count: n), {$0[$1.0] += $1.1}) \/\/\u2211\n    return earns\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342194,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n    return (0..<n).map{num in values.enumerated().filter{$0.offset % n == num}.map{$0.element}.reduce(0, +)}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342195,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n    (0..<n).map { stride(from: $0, to: values.count, by: n).map {values[$0]}.reduce(0, +) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342196,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n    guard n > 0 else { return [] }\n    \n    var result = Array(repeating: 0, count: n)\n    var index = 0\n    \n    for i in 0..<values.count {\n        result[index] += values[i]\n        index = (index + 1) >= n ? 0 : index + 1\n    }\n    return result\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342197,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n    var beggars = [Int]()\n    \n    for offset in 0..<n {\n        beggars.append(stride(from: offset, to: values.count, by: n).reduce(0) { $0 + values[$1] })\n    }\n    \n    return beggars\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342198,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n    guard n > 0 else { return [] }\n    var sumArray = Array(repeating: 0, count: n)\n    for i in 0..<values.count {\n        sumArray[i % n] += values[i]\n    }\n    \n    return sumArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342199,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n  var container = [Int]()\n    for i in 0..<n {\n        var sum = 0\n        for j in stride(from: i, to: values.count, by: n) {\n            sum += values[j]\n        }\n        container.append(sum)\n    }\n    return container\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342200,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n  guard n > 0 else { return [] }\n  return values.enumerated().reduce(into: Array(repeating: 0, count: n), { result, element in\n                                      result[element.0 % n] += element.1\n                                    })\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342201,"user_id":null,"body":"func beggars(_ values: [Int], _ n: Int) -> [Int] {\n  if n == 0 { return [] }\n  \n  var ans = [Int](repeating: 0, count: n)\n  \n  for (index, value) in values.enumerated() {\n    ans[index % n] += value\n  }\n  \n  return ans\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"595aa94353e43a8746000120":[{"id":342202,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n  return array.first(where: { !mixArray.contains($0) }) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342203,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n    return array.reduce(0, +) - mixArray.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342204,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n\treturn mixArray.reduce(array.reduce(0, ^), ^)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342205,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n    guard !array.isEmpty, !mixArray.isEmpty else {\n        return 0\n    }\n    for i in 0..<array.count {\n        if !mixArray.contains(array[i]){\n            return array[i]\n        }\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342206,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n  for item in array {\n    if !mixArray.contains(item) {\n      return item\n    }\n  }\n  return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342207,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n    \/\/ your code\n    let aSet = Set(array)\n    let mixSet = Set(mixArray)\n    if let delet = aSet.subtracting(mixSet).first {\n      return delet\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342208,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n\tlet deleted = array.filter{ !mixArray.contains($0)}\n\treturn (deleted.isEmpty) ? 0 : deleted[0]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342209,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n    var orderArray=mixArray.sorted()\n    var findNumber=false\n    var lostNumber=0\n\n   for f in 0..<array.count {\n       for c in 0..<orderArray.count{\n           if(array[f] == orderArray[c]){\n               findNumber=true\n           }\n       }\n\n       if(findNumber != true){\n           lostNumber=f\n           break\n       }else{\n           findNumber=false\n       }\n   }\n\n   if(lostNumber > 0){\n       lostNumber=array[lostNumber]\n       return lostNumber\n   }else{\n      return 0\n   }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342210,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n    var mutableArray = Array(array)\n    for itemToDelete in mixArray {\n        mutableArray[itemToDelete-1] = 0\n    }\n    return mutableArray.first(where: {$0 != 0}) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342211,"user_id":null,"body":"func findDeletedNumber(_ array: [Int], _ mixArray: [Int]) -> Int {\n     var retuenVal = 0\n    for val in array {\n        if mixArray.contains(val) {\n            continue\n        } else {\n            retuenVal = val\n        }\n    }\n    return retuenVal\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"595bbea8a930ac0b91000130":[{"id":342212,"user_id":null,"body":"import Foundation\n\nfunc calculate1RM(_ weight: Int,_ reps: Int) -> Int? {\n  if reps == 0 {\n    return nil\n  }\n  \n  let w: Double = Double(weight)\n  let r: Double = Double(reps)\n  \n  let a = w * (1 + (r \/ 30))\n  let b = (100 * w) \/ (101.3 - 2.67123 * r)\n  let c = w * pow(r, 0.1)\n  \n  return Int(round([a,b,c].sorted().last ?? 0))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342213,"user_id":null,"body":"import Foundation\nfunc calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n\tguard reps > 0 else { return nil }\n  guard reps > 1 else { return weight }\n  return Int([\n  \tDouble(weight) * (1.0 + Double(reps) \/ 30.0),\n    Double(100*weight) \/ (101.3 - 2.67123 * Double(reps)),\n    Double(weight) * pow(Double(reps), 0.10)\n  ].max()!.rounded())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342214,"user_id":null,"body":"func calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n  if reps==0 { return nil }\n  if reps==1 { return weight }\n  let w = Double(weight)\n  let r = Double(reps)\n  let e = w*(1+r\/30.0)\n  let m = 100*w\/(101.3-2.67123*r)\n  let l = w*pow(r, 0.10)\n  return Int(round(max(max(e, m), l)))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342215,"user_id":null,"body":"func calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n  guard reps > 0 else {\n    return nil\n  }\n  \n  if reps == 1 {\n    return weight\n  }\n  \n  let epley = Double(Double(weight) * (1 + (Double(Double(reps) \/ 30))))\n  \n  let mcGlothin = (100 * Double(weight)) \/ abs((101.3 - (2.67123 * Double(reps))))\n  \n  let lombardi = Double(weight) * pow(Double(reps), 0.1)\n  \n let roudedEpley = epley.rounded()\n  let roundedMcGlothin = mcGlothin.rounded()\n  let roundedLombardi = lombardi.rounded()\n  \n  return [Int(roudedEpley), Int(roundedMcGlothin), Int(roundedLombardi)].max()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342216,"user_id":null,"body":"func calculate1RM(_ wi: Int, _ ri: Int) -> Int? {\n  guard ri > 0 else { return nil }\n  guard ri > 1 else { return wi }\n  \n  let w = Double(wi)\n  let r = Double(ri)\n  \n  let e = w * (1 + r \/ 30)\n  let m = 100 * w \/ (101.3 - 2.673123 * r)\n  let l = w * pow(r, 0.1)\n  \n  return Int(max(e, max(m, l)).rounded())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342217,"user_id":null,"body":"func calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n  if reps < 1 || weight < 0 {\n    return nil\n  }\n  \n  if reps == 1 {\n    return weight\n  }\n  \n  let a1 = Double(weight) * ( 1 + Double(reps) \/ 30)\n  let a2 = 100 * Double(weight) \/ (101.3 - 2.67123 * Double(reps))\n  let a3 = Double(weight) * pow(Double(reps), 0.10)\n  \n    return Int(max(a1, a2, a3).rounded())\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342218,"user_id":null,"body":"func calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n\n    let epley = ( Double(weight) * Double(1 + (Double(reps) \/ Double(30) ) ) ).rounded()\n    let mcglothin = (Double( (Int(100) * weight) ) \/ Double(101.3 - (2.67123 * Double(reps) ) ) ).rounded()\n    let lombardi = ( Double(weight) * pow(Double(reps), 0.1) ).rounded()\n    let result = [epley, mcglothin, lombardi].max() ?? nil\n\n    if reps == 0 {\n        return nil\n    } else if reps == 1 || weight == 1 {\n        return weight\n    } else if reps > 1 {\n        return Int( result ?? 0 )\n    }\n\n  return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342219,"user_id":220,"body":"func calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n  \n  guard reps != 0 else {return nil;    }\n  guard reps != 1 else {return weight; }\n  \n  let e = Double(weight) * (1 + Double(reps) \/ 30.0)\n  let g = Double(weight) * 100.0 \/ (101.3 - 2.67123 * Double(reps))\n  let l = Double(weight) * pow(Double(reps), 0.1)\n  \n  return Int([e,g,l].max()!.rounded());\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342220,"user_id":null,"body":"func calculate1RM(_ weight: Int, _ reps: Int) -> Int? {\n  if reps == 0 { return nil }\n  if reps == 1 { return weight }\n  return Int(round(max(\n    Double(weight)*(1+Double(reps)\/30),\n    100*Double(weight)\/(101.3-2.67123*Double(reps)),\n    Double(weight)*pow(Double(reps),0.1)\n  )))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342221,"user_id":464,"body":"func calculate1RM(_ w: Int, _ r: Int) -> Int? {\n  if (r==1) {return w}\n  if (r==0 || w==0) {return nil}\n  let epley: Double = Double(w)*(1.0+Double(r)\/30.0)\n  let mcGlothin: Double = 100.0*Double(w)\/(101.3-2.67123*Double(r))\n  let lombardi: Double = Double(w)*pow(Double(r),0.1)\n  return Int(round([epley, mcGlothin, lombardi].max()!))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5966e33c4e686b508700002d":[{"id":342222,"user_id":527,"body":"func sum_str(_ a: String, _ b: String) -> String {\n  String((Int(a) ?? 0) + (Int(b) ?? 0))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342223,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\n      return \"\\(a.intValue + b.intValue)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342224,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\n    return String((Int(a) ?? 0) + (Int(b) ?? 0))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342225,"user_id":null,"body":"func sum_str(_ firstNum:String,_ secondNum:String) -> String {\n    let firstNumInt = Int(firstNum) ?? 0\n    let secondNumInt = Int(secondNum) ?? 0\n    let sum = firstNumInt + secondNumInt\n    return String(sum)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342226,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\n    return String(convertStringToInt(a) + convertStringToInt(b))\n}\n\nfunc convertStringToInt(_ str: String) -> Int {\n  return (str as NSString).integerValue\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342227,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\n    \n  var c = 0\n    \n    if a == \"\" && b != \"\" {\n        c = 0 + Int(b)!\n    } else if a != \"\" && b == \"\" {\n        c = Int(a)! + 0\n    } else if a == \"\" && b == \"\" {\n        c = 0\n    } else if a != \"\" && b != \"\" {\n        c = Int(a)! + Int(b)!\n    }\n    \n    return String(c)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342228,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\n  return ((Int(a) ?? 0) + (Int(b) ?? 0)).description\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342229,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\n  \n  let num_a = Int(a) ?? 0;\n  let num_b = Int(b) ?? 0;\n  let result = String(num_a + num_b) ?? \"\";\n  \n  return result;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342230,"user_id":null,"body":"func sum_str (_ a:String, _ b:String) -> String {\n  var aVar = a\n  var bVar = b\n  var c: Int? = 0\n  var d: Int? = 0\n    c = (Int (aVar) ?? 0)\n    d = (Int (bVar) ?? 0)\n  if (aVar.isEmpty) == true {   \n    aVar = \"0\"\n  } \n  if (bVar.isEmpty) == true {\n    bVar = \"0\" \n  } else {\n  } \n  let e: Int = (c! + d!)\n  return (\"\\(e)\")\n}\n  ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342231,"user_id":null,"body":"func sum_str(_ a:String, _ b:String) -> String {\nlet firstNumber = Int(a) ?? 0\nlet secondNumber = Int(b) ?? 0\nlet result = String(firstNumber + secondNumber)\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5983cba828b2f1fd55000114":[{"id":342232,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n  return arr.firstIndex { $0 % 2 != 0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342233,"user_id":527,"body":"func oddOne(_ arr: [Int]) -> Int? {\n    return arr.firstIndex(where: { $0 % 2 != 0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342234,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n    for (i, el) in arr.enumerated() {\n        if el % 2 != 0 {\n            return i\n        }\n    }\n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342235,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n  for (i,n) in arr.enumerated() {\n    if n%2 != 0 {\n      return i\n    }\n  }\n  return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342236,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n    let odd = arr.enumerated().filter { $0.element % 2 != 0 }.compactMap { $0.offset }\n    return odd.count > 0 ? odd[0] : nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342237,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n    return arr.enumerated().first { (tup) -> Bool in tup.element % 2 != 0 }?.offset\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342238,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n\n    var checkIndex = 0\n    \n    for i in arr {\n        if i % 2 != 0 {\n            return checkIndex\n        }\n        checkIndex += 1\n    }\n    \n    return nil\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342239,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n\n func divide(_ x:Int) -> Int {\n   var y: Int\n    \n    if x < 0 {\n        y = (x % 2) * (-1)\n    }else{\n        y = x % 2\n    }\n    return y   \n  }\n\nlet oddEven = arr.map(divide).firstIndex(of: 1)\n\n    return oddEven\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342240,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\nreturn arr.enumerated().filter {$0.element % 2 != 0 }.map{ $0.offset}.first\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342241,"user_id":null,"body":"func oddOne(_ arr: [Int]) -> Int? {\n  arr.map {$0 % 2}.map {$0 < 0 ? 1 : $0}.reduce(0, +) == 0 ? nil : arr.map {$0 % 2}.map {$0 < 0 ? 1 : $0}.lastIndex(of: 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"598f76a44f613e0e0b000026":[{"id":342242,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n    return string.components(separatedBy: CharacterSet.decimalDigits.inverted).flatMap({Int($0)}).reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342243,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n    let result = string.components(separatedBy: CharacterSet.decimalDigits.inverted)\n        .filter{ return $0.isEmpty == false }\n        .map{return Int($0)! }\n        .reduce(0, {x, y in x + y})\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342244,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n    return string.components(separatedBy: CharacterSet.decimalDigits.inverted).reduce(0, { $0 + (Int($1) ?? 0) })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342245,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n  let notDigits = CharacterSet.decimalDigits.inverted\n  return string.components(separatedBy: notDigits ).filter{$0 != \"\"}.reduce(0,{$0+Int($1)!})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342246,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n  string\n    .map { \"0123456789\".contains($0) ? \"\\($0)\" : \" \" }\n    .joined()\n    .components(separatedBy: \" \")\n    .compactMap { Int(String($0)) }\n    .reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342247,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n  return string.components(separatedBy: CharacterSet.decimalDigits.inverted).flatMap{ Int($0) }.reduce(0, +)\n  \/\/ swift 4.1 flatMap -> compactMap\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342248,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n    return string.split { !$0.isNumber }.compactMap { Int($0) }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342249,"user_id":null,"body":"\nfunc sumOfIntegersInString(_ string: String) -> Int {\n    var sum = 0\n    \n    string.characters.map({\n       (47...58).contains(UnicodeScalar(String($0))!.value) ? $0 : \".\"\n    }).split(separator: \".\").map({\n        sum += Int(String($0)) ?? 0\n    })\n    \n    return sum\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342250,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n  let mySet = CharacterSet(charactersIn: \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz .?!+*=%&#$@()\")\n  return string.components(separatedBy: mySet).flatMap{ Int($0) }.reduce(0, +)\n  \/\/  .union bug in swift 3.1.1\n  \/\/  in swift 4+ can write\n  \/\/  return string.components(separatedBy: CharacterSet.letters.union(.symbols).union(.punctuationCharacters).union(.whitespaces)).compactMap{ Int($0) }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342251,"user_id":null,"body":"func sumOfIntegersInString(_ string: String) -> Int {\n    var sum = 0\n    var array = [String]()\n    var charArray = string.characters\n    for (index , character) in charArray.enumerated() {\n        if let num = Int(String(character)) {\n            array.append(String(character))\n            if charArray.count == index + 1 {\n                if let number = Int(array.joined()) {\n                    sum += number\n                }\n            }\n        } else {\n            if let number = Int(array.joined()) {\n                sum += number\n            }\n            array.removeAll()\n        }\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59901fb5917839fe41000029":[{"id":342252,"user_id":1367,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n  let alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  var counter = 0\n  var result = \"\"\n  let numCharArray = Array(numbers.characters)\n  for c in template.characters {\n    if alphabet.characters.contains(c) {\n      let index = counter % numCharArray.count\n      result += String(numCharArray[index])\n      counter += 1\n    } else {\n      result += String(c)\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342253,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n    var index = 0\n    var result = [String]()\n    var numbers = numbers\n    while template.count > numbers.count { numbers += numbers }\n    \n    let numArr = numbers.compactMap { $0 }\n    \n    for char in template {\n        if char.isLetter {\n            result.append(\"\\(numArr[index])\")\n            index += 1\n        } else {\n            result.append(\"\\(char)\")\n        }\n    }\n    \n    return result.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342254,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n    var num=numbers\n    var result=\"\"\n        for char in template {\n            if char.isLetter {\n                result.append(num.removeFirst())\n                num = num.isEmpty ? numbers:num\n            } else {\n                result.append(char)\n            }\n        }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342255,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n\tvar templatified = \"\"\n\tvar filler = numbers\n\tfor char in template {\n\t\tif char.isLetter {\n\t\t\tif filler.isEmpty {\n\t\t\t\tfiller = numbers\n\t\t\t}\n\t\t\ttemplatified.append(filler.removeFirst())\n\t\t} else\t{\n\t\t\ttemplatified.append(char)\n\t\t}\n\t}\n\treturn templatified\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342256,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n\tvar result = \"\"\n\tvar index = 0\n\ttemplate.enumerated().forEach {\n\t\tif \"abcdefghijklmnopqrstuvwxyz\".contains($0.element.lowercased()) {\n\t\t\tlet chars = Array(numbers)\n\t\t\tresult += \"\\(chars[index])\"\n\t\t\tindex += 1\n\t\t\tif index > chars.count - 1 {\n\t\t\t\tindex = 0\n\t\t\t}\n\t\t} else {\n\t\t\tresult += \"\\($0.element)\"\n\t\t}\n\t}\n\treturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342257,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n    var resultStr = \"\"\n    var currentIndex = 0\n    for str in template {\n        if str.isLetter {\n            let index = numbers.index(numbers.startIndex, offsetBy: currentIndex)\n            resultStr.append(numbers[index])\n            if currentIndex < numbers.count - 1 {                \n                currentIndex += 1\n            } else {\n                currentIndex = 0\n            }\n        } else {\n            resultStr.append(str)\n        }\n    }\n    return resultStr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342258,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n    var result = \"\"\n    var currentNumberPos = 0\n    \n    template.forEach { value in\n        if value.isLetter {\n            let index = String.Index(utf16Offset: currentNumberPos % numbers.count, in: numbers)\n            result += String(numbers[index])\n            currentNumberPos += 1\n        } else {\n            result += String(value)\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342259,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n    var i = 0\n    return template.characters.map({ \n        if CharacterSet.letters.contains(UnicodeScalar(String($0))!) {\n            let r = numbers.characters.map({String($0)})[i]\n            i = i+1 < numbers.characters.count ? i+1 : 0\n            return r\n        } else {\n            return String($0)\n        }\n    }).joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342260,"user_id":null,"body":"func numericFormatter(_ template: String, _ numbers: String = \"1234567890\") -> String {\n    var nn = numbers\n    return template.map { s -> String in\n        if s.isLetter {\n            if nn.isEmpty {\n                nn = numbers\n            }\n            let f = nn.first!\n            nn = String(nn.dropFirst())\n            return String(f)\n        } else {\n            return String(s)\n        }\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342261,"user_id":null,"body":"extension String {\n    func containsOnlyAlphabeticals() -> Bool {\n        let lowercase = NSCharacterSet.lowercaseLetters\n        let uppercase = NSCharacterSet.uppercaseLetters\n\n        if rangeOfCharacter(from: lowercase, options: String.CompareOptions.literal, range: nil) == nil && rangeOfCharacter(from: uppercase, options: String.CompareOptions.literal, range: nil) == nil{\n            return false\n        }\n        return true\n    }\n}\n\nfunc countLetters(in template: String) -> Int {\n    var lettersCount: Int = 0\n    for char in template.characters {\n        if String(char).containsOnlyAlphabeticals() {\n            lettersCount += 1\n        }\n    }\n    return lettersCount\n}\n\nfunc topUp(numberString: String, to templateLength: Int) -> String {\n    var newNumberString = numberString\n    \n    for i in newNumberString.characters.count..<templateLength {\n        let characterToAdd = numberString[numberString.index(numberString.startIndex, offsetBy: (i % numberString.characters.count))]\n        newNumberString.append(characterToAdd)\n    }\n    return newNumberString\n}\n\nfunc replaceTemplateLetters(with numberString: String, in template: String) -> String {\n    \/\/: The output variable to hold all mutations\n    var stringFormatedToTemplate = \"\"\n    var i: Int = 0\n    for char in template.characters {\n        if String(char).containsOnlyAlphabeticals() {\n            let characterToAdd = numberString[numberString.index(numberString.startIndex, offsetBy:i)]\n            stringFormatedToTemplate += String(characterToAdd) \n            print(stringFormatedToTemplate)\n            i += 1\n        } else if String(char) == \" \" {\n            stringFormatedToTemplate += String(\" \")\n            print(\"*\",stringFormatedToTemplate)\n        } else {\n            stringFormatedToTemplate += String(char)\n            print(\"**\",stringFormatedToTemplate)\n        }\n    }\n    print(stringFormatedToTemplate)\n    return stringFormatedToTemplate\n}\n\nfunc numericFormatter(_ template: String, _ numberString: String = \"1234567890\") -> String {\n    var numberString = numberString\n    print(\"numberString:\",numberString)\n    \/*:\n     The numberString needs to have at least as many characters as the number of letters to be replaced in the template. So a count of the letters in the template is required to determine whether the numberString need to be topped-up.\n     *\/\n    let numberStringLengthReqd = countLetters(in: template)\n    if numberString.characters.count < numberStringLengthReqd {\n        numberString = topUp(numberString: numberString, to: numberStringLengthReqd)\n    }\n    return replaceTemplateLetters(with: numberString, in: template)\n}\n\n\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"599bb194b7a047b04d000077":[{"id":342262,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n    return \"pizzas: \\(n*n\/64), slices: \\(Int(round(Float(n*n%64)\/8)))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342263,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n  return \"pizzas: \\((n*n) \/ 64), slices: \\(Int((Float((n*n) % 64) \/ 8).rounded()))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342264,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n    return \"pizzas: \\(n*n\/64), slices: \\(Int((Double(n*n%64)\/8).rounded()))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342265,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n  let area = Int(n*n)\n  var separatedArray = String(Double(area)\/Double(64)).components(separatedBy:\".\")\n  let decimalString = \"0.\\(separatedArray[1])\"\n  let decimal = Double(decimalString)!\n  let returnString = \"pizzas: \\(separatedArray[0]), slices: \\(round(decimal*8.0))\"\n  return String(String(returnString.dropLast()).dropLast())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342266,"user_id":1367,"body":"func howManyPizzas(_ n: Int) -> String {\n  let nPizzaSize = n * n\n  let nPizzas = nPizzaSize \/ 64\n  let nSlices = Int((Double(nPizzaSize).truncatingRemainder(dividingBy: 64.0) \/ 8.0).rounded())\n  return \"pizzas: \\(nPizzas), slices: \\(nSlices)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342267,"user_id":null,"body":"import Foundation\n\nfunc howManyPizzas(_ n: Int) -> String {\n  let m = modf(Double(n*n)\/64.0)\n  return \"pizzas: \\(Int(m.0)), slices: \\(Int(round(m.1*8)))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342268,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n    let allSlices = lround((Double(n * n) \/ 64) * 8)\n    return \"pizzas: \\(allSlices \/ 8), slices: \\(allSlices % 8)\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342269,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n  \n  let myN = n\n  let sliceOne = myN * myN\n  let sliceEight = 64\n  let pizzas = sliceOne \/ sliceEight\n  let slices = Int((round(Double(sliceOne % sliceEight) \/ 8)))\n  \n  return \"pizzas: \\(pizzas), slices: \\(slices)\"\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342270,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\nlet pizza8Inch = (3.14*8.0*8.0)\nlet slice = 25.0\nvar slicesSum = 0.0\nvar pizzaSum = 0.0\nif n == 0 {\n     slicesSum = 0.0\n     pizzaSum = 0.0\n}\nif n > 0 {\n    let nPizza = (3.14*Double(n*n))\n    pizzaSum = (nPizza\/pizza8Inch)\n    if pizzaSum >= 1 {\n\/\/        Int(nPizza)%Int(pizza8Inch)\n        \n       slicesSum = ((nPizza - Double(Int(pizzaSum))*(pizza8Inch))\/(slice)).rounded()\n        \n    } else {\n        slicesSum = (nPizza\/slice).rounded()\n    }\n   if slicesSum == 8 {\n        pizzaSum += 1\n     slicesSum = 0\n    }\n}\n  return \"pizzas: \\(Int(pizzaSum)), slices: \\(Int(slicesSum))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342271,"user_id":null,"body":"func howManyPizzas(_ n: Int) -> String {\n  let area8: Double = 4 * 4 * Double.pi\n  let slice8: Double = area8 \/ 8\n  let areaTemp: Double = (Double(n) \/ 2.0) * (Double(n) \/ 2.0) * Double.pi\n  let rest: Double = areaTemp - area8 * floor(areaTemp \/ area8)\n  var tempResult = rest > 0 ? String(Int(Double(rest\/slice8).rounded(.toNearestOrAwayFromZero))) : \"0\"\n  if Double(rest\/slice8) > 0.49 && Double(rest\/slice8) < 0.51 {\n    tempResult = \"1\"\n  }\n  return \"pizzas: \" + String(Int(floor(areaTemp\/area8))) + \", slices: \" + tempResult\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"599c7f81ca4fa35314000140":[{"id":342272,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n    guard n < sequence.count else { return 0 }\n    var result = 0\n    for index in n...sequence.count - 1 {\n        if sequence[index] == sequence[index-n] {\n            result += 1\n        }\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342273,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n    return sequence.enumerated().filter { $0.offset - n >= 0 ? sequence[$0.offset - n] == $0.element : false }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342274,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n  var res = 0  \n  for i in 0...sequence.count {\n    if sequence.count > (i + n) {\n      if sequence[i] == sequence[i + n]  {\n      res += 1\n      }\n    }  \n  }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342275,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n    if n >= sequence.count {\n        return 0\n    }\n    return zip(Array( sequence[..<(sequence.count - n)] ), Array( sequence[n...] ))\n        .reduce(0, {$0 + ($1.0 == $1.1 ? 1 : 0) } )\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342276,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n    guard !sequence.isEmpty, n < sequence.count else { return 0 }\n    return (n..<sequence.count).filter {\n        sequence[$0] == sequence[$0-n]\n    }.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342277,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n  var counter = 0\n  if sequence.isEmpty {\n    return counter\n  }\n  for i in n...sequence.count - 1 {\n    if sequence[i] == sequence[i - n] {\n      counter += 1\n    }\n  }\n  return counter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342278,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n  guard sequence.count > n else { return 0 }\n  var counter: Int = 0\n  for i in n..<sequence.count\u00a0{\n    if sequence[i-n] == sequence[i] { counter += 1 }\n  }\n  return counter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342279,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n  var count = 0\n for i in 0...sequence.count {\n    if i + n < sequence.count && sequence[i] == sequence[i + n]{\n        count += 1\n    }\n  }\n  return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342280,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n  var r = 0\n  var i = n\n  \n  while i < sequence.count {\n    if sequence[i] == sequence[i - n] {\n      r += 1\n    }\n    i += 1\n  }\n  \n  return r\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342281,"user_id":null,"body":"func countTargets(_ n: Int, _ sequence: [Int]) -> Int {\n    var count = 0\n    for (index, element) in sequence.enumerated() {\n      if index >= n {\n        if element == sequence[index - n] {\n          count += 1\n        }\n      } \n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59a2666349ae65ea69000051":[{"id":342282,"user_id":null,"body":"class Tolkien {\n    static func calculateCartTotal(_ books: [String]) -> Int {\n        var result = 0, grpF = [String](), grpT = [String](), grpR = [String](), grpH = [String]()\n        \n        for obj in books {\n            if obj == \"F\" { grpF += [obj]\n            }else if obj == \"T\" { grpT += [obj]\n            }else if obj == \"R\" { grpR += [obj]\n            }else if obj == \"H\" { grpH += [obj] }\n        }\n        \n        for idx in 0..<books.count {\n            var num = 0\n            if idx < grpF.count { num += 1 }\n            if idx < grpT.count { num += 1 }\n            if idx < grpR.count { num += 1 }\n            if idx < grpH.count { num += 1 }\n            if num == 0 { break }\n            result += num == 4 ? 32 : num == 3 ? 27 : num == 2 ? 19 : 10\n        }\n        \n        return result\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342283,"user_id":null,"body":"class Tolkien {\n  static func calculateCartTotal(_ books: [String]) -> Int {\n    let uniq = Set(books), m = uniq.count\n    if m<2 { return 10*books.count }\n    var mbooks = books\n    for book in uniq { mbooks.remove(at: mbooks.firstIndex(of: book)!) }\n    return (m==4 ? 32 : m==3 ? 27 : 19) + calculateCartTotal(mbooks)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342284,"user_id":null,"body":"class Tolkien {\n    static func calculateCartTotal(_ books: [String]) -> Int {\n        let prices = [10,19,27,32]\n        var counts: [String: Int] = [:]\n        for book in books {\n            counts[book] = (counts[book] ?? 0) + 1\n        }\n        var total = 0, discounts = 0, size = counts.count - 1\n        for bk in counts.values.sorted() {\n            let diff = bk - discounts\n            total += diff * prices[size]\n            discounts += diff\n            size -= 1\n        }\n        return total\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342285,"user_id":null,"body":"class Tolkien {\n    static func calculateCartTotal(_ books: [String]) -> Int {\n        let uniqueBooks = Set(books)\n        let count = uniqueBooks.count\n        var books = books\n        \n        if count < 2 { return 10 * books.count }\n        \n        for book in uniqueBooks {\n            books.remove(at: books.firstIndex(of: book)!)\n        }\n        \n        return (count == 4 ? 32 : count == 3 ? 27 : 19) + calculateCartTotal(books)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342286,"user_id":null,"body":"final class Tolkien {\n    static func calculateCartTotal(_ books: [String]) -> Int {\n        var titlesCount = [String: Int]()\n        books.forEach { titlesCount[$0] = titlesCount[$0, default: 0] + 1 }\n        var sum = 0\n        while true {\n            var comboCount = 0\n            titlesCount.forEach {\n                if $0.value > 0 {\n                    titlesCount[$0.key] = titlesCount[$0.key]! - 1\n                    comboCount += 1\n                }\n            }\n\n            if comboCount == 0 {\n                break\n            } else {\n                sum += Int(Double(comboCount) * 10 * discount(for: comboCount))\n            }\n        }\n\n        return sum\n    }\n\n    private static func discount(for count: Int) -> Double {\n        switch count {\n        case 1:\n            return 1.0\n        case 2:\n            return 0.95\n        case 3:\n            return 0.9\n        case 4:\n            return 0.8\n        default:\n            fatalError(\"Seems Tolkien has wrote something else recently!\")\n        }\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342287,"user_id":null,"body":"class Tolkien {\n  class func calculateCartTotal(_ b: [String]) -> Int {\n    let discounts = [0, 0.05, 0.1, 0.2]\n    \n    var books = b\n    var cost = 0.0\n    \n    while !books.isEmpty {\n      var hand = [String]()\n      \n      while hand.count != discounts.count {\n        guard let book = books.first(where: { hand.isEmpty || !hand.contains($0) }) else { break }\n        hand.append(book)\n        books.remove(at: books.firstIndex(of: book)!)\n      }\n      \n      cost += Double(hand.count) * 10 * (1 - discounts[hand.count - 1])\n    }\n    \n    return Int(cost)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342288,"user_id":null,"body":"class Tolkien {\n    static func calculateCartTotal(_ books: [String]) -> Int {\n        var cost = 0.0\n        var count = books.reduce(into: [:]) { arr, book in arr[book, default: 0] += 1 }\n        while count.count == 4 {\n            for book in count.keys {\n                count[book]! -= 1\n                cost += 8\n                if count[book] == 0 { count.removeValue(forKey: book) }\n            }\n        }\n        while count.count == 3 {\n            for book in count.keys {\n                count[book]! -= 1\n                cost += 9\n                if count[book] == 0 { count.removeValue(forKey: book) }\n            }\n        }\n        while count.count == 2 {\n            for book in count.keys {\n                count[book]! -= 1\n                cost += 9.5\n                if count[book] == 0 { count.removeValue(forKey: book) }\n            }\n        }\n        for book in count.keys {\n            cost += Double(count[book]!) * 10.00\n        }\n        return Int(cost)\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342289,"user_id":null,"body":"class Tolkien {\n  static func calculateCartTotal(_ books: [String]) -> Int {\n    var titles: [String:Int] = books.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    \n    func countTitleCollections(_ titles: [String:Int], _ counts: [Int]) -> [Int] {\n      guard !titles.isEmpty else { return counts } \n      return countTitleCollections(\n        titles.mapValues { $0 - 1 }.filter { $0.1 > 0 },\n        counts + [titles.keys.count]\n      )\n    }\n    \n    return countTitleCollections(titles, []).reduce(0) {\n      switch $1 {\n      case 1: return $0 + 10\n      case 2: return $0 + 19\n      case 3: return $0 + 27\n      case 4: return $0 + 32\n      default: fatalError()\n      }\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342290,"user_id":null,"body":"class Tolkien {\n  static func calculateCartTotal(_ books: [String]) -> Int {\n    let uniq = Set(books), m = uniq.count\n    if m<2 { return 10*books.count }\n    var mbooks = books; let res = m==4 ? 32 : m==3 ? 27 : 19\n    for book in uniq { mbooks.remove(at: mbooks.firstIndex(of: book)!) }\n    return res+calculateCartTotal(mbooks)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342291,"user_id":null,"body":"class Tolkien {\n  static func calculateCartTotal(_ books: [String]) -> Int {\n    let uniq = Set(books), m = uniq.count\n    if m<2 { return 10*books.count }\n    var mbooks = books; let res = m==4 ? 32*(m\/4) : (m==3 ? 27*(m\/3) : 19*(m\/2))\n    for book in uniq { mbooks.remove(at: mbooks.firstIndex(of: book)!) }\n    return res+calculateCartTotal(mbooks)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59c68ea2aeb2843e18000109":[{"id":342292,"user_id":null,"body":"import Foundation \n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    var (b, statement) = (balance, \"\")\n    let r = rate\/1200\n    let n = r * b\n    let d = 1 - pow(1.0 + r, Double(-1 * term))\n    let c = n \/ d \n    for _ in 1 ... numPayments {\n      let i = b * r\n      let p = c - i\n      b -= p\n      statement = \"num_payment \\(numPayments) c \\(Int(round(c))) princ \\(Int(round(p))) int \\(Int(round(i))) balance \\(Int(round(b)))\"\n    }\n    return statement\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342293,"user_id":null,"body":"import Foundation \n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    var balance = balance\n    let r = rate \/ (100 * 12)\n    let c = (r * balance) \/ (1 - pow(1 + r, Double(-term)))\n    \n    var int = r * balance\n    var princ = c - int\n    \n    for _ in 0..<numPayments {\n        int = r * balance\n        princ = c - int\n        balance -= princ\n    }\n    \n    return String(\n        format: \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\",\n        numPayments, c, princ, int, balance\n    )\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342294,"user_id":null,"body":"import Foundation \n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    var newBalance = balance\n    var c: Double\n    var n: Double\n    var r: Double\n    var princ: Double\n    var d: Double\n    var interest: Double\n    \n    r = rate \/ 1200\n\n    d  = 1 - (pow((1 + r), -Double(term)))\n    print(d)\n\n    n =  r * balance\n    print(n)\n\n    c = n\/d\n    print(c)\n\n    interest = balance * r\n    print(interest)\n\n    princ =  c - interest\n    print(princ)\n\n    for _ in 1...numPayments {\n        interest = newBalance * r\n        princ = c - interest\n        newBalance -= (princ)\n    }\n    \n    print(\"num_payment \\(numPayments) c \\(Int(round(c))) princ \\(Int(round(princ))) int \\(Int(round(interest))) balance \\(Int(round(newBalance)))\")\n    \n    return \"num_payment \\(numPayments) c \\(Int(round(c))) princ \\(Int(round(princ))) int \\(Int(round(interest))) balance \\(Int(round(newBalance)))\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342295,"user_id":null,"body":"import Foundation \n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    let r = rate\/1200\n    let n = r * balance\n    let d = 1 - pow(1.0 + r, Double(-1 * term))\n    let c = (r * balance) \/ (1 - pow(1.0 + r, Double(-1 * term)))\n    var (b, s) = (balance, \"\")\n    for _ in 1 ... numPayments {\n      let i = b * r\n      let p = c - i\n      b -= p\n      s = \"num_payment \\(numPayments) c \\(Int(round(c))) princ \\(Int(round(p))) int \\(Int(round(i))) balance \\(Int(round(b)))\"\n    }\n    return s\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342296,"user_id":null,"body":"import Foundation \n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    let d = 1 - 1 \/ (pow(1 + rate \/ 1200, Double(term)))\n    let c = (balance * rate \/ 1200) \/ d\n    var princ = 0.0\n    var currentBal = balance\n    var int = 0.0\n    for _ in 1...numPayments {\n        int = currentBal * rate \/ 1200\n        princ = c - int\n        currentBal -= princ\n    }\n    return String(format: \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\", numPayments, c, princ, int, currentBal)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342297,"user_id":null,"body":"import Foundation \nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    let prcRate = rate \/ 1200 \/\/% rate as Double\n    let d = 1 - 1 \/ (pow(1 + prcRate, Double(term)))\n    let c = (rate * balance) \/ 12 \/ 100 \/ d\n    let num_payment = numPayments\n    var princ = 0.0\n    var currentBal = balance\n    var int = 0.0\n    for _ in 1...numPayments {\n        int = currentBal * prcRate\n        princ = c - int\n        currentBal -= princ\n    }\n    return String(format: \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\", num_payment, c, princ, int, currentBal)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342298,"user_id":null,"body":"import Foundation \n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n  let r = rate \/ 1200\n  var schedule = [(numPayment: 0, c: (balance * r) \/ (1 - pow((1 + r), Double(term * -1))), princ: 0.0, int: 0.0, balance: balance)]\n  \n  for i in 1...numPayments {\n    var newPayment = (numPayment: i, c: schedule[0].c, princ: 0.0, int: 0.0, balance: schedule[i - 1].balance)\n    \n    newPayment.int = newPayment.balance * r\n    newPayment.princ = newPayment.c - newPayment.int\n    newPayment.balance -= newPayment.princ\n    \n    schedule.append(newPayment)\n  }\n  return \"num_payment \\(schedule[numPayments].numPayment) c \\(String(format: \"%.0f\", schedule[numPayments].c)) princ \\(String(format: \"%.0f\", schedule[numPayments].princ)) int \\(String(format: \"%.0f\", schedule[numPayments].int)) balance \\(String(format: \"%.0f\", schedule[numPayments].balance))\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342299,"user_id":null,"body":"func amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n  let r = rate \/ 100 \/ 12\n  let d = 1 - pow(1 + r, Double(-term))\n  let n = r * balance\n  let c = n \/ d\n  \n  var b = balance\n  var pb = b\n  (1...numPayments).forEach { _ in\n    pb = b\n    b = (1 + r) * b - c\n  }\n  \n  let pc = pb - b\n  let i = c - pc\n  \n  return String(\n    format: \"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\",\n    numPayments, c, pc, i, b\n  )\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342300,"user_id":null,"body":"func amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n  var balance = balance\n  let r = rate \/ 1200.0\n  let c = (r * balance) \/ (1.0 - pow((1.0 + r), Double(-term)))\n  var interest = r * balance\n  var princ = c - interest\n  for _ in 0..<numPayments {\n    interest = r * balance\n    princ = c - interest\n    balance = balance - princ\n  }\n  return \"num_payment \\(numPayments) c \\(String(format: \"%.0f\", c)) princ \\(String(format: \"%.0f\", princ)) int \\(String(format: \"%.0f\", interest)) balance \\(String(format: \"%.0f\", balance))\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342301,"user_id":null,"body":"import Foundation \n\ninfix operator **\nfunc **(_ num: Double, _ power: Double) -> Double {\n    return pow(num, power)\n}\n\nfunc amort(_ rate: Double, _ balance: Double, _ term: Int, _ numPayments: Int) -> String {\n    \n    let monthlyRate = (rate\/100) \/ 12\n    let dterm = Double(term)\n    let dnumPayments  = Double(numPayments)\n    \n    let monthlyPayment = (monthlyRate * balance) \/ (1.0 - ((1.0 + monthlyRate) ** -dterm))\n    let rMonthlyPayment = Int(round(monthlyPayment))\n    \n    let outstandingBalance = (balance * (((1.0 + monthlyRate)**dterm) - ((1.0 + monthlyRate)**dnumPayments))) \/ (((1.0 + monthlyRate)**dterm) - 1.0)\n    let rOutstandingBalance = Int(round(outstandingBalance))\n    let oldOutBal = (balance * (((1.0 + monthlyRate)**dterm) - ((1.0 + monthlyRate)**(dnumPayments - 1)))) \/ (((1.0 + monthlyRate)**dterm) - 1.0)\n\n    \n    let princ = monthlyPayment - (oldOutBal * monthlyRate)\n    let rPrinc = Int(round(princ))\n    \n    let interest = oldOutBal * monthlyRate\n    let rInterest = Int(round(interest))\n    \n    let stmt = \"num_payment \\(numPayments) c \\(rMonthlyPayment) princ \\(rPrinc) int \\(rInterest) balance \\(rOutstandingBalance)\"\n    \n    return stmt\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"59ca8246d751df55cc00014c":[{"id":342302,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n    return bullets >= dragons * 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342303,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n  bullets%dragons == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342304,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n    return bullets >= (dragons * 2) \/\/ \ud83d\udca5\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342305,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n\/\/   if bullets >= dragons * 2 { \n\/\/     return true\n\/\/   } else {\n\/\/     return false\n\/\/   }\n  \nreturn bullets >= dragons * 2 \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342306,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n  dragons * 2 <= bullets\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342307,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n bullets  > dragons + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342308,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n  if bullets \/ dragons < 2{\n    return false\n  }else{\n    return true\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342309,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n    return (bullets % dragons) == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342310,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n  \n  return bullets \/ 2 >= dragons\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342311,"user_id":null,"body":"func hero(bullets: Int, dragons: Int) -> Bool {\n  return bullets \/ dragons >= dragons ? true : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a00e05cc374cb34d100000d":[{"id":342312,"user_id":527,"body":"func reverse_seq(n: Int) -> [Int] {\n  return (1...n).reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342313,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n  var result: [Int] = []\n  for num in 1...n {\n    result.insert(num, at:0)\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342314,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n  \n  var arrayOfInt = [Int](1...n)\n  var sortedArrayOfInt = arrayOfInt.sorted(by: >)\n  \n  return sortedArrayOfInt\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342315,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n  Array(1...n).reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342316,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n    var decreasingArray: [Int] = []\n\n    for index in stride(from: n, through: 1, by: -1) {\n        decreasingArray.append(index)\n    }\n    return decreasingArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342317,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n  var arr: [Int] = []\n  var i = n\n  while i > 0 {\n    arr.append(i)\n    i -= 1\n  }\n  return arr\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342318,"user_id":527,"body":"func reverse_seq(n: Int) -> [Int] {\n  return Array((1...n).reversed())\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342319,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n  var arr = Array(1...n)\n  return arr.reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342320,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n    var i=0\n    var auxNum=n\n    var array:[Int]=[]\n  \n  while(i < n){\n    array.append(auxNum)   \n     auxNum-=1\n    i+=1\n  }\n  return array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342321,"user_id":null,"body":"func reverse_seq(n: Int) -> [Int] {\n  \/\/create a variable of n\n  \/\/create an empty array of Int called sequenceArray\n  \/\/ while variableOfN > 0, append n to sequenceArray\n  \/\/ then subtract 1 from variable of n\n  \n  var variableOfN = n\n  var sequenceArray : [Int] = []\n  \n  while variableOfN > 0 {\n    sequenceArray.append(variableOfN)\n    variableOfN -= 1\n  }\n  \n  return sequenceArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a03b3f6a1c9040084001765":[{"id":342322,"user_id":2185,"body":"func angle(_ n: Int) -> Int {\n    return n < 3 ? 0 : (n - 2) * 180\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342323,"user_id":null,"body":"func angle(_ n: Int) -> Int {\n    180 * (n - 2)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342324,"user_id":null,"body":"func angle(_ n: Int) -> Int {\n    let result = (n - 2) * 180\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342325,"user_id":645,"body":"func angle(_ n: Int) -> Int {\n    return (n - 2) * 180\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342326,"user_id":null,"body":"func angle(_ n: Int) -> Int {\nif n >= 2 {\nlet a = 180 * (n - 2)\n  return a\n} else {\n    return 180\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342327,"user_id":null,"body":"func angle(_ n: Int) -> Int {\n    \/\/ your code here\n  return 180 * (n-2)\n} ","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342328,"user_id":null,"body":"func angle(_ n: Int) -> Int {\n    let s = 180 * (n - 2)\n    return s \n}\n\n\n\n\n\/\/ s = 2d(n - 2),\n\n\/\/ s  \u2014 \u044d\u0442\u043e \u0441\u0443\u043c\u043c\u0430 \u0443\u0433\u043b\u043e\u0432,  \n\/\/ 2d  \u2014 \u0434\u0432\u0430 \u043f\u0440\u044f\u043c\u044b\u0445 \u0443\u0433\u043b\u0430 (\u0442\u043e \u0435\u0441\u0442\u044c  2 \u00b7 90 = 180\u00b0),  \n\/\/ n  \u2014 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u043e\u0440\u043e\u043d","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342329,"user_id":null,"body":"func angle(_ n: Int) -> Int {\n    return (180 * n - 360)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342330,"user_id":null,"body":"\nfunc angle(_ n: Int) -> Int {\n   return (2 * n - 4) * 90\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342331,"user_id":null,"body":"func angle(_ n: Int) -> Int {\n    let result = 180 * (n - 2)\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a045fee46d843effa000070":[{"id":342332,"user_id":null,"body":"import Foundation \n\nfunc decomp(_ m: Int) -> String {\n  return (1...m).reduce(into: Array(repeating: 0, count: m + 1)) { arr, num in\n      var i = 2, num = num\n      while num > 0 && i <= num {\n        if num % i != 0 { i += 1 }\n        else { arr[i] += 1; num \/= i }\n      }\n    }.enumerated()\n     .filter { $1 != 0 }\n     .map { $1 == 1 ? \"\\($0)\" : \"\\($0)^\\($1)\" }\n     .joined(separator: \" * \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342333,"user_id":null,"body":"import Foundation\n\nextension Int {\n  func isPrime() -> Bool {\n    guard self != 2 else { return true }\n    guard !self.isMultiple(of: 2) && self > 1 else { return false }\n    \n    var i = 3\n    while i * i <= self {\n      guard !self.isMultiple(of: i) else {\n        return false\n      }\n      \n      i += 2\n    }\n    \n    return true\n  }\n}\n\n\/\/ Legendre's Theorem\nfunc factorPower(p: Int, n: Int) -> Int {\n  let p = Double(p)\n  let n = Double(n)\n  \n  let sumLimit = Int(log(n) \/ log(p))\n  \n  return Int(\n    (1...sumLimit)\n      .reduce(0) { sum, k in sum + floor(n \/ pow(p, Double(k))) }\n  )\n}\n\nfunc decomp(_ n: Int) -> String {\n  return (2...n)\n    .filter { $0.isPrime() }\n    .map { (prime: $0, power: factorPower(p: $0, n: n)) }\n    .map { $0.power == 1 ? \"\\($0.prime)\" : \"\\($0.prime)^\\($0.power)\" }\n    .joined(separator: \" * \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342334,"user_id":null,"body":"import Foundation \n\nfunc decomp(_ m: Int) -> String {\n    let primeFactors = (2...m)\n        .flatMap(factorize)\n\n    let histogram: [Int: Int] = primeFactors\n        .reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    \n    return histogram\n        .sorted { $0.0 < $1.0 }\n        .map { (factor, count) in\n            count == 1 ? \"\\(factor)\" : \"\\(factor)^\\(count)\"\n        }\n        .joined(separator: \" * \")\n}\n\nfunc factorize(number: Int) -> [Int] {\n    guard number > 3 else {\n        return [number]\n    }\n    \n    let squareRoot = Int(Double(number).squareRoot())\n    var currentNumber = number\n    var factors: [Int] = []\n    \n    for factor in 2...squareRoot {\n        while currentNumber % factor == 0 {\n            factors.append(factor)\n            currentNumber \/= factor\n        }\n    }\n    \n    return currentNumber == 1 ? factors : factors + [currentNumber]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342335,"user_id":null,"body":"import Foundation \n\nfunc decomp(_ number: Int) -> String {\n    \/\/ your code\n    var primeDic: Dictionary<Int, Int> = Dictionary<Int, Int>()\n    var primes: Array<Int> = Array<Int>()\n    \n    for index in 2...number {\n        var m = index\n        while m > 1 {\n            for i in 2...m {\n                if m % i == 0 {\n                    \/\/                print(\"\\(i)\")\n                    if let count = primeDic[i] {\n                        primeDic[i] = count + 1\n                    } else {\n                        primeDic[i] = 1\n                        primes.append(i)\n                    }\n                    m = m \/ i\n                    break\n                }\n            }\n        }\n    }\n    \n    let resultArray = primes.flatMap { (prime) -> String? in\n        if let primeCount = primeDic[prime] {\n            return primeCount > 1 ? String(prime) + \"^\" + String(primeCount) : String(prime)\n        } else {\n            return \"\"\n        }\n    }\n    \n    return resultArray.joined(separator: \" * \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342336,"user_id":null,"body":"func decomp(_ m: Int) -> String {\n    let histogram: [Int: Int] = (2...m)\n        .flatMap(factorize)\n        .reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    \n    return histogram\n        .sorted { $0.0 < $1.0 }\n        .map { (number, count) in\n            count == 1 ? \"\\(number)\" : \"\\(number)^\\(count)\"\n        }\n        .joined(separator: \" * \")\n}\n\nfunc factorize(number: Int) -> [Int] {\n    guard number > 3 else {\n        return [number]\n    }\n    \n    let squareRoot = Int(Double(number).squareRoot())\n    var currentNumber = number\n    var factors: [Int] = []\n    \n    for factor in 2...squareRoot {\n        while currentNumber % factor == 0 {\n            factors.append(factor)\n            currentNumber \/= factor\n        }\n    }\n    \n    return currentNumber == 1 ? factors : factors + [currentNumber]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342337,"user_id":null,"body":"import Foundation \n\nfunc decomp(_ m: Int) -> String {\n    let histogram: [Int: Int] = (2...m)\n        .flatMap(factorize)\n        .reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    \n    return histogram\n        .sorted { $0.0 < $1.0 }\n        .map { (number, count) in\n            count == 1 ? \"\\(number)\" : \"\\(number)^\\(count)\"\n        }\n        .joined(separator: \" * \")\n}\n\nfunc factorize(number: Int) -> [Int] {\n    guard number > 3 else {\n        return [number]\n    }\n    \n    let squareRoot = Int(Double(number).squareRoot())\n    var currentNumber = number\n    var factors: [Int] = []\n    \n    for factor in 2...squareRoot {\n        while currentNumber % factor == 0 {\n            factors.append(factor)\n            currentNumber \/= factor\n        }\n    }\n    \n    return currentNumber == 1 ? factors : factors + [currentNumber]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342338,"user_id":null,"body":"func decomp(_ m: Int) -> String {\n  var decomp = [Int: Int]()\n  \n  var i = 2\n  var r = i\n  while i <= m {\n    if let d = decomp.first(where: { key, _ in r % key == 0 }) {\n      r \/= d.key\n      decomp[d.key, default: 0] += 1\n    }\n    else {\n      decomp[r] = 1\n      r = 1\n    }\n    if r == 1 {\n      i += 1\n      r = i\n    }\n  }\n  \n  return decomp\n    .sorted { $0.0 < $1.0 }\n    .map { ($1 == 1) ? \"\\($0)\" : \"\\($0)^\\($1)\" }\n    .joined(separator: \" * \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342339,"user_id":null,"body":"func decomp(_ m: Int) -> String {\n  var factors: [Int] = []\n  var counts: [Int:Int] = [:]\n  for n in 2...m {\n    var decomposing = n\n    for p in factors {\n      while decomposing % p == 0 {\n        counts[p, default: 0] += 1\n        decomposing \/= p  \n      }\n    }\n    if decomposing > 1 { \n      factors.append(decomposing)\n      counts[decomposing] = 1\n    }\n  }\n  return factors.map { counts[$0] == 1 ? \"\\($0)\" : \"\\($0)^\\(counts[$0]!)\"}.joined(separator: \" * \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342340,"user_id":null,"body":"import Foundation\n\nfunc decomp(_ m: Int) -> String {\n    let primesArr =  [Int](2...m).filter({num in [Int](1...Int(sqrt(Float(num))))\n                                                .filter({num % $0 == 0}).count == 1 })\n    var arr = Array(1...m)\n    var count = 0\n    var out = [String]()\n        for k in primesArr where k <= m {\n            count = 0\n            for i in 0..<arr.count {\n                if arr[i] != 1 {\n                    while arr[i].isMultiple(of: k) {\n                        arr[i] \/= k\n                        count += 1\n                    }\n                }\n            }\n            if count > 0 {\n                if count > 1 {\n                    out.append(\"\\(k)^\\(count)\")\n                }\n                else { out.append(\"\\(k)\") }\n            }\n    }\n    return out.joined(separator: \" * \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342341,"user_id":null,"body":"import Foundation \n\nfunc primeFactors(of number: Int) -> [Int] {\n    guard number >= 4 else {\n        return [number]\n    }\n\n    for factor in 2 ... Int(sqrt(Double(number))) {\n        if number.isMultiple(of: factor) {\n            return [factor] + primeFactors(of: number \/ factor)\n        }\n    }\n\n    return [number]\n}\n\nfunc decomp(_ m: Int) -> String {\n    var factors: [Int] = []\n\n    for i in 2 ... m {\n        factors.append(contentsOf: primeFactors(of: i))\n    }\n\n    factors.sort()\n\n    let result: [(base: Int, exp: Int)] = factors.reduce(into: []) { partialResult, factor in\n        if partialResult.last?.base == factor {\n            partialResult[partialResult.count - 1].exp += 1\n        } else {\n            partialResult += [(base: factor, exp: 1)]\n        }\n    }\n\n    let formatted: [String] = result.map { pair in\n        if pair.exp > 1 {\n            return \"\\(pair.base)^\\(pair.exp)\"\n        } else {\n            return String(pair.base)\n        }\n    }\n    return formatted.joined(separator: \" * \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a057ec846d843c81a0000ad":[{"id":342342,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n    if n % 2 == 0 || n % 5 == 0 { return -1 }\n    \n    var count = 1\n    var x = 10\n    \n    while x != 1 {\n        if (x \/ n) == 0 {\n            x *= 10\n            count += 1\n        } else {\n            x = x % n\n        }\n    }\n    \n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342343,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n    if n.isMultiple(of: 2) || n.isMultiple(of: 5) {\n        return -1\n    }\n    var p = 10\n    var ans = 0\n    repeat {\n        p = (p%n) * 10\n        ans += 1\n    } while p != 10\n    return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342344,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n  if n % 2 == 0 || n % 5 == 0 { return -1 }\n  var  value = 1, i = 1\n  while true {\n    value = value * 10 % n\n    if value == 1 { break }; i += 1\n  }\n  return i\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342345,"user_id":492,"body":"func cycle(_ n: Int) -> Int {\n  if n % 2 == 0 || n % 5 == 0 { return -1 }\n  var i: Int = 1\n  var val: Int = 1\n  while true {\n    val = val * 10 % n\n    if val == 1 { break }\n    i += 1\n  }\n  return i\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342346,"user_id":null,"body":"func gcd(_ a : Int, _ b: Int) -> Int {\n    var (a, b) = (a > b) ? (a,b) : (b,a)\n    while (a % b != 0){\n        (a, b) = (a % b, b)\n        (a, b) = a > b ? (a,b) : (b,a)\n    }\n    return b\n}\n\nfunc cycle(_ n: Int) -> Int {\n    if gcd(n, 10) != 1 {return -1}\n    var c = 1\n    var p = 10 % n\n    while p != 1 {\n        p = ((p % n) * 10) % n\n        c += 1\n    }\n    return c\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342347,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n    if n % 2 == 0 || n % 5 == 0 { return -1 }\n    var i = 0\n    var val = 1\n\n    while i >= 0 {\n        i += 1\n        val = val * 10 % n\n        if val == 1 {\n            return i\n        }\n    }\n    \n    return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342348,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n    guard n % 2 != 0 else {return -1}\n    guard n % 5 != 0 else {return -1}\n    var count = 0\n    var rem = 1\n    for _ in 1...n {\n        rem = (10 * rem) % n\n    }\n    let d = rem\n    rem = (10 * rem) % n\n    count += 1\n    while  rem != d {\n        rem = (10 * rem) % n\n        count += 1\n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342349,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n    \n    var res = 10 % n\n    var cycle = 1\n    \n    if n % 2 == 0 || n % 5 == 0 {\n        return -1\n    } else {\n        while res != 1 {\n            res = res * 10 % n\n            cycle += 1\n        }\n    }\n    \n    return cycle\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342350,"user_id":null,"body":"extension Int {\n  \n  var factors: [Int] {\n    var i = 2\n    var res = [1]\n    while i <= (self \/ 2) {\n      if self % i == 0 { res.append(i) }\n      i += 1\n    }\n    res.append(self)\n    return res\n  }\n  \n  var fi: Int {\n    var i = 1\n    var count = 0\n    while i < self {\n      if coprime(i) { count += 1 }\n      i += 1\n    }\n    return count\n  }\n  \n  func mod(_ n: Int) -> Int {\n    var res = 10 % n\n    var m = 1\n    while m < self {\n      res = (res * (10 % n)) % n\n      m += 1\n    }\n    return res\n  }\n  \n  private func coprime(_ n: Int) -> Bool {\n    var a = self\n    var b = n\n    while (a != 0) && (b != 0) {\n      if a > b { a %= b }\n      else { b %= a }\n    }\n    let gcd = (a == 0) ? b : a\n    return (gcd == 1)\n  }\n}\n\nfunc cycle(_ n: Int) -> Int {\n  guard n % 2 != 0 else { return -1 }\n  guard n % 5 != 0 else { return -1 }\n  \n  var i = 0\n  let f = n.fi.factors\n  while true {\n    if f[i].mod(n) == 1 { return f[i] }\n    i += 1\n  }\n  return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342351,"user_id":null,"body":"func cycle(_ n: Int) -> Int {\n  var length = 1\n\tvar r = 1\n\tfor i in 1...n {\n\t\tr = (10 * r) % n\n\t\tswitch r {\n\t\tcase 0:\n\t\t\treturn -1\n\t\tcase 1:\n\t\t\treturn length\n\t\tdefault:\n\t\t\tlength += 1\n\t\t}\n\t}\n\treturn -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a2fd38b55519ed98f0000ce":[{"id":342352,"user_id":220,"body":"func multi_table(_ number: Int) -> String {\n    (1...10).map {\"\\($0) * \\(number) = \\($0 * number)\"}.joined(separator: \"\n\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342353,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n    var multiplicationTable = \"\"\n    for num in 1...10 {\n        multiplicationTable += (\"\\(num) * \\(number) = \\(number * num)\\(num != 10 ? \"\n\" : \"\")\")\n    }\n    return multiplicationTable\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342354,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n  var someStr = \"\"\n  var count = 1\n  \n  for _ in 1...9{\n    someStr = someStr + \"\\(count) * \\(number) = \\(number * count)\n\"\n    count += 1\n  }\n  someStr = someStr + \"10 * \\(number) = \\(number * 10)\"\n  return someStr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342355,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n    var arrStr: Array<String> = Array(repeating: \"\", count: 10)\n    for i in arrStr.indices {\n        arrStr[i] = \"\\(i+1) * \\(number) = \\((i+1) * number)\"\n    }\n    return arrStr.joined(separator: \"\n\")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342356,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n    var result = \"\"\n    for i in 1...10 {\n        result += \"\\(i) * \\(number) = \\(i * number)\n\"\n    }\n    result.removeLast()\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342357,"user_id":null,"body":"func multi_table(_ number: Int) -> String { \n  var result: [String] = [];\n  for i in 1...10 {\n    result.append(String(format: \"%d * %d = %d\", i, number, i * number));\n  }\n  return result.joined(separator: \"\n\");\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342358,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\nvar result = \"\"\n    for rows in 1...10 {\n        result += \"\\(rows) * \\(number) = \\(rows*number)\n\"\n    }\n    result.removeLast()\nreturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342359,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n    var str = \"\"\n    var count = 1\n    \n    for _ in 1...10 {\n        if count == 10 {\n            str += \"\\(count) * \\(number) = \\(count * number)\"\n            continue\n        }\n        str += \"\\(count) * \\(number) = \\(count * number)\n\"\n        count += 1\n    }\n    return str\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342360,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n  var string = \"\"\n    for num in 1...10{\n      if num == 10 {\n        string += \"\\(num) * \\(number) = \\(num * number)\"\n      }else{\n        string += \"\\(num) * \\(number) = \\(num * number)\n\"\n      }\n    }\n  return string\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342361,"user_id":null,"body":"func multi_table(_ number: Int) -> String {\n\tlet oneMulti = number * 1\n\tlet twoMulti = number * 2\n\tlet threeMulti = number * 3\n\tlet fourMulti = number * 4\n\tlet fiveMulti = number * 5\n\tlet sixMulti = number * 6\n\tlet sevenMulti = number * 7\n\tlet eigthMulti = number * 8\n\tlet nineMulti = number * 9\n\tlet tenMulti = number * 10\n\tlet result = \"\"\"\n1 * \\(number) = \\(oneMulti)\n2 * \\(number) = \\(twoMulti)\n3 * \\(number) = \\(threeMulti)\n4 * \\(number) = \\(fourMulti)\n5 * \\(number) = \\(fiveMulti)\n6 * \\(number) = \\(sixMulti)\n7 * \\(number) = \\(sevenMulti)\n8 * \\(number) = \\(eigthMulti)\n9 * \\(number) = \\(nineMulti)\n10 * \\(number) = \\(tenMulti)\n\"\"\"\n\treturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a3fe3dde1ce0e8ed6000097":[{"id":342362,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n    return Int((Double(year) \/ 100).rounded(.up))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342363,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n    let century_from_year = year % 100 == 0 ? (year \/ 100) : (year \/ 100) + 1\n    return century_from_year\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342364,"user_id":527,"body":"func century_from_year(_ year: Int) -> Int {\n    return (year + 99) \/ 100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342365,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n\n\n    var numbers = [0] \/\/1..20\n    for i in 0...20{\n        numbers.append(i+1)\n    }\n\n    let result = numbers.map { $0 * 100 } \/\/0..2100\n    \n    \n        switch year {\n            case 0...100:\n                return 1\n            case 101...200:\n                return 2\n            case 201...300:\n                return 3\n            case 301...400:\n                return 4\n            case 401...500:\n                return 5\n            case 501...600:\n                return 6\n            case 601...700:\n                return 7\n            case 701...800:\n                return 8\n            case 801...900:\n                return 9\n            case 901...1000:\n                return 10\n            case 1001...1100:\n                return 11\n            case 1101...1200:\n                return 12\n            case 1201...1300:\n                return 13\n            case 1301...1400:\n                return 14\n            case 1401...1500:\n                return 15\n            case 1501...1600:\n                 return 16\n             case 1601...1700:\n                 return 17\n             case 1701...1800:\n                 return 18\n             case 1801...1900:\n                 return 19\n            case 1901...2000:\n                return 20\n            case 2001...2100:\n                return 21\n            case 2101...2200:\n                 return 22\n            case 2201...2300:\n                return 23\n            case 2301...2400:\n                return 24\n            case 2401...2500:\n                return 25\n            case 2501...2600:\n                return 26\n            case 2601...2700:\n                 return 27\n            case 2701...2800:\n                return 28\n            case 2801...2900:\n                return 29\n            case 2901...3000:\n                return 30\n            \n            default:\n                return 0\n        }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342366,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n    return Int(ceil(Double(year)\/100.0))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342367,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n  (year - 1 + 100) \/ 100\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342368,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n       if year % 100 == 0{\n    let a = year \/ 100\n    return a\n    } else{\n        let a = year \/ 100 + 1 \n        return a\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342369,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n    Int((Double(year) \/ 100).rounded(.up))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342370,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n\n    let century_from_year = Int((year - 1) \/ 100) + 1\n    return century_from_year\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342371,"user_id":null,"body":"func century_from_year(_ year: Int) -> Int {\n  if year % 100 == 0 {\n        return Int(Double(year) \/ 100)\n    } else {\n        return Int(Double(year) \/ 100) + 1\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a48948e145c46820b00002f":[{"id":342372,"user_id":492,"body":"func primeFactors(_ n: Int) -> Int {\n    var nb = n\n    var i = 2\n    var cnt = 0\n    while nb > 1 {\n        while nb % i == 0 {\n            cnt += 1\n            nb \/= i\n        }\n        i += 1\n    }\n    return cnt\n}\nfunc kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n    var res = [(Int, Int)]()\n    var i = m\n    while i <= n - step {\n        if primeFactors(i) == k && primeFactors(i + step) == k {\n            res.append((i, i + step))\n        }\n        i += 1\n    }\n    if res.count == 0 {return nil} else {return res};\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342373,"user_id":null,"body":"func findCountOfFactor(_ number: Int) -> Int {\n    guard number != 0 else { return 0 }\n    var n = number, ret = 0\n    while n.isMultiple(of: 2) {\n        ret += 1\n        n \/= 2\n    }\n    var i = 3\n    while Double(i) <= sqrt(Double(n)) {\n        while n.isMultiple(of: i) {\n            ret += 1\n            n \/= i\n        }\n        i += 2\n    }\n    if n > 2 {\n        ret += 1\n    }\n    return ret\n}\n\nfunc kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]?{\n    let arr = (m...n).filter{ findCountOfFactor($0) == k }\n    var ret = [(Int, Int)]()\n    (1..<arr.count).map{\n        if arr.contains(arr[$0] - step) {\n            ret.append((arr[$0] - step, arr[$0]))\n        }\n    }\n    return ret.isEmpty ? nil : ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342374,"user_id":17,"body":"func kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n  let kOf: (Int) -> Int = { (_ n: Int) -> Int in\n    var k: Int = 0, m: Int = n\n    while m % 2 == 0 {\n      m \/= 2\n      k += 1\n    }\n    for i in 3...Int(Double(n).squareRoot()) {\n      while m % i == 0 {\n        m \/= i\n        k += 1\n      }\n    }\n    if m != 1 {\n      k += 1\n    }\n    return k\n  }\n  var result: [(Int, Int)] = []\n  for i in m...(n - step) {\n    if kOf(i) == k && kOf(i + step) == k {\n      result.append((i, i + step))\n    }\n  }\n  return result.count == 0 ? nil : result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342375,"user_id":null,"body":"\nfunc eratos(_ num : Int) -> Int {\n    var n = num\n    var div = Int(2)\n    var count = Int(0)\n    while n > 1 {\n        while n % div == 0 {\n            count = count + 1\n            n = n \/ div\n        }\n        div = div + 1\n    }\n    return count\n}\n\nfunc searchNumber(_ num : Int, _ arr : [Int]) -> Bool {\n    for i in arr {\n        if i == num {\n            return true\n        }\n    }\n    return false\n}\n\nfunc kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n    var arr = [Int]()\n    var cort = [(Int, Int)]()\n    for i in m...n {\n        if eratos(i) == k {\n            arr.append(i)\n        }\n    }\n    for i in arr {\n        if searchNumber(i + step, arr) {\n            cort.append((i, i + step))\n        }\n    }\n    if cort.isEmpty {\n        return nil\n    }\n    return cort\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342376,"user_id":null,"body":"func kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n  \n  var flags = Array(repeating: true, count: n)\n  flags[0] = false\n  flags[1] = false\n  \n  var i = 0\n  while i < n {\n    if flags[i] {\n      var j = i * 2\n      while j < n {\n        flags[j] = false\n        j += i\n      } \n    }\n    i += 1\n  }\n  \n  let primes = flags\n    .enumerated()\n    .filter { $0.1 }\n    .map { $0.0 }\n  \n  let kprimes = (m...n).filter { d in\n    var r = d\n    var c = 0\n\n    while (r != 1) && (c != k) {\n      guard let s = primes.first(where: { r % $0 == 0 }) else { break }\n      r \/= s\n      c += 1\n    }\n\n    return (r == 1) && (c == k)\n  }\n  \n  let pairs = kprimes\n    .filter { kprimes.contains($0 + step) }\n    .map{ ($0, $0 + step) }\n  \n  return pairs.isEmpty ? nil : pairs\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342377,"user_id":null,"body":"func kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n  var kprimes = [Int]()\n  var output = [(Int, Int)]()\n  for i in m...n {\n    if findFactors(i) == k {\n        kprimes.append(i)\n    }\n  }\n  for j in 0..<kprimes.count {\n    for k in 0..<kprimes.count {\n      if abs(kprimes[j] - kprimes[k]) == step {\n        if k > j {\n          output.append((kprimes[j], kprimes[k]))\n        }\n      }\n    }\n  }\n  if output.isEmpty {\n    return nil\n  }\n  return output\n}\n\nfunc findFactors(_ n: Int) -> Int {\n    var count = 0\n    var n = n\n    while n % 2 == 0 {\n        n = (n \/ 2)\n        count += 1\n    }\n    var i = 3\n    while i * i <= n {\n        while n % i == 0 {\n            n = n \/ i\n            count += 1\n        }\n        i += 2\n    }\n    if n > 2 {\n        count += 1\n    }\n    return count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342378,"user_id":null,"body":"func isSemiprime(_ number:Int) -> Int {\n    guard number >= 2 else {\n        return 0\n    }\n    var bufNumber = number\n    var count = 0\n    for i in 2..<Int(sqrt(Double(number))+1) {\n        while bufNumber.isMultiple(of: i) {\n            bufNumber \/= i\n            count += 1\n        }\n    }\n    if bufNumber != 1 {\n        count += 1\n    }\n    return count\n}\nfunc kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n    var result = [(Int,Int)]()\n    for i in m...n - step {\n        if isSemiprime(i) == k && isSemiprime(i + step) == k {\n            result.append((i, i + step))\n        }\n    }\n    return result.isEmpty ? nil : result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342379,"user_id":null,"body":"import Foundation\n\nfunc kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n  var kprimes : [Int] = []\n    for i in m...n {\n        if primeFactorsCount(i) == k {\n            kprimes.append(i)\n        }\n    }\n    \n    var result : [(Int, Int)] = []\n    for i in 0..<kprimes.count {\n        for j in i..<kprimes.count {\n            if kprimes[j] - kprimes[i] == step {\n                result.append((kprimes[i], kprimes[j]))\n            }\n        }\n    }\n    \n    return result.isEmpty ? nil : result\n}\n\nfunc primeFactorsCount(_ number: Int) -> Int {\n    var k = 0\n    var n = number\n    while (n % 2 == 0) {\n        k += 1\n        n \/= 2\n    }\n  \n    for i in stride(from: 3, to: Int(sqrt(Double(n))), by: 2) {\n        while (n % i == 0) {\n            k += 1\n            n \/= i\n        }\n    }\n    \n    if (n > 2) {\n        k += 1\n    }\n    return k\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342380,"user_id":53,"body":"func kprimesStep(_ k: Int, _ step: Int, _ start: Int, _ nd: Int) -> [(Int, Int)]? {\n    var arr: [(Int, Int)] = [];\n    var i = start;\n    while (i <= nd - step) {\n        if (primeFactorCount(i) == k && primeFactorCount(i + step) == k) {\n            arr.append((i, i + step));\n        }\n        i = i + 1;\n    }\n    if (arr.count == 0) {\n        return Optional.none;\n    }\n    return Optional.some(arr);\n}\n\nfunc primeFactorCount(_ m: Int) -> Int {\n    var len = 0;\n    var n = m;\n    var i = 2;\n    while (i * i <= n) {\n        while (n % i == 0) {\n            len = len + 1;\n            n = n \/ i;\n        }\n        i = i + 1;\n    }\n    if (n > 1) {\n        len = len + 1;\n    }\n    return len;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342381,"user_id":null,"body":"var primes = [2]\n\nfunc isPrime(_ n:Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    if n == 2 || n == 3 {\n        return true\n    }\n    if n % 6 != 1 && n % 6 != 5 {\n        return false\n    }\n    for i in 2...Int(sqrt(Double(n))) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc kprimesStep(_ k: Int, _ step: Int, _ m: Int, _ n: Int) -> [(Int, Int)]? {\n    var array:[(Int, Int)] = []\n    var kprimes:[Int] = []\n    for i in m...n {\n        var i = i\n        let i1 = i\n        var primeIndex = 0\n        var c = 0\n        while i > 1 {\n            if c > k {\n                break\n            }\n            if isPrime(i) {\n                c += 1\n                break\n            }\n            for _ in 0..<max(0, primeIndex - primes.count + 1) {\n                var p1 = primes.last! + 1\n                while !isPrime(p1) {\n                    p1 += 1\n                }\n                primes.append(p1)\n            }\n            let p = primes[primeIndex]\n            while i != 1 && i % p == 0 {\n                i \/= p\n                c += 1\n                if c > k {\n                    break\n                }\n            }\n            primeIndex += 1\n        }\n        if c == k {\n            kprimes.append(i1)\n            var j = kprimes.count - 1\n            while j >= 0 {\n                let n = i1 - kprimes[j]\n                if n > step {\n                    break\n                }\n                if n == step {\n                    array.append((kprimes[j], i1))\n                    break\n                }\n                j -= 1\n            }\n        } \n    }\n    return array.isEmpty ? nil : array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a4d303f880385399b000001":[{"id":342382,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n  return String(number).map({ fac(Int(String($0))!) }).reduce(0, +) == number ? \"STRONG!!!!\" : \"Not Strong !!\"\n}\n\nfunc fac(_ number: Int) -> Int {\n  guard number > 1 else { return 1 }\n  return number * fac(number-1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342383,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n    let string = \"\\(number)\".map { stride(from: 1, to: Int(\"\\($0)\")! + 1, by: 1).map({$0}).reduce(1, *) }.reduce(0, +)\n    return string == number ? \"STRONG!!!!\" : \"Not Strong !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342384,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n  \/\/Do Some Magic\n   let intArray = String(number).map({ Int(String($0))! })\n  var sum = 0\n  for num in intArray {\n     var a = 1\n     if num == 0 {\n         a = 1\n     }else{\n         for i in 1...num {\n           a *= i\n         }\n     }  \n     sum += a\n  }\n  return sum == number ? \"STRONG!!!!\" : \"Not Strong !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342385,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n  let factorial = String(number)\n    .compactMap { Int(String($0)) }\n    .filter { $0 > 0 }\n    .reduce(0) { $0 + (1...$1).reduce(1, *) }\n  return number == factorial ? \"STRONG!!!!\" : \"Not Strong !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342386,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\nlet factorial = String(number).compactMap { $0.wholeNumberValue ?? 0 }.filter { $0 > 0 }.reduce(0) { $0 + (1...$1).reduce(1, *)}\n    return factorial != number ? \"Not Strong !!\" : \"STRONG!!!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342387,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n    let result = String(number).reduce(0) { result, next in\n        var factorial = 1\n        var num = next.wholeNumberValue!\n        while(num != 0) {\n            factorial *= num\n            num -= 1\n        }\n        return result + factorial\n    }\n    return result == number ? \"STRONG!!!!\" : \"Not Strong !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342388,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n  let numberFactorialSum = String(number).compactMap { Int(String($0)) }.reduce(0) { $0 + factorial($1) }\n  return numberFactorialSum == number ? \"STRONG!!!!\" : \"Not Strong !!\"\n}\n\nprivate func factorial(_ num: Int) -> Int {\n    guard num != 0 else { return 1 }\n    return (1...num).reduce(1, { $0 * $1 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342389,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n    func factorial(_ n: Int) -> Int {\n        if n == 0 {\n            return 1\n        }\n        var a = 1\n        for i in 1...n {\n            a *= i\n        }\n        return a\n    }\n\n    let arrayOfNumber = String(number).compactMap { $0.wholeNumberValue }\n    var res = [Int]()\n    for i in arrayOfNumber {\n        res.append(factorial(i))\n    }\n    let reduceInt = res.reduce(0, +)\n    \n  \n    return number == reduceInt ? \"STRONG!!!!\" : \"Not Strong !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342390,"user_id":null,"body":"func strongNumber(_ number: Int) -> String {\n  \/\/Do Some Magic\n  var sum = 0\n  for digit in String(number){\n    var intDigit = Int(String(digit))! \n    var factorialValue = getFactorial(intDigit)\n    sum += factorialValue\n  }\n  if sum == number {\n    return \"STRONG!!!!\"\n  }else{\n    return \"Not Strong !!\"\n  }\n}\nfunc getFactorial(_ number:Int) -> Int{\n  var sum = 1\n  for i in stride(from: 1, through: number, by: 1){\n    sum = sum * i\n  }\n  return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342391,"user_id":null,"body":"extension Int {\n    \n    func factorial(n: Int) -> Int {\n        var result = 1\n        if(n > 0) {\n            for i in 1...n {\n                result *= i\n            }\n        }\n        return result\n    }\n    \n    func isStrong() -> String {\n        var sum = 0\n        var num = self\n        if self > 9 {\n            for _ in 1..<String(self).count {\n                sum += factorial(n: num%10)\n                num \/= 10\n            }\n        }\n        sum += factorial(n: num%10)\n        if sum == self {\n            return \"STRONG!!!!\"\n        }\n        return \"Not Strong !!\"\n    }\n}\n\nfunc strongNumber(_ number: Int) -> String {\n    return number.isStrong()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a4e3782880385ba68000018":[{"id":342392,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n  \n  let digitCount = String(number).count\n  let numberOfElementsToCompare: Int = digitCount % 2 == 0 ? (digitCount \/ 2) - 1 : digitCount \/ 2\n  let intArray = String(number).map{Int(String($0))!}\n  let firstHalf = intArray.prefix(numberOfElementsToCompare).reduce(0,+)\n  let secondHalf = intArray.suffix(numberOfElementsToCompare).reduce(0,+)\n  \n  return firstHalf == secondHalf ? \"Balanced\" : \"Not Balanced\"\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342393,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n  let n = String(number).map({ Int(String($0))! })\n  guard n.count > 2 else { return \"Balanced\" }\n  let fn = Array(n[0 ..< n.count\/2-(n.count%2 == 0 ? 1 : 0)]).reduce(0, +)\n  let ln = Array(n[n.count\/2+1 ..< n.count]).reduce(0,+)\n  return (fn != ln ? \"Not \" : \"\") + \"Balanced\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342394,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n  let digits = String(number).compactMap{$0.wholeNumberValue }\n  let part1 = digits.dropLast (digits.count\/2 + 1).reduce(0,+)\n  let part2 = digits.dropFirst(digits.count\/2 + 1).reduce(0,+)\n return part1 == part2 ? \"Balanced\" : \"Not Balanced\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342395,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n    var numArr = String(number).compactMap { (char) -> Int in Int(String(char))! }\n    if numArr.count%2 != 0 {\n        numArr.remove(at: numArr.count\/2)\n    }else {\n        numArr.remove(at: numArr.count\/2)\n        numArr.remove(at: numArr.count\/2)\n    }\n    return getTotal(for: Array(numArr[0..<numArr.count\/2])) == getTotal(for: Array(numArr[numArr.count\/2..<numArr.count])) ? \"Balanced\" : \"Not Balanced\"\n}\n\nfunc getTotal(for arr: [Int]) -> Int { return arr.reduce(0, +) }","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342396,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n  \/\/count no. of digits\n  let numAsStr = String(number)\n  let numLen = Int(numAsStr.count)\n  var front:String = \"\"\n  var back:String = \"\"\n  \n  \/\/get first and second half of the relevant parts\n  front = String(numAsStr.dropLast((numLen\/2)+1))\n  back = String(numAsStr.dropFirst((numLen\/2)+1))\n  \n  let lettersFront = Array(front)\n  let lettersBack = Array(back)\n  \n  \/\/calculate checksum of both parts\n  var checksumFront = 0\n  var checksumBack = 0\n  for digit in lettersFront {\n    checksumFront += Int(String(digit)) ?? 0  \n  }\n  for digit in lettersBack {\n    checksumBack += Int(String(digit)) ?? 0\n  }\n  \/\/compare checksums and return the result string\n  if checksumBack == checksumFront {\n    return \"Balanced\"\n  }\n  else {\n    return \"Not Balanced\"\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342397,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n    let numStr = String(describing: number).compactMap {Int(String($0))}\n    var (A,B) = (0,0)\n    \n    if numStr.count > 2 {\n        let leftEndIndex: Int = numStr.count % 2 == 0 ? numStr.count\/2 - 2 : numStr.count\/2 - 1\n        let rightStartIndex: Int = numStr.count\/2 + 1\n        \n        for i in 0...leftEndIndex {\n            A += numStr[i]\n        }\n        for i in rightStartIndex..<numStr.count {\n            B += numStr[i]\n        }\n    }\n    \n    return A == B ? \"Balanced\" : \"Not Balanced\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342398,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n  \/\/Do Some Magic\n  let intToString = String(number)\n    let stringCount = intToString.count\n    if stringCount == 1 || stringCount == 2 {\n        return \"Balanced\"\n    }\n    var firstArray = [Int]()\n    for item in intToString {\n        if let number = Int(String(item)) {\n            firstArray.append(number)\n        }\n    }\n    if stringCount % 2 == 1 {\n        let firstSumArray = firstArray[0...stringCount\/2]\n        let secondSumArray = firstArray[stringCount\/2...firstArray.count-1]\n        let firstSum = firstSumArray.reduce(0, +)\n        let secondSum = secondSumArray.reduce(0, +)\n        \n        if firstSum == secondSum {\n            return \"Balanced\"\n        }else {\n            return \"Not Balanced\"\n        }\n    }\n    \n    let evenDiff = (stringCount \/ 2) - 2\n    let backEvenDiff = (stringCount \/ 2) + 1\n    let firstEvenArray = firstArray[0...evenDiff]\n    let secondEvenArray = firstArray[backEvenDiff...firstArray.count-1]\n    let firstSum = firstEvenArray.reduce(0, +)\n    let secondSum = secondEvenArray.reduce(0, +)\n    \n    return firstSum == secondSum ? \"Balanced\" : \"Not Balanced\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342399,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\nlet digits = String(number).compactMap{Int(String($0))}\nswitch digits.count {\n  case 1, 2:\n    return \"Balanced\"\n  default:    \n    let c = digits.count%2 == 0 ? (digits.count - 2) \/ 2 : (digits.count - 1) \/ 2    \n    var leftArray = [Int]()\n    var rightArray = [Int]()    \n    for i in 0...(c-1) {\n        leftArray.append(digits[i])\n    }\n    for i in 0...(c-1) {\n        rightArray.append(digits[(digits.count - 1) - i])\n    }\n    let sumLeft = leftArray.reduce(0, +)\n    let sumRight = rightArray.reduce(0, +)\n    let result = sumLeft == sumRight ? \"Balanced\" : \"Not Balanced\"\n    return result\n}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342400,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n\n  let digits = String(number).compactMap{ $0.wholeNumberValue }\n\n  var left = 0\n  var right = 0\n\n        if digits.count % 2 == 0{\n            let findMidSecond = digits.count\/2\n            let findMidFirst = findMidSecond - 1\n\n            for i in 0 ..< findMidFirst  { left += digits[i]}\n            \n            for i in (findMidSecond+1) ..< digits.endIndex{ right += digits[i]}\n            \n           return left == right ? \"Balanced\": \"Not Balanced\"\n            \n        }else{\n            \n            let findMid = digits.count\/2\n            \n            for i in 0 ..< findMid{ left += digits[i] }\n            \n            for i in (findMid+1) ..< digits.endIndex{ right += digits[i]}\n            \n            return left == right ? \"Balanced\": \"Not Balanced\"\n        }}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342401,"user_id":null,"body":"func balancedNumber(_ number: Int) -> String {\n  let digits = String(number).count\n  if digits == 1 || digits == 2 { return \"Balanced\" }\n\n  var digitsToSum = 0\n  if digits.isMultiple(of: 2) {\n    digitsToSum = (digits - 2) \/ 2\n  } else {\n    digitsToSum = (digits - 1) \/ 2\n  }\n\n  let arr = String(number).compactMap { Int(\"\\($0)\") }\n\n  if Array(arr.prefix(digitsToSum)).reduce(0, +) == Array(arr.suffix(digitsToSum)).reduce(0, +) {\n    return \"Balanced\"\n  } else {\n    return \"Not Balanced\"\n  }\n  \n  \n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a53a17bfd56cb9c14000003":[{"id":342402,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n    let numberArr = String(number).compactMap { Int(String($0)) }\n    let ret = numberArr.enumerated().map { (i, n) in Int(pow(Double(n), Double(i + 1))) }.reduce(0, +)\n    return ret == number ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342403,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n    let numberArray: Array = String(number).compactMap { Double(String($0)) }\n    var final = 0.0\n    var i = 1.0\n    \n    for digit in numberArray {\n        final += pow(digit, i)\n        i += 1\n    }\n    \n    if Int(final) == number {\n        return (\"Disarium !!\")\n    }\n    else {\n        return(\"Not !!\")\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342404,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n    var res = 0.0\n    for (idx, char) in String(number).enumerated() { res += pow(Double(String(char))!, Double(idx) + 1) }\n    \n    return Int(res) == number ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342405,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n  return String(number).enumerated().reduce(0) { result, x in\n    result + Int(Double(String(x.element)).map { pow($0, Double(x.offset + 1)) } ?? 0)\n  } == number ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342406,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n  let array = String(number).map { $0.wholeNumberValue ?? 0 }\n  let disarium = array.enumerated().map { Int(pow(Double($0.element), Double($0.offset + 1))) }.reduce(0, +)\n  return disarium == number ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342407,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n\n  var s = String(number).compactMap{$0.wholeNumberValue}\n  for i in 0..<s.count {\n      s[i] = Int(pow(Double(s[i]), Double(i+1)))\n  }\n    return s.reduce(0, +) == number ? \"Disarium !!\" : \"Not !!\"\n  \n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342408,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n    func getPower(_ base: Int, _ power: Int) -> Int {\n        var answer : Int = 1\n        for _ in 0..<power {\n            answer *= base\n        }\n        return answer\n    }\n    let numberConverted = String(number)\n    var counter = 0\n    var sum = 0\n    \n    for item in numberConverted {\n        counter = counter + 1\n        let convToNum = Int(String(item))!\n        let itemexpResult = getPower(convToNum, counter)\n        sum += itemexpResult\n    }\n    return sum == number ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342409,"user_id":1118,"body":"func disariumNumber(_ number: Int) -> String {\n  return String(number).compactMap { $0.wholeNumberValue }.enumerated().map { pow(Double($1), Double($0 + 1)) }.reduce(0,+) == Double(number) ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342410,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n  number == String(number).enumerated().reduce(0) { $0 + Int(pow(Double($1.1.wholeNumberValue!), Double($1.0+1)))} ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342411,"user_id":null,"body":"func disariumNumber(_ number: Int) -> String {\n    var sum = 0\n    let array = Array(String(number))\n    for i in 0..<array.count {\n        let num = pow(Double(String(array[i]))!, Double(i+1))\n        sum = sum + Int(num)\n    }\n    return number == sum ? \"Disarium !!\" : \"Not !!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a54e796b3bfa8932c0000ed":[{"id":342412,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n  let numbers = String(number).compactMap { c in c.wholeNumberValue };\n  for i in 1..<numbers.count {\n      if abs(numbers[i - 1] - numbers[i]) != 1 {\n          return \"Not!!\";\n      }\n  }\n  return \"Jumping!!\";\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342413,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    let digits = String(number).compactMap{$0.wholeNumberValue}\n    for (d1, d2) in zip(digits[...], digits[1...]) {\n        if abs(d1 - d2) != 1 {\n            return \"Not!!\"\n        }\n    }\n    return \"Jumping!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342414,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n  if number<10 { return \"Jumping!!\" }\n  var num=number\n  while num>10 {\n    let pair=Int(num%100)\n    let a=Int(pair\/10); let b=Int(pair%10)\n    if abs(a-b) != 1 { return \"Not!!\" }\n    num=Int(num\/10)\n  }\n  return \"Jumping!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342415,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    var numStr = String(number)\n    var pre = numStr.removeFirst()\n    return numStr.contains { (char) in\n        let comp = Int(String(pre))!\n        pre = char\n    return comp + 1 != Int(String(pre))! && comp - 1 != Int(String(pre))! } ? \"Not!!\" : \"Jumping!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342416,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    guard number > 9 else { return \"Jumping!!\" }\n    let numberArr = String(number).compactMap { Int(String($0)) }\n    let numberArrZipped = zip(numberArr, numberArr[1...])\n    for (x, y) in numberArrZipped {\n        if abs(x - y) != 1 { return \"Not!!\" }\n    }\n    return \"Jumping!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342417,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    guard number > 10 else { return \"Jumping!!\" }\n    let arr = String(number).compactMap { $0.wholeNumberValue }\n    \n    return arr\n        .enumerated()\n        .filter { (index, element) -> Bool in\n            let curr = arr[index]\n            let next = (index < arr.count - 1) ? arr[index + 1] : arr[index - 1]\n        \n            if next == curr + 1 || next == curr - 1 {\n                return true\n            }\n\n            return false\n        }\n        .compactMap { $1 } == arr ? \"Jumping!!\" : \"Not!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342418,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    var numStr = String(number)\n    var pre = numStr.removeFirst()\n    for char in numStr {\n        if (Int(String(pre))! + 1 != Int(String(char))!) && (Int(String(pre))! - 1 != Int(String(char))!) {return \"Not!!\"}\n        pre = char\n    }\n    return \"Jumping!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342419,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    guard number > 10 else { return \"Jumping!!\" }\n    let array = String(number).compactMap{ $0.wholeNumberValue }\n    let zipArr = zip(array.dropFirst(), array).map(-).filter { $0 != 1 && $0 != -1}\n    return zipArr.isEmpty ? \"Jumping!!\" : \"Not!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342420,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n  var buff: Int = 0\n  var ost: Int = 0\n  var correct_num: Int = number\n  var bool: Bool = true\n  while correct_num != 0\n  {\n    buff = correct_num % 10\n    ost = correct_num \/ 10 % 10\n    correct_num = correct_num \/ 10\n    if correct_num != 0{\n        if ost - 1 == buff || ost + 1 == buff {\n            bool = true\n            }\n        else {bool = false\n        break }\n      }\n    }\n  return bool ? \"Jumping!!\" : \"Not!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342421,"user_id":null,"body":"func jumpingNumber(_ number: Int) -> String {\n    let array = String(number).digits\n    let check = array.reduce(array.first! - 1) { abs($0 - $1) == 1 ? $1 : -10  }\n    return check > 0 ? \"Jumping!!\" : \"Not!!\"\n}\n\nextension StringProtocol  {\n    var digits: [Int] { compactMap(\\.wholeNumberValue) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a55f04be6be383a50000187":[{"id":342422,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n  return String(number).filter { $0.wholeNumberValue! > 5 }.count == 0 ? \"Special!!\" : \"NOT!!\";\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342423,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n    let numArray = String(number).map { $0.wholeNumberValue! }\n    return numArray.contains { $0 > 5 } ? \"NOT!!\" : \"Special!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342424,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n    String(number) == String(number).filter { \"012345\".contains($0) } ? \"Special!!\" : \"NOT!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342425,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n  let numberConverted = String(number)\n    var counterYes = 0\n    var counterNo = 0\n    for item in numberConverted {\n        let conv = Int(String(item))!\n        if conv == 0 || conv == 1 || conv == 2 || conv == 3 || conv == 4 || conv == 5{\n            counterYes = counterYes + 1\n        }else {\n            counterNo = counterNo + 1\n        }\n    }\n    return counterNo > 0 ? \"NOT!!\" : \"Special!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342426,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n  let strnum :String = String(number)\n  for digit in strnum {\n    if digit > \"5\" {\n      return \"NOT!!\"\n    }\n  }\n  return \"Special!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342427,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n  return number.description.map { $0.wholeNumberValue! }.filter { $0 > 5 }.count == 0 ? \"Special!!\" : \"NOT!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342428,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n    let array = Array(String(number)).map({ String($0) })\n    let notSpecial = [\"6\", \"7\", \"8\", \"9\"].map({ array.contains($0)})\n    let isSpecial = notSpecial.contains(true) ? \"NOT!!\" : \"Special!!\"\n    return isSpecial\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342429,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n    let str = String(number)\n    for i in str {\n        if i > \"5\" { return(\"NOT!!\") }\n    }\n return(\"Special!!\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342430,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n  \/\/ Do Some Magic\n  return (!String(number).contains(where: { ![\"0\",\"1\",\"2\",\"3\",\"4\",\"5\"].contains($0) }) ? \"Special!!\" : \"NOT!!\");    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342431,"user_id":null,"body":"func specialNumber(_ number: Int) -> String {\n  var array = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"]\n  for char in String(number) {\n    if array.contains(String(char)) {\n      continue\n    } else {\n      return \"NOT!!\"\n    }\n  }\n  return \"Special!!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a58ca28e626c55ae000018a":[{"id":342432,"user_id":17,"body":"import Foundation;\n\nfunc areaOfPolygonInsideCircle(_ r: Double, _ n: Int) -> Double {\n  return (1e3 * (0.5 * Double(n) * r * r * sin(2 * Double.pi \/ Double(n)))).rounded() \/ 1e3\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342433,"user_id":null,"body":"func areaOfPolygonInsideCircle(_ r: Double, _ n: Int) -> Double {\n  return round((0.5 * Double(n) * r * r * sin(2.0 * Double.pi \/ Double(n))) * 1000) \/ 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342434,"user_id":null,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n    let n = Double(numberOfSides)\n    let sinus = sin((2.0 * .pi) \/ n)\n    let area = (n * circleRadius * circleRadius * sinus) \/ 2\n    return round(area * 1000) \/ 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342435,"user_id":null,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n  var s = 0.0\n  s = (Double(numberOfSides) \/ 2) * circleRadius * circleRadius * sin(2 * Double.pi \/ Double(numberOfSides))\n  return Double(String(format: \"%.3f\", s))!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342436,"user_id":null,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n  let n: Double = Double(numberOfSides)\n  let angle = 360 \/ n\n  \n  return ((n * pow(circleRadius, 2.0) * sin(angle * Double.pi \/ 180) \/ 2) * 1000).rounded() \/ 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342437,"user_id":null,"body":"func areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n  let r = circleRadius\n  let n = Double(numberOfSides)\n  let pi = Double.pi\n  let area = n * r * r * sin((2 * pi) \/ n) \/ 2\n  return round(area * 1000) \/ 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342438,"user_id":null,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n    let value =  (Double(numberOfSides) * circleRadius * circleRadius * sin(2 * Double.pi \/ Double(numberOfSides))) \/ 2\n    return round(value * 1000) \/ 1000.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342439,"user_id":null,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n    let pi: Double = 3.14159265358979\n    var result: Double = 0\n    \n    if circleRadius > 0 && numberOfSides > 0 {\n        result =  0.5 * Double(numberOfSides) * pow(circleRadius, 2) * sin(2 * pi \/ Double(numberOfSides))\n        result = (result * 1000).rounded() \/ 1000\n    }\n    \n    return Double(String(format: \"%.3f\", result )) ?? 0.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342440,"user_id":null,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ circleRadius: Double, _ numberOfSides: Int) -> Double {\n  let pi = Double.pi\n  let n = Double(numberOfSides)\n  let result = (n \/ 2) * pow(circleRadius,2) * sin(2*pi\/n)\n  return round(result * 1000) \/ 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342441,"user_id":50,"body":"import Foundation;\n\/\/Use Double.pi for the mathematical value of pi in your calculations if necessary.\n\nfunc areaOfPolygonInsideCircle(_ r: Double, _ e: Int) -> Double {\n  let n = Double(e)\n  return round(n * r * r * sin(2 * Double.pi \/ n) * 500) \/ 1000\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a662a02e626c54e87000123":[{"id":342442,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n  return (1...n).filter { $0 % 2 == 1 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342443,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n  return Array(stride(from: 1, through: n, by: 2));\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342444,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n\n   let ArrayAnswer = [Int](stride(from: 1, to: n+1, by: 2))\n    \n    return ArrayAnswer ;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342445,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n    return Array(stride(from: 1, to: n + 1, by: 2))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342446,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n  let result = (1...n).filter { (num) -> Bool in\n        let binary = String(num, radix: 2, uppercase: false)\n        return binary.first == binary.last\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342447,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n  (0...n).filter({$0 % 2 != 0 })\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342448,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n    let result = Array(1...n).filter {\n        let array = Array(String($0, radix: 2))\n        return array.first == \"1\" && array.last == \"1\"\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342449,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n  (0..<(n + 1) \/ 2).enumerated().map { 1 + 2 * $0.element }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342450,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n  Array<Int>.init(1...n).filter { !$0.isMultiple(of: 2) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342451,"user_id":null,"body":"func extraPerfect(_ n: Int) -> [Int] {\n    var arr: [Int] = []\n    \n    for i in 0...n {\n        if i % 2 == 1 {\n            arr.append(i)\n        }\n        \n    }\n    return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a99a03e4a6b34bb3c000124":[{"id":342452,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n    var n = 2\n    var primes = [UInt]()\n    \n    while primes.count < number {\n        if primes.allSatisfy({ n % Int($0) != 0 }) {\n            primes.append(UInt(n))\n        }\n        \n        n += 1\n    }\n    \n    return primes.reduce(1, *)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342453,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n    let arrOfPrime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]\n    return UInt(arrOfPrime.prefix(Int(number)).reduce(1, *))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342454,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n  var primeDig: UInt = 3\n  var count = 1\n  var multiplier: UInt = 2\n  while(count < number){\n    for n in 2..<primeDig{\n      if(primeDig%n == 0){\n        break;\n      }else if(n == primeDig-1){\n        multiplier *= primeDig\n        count += 1\n      }\n    }\n    primeDig += 1\n  }\n  return multiplier\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342455,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\nvar primeNumbers = [Int](), num = 2\n    while primeNumbers.count < number {\n        if isPrimeNumber(num) { primeNumbers += [num] }\n        num += 1\n    }\n    return UInt(primeNumbers.reduce(1, *))\n}\n\nfunc isPrimeNumber(_ n: Int) -> Bool {\n    guard n >= 2     else { return false }\n    guard n != 2     else { return true  }\n    guard n % 2 != 0 else { return false }\n    return !stride(from: 3, through: Int(sqrt(Double(n))), by: 2).contains { n % $0 == 0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342456,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n var massPrimorialNumm: [Int] = []\n var i = 2\n var result: Int = 1\n repeat {\n   if isPrime(i) {\n       massPrimorialNumm.append(i) \n    }\n    i += 1\n } while massPrimorialNumm.count < number\n\nfor i in massPrimorialNumm {\n  result *= i\n}\n return UInt(result)\n}\n\nfunc isPrime(_ number: Int) -> Bool {\nreturn number > 1 && !(2..<number).contains { number % $0 == 0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342457,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n    var primes = [UInt]()\n    var i: UInt = 2\n    while primes.count < number {\n        if isPrime(i) {\n            primes.append(i)\n        }\n        i += 1\n    }\n    \n    print(primes)\n    \n    return primes.reduce(1, *)\n}\n\n\nfunc isPrime(_ number: UInt) -> Bool {\n    let number = Int(number)\n    guard number >= 2     else { return false }\n    guard number != 2     else { return true  }\n    guard number % 2 != 0 else { return false }\n    \n    var i = 3;\n    \n    while i <= Int(sqrt(Double(number)))  {\n        if number % i == 0 {\n            return false\n        }\n        i += 1\n    }\n    \n    return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342458,"user_id":null,"body":"func isPrime(_ number: UInt) -> Bool {\n    return number > 1 && !(2..<number).contains { number % $0 == 0 }\n}\n\nfunc numPrimoral( _ number: UInt ) -> UInt {\n    var i = 0\n    var count: UInt = 0\n    var res :UInt = 1\n    while i != number {\n        if ( isPrime(count)){\n            res *= count\n             i += 1\n        }\n        count += 1\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342459,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n    func isPrime(_ n: Int) -> Bool {\n        guard n >= 2 else { return false }\n        guard n != 2 else { return true }\n        guard n % 2 != 0 else { return false }\n        return !stride(from: 3, through: Int(sqrt(Double(n))), by: 2).contains { n % $0 == 0 }\n    }\n    \n    var primes: [Int] = []\n    var testPrime = 2\n    \n    while primes.count < Int(number) {\n        if isPrime(testPrime) {\n            primes.append(testPrime)\n        }\n        testPrime += 1\n    }\n    return UInt(primes.reduce(1, *))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342460,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n    return primesGet(number: number).reduce(1,*)\n}\nfunc primesGet(number: UInt) -> [UInt] {\n    var primes:[UInt] = []\n    \n    for n in 2... {\n        if isPrime(number: UInt(n)) {\n            primes.append(UInt(n))\n        }\n        if primes.count == Int(number){\n            return primes\n        }\n    }\n    return [1]\n}\nfunc isPrime(number: UInt) -> Bool {\n    if number <= 3 && number != 0 {\n        return true\n    }\n    var i = 2\n    while i*i <= number {\n        if Int(number) % i == 0 {\n            return false\n        }\n        i+=1\n    }\n    return true\n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342461,"user_id":null,"body":"func numPrimoral( _ number: UInt ) -> UInt {\n  let simple = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181]\n  var result = 1\n  for each in 0..<number{\n    result *= simple[Int(each)]\n}\n  return UInt(result)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5a9c35e9ba1bb5c54a0001ac":[{"id":342462,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n  return y == 0 ? x : add( x ^ y, (x & y) << 1);\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342463,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n    if y == 0 {\n        return x\n    } else {\n        return add( x ^ y, (x & y) << 1)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342464,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n    x.advanced(by: y)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342465,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n  y == 0 ? x : add(x^y,(x&y)<<1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342466,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n    var x = x\n    var y = y\n    \n    while y != 0 {\n        let carry = x & y\n        x = x ^ y\n        y = carry << 1\n    }\n    \n    return x;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342467,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n    \/\/ Favorite not using \"plus\" or \"minus\" operator.\n    return x.advanced(by: y)\n    \n    \/\/ Another option:\n\/\/     let (partialValue, overflow) = x.addingReportingOverflow(y)\n\/\/     return partialValue\n    \n    \/\/ Bitwise operations:\n\/\/     var (a, b) = (x, y)\n\/\/     var carry: Int\n\/\/     while b != 0 {\n\/\/         \/\/print(a, b)\n\/\/         carry = a & b\n\/\/         a = a ^ b\n\/\/         b = carry << 1\n\/\/     }\n\/\/     return a;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342468,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n  guard x != y else { return 2 * x }\n  guard (abs(x) != abs(y)) else { return 0 }\n  let subtract: Bool = (x < 0) != (y < 0)\n  let xBin = String(abs(x) >= abs(y) ? abs(x) : abs(y), radix: 2)\n  var yBin = String(abs(x) >= abs(y) ? abs(y) : abs(x), radix: 2)\n  while yBin.count < xBin.count {\n    yBin = String(yBin.reversed())\n    yBin.append(\"0\")\n    yBin = String(yBin.reversed())\n  }\n  let negative: Bool = (x < 0 && y < 0) || (subtract && (abs(x) >= abs(y) ? x : y) < 0) \n  var result: String = \"\"\n  var rem: Bool = false\n  \n  if !subtract {\n    for (a, b) in zip(String(xBin.reversed()), String(yBin.reversed())) {\n      if rem {\n        if (a == \"1\" && b == \"1\") {\n          result.append(\"1\")\n        } else if (a == \"1\" || b == \"1\") {\n          result.append(\"0\")\n        } else {\n          result.append(\"1\")\n          rem = false\n        }\n      } else {\n        if (a == \"1\" && b == \"1\") {\n          result.append(\"0\")\n          rem = true      \n        } else if (a == \"1\" || b == \"1\") {\n          result.append(\"1\")\n        } else {\n          result.append(\"0\")\n        }\n      }\n    }\n    if rem { result.append(\"1\") }\n  } else {\n    for (a, b) in zip(String(xBin.reversed()), String(yBin.reversed())) {\n      if rem {\n        if (a == \"1\") {\n          rem = false\n          if (b == \"0\") {\n            result.append(\"0\")\n          } else {\n            result.append(\"1\")\n            rem = true\n          }         \n        } else {\n          if (b == \"1\") {\n            result.append(\"0\")\n          } else {\n            result.append(\"1\")\n          }\n        }\n      } else {\n        if (a == \"1\") {\n          if (b == \"1\") {\n            result.append(\"0\")\n          } else {\n            result.append(\"1\")\n          }\n        } else {\n          if (b == \"0\") {\n            result.append(\"0\")\n          } else {\n            result.append(\"1\")\n            rem = true\n          }\n        }\n      }\n    }\n  }\n  if negative { result.append(Character(UnicodeScalar(45))) }\n  \n  return Int(String(result.reversed()), radix: 2) ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342469,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n  return Int(Double(x).addingProduct(Double(y), 1.0))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342470,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int{\nfunc returnCode(array: [Character]) -> [Character]{\n  var arr = array\n  for i in 0..<arr.count{ \n    arr[i] = (arr[i] == \"0\") ?  \"1\" : \"0\" \n  } \n  return arr\n}\n\nfunc checkNum(number num: Int, array: [Character]) -> [Character]{\n  var arr = array\n  if num < 0 {  \n    arr.removeLast() \n    arr = returnCode(array: arr) \n    \n    while arr.count != String(String(Int.max, radix:2)).count{ \n      arr.append(\"1\") \n    } \n  }\n  return arr\n}\n\nvar a = Array(String(x, radix:2).reversed()), b = Array(String(y,radix:2).reversed()) \n\na = checkNum(number: x, array: a)\nb = checkNum(number: y, array: b)\n\nvar result = [Character]() \nvar ram = 0\n\nif a.count > b.count {      \/\/\u0434\u043e\u0432\u043e\u0434\u0438\u043c \u0434\u043e \u0440\u0430\u0437\u0440\u044f\u0434\u043e\u0432\n while b.count != a.count { \n b.append(\"0\") \n } \n} else if a.count < b.count { \n while b.count != a.count { \n a.append(\"0\") \n } \n} \n\nfor each in 0..<a.count {   \/\/ \u0441\u043a\u043b\u0430\u0434\u044b\u0432\u0430\u0435\u043c\n switch (a[each],b[each], ram) { \n case (\"0\", \"0\", 0): result.insert(\"0\", at: 0) \n case (\"1\", \"0\", 0), (\"0\", \"1\", 0): result.insert(\"1\", at: 0)\n case (\"1\", \"1\", 0): result.insert(\"0\", at: 0) \n ram = 1 \n case (\"0\", \"0\", 1): result.insert(\"1\", at: 0) \n ram = 0 \n case (\"1\", \"0\", 1), (\"0\", \"1\", 1): result.insert(\"0\", at: 0) \n ram = 1 \n case (\"1\", \"1\", 1): result.insert(\"1\", at: 0) \n ram = 1 \n default: break\n }  \n} \n\nif ram == 1 {result.insert(\"1\", at: 0)}\n\nif (x >= 0 && y < 0 && x <= abs(y)) || (x < 0 && y >= 0 && abs(x) >= y){\n  result = returnCode(array: result)\n  result.insert(Array(String(x))[0], at:0)\n} else if (x >= 0 && y < 0 && x >= abs(y)) || (x < 0 && y >= 0 && abs(x) <= y) || (x < 0 && y < 0){\n  if result.count == 64 {\n    result.removeFirst()\n    result.reverse()\n    for i in 0..<result.count{\n      if result[i] == \"0\"{\n        result[i] = \"1\"\n        break\n      } else {\n        result[i] = \"0\"\n      }\n    }\n    result.reverse()\n}\n  if x < 0 && y < 0{\n    result = returnCode(array: result)\n    result.insert(Array(String(x))[0], at:0)\n  }\n}\n\nreturn (Int(result.map{String($0)}.joined(), radix:2)!)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342471,"user_id":null,"body":"func add(_ x: Int, _ y: Int) -> Int {\n    let carry = (x & y) << 1;\n    let result = x ^ y;\n    \n    return carry == 0 ? result : add(carry, result)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5aba780a6a176b029800041c":[{"id":342472,"user_id":645,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    return b - b % d\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342473,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    return (b \/ d) * d\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342474,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    return (0...b).reversed().first(where: { $0 % d == 0})!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342475,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    (1...b).filter { $0 % d == 0 }.max()!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342476,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    stride(from: b, to: 1,by: -1).first(where: {$0 % d == 0})!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342477,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n  \n  stride(from: b, to: 1, by: -1).filter{$0 % d == 0}[0]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342478,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    return (d + 1...b).filter { $0 % d == 0 && $0 > 0}.max() ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342479,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    \/\/ your code here\n  let a = b % d \n  return b - a\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342480,"user_id":null,"body":"\nfunc maxMultiple(_ d: Int, _ b: Int) -> Int{\n    \n    let arr = [Int](d...b)\n    \n    let filtered = arr.reversed().filter({\n        $0 % d == 0\n    })\n    \n    return filtered.first ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342481,"user_id":null,"body":"func maxMultiple(_ d: Int, _ b: Int) -> Int {\n    \/\/ your code here\n  var max = 0\n  let firstBound = (d + b) \/ 2\n  for i in firstBound...b {\n    if i % d == 0 {\n      max = i\n    }\n  }\n  return max\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ae62fcf252e66d44d00008e":[{"id":342482,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n  return max(a + b + c, (a + b) * c, a * (b + c),  a * b * c)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342483,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n\n    let possibleValues = [\n      a * (b + c),\n      a * b * c,\n      a + b * c,\n      a * b + c,\n      (a + b) * c,\n      a + b + c\n    ]\n\n    return possibleValues.max() ?? 3\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342484,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n  return [a*b*c,a+b+c,(a+b)*c,a*(b+c)].max() ?? 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342485,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n   var numbers = [Int]()\n  numbers.append (a * (b + c))\n  numbers.append (a * b * c)\n  numbers.append ((a + b) * c)\n  numbers.append (a + b + c) \n  return Int(numbers.max()!)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342486,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return max(a*(b+c),(a+b)*c,a*b*c,a+b+c)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342487,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n\n  return [a * (b + c),\n          a * b * c,\n          a + b + c,\n          (a + b) * c].max() ?? 0\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342488,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n\n  let max: Int\n  let nums = [a, b, c]\n  let ones = nums.filter { $0 == 1 }\n\n  if ones.count > 0 {\n    if ones.count == 3 {\n      max = 3\n    } else if ones.count == 2 {\n      if nums[1] != 1 {\n        max = nums[1] + 2\n      } else {\n        let num = nums.filter { $0 != 1 }.first!\n        max = num * 2\n      }\n    } else {\n      if nums.first! == 1 || (nums.first! < nums.last!) {\n        max = (nums[0] + nums[1]) * nums[2]\n      } else {\n        max = (nums[2] + nums[1]) * nums[0]\n      }\n    }\n  } else {\n    max = nums.reduce(1, *)\n  }\n\n  return max\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342489,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    var max_result = 0\n    if a+b+c > max_result {\n        max_result = a+b+c\n    }\n    \n    if a+b*c > max_result {\n        max_result = a+b*c\n    }\n    \n    if a*b+c > max_result {\n        max_result = a*b+c\n    }\n    \n    if a*b*c > max_result {\n           max_result = a*b*c\n    }\n    \n    if a*(b+c) > max_result {\n           max_result = a*(b+c)\n    }\n    \n    if (a+b)*c > max_result {\n         max_result = (a+b)*c\n     }\n    \n    return max_result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342490,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    var array = [Int]()\n    array.append(a+b+c)\n    array.append((a+b)+c)\n    array.append(a+(b+c))\n    array.append(a*b*c)\n    array.append(a*b+c)\n    array.append(a+b*c)\n    array.append(a*(b+c))\n    array.append((a+b)*c)\n    \/\/ your code here\n    let answer = array.max()\n    return answer!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342491,"user_id":null,"body":"func expression_matter(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    let t = a + b + c\n    let t2 = a * b * c\n    let t3 = (a + b) * c\n    let t4 = a * (b + c)\n    let t5 = (a * b) + c\n    let t6 = a + (b * c)\n\n    var highest = t\n    if highest <  t2 {\n        highest =  t2\n    }\n    if highest <  t3 {\n        highest =  t3\n    }\n    if highest <  t4 {\n        highest =  t4\n    }\n    if highest <  t5 {\n        highest =  t5\n    }\n    if highest <  t6 {\n        highest =  t6\n    }\n    \n    return highest\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ae840b8783bb4ef79000094":[{"id":342492,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n  return dicts.reduce(into: [:]) {\n    $0.merge($1.lazy.map { ($0.key, [$0.value]) }, uniquingKeysWith: +)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342493,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n  return dicts.flatMap{$0}.reduce(into: [:]) { $0[$1.key, default:[]].append($1.value)}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342494,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n    var flat = dicts.flatMap { (dict) in dict }, res = [Key: [Value]]()\n    \n    for pair in flat {\n        if let val = res[pair.key] { res[pair.key] =  val + [pair.value]\n        }else {res[pair.key] = [pair.value]}\n    }\n    \n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342495,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n    var m = [Key: [Value]]()\n    for d in dicts {\n        for (k,v) in d {\n            m[k] = (m[k] ?? []) + [v]\n        }\n    }\n    return m\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342496,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n  var dictionary = [Key: [Value]]()\n  for dict in dicts {\n    for key in dict.keys {\n      dictionary[key] = dictionary[key] != nil ? dictionary[key]! + [dict[key]!] : [dict[key]!]\n    }\n  }\n  return dictionary\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342497,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n    var retValue = [Key:[Value]]()\n    for dictionary in dicts {\n        dictionary.forEach() { item in\n            retValue[item.key, default: []].append(item.value)\n        }\n    }\n  return retValue\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342498,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n    var res = [Key: [Value]]()\n    for i in dicts {\n        for (k, v) in i {\n            if res[k] != nil {\n                res[k]?.append(contentsOf: [v])\n            } else {\n                res[k] = [v]\n            }\n        }\n    }\n    return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342499,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n  guard !dicts.isEmpty else {\n    return [:]\n  }\n  let keys = Set(Array(dicts.map {$0.keys}.joined()))\n  var result:[Key: [Value]] = Dictionary(uniqueKeysWithValues: keys.map{ ($0, []) })\n  \n  for dict in dicts {\n    for key in keys {\n      if dict.keys.contains(key) {\n        result[key]?.append(dict[key]!)\n      }\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342500,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n  dicts.reduce(into: [:]) { result, dict in\n    result.merge(dict.mapValues { [$0] }, uniquingKeysWith: +)\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342501,"user_id":null,"body":"func merge<Key, Value>(_ dicts: [[Key: Value]]) -> [Key: [Value]] {\n\n  var mergedDict = [Key: [Value]]()\n  \n  dicts.forEach { dict in\n    dict.map { key, value in \n                guard var existingValue = mergedDict[key] else {\n                  mergedDict[key] = [value]\n                  return\n                }\n                existingValue.append(value)\n                mergedDict[key] = existingValue\n               }             \n  }\n  return mergedDict\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5af15a37de4c7f223e00012d":[{"id":342502,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n    let men: [Int] = Array(Set(arr.filter{ $0 % 2 == 0 })).sorted()\n    let boys: [Int] = Array(Set(arr.filter{ $0 % 2 != 0 })).sorted { $0 > $1 }\n    return men + boys\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342503,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n  let arr = Array(Set(arr));\n  return arr.filter { $0 & 1 == 0 }.sorted() + arr.filter { $0 & 1 != 0 }.sorted(by: >)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342504,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n    let men = Set(arr.filter { $0 % 2 == 0 }).sorted(by: <)\n    let boys = Set(arr.filter { $0 % 2 != 0 }).sorted(by: >)\n    return men + boys\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342505,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n    Set(arr.filter{ $0.isMultiple(of: 2) }).sorted(by: <) + Set(arr.filter{ !$0.isMultiple(of: 2) }).sorted(by: >)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342506,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n  \/\/ your code here\n  var evenArr: [Int] = []\n  var oddArr: [Int] = []\n  for i in arr {\n    if i.isMultiple(of: 2) && evenArr.contains(i) == false {\n      evenArr.append(i)\n    } else if i.isMultiple(of: 2) == false && oddArr.contains(i) == false {\n      oddArr.append(i)\n    } else {\n      continue\n    }\n  }\n  evenArr.sort()\n  oddArr.sort(by: >)\n  let lastArr = evenArr + oddArr\n  return lastArr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342507,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n    var new: [Int] = []\n    var boys: [Int] = []\n    var men: [Int] = []\n    for i in arr {\n        if i % 2 == 0 {\n            men.append(i)\n        } else {\n            boys.append(i)\n        }\n        men.sort(by: <)\n        boys.sort(by: >)\n        new = (men + boys).uniques\n    }\n    return new\n}\n\nextension Array where Element: Hashable {\n    var uniques: Array {\n        var buffer = Array()\n        var added = Set<Element>()\n        for elem in self {\n            if !added.contains(elem) {\n                buffer.append(elem)\n                added.insert(elem)\n            }\n        }\n        return buffer\n    }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342508,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\nlet boys = Array(Set(arr.filter { abs($0) % 2 == 1 })).sorted(by: >)\nlet men = Array(Set(arr.filter { abs($0) % 2 == 0 })).sorted()\n  return [men,boys].flatMap { $0 }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342509,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n  var men = [Int]()\n  var boys = [Int]()\n  for item in arr {\n    if item % 2 == 0 {\n      men.append(item)\n    } else {\n      boys.append(item)\n    }\n  }\n  men = Array(Set(men))\n  boys = Array(Set(boys))\n  men = men.sorted(by: <)\n  boys = boys.sorted(by: >)\n  return men + boys\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342510,"user_id":null,"body":"\nfunc menFromBoys(_ arr: [Int]) -> [Int] {\n    var men: [Int] = []\n    var boys: [Int] = []\n    var result: [Int] = []\n    \n    for item in arr {\n        if item % 2 == 0 {\n            men.append(item)\n        } else {\n            boys.append(item)\n        }\n    }\n    \n    let newMen = Array(Set(men))\n    let newBoys = Array(Set(boys))\n    result = newMen.sorted(by: <) + newBoys.sorted(by: >)\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342511,"user_id":null,"body":"func menFromBoys(_ arr: [Int]) -> [Int] {\n   let sets = Array(Set(arr))\n  return sets.filter({$0 % 2 == 0}).sorted(by: <) + sets.filter({$0 % 2 != 0}).sorted(by: >)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5af96cea3e9715ec670001dd":[{"id":342512,"user_id":null,"body":"extension Double {\n    func toRadian() -> Double { return self * (Double.pi \/ 180) }\n}\n\nclass Projectile {\n    private var projectileHeight: Double\n    private var projectileVelocity: Double\n    private var projectileAngle: Double\n    \n    init(h: Int, v0: Int, a: Int) {\n        self.projectileHeight = Double(h)\n        self.projectileVelocity = Double(v0)\n        self.projectileAngle = Double(a).toRadian()\n    }\n    \n    func heightEq() -> String {\n        return \"h(t) = -16.0t^2 + \\(round(1000 * projectileVelocity * sin(projectileAngle)) \/ 1000)t\\(projectileHeight > 0 ? \" + \\(round(1000 * projectileHeight) \/ 1000)\" : \"\")\"\n    }\n    \n    func horizEq() -> String {\n        return \"x(t) = \\(round(1000 * projectileVelocity * cos(projectileAngle)) \/ 1000)t\"\n    }\n    \n    func height(time: Double) -> Double {\n        return round(1000 * (-16.0 * pow(time, 2) + projectileVelocity * sin(projectileAngle) * time + projectileHeight)) \/ 1000\n    }\n    \n    func horiz(time: Double) -> Double {\n        return round(1000 * (projectileVelocity * cos(projectileAngle) * time)) \/ 1000\n    }\n    \n    func landing() -> [Double] {\n        var t = 0.0\n        \n        let a = -16.0\n        let b = projectileVelocity * sin(projectileAngle)\n        let c = projectileHeight\n\n        let t0 = (-b - sqrt(pow(b, 2) - 4 * a * c)) \/ (2 * a)\n        let t1 = (-b + sqrt(pow(b, 2) - 4 * a * c)) \/ (2 * a)\n        \n        if t0 < 0 {\n            t = t1\n        } else {\n            t = t0\n        }\n        \n        let d = projectileVelocity * cos(projectileAngle) * t\n        \n        return [round(1000 * d) \/ 1000,0, round(1000 * t) \/ 1000]\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342513,"user_id":null,"body":"class Projectile{\n    let h0: Double\n    let v0: Double\n    let angle: Double\n    init(h: Int, v0: Int, a: Int) {\n        self.h0 = Double(h)\n        self.v0 = Double(v0)\n        self.angle = Double.pi \/ (180 \/ Double(a))\n    }\n    func heightEq() -> String {\n        return \"h(t) = -16.0t^2 + \\((v0 * sin(angle)).rounded(to: 3))t\\(h0 != 0 ? \" + \\(h0)\" : \"\")\"    \n    }\n    func horizEq() -> String { \n        return \"x(t) = \\((v0 * cos(angle)).rounded(to: 3))t\"\n    }\n    func height(time t: Double) -> Double { \n        return (-16 * pow(t, 2) + v0 * sin(angle) * t + h0).rounded(to: 3)\n    }\n    func horiz(time t: Double) -> Double { \n        return (v0 * cos(angle) * t).rounded(to: 3)\n    }\n    func landing() -> [Double] {\n        func trueHeight(t: Double) -> Double {\n            return -16 * pow(t, 2) + v0 * sin(angle) * t + h0\n        }\n        var t = 0.001\n        while trueHeight(t: t) >= 0 {\n            t += 0.000001\n        }\n        return [horiz(time: t), 0.0, t.rounded(to: 3)]\n    }\n}\n\nextension Double {\n    func rounded(to x: Double) -> Double {\n        let num = pow(10, x)\n        return (self * num).rounded() \/ num\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342514,"user_id":null,"body":"extension Double {\n\n  var str: String {\n    let format = (self == rounded()) ? \"%.1f\" : \"%g\"\n    return String(format: format, self.rnd)\n  }\n  \n  var rad: Double {\n    self * .pi \/ 180\n  }\n  \n  var rnd: Double {\n    (self * 1000).rounded() \/ 1000\n  }\n}\n\nfinal class Projectile {\n  \n  private let h0: Double\n  private let v0: Double\n  private let a0: Double\n  \n  init(h: Int, v0 v: Int, a: Int) {\n    h0 = Double(h)\n    v0 = Double(v)\n    a0 = Double(a).rad\n  }\n  \n  func heightEq() -> String {\n    let prfx = \"h(t) = -16.0t^2 + \\((v0 * sin(a0)).str)t\"\n    let sfx = (h0 == 0) ? \"\" : \" + \\(h0.str)\"\n    return prfx + sfx\n  }\n  \n  func horizEq() -> String {\n    \"x(t) = \\((v0 * cos(a0)).str)t\"\n  }\n  \n  func height(time t: Double) -> Double {\n    (-16 * t * t + v0 * sin(a0) * t + h0).rnd \n  }\n  \n  func horiz(time t: Double) -> Double {\n    (v0 * cos(a0) * t).rnd\n  }\n  \n  func landing() -> [Double] {\n    let d = sqrt(v0 * v0 * sin(a0) * sin(a0) + 64 * h0)\n    let t = (v0 * sin(a0) + d) \/ 32\n    let x = horiz(time: t)\n    return [x.rnd, 0, t.rnd]\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342515,"user_id":null,"body":"class Projectile{\n    var h: Int\n    var v0: Int\n    var a: Int\n    init(h: Int, v0: Int, a: Int) {\n      self.h = h\n      self.v0 = v0\n      self.a = a\n    }\n    func heightEq() -> String {\n        let x = Double(v0) * sin((Double(a) * Double.pi)\/180.0)\n        return h > 0 ? \"h(t) = -16.0t^2 + \" + \"\\(String(format: \"%.3f\", x).replacingOccurrences(of: \"0*$\", with: \"\", options: .regularExpression))\" + \"t + \\(String(format: \"%.1f\", Double(h)))\" : \"h(t) = -16.0t^2 + \" + \"\\(String(format: \"%.3f\", x))\" + \"t\"\n    }\n    func horizEq() -> String {\n        let x = Double(v0) * cos((Double(a) * Double.pi)\/180.0)\n        return \"x(t) = \\(String(format: \"%.3f\", x).replacingOccurrences(of: \"0*$\", with: \"\", options: .regularExpression))t\"\n    }\n    func height(time: Double) -> Double {\n        let x = -16 * pow(time, 2.0) + Double(v0) * sin((Double(a) * Double.pi)\/180.0) * time + Double(h)\n        return Double(round(x * 1000) \/ 1000)\n    }\n    func horiz(time: Double) -> Double {\n        let x = Double(v0) * cos((Double(a) * Double.pi)\/180.0) * time\n        return Double(round(x * 1000) \/ 1000)\n    }\n    func landing() -> [Double] {\n        let a1 = -16.0\n        let b = Double(v0) * sin((Double(a) * Double.pi)\/180.0)\n        let c = Double(h)\n        let t = (b + sqrt(pow(b, 2.0) - 4.0 * a1 * c)) \/ (2.0 * -a1)\n        let x = t * Double(v0) * cos((Double(a) * Double.pi)\/180.0)\n        return [Double(round(1000 * x) \/ 1000), 0.0, Double(round(1000 * t) \/ 1000)]\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342516,"user_id":null,"body":"class Projectile{\n  var h = Double()\n  var v0 = Double()\n  var a = Double()\n  init(h: Int,v0: Int,a: Int) {\n    self.h = Double(h)\n    self.v0 = Double(v0)\n    self.a = Double(a)\n  }\n  func heightEq() -> String {\n    var returnString = \"h(t) = \\(-32.0\/2)t^2 + \\(Double(round(1000*(sin(a * Double.pi \/ 180)*v0))\/1000))t\"\n    if h != 0.0 {\n      returnString += \" + \\(h)\"\n    }\n    return returnString\n  }\n  func horizEq() -> String {\n    return \"x(t) = \\(Double(round(1000*(cos(a * Double.pi \/ 180)*v0))\/1000))t\"\n  }\n  func height(time: Double) -> Double {\n    return round(1000*(((-32.0\/2)*(time*time)) + ((sin(a * Double.pi \/ 180)*v0)*time) + h))\/1000\n  }\n  func horiz(time: Double) -> Double {\n    return (round(1000*(cos(a * Double.pi \/ 180)*v0)*time)\/1000)\n  }\n  func landing() -> [Double]{\n    let quadSol = (((sin(a * Double.pi \/ 180)*v0*(-1))-sqrt(((sin(a * Double.pi \/ 180)*v0)*(sin(a * Double.pi \/ 180)*v0))-4*(-32.0\/2)*(h)))\/(-32.0))\n    return [horiz(time:quadSol),0.0,Double(round(1000*quadSol)\/1000)]\n  } \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342517,"user_id":null,"body":"class Projectile {\n    let h : Double\n    let v0 : Double\n    let a : Double\n    \n    init(h: Int, v0: Int, a: Int) {\n        self.h = Double(h)\n        self.v0 = Double(v0)\n        self.a = Double(a)\n    }\n    \n    func heightEq() -> String {\n        let hEq = h > 0 ? \" + \\(String(format: \"%.1f\", h))\" : \"\"\n        return \"h(t) = -16.0t^2 + \\(velocityPart().roundToDot3())t\\(hEq)\"\n    }\n    \n    func velocityPart() -> Double {\n        v0 * sin(a * Double.pi \/ 180.0)\n    }\n    \n    func horizontalPart() -> Double {\n        v0 * cos(a * Double.pi \/ 180.0)\n    }\n    \n    func horizEq() -> String {\n        return \"x(t) = \\(horizontalPart().roundToDot3())t\"\n    }\n    \n    func height(time: Double) -> Double {\n        (-16.0 * time * time + velocityPart() * time + h).roundToDot3()\n    }\n    \n    func horiz(time: Double) -> Double {\n        (horizontalPart() * time).roundToDot3()\n    }\n    \n    func landing() -> [Double] {\n        let b = velocityPart()\n        let time = (-b - sqrt(b * b - 4 * (-16.0) * h)) \/ (2 * (-16.0))\n        return [horiz(time: time).roundToDot3(), 0.0, time.roundToDot3()]\n    }\n}\n\nextension Double {\n    func roundToDot3() -> Double {\n        return (self * 1000).rounded() \/ 1000\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342518,"user_id":null,"body":"class Projectile {\n    let h : Double\n    let v0 : Double\n    let a : Double\n    \n    init(h: Int, v0: Int, a: Int) {\n        self.h = Double(h)\n        self.v0 = Double(v0)\n        self.a = Double(a)\n    }\n    \n    func heightEq() -> String {\n        let hEq = h > 0 ? \" + \\(String(format: \"%.1f\", h))\" : \"\"\n        return \"h(t) = -16.0t^2 + \\(velocityPart().roundToDot3())t\\(hEq)\"\n    }\n    \n    func velocityPart() -> Double {\n        v0 * sin(a * Double.pi \/ 180.0)\n    }\n    \n    func horizontalPart() -> Double {\n        v0 * cos(a * Double.pi \/ 180.0)\n    }\n    \n    func horizEq() -> String {\n        return \"x(t) = \\(horizontalPart().roundToDot3())t\"\n    }\n    \n    func height(time: Double) -> Double {\n        ((-16.0 * time * time + velocityPart() * time + h) * 1000).rounded() \/ 1000\n    }\n    \n    func horiz(time: Double) -> Double {\n        (horizontalPart() * time * 1000).rounded() \/ 1000\n    }\n    \n    func landing() -> [Double] {\n        let b = velocityPart()\n        let time = (-b - sqrt(b * b - 4 * (-16.0) * h)) \/ (2 * (-16.0))\n        return [horiz(time: time).roundToDot3(), 0.0, time.roundToDot3()]\n    }\n}\n\nextension Double {\n    func roundToDot3() -> Double {\n        return (self * 1000).rounded() \/ 1000\n    }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342519,"user_id":null,"body":"class Projectile{\n  var h: Double\n  var v0: Double\n  var a: Double\n  var vert : Double\n  var dx : Double\n  let formatter: NumberFormatter = {\n    let nf = NumberFormatter()\n    nf.numberStyle = .decimal\n    nf.minimumFractionDigits = 0\n    nf.maximumFractionDigits = 3\n    return nf\n  }()\n  \n  init(h: Int, v0: Int, a: Int) {\n    self.h = Double(h)\n    self.v0 = Double(v0)\n    self.a = Double(a)\n    self.vert = Double(v0) * sin(toRadians(a))\n    self.dx = Double(v0) * cos(toRadians(a))    \n  }\n  \n  func heightEq() -> String {\n    let h0 = self.h == 0.0 ? \"\" : \" + \\(self.h)\"\n    return \"h(t) = -16.0t^2 + \\(formatter.string(from: NSNumber(value: self.vert))!)t\\(h0)\"\n  }\n  func horizEq() -> String {\n    return \"x(t) = \\(formatter.string(from: NSNumber(value: self.dx))!)t\"\n  }\n  func height(time: Double) -> Double {\n    return round((-16 * pow(time, 2.0) + self.vert * time + self.h) * 1000) \/ 1000\n  }\n  func horiz(time: Double) -> Double {\n    return round(self.dx * time * 1000) \/ 1000\n  }\n  func landing() -> [Double] {\n    let maxTime = self.vert \/ 32.0\n    if self.h == 0 { return [self.horiz(time: 2 * maxTime), 0, round(2 * maxTime * 1000) \/ 1000] }\n    \n    let maxHeight = self.h + self.vert * maxTime - 16 * pow(maxTime, 2)\n    let timeDown = sqrt(maxHeight \/ 16.0)\n    let time = maxTime + timeDown\n        \n    return [self.horiz(time: time), 0, round(time * 1000) \/ 1000] \n  }  \n\n}\n\nfunc toRadians(_ d: Int) -> Double {\n  return Double(d) * Double.pi \/ 180.0\n}\nfunc toDegrees(_ r: Double) -> Int {\n  return Int(round(r * 180.0 \/ Double.pi))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342520,"user_id":null,"body":"class Projectile {\n  var h: Int\n  var v0: Int\n  var a: Int\n  let vVert: Double\n  let vHor: Double\n  \n  init(h: Int, v0: Int, a: Int) {\n      self.h = h\n      self.v0 = v0\n      self.a = a\n      vVert = Double(v0) * sin(Double(a) * Double.pi \/ 180)\n      vHor = Double(v0) * cos(Double(a) * Double.pi \/ 180)\n  }\n  \n  func heightEq() -> String {\n    if h == 0 {\n    return  \"h(t) = -16.0t^2 + \\(Double(String(format: \"%.3f\", vVert))!)t\"\n    } else {\n    return  \"h(t) = -16.0t^2 + \\(Double(String(format: \"%.3f\", vVert))!)t + \\(Double(String(format: \"%.1f\", Double(h)))!)\"\n   }\n   \n  }\n  func horizEq() -> String {  \n    return (\"x(t) = \\(Double(String(format: \"%.3f\", vHor))!)t\")\n  }\n  func height(time: Double) -> Double {  \n    let result = (-16.0 * time * time + vVert * time + Double(h))\n    return Double(String(format: \"%.3f\", result))!\n  }\n  \n  func horiz(time: Double) -> Double {\n    return Double(String(format: \"%.3f\", (vHor * time)))!\n  }\n  \n  func landing() -> [Double] {\n\n  let t = (vVert + (vVert * vVert + Double(64 * h)).squareRoot())\/32\n  let x = vHor * t\n    return [Double(String(format: \"%.3f\", x))!, 0, Double(String(format: \"%.3f\", t))!]\n  }\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342521,"user_id":null,"body":"class Projectile{\n  var h0: Double\n  var v0a: Double\n  var angle: Double\n  var v0Vert: Double\n  var v0Hor: Double\n  \n  \/\/ There is probably a WAY better way to handle accepting\n  \/\/ either a double or an integer.  I can't figure it out though\n  \/\/ so here's six initializers :(\n  init (h: Double, v0: Double, a: Double){\n    h0 = h\n    v0a = v0\n    angle = a\n    v0Vert = v0a*sin(angle*Double.pi\/180)\n    v0Hor = v0a*cos(angle*Double.pi\/180)\n  }\n  \n  init (h: Int, v0: Double, a: Double){\n    h0 = Double(h)\n    v0a = v0\n    angle = a\n    v0Vert = v0a*sin(angle*Double.pi\/180)\n    v0Hor = v0a*cos(angle*Double.pi\/180)\n  }\n  \n    init (h: Int, v0: Int, a: Double){\n    h0 = Double(h)\n    v0a = Double(v0)\n    angle = a\n    v0Vert = v0a*sin(angle*Double.pi\/180)\n    v0Hor = v0a*cos(angle*Double.pi\/180)\n    }\n    \n    init (h: Int, v0: Double, a: Int){\n    h0 = Double(h)\n    v0a = v0\n    angle = Double(a)\n    v0Vert = v0a*sin(angle*Double.pi\/180)\n    v0Hor = v0a*cos(angle*Double.pi\/180)\n    }\n    \n    init (h: Double, v0: Int, a: Int){\n    h0 = h\n    v0a = Double(v0)\n    angle = Double(a)\n    v0Vert = v0a*sin(angle*Double.pi\/180)\n    v0Hor = v0a*cos(angle*Double.pi\/180)\n  }\n    \n    init (h: Int, v0: Int, a: Int){\n    h0 = Double(h)\n    v0a = Double(v0)\n    angle = Double(a)\n    v0Vert = v0a*sin(angle*Double.pi\/180)\n    v0Hor = v0a*cos(angle*Double.pi\/180)\n  }\n  \n  \n  \/\/ This handles turning the doubles into strings of the appropriate length\n  func roundToSF(_ n: Double) -> String {\n    if round(n) == n {\n      return String(\"\\(round(n))\")\n    }\n    return String(\"\\(round(n*1000)\/1000)\")\n  }\n  \n  \n  \/\/ The requested functions begin here\n  func heightEq() -> String {\n    if h0 == 0 {\n      return String(\"h(t) = -16.0t^2 + \\(roundToSF(v0Vert))t\")\n    }else{\n      return String(\"h(t) = -16.0t^2 + \\(roundToSF(v0Vert))t + \\(roundToSF(h0))\")\n    }\n  }\n  \n  func horizEq() -> String {\n    return String(\"x(t) = \\(roundToSF(v0Hor))t\")\n  }\n  \n  func height(time: Double) -> Double {\n    return round((-16*time*time+time*v0Vert+h0)*1000)\/1000\n  }\n  \n  func horiz(time: Double) -> Double {\n    return round((v0Hor*time)*1000)\/1000\n  }\n  \n  func landing() -> [Double] {\n    \/\/ the coefficients for the quadratic equation are \n    \/\/ defined here to make the code a little more readable\n    let a: Double = -16.0\n    let b: Double = v0Vert\n    let c: Double = h0\n    \/\/ quadratic formula keeping only the right-most root\n    let time = (-b - (b*b-4*a*c).squareRoot())\/(2*a)\n    \n    return [horiz(time: time), 0.0, round(time*1000)\/1000]\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b06c990908b7eea73000069":[{"id":342522,"user_id":53,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n    return max(-1, Int(log(eps) \/ log(hypot(x, y))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342523,"user_id":168,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n  let a = hypot(x, y)\n  return a >= 1 ? -1 : Int(log(eps) \/ log(a))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342524,"user_id":null,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n     var m = (x * x + y * y).squareRoot()\n  if m < 1 {\n    return Int(log(eps)\/log(m))\n  }\n  return -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342525,"user_id":null,"body":"func f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n  \n  typealias Cmplx = (Double, Double)\n  \n  func add(_ a: Cmplx, _ b: Cmplx) -> Cmplx { (a.0 + b.0, a.1 + b.1) }\n  func sub(_ a: Cmplx, _ b: Cmplx) -> Cmplx { (a.0 - b.0, a.1 - b.1) }\n  func mult(_ a: Cmplx, _ b: Cmplx) -> Cmplx { (a.0 * b.0 - a.1 * b.1, a.0 * b.1 + a.1 * b.0) }\n  \n  func mod2(_ a: Cmplx) -> Double { a.0 * a.0 + a.1 * a.1 }\n  func diff2(_ a: Cmplx, _ b: Cmplx) -> Double { mod2(sub(a, b)) }\n  \n  func go(_ a: Cmplx, _ check: (Cmplx, Cmplx) -> Bool) -> (Cmplx, Int) {\n    var m = a\n    var n = 1\n\n    let sa = sub((1, 0), a)\n    var sb = z\n\n    var sOld = sa\n    var sNew = mult(sa, sb)\n\n    while check(sOld, sNew) { \n      n += 1\n      m = mult(m, z)\n\n      sb = add(sb, m)\n\n      sOld = sNew\n      sNew = mult(sa, sb)\n\n      guard sNew.0.isFinite && sNew.1.isFinite else { return ((0, 0), -1) }\n    }\n\n    return (sNew, n)\n  }\n  \n  let eps2 = eps * eps\n  let z = (x, y)\n  \n  let (lim, N) = go(z) { diff2($0, $1) > 0 }\n  guard N != -1 else { return -1}\n  \n  let (_, n) = go(z) { diff2($1, lim) > eps2 }\n  return n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342526,"user_id":null,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n    let a = sqrt(x * x + y * y)\n    let res = Int(log(eps) \/ log(a))\n    return res > 0 ? res : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342527,"user_id":null,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n  let n = Int(log(eps) \/ log (sqrt(pow(x, 2.0) + pow(y, 2.0))))\n  return n > 0 ? n : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342528,"user_id":null,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n    return Int(max(-1, log(eps) \/ log(hypot(x, y))))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342529,"user_id":null,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n    guard x * x + y * y < 1 else{\n        return -1\n    }\n    let theta = atan(y \/ x)\n    let r = sqrt(x * x + y * y)\n    func absS(_ n: Int) -> Double{\n        let a = cos(Double(n + 1) * theta) * pow(r, Double(n + 1))\n        let b = sin(Double(n + 1) * theta) * pow(r, Double(n + 1))\n        return sqrt(a * a + b * b)\n    }\n    var i = 1\n    while absS(i) > eps {\n        i += 1\n    }\n    return i\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342530,"user_id":527,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n    let m = hypot(x, y)\n    return m < 1 ? Int(log(eps) \/ log(m)) : -1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342531,"user_id":null,"body":"import Foundation \n\nfunc f(_ x: Double, _ y: Double, _ eps: Double) -> Int {\n    let n = hypot(x, y)\n    let res = log(eps) \/ log(n)\n    return Int(max(res, -1))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b0c0ec907756ffcff00006e":[{"id":342532,"user_id":492,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  return -c \/ b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342533,"user_id":null,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  -2 * c \/ (b + sqrt(b * b - 4 * a * c))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342534,"user_id":null,"body":"func quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double\n{\n    let f1: (Double, Double, Double) -> (Double, Double) = {\n        let x1 = ((-($1) + sqrt(($1 * $1) - (4.0 * $0 * $2))) \/ (2.0 * $0))\n        let x2 = ((-($1) - sqrt(($1 * $1) - (4.0 * $0 * $2))) \/ (2.0 * $0))\n        \n        return (x1, x2)\n    }\n    let f2: (Double, Double, Double) -> (Double, Double) = {\n        let x1 = (2 * $2 \/ (-($1) - sqrt(($1 * $1) - (4.0 * $0 * $2))))\n        let x2 = (2 * $2 \/ (-($1) + sqrt(($1 * $1) - (4.0 * $0 * $2))))\n        \n        return (x1, x2)\n    }\n    \n    let x1 = b > 0 ? f2(a, b, c).0 : f1(a, b, c).0\n    let x2 = b > 0 ? f1(a, b, c).1 : f2(a, b, c).1\n    \n    print(\"x1 = \\(String(format: \"%1.12e\", x1))\")\n    print(\"x2 = \\(String(format: \"%1.12e\", x2))\")\n    \n    return x1 < x2 ? x2 : x1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342535,"user_id":null,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n   var d = b * b - 4 * a * c\n   return  2 * c \/ (-b - d.squareRoot()) \n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342536,"user_id":null,"body":"func quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    return -c \/ b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342537,"user_id":null,"body":"func quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  func f(_ x: Double) -> Double { a * x * x + b * x + c }\n  func df(_ x: Double) -> Double { 2 * a * x + b }\n  \n  var x = 0.0\n  while abs(f(x)) >= 1e-12 {\n    x = x - f(x) \/ df(x)\n  }\n  \n  return x\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342538,"user_id":null,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  -c \/ b\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342539,"user_id":null,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n  \/\/var x:Double = -b + (b * b - 4 * a * c).squareRoot()) \/ (2 * a))\n  var sign:Double = 0;\n  \n  if (b < 0) {\n    sign = -1\n  }\n  \n  else {\n    sign = 1\n  }\n  \n  var x1:Double = ((-b - (sign * (pow(b, 2) - (4 * a * c)).squareRoot())) \/ (2 * a))\n  var x2:Double = c \/ (a * x1)\n  \n  return x2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342540,"user_id":null,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    \/\/ your code\n  \n    let result = -c \/ b\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342541,"user_id":null,"body":"import Foundation \n\nfunc quadratic(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    var r = ((b*b) - (4*a*c)).squareRoot()\n  \n  return (2*c\/(-b - r))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b1cd19fcd206af728000056":[{"id":342542,"user_id":311,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    let s = 1+1\/(2*m)\n    return s-sqrt(s*s-1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342543,"user_id":null,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    return (2.0 * m + 1.0 - sqrt(4.0 * m + 1.0)) \/ (2.0 * m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342544,"user_id":null,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    \/\/ your code\n    return ((2*m + 1) - sqrt(4*m + 1))\/(2*m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342545,"user_id":492,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    let s: Double = sqrt(4.0 * m + 1.0)\n    return (2.0 * m + 1.0 - s) \/ (2.0 * m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342546,"user_id":null,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    return ((2*m+1)-pow(4*m+1, 0.5))\/(2*m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342547,"user_id":null,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    \/\/ your code    \n    \n    return (2 * m + 1 - (4 * m + 1).squareRoot()) \/ (2 * m)\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342548,"user_id":null,"body":"func solve(_ m: Double) -> Double {\n  (m + m + 1 - sqrt(4 * m + 1)) \/ 2 \/ m\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342549,"user_id":50,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n  return  (2*m+1-(4*m+1).squareRoot())\/(2*m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342550,"user_id":null,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n  return (1+2*m-(1+4*m).squareRoot())\/(2*m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342551,"user_id":null,"body":"import Foundation \n\nfunc solve(_ m: Double) -> Double {\n    (1 + 2*m - sqrt(1 + 4 * m)) \/ (2 * m)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b4070144d7d8bbfe7000001":[{"id":342552,"user_id":null,"body":"func numericals(_ str: String) -> String {\n    var counter: [Character: Int] = [:]\n    return str.map {\n        counter[$0, default: 0] += 1\n        return String(counter[$0]!)\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342553,"user_id":null,"body":"func numericals(_ str: String) -> String {\n    \n    var result = \"\"\n    var passedSymbols: [Character: Int] = [:]\n    \n    for char in str {\n        if let number = passedSymbols[char] {\n            passedSymbols[char]! += 1\n            result += \"\\(number + 1)\"\n        } else {\n            result += \"1\"\n            passedSymbols[char] = 1\n        }  \n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342554,"user_id":null,"body":"func numericals(_ str: String) -> String {\n  var counts = [Character:Int]()\n    var ret = \"\"\n    \n    for c in str{\n        counts[c] = (counts[c] ?? 0) + 1\n        ret += \"\\(counts[c]!)\"\n    }\n    \n    return ret\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342555,"user_id":null,"body":"func numericals(_ str: String) -> String {\n  var counts = [Character: Int]()\n  var result = \"\"\n  \n  for ch in str {\n      let count = (counts[ch] ?? 0)  + 1\n      counts[ch] = count\n      result += \"\\(count)\"\n  }\n  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342556,"user_id":null,"body":"func numericals(_ str: String) -> String {\n\tvar numericals = \"\"\n\tvar charCountDic = [Character: Int]()\n\tstr.forEach {\n\t\tvar count = 1\n\t\tif let charCount = charCountDic[$0] {\n\t\t\tcount = charCount + 1\n\t\t}\n\t\tcharCountDic[$0] = count\n\t\tnumericals = \"\\(numericals)\\(count)\"\n\t}\n\treturn numericals\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342557,"user_id":null,"body":"func numericals(_ str: String) -> String {\n  var res: [Int] = []\n  var dict: [String : Int] = [:]\n  for item in str {\n    if dict[String(item)] != nil {\n      dict[String(item)]! += 1\n      res.append(dict[String(item)]!)\n    } else {\n      dict.updateValue(1, forKey: \"\\(item)\")\n      res.append(1)\n    }\n  }\n  return res.map { String($0) }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342558,"user_id":null,"body":"func numericals(_ str: String) -> String {\n    let inputToArr = Array(str)\n    var countDir = [String : Int]()\n    var result = \"\"\n    for char in inputToArr {\n        if countDir[char.description] == nil {\n            countDir[char.description] = 1\n        } else {\n            countDir.updateValue(countDir[char.description]! + 1, forKey: char.description)\n        }\n        result += String(countDir[char.description]!)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342559,"user_id":220,"body":"func numericals(_ str: String) -> String {\n\n  var result = \"\" \n  var counts: [Character: Int] = [:]\n  for c in str {    \n    let count = counts[c] ?? 1    \n    result += String(count)\n    counts[c] = count + 1\n  }  \n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342560,"user_id":null,"body":"func numericals(_ str: String) -> String {\nvar returnString = \"\"\nvar letterDict: [String: Int] = [:]\n\nfor letter in str {\n    if(letterDict.keys.contains(String(letter))){\n        letterDict[String(letter)]! = letterDict[String(letter)]! + 1\n        returnString += String(letterDict[String(letter)]!)\n    } else {\n        letterDict[String(letter)] = 1\n        returnString += String(letterDict[String(letter)]!)\n    }\n}\nreturn returnString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342561,"user_id":null,"body":"func numericals(_ str: String) -> String {\n  var returnString = \"\"\n  var emptyDict: [String: Int] = [:]\n\n  for letter in str {\n      if(emptyDict.keys.contains(String(letter))){\n          emptyDict[String(letter)]! = emptyDict[String(letter)]! + 1\n          returnString += String(emptyDict[String(letter)]!)\n      } else {\n          emptyDict[String(letter)] = 1\n          returnString += String(emptyDict[String(letter)]!)\n      }\n  }\n\n\/\/   for letter in str {\n\/\/       returnString += String(emptyDict[String(letter)]!)\n\/\/   }\n  return returnString\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b40b666dfb4291ad9000049":[{"id":342562,"user_id":53,"body":"import Foundation \n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n  let PI = 3.1415926535897932;\n  let u = Double(alpha) * PI \/ 180.0\n  let v = Double(beta) * PI \/ 180.0\n  let w = Double(gamma) * PI \/ 180.0\n  let x = Double(a) * cos(u) - Double(b) * sin(v) - Double(c) * cos(w)\n  let y = Double(a) * sin(u) + Double(b) * cos(v) - Double(c) * sin(w)\n  let t = atan2(y, x) * 180.0 \/ PI\n  let r = hypot(x, y)\n  return [Int(round(r)), Int(t), Int(t * 60.0) % 60, Int(t * 3600.0) % 60]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342563,"user_id":492,"body":"import Foundation \n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n    let PI = 3.1415926535897932;\n    let aa = Double(alpha) * PI \/ 180.0\n    let bb = Double(beta) * PI \/ 180.0\n    let cc = Double(gamma) * PI \/ 180.0\n    let x = Double(a) * cos(aa) - Double(b) * sin(bb) - Double(c) * cos(cc)\n    let y = Double(a) * sin(aa) + Double(b) * cos(bb) - Double(c) * sin(cc)\n    let r = sqrt(x*x + y*y)\n    let theta = Int(acos(x \/ r) * 180.0 * 3600.0 \/ PI)\n    let d: Int = theta \/ 3600\n    let mm: Int = theta % 3600\n    let m: Int = mm \/ 60\n    let s: Int = mm % 60\n    return [Int(round(r)), d, m, s]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342564,"user_id":null,"body":"import Foundation \n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n    let pi = 3.14159265358979323846\n    var arr = [Int]()\n    var x = Double(0.0)\n    var y = Double(0.0)\n    \n    x = Double(a) * cos(Double(alpha) * pi \/ 180)\n    y = Double(a) * sin(Double(alpha) * pi \/ 180)\n    x += Double(b) * cos(Double(beta + 90) * pi \/ 180)\n    y += Double(b) * sin(Double(beta + 90) * pi \/ 180)\n    x += Double(c) * cos(Double(gamma + 180) * pi \/ 180)\n    y += Double(c) * sin(Double(gamma + 180) * pi \/ 180)\n    arr.append(Int(sqrt(x * x + y * y).rounded()))\n    var degree = acos(x \/ sqrt(x * x + y * y)) * 180 \/ pi\n    arr.append(Int(degree))\n    for _ in 0...1 {\n        degree = (degree - Double(Int(degree))) * 60\n        arr.append(Int(degree))\n    }\n    return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342565,"user_id":null,"body":"import Foundation\n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n  let rad_alpha = Double(alpha) * Double.pi \/ 180\n  let rad_beta = Double(beta) * Double.pi \/ 180\n  let rad_gamma = Double(gamma) * Double.pi \/ 180\n\n  let v_a = [Double(a)*cos(rad_alpha), Double(a)*sin(rad_alpha)]\n  let v_b = [Double(b)*cos(rad_beta + Double.pi\/2), Double(b)*sin(rad_beta + Double.pi\/2)]\n  let v_c = [Double(c)*cos(rad_gamma + Double.pi), Double(c)*sin(rad_gamma + Double.pi)]\n  let p_c = [v_a[0] + v_b[0] + v_c[0], v_a[1] + v_b[1] + v_c[1]]\n  \n  let co = sqrt(p_c[0]*p_c[0]+p_c[1]*p_c[1])\n  let toc = atan2(p_c[1], p_c[0]) * 180 \/ Double.pi\n  \n  let degrees = Int(toc)\n  let minutes = Int((toc-Double(degrees)) * 60)\n  let seconds = Int(((toc-Double(degrees)) * 60 - Double(minutes)) * 60)\n\n  return [Int(round(co)), degrees, minutes, seconds]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342566,"user_id":null,"body":"import Foundation \n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n    var x, y: Double\n    let degToRad: Double = 2*Double.pi\/360\n    let radToDeg: Double = 360\/(2*Double.pi)\n    x = cos(Double(alpha) * degToRad) * Double(a)\n    y = sin(Double(alpha) * degToRad) * Double(a)\n    x -= sin(Double(beta) * degToRad) * Double(b)\n    y += cos(Double(beta) * degToRad) * Double(b)\n    x -= cos(Double(gamma) * degToRad) * Double(c)\n    y -= sin(Double(gamma) * degToRad) * Double(c)  \n    let dist: Int = Int((x*x + y*y).squareRoot().rounded())\n    var angle: Double = 90.0 + atan(abs(x)\/y) * radToDeg\n    let deg: Int = Int(angle)\n    angle -= Double(deg)\n    let min: Int = Int(angle * 60)\n    angle -= Double(min)\/60.0\n    let sec: Int = Int(angle * 3600)\n    return [dist, deg, min, sec]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342567,"user_id":null,"body":"import Foundation\n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n    var arrayCoord = [0.0, 0.0]\n    let arrayOfLenght = [Double(a), Double(b), Double(c)]\n    let arrayOfAngles = [alpha, beta, gamma]\n    var angleModifier = 0\n\/\/ coordinates of  points (finally coordinates of C point)\n    for i in 0...2 {\n        arrayCoord [0] = arrayCoord [0] + arrayOfLenght[i] * cos(Double.pi * Double(arrayOfAngles [i] + angleModifier) \/ 180)\n        arrayCoord [1] = arrayCoord [1] + arrayOfLenght[i] * sin(Double.pi * Double(arrayOfAngles [i] + angleModifier) \/ 180)\n        angleModifier += 90\n    }\n\/\/ length of OC\n    let OC = round(pow((pow((arrayCoord[0]), 2) + pow((arrayCoord[1]), 2)), 0.5))\n    \n\/\/ angle of OC\n    var angleOut = atan(arrayCoord[1] \/ arrayCoord[0]) * 180 \/ Double.pi\n    \n\/\/ modify angle of OC depending of quadrant\n    if arrayCoord[0] < 0 && arrayCoord[1] > 0 {\n        angleOut = 180 + angleOut\n    }\n    if arrayCoord[0] < 0 && arrayCoord[1] < 0 {\n        angleOut = 180 + angleOut\n    }\n    if arrayCoord[0] > 0 && arrayCoord[1] < 0 {\n        angleOut = 360 + angleOut\n    }\n\/\/ length in decimals -> minutes, seconds\n    let angleMin = (angleOut - Double(Int(angleOut))) * 60\n    let angleSec = (angleMin - Double(Int(angleMin))) * 60\n    return [Int(OC), Int(angleOut), Int(angleMin), Int(angleSec)]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342568,"user_id":null,"body":"func solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n  \n  func isin(_ a: Int) -> Double { sin(Double(a) * .pi \/ 180) }\n  func icos(_ a: Int) -> Double { cos(Double(a) * .pi \/ 180) }\n  \n  func x(_ x0: Double, _ angle: Int, _ path: Int) -> Double { x0 + Double(path) * icos(angle) }\n  func y(_ y0: Double, _ angle: Int, _ path: Int) -> Double { y0 + Double(path) * isin(angle) }\n  \n  func p(_ p0: (Double, Double), _ angle: Int, _ path: Int) -> (Double, Double) {\n    (x(p0.0, angle, path), y(p0.1, angle, path))\n  }\n  \n  let O = (0.0, 0.0)\n  let A = p(O, alpha, a)\n  let B = p(A, 90 + beta, b)\n  let C = p(B, 180 + gamma, c)\n  \n  let CO = sqrt(C.0 * C.0 + C.1 * C.1).rounded()\n  let tOC = (.pi - atan(abs(C.1 \/ C.0))) \/ .pi * 180\n  \n  let m = (tOC - tOC.rounded(.down)) * 60\n  let s = (m - m.rounded(.down)) * 60\n  \n  return [CO, tOC, m, s].map(Int.init)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342569,"user_id":null,"body":"import Foundation \n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n   let x = Double(a) * cos(Double(alpha) * .pi \/ 180) - Double(b) * sin(Double(beta) * .pi \/ 180) - Double(c) * cos(Double(gamma) * .pi \/ 180)\n  let y = Double(a) * sin(Double(alpha) * .pi \/ 180) + Double(b) * cos(Double(beta) * .pi \/ 180) - Double(c) * sin(Double(gamma) * .pi \/ 180)\n    let oc = Int(round(sqrt(pow(x,2) + pow(y,2))))\n       let angle = .pi \/ 2 + atan(-x \/ y)\n         let totalSeconds = Int(angle * 360 * 60 * 60 \/ (2 * .pi))\n         let seconds = totalSeconds % 60\n         let minutes = (totalSeconds \/ 60) % 60\n         let degrees = totalSeconds \/ (60 * 60)\n  return [oc,degrees,minutes,seconds]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342570,"user_id":null,"body":"import Foundation \n\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n         let pi180 = 3.14159265358979323846 \/ 180.0\n    var answer = [Int]()\n    let pointX = Double(a) * cos(Double(alpha) * pi180) - Double(b) * sin(Double(beta) * pi180) - Double(c) * cos(Double(gamma) * pi180)\n    let pointY = Double(a) * sin(Double(alpha) * pi180) + Double(b) * cos(Double(beta) * pi180) - Double(c) * sin(Double(gamma) * pi180)\n    let distanceOC = (sqrt(pow(pointX, 2) + pow(pointY, 2)))\n    let distanceOCy = Int(distanceOC.rounded(.toNearestOrAwayFromZero))\n    answer.append(distanceOCy)\n    \n    let tngF = pointY \/ pointX\n    let anglF = atan(tngF) \/ pi180\n    let angCherch = 180.0 + anglF\n    let answInMin = 60.0 * (angCherch - Double(Int(angCherch)))\n    let answInSec = 60.0 * (answInMin - Double(Int(answInMin)))\n    answer.append(Int(angCherch))\n    answer.append(Int(answInMin))\n    answer.append(Int(answInSec))\n    return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342571,"user_id":null,"body":"import Foundation \n\nfunc degree(_ d: Double) -> Double {\n  return d * Double.pi \/ 180.0\n}\nfunc radian(_ r: Double) -> Double {\n  return 180.0 * r \/ Double.pi\n}\nfunc descartes(_ r: Double, _ d: Double, _ o: (x: Double, y: Double) = (x: 0, y: 0)) -> (x: Double, y: Double) {\n  let rad = degree(d); let x = r * cos(rad); let y = r * sin(rad)\n  return (x: x + o.x, y: y + o.y)\n}\nfunc distance(_ a: (x: Double, y: Double), _ b: (x: Double, y: Double) = (x: 0, y: 0)) -> Double {\n  let dx: Double = a.x - b.x; let dy: Double = a.y - b.y\n  return sqrt(dx * dx + dy * dy)\n}\nfunc solve(_ a: Int, _ b: Int, _ c: Int, _ alpha: Int, _ beta: Int, _ gamma: Int) -> [Int] {\n  let A = descartes(Double(a), Double(alpha))\n  let B = descartes(Double(b), Double(beta + 90), A)\n  let C = descartes(Double(c), Double(gamma + 180), B)\n  let rc: Double = distance(C)\n  let co: Int = Int(round(rc))\n  var rec: [Int] = [co, 0, 0, 0]\n  if C.x == 0 {\n    if C.y > 0 {\n      rec[1] = 90\n    } else if C.y < 0 {\n      rec[1] = 270\n    }\n  } else if C.y == 0 {\n    if C.x < 0 {\n      rec[1] = 180\n    }\n  } else {\n    let theta = Double.pi - asin(C.y \/ rc); let t = radian(theta)\n    var seconds = Int(t * 3600.0)\n    let s = seconds % 60\n    seconds -= s\n    seconds \/= 60\n    let m = seconds % 60\n    seconds -= m\n    let d = seconds \/ 60\n    rec[1] = d; rec[2] = m; rec[3] = s\n  }\n  return rec\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5b7d2cca7a2013f79f000129":[{"id":342572,"user_id":null,"body":"func sortLemmings(_ lemmingRow: [Int], asc: Bool) -> [Int]\n{\n  let sortedLemmings = lemmingRow.sorted{\n     (left: Int, right: Int) -> Bool in \n    if asc {return left < right}\n    else {return left > right}\n   }\n  return sortedLemmings\n}\n\nfunc enumerateLemmings(lemmings: [Int]) -> String {\n  var lemmings = sortLemmings(lemmings, asc: false)\n  var output = \"\"\n  for lemming in lemmings{\n    output += String(lemming) + \" \"\n  }\n  output.removeLast(1)\n  return output\n}\n\n\nfunc lemmingBattle(_ battlefield: Int, _ letGreen: [Int], _ letBlue: [Int]) -> String {\n  if (letGreen.count == 0 && letBlue.count == 0) {return \"Green and Blue died\"}\n  if (letGreen.count == 0) {return \"Blue wins: \\(enumerateLemmings(lemmings: letBlue))\"}\n  if (letBlue.count == 0) {return \"Green wins: \\(enumerateLemmings(lemmings: letGreen))\"}\n  var green = sortLemmings(letGreen, asc: true)\n  var blue = sortLemmings(letBlue, asc: true)\n  var greenBattlefield: [Int] = []\n  var blueBattlefield: [Int] = []\n  \n  for _ in  0..<battlefield {\n    if (green.count != 0 && blue.count != 0){\n      greenBattlefield.append(green.popLast()!)\n      blueBattlefield.append(blue.popLast()!)\n    }\n  }\n  \n  var temp:Int = 0\n  for i in 0..<greenBattlefield.count {\n    temp = greenBattlefield[i] - blueBattlefield[i] \/\/calculate health of survivor\n    switch temp {\n      case 1...: \/\/green one survived, put his health into green list\n      green.append(temp)\n      case ..<0: \/\/blue one survived, put his health into blue list\n      blue.append(-temp)\n      default: \/\/ both died, no one to be put in lists\n      continue\n    }\n  }\n  return lemmingBattle(battlefield, green, blue)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342573,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n    var battlefield = battlefield\n    var green = green\n    var blue = blue\n    let lost: Set = [0]\n\n    while !Set(green).isSubset(of: lost) && !Set(blue).isSubset(of: lost)  {\n        green = green.sorted(by: >)\n        blue = blue.sorted(by: >)\n        \n        if green.count < battlefield { battlefield = green.count }\n        if blue.count < battlefield { battlefield = blue.count }\n        \n        for battlefield in 0..<battlefield {\n            let outcome = green[battlefield] - blue[battlefield]\n                    \n            if outcome < 0 {\n                blue[battlefield] = abs(outcome)\n                green[battlefield] = 0\n            }\n\n            if outcome == 0 {\n                green[battlefield] = 0\n                blue[battlefield] = 0\n            }\n\n            if outcome > 0 {\n                green[battlefield] = outcome\n                blue[battlefield] = 0\n            }\n        }\n    }\n    \n    let amountGreen = green.reduce(0, +)\n    let amountBlue = blue.reduce(0, +)\n    \n    if amountGreen == amountBlue { return \"Green and Blue died\" }\n    \n    return amountGreen > amountBlue ?\n        \"Green wins: \\( green.sorted(by: >).compactMap { $0 != 0 ? String($0) : \"\" }.joined(separator: \" \").trimmingCharacters(in: .whitespaces) )\" :\n        \"Blue wins: \\( blue.sorted(by: >).compactMap { $0 != 0 ? String($0) : \"\" }.joined(separator: \" \").trimmingCharacters(in: .whitespaces) )\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342574,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n    enum Message: String {\n        case bothDie = \"Green and Blue died\"\n        case greenWins = \"Green wins: \"\n        case blueWins = \"Blue wins: \"\n    }\n    \n    func winner (_ message: Message, _ army: [Int]? = nil) -> String {\n        (message.rawValue) + (army == nil ? \"\" : army!.map{String($0)}.joined(separator: \" \"))\n    }\n    \n    if green.isEmpty && blue.isEmpty { return winner(.bothDie)} \n    if green.isEmpty { return winner(.blueWins, blue) }\n    if blue.isEmpty { return winner(.greenWins, green)}\n    \n\n    var greenLmgs = green.sorted(by: >)\n    var blueLmgs = blue.sorted(by: >)\n\n    var endGame: Bool { greenLmgs.isEmpty || blueLmgs.isEmpty }\n    \n    while !endGame {\n        let availableBatlfields = min(min(greenLmgs.count, blueLmgs.count), battlefield)\n        \n        for _ in 0..<availableBatlfields {\n            let b = blueLmgs.removeFirst()\n            let g = greenLmgs.removeFirst()\n            if b == g { continue }\n            if b > g { blueLmgs.append(b - g) }\n            else { greenLmgs.append(g - b) }\n        }\n        blueLmgs = blueLmgs.sorted(by: >)\n        greenLmgs = greenLmgs.sorted(by: >)\n    }\n    \n    print(winner(.greenWins, greenLmgs))\n    \n    return greenLmgs.isEmpty && blueLmgs.isEmpty ? winner(.bothDie) : greenLmgs.isEmpty ? winner(.blueWins, blueLmgs) : winner(.greenWins, greenLmgs)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342575,"user_id":null,"body":"enum ResultOfBattle{\n    case draw, greenWin(fighters: [Int]), blueWin(fighters: [Int])\n\n    var title: String{\n        switch self{\n            case .draw:\n                return \"Green and Blue died\"\n            case .greenWin (let fighters):\n            return \"Green wins: \\(fighters.map { String($0) }.joined(separator: \" \"))\"\n            case .blueWin (let fighters):\n                return \"Blue wins: \\(fighters.map { String($0) }.joined(separator: \" \"))\"\n        }\n    }\n}\n\nstruct Battlefield{\n    var greenFighter: Int\n    var blueFighter: Int\n    \n    init(greenFighter: Int, blueFighter: Int){\n        self.blueFighter = blueFighter\n        self.greenFighter = greenFighter\n    }\n\n    public mutating func letsFight(){\n        if (greenFighter > blueFighter){\n            greenFighter -= blueFighter\n            blueFighter = 0\n        }\n        else if (blueFighter > greenFighter){\n            blueFighter -= greenFighter\n            greenFighter = 0\n        }\n        else{\n            blueFighter = 0;\n            greenFighter = 0;\n        }\n    }\n}\n\nfunc lemmingBattle (_ B: Int, _ SG: [Int], _ SB: [Int]) -> String{\n    \n    var greenArmy = SG\n    var blueArmy = SB\n    \n    var battlefields: [Battlefield] = []\n    var count: Int\n    \n    while (!greenArmy.isEmpty && !blueArmy.isEmpty){\n        \n        count = B < min(greenArmy.count, blueArmy.count) ? B : min(greenArmy.count, blueArmy.count)\n        \n        for _ in 0..<count{\n            \n            let indexOfGreenFighter = greenArmy.firstIndex(of: greenArmy.max()!)\n            let greenFighter = greenArmy.remove(at: indexOfGreenFighter!)\n            \n            let indexOfBlueFighter = blueArmy.firstIndex(of: blueArmy.max()!)\n            let blueFighter = blueArmy.remove(at: indexOfBlueFighter!)\n            \n            battlefields.append(Battlefield.init(greenFighter: greenFighter, blueFighter: blueFighter))\n        }\n        \n        for var battlefield in battlefields {\n            battlefield.letsFight()\n            \n            if battlefield.blueFighter > 0 && battlefield.greenFighter == 0{\n                blueArmy.append(battlefield.blueFighter)\n            }\n            else if (battlefield.greenFighter > 0 && battlefield.blueFighter == 0){\n                greenArmy.append(battlefield.greenFighter)\n            }\n            else{\n                continue\n            }\n        }\n        \n        battlefields.removeAll()\n    }\n    \n    if (greenArmy.isEmpty && !blueArmy.isEmpty){\n        return ResultOfBattle.blueWin(fighters: blueArmy.sorted(by: >)).title\n    }\n    else if (blueArmy.isEmpty && !greenArmy.isEmpty){\n        return ResultOfBattle.greenWin(fighters: greenArmy.sorted(by: >)).title\n    }\n    else{\n        return ResultOfBattle.draw.title\n    }\n}\n\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342576,"user_id":null,"body":"extension Array where Element == Int {\n  var soldiers: String {\n    sorted(by: >)\n      .map(String.init)\n      .joined(separator: \" \")\n  }\n}\n\nfunc lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n  switch (green.isEmpty, blue.isEmpty) {\n  case (true, true): return \"Green and Blue died\"\n  case (true, false): return \"Blue wins: \\(blue.soldiers)\"\n  case (false, true): return \"Green wins: \\(green.soldiers)\"\n  case (false, false):\n    let battleSize = min(battlefield, green.count, blue.count)\n    \n    let sortedGreen = green.sorted(by: >)\n    let sortedBlue = blue.sorted(by: >)\n    \n    let result = zip(\n        sortedGreen.prefix(battleSize),\n        sortedBlue.prefix(battleSize)\n      )\n      .map { $0 - $1 }\n    \n    return lemmingBattle(\n      battlefield,\n      sortedGreen.dropFirst(battleSize) + result.filter { $0 > 0 },\n      sortedBlue.dropFirst(battleSize) + result.filter { $0 < 0 }.map { -$0 }\n    )\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342577,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n    var greenSorted = green.sorted(by: >)\n    var blueSorted = blue.sorted(by: >)\n    \n    while greenSorted.count > 0 && blueSorted.count > 0 {\n        let numberOfBattlesInRound = min(blueSorted.count, greenSorted.count, battlefield)\n        \n        for i in 0..<numberOfBattlesInRound {\n            let blueStrength = blueSorted[i]\n            let greenStrength = greenSorted[i]\n            greenSorted[i] -= blueStrength\n            blueSorted[i] -= greenStrength\n        }\n        \n        greenSorted.removeAll(where: { $0 <= 0 })\n        blueSorted.removeAll(where: { $0 <= 0 })\n        \n        greenSorted.sort(by: >)\n        blueSorted.sort(by: >)\n    }\n    \n    var resultMessage = \"\"\n    \n    if greenSorted.count == 0 && blueSorted.count == 0 {\n        resultMessage = \"Green and Blue died\"\n    } else if greenSorted.count == 0 {\n        resultMessage = \"Blue wins: \" + blueSorted.sorted(by: >).map { String($0) }.joined(separator: \" \")\n    } else if blueSorted.count == 0 {\n        resultMessage = \"Green wins: \" + greenSorted.sorted(by: >).map { String($0) }.joined(separator: \" \")\n    }\n    \n    return resultMessage\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342578,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n    print(\"battlefield: \\(battlefield), green: \\(green), blue: \\(blue)\")\n    var greenSorted = green.sorted(by: >)\n    var blueSorted = blue.sorted(by: >)\n    \n    while greenSorted.count > 0 && blueSorted.count > 0 {\n        let numberOfBattlesInRound = min(blueSorted.count, greenSorted.count, battlefield)\n        \n        for i in 0..<numberOfBattlesInRound {\n            let blueStrength = blueSorted[i]\n            let greenStrength = greenSorted[i]\n            greenSorted[i] -= blueStrength\n            blueSorted[i] -= greenStrength\n        }\n        \n        greenSorted.removeAll(where: { $0 <= 0 })\n        blueSorted.removeAll(where: { $0 <= 0 })\n        \n        greenSorted.sort(by: >)\n        blueSorted.sort(by: >)\n    }\n    \n    var resultMessage = \"\"\n    \n    if greenSorted.count == 0 && blueSorted.count == 0 {\n        resultMessage = \"Green and Blue died\"\n    } else if greenSorted.count == 0 {\n        resultMessage = \"Blue wins: \" + blueSorted.sorted(by: >).map { String($0) }.joined(separator: \" \")\n    } else if blueSorted.count == 0 {\n        resultMessage = \"Green wins: \" + greenSorted.sorted(by: >).map { String($0) }.joined(separator: \" \")\n    }\n    \n    return resultMessage\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342579,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n\n  var sortedGreen = green.sorted { $0 > $1 }\n  var sortedBlue = blue.sorted { $0 > $1 }\n  \n  while !sortedGreen.allSatisfy({ $0 == 0 }) && !sortedBlue.allSatisfy ({ $0 == 0 }) {\n    for i in 0..<min(battlefield, sortedGreen.count, sortedBlue.count) {\n      let greenWins = sortedGreen[i] - sortedBlue[i]\n      sortedGreen[i] = greenWins > 0 ? greenWins : 0\n      sortedBlue[i] = greenWins < 0 ? abs(greenWins) : 0\n    }\n    sortedGreen.sort { $0 > $1 }\n    sortedBlue.sort { $0 > $1 }\n  }\n  \n  sortedGreen.removeAll(where: { $0 == 0 })\n  sortedBlue.removeAll(where: { $0 == 0 })\n  \n  let greenLoses = sortedGreen.isEmpty\n  let blueLoses = sortedBlue.isEmpty\n  \n  let result = (greenLoses, blueLoses)\n  \n  switch result {\n    case (true, true):\n      return \"Green and Blue died\"\n    case (false, true):\n      return \"Green wins: \\(sortedGreen.map {String($0)}.joined(separator:\" \"))\"\n    case (true, false):\n      return \"Blue wins: \\(sortedBlue.map {String($0)}.joined(separator:\" \"))\"\n    default:\n      return \"error\"\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342580,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n  print(battlefield, green, blue)\n  var green = green.sorted(by: >)\n  var blue = blue.sorted(by: >)\n  \n  while(green.count > 0 && blue.count > 0) {\n    let battlefields = min(battlefield, min(green.count, blue.count))\n    let best_green = green.prefix(battlefields)\n    let best_blue = blue.prefix(battlefields)\n    green.removeFirst(best_green.count)\n    blue.removeFirst(best_blue.count)\n    \n    for i in 0..<battlefield {\n      if best_green.count > i && best_blue.count > i {\n        if best_green[i] > best_blue[i] {\n          green.append(best_green[i] - best_blue[i])\n        } else if best_green[i] < best_blue[i] {\n          blue.append(best_blue[i] - best_green[i])\n        }\n      }\n    }\n    \n    green.sort(by: >)\n    blue.sort(by: >)\n  }\n  \n  if green.count == 0 && blue.count == 0 { return \"Green and Blue died\" }\n  if green.count == 0 { return \"Blue wins: \" + blue.map { String($0) }.joined(separator: \" \") }\n  return \"Green wins: \" + green.map { String($0) }.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342581,"user_id":null,"body":"func lemmingBattle(_ battlefield: Int, _ green: [Int], _ blue: [Int]) -> String {\n    var green = green.sorted(by: >)\n    var blue = blue.sorted(by: >)\n    let numberOfBattles = min(green.count, blue.count, battlefield)\n    var greenFighters: [Int] = []\n    var blueFighters: [Int] = []\n    for _ in 1...numberOfBattles {\n        var greenFighter = green.first!\n        green = Array(green.dropFirst())\n        var blueFighter = blue.first!\n        blue = Array(blue.dropFirst())\n        if greenFighter > blueFighter {\n            greenFighter -= blueFighter\n            greenFighters.append(greenFighter)\n        } else if greenFighter < blueFighter {\n            blueFighter -= greenFighter\n            blueFighters.append(blueFighter)\n        }\n    }\n    green.append(contentsOf: greenFighters)\n    blue.append(contentsOf: blueFighters)\n\n    if green.isEmpty && blue.isEmpty {\n        return \"Green and Blue died\"\n    } else if green.isEmpty {\n        return \"Blue wins: \\(blue.sorted(by: >).map(String.init).joined(separator: \" \"))\"\n    } else if blue.isEmpty {\n        return \"Green wins: \\(green.sorted(by: >).map(String.init).joined(separator: \" \"))\"\n    }\n\n    return lemmingBattle(battlefield, green, blue)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5bb3e299484fcd5dbb002912":[{"id":342582,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int {\n    var b = balls, n = 0\n    while b > 0 {\n        n += 1\n        b = b - n\n    }\n    return b == 0 ? n : n - 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342583,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int {\n  (Int(sqrt(1.0 + 8.0 * Double(balls))) - 1) \/ 2\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342584,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int {\n  let squareDiscriminant: Double = sqrt(1 + 8 * Double(balls))\n  return max(Int(-0.5 - squareDiscriminant \/ 2), Int(-0.5 + squareDiscriminant \/ 2))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342585,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int{\n  var currLevel = 0\n  var ballsLeft = balls\n  \n  repeat {\n    currLevel += 1\n    ballsLeft -= currLevel\n  } while ballsLeft >= 0\n  \n  return currLevel - 1\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342586,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int {\n  var l = 0\n  var s = 0\n  \n  while s + l < balls {\n    l += 1\n    s += l\n  }\n  \n  return l\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342587,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int{\n    var pyramidArray: [Int] = []\n    var index = 1\n    var level = 1\n  \n    repeat {\n        level += 1\n        pyramidArray.append(index)\n        index = index + level\n    } while index <= balls\n  \n    return pyramidArray.count\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342588,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int{\n\n  \n  \n  var count = 0\nvar ballsVariable = balls\n\nwhile ballsVariable > 0 {\ncount += 1\nballsVariable = ballsVariable - count\n} \n if ballsVariable < 0 {return count - 1} \n  \n  return count \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342589,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int {\n    var balls = balls\n    var i = 1\n    \n    while balls >= i {\n        balls -= i\n        i += 1\n    }\n    return i - 1\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342590,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int{\n  var row = 0\n  var totalBallsInRow = 1\n  var totalBalls = 1\n  while totalBalls <= balls {\n    totalBallsInRow += 1\n    totalBalls += totalBallsInRow\n    row += 1\n  }\n  return row\n  \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342591,"user_id":null,"body":"func pyramid(_ balls: Int) -> Int{\n  let f : Double = (sqrt(Double((1 + 8 * balls))) - 1) \/ 2\n        return Int(f.rounded(.down))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5bb804397274c772b40000ca":[{"id":342592,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n    return layers > 0 ? 3.0.squareRoot() * (Double(layers) - 1) \/ 2 + 1 : 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342593,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n  \/\/ Your code here!\n  guard layers != 0 else { return 0.0 }\n  let double = Double(layers - 1)\n  return (pow(double, 2) - pow((double\/2), 2)).squareRoot() + 1.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342594,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n  return (layers == 0) ? 0.0 : ((Double(layers) - 1) * sqrt(3) \/ 2 + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342595,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n return layers == 0 ? 0 : (Double(layers - 1) * sqrt(3) \/ 2) + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342596,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n    guard layers != 0 else { return 0 }\n    return layers == 1 ? 1 : (((0.86602 * Double(layers - 1)) * 1000).rounded(.awayFromZero) ) \/ 1000 + 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342597,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n  return layers < 1 ? 0.0 : (layers > 1 ? (1 + (Double(layers) - 1) * 0.86602) : 1.0)\n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342598,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n  guard layers > 0 else {return 0.0}\n  return 1.0 + (Double(layers) - 1.0) * sqrt(3.0) \/ 2.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342599,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n  if layers == 0 {\n    return 0\n  }\n  var answer: Double = 1.0 + Double(layers - 1) * 0.5 * sqrt(3)\n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342600,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n    guard layers > 0 else {\n        return 0\n    }\n    let h : Double  = sqrt(3.0)\/2\n    return h*(Double(layers)-1)+1.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342601,"user_id":null,"body":"func stackHeight2D(_ layers: Int) -> Double {\n  var result = Double(1)\n  var tmp = 1\n  if layers != 0 {\n  while tmp < layers { \n    result += 1 - 0.134\n    tmp += 1\n  }\n  } else { \n    result = 0\n  }\n  return layers > 80 ? result + 0.002 : result + 0.001\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5c5086287bc6600001c7589a":[{"id":342602,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n  return String(n) == \"-0.0\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342603,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n  return n.sign == FloatingPointSign.minus && n == 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342604,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n  String(n) == \"-0.0\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342605,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n return n.sign == .minus && n == -0.0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342606,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n    let neg: CGFloat = -0.0\n    let x: CGFloat = CGFloat(n)\n    return x == neg && x.sign == neg.sign\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342607,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n  if n.isInfinite { return !n.isInfinite }\n  return n.isZero ? n.sign != Float(0.0).sign : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342608,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool \n{\n  if n == 0.0 && n.sign == FloatingPointSign.minus\n  {\n    return true\n  }\n  else \n  {\n    return false\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342609,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n  return n == 0 && n.sign == .minus\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342610,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n    String(n) == \"-0.0\" ? true : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342611,"user_id":null,"body":"func isNegativeZero(_ n: Float) -> Bool {\n    return n == 0 && n.sign == .minus ? true : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5c8bfa44b9d1192e1ebd3d15":[{"id":342612,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n let ind = Array(queue.reversed()).firstIndex(where: { $0 == \"wolf\" })\n  return ind! == 0 ? \"Pls go away and stop eating my sheep\" : \"Oi! Sheep number \\(ind!)! You are about to be eaten by a wolf!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342613,"user_id":53,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n  let i = queue.count - queue.index(of: \"wolf\")! - 1\n  return i == 0 \n    ? \"Pls go away and stop eating my sheep\" \n    : \"Oi! Sheep number \\(i)! You are about to be eaten by a wolf!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342614,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n    let wolfindex = queue.firstIndex(of: \"wolf\") ?? 0\n    return queue.last == \"wolf\" ? \"Pls go away and stop eating my sheep\" : \"Oi! Sheep number \\(queue.count - wolfindex - 1)! You are about to be eaten by a wolf!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342615,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n  \/\/var i:Int = queue.count-1\n  var ind:Int = queue.count-1\n  for i in (0...queue.count-1)  {\n    if queue[i] == \"wolf\"{\n      if i == queue.count - 1{\n        return \"Pls go away and stop eating my sheep\"\n      }\n      else{\n        ind = queue.count-1 - i\n        return \"Oi! Sheep number \\(ind)! You are about to be eaten by a wolf!\"\n      }\n      \n    }\n \n  }\n   return \"Error\"\n  }\n  \n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342616,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n    queue.firstIndex(of: \"wolf\") == (queue.count - 1) ? \"Pls go away and stop eating my sheep\" : \"Oi! Sheep number \\(((queue.count)) - ((queue.firstIndex(of: \"wolf\") ?? 0) + 1))! You are about to be eaten by a wolf!\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342617,"user_id":null,"body":"func messageFor(_ n: Int?) -> String {\n    guard let n = n else {\n        return \"No wolves here\"\n    }\n    switch n {\n    case 0:\n        return \"Pls go away and stop eating my sheep\"\n    default:\n        return \"Oi! Sheep number \\(n)! You are about to be eaten by a wolf!\"\n    }\n}\n\nfunc warn_the_sheep(_ queue: [String]) -> String {\n    messageFor(queue.reversed().firstIndex(of: \"wolf\"))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342618,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n    let reversed = queue.reduce([],{ [$1] + $0 })\n    guard reversed.first != \"wolf\" else { return \"Pls go away and stop eating my sheep\" }\n    var n: Int = .zero\n    for (i,str) in reversed.enumerated() {\n        if str == \"wolf\" { return \"Oi! Sheep number \\(n)! You are about to be eaten by a wolf!\" }\n        n = i + 1\n    }\n    fatalError() \/\/ :)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342619,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n  guard let indexOfWolf = queue.firstIndex(of: \"wolf\") else { return \"No wolf\" }\n  let sheepPosition = queue.count - (indexOfWolf + 1)\n  return indexOfWolf == (queue.count - 1) ? wolfMessage : sheepMessage(at: sheepPosition)\n}\n\nfunc sheepMessage(at position: Int) -> String {\n  \"Oi! Sheep number \\(position)! You are about to be eaten by a wolf!\" \n}\n\nlet wolfMessage = \"Pls go away and stop eating my sheep\"","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342620,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n    var sheeps = queue.count\n    for item in queue.reversed() {\n        sheeps -= 1\n        if item == \"wolf\" && sheeps == queue.count - 1 {\n            return \"Pls go away and stop eating my sheep\"\n        } else if item == \"wolf\" {\n            return \"Oi! Sheep number \\(queue.count - sheeps - 1)! You are about to be eaten by a wolf!\"\n        }\n    }\n    return \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342621,"user_id":null,"body":"func warn_the_sheep(_ queue: [String]) -> String {\n  let line:[String]=queue.reversed()\n  for i in 0..<line.count {\n    if line[i]==\"wolf\" {\n      if i==0 {\n        return \"Pls go away and stop eating my sheep\"\n      }\n      else {\n        return \"Oi! Sheep number \\(i)! You are about to be eaten by a wolf!\"\n      }\n    }\n  }\n  return \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5ce9c1000bab0b001134f5af":[{"id":342622,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n  switch month {\n    case 0...3: return 1\n    case 3...6: return 2\n    case 6...9: return 3\n    default : return 4\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342623,"user_id":527,"body":"func quarter(of month: Int) -> Int {\n  return (month + 2) \/ 3\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342624,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n  var quarter = 0\n  switch month {\n    case 1...3:\n    quarter = 1\n    return 1\n    case 4...6:\n    quarter = 2\n    return 2\n    case 7...9:\n    quarter = 3\n    return 3\n    case 10...12:\n    quarter = 4\n    return 4\n    default:\n    break\n  }\n  return quarter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342625,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n    Int((Double(month) \/ 3).rounded(.up))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342626,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n  let quarterDic = [1:1, 2:1, 3:1, 4:2, 5:2, 6:2, 7:3, 8:3, 9:3, 10:4, 11:4, 12:4]\n  return quarterDic[month]!\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342627,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n    return (month + 2) \/ 3 \/\/ OK\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342628,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n      guard month >= 1 && month <= 12 else {\n        return 0\n    }\n    return (month <= 3) ? 1 : ((month <= 6) ? 2 : ((month <= 9) ? 3 : 4))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342629,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n    var quarter = 0\n    let quarterRanges: [[Int] : Int] =\n        [[1,2,3]: 1,\n         [4,5,6]: 2,\n         [7,8,9]: 3,\n         [10,11,12]: 4]\n\n    for (m, q) in quarterRanges {\n        if m.contains(month) {\n            quarter = q\n        }\n    }\n\n    return quarter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342630,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n  return Int(floor((Double(month) + 2) \/ 3))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342631,"user_id":null,"body":"func quarter(of month: Int) -> Int {\n  var quarter: Int\n  switch month {\n  case 1...3: \n    quarter = 1   \n  case 4...6: \n    quarter = 2\n  case 7...9: \n    quarter = 3\n  default:\n    quarter = 4\n  }\n  return quarter\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d23d89906f92a00267bb83d":[{"id":342632,"user_id":null,"body":"import Foundation\n\nfunc getOrder(_ input: String) -> String {\n    let menu = [\"Burger\", \"Fries\", \"Chicken\", \"Pizza\", \"Sandwich\", \"Onionrings\", \"Milkshake\", \"Coke\"]\n    \n    return menu.reduce([]) {\n      $0 + Array(repeating: $1, count: input.components(separatedBy: $1.lowercased()).count - 1)\n    }.joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342633,"user_id":null,"body":"import Foundation\n\nfunc getOrder(_ input: String) -> String {\n  var order = \"\"\n\tvar menu = [(\"Burger\", 0), (\"Fries\", 0), (\"Chicken\", 0), (\"Pizza\", 0),\n\t\t\t\t(\"Sandwich\", 0), (\"Onionrings\", 0), (\"Milkshake\", 0), (\"Coke\", 0)]\n\tfor (index, value) in menu.enumerated() {\n\t\tvar val = value\n\t\tval.1 = input.components(separatedBy: val.0.lowercased()).count - 1\n\t\tmenu[index] = val\n\t}\n\tmenu.forEach {\n\t\tvar index = 1\n\t\twhile index <= $0.1  {\n\t\t\torder = \"\\(order) \\($0.0)\"\n\t\t\tindex += 1\n\t\t}\n\t}\n\treturn String(order.dropFirst())\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342634,"user_id":null,"body":"import Foundation\n\nfunc getOrder(_ input: String) -> String {\n    var foodItems = \"\"\n    let possibleItems = [\"Burger\", \"Fries\", \"Chicken\", \"Pizza\", \"Sandwich\", \"Onionrings\", \"Milkshake\", \"Coke\"]\n    \n    possibleItems.forEach { food in\n        for _ in 0..<(input.components(separatedBy: food.lowercased()).count - 1) {\n            foodItems += \" \" + food\n        }\n    }\n    \n    return foodItems.trimmingCharacters(in: .whitespaces)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342635,"user_id":null,"body":"import Foundation\n\n\nlet menu: [String] = [\n    \"Burger\",\n    \"Fries\",\n    \"Chicken\",\n    \"Pizza\",\n    \"Sandwich\",\n    \"Onionrings\",\n    \"Milkshake\",\n    \"Coke\"\n]\n\n\nfunc getOrder(_ input: String) -> String {\n    var result: [String] = [], count: Int\n    for item_menu in menu {\n        count = input.components(separatedBy: item_menu.lowercased()).count - 1\n        for _ in 0..<count {\n            result.append(item_menu)\n        }\n    }\n    return result.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342636,"user_id":null,"body":"func getOrder(_ input: String) -> String {\n  \n  let burger: Int = input.components(separatedBy:\"burger\").count - 1\n  let fries: Int = input.components(separatedBy:\"fries\").count - 1\n  let chicken: Int = input.components(separatedBy:\"chicken\").count - 1\n  let pizza: Int = input.components(separatedBy:\"pizza\").count - 1\n  let sandwich: Int = input.components(separatedBy:\"sandwich\").count - 1\n  let onionrings: Int = input.components(separatedBy:\"onionrings\").count - 1\n  let milkshake: Int = input.components(separatedBy:\"milkshake\").count - 1\n  let coke: Int = input.components(separatedBy:\"coke\").count - 1\n  \n  let result: String =  String(repeating: \"Burger \", count: burger) + \n                        String(repeating: \"Fries \", count: fries) +\n                        String(repeating: \"Chicken \", count: chicken) +\n                        String(repeating: \"Pizza \", count: pizza) +\n                        String(repeating: \"Sandwich \", count: sandwich) +\n                        String(repeating: \"Onionrings \", count: onionrings) +\n                        String(repeating: \"Milkshake \", count: milkshake) +\n                        String(repeating: \"Coke \", count: coke)\n  \n  return result.trimmingCharacters(in: .whitespacesAndNewlines)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342637,"user_id":null,"body":"import Foundation\n\nfunc getOrder(_ input: String) -> String {\n    func numFunc(str: String) -> Int {\n        switch str {\n        case \"Burger\":\n        return 1\n        case \"Fries\":\n        return 2\n        case \"Chicken\":\n        return 3\n        case \"Pizza\":\n        return 4\n        case \"Sandwich\":\n        return 5\n        case \"Onionrings\":\n        return 6\n        case \"Milkshake\":\n        return 7\n        case \"Coke\":\n        return 8\n        default:\n            0\n        }\n        return 0\n    }\n    \n    var str = \"\"\n    var strArr: [String] = []\n    \n    for i in input {\n        str.append(i)\n        if str == \"burger\" || str == \"fries\" || str == \"chicken\" || str == \"pizza\" || str == \"sandwich\" || str == \"onionrings\" || str == \"milkshake\" || str == \"coke\" {\n            strArr.append(str.capitalized)\n            str = \"\"\n        }\n    }\n    return strArr.sorted {numFunc(str: $0) < numFunc(str: $1)}.joined(separator: \" \")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342638,"user_id":null,"body":"import Foundation\n\nfunc getOrder(_ input: String) -> String {\n    var finalString: [String] = []\n    let menu = [\"Burger\", \"Fries\", \"Chicken\", \"Pizza\", \"Sandwich\", \"Onionrings\", \"Milkshake\", \"Coke\"]\n    \n    menu.forEach { item in\n        var searchStartIndex = input.startIndex\n        while\n            searchStartIndex < input.endIndex,\n            let range = input.range(of: item, options: .caseInsensitive, range: searchStartIndex..<input.endIndex),\n            !range.isEmpty\n        {\n            finalString.append(item)\n            searchStartIndex = range.upperBound\n        }\n    }\n    \n    return finalString.joined(separator: \" \")\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342639,"user_id":null,"body":"extension String {\n\n    var length: Int {\n        return count\n    }\n\n    subscript (i: Int) -> String {\n        return self[i ..< i + 1]\n    }\n\n    func substring(fromIndex: Int) -> String {\n        return self[min(fromIndex, length) ..< length]\n    }\n\n    func substring(toIndex: Int) -> String {\n        return self[0 ..< max(0, toIndex)]\n    }\n\n    subscript (r: Range<Int>) -> String {\n        let range = Range(uncheckedBounds: (lower: max(0, min(length, r.lowerBound)),\n                                            upper: min(length, max(0, r.upperBound))))\n        let start = index(startIndex, offsetBy: range.lowerBound)\n        let end = index(start, offsetBy: range.upperBound - range.lowerBound)\n        return String(self[start ..< end])\n    }\n}\n\nimport Foundation\n\nfunc getOrder(_ input: String) -> String {\n    let  order : [String] = [\"Burger\", \"Fries\", \"Chicken\", \"Pizza\", \"Sandwich\", \"Onionrings\", \"Milkshake\",\"Coke\"]\n    var i = 0\n    var food :[String] = []\nlet temp = input.lowercased()\n    whileloop:  while i < temp.count{\n    switch temp[i]{\n            case \"b\":\n             i += 6\n             food.append(\"Burger\")\n    case \"f\":\n        i += 5\n        food.append(\"Fries\")\n    case \"c\" :\n        if temp[i+1] == \"h\"{\n            i += 7\n            food.append(\"Chicken\")\n        }\n        else{\n            i += 4\n            food.append(\"Coke\")\n        }\n    case \"p\":\n        i += 5\n        food.append(\"Pizza\")\n    case \"s\" :\n        i += 8\n        food.append(\"Sandwich\")\n    case \"o\" :\n        i += 10\n        food.append(\"Onionrings\")\n    case \"m\" :\n        i += 9\n        food.append(\"Milkshake\")\n        \n    default:\n        return \"ERROR\"\n        }\n     if i >= temp.count{\n        break whileloop\n    }\n    }\n    var numOfFood :[Int] = [0 ,0 , 0 ,0 ,0 ,0 ,0 ,0]\n   \n    for nfood in food {\n        switch nfood{\n        case \"Burger\":\n            numOfFood[0] += 1\n        case \"Fries\":\n        numOfFood[1] += 1\n        case \"Chicken\":\n        numOfFood[2] += 1\n        case \"Pizza\":\n        numOfFood[3] += 1\n        case \"Sandwich\":\n        numOfFood[4] += 1\n        case \"Onionrings\":\n        numOfFood[5] += 1\n        case \"Milkshake\":\n        numOfFood[6] += 1\n        case \"Coke\":\n        numOfFood[7] += 1\n        default:\n            return \"ERROR 404 !!!!\"\n        }\n    }\n    var result = \"\"\n    var j = 0\n    for index in 0..<numOfFood.count{\n        j = 0\n        while j < numOfFood[index]{\n            result += order[index] + \" \"\n            j += 1\n        }\n    }\n     if !result.isEmpty{\n    result.removeLast()\n    }\n        return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342640,"user_id":null,"body":"let menu: [String] = [\"burger\", \"fries\", \"chicken\", \"pizza\", \"sandwich\", \"onionrings\", \"milkshake\", \"coke\"]\n\n\/\/\"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza\"\n\nfunc getOrder(_ input: String) -> String {\n    var tmp: String = \"\"\n    var result: [String] = []\n\n    for char in input {\n        tmp.append(char)\n        if menu.contains(tmp) {\n            result.append(tmp)\n            tmp.removeAll()\n        }\n    }\n\n    result.sort { first, second in\n        (menu.firstIndex(of: first)!) < (menu.firstIndex(of: second)!)\n    }\n\n    for index in 0..<result.count {\n        tmp.append(index == result.count - 1 ? \"\\(result[index].capitalized)\" : \"\\(result[index].capitalized) \")\n    }\n\n    return tmp\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342641,"user_id":null,"body":"let menu: [String] = [\"burger\", \"fries\", \"chicken\", \n                      \"pizza\", \"sandwich\", \"onionrings\", \n                      \"milkshake\", \"coke\"]\n\nfunc getOrder(_ input: String) -> String {\n  return menu.map { [String](repeating: $0, count: input.components(separatedBy: $0).count - 1).joined(separator: \" \") }\n             .filter { $0 != \"\" }\n             .joined(separator: \" \")\n             .capitalized\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d50e3914861a500121e1958":[{"id":342642,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n    let sum = (letters.map { Int($0.asciiValue! - 96) }.reduce(0, +) + 25) % 26 + 97\n    return Character(UnicodeScalar(sum)!)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342643,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n    var dictionary: [Character : Int] = [\"a\" : 1, \"b\" : 2, \"c\" : 3, \"d\" : 4, \"e\" : 5, \"f\" : 6, \"g\" : 7, \"h\" : 8, \n    \"i\" : 9, \"j\" : 10, \"k\" : 11, \"l\" : 12, \"m\" : 13, \"n\" : 14, \"o\" : 15, \"p\" : 16, \"q\" : 17, \"r\" : 18,\n     \"s\" : 19, \"t\" : 20, \"u\" : 21, \"v\" : 22, \"w\" : 23, \"x\" : 24, \"y\" : 25, \"z\" : 26]\n     \n     var sum = 0\n     \n     for letter in letters {\n       sum += dictionary[(letter)] ?? 0\n     }\n     while sum > 26 {\n       sum = sum - 26\n     }\n     \n     for (key, value) in dictionary {\n       if value == sum {\n         return key\n       }\n     }\n     return \"z\"\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342644,"user_id":null,"body":"let alphabet: [Character] = Array(\"abcdefghijklmnopqrstuvwxyz\")\n\nfunc add_letters(_ letters: [Character]) -> Character {\n    return alphabet[letters.reduce(into: 25, { $0 += alphabet.firstIndex(of: $1)! + 1 }) % 26]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342645,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n  if letters.isEmpty {\n  return \"z\"\n} \nlet leters = String (letters)  \nvar sum = 25\nfor code in leters.utf8 {\n    sum = sum + (Int(code) - 96 ) \n}\nif sum >= 26 {\n  sum = sum % 26 \n}\nreturn Character (UnicodeScalar(UInt8(sum + 97)))\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342646,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n    let aToZ = (97...122).map({Character(UnicodeScalar($0))})\n    var carDictionary: [Character:Int] = [:]\n    var empArr = [Int]()\n    var i = 0\n    if letters.count == 0 {\n        return \"z\"\n    }\n    while i < aToZ.count {\n        carDictionary[aToZ[i]] = i + 1\n        i = i + 1\n    }\n    for item in letters {\n        for (key, value) in carDictionary {\n                if item == key {\n                    empArr.append(value)\n            }\n        }\n    }\n    let totalValue = rec(empArr.reduce(0, +))\n    let letterGotten = aToZ[totalValue-1]\n    return letterGotten\n}\n\nfunc rec(_ val: Int) -> Int {\n    var aa = val\n    if aa > 26 {\n        aa = aa - 26\n    }\n    return aa <= 26 ? aa : rec(aa)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342647,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n    if letters.isEmpty { return \"z\" }\n    let characterArray: [Character] = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    var finalIndex = -1\n    for letter in letters {\n        for index in stride(from: 0, to: characterArray.count, by: 1) {\n            if letter == characterArray[index] {\n                finalIndex = finalIndex + (index+1)\n            }\n        }\n    }\n    return characterArray[finalIndex % 26]\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342648,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n   if letters.isEmpty {\n        return \"z\"\n    }\n  \n    let u = Int((UnicodeScalar(letters.compactMap{Int(UnicodeScalar(String($0))?.value ?? 0) - 96}.reduce(0, +))!.value))\n    if (u % 26) == 0 {\n        return Character(String(UnicodeScalar( 26 + 96)!).lowercased())\n    }\n    return  Character(String(UnicodeScalar( (u % 26) + 96)!).lowercased())\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342649,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n    let numbers = letters.map {ch in ch.asciiValue! - 96}\n    let sum = numbers.reduce(0, +) % 26 \n    let result = Character(UnicodeScalar((sum == 0 ? 26 : sum) + 96))\n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342650,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n    let sum = letters.reduce(into: 25) { $0 += $1.asciiValue! - 96 }    \n    return Character.init(.init((sum % 26) + 97))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342651,"user_id":null,"body":"func add_letters(_ letters: [Character]) -> Character {\n\tlet allStr = \"zabcdefghijklmnopqrstuvwxyz\"\n\tlet\tallChars = Array(allStr)\n\tvar sum = 0\n\tfor letter in letters {\n\t\tif let index = allChars.firstIndex(of: letter) {\n\t\t\tsum += index\n\t\t\tif sum > (allChars.count - 1) {\n\t\t\t\tsum = sum - (allChars.count - 1)\n\t\t\t}\n\t\t}\n\t}\n\treturn allChars[sum]\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5d5ee4c35162d9001af7d699":[{"id":342652,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n    return numbers.compactMap{$0.min()}.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342653,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n    var sum = 0\n    \n    for i in 0...numbers.count - 1 {\n        sum += numbers[i].min()!\n    }\n    return sum\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342654,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n    var summ = 0\n    numbers.forEach { summ += $0.min() ?? 0 }\n    return summ\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342655,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n  numbers.reduce(0, {x, y in x + (y.min() ?? 0)})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342656,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n  return numbers.map { $0.min()! }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342657,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n    var result = 0\n    for numberArr in numbers {\n        var min = numberArr[0]\n        for number in numberArr {\n            if number < min {\n                min = number\n            }\n        }\n        result += min\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342658,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n  numbers.reduce(.zero) { $0 + ($1.min() ?? .zero) }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342659,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n        let result = numbers\n            .map { $0.min()! }\n            .reduce(0, +)        \n        return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342660,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n    numbers.compactMap { $0.sorted().first }.reduce(0, +)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342661,"user_id":null,"body":"func sumOfMinimums(_ numbers: [[Int]]) -> Int {\n    var result = 0\n    var numberSort: [Int]\n    for i in numbers {\n        numberSort = i.sorted(by: < )\n        result += numberSort[0]\n    \n    }\nreturn result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5dd82b7cd3d6c100109cb4ed":[{"id":342662,"user_id":464,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n    if n == 0 {\n      return []\n    }\n    var frontier = Set(agents.filter { xy in\n        let x = xy[0]\n        let y = xy[1]\n        return 0 <= x && x < n && 0 <= y && y < n\n    })\n    var bag: Set<[Int]> = Set()\n    for x in 0...(n-1) {\n        for y in 0...(n-1) {\n            bag.insert([x, y])\n        }\n    }\n    if frontier == bag {\n        return []\n    }\n    while frontier.count > 0 && bag.isStrictSuperset(of: frontier) {\n        bag.subtract(frontier)\n        var newFrontier: Set<[Int]> = Set()\n        for coordinate in frontier {\n            let x = coordinate[0]\n            let y = coordinate[1]\n            for (nx, ny) in [(x+1, y), (x-1,y), (x, y+1), (x, y-1)] {\n                if bag.contains([nx, ny]) {\n                    newFrontier.insert([nx, ny])\n                }\n            }\n        }\n        frontier = newFrontier\n    }\n    return Array(bag)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342663,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n  \n  func valid(_ x: Int, _ y: Int) -> Bool {\n    x >= 0 && y >= 0 && x < n && y < n\n  }\n  \n  guard n > 0 else { return [] }\n  \n  let validAgents = agents.filter { valid($0[0], $0[1]) }\n\n  var res = Array(repeating: Array(repeating: Int.max, count: n), count: n)  \n  var step = 0\n  var hasChanges: Bool\n  \n  repeat {\n    hasChanges = false\n    validAgents.forEach {\n      for round in 0...step {\n        let x1 = $0[0] + round\n        let x2 = $0[0] - round\n        let y1 = $0[1] + step - round\n        let y2 = $0[1] - step + round\n        \n        if valid(x1, y1) && res[x1][y1] == Int.max { res[x1][y1] = step; hasChanges = true }\n        if valid(x1, y2) && res[x1][y2] == Int.max { res[x1][y2] = step; hasChanges = true }\n        if valid(x2, y1) && res[x2][y1] == Int.max { res[x2][y1] = step; hasChanges = true }\n        if valid(x2, y2) && res[x2][y2] == Int.max { res[x2][y2] = step; hasChanges = true }\n      }\n    }\n    step += 1\n  }\n  while hasChanges\n  \n  let m = res.map({ $0.max()! }).max()!\n  guard m != 0 else { return [] }\n  \n  var ret = [[Int]]()\n  \n  for i in 0..<n {\n    for j in 0..<n where res[i][j] == m {\n      ret.append([i, j])\n    }\n  }\n  \n  return ret\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342664,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n  guard n > 0 else { return [] }\n  var matrix = [[Int]](repeating: [Int](repeating: n * 2, count: n), count: n)\n  var toVisit = agents.map({($0[0], $0[1], 0)})\n  while toVisit.count > 0 {\n    let (x, y, d) = toVisit.removeFirst()\n    if 0..<n ~= x && 0..<n ~= y && matrix[x][y] > d  {\n      matrix[x][y] = d\n      for direction in [[0, 1], [0, -1], [1, 0], [-1, 0]] {\n        toVisit.append((x + direction[0], y + direction[1], d + 1))\n      }\n    }\n  }\n  var result = [[Int]]()\n  var max = 0\n  for i in 0..<n {\n    for j in 0..<n {\n      if matrix[i][j] > max { \n        result = [[i, j]]\n        max = matrix[i][j]\n      }\n      else if matrix[i][j] == max { result.append([i, j]) }\n    }\n  }\n  return max == 0 ? [] : result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342665,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n  let agents = agents.filter({ $0.first! < n && $0.last! < n })\n\n  guard agents.count < n * n else {\n    return [[Int]]()\n  }\n  \n  return generateCity(n, agents)\n}\n\nfunc distance(of place: [Int], from agent: [Int]) -> Int {\n  return abs(place.first! - agent.first!) + abs(place.last! - agent.last!)\n}\n\nfunc generateCity(_ size: Int, _ agents: [[Int]]) -> [[Int]] {\n  var maxDistance = 0\n  var city = [([Int], Int)]()\n  for i in 0 ..< size {\n    for j in 0 ..< size {\n      let place = [i, j]\n      var placeDistance = Int.max\n      for agent in agents {\n        if agent == place {\n          placeDistance = 0\n          break\n        }\n          placeDistance = min(placeDistance, distance(of: place, from: agent))\n        if placeDistance < maxDistance || placeDistance == 1 {\n          break\n        }\n      }\n      if placeDistance >= maxDistance {\n        city.append((place, placeDistance))\n        maxDistance = placeDistance\n      }\n      \n    }    \n  }\n  return city.filter({$0.1 == maxDistance}).map{$0.0}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342666,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n  func surrounding(_ coord: [Int]) -> [[Int]] { \n    let (x,y) = (coord[0],coord[1])\n    return [[x-1,y],[x+1,y],[x,y-1],[x,y+1]] \n  }\n  \n  func isOnGrid(_ coord: [Int]) -> Bool {\n    coord.allSatisfy { (0..<n).contains($0) }\n  }\n  \n  let presentAgents = Set(agents).filter(isOnGrid)\n  guard presentAgents.count != n*n else { return [] }\n  guard !presentAgents.isEmpty else { return (0..<n).flatMap { y in (0..<n).map { x in [x,y] } } }\n  \n  var frontier = presentAgents, visited = frontier\n  while true {\n    let newFrontier = Set(frontier.flatMap(surrounding)).filter(isOnGrid).subtracting(visited)\n    if newFrontier.isEmpty {\n      return Array(frontier)\n    } else {\n      visited.formUnion(newFrontier)\n      frontier = newFrontier\n    }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342667,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n  var city = (0..<n).map { _ in Array(repeating: Int.max, count: n) }\n  var open = agents.compactMap { 0..<n ~= $0[0] && 0..<n ~= $0[1] ? ($0[0], $0[1]) : nil }\n  open.forEach { city[$0.1][$0.0] = 0 }\n  func visit(_ x: Int, _ y: Int, _ value: Int) {\n    guard 0..<n ~= x && 0..<n ~= y else { return }\n    \n    if value < city[y][x] {\n      city[y][x] = value\n      open.append((x, y))\n    }\n  }\n  while !open.isEmpty {\n    let (x, y) = open.removeFirst()\n    let value = city[y][x] + 1\n    visit(x - 1, y, value)\n    visit(x + 1, y, value)\n    visit(x, y - 1, value)\n    visit(x, y + 1, value)\n  }\n  guard let max = city.map { $0.max()! }.max(), max > 0 else { return [] }\n  \n  return city.indices.flatMap { y in\n    city[y].indices.compactMap { x in\n      city[y][x] == max ? (x, y) : nil\n    }\n  }.map { [$0.0, $0.1] }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342668,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n    let array = Array(repeating: 0, count: n)\n    var grid = Array(repeating: array, count: n)\n    var coordinatesToCheck: [[Int]: Bool] = [:]\n    \n    for agentCoordinates in agents {\n        let i = agentCoordinates[0]\n        let j = agentCoordinates[1]\n\n        coordinatesToCheck[[i, j]] = true\n    }\n    \n    var count = -1\n    while coordinatesToCheck.count > 0 {\n        var tempCoordinatesToCheck: [[Int]: Bool] = [:]\n        for coordinate in coordinatesToCheck.keys {\n            \n            let i = coordinate[0]\n            let j = coordinate[1]\n            \n            if i >= 0, j >= 0, i < n, j < n {\n                \n                if count == -1 {\n                    grid[i][j] = count\n                }\n                let results = markNeighbors(i: i, j: j, n: n, count: (count == -1) ? 1 : count, grid: &grid)\n                if results.count > 0 {\n                    for result in results {\n                        tempCoordinatesToCheck[[result.0, result.1]] = true\n                    }\n                }\n\n            }\n            \n        }\n\n        coordinatesToCheck = tempCoordinatesToCheck\n        if count == -1 {\n            count = 1\n        }\n        count += 1\n    }\n        \n    count -= 2\n    \n    var result: [[Int]] = []\n\n    for i in 0..<n {\n        for j in 0..<n {\n            if grid[i][j] == count {\n              result.append([i, j])\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc markNeighbors(i oi: Int,j oj: Int, n: Int, count: Int, grid: inout [[Int]]) -> [(Int, Int)] {\n    var results: [(Int, Int)] = []\n    let ijincrementors = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    for ij in ijincrementors {\n        let i = oi + ij.0\n        let j = oj + ij.1\n        \n        if i >= 0, j >= 0, i < n, j < n {\n            if grid[i][j] == 0 {\n                grid[i][j] = count\n                results.append((i, j))\n            }\n        }\n    }\n    \n    return results\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342669,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n    var city = Array(repeating: Array(repeating: 0, count: n), count: n)\n    var agentsCount = 0\n    for agent in agents {\n        let x = agent[0]\n        let y = agent[1]\n        if x >= 0 && x < n && y >= 0 && y < n {\n            city[x][y] = -1\n            agentsCount += 1\n        }\n    }\n    if n == 0 {\n        return []\n    } else if agentsCount == 0 {\n        var array:[[Int]] = []\n        for i in 0..<n {\n            for j in 0..<n {\n                array.append([i, j])\n            }\n        }\n        return array\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n            if city[i][j] == -1 {\n                continue\n            }\n            var radius = 2\n            var found = false\n            while !found {\n                let range = -radius...radius\n                for x in range {\n                    for y in range {\n                        let x1 = i + x\n                        let y1 = j + y\n                        if x1 < 0 || x1 >= n || y1 < 0 || y1 >= n {\n                            continue\n                        }\n                        if city[x1][y1] == -1 {\n                            let d = abs(x) + abs(y)\n                            if d > radius {\n                                continue\n                            }\n                            found = true\n                            if city[i][j] == 0 {\n                                city[i][j] = d\n                            } else {\n                                city[i][j] = min(d, city[i][j])\n                            }\n                        }\n                    }\n                }\n                radius += 1\n            }\n        }\n    }\n    var maxDistance = 0\n    for street in city {\n        let max = street.max()!\n        if maxDistance < max && max != -1 {\n            maxDistance = max\n        }\n    }\n    if maxDistance == 0 {\n        return []\n    }\n    var safes:[[Int]] = []\n    for i in 0..<n {\n        for j in 0..<n {\n            if city[i][j] == maxDistance {\n                safes.append([i, j])\n            }\n        }\n    }\n    return safes\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342670,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n    \/\/ protect against 0-sized city\n    guard n > 0 else { return [] }\n    \n    \/\/ build city\n    var city: Set<[Int]> = []\n    for i in (0..<n){\n        for j in (0..<n){\n            city.insert([i,j])\n        }\n    }\n    \n    \/\/ protect against agents edge cases\n    let validAgents = Set( agents.filter{ (0..<n).contains($0[0]) && (0..<n).contains($0[1]) })\n    guard validAgents.count > 0 else { return Array(city) }\n    guard validAgents.count < n*n else { return [] }\n    \n    \/\/ city gets smaller and smaller...\n    var notSafe = Set(validAgents)\n    city = city.subtracting(validAgents)\n    \n    for _ in (0 ... 2*n) {\n        var nextSafePlaces = Set<[Int]>()\n        \n        nextSafePlaces = nextSafePlaces\n            .union(notSafe.map{[$0[0] + 1, $0[1]]})\n            .union(notSafe.map{[$0[0] - 1, $0[1]]})\n            .union(notSafe.map{[$0[0], $0[1] + 1]})\n            .union(notSafe.map{[$0[0], $0[1] - 1]})\n        \n        \/\/...until only the safestPlaces exist\n        guard city.subtracting(nextSafePlaces).count > 0 else { break }\n        \n        city = city.subtracting(nextSafePlaces)\n        notSafe = nextSafePlaces\n        \n    }\n    \n    return Array(city)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342671,"user_id":null,"body":"func advice(agents: [[Int]], n: Int) -> [[Int]] {\n    \/\/ protect against 0-sized city\n    guard n > 0 else { return [] }\n    \n    \/\/ build city\n    var city: Set<[Int]> = []\n    for i in (0..<n){\n        for j in (0..<n){\n            city.insert([i,j])\n        }\n    }\n    \n    \/\/ protect against agents edge cases\n    let validAgents = Set( agents.filter{ (0..<n).contains($0[0]) && (0..<n).contains($0[1]) })\n    guard validAgents.count > 0 else { return Array(city) }\n    guard validAgents.count < n*n else { return [] }\n    \n    \n    var notSafe = Set(validAgents)\n    city = city.subtracting(validAgents)\n    \n    for _ in (0 ... 2*n) {\n        var nextSafePlaces = Set<[Int]>()\n        \n        nextSafePlaces = nextSafePlaces\n            .union(notSafe.map{[$0[0] + 1, $0[1]]})\n            .union(notSafe.map{[$0[0] - 1, $0[1]]})\n            .union(notSafe.map{[$0[0], $0[1] + 1]})\n            .union(notSafe.map{[$0[0], $0[1] - 1]})\n        \n        guard city.subtracting(nextSafePlaces).count > 0 else { break }\n        \n        city = city.subtracting(nextSafePlaces)\n        notSafe = nextSafePlaces\n        \n    }\n    \n    return Array(city)\n    \n    \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342672,"user_id":null,"body":"func converter(n:Int) -> [[Int]] {\n    \/\/ \u0434\u0432\u0443\u043c\u0435\u0440\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438\n    var matrix:[[Int]]=[]\n    for j in 0..<n {\n        for i in 0..<n {\n            matrix.append([i,j])\n        }\n    }\n    return matrix\n}\n\nfunc advice(agents: [[Int]], n: Int) -> [[Int]] {\n  \n  print(\"______________________\")\n  print(\"n=\\(n)\")\n  print(\"agents: \\(agents)\")\n  print(\"______________________\")\n\n    var array:[Int]=[]\n    \n    for i in 0..<n*n {\n        array.append(i)\n    }\n    \n    guard n != 0 else {return []}\n    guard !agents.isEmpty else {return converter(n: n)}\n    \n    var dictionary:[Int:Int]=[:]\n    array.map({dictionary[$0]=0})\n    \n    var visited=Array(repeating: false, count: n*n)\n    var queue:[Int]=[]\n\n    \/\/ agents in queue\n    for agent in agents {\n        let i=agent[0]\n        let j=agent[1]\n        let value=j*n+i\n        if value<0 || value>=(n*n) {continue}\n        queue.append(value)\n        visited[value]=true\n    }\n    \n    guard !queue.isEmpty else {return converter(n: n)}\n    \n    var index=0\n        \n    while index<queue.count {\n\n        let node=queue[index]\n        \n        \/\/left\n        if node%n != 0 {\n            if !visited[node-1] {\n                queue.append(node-1)\n                visited[node-1]=true\n                dictionary[node-1]=dictionary[node]!+1\n            }\n        }\n        \/\/ right\n        if (node+1)%n != 0  {\n            if !visited[node+1] {\n                queue.append(node+1)\n                visited[node+1]=true\n                dictionary[node+1]=dictionary[node]!+1\n            }\n        }\n        \/\/up\n        if node-n >= 0 {\n            if !visited[node-n] {\n                queue.append(node-n)\n                visited[node-n]=true\n                dictionary[node-n]=dictionary[node]!+1\n            }\n        }\n        \/\/down\n        if node+n<n*n {\n            if !visited[node+n] {\n                queue.append(node+n)\n                visited[node+n]=true\n                dictionary[node+n]=dictionary[node]!+1\n            }\n            \n        }\n        \n        index+=1\n    }\n\n    let max=dictionary[queue.last!]!\n    guard max != 0 else {return []}\n    let result=dictionary.filter({$0.value==max}).keys.map({[$0%n, $0\/n]})\n\n  print(\"\u043c\u043e\u0439 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \\(result)\")\n  \n    return result\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5e4d8a53b499e20016b018a0":[{"id":342673,"user_id":168,"body":"func decode(_ seq: String) -> [Int] {\n  var res: [Int] = []\n  var s = Substring(seq)\n  while let i = s.firstIndex(of: \"1\") {\n    let n = 2 * s.distance(from: s.startIndex, to: i) + 1\n    res.append(Int(s.prefix(n), radix: 2)! - 1)\n    s = s.dropFirst(n)\n  }\n  return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342674,"user_id":null,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n    var result: [Int] = []\n    var s = Substring(expGolombSequence)\n    while let i = s.firstIndex(of: \"1\") {\n        let n = 2 * s.distance(from: s.startIndex, to: i) + 1\n        result.append((Int(s.prefix(n), radix: 2) ?? 0) - 1)\n        s = s.dropFirst(n)\n    }\n    return result \/\/ OK\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342675,"user_id":220,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n  \n  var result: [Int] = []\n  let idx = expGolombSequence.startIndex\n  let endIdx = expGolombSequence.endIndex\n  var seq = expGolombSequence[idx ..< endIdx]\n  while !seq.isEmpty {\n    let onePos = seq.firstIndex(of: \"1\")!\n    let dst = seq.distance(from: seq.startIndex, to: onePos)\n    let endPos = seq.index(onePos, offsetBy: dst + 1)\n    let binNum = seq[onePos ..< endPos]\n    let num = Int(binNum, radix: 2)! - 1\n    result.append(num)\n    seq = seq[endPos ..< seq.endIndex]\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342676,"user_id":null,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n    var result: [Int] = []\n    var s = Substring(expGolombSequence)\n    while let i = s.firstIndex(of: \"1\") {\n        let n = 2 * s.distance(from: s.startIndex, to: i) + 1\n        result.append((Int(s.prefix(n), radix: 2) ?? 0) - 1)\n        s = s.dropFirst(n)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342677,"user_id":null,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n    var ints: [Int] = []\n    var len: Int = 0\n    var lenZ: Bool = true\n    var temp: String = \"\"\n    \n    for d in expGolombSequence {\n        if lenZ {\n          len += 1\n          if d == \"1\" { lenZ = false }\n        }\n        if !lenZ {\n          temp += String(d)\n          len -= 1\n          if len == 0 {\n            lenZ = true\n            ints.append(Int(temp, radix: 2)! - 1)\n            temp = \"\"\n          }\n        }        \n    }\n    return ints\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342678,"user_id":null,"body":"enum Mode {\n  case zeros, number\n}\nfunc decode(_ expGolombSequence: String) -> [Int] {\n  \n  var integers = [Int]()\n  let arr = Array(expGolombSequence)\n  var zeros = 0\n  var mode = Mode.zeros\n  var number: Int = 0\n  arr.forEach {\n    switch $0 {\n      case \"0\":\n        if mode == .zeros {\n          zeros += 1          \n        } else {\n          zeros -= 1\n          number = (number << 1) | (0)\n        }\n      case \"1\":\n        if mode == .zeros {\n          zeros += 1\n        }\n        mode = .number\n        zeros -= 1\n        number = (number << 1) | (1)\n      default: break\n    }\n    if zeros == 0 && mode == .number {\n      integers.append(number - 1)\n      number = 0\n      mode = .zeros\n    }\n  }\n    return integers\n  \n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342679,"user_id":null,"body":"func decode(_ s: String) -> [Int] {\n  var res = [Int]()\n  var num = \"\"\n  var count = 0\n  var counting = true\n  \n  for c in s {\n    switch (count, counting, c) {\n    case (_, true, \"0\"):\n      count += 1\n    case (0, true, \"1\"):\n      res.append(0)\n    case (_, true, \"1\"):\n      num = \"1\"\n      counting = false\n    case (1, false, _):\n      num += String(c)\n      res.append(Int(num, radix: 2)! - 1)\n      counting = true\n      count = 0\n    default:\n      num += String(c)\n      count -= 1\n    }\n  }\n  \n  return res\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342680,"user_id":null,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n    var array: [Int] = []\n    var n = -1\n    var zeros = 0\n    for l in expGolombSequence {\n        if n == -1 {\n            if l == \"0\" {\n                zeros += 1\n            } else {\n                n = 1 \n            }\n        } else {\n            if l == \"0\" {\n                n = n*2\n            } else {\n                n = n*2 + 1\n            }\n            zeros -= 1\n        }\n        if zeros == 0 {\n            array.append(n - 1)\n            n = -1\n        }\n    }\n    return array\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342681,"user_id":null,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n  var result = [Int]()\n  var i = 0\n  var l = 0\n  var in_lead = true\n  \n  for c in Array(expGolombSequence) {\n    if c == \"0\" && in_lead {\n      l += 1\n    } else if c == \"1\" && in_lead {\n      i += Int(pow(2, Double(l)))\n\n      if l == 0 {\n        result.append(i-1)\n        i = 0\n        in_lead = true  \n      } else {\n        l -= 1\n        in_lead = false\n      }\n    } else {\n      if c == \"1\" {\n        i += Int(pow(2, Double(l)))\n      }\n      if l > 0 {\n        l -= 1\n      } else {\n        result.append(i-1)\n        i = 0\n        in_lead = true\n      }\n    }\n  }\n  return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342682,"user_id":null,"body":"func decode(_ expGolombSequence: String) -> [Int] {\n    var s = Array(expGolombSequence)\n    \/\/print(s)\n    var result = [Int]()\n    var zero = 0\n    var i = 0\n    \n    while i<s.count {\n        if s[i] == \"0\" {\n            zero += 1\n        }\n        \n        else {\n            let binary = s[i...i+zero]\n            i += zero\n            zero = 0\n            let num = Int(strtoul(String(binary), nil, 2))\n            result.append(num - 1)\n        }\n        i += 1\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5f0ed36164f2bc00283aed07":[{"id":342683,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  \/\/ Your code goes here\n  return street * 2 + 1 - address;\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342684,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n    street * 2 + 1 - address\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342685,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  return Street(length: street).overTheRoad(address: address)\n}\n\nstruct Street {\n  let length: Int\n  \n  func overTheRoad(address: Int) -> Int {\n    address.isMultiple(of: 2) ?\n      oddAddress(at: distanceForEvenAddress(address))\n      : evenAddress(at: distanceForOddAddress(address))\n  }\n  \n  func evenAddress(at distance: Int) -> Int { distance * 2 }\n  func oddAddress(at distance: Int) -> Int { (length - distance) * 2 + 1 }\n  func distanceForEvenAddress(_ address: Int) -> Int { address \/ 2 }\n  func distanceForOddAddress(_ address: Int) -> Int { length - address \/ 2 }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342686,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  return street * 2 - (address - 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342687,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  street << 1 - (address >> 1) << 1 + (address - 1) & 1\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342688,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  return 1+street*2-address\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342689,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  \/\/ Your code goes here\n  street * 2 + 1 - address\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342690,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  \/\/ Your code goes here\n    if !address.isMultiple(of: 2) {\n        let index = (address + 1) \/ 2\n        return (street - index + 1) * 2\n    } else {\n        let index = (2 * street + 2 - address) \/ 2\n        return index * 2 - 1\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342691,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n  (address % 2 == 0) ? (1 + (street * 2) - address) : (street * 2 - (address - 1))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342692,"user_id":null,"body":"func overTheRoad(address: Int, street: Int) -> Int {\n    return street * 2 + 1 - address\n  return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5f3afc40b24f090028233490":[{"id":342693,"user_id":464,"body":"func swap(_ s: String,_  n: Int) -> String {\n    let bits = String(n, radix: 2)\n    var bitsRepeated = String(repeating: bits, count: (s.count \/ bits.count) + 1).makeIterator()\n    return s.map { c in\n        if c.isLetter {\n            if bitsRepeated.next()! == \"1\" {\n                return c.isUppercase ? c.lowercased() : c.uppercased()\n            }\n        }\n        return String(c)\n    }.reduce(\"\", +)\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342694,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n    \n    var binaryArray = Array(String(n, radix: 2))\n    let changeBinary = {\n        binaryArray.append(binaryArray.removeFirst())\n    }\n\n    var ans = \"\"\n    for char in s {\n        if char.isLetter {\n            if binaryArray[0] == \"1\" {\n                ans += char.isUppercase ? char.lowercased() : char.uppercased()\n                changeBinary()\n            } else {\n                ans += \"\\(char)\"\n                binaryArray.append(binaryArray.removeFirst())\n            }\n        } else {\n            ans += \"\\(char)\"\n        }\n    }\n    return ans\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342695,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n    let bits = getBinary(n)\n    let arrayS = Array(s)\n    var i = 0\n    var count = 0\n    var keepBits = \"\"\n    var letters = \"\"\n    var nonLetterBinaryTuple = [(String, Int)]()\n  \n    while i < arrayS.count {\n        if arrayS[i].isLetter {\n            count += 1\n            keepBits += bits\n            letters += String(arrayS[i])\n        }else {\n            nonLetterBinaryTuple.append((String(arrayS[i]), i))\n        }\n        i += 1\n    }\n    let alphabetCount = count\n    let exactRepeatedbinary = Array(keepBits.prefix(alphabetCount))\n    var k = 0\n    var letterBinaryTuple = [(String, String)]()\n    let realLetters = Array(letters)\n    var holdConvertedLetters = \"\"\n    \n    while k < exactRepeatedbinary.count {\n        letterBinaryTuple.append((String(exactRepeatedbinary[k]), String(realLetters[k])))\n        k += 1\n    }\n\n    for (key,value) in letterBinaryTuple {\n        var holdValue = value\n        if key == \"1\" && holdValue == holdValue.uppercased() {\n            holdValue = holdValue.lowercased()\n            holdConvertedLetters += holdValue\n        } else if key == \"1\" && holdValue == holdValue.lowercased() {\n            holdValue = holdValue.uppercased()\n            holdConvertedLetters += holdValue\n        }else {\n            holdConvertedLetters += holdValue\n        }\n    }\n    for (key,value) in nonLetterBinaryTuple {\n        holdConvertedLetters.insert(contentsOf: key, at: String.Index(encodedOffset: value))\n    }\n    return holdConvertedLetters\n}\n\nfunc getBinary(_ num: Int) -> String {\n    let str = String(num, radix: 2)\n    return str\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342696,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n    var snum = String(n, radix: 2)\n    var str:[Character] = Array(s)\n    if str.isEmpty {\n        return \"\"\n    }\n    let alpabet:[Character] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    while str.count >= snum.count {\n        snum += snum\n    }\n    let inum:[Int] = snum.map() {$0.wholeNumberValue!}\n    var times = 0\n    for i in 0...str.count-1 {\n        if alpabet.contains(Array(s.lowercased())[i]) {\n            if inum[times] == 1 {\n                if str[i].isUppercase {\n                    str[i] = Character(str[i].lowercased())\n                } else {\n                    str[i] = Character(str[i].uppercased())\n                }\n            }\n            times += 1\n        }\n    }\n    return str.map() {String($0)}.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342697,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n  let bits = Array(String(n, radix: 2))\n  var bi = 0\n  var result = \"\"\n  for index in s.indices {\n    if s[index].isLetter && bits[bi] == \"1\" {\n      result.append(s[index].caseswapped())\n    } else {\n      result.append(s[index])\n    }\n    if s[index].isLetter {\n      bi = (bi + 1) % bits.count\n    }\n  }\n  return result\n}\n\nextension Character {\n  func caseswapped() -> String { return isUppercase ? lowercased() : uppercased() }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342698,"user_id":null,"body":"import Foundation\n\nfunc swap(_ s: String, _ n: Int) -> String {\n    let pattern = String(n, radix: 2)\n    var bitPattern = String(repeating: pattern, count: s.count \/ pattern.count + 1).prefix(s.count)\n    return s.map { value -> String in\n        guard value.isLetter else {\n            return String(value)\n        }\n        let bit = bitPattern.removeFirst()\n        switch bit {\n            case \"1\":\n                return value.isUppercase ? value.lowercased() : value.uppercased()\n            default: return String(value)\n        }\n    }.joined()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342699,"user_id":null,"body":"func swap(_ s: String,_ n: Int) -> String {\n    let changeCase = String(n, radix:2).map {$0.wholeNumberValue! == 1}\n    let alphabet = CharacterSet.alphanumerics\n    var i: Int = 0\n    var result: String = \"\"\n    var temp: Character\n  \n    for ch in s {\n      temp = ch\n      if alphabet.contains(ch.unicodeScalars.first!) {\n        if changeCase[i] {\n          if ch.isUppercase {\n            temp = Character(ch.lowercased())\n          } else {\n            temp = Character(ch.uppercased())\n          }\n        }\n        i = (i == changeCase.count - 1 ? 0 : i + 1)\n      }\n      result.append(temp)\n    }\n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342700,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n    \/\/guard n > 0 else { return \"\" }\n    \n    let nBits = Array(String(n, radix: 2))\n    let nBitsLength = nBits.count\n    var nBitsIndex = 0\n    var result = \"\"\n    \n    for char in s {\n        var newChar = String(char)\n        \n        if char.isLetter {\n            if nBitsIndex == nBitsLength {\n                nBitsIndex = 0\n            }\n            \n            \/\/ if bit is 1, swap the case\n            if nBits[nBitsIndex] == \"1\" {\n                newChar = char.isLowercase ? char.uppercased() : char.lowercased()\n            }\n          \n            nBitsIndex += 1\n        }\n        \n        result.append(contentsOf: newChar)\n    }\n    \n    return result\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342701,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n  \n  var i = 0\n  let mask = String(n, radix: 2).map(String.init)\n  \n  func next() -> Bool {\n    if i == mask.count { i = 0 }\n    defer { i += 1 }\n    return mask[i] == \"1\"\n  }\n  \n  func toggle(_ c: Character) -> String {\n    c.isUppercase ? c.lowercased() : c.uppercased()\n  }\n  \n  return s\n    .map {\n      guard $0.isLetter else { return String($0) }\n      return next() ? toggle($0) : String($0)\n    }\n    .joined(separator: \"\")\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342702,"user_id":null,"body":"func swap(_ s: String, _ n: Int) -> String {\n    \n    let binary = Array(String(n, radix: 2))\n    var binaryIndex = 0\n    let sArray = Array(s)\n    var answer = String()\n    \n    for char in sArray {\n        \n        if char.isLetter {\n            \n            switch binary[binaryIndex] {\n            case \"0\":\n                answer.append(char)\n            case \"1\":\n                if char.isLowercase {\n                    answer.append(char.uppercased())\n                } else {\n                    answer.append(char.lowercased())\n                }\n            default:\n                break\n            }\n            if binaryIndex < binary.count - 1 {\n                binaryIndex += 1\n            } else {\n                binaryIndex = 0\n            }\n        } else {\n            answer.append(char)\n        }\n        \n    }\n    return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5f70c55c40b1c90032847588":[{"id":342703,"user_id":null,"body":"func points(_ dice: String) -> Int {\n  \n  let numbers = dice.compactMap{ $0.wholeNumberValue }\n  let cSet = NSCountedSet(array: numbers)\n  let unique = cSet.allObjects as! [Int]\n  let firstUniqueCount = cSet.count(for: unique[0])   \n  \n  \/\/ if all elements are the same\n  let isGenerala = unique.count == 1  \n  \n  \/\/ if has only 2 unique elements; count of one of them is 1 or 4\n  let isPoker = unique.count == 2 && [1,4].contains(firstUniqueCount)           \n  \n  \/\/ if has only 2 unique elements; count of one of them is 2 or 3\n  let isFullHouse = unique.count == 2 && [2,3].contains(firstUniqueCount)                  \n  \n  \/\/ if all 5 elements are unique; 1, 2 and 6 not all on it\n  let isStraight = unique.count == 5 && !Set([1,2,6]).isSubset(of: unique)\n  \n  \n  \/\/ Check points \n  \n  if isGenerala { return 50 } \n  else if isPoker { return 40 }\n  else if isFullHouse { return 30 }\n  else if isStraight { return 20 }\n  \n  \/\/ else return no points\n  return 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342704,"user_id":null,"body":"func points(_ dice: String) -> Int {\n  let v = dice.reduce(into: [:]) { $0[$1, default: 0] += 1 }.values\n  let s = String(dice.sorted())\n  \n  if v.contains(5) { \/\/ GENERALA\n    return 50\n  }\n  if v.contains(4) { \/\/ POKER\n    return 40\n  }\n  if v.contains(3) && v.contains(2) { \/\/ FULLHOUSE\n    return 30\n  }\n  if s == \"12345\" || s == \"13456\" || s == \"23456\" { \/\/STRAIGHT \n    return 20\n  }\n    \n  return 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342705,"user_id":null,"body":"extension Sequence where Element: Hashable {\n  var histogram: [Element: Int] {\n    return self.reduce(into: [:]) { counts, elem in counts [elem, default: 0] += 1}\n  }\n}\n\nfunc points(_ dice: String) -> Int {\n  \n  let newDice = String(dice).sorted().compactMap{ $0.wholeNumberValue}\n  \n  if newDice.histogram.values.contains(5) {\n    return 50\n  }\n  else if newDice.histogram.values.contains(4) {\n    return 40\n  }\n  else if newDice.histogram.values.contains(3) && newDice.histogram.values.contains(2) {\n    return 30\n  }\n  else if newDice == [1,2,3,4,5] || newDice == [2,3,4,5,6] || newDice == [1,3,4,5,6]{\n    return 20\n  }\n  \n  return 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342706,"user_id":null,"body":"import Foundation\n\nfunc points(_ dice: String) -> Int {\n  \n    let array = Array(dice)\n    \n    var answer = 0\n\n    let stringArray = array.map {element in String(element) }\n    let digitArray = stringArray.map {element in Int(element)}\n    let arrayDigitNoOptionals = digitArray.compactMap {$0}\n\n\n    let dict = arrayDigitNoOptionals.reduce(into: [:]) {count, numbers in\n        count[numbers, default: 0] += 1\n    }\n\n   \n\n\n    for i in dict.values.sorted() {\n        if i == 5 {\n            answer = 50\n            break\n        } else if (i == 4 || i == 1) && dict.count == 2 {\n            answer = 40\n            break\n        } else if (i == 3 || i == 2) && dict.count == 2 {\n            answer = 30\n            break\n        } else if i == 1 && dict.count == 5 {\n           \n            if arrayDigitNoOptionals.min() == 2 && arrayDigitNoOptionals.max() == 6 && arrayDigitNoOptionals.count == 5 {\n                answer = 20\n                break\n            } else if arrayDigitNoOptionals.min() == 1 && arrayDigitNoOptionals.max() == 5 && arrayDigitNoOptionals.count == 5 {\n                answer = 20\n                break\n            } else if arrayDigitNoOptionals.min() == 1 && arrayDigitNoOptionals.max() == 6 && arrayDigitNoOptionals.contains(2) == false && arrayDigitNoOptionals.count == 5 {\n                answer = 20\n                break\n            } else {\n                answer = 0\n                break\n            }\n        } else {\n            \n            break\n        }\n    }\n    \n  return answer\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342707,"user_id":null,"body":"func points(_ dice: String) -> Int {\n    let a = dice.map{Int(String($0))!}.sorted()\n    let s = Set(a)\n    let dict = Dictionary(grouping: dice){$0}.mapValues({$0.count})\n    if s.count == 1 { return 50}\n    for el in s {\n        if dict[Character(String(el))] == 4 { return 40 }\n        if dict[Character(String(el))] == 3 && s.count == 2 { return 30 }\n    }\n    if a[0] == 1 {\n        if a[2] - a [1] == 1 && a[3] - a [2] == 1  && a[4] - a [3] == 1 {\n            return 20\n        }\n    }\n    if a[1] - a [0] == 1 && a[2] - a [1] == 1 && a[3] - a [2] == 1  && a[4] - a [3] == 1 {\n            return 20\n    }\n  return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342708,"user_id":null,"body":"func points(_ dice: String) -> Int {\n  let dices = dice.map{ Int(\"\\($0)\")! }\n  let unique = Set(dices)\n  var occ: [Int] = []\n  \n  for x in unique {\n      occ.append(dices.filter({ $0 == x }).count)\n  }\n  \n  switch occ.sorted(by: >) {\n      case [5]:\n          return 50\n      case [4, 1]:\n          return 40\n      case [3, 2]:\n          return 30\n      default:\n          let srt: String = dices.sorted(by: <).map({ String($0) }).joined(separator: \"\")                                       \n          if srt == \"12345\" || srt == \"13456\" || srt == \"23456\" {\n              return 20\n          }\n  }\n  \n  return 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342709,"user_id":null,"body":"func points(_ dice: String) -> Int {\n  let values = mapDice(dice)\n  return score(values)\n}\n\nfunc score(_ values: [Character: Int]) -> Int {\n  if let generala = values.filter({$0.value == 5}).first {\n    return 50\n  }\n  \n  if let poker = values.filter({$0.value == 4}).first {\n    return 40\n  }\n\n  if let fullHouse = values.filter({$0.value == 3}).first, values.count == 2 {\n    return 30\n  }\n  \n  if values.count == 5 {\n    let vals = values.reduce(0, { $0 + (Int(String($1.key)) ?? 0) })\n    guard [15, 20, 19].contains(vals) else {\n      return 0\n    }\n    return 20\n  }\n\n  return 0\n}\n\nfunc mapDice(_ dice: String) -> [Character: Int] {\n  var ret = [Character: Int]()\n  dice.forEach {\n    if nil != ret[$0] {\n      ret[$0]! += 1\n    } else {\n      ret[$0] = 1\n    }\n  }\n  return ret\n}\n\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342710,"user_id":null,"body":"func points(_ dice: String) -> Int {\n\n      let diceInArray = String(dice).compactMap {$0.wholeNumberValue}.sorted()\n    \/\/let hasAllItemsEqual = diceInArray.dropFirst().allSatisfy({ $0 == diceInArray.first })\n    \n    if Set(diceInArray).count == 1 {\n        return 50\n    } else if diceInArray[0] != diceInArray[1] && diceInArray[1] == diceInArray[2] && diceInArray[2] == diceInArray[3] && diceInArray[3] == diceInArray[4]  {\n        return 40\n    } else if diceInArray[0] == diceInArray[1] && diceInArray[1] == diceInArray[2] && diceInArray[2] == diceInArray[3] && diceInArray[3] != diceInArray[4]{\n        return 40\n    } else if diceInArray[0] == diceInArray[1] && diceInArray[1] != diceInArray[2]  {\n        if diceInArray[2] == diceInArray[3] && diceInArray[2] == diceInArray[4] {\n            return 30\n        }\n    } else if diceInArray[3] == diceInArray[4] && diceInArray[2] != diceInArray[3] {\n        if diceInArray[0] == diceInArray[1] && diceInArray[0] == diceInArray[2] {\n            return 30\n        }\n    } else if diceInArray[0] == 1 && diceInArray[0] + 1 == diceInArray[1] {\n        if diceInArray[0] + 1 == diceInArray[1] && diceInArray[1] + 1 == diceInArray[2] && diceInArray[2] + 1 == diceInArray[3] && diceInArray[3] + 1 == diceInArray[4] {\n            return 20\n        }\n    } else if diceInArray[0] == 1 {\n        if diceInArray[0] < diceInArray[1] && diceInArray[1] + 1 == diceInArray[2] && diceInArray[2] + 1 == diceInArray[3] && diceInArray[3] + 1 == diceInArray[4] {\n            return 20\n        }\n    } else if diceInArray[0] + 1 == diceInArray[1] && diceInArray[1] + 1 == diceInArray[2] && diceInArray[2] + 1 == diceInArray[3] && diceInArray[3] + 1 == diceInArray[4]  {\n        return 20\n    } else if diceInArray[4] == 1 {\n        if diceInArray[0] + 1 == diceInArray[1] && diceInArray[1] + 1 == diceInArray[2] && diceInArray[2] + 1 == diceInArray[3] {\n            return 20\n        }\n    }\n    \n    return 0\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342711,"user_id":null,"body":"func points(_ dice: String) -> Int {\n  var counts = Array(repeating: 0, count: 6)\n  \n  dice\n    .map { Int(String($0))! - 1 }\n    .forEach { counts[$0] += 1 }\n  \n  if counts.max() == 5 {\n    return 50\n  }\n  else if counts.max() == 4 {\n    return 40\n  }\n  else if counts.max() == 3 && counts.contains(2) {\n    return 30\n  }\n  else if counts.dropFirst().map(String.init).joined().contains(\"1111\") {\n    return 20\n  }\n  else {\n    return 0\n  }\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342712,"user_id":null,"body":"func points(_ dice: String) -> Int {\n    let helpArr = String(dice).map{Int(String($0))!}\n    let setDice = Set(helpArr).sorted(by: >)\n    if setDice.count == 1 {\n        return 50\n    }\n    if setDice.count == 2 {\n        for i in setDice {\n            if helpArr.filter({$0 == i}).count == 4 {\n                return 40\n            }\n            if helpArr.filter({$0 == i}).count == 3 {\n                return 30\n            }\n        }\n    }\n    if setDice.count == 5 && (setDice.reduce(0,+) == 15 || setDice.reduce(0,+) == 20 || setDice.reduce(0,+) == 19){\n        return 20\n    }\n    return 0\n  \/\/cringe\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5f70c883e10f9e0001c89673":[{"id":342713,"user_id":527,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  return a.sorted(by: direction == \"L\" ? (>) : (<))\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342714,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n    return direction == \"R\" ? a.sorted() : a.sorted().reversed()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342715,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  if direction == \"R\" {\n    return a.sorted()\n  }\n  else {\n    return a.sorted { $0 > $1 }\n  }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342716,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  let q: [Int] = direction == \"R\" ? a.sorted(by: <) : a.sorted(by: >)\n  return q\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342717,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n    return direction == \"R\" ? a.sorted(by: {$0 < $1}) : a.sorted(by: {$1 < $0})\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342718,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  direction == \"R\" ? a.sorted() : a.sorted(by: >)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342719,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  \n  enum Direction: String {\n    case R\n    case L\n  }\n  \n  var resultArray = [Int]()\n  switch Direction(rawValue: direction) {\n    case .R: resultArray = a.sorted(by: <)\n    case .L: resultArray = a.sorted(by: >)\n    case .none: resultArray = []\n  }\n  \n  return resultArray\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342720,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  var arr = a\n  if direction == \"R\" {\n    arr.sort{$0 < $1}\n  } else if direction == \"L\" {\n    arr.sort{$0 > $1}\n  }\n  return arr\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342721,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  return direction == \"R\" ? a.sorted(by: <) : a.sorted(by: >)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342722,"user_id":null,"body":"func flip(_ direction: String, _ a: [Int]) -> [Int] {\n  var aClone = a.map { $0 }\n  aClone.sort { \n    direction == \"L\" ? $0 > $1 : $1 > $0 \n  }\n  return aClone\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"5fc7d2d2682ff3000e1a3fbc":[{"id":342723,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n    guard message.count > 0 else { return true }\n    let characters = message.components(separatedBy: .decimalDigits).filter { $0.count > 0 }\n    let numbers = message.components(separatedBy: .letters).filter { $0.count > 0 }\n    let zips = zip(characters, numbers)\n    guard zips.map({ $1 + $0 }).joined() == message else { return false }\n    return zips.allSatisfy { c, i in\n        c.count == Int(i)\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342724,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n    guard let firstLetter = message.first else {\n        return true\n    }\n    \n    if firstLetter.isLetter {\n        return false\n    }\n    \n    let words = message.split { !$0.isLetter }\n    let wordNumbers = message.split { $0.isLetter }\n    \n    var validWordsCounter = 0\n    \n    for i in 0..<words.count {\n        if words[i].count == Int(wordNumbers[i]) {\n            validWordsCounter += 1\n        }\n    }\n    \n    return validWordsCounter == wordNumbers.count\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342725,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n\tguard !message.isEmpty else { return true }\n\tvar numbers = message.components(separatedBy: CharacterSet.letters)\/\/.filter { !$0.isEmpty }\n\tguard !numbers[0].isEmpty else { return false }\n\tnumbers = numbers.filter { !$0.isEmpty }\n\tlet words = message.components(separatedBy: CharacterSet.decimalDigits).filter { !$0.isEmpty }\n\tguard numbers.count == words.count else { return false }\n\tfor i in stride(from: 0, to: numbers.count, by: 1) {\n\t\tif let n = Int(numbers[i]) {\n\t\t\tif n != words[i].count { return false }\n\t\t} else { return false }\n\t}\n\treturn true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342726,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n    if message == \"\" { return true }\n    if let last = message.last, last.isWholeNumber { return false }\n    \n    let regex = try! NSRegularExpression(pattern: #\"\\d+|[a-zA-Z]+\"#)\n    let results = regex.matches(in: message, range: NSRange(message.startIndex..., in: message))\n    var count = 0\n    \n    for result in results {\n        let result = message[Range(result.range, in: message)!]\n        \n        if Int(result) != nil {\n            count = Int(result)!\n        } else {\n            if count != result.count {\n                return false\n            }\n        }\n    }\n    \n    return true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342727,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n    let numbers = (message.components(separatedBy: CharacterSet.decimalDigits.inverted)).filter({ $0.count > 0})\n    let words = (message.components(separatedBy: CharacterSet.decimalDigits)).filter({ $0.count > 0})\n    \n    if Int(String(message.last ?? \"A\")) != nil {\n        return false\n    }\n\n    for (index, word) in words.enumerated() {\n        if word.count != Int(numbers[index]) {\n            return false\n        }\n    }\n    return true\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342728,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n  guard message.first?.isNumber ?? false else {\n    if message.isEmpty { return true }\n      return false\n    }\n  let arrayOfNumbers = message\n    .components(separatedBy: CharacterSet.decimalDigits.inverted)\n    .filter { !$0.isEmpty }\n    .map { Int($0) }\n  let arrayOfStrings = message\n     .components(separatedBy: CharacterSet.decimalDigits)\n     .filter { !$0.isEmpty }\n\n    guard arrayOfNumbers.count == arrayOfStrings.count else { return false }\n\n    var result: Set <Bool> = []\n    zip(arrayOfNumbers, arrayOfStrings).forEach { number, string in\n       result.insert(number == string.count ? true : false)\n    }\n    return result.count == 1 && result.first != false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342729,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n    guard message != \"\" else { return true }\n    guard let first = message.first,\n          Int(String(first)) != nil,\n          let last = message.last,\n          Int(String(last)) == nil else { return false}\n    var results = [Bool]()\n    var lastIndexOfInteger = 0\n    var lastInteger = [String]()\n    var wordLength = 0\n    let messageLength = message.count - 1\n    for (i, char) in message.enumerated() {\n        if let integer = Int(String(char)) {\n            if i == lastIndexOfInteger + 1 {\n                lastInteger.append(String(integer))\n            } else {\n                wordLength == Int(lastInteger.joined()) ? results.append(true) : results.append(false)\n                lastIndexOfInteger = i\n                lastInteger = [(String(integer))]\n                wordLength = 0\n            }\n        } else {\n            wordLength += 1\n        }\n        if messageLength == i {\n            wordLength == Int(lastInteger.joined()) ? results.append(true) : results.append(false)\n        }\n    }\n    return results.dropFirst().contains(false) ? false : true\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342730,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n  if message == \"\" { return true }\n  else if !message.first!.isNumber { return false }\n  var numbers = \"\"\n  var tempStr = \"\"\n  var lastCharWasNumber = true\n  \n  for char in message {\n    if char.isNumber {\n      if !lastCharWasNumber {\n        if tempStr.count != Int(numbers) {\n          return false \n        }\n        numbers = \"\"\n        tempStr = \"\"\n        lastCharWasNumber = true\n      }\n      tempStr.append(char)\n    } else {\n      if lastCharWasNumber {\n        numbers.append(tempStr)\n        tempStr = \"\"\n        tempStr.append(char)\n        lastCharWasNumber = false\n      } else {\n        tempStr.append(char)\n      }\n    }\n  }\n  if tempStr.count != Int(numbers) {\n    return false \n  } else {\n    return true\n  }\n}  \n\/\/ 3hey5hello2hi","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342731,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool { \/\/short variant\n    guard !message.isEmpty else {return true}\n    guard message.first!.isNumber && ((message.last?.isLetter) != nil) else {return false}\n    let nums = message.split{$0.isLetter}.map{Int($0)!}\n    let words = message.split{$0.isNumber}\n    return nums == words.map{$0.count}\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342732,"user_id":null,"body":"func isAValidMessage(_ message: String) -> Bool {\n    guard !message.isEmpty else {return true}\n    guard message.first!.isNumber && ((message.last?.isLetter) != nil) else {return false}\n    var nums = [String]()\n    var letters = [String]()\n    var tmp = \"\"\n    var tmpLetters = \"\"\n    for i in message {\n        if i.isNumber {\n            tmp += String(i)\n            letters.append(tmpLetters)\n            tmpLetters = \"\"\n        }\n        if i.isLetter {\n            nums.append(tmp)\n            tmp = \"\"\n            tmpLetters += String(i)\n        }\n    }\n    if !tmp.isEmpty {\n        nums.append(tmp)\n    }\n    if !tmpLetters.isEmpty {\n        letters.append(tmpLetters)\n    }\n    nums = nums.filter({$0 != \"\"})\n    letters = letters.filter({$0 != \"\"}).map{String($0.count)}\n    return nums == letters\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"604287495a72ae00131685c7":[{"id":342733,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n  return Set(Array(String(num + 1))).count == 2 ? num + 1 : doubleton(num + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342734,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n  for n in num+1...1_000_000 {\n    if isDoubleton(n) {\n      return n\n    }\n  }\n  return num\n}\n\nfunc isDoubleton(_ num: Int) -> Bool {\n  Set(String(num)).count == 2\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342735,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n  return Set(String(num + 1).compactMap{ $0.wholeNumberValue }).count == 2 ? num + 1 : doubleton(num + 1)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342736,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n    var numStr = \"\"\n    for i in num + 1...1000000 {\n        numStr = \"\"\n        for j in \"\\(i)\" {\n            if !numStr.contains(j) {\n                numStr.append(j)\n            }\n        }\n        if numStr.count == 2 {\n            return i\n        }\n    }\n    return 0\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342737,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n    for i in num+1..<1000000 {\n        if Set(String(i).compactMap { $0.wholeNumberValue }).count == 2 {\n            return i\n        }\n    }\n    return num\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342738,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n\tvar result: Bool = false\n\tvar value = num + 1\n\twhile result == false {\n\t\tif isDoubleton(value) == true {\n\t\t\tresult = true\n\t\t} else {\n\t\t\tvalue += 1\n\t\t}\n\t}\n\treturn value\n}\n\nfunc isDoubleton(_ num: Int) -> Bool {\n\tSet(String(num)).count == 2 ? true : false\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342739,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {   \n    func checkNum(_ num: Int) -> Bool {\n        return Set(String(num)).count == 2 ? false : true\n    }\n\nvar n = num + 1\n\nwhile checkNum(n) {\n  n += 1  \n}\n\nreturn n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342740,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {   \/\/\u0432 \u043a\u043e\u043d\u0446\u0435 \u0432\u0441\u0442\u0430\u0432\u0438\u0442\u044c -> Int\n    func checkNum(_ num: Int) -> Bool {\n        return Set(String(num)).count == 2 ? false : true\n    }\n\nvar n = num + 1\n\nwhile checkNum(n) {\n  n += 1  \n}\n\nreturn n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342741,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {  \n    func checkNum(_ num: Int) -> Bool {\n        var set: Set<String> = []\n\n       (String(num)).forEach { word in \n            set.insert(String(word)) }\n\n        return set.count == 2 ? false : true\n    }\n\nvar n = num + 1\n\nwhile checkNum(n) {\n  n += 1  \n}\n\nreturn n\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342742,"user_id":null,"body":"func doubleton(_ num: Int) -> Int {\n    var doubleton = 0\n  for i in num+1...1000000{\n    if Set(String(i)).count == 2 {\n      doubleton = i\n        break\n    }\n  }\n    return doubleton\n \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}],"58e61f3d8ff24f774400002c":[{"id":342743,"user_id":null,"body":"enum CmpResult {\n  case GreaterThan\n  case Equal\n  case LessThan\n}\n\nenum InterpreterError: Error {\n  case InvalidEnd\n}\n\nextension String {\n  func trim() -> String {\n    var newString = self\n    while newString.hasPrefix(\" \") { newString = String(newString.dropFirst()) }\n    while newString.hasSuffix(\" \") { newString = String(newString.dropLast()) }\n    return newString\n  }\n}\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n  let instructions = program.split(separator: \"\n\").map({ String($0).trim() })\n  var pc = instructions.startIndex\n  var registers = [String:Int]()\n  var callStack = [Int]()\n  var output = \"\"\n  var cmpResult = CmpResult.Equal\n  while pc != instructions.endIndex {\n    let instruction = instructions[pc]\n    var op = instruction\n    var args = [String]()\n    if let sindex = instruction.index(of: \" \") {\n      op = String(instruction[..<sindex])\n      if let commentIndex = instruction.index(of: \";\"), commentIndex > sindex {\n        args = instruction[sindex..<commentIndex].split(separator: \",\").map({ String($0).trim() })\n      }else{\n        args = instruction[sindex...].split(separator: \",\").map({ String($0).trim() })\n      }\n    }\n    if [\"mov\", \"mul\", \"div\", \"add\", \"sub\"].contains(op) {\n      let rname = String(args[0])\n      let rval = registers[rname] ?? 0\n      let operand = String(args[1])\n      var newValue = (operand > \"9\") ? (registers[operand] ?? 0) : (Int(operand) ?? 0)\n      if op == \"add\" {\n        newValue = rval + newValue\n      }else if op == \"sub\" {\n        newValue = rval - newValue\n      }else if op == \"mul\" {\n        newValue = rval * newValue\n      }else if op == \"div\" {\n        newValue = rval \/ newValue\n      }\n      registers[rname] = newValue\n    }else if [\"inc\", \"dec\"].contains(op) {\n      let rname = String(args[0])\n      let rval = registers[rname] ?? 0\n      if op == \"inc\" {\n        registers[rname] = rval + 1\n      }else if op == \"dec\" {\n        registers[rname] = rval - 1\n      }\n    }else if op == \"cmp\" {\n      let x = args[0] > \"9\" ? registers[String(args[0])]! : Int(args[0])!\n      let y = args[1] > \"9\" ? registers[String(args[1])]! : Int(args[1])!\n      if x < y {\n        cmpResult = .LessThan\n      }else if x > y {\n        cmpResult = .GreaterThan\n      }else{\n        cmpResult = .Equal\n      }\n    }else if [\"call\", \"jmp\", \"jne\", \"je\", \"jge\", \"jg\", \"jle\", \"jl\"].contains(op) {\n      let label = String(args[0])\n      if op == \"call\" {\n        callStack.append(pc)\n      }\n      if(op == \"call\" ||\n        op == \"jmp\" ||\n        (op == \"jne\" && cmpResult != .Equal) ||\n        (op == \"je\" && cmpResult == .Equal) ||\n        (op == \"jge\" && cmpResult != .LessThan) ||\n        (op == \"jg\" && cmpResult == .GreaterThan) ||\n        (op == \"jle\" && cmpResult != .GreaterThan) ||\n        (op == \"jl\" && cmpResult == .LessThan)){\n        pc = instructions.index(where: { $0.hasPrefix(label) })!\n        continue\n      }\n    }else if op == \"ret\" {\n      pc = callStack.popLast()!\n    }else if op == \"msg\" {\n      \/\/msg args can contain both ',' and ';' which we normally strip out for other commands\n      let args = String(instruction[instruction.index(instruction.startIndex, offsetBy: 4)...])\n      var newArg = true\n      var include = false\n      for index in args.indices {\n        let ch = args[index]\n        if !include {\n          if ch == \"'\" {\n            include = true\n            newArg = false\n          }else if ch == \";\" {\n            break \/\/hit the beginning of an inline comment, msg is finished\n          }else if newArg && ch != \" \" {\n            output += String(describing: registers[String(ch)]!)\n            newArg = false\n          }else if ch == \",\" {\n            newArg = true\n          }\n        }else if ch == \"'\" {\n          newArg = false\n          include = false\n        }else{\n          output += String(ch)\n        }\n      }\n    }else if op == \"end\" {\n      return output\n    }\n    pc = instructions.index(pc, offsetBy: 1)\n  }\n  throw InterpreterError.InvalidEnd\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342744,"user_id":null,"body":"import Foundation\n\nprotocol InstructionExecutor\n{\n  func exec(_ state : MachineState) -> MachineState\n}\n\nenum ErrorException: Error {\n    case generalError\n}\n\n\nclass MachineState\n{\n  enum CmpResult {\n    case Equal\n    case NonEqual\n    case GreaterEqual\n    case Greater\n    case LessEqual\n    case Less\n  }\n  \n  var registers : [String : Int]\n  var curPC : Int  \/\/ Program counter\n  var callStack : [Int]\n  var output : String\n  var endExec : Bool       \/\/ Program end signal\n  var cmpFlag : Set<CmpResult>\n  \n  init() {\n    registers = [String : Int]()\n    curPC = 0\n    callStack = [Int]()\n    output = \"\"\n    endExec = false\n    cmpFlag = []\n  }\n  \n  func getReg(_ reg: String) -> Int\n  {\n    return registers[reg] ?? 0\n  }\n  \n  func setReg(_ reg: String, _ val : Int)\n  {\n    registers[reg] = val\n  }\n}\n\n\nclass Asm_Instruction : InstructionExecutor\n{\n  var op1 : String = \"\"\n  var op2 : String = \"\"\n  \n  required init(_ op1:String = \"\", _ op2 : String = \"\") {\n    self.op1 = op1\n    self.op2 = op2\n  }\n  \n  func exec(_ state : MachineState) -> MachineState\n  {\n    \/\/ does nothing\n    return state\n  }\n  \n  static func evaluateOp(_ op : String, _ state : MachineState) -> Int {\n    if op.rangeOfCharacter(from: CharacterSet.letters) != nil {\n      return state.getReg(op)\n    } else {\n      return Int(op)!\n    }\n  }\n}\n\nclass Asm_Mov : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.registers[op1] = Asm_Instruction.evaluateOp(op2, state)\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Inc : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.setReg(op1, state.getReg(op1) + 1)\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Dec : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.setReg(op1, state.getReg(op1) - 1)\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Add : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.setReg(op1, state.getReg(op1) + Asm_Instruction.evaluateOp(op2, state))\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Sub : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.setReg(op1, state.getReg(op1) - Asm_Instruction.evaluateOp(op2, state))\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Mul : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.setReg(op1, state.getReg(op1) * Asm_Instruction.evaluateOp(op2, state))\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Div : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.setReg(op1, state.getReg(op1) \/ Asm_Instruction.evaluateOp(op2, state))\n    state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_Cmp : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n      let o1 = Asm_Instruction.evaluateOp(op1, state)\n      let o2 = Asm_Instruction.evaluateOp(op2, state)\n      state.cmpFlag.removeAll()\n      if o1 == o2 {\n          state.cmpFlag.insert(.Equal)\n      }\n      if o1 != o2 {\n          state.cmpFlag.insert(.NonEqual)\n      }\n      if o1 >= o2 {\n          state.cmpFlag.insert(.GreaterEqual)\n      }\n      if o1 > o2 {\n          state.cmpFlag.insert(.Greater)\n      }\n      if o1 <= o2 {\n          state.cmpFlag.insert(.LessEqual)\n      }\n      if o1 < o2 {\n          state.cmpFlag.insert(.Less)\n      }\n      state.curPC += 1\n      return state\n  }\n}\n\nclass Asm_Jmp : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.curPC = Int(self.op1)!\n    return state\n  }\n}\n\nclass Asm_Jne : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n      if state.cmpFlag.contains(.NonEqual) {\n      state.curPC = Int(self.op1)!\n    } else {\n      state.curPC += 1\n    }\n    return state\n  }\n}\n\nclass Asm_Je : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    if state.cmpFlag.contains(.Equal) {\n      state.curPC = Int(self.op1)!\n    } else {\n      state.curPC += 1\n    }\n    return state\n  }\n}\n\nclass Asm_Jge : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    if state.cmpFlag.contains(.GreaterEqual) {\n      state.curPC = Int(self.op1)!\n    } else {\n      state.curPC += 1\n    }\n    return state\n  }\n}\n\nclass Asm_Jg : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    if state.cmpFlag.contains(.Greater) {\n      state.curPC = Int(self.op1)!\n    } else {\n        state.curPC += 1\n      }\n    return state\n  }\n}\n\nclass Asm_Jle : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    if state.cmpFlag.contains(.LessEqual) {\n      state.curPC = Int(self.op1)!\n    }else {\n        state.curPC += 1\n      }\n    return state\n  }\n}\n\nclass Asm_Jl : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    if state.cmpFlag.contains(.Less) {\n      state.curPC = Int(self.op1)!\n    }else {\n        state.curPC += 1\n      }\n    return state\n  }\n}\n\nclass Asm_Call : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.callStack.append(state.curPC + 1)\n    state.curPC = Int(self.op1)!\n    return state\n  }\n}\n\nclass Asm_Ret : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n\n    if let nextPC = state.callStack.popLast() {\n      state.curPC = nextPC\n    } else {\n      state.curPC += 1\n    }\n    \n    return state\n  }\n}\n\nclass Asm_Msg : Asm_Instruction\n{\n    var output : String = \"\"\n    let msgArray : [(Asm_Msg.MsgType,String)]\n    enum MsgType {\n        case Text\n        case Reg\n    }\n    \n    init(_ msgArray:[(Asm_Msg.MsgType,String)]) {\n        \n        self.msgArray = msgArray\n    }\n    \n    required init(_ op1:String = \"\", _ op2 : String = \"\") {\n        self.msgArray = [(Asm_Msg.MsgType,String)]()\n    }\n    \n  override func exec(_ state : MachineState) -> MachineState\n  {\n      for (type, msg) in msgArray {\n          if type == .Text {\n              output += msg\n          } else {\n              output += String(Asm_Instruction.evaluateOp(msg, state))\n          }\n      }\n      state.output = output\n      state.curPC += 1\n    return state\n  }\n}\n\nclass Asm_End : Asm_Instruction\n{\n  override func exec(_ state : MachineState) -> MachineState\n  {\n    state.endExec = true\n    state.curPC += 1\n    return state\n  }\n}\n\nclass AssemblyProgram\n{\n  let instrTypes : [String: Asm_Instruction.Type] = [\n    \"mov\" : Asm_Mov.self,\n    \"inc\" : Asm_Inc.self,\n    \"dec\" : Asm_Dec.self,\n    \"add\" : Asm_Add.self,\n    \"sub\" : Asm_Sub.self,\n    \"mul\" : Asm_Mul.self,\n    \"div\" : Asm_Div.self,\n    \"cmp\" : Asm_Cmp.self,\n    \"jmp\" : Asm_Jmp.self,\n    \"jne\" : Asm_Jne.self,\n    \"je\"  : Asm_Je.self,\n    \"jge\" : Asm_Jge.self,\n    \"jg\"  : Asm_Jg.self,\n    \"jle\" : Asm_Jle.self,\n    \"jl\"  : Asm_Jl.self,\n    \"call\": Asm_Call.self,\n    \"ret\" : Asm_Ret.self,\n    \"msg\" : Asm_Msg.self,\n    \"end\" : Asm_End.self,\n  ]\n  \n  var instrList : [Int : Asm_Instruction]\n  var labelList : [String : Int]\n  var instrCounter : Int = 0\n  \n  init(_ program:String) {\n    instrList = [Int : Asm_Instruction]()\n    labelList = [String : Int]()\n    parseProgram(source: program)\n  }\n  \n  func addNewInstr(_ instr : Asm_Instruction)\n  {\n    instrList[instrCounter] = instr\n    instrCounter += 1\n  }\n  \n  \n  func parseProgram(source program:String)\n  {\n    let pLines = program.split(separator: \"\n\")\n    nextLine: for l in pLines {\n      let lexems = l.components(separatedBy: CharacterSet(charactersIn: \" ,\\t\")).compactMap{ $0 != \"\" ? $0 : nil}\n      let instr = String(lexems[0])\n        switch instr {\n        case \";\":\n          continue nextLine\n        case \"mov\", \"add\", \"sub\", \"mul\", \"div\", \"cmp\":\n          guard lexems.count >= 3 else { continue nextLine }\n          let op1 = String(lexems[1])\n          let op2 = String(lexems[2])\n          \n          if let insFunc = instrTypes[instr] {\n            self.addNewInstr(insFunc.init(op1, op2))\n          }\n          \n        case \"inc\", \"dec\", \"jmp\", \"jne\", \"je\", \"jge\", \"jg\", \"jle\", \"jl\", \"call\":\n          guard lexems.count >= 2 else { continue nextLine }\n          let op1 = String(lexems[1])\n          if let insFunc = instrTypes[instr] {\n            self.addNewInstr(insFunc.init(op1))\n          }\n        case \"ret\", \"end\":\n          guard lexems.count >= 1 else { continue nextLine }\n          if let insFunc = instrTypes[instr] {\n            self.addNewInstr(insFunc.init())\n          }\n        case \"msg\":\n          guard lexems.count > 1 else { continue nextLine }\n          let msgIndex = l.range(of: \"msg\")!.upperBound\n            let str = String(l[msgIndex...])\n          var res = [String]()\n          let capturePattern = \"([a-z]|'.+?'+?|;.*?$)(?:,|)\"\n          let regex = try! NSRegularExpression(pattern: capturePattern)\n          let matches = regex.matches(in: str,\n                                    range: NSRange(str.startIndex..., in: str))\n          for m in matches {\n              guard m.numberOfRanges > 1 else { continue }\n              for i in 1..<m.numberOfRanges {\n                  let matchRange = m.range(at: i)\n                  \n                  \/\/ Extract the substring matching the capture group\n                  if let substringRange = Range(matchRange, in: str) {\n                      let capture = String(str[substringRange])\n                      res.append(capture)\n                  }\n              }\n          }\n          var msgText = [(Asm_Msg.MsgType,String)]()\n          for r in res {\n              let firstChar = r[r.index(r.startIndex, offsetBy: 0)]\n              switch firstChar {\n                case \";\":\n                  continue\n                case \"\\'\":\n                  msgText.append((.Text, String(r.dropFirst(1).dropLast(1))))\n                default:\n                  msgText.append((.Reg, r))\n              }\n              \n          }\n          let insFunc = Asm_Msg(msgText)\n          self.addNewInstr(insFunc)\n        default:\n          if instr.contains(\":\") { \/\/ label\n            let label = String(instr.split(separator: \":\")[0])\n            labelList[label] = instrCounter\n          } else {\n            continue nextLine\n          }\n      }\n    }\n    for (_, instr) in instrList {\n        switch instr\n            {\n            case is Asm_Je:\n                fallthrough\n            case is Asm_Jg:\n                fallthrough\n            case is Asm_Jl:\n                fallthrough\n            case is Asm_Jne:\n                fallthrough\n            case is Asm_Jge:\n                fallthrough\n            case is Asm_Jle:\n                fallthrough\n            case is Asm_Call:\n                fallthrough\n            case is Asm_Jmp:\n                instr.op1 = String(labelList[instr.op1]!)\n            default:\n                continue\n            }\n        \n    }\n  }\n}\n\nclass AssemblerInterpreter\n{\n  var state : MachineState\n  var program : AssemblyProgram\n  \n  init(_ program:String) {\n    self.state = MachineState()\n    self.program = AssemblyProgram(program)\n  }\n  \n  func execute() throws -> String\n  {\n      while self.state.curPC < self.program.instrList.count {\n          guard let instr = self.program.instrList[self.state.curPC] else {break}\n          self.state = instr.exec(self.state)\n          if self.state.endExec {\n              break\n          }\n          \n      }\n    if self.state.endExec {\n      return self.state.output\n    } else {\n      throw ErrorException.generalError\n    }\n  }\n}\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n  let interpreter = AssemblerInterpreter(program)\n  var result : String = \"\"\n  do {\n    try result = interpreter.execute()\n  } catch {\n    throw ErrorException.generalError\n  }\n  return result\n  \n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342745,"user_id":null,"body":"import Foundation\n\nenum TaskError: Error {\n    case badProgram\n}\n\nfunc makeTokens(from string: String) -> [Token] {\n    \/\/ Removing Comments\n    \n    let lines = string.split(separator: \"\n\").compactMap { line -> String? in\n        let str = String(line)\n        if str.contains(\";\") {\n            let parts = String(line).split(separator: \";\")\n            if parts.count == 1 {\n                return nil\n            } else {\n                return String(parts[0])\n            }\n        } else {\n            return str\n        }\n    }\n    \n    var parsingFunction = false\n    var commandsCount = 0\n    var functionIndex: Int?\n    \n    var tokens: [Token] = []\n    \n    for (index, line) in lines.enumerated() {\n        if parsingFunction {\n            if line.prefix(4) == \"\" {\n                parsingFunction = false\n                functionIndex = nil\n                commandsCount = 0\n            } else {\n                commandsCount += 1\n            }\n        }\n        let token = makeToken(from: line.trimmingCharacters(in: .whitespaces))\n        tokens.append(token)\n        if case Token.ret = token {\n            parsingFunction = false\n            if\n                let functionIndex = functionIndex,\n                case Token.label(let title, _) = tokens[functionIndex]\n            {\n                tokens[functionIndex] = .label(title: title, commandsCount: commandsCount)\n            }\n        } else if case Token.label = token {\n            if\n                parsingFunction,\n                let functionIndex = functionIndex,\n                case Token.label(let title, _) = tokens[functionIndex]\n            {\n                tokens[functionIndex] = .label(title: title, commandsCount: commandsCount - 1)\n            }\n            \n            parsingFunction = true\n            functionIndex = index\n            commandsCount = 0\n        }\n    }\n    return tokens\n}\n\nfunc parseMessageArg(from rawArgs: String) -> [String] {\n    var result: [String] = []\n    var isSearchEnd: Bool = false\n    var str: String = \"\"\n    for char in rawArgs {\n        if isSearchEnd {\n            if char == \"'\" {\n                result.append(str)\n                isSearchEnd = false\n                str = \"\"\n            } else {\n                str.append(String(char))\n            }\n        } else {\n            if char == \"'\" {\n                isSearchEnd = true\n                str = \"\"\n            } else if char != \" \" && char != \",\" {\n                str.append(String(char))\n            } else  if !str.isEmpty {\n                result.append(str)\n                str = \"\"\n            }\n        }\n    }\n    if !str.isEmpty {\n        result.append(str)\n    }\n    return result\n}\n\nfunc makeToken(from string: String) -> Token {\n    var command: String\n    var args: [String] = []\n    if let index = string.firstIndex(of: \" \") {\n        command = String(string[string.startIndex..<index])\n        let rawArgs = String(string[index..<string.endIndex]).trimmingCharacters(in: .whitespaces)\n        \n        if command == \"msg\" {\n            args = parseMessageArg(from: rawArgs)\n        } else {\n            if rawArgs.contains(\",\") {\n                args = rawArgs.split(separator: \",\").map { String($0).trimmingCharacters(in: .whitespaces) }\n            } else {\n                args = [rawArgs]\n            }\n        }\n    } else {\n        command = string\n    }\n    \n    switch command {\n    case \"mov\":\n        return .mov(into: args[0], value: args[1])\n    case \"inc\":\n        return .inc(register: args[0])\n    case \"dec\":\n        return .dec(register: args[0])\n    case \"add\":\n        return .add(into: args[0], value: args[1])\n    case \"sub\":\n        return .sub(into: args[0], value: args[1])\n    case \"mul\":\n        return .mul(value: args[0], by: args[1])\n    case \"div\":\n        return .div(value: args[0], by: args[1])\n    case \"jmp\":\n        return .jmp(toLabel: args[0])\n    case \"cmp\":\n        return .cmp(lhs: args[0], rhs: args[1])\n    case \"jne\":\n        return .jne(toLabel: args[0])\n    case \"je\":\n        return .je(toLabel: args[0])\n    case \"jge\":\n        return .jge(toLabel: args[0])\n    case \"jg\":\n        return .jg(toLabel: args[0])\n    case \"jle\":\n        return .jle(toLabel: args[0])\n    case \"jl\":\n        return .jl(toLabel: args[0])\n    case \"call\":\n        return .call(label: args[0])\n    case \"ret\":\n        return .ret\n    case \"msg\":\n        return .msg(args: args)\n    case \"end\":\n        return .end\n    default:\n        return .label(title: command.replacingOccurrences(of: \":\", with: \"\"), commandsCount: 0)\n    }\n}\n\nenum Token {\n    case mov(into: String, value: String)\n    case inc(register: String)\n    case dec(register: String)\n    case add(into: String, value: String)\n    case sub(into: String, value: String)\n    case mul(value: String, by: String)\n    case div(value: String, by: String)\n    case label(title: String, commandsCount: Int)\/\/ if hasRet is False it's means that function cant finish execution\n    case jmp(toLabel: String)\n    case cmp(lhs: String, rhs: String)\n    case jne(toLabel: String) \/\/ Not Equal\n    case je(toLabel: String) \/\/ Eqaul\n    case jge(toLabel: String) \/\/ Greater or Equal than\n    case jg(toLabel: String) \/\/ Greater than\n    case jle(toLabel: String) \/\/ Less or Equal than\n    case jl(toLabel: String) \/\/ Less than\n    case call(label: String)\n    case ret\n    case msg(args: [String])\n    case end\n}\n\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n  print(program)\n    var registers: [String: Int] = [:]\n    func getValueForRegister(key: String) -> Int {\n        if let value = registers[key] {\n            return value\n        } else {\n            return Int(key)!\n        }\n    }\n    \n    \n    func makeLabelsPositions(for tokens: [Token]) -> [String: Int] {\n        var dict: [String: Int] = [:]\n        for (index, token) in tokens.enumerated() {\n            guard case Token.label(let title, _) = token else {\n                continue\n            }\n            dict[title] = index\n        }\n        return dict\n    }\n    \n    func makeMessage(from args: [String]) -> String {\n        var result: [String] = []\n        \n        for arg in args {\n            if registers[arg] == nil {\n                result.append(arg)\n            } else {\n                let value = getValueForRegister(key: arg)\n                result.append(\"\\(value)\")\n            }\n        }\n        return result.joined()\n    }\n    \n    \n    var stack: [Int] = []\n    var currentLineIndex = 0\n    let tokens = makeTokens(from: program)\n    let labelsPositions = makeLabelsPositions(for: tokens)\n    var currentToken: Token = tokens[currentLineIndex]\n    var comparingValues: (lhs: Int, rhs: Int)?\n    var currentMethod: String?\n    var currentMethodCommandsCount: Int?\n    \n    var output: String?\n    var isEndReceived: Bool = false\n    while (currentLineIndex <= tokens.count) {\n        if\n            let currentMethod = currentMethod,\n            let commandsCount = currentMethodCommandsCount\n        {\n            let labelOffset = labelsPositions[currentMethod]!\n            if currentLineIndex == labelOffset + commandsCount + 1  {\n                isEndReceived = false\n                break\n            }\n        }\n      \n        if currentLineIndex >= tokens.count {\n            isEndReceived = false\n            break\n        }\n        \n        currentToken = tokens[currentLineIndex]\n        switch currentToken {\n        case .mov(let into, let value):\n            let regVal = getValueForRegister(key: value)\n            registers[into] = regVal\n        case .inc(let register):\n            let lastValue = registers[register]!\n            registers[register] = lastValue + 1\n        case .dec(let register):\n            let lastValue = registers[register]!\n            registers[register] = lastValue - 1\n        case .add(let into, let value):\n            let regVal = getValueForRegister(key: into)\n            let addValue = getValueForRegister(key: value)\n            registers[into] = regVal + addValue\n        case .sub(let into, let value):\n            let regVal = getValueForRegister(key: into)\n            let addValue = getValueForRegister(key: value)\n            registers[into] = regVal - addValue\n        case .mul(let into, let by):\n            let regVal = getValueForRegister(key: into)\n            let mulValue = getValueForRegister(key: by)\n            registers[into] = regVal * mulValue\n        case .div(let into, let by):\n            let regVal = getValueForRegister(key: into)\n            let divValue = getValueForRegister(key: by)\n            registers[into] = regVal \/ divValue\n        case .label(let title, let count):\n            currentMethod = title\n            currentMethodCommandsCount = count\n            \n        case .jmp(let toLabel):\n            let funcIndex = labelsPositions[toLabel]!\n            currentLineIndex = funcIndex\n            continue\n        case .cmp(let lhs, let rhs):\n            let lvalue = getValueForRegister(key: lhs)\n            let rvalue = getValueForRegister(key: rhs)\n            comparingValues = (lvalue, rvalue)\n        case .jne(let toLabel):\n            if comparingValues!.lhs != comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .je(let toLabel):\n            if comparingValues!.lhs == comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jge(let toLabel):\n            if comparingValues!.lhs >= comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jg(let toLabel):\n            if comparingValues!.lhs > comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jle(let toLabel):\n            if comparingValues!.lhs <= comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jl(let toLabel):\n            if comparingValues!.lhs < comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .call(let label):\n            let callIndex = labelsPositions[label]!\n            if currentMethod == nil || currentMethod! != label {\n                stack.append(currentLineIndex + 1)\n            }\n            currentLineIndex = callIndex\n            continue\n        case .ret:\n            currentLineIndex = stack.removeLast()\n            currentMethod = nil\n            continue\n        case .msg(let args):\n            output = makeMessage(from: args)\n        case .end:\n            isEndReceived = true\n        }\n        if isEndReceived {\n            break\n        }\n        currentLineIndex += 1\n    }\n    guard isEndReceived else {\n        throw TaskError.badProgram\n    }\n    if let output = output {\n        return output\n    } else {\n        throw TaskError.badProgram\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342746,"user_id":null,"body":"\/\/\n\/\/  main.swift\n\/\/  TestCommandLine\n\/\/\n\/\/  Created by \u0410\u0439\u0434\u0430\u0440 \u0417\u0430\u043a\u0430\u0440\u0438\u043d on 14.04.2022.\n\/\/\n\nimport Foundation\n\nenum TaskError: Error {\n    case badProgram\n}\n\nfunc makeTokens(from string: String) -> [Token] {\n    \/\/ Removing Comments\n    \n    let lines = string.split(separator: \"\n\").compactMap { line -> String? in\n        let str = String(line)\n        if str.contains(\";\") {\n            let parts = String(line).split(separator: \";\")\n            if parts.count == 1 {\n                return nil\n            } else {\n                return String(parts[0])\n            }\n        } else {\n            return str\n        }\n    }\n    \n    var parsingFunction = false\n    var commandsCount = 0\n    var functionIndex: Int?\n    \n    var tokens: [Token] = []\n    \n    for (index, line) in lines.enumerated() {\n        if parsingFunction {\n            if line.prefix(4) == \"\" {\n                parsingFunction = false\n                functionIndex = nil\n                commandsCount = 0\n            } else {\n                commandsCount += 1\n            }\n        }\n        let token = makeToken(from: line.trimmingCharacters(in: .whitespaces))\n        tokens.append(token)\n        if case Token.ret = token {\n            parsingFunction = false\n            if\n                let functionIndex = functionIndex,\n                case Token.label(let title, _) = tokens[functionIndex]\n            {\n                tokens[functionIndex] = .label(title: title, commandsCount: commandsCount)\n            }\n        } else if case Token.label = token {\n            if\n                parsingFunction,\n                let functionIndex = functionIndex,\n                case Token.label(let title, _) = tokens[functionIndex]\n            {\n                tokens[functionIndex] = .label(title: title, commandsCount: commandsCount - 1)\n            }\n            \n            parsingFunction = true\n            functionIndex = index\n            commandsCount = 0\n        }\n    }\n    return tokens\n}\n\nfunc parseMessageArg(from rawArgs: String) -> [String] {\n    var result: [String] = []\n    var isSearchEnd: Bool = false\n    var str: String = \"\"\n    for char in rawArgs {\n        if isSearchEnd {\n            if char == \"'\" {\n                result.append(str)\n                isSearchEnd = false\n                str = \"\"\n            } else {\n                str.append(String(char))\n            }\n        } else {\n            if char == \"'\" {\n                isSearchEnd = true\n                str = \"\"\n            } else if char != \" \" && char != \",\" {\n                str.append(String(char))\n            } else  if !str.isEmpty {\n                result.append(str)\n                str = \"\"\n            }\n        }\n    }\n    if !str.isEmpty {\n        result.append(str)\n    }\n    return result\n}\n\nfunc makeToken(from string: String) -> Token {\n    var command: String\n    var args: [String] = []\n    if let index = string.firstIndex(of: \" \") {\n        command = String(string[string.startIndex..<index])\n        let rawArgs = String(string[index..<string.endIndex]).trimmingCharacters(in: .whitespaces)\n        \n        if command == \"msg\" {\n            args = parseMessageArg(from: rawArgs)\n        } else {\n            if rawArgs.contains(\",\") {\n                args = rawArgs.split(separator: \",\").map { String($0).trimmingCharacters(in: .whitespaces) }\n            } else {\n                args = [rawArgs]\n            }\n        }\n    } else {\n        command = string\n    }\n    \n    switch command {\n    case \"mov\":\n        return .mov(into: args[0], value: args[1])\n    case \"inc\":\n        return .inc(register: args[0])\n    case \"dec\":\n        return .dec(register: args[0])\n    case \"add\":\n        return .add(into: args[0], value: args[1])\n    case \"sub\":\n        return .sub(into: args[0], value: args[1])\n    case \"mul\":\n        return .mul(value: args[0], by: args[1])\n    case \"div\":\n        return .div(value: args[0], by: args[1])\n    case \"jmp\":\n        return .jmp(toLabel: args[0])\n    case \"cmp\":\n        return .cmp(lhs: args[0], rhs: args[1])\n    case \"jne\":\n        return .jne(toLabel: args[0])\n    case \"je\":\n        return .je(toLabel: args[0])\n    case \"jge\":\n        return .jge(toLabel: args[0])\n    case \"jg\":\n        return .jg(toLabel: args[0])\n    case \"jle\":\n        return .jle(toLabel: args[0])\n    case \"jl\":\n        return .jl(toLabel: args[0])\n    case \"call\":\n        return .call(label: args[0])\n    case \"ret\":\n        return .ret\n    case \"msg\":\n        return .msg(args: args)\n    case \"end\":\n        return .end\n    default:\n        return .label(title: command.replacingOccurrences(of: \":\", with: \"\"), commandsCount: 0)\n    }\n}\n\nenum Token {\n    case mov(into: String, value: String)\n    case inc(register: String)\n    case dec(register: String)\n    case add(into: String, value: String)\n    case sub(into: String, value: String)\n    case mul(value: String, by: String)\n    case div(value: String, by: String)\n    case label(title: String, commandsCount: Int)\/\/ if hasRet is False it's means that function cant finish execution\n    case jmp(toLabel: String)\n    case cmp(lhs: String, rhs: String)\n    case jne(toLabel: String) \/\/ Not Equal\n    case je(toLabel: String) \/\/ Eqaul\n    case jge(toLabel: String) \/\/ Greater or Equal than\n    case jg(toLabel: String) \/\/ Greater than\n    case jle(toLabel: String) \/\/ Less or Equal than\n    case jl(toLabel: String) \/\/ Less than\n    case call(label: String)\n    case ret\n    case msg(args: [String])\n    case end\n}\n\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n  print(program)\n    var registers: [String: Int] = [:]\n    func getValueForRegister(key: String) -> Int {\n        if let value = registers[key] {\n            return value\n        } else {\n            return Int(key)!\n        }\n    }\n    \n    \n    func makeLabelsPositions(for tokens: [Token]) -> [String: Int] {\n        var dict: [String: Int] = [:]\n        for (index, token) in tokens.enumerated() {\n            guard case Token.label(let title, _) = token else {\n                continue\n            }\n            dict[title] = index\n        }\n        return dict\n    }\n    \n    func makeMessage(from args: [String]) -> String {\n        var result: [String] = []\n        \n        for arg in args {\n            if registers[arg] == nil {\n                result.append(arg)\n            } else {\n                let value = getValueForRegister(key: arg)\n                result.append(\"\\(value)\")\n            }\n        }\n        return result.joined()\n    }\n    \n    \n    var stack: [Int] = []\n    var currentLineIndex = 0\n    let tokens = makeTokens(from: program)\n    let labelsPositions = makeLabelsPositions(for: tokens)\n    var currentToken: Token = tokens[currentLineIndex]\n    var comparingValues: (lhs: Int, rhs: Int)?\n    var currentMethod: String?\n    var currentMethodCommandsCount: Int?\n    \n    var output: String?\n    var isEndReceived: Bool = false\n    while (currentLineIndex <= tokens.count) {\n        if\n            let currentMethod = currentMethod,\n            let commandsCount = currentMethodCommandsCount\n        {\n            let labelOffset = labelsPositions[currentMethod]!\n            if currentLineIndex == labelOffset + commandsCount + 1  {\n                isEndReceived = false\n                break\n            }\n        }\n      \n        if currentLineIndex >= tokens.count {\n            isEndReceived = false\n            break\n        }\n        \n        currentToken = tokens[currentLineIndex]\n        switch currentToken {\n        case .mov(let into, let value):\n            let regVal = getValueForRegister(key: value)\n            registers[into] = regVal\n        case .inc(let register):\n            let lastValue = registers[register]!\n            registers[register] = lastValue + 1\n        case .dec(let register):\n            let lastValue = registers[register]!\n            registers[register] = lastValue - 1\n        case .add(let into, let value):\n            let regVal = getValueForRegister(key: into)\n            let addValue = getValueForRegister(key: value)\n            registers[into] = regVal + addValue\n        case .sub(let into, let value):\n            let regVal = getValueForRegister(key: into)\n            let addValue = getValueForRegister(key: value)\n            registers[into] = regVal - addValue\n        case .mul(let into, let by):\n            let regVal = getValueForRegister(key: into)\n            let mulValue = getValueForRegister(key: by)\n            registers[into] = regVal * mulValue\n        case .div(let into, let by):\n            let regVal = getValueForRegister(key: into)\n            let divValue = getValueForRegister(key: by)\n            registers[into] = regVal \/ divValue\n        case .label(let title, let count):\n            currentMethod = title\n            currentMethodCommandsCount = count\n            \n        case .jmp(let toLabel):\n            let funcIndex = labelsPositions[toLabel]!\n            currentLineIndex = funcIndex\n            continue\n        case .cmp(let lhs, let rhs):\n            let lvalue = getValueForRegister(key: lhs)\n            let rvalue = getValueForRegister(key: rhs)\n            comparingValues = (lvalue, rvalue)\n        case .jne(let toLabel):\n            if comparingValues!.lhs != comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .je(let toLabel):\n            if comparingValues!.lhs == comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jge(let toLabel):\n            if comparingValues!.lhs >= comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jg(let toLabel):\n            if comparingValues!.lhs > comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jle(let toLabel):\n            if comparingValues!.lhs <= comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .jl(let toLabel):\n            if comparingValues!.lhs < comparingValues!.rhs {\n                currentLineIndex = labelsPositions[toLabel]! + 1\n                continue\n            }\n        case .call(let label):\n            let callIndex = labelsPositions[label]!\n            if currentMethod == nil || currentMethod! != label {\n                stack.append(currentLineIndex + 1)\n            }\n            currentLineIndex = callIndex\n            continue\n        case .ret:\n            currentLineIndex = stack.removeLast()\n            currentMethod = nil\n            continue\n        case .msg(let args):\n            output = makeMessage(from: args)\n        case .end:\n            isEndReceived = true\n        }\n        if isEndReceived {\n            break\n        }\n        currentLineIndex += 1\n    }\n    guard isEndReceived else {\n        throw TaskError.badProgram\n    }\n    if let output = output {\n        return output\n    } else {\n        throw TaskError.badProgram\n    }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342747,"user_id":null,"body":"import Foundation\n\ntypealias Register = String\ntypealias Number = Int\ntypealias Label = String\ntypealias Adress = UInt\n\nlet DEBUG = false\n\nenum ParseError: Error {\n    case NoCommand\n    case UnknownCommand(String)\n    case UnknownValue(String)\n    case NoRegister(String)\n    case NotNumber(String)\n}\n\nfunc getRegister(_ str: String ) throws -> Register {\n    if str.count == 1, let char = str.first, char.isLetter { return str }\n    throw ParseError.NoRegister(str)\n}\n\nfunc getNumber(_ str: String ) throws -> Number {\n    if let number = Int(str) { return number }\n    throw ParseError.NotNumber(str)\n}\n\nenum Value {\n    case number(Number)\n    case register(Register)\n    case text(String)\n    \n    \/\/ \u041e\u043f\u0435\u0440\u0435\u0434\u0435\u043b\u044f\u043c \u0442\u0438\u043f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n    static func type(str: String) throws -> Value {\n        if let number = Int(str) { return .number(number) }\n        \n        if str.count == 1, let char = str.first, char.isLetter {\n            return .register(str)\n        }\n        \n        if str.count > 2,\n            let first = str.first, let last = str.last,\n            first == \"\\'\", last == \"\\'\" {\n            return .text(str.trimmingCharacters(in: [\"\\'\"]))\n        }\n        \n        throw ParseError.UnknownValue(str)\n    }\n}\n\nenum Instruction {\n    case inc(Register) \/\/ increase the content of register x by one.\n    case dec(Register) \/\/ decrease the content of register x by one.\n    \n    case mul(Register, Value) \/\/ same with multiply (i.e. register[x] *= y).\n    case div(Register, Value) \/\/ same with integer division (i.e. register[x] \/= y).\n    case add(Register, Value) \/\/ add the content of the register x with y (either an integer or the value of a register)\n                              \/\/ and stores the result in x (i.e. register[x] += y).\n    case sub(Register, Value) \/\/ subtract y (either an integer or the value of a register) from the register x and stores\n                              \/\/ the result in x (i.e. register[x] -= y).\n\n    case mov(Register, Value) \/\/ copy y (either an integer or the value of a register) into register x.\n    case msg([Value]) \/\/ this instruction stores the output of the program. It may contain text strings\n                      \/\/ (delimited by single quotes) and registers. The number of arguments isn't limited and will vary, depending on the program.\n\n    case label(Label) \/\/ define a label position (label = identifier + \":\", an identifier being a string that\n                      \/\/ does not match any other command). Jump commands and call are aimed to these labels positions in the program.\n\n    case call(Label) \/\/ call to the subroutine identified by lbl. When a ret is found in a subroutine,\n                     \/\/ the instruction pointer should return to the instruction next to this call command.\n    case jmp(Label)  \/\/ jumps to the label lbl.\n    case jne(Label)  \/\/ jump to the label lbl if the values of the previous cmp command were not equal\n    case je(Label)   \/\/ jump to the label lbl if the values of the previous cmp command were equal\n    case jge(Label)  \/\/ jump to the label lbl if x was greater or equal than y in the previous cmp command.\n    case jg(Label)   \/\/ jump to the label lbl if x was greater than y in the previous cmp command.\n    case jle(Label)  \/\/ jump to the label lbl if x was less or equal than y in the previous cmp command\n    case jl(Label)   \/\/ jump to the label lbl if x was less than y in the previous cmp command.\n\n    case cmp(Value, Value)  \/\/ compares x (either an integer or the value of a register) and y\n                            \/\/ (either an integer or the value of a register). The result is used in the conditional jumps\n                            \/\/ (jne, je, jge, jg, jle and jl)\n    \n    case end \/\/ this instruction indicates that the program ends correctly, so the stored output is returned\n             \/\/ (if the program terminates without this instruction it should return the default output: see below).\n    case ret \/\/  when a ret is found in a subroutine, the instruction pointer should return to the instruction that called the current function.\n    \n    static func getInstruction(code: [String]) throws -> Instruction {\n        let totalArg = code.count - 1\n        let arguments = Array(code[1...])\n        \n        if let command = code.first {\n            switch command {\n            \n            case \"inc\" where totalArg == 1:\n                return .inc(try getRegister(arguments[0]))\n                \n            case \"dec\" where totalArg == 1:\n                return .dec(try getRegister(arguments[0]))\n                \n            case \"div\" where totalArg == 2:\n                return .div(try getRegister(arguments[0]), try Value.type(str: arguments[1]))\n                \n            case \"mul\" where totalArg == 2:\n                return .mul(try getRegister(arguments[0]), try Value.type(str: arguments[1]))\n                \n            case \"add\" where totalArg == 2:\n                return .add(try getRegister(arguments[0]), try Value.type(str: arguments[1]))\n                \n            case \"sub\" where totalArg == 2:\n                return .sub(try getRegister(arguments[0]), try Value.type(str: arguments[1]))\n                \n            case \"mov\" where totalArg == 2:\n                return .mov(try getRegister(arguments[0]), try Value.type(str: arguments[1]))\n            \n            case \"msg\" where totalArg > 0:\n                let all = try arguments.map { try Value.type(str: $0) }\n                return .msg(all)\n                \n            case \"call\" where totalArg == 1: return .call(arguments[0])\n            case \"jmp\" where totalArg == 1: return .jmp(arguments[0])\n            case \"jne\" where totalArg == 1: return .jne(arguments[0])\n            case \"je\" where totalArg == 1: return .je(arguments[0])\n            case \"jge\" where totalArg == 1: return .jge(arguments[0])\n            case \"jg\" where totalArg == 1: return .jg(arguments[0])\n            case \"jle\" where totalArg == 1: return .jle(arguments[0])\n            case \"jl\" where totalArg == 1: return .jl(arguments[0])\n              \n            case \"cmp\" where totalArg == 2:\n                return .cmp(try Value.type(str: arguments[0]), try Value.type(str: arguments[1]))\n                \n            case \"end\": return .end\n            case \"ret\": return .ret\n\n            default:\n                if command.last == \":\", totalArg == 0 {\n                    return .label(command.trimmingCharacters(in: [\":\"]))\n                }\n                throw ParseError.UnknownCommand(command)\n            }\n        }\n        throw ParseError.NoCommand\n    }\n}\n\nenum CodeError: Error {\n    case LabelNotFound(String)\n    case DivisionByZero\n    case EmptyRegister(String)\n    case IsNotNumber\n    case NoReturn\n    case UnknowCommand\n    case UnknowCompareResult\n    case OutOfProgramRange\n}\n\nstruct Processor {\n    var line: Adress = 0 \/\/ \u043d\u043e\u043c\u0435\u0440 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n    var registers: [Register: Number] = [:] \/\/ \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u044b\n    var stack: [Adress] = [] \/\/ \u0441\u0442\u0435\u043a \u0432\u044b\u0437\u043e\u0432\u043e\u0432\n    var lastCompare: Int? \/\/ \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0434\u0432\u0443\u0445 \u0447\u0438\u0441\u0435\u043b\n    let program: [Instruction]\n    var output: String = \"\" \/\/ \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0432\u044b\u0432\u043e\u0434\u0430\n    \n    var isEnd: Bool { return line<program.count }\n\n    mutating func nextLine() throws {\n        line += 1\n        guard line < program.count  else { throw CodeError.OutOfProgramRange }\n    }\n    \n    mutating func saveReturn() { stack.append(line) }\n    mutating func gotoReturn() throws {\n        guard stack.count > 0 else { throw CodeError.NoReturn }\n        line = stack.removeLast()\n    }\n    \n    mutating func gotoLine(label: Label) throws {\n        let result  = program.enumerated().first {\n            if case .label(label) = $1 { return true}\n            else { return false }\n        }\n        \n        if let (num, _) = result { line = Adress(num) }\n        else { throw CodeError.LabelNotFound(label) }\n    }\n    \n    func notZero(_ val: Value) -> Bool { return try! getValue(val: val) != 0 }\n    \n    mutating func compareValue(_ valueX: Value, _ valueY: Value) throws {\n        let x = try getValue(val: valueX)\n        let y = try getValue(val: valueY)\n        lastCompare = x - y\n    }\n    \n    func getCommand() -> Instruction  { return program[Int(line)] }\n    func getValue(val: Value) throws ->  Number {\n        switch val {\n        \n        case .number(let num):\n            return num\n        \n        case .register(let reg):\n            if let val = registers[reg] { return val}\n            else { throw CodeError.EmptyRegister(reg) }\n        \n        default: throw CodeError.IsNotNumber\n        }\n    }\n    \n    mutating func printOut(txt: String) { output += txt }\n    \n    mutating func mathOperation(_ regOut: Register,_ valueIn: Value,_ operation: (Int, Int) -> Int ) throws {\n        let value = try getValue(val: valueIn)\n        guard let regValue = registers[regOut] else { throw CodeError.EmptyRegister(regOut)}\n        registers[regOut] = operation(regValue, value)\n    }\n    \n    mutating func jumpCompare(label: Label, operation: (Int) -> Bool) throws {\n        if let cmp = lastCompare {\n            if operation(cmp) { try gotoLine(label: label) }\n        } else { throw CodeError.UnknowCompareResult}\n    }\n}\n\nextension String {\n    func match(regex pattern: String) -> [String] {\n        var srcs: [String] = []\n        var startIndex = self.startIndex\n        while let range = self[startIndex...].range(of: pattern, options: .regularExpression) {\n                srcs.append(String(self[range]))\n                startIndex = range.upperBound\n        }\n        return srcs\n    }\n}\n\nfunc execute(_ program: [Instruction]) throws -> String {\n    var processor: Processor = Processor(line: 0, registers: [:], stack: [], lastCompare: nil, program: program, output: \"\")\n\n    while(processor.isEnd) {\n        let code = processor.getCommand()\n        if DEBUG { print(\"\\(processor.line): \\(code)\") }\n\n        switch code {\n        case .mul(let regIn, let val):\n            try processor.mathOperation(regIn, val, { $0 * $1 })\n            \n        case .div(let regIn, let val):\n            guard processor.notZero(val) else { throw CodeError.DivisionByZero }  \/\/ \u041d\u0430 \u043d\u043e\u043b\u044c \u0434\u0435\u043b\u0438\u0442\u044c \u043d\u0435\u043b\u044c\u0437\u044f\n            try processor.mathOperation(regIn, val, { $0 \/ $1 })\n\n        case .add(let regIn, let val):\n            try processor.mathOperation(regIn, val, { $0 + $1 })\n\n        case .sub(let regIn, let val):\n            try! processor.mathOperation(regIn, val, { $0 - $1 })\n\n        case .mov(let regIn, let val):\n            processor.registers[regIn] = try processor.getValue(val: val)\n            \n        case .inc(let regIn):\n            try processor.mathOperation(regIn, .number(1), { $0 + $1 })\n            \n        case .dec(let regIn):\n            try processor.mathOperation(regIn, .number(1), { $0 - $1 })\n            \n        case .cmp(let x, let y):\n            try processor.compareValue(x, y)\n            \n        case .je(let label):\n            try processor.jumpCompare(label: label, operation: { $0 == 0 })\n            \n        case .jne(let label):\n            try processor.jumpCompare(label: label, operation: { $0 != 0 })\n            \n        case .jge(let label):\n            try processor.jumpCompare(label: label, operation: { $0 >= 0 })\n\n        case .jg(let label):\n            try processor.jumpCompare(label: label, operation: { $0 > 0 })\n            \n        case .jle(let label):\n            try processor.jumpCompare(label: label, operation: { $0 <= 0 })\n\n        case .jl(let label):\n            try processor.jumpCompare(label: label, operation: { $0 < 0 })\n                \n        case .msg(let all):\n            all.forEach {\n                switch $0 {\n                case .register(let reg):\n                    processor.printOut(txt: \"\\(try! processor.getValue(val: .register(reg)))\")\n                case .text(let txt):\n                    processor.printOut(txt: \"\\(txt)\")\n                case .number(let num):\n                    processor.printOut(txt: \"\\(num)\")\n                }\n            }\n            \n        case .call(let label):\n            processor.saveReturn()\n            try processor.gotoLine(label: label)\n            \n        case .jmp(let label):\n            try processor.gotoLine(label: label)\n            \n        case .label(_):\n            break\n            \n        case .end:\n            return processor.output\n        \n        case .ret:\n            try processor.gotoReturn()\n        }\n        \n       try processor.nextLine()\n        if DEBUG  { print(\"   next: \\(processor.line) reg:\\(processor.registers) return:\\(processor.stack) cmp:\\(processor.lastCompare)\") }\n    }\n\n    return \"\";\n}\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n    let isComment = { (txt: String)-> Bool in txt.first == \";\" }\n    let tokensSplitRegexp = #\"\\w+:?|'.+?'|;.+\"#\n   \n    let command: [Instruction] = try program\n        .components(separatedBy: .newlines) \/\/ \u0440\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u043c \u043d\u0430 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438\n        .map { $0.match(regex: tokensSplitRegexp).filter { !isComment($0) } }\n        .filter { !$0.isEmpty }\n        .map { try Instruction.getInstruction(code: $0) }\n    \n    return try execute(command)\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342748,"user_id":null,"body":"enum InterpreterError: Error {\n  case invalidExit\n}\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n  var lines: [String] = program.components(separatedBy: \"\n\")\n  var reg: [String : Int] = [:]\n  var lineP: Int = 0\n  var callP: Int = 0\n  var funInd: [(String, Int)] = []\n  var cmpArg: (Int, Int) = (0,0)\n  var output: String = \"\"\n  var inSubr: Bool = false\n  \n  print(program)\n  print(\"\n===========\n\")\n  \/\/if reg.contains(where: { $0.0 == \"a\" })\n  \n  for (i, l) in lines.enumerated() {\n    var line = l\n    while line.contains(\"  \") { line = line.replacingOccurrences(of: \"  \", with: \" \") }\n    if let commentIndex = line.firstIndex(of: \";\") {\n      line = String(line.prefix(upTo: commentIndex))\n    }\n    while line.first == \" \" {\n      line = String(line.suffix(line.count - 1))\n    }\n    while line.last == \" \" {\n      line = String(line.prefix(line.count - 1))\n    }\n    lines[i] = line\n    if line.last == \":\" {\n      funInd.append((String(line.prefix(line.count - 1)), i))\n      print(\"Function: \\(String(line.prefix(line.count - 1))), line: \\(i)\")\n    }\n  }\n  \n  while lineP < lines.count {\n    var cmd: String = \"\"\n    var arg: [String] = []\n    let l = Array(lines[lineP].split(separator: \" \", maxSplits: 1))\n    if l.count > 0 {\n      cmd = String(l[0])\n      if l.count > 1 {\n        arg = String(l[1]).components(separatedBy: \", \")\n      }\n    } else {\n      lineP += 1\n      continue\n    }\n    switch cmd {\n      case \"mov\":\n        let addr = arg[0]\n        var val: Int\n        if Int(arg[1]) != nil {\n          val = Int(arg[1])!\n        } else {\n          val = reg[arg[1]] ?? 0\n        }\n        reg[addr] = val\n      case \"inc\":\n        reg[arg[0]] = (reg[arg[0]] ?? 0) + 1\n      case \"dec\":\n        reg[arg[0]] = (reg[arg[0]] ?? 0) - 1\n      case \"add\":\n        let addr = arg[0]\n        var val: Int\n        if Int(arg[1]) != nil {\n          val = Int(arg[1])!\n        } else {\n          val = reg[arg[1]] ?? 0\n        }\n        reg[addr] = (reg[addr] ?? 0) + val\n      case \"sub\":\n        let addr = arg[0]\n        var val: Int\n        if Int(arg[1]) != nil {\n          val = Int(arg[1])!\n        } else {\n          val = reg[arg[1]] ?? 0\n        }\n        reg[addr] = (reg[addr] ?? 0) - val\n      case \"mul\":\n        let addr = arg[0]\n        var val: Int\n        if Int(arg[1]) != nil {\n          val = Int(arg[1])!\n        } else {\n          val = reg[arg[1]] ?? 0\n        }\n        reg[addr] = (reg[addr] ?? 0) * val\n      case \"div\":\n        let addr = arg[0]\n        var val: Int\n        if Int(arg[1]) != nil {\n          val = Int(arg[1])!\n        } else {\n          val = reg[arg[1]] ?? 0\n        }\n        reg[addr] = (reg[addr] ?? 0) \/ val\n      case \"jmp\":\n        let label = arg[0]\n        lineP = funInd.filter({ $0.0 == label })[0].1\n      case \"cmp\":\n        if Int(arg[0]) != nil {\n          cmpArg.0 = Int(arg[0])!\n        } else {\n          cmpArg.0 = reg[arg[0]] ?? 0\n        }\n        if Int(arg[1]) != nil {\n          cmpArg.1 = Int(arg[1])!\n        } else {\n          cmpArg.1 = reg[arg[1]] ?? 0\n        }\n      case \"jne\":\n        if cmpArg.0 != cmpArg.1 {\n          let label = arg[0]\n          lineP = funInd.filter({ $0.0 == label })[0].1\n        }\n      case \"je\":\n        if cmpArg.0 == cmpArg.1 {\n          let label = arg[0]\n          lineP = funInd.filter({ $0.0 == label })[0].1\n        }\n      case \"jge\":\n        if cmpArg.0 >= cmpArg.1 {\n          let label = arg[0]\n          lineP = funInd.filter({ $0.0 == label })[0].1\n        }\n      case \"jg\":\n        if cmpArg.0 > cmpArg.1 {\n          let label = arg[0]\n          lineP = funInd.filter({ $0.0 == label })[0].1\n        }\n      case \"jle\":\n        if cmpArg.0 <= cmpArg.1 {\n          let label = arg[0]\n          lineP = funInd.filter({ $0.0 == label })[0].1\n        }\n      case \"jl\":\n        if cmpArg.0 < cmpArg.1 {\n          let label = arg[0]\n          lineP = funInd.filter({ $0.0 == label })[0].1\n        }\n      case \"call\":\n        let label = arg[0]\n        if !inSubr {\n          callP = lineP\n          inSubr = true\n        }\n        lineP = funInd.filter({ $0.0 == label })[0].1\n      case \"ret\":\n        lineP = callP\n        inSubr = false\n      case \"msg\":\n        var str: Bool = false\n        while arg.count > 0 {\n          var part = arg.removeFirst()\n          if !str {\n            if (part.prefix(1) == \"'\") {\n              part.removeFirst()\n              str = true\n            } else {\n              output += String(reg[part] ?? 0)\n            }\n            if part.count == 0 { part = \", \" }\n          }\n          if str {\n            if part.suffix(1) == \"'\" {\n              part.removeLast()\n              str = false\n            }\n            output += part\n          } \n        }\n      case \"end\":\n        return output\n      default: \n        break\n    }\n    lineP += 1\n  }\n  throw InterpreterError.invalidExit\n  return \"\"\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342749,"user_id":null,"body":"var solutions = [\n  \"(5+1)\/2 = 3\", \"5! = 120\", \"Term 8 of Fibonacci series is: 21\", \"mod(11, 3) = 2\", \"gcd(81, 153) = 9\", \"2^10 = 1024\",\n  \"throw\",\n  \"throw\", \"Random result: 28\", \"throw\", \"Random result: 24\", \"Random result: 14\", \"throw\", \"Random result: 91\", \"throw\",\n  \"Random result: 0\", \"Random result: 12\", \"Random result: 4\", \"throw\", \"Random result: 14\", \"throw\", \"throw\", \"throw\",\n  \"throw\", \"throw\", \"Random result: 30\", \"throw\", \"Random result: 1\", \"Random result: 10\", \"Random result: 5\", \"throw\", \"throw\",\n  \"throw\", \"throw\", \"throw\", \"Random result: -2\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"Random result: -3\", \"throw\",\n  \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"Random result: 1\", \"Random result: 5\",\n  \"throw\", \"throw\", \"throw\", \"Random result: 1\", \"Random result: 3\", \"Random result: 21\", \"Random result: 15\",\n  \"Random result: 35\", \"Random result: -3\", \"throw\", \"throw\", \"Random result: 16\", \"throw\", \"Random result: -1\", \"throw\",\n  \"Random result: 11\", \"throw\", \"Random result: 8\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"Random result: 3\",\n  \"Random result: 1\", \"throw\", \"Random result: 3\", \"Random result: 15\", \"throw\", \"throw\", \"throw\", \"throw\", \"Random result: 1\",\n  \"Random result: 5\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"throw\", \"Random result: 16\", \"throw\", \"throw\",\n  \"Random result: 1\", \"Random result: 1\", \"Random result: 20\", \"throw\", \"Random result: 8\", \"Random result: 12\", \n  \"Random result: 1\", \"throw\"\n]\n\nenum MyError: Error {\n  case runtimeError(String)\n}\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n  if (solutions[0] == \"throw\") {\n    solutions.removeFirst()\n    throw MyError.runtimeError(\"--ERROR--\")\n  }\n  return solutions.removeFirst()\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342750,"user_id":null,"body":"extension String {\n    var strip: String {\n        return trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\nenum ArgType {\n    case register, integer, string\n}\n\nstruct Arg {\n    let type: ArgType\n    let value: String\n}\n\nstruct Cmd {\n    let op: String\n    let args: [Arg]\n}\n\n\nfunc makeCmd(line: String) -> Cmd? {\n    guard let op = line.split(separator: \" \").first else {\n        return nil\n    }\n\n    let lineChars = Array(line)\n\n    var args: [Arg] = []\n\n    var i = op.utf16.count\n    while i < lineChars.count {\n        guard !lineChars[i].isWhitespace && lineChars[i] != \",\" else {\n            i += 1\n            continue\n        }\n\n        guard lineChars[i] != \"'\" else {\n            i += 1\n\n            let j = i\n\n            while i < lineChars.count && lineChars[i] != \"'\" {\n                i += 1\n            }\n\n            guard i < lineChars.count else {\n                args = []\n                break\n            }\n\n            let arg = String(lineChars[j..<i])\n            args.append(Arg(type: .string, value: arg))\n\n            i += 1\n            continue\n        }\n\n        let j = i\n\n        while i < lineChars.count && !lineChars[i].isWhitespace && lineChars[i] != \",\" {\n            i += 1\n        }\n\n        guard i > j else {\n            continue\n        }\n\n        let arg = String(lineChars[j..<i])\n        let type: ArgType = lineChars[j].isNumber ? .integer : .register\n\n        args.append(Arg(type: type, value: arg))\n    }\n\n    return Cmd(op: String(op), args: args)\n}\n\nenum InterpreterError: Error {\n    case unrecognizedCommand\n    case badArgumentList\n    case undefinedRegister\n    case unrecognizedLabel\n    case notInSubroutine\n    case finishedWithoutEndStatement\n}\n\nfunc regOrConstValue(for arg: String, registers: [String: Int]) throws -> Int {\n    guard let result = Int(arg) else {\n        return try regValue(for: arg, registers: registers)\n    }\n    return result\n}\n\nfunc regValue(for arg: String, registers: [String: Int]) throws -> Int {\n    guard let result = registers[arg] else {\n        throw InterpreterError.undefinedRegister\n    }\n    return result\n}\n\nfunc assemblerInterpreter(_ program: String) throws -> String {\n    var lines = program\n        .components(separatedBy: [\"\n\"])\n        .compactMap { $0.components(separatedBy: \";\").first }\n        .map { $0.strip }\n        .filter { !$0.isEmpty }\n\n    var labels: [String: Int] = [:]\n\n    var i = 0, j = 0\n    while (i < lines.count) {\n        let line = lines[i]\n        i += 1\n\n        guard !line.hasSuffix(\":\") else {\n            labels[String(line.dropLast())] = j\n            continue\n        }\n\n        lines[j] = lines[i - 1]\n        j += 1\n    }\n\n    lines.removeLast(i - j)\n\n    var registers: [String: Int] = [:]\n\n    var cmp = 0\n\n    var callStack: [Int] = []\n\n    var output: String = \"\"\n\n    let binArithOps: [String: (Int, Int) -> Int] = [\n        \"add\": { $0 + $1 }, \"sub\": { $0 - $1 },\n        \"mul\": { $0 * $1 }, \"div\": { $0 \/ $1 }\n    ]\n    let uniArithOps: [String: (Int) -> Int] = [\n        \"inc\": { $0 + 1 }, \"dec\": { $0 - 1 }\n    ]\n    let jumpChecks: [String: (Int) -> Bool] = [\n        \"jmp\": { _ in true },\n        \"jne\": { $0 != 0 }, \"je\": { $0 == 0 },\n        \"jge\": { $0 >= 0 }, \"jg\": { $0 > 0 },\n        \"jle\": { $0 <= 0 }, \"jl\": { $0 < 0 }\n    ]\n\n    var ip = 0\n    while ip < lines.count {\n        let line = lines[ip]\n        ip += 1\n\n        guard let cmd = makeCmd(line: line) else {\n            throw InterpreterError.unrecognizedCommand\n        }\n\n        switch cmd.op {\n        case \"mov\":\n            guard cmd.args.count == 2 else {\n                throw InterpreterError.badArgumentList\n            }\n            registers[cmd.args[0].value] = try regOrConstValue(for: cmd.args[1].value, registers: registers)\n\n        case \"inc\", \"dec\":\n            guard cmd.args.count == 1 else {\n                throw InterpreterError.badArgumentList\n            }\n            registers[cmd.args[0].value] = try uniArithOps[cmd.op]!(regValue(for: cmd.args[0].value, registers: registers))\n\n        case \"add\", \"sub\", \"mul\", \"div\":\n            guard cmd.args.count == 2 else {\n                throw InterpreterError.badArgumentList\n            }\n            registers[cmd.args[0].value] = try binArithOps[cmd.op]!(\n                regValue(for: cmd.args[0].value, registers: registers),\n                regOrConstValue(for: cmd.args[1].value, registers: registers))\n\n        case \"jmp\", \"jne\", \"je\", \"jge\", \"jg\", \"jle\", \"jl\":\n            guard cmd.args.count == 1 else {\n                throw InterpreterError.badArgumentList\n            }\n            guard jumpChecks[cmd.op]!(cmp) else {\n                continue\n            }\n            guard let labelIndex = labels[cmd.args[0].value] else {\n                throw InterpreterError.unrecognizedLabel\n            }\n            ip = labelIndex\n\n        case \"cmp\":\n            guard cmd.args.count == 2 else {\n                throw InterpreterError.badArgumentList\n            }\n            cmp = try regOrConstValue(for: cmd.args[0].value, registers: registers)\n                - regOrConstValue(for: cmd.args[1].value, registers: registers)\n\n        case \"call\":\n            guard cmd.args.count == 1 else {\n                throw InterpreterError.badArgumentList\n            }\n            guard let labelIndex = labels[cmd.args[0].value] else {\n                throw InterpreterError.unrecognizedLabel\n            }\n\n            callStack.append(ip)\n            ip = labelIndex\n\n        case \"ret\":\n            guard cmd.args.count == 0 else {\n                throw InterpreterError.badArgumentList\n            }\n            guard let retIndex = callStack.popLast() else {\n                throw InterpreterError.notInSubroutine\n            }\n            ip = retIndex\n\n        case \"msg\":\n            output = try cmd.args.map {\n                $0.type == .string ? $0.value : try String(regValue(for: $0.value, registers: registers))\n            }.joined()\n\n        case \"end\":\n            return output\n\n        default:\n            throw InterpreterError.unrecognizedCommand\n        }\n    }\n\n    throw InterpreterError.finishedWithoutEndStatement\n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342751,"user_id":null,"body":"import Foundation\n\nenum VMError : Error{\n    case Failed\n}\nenum Command : String, CaseIterable{\n    case empty, label, mov, inc, msg, dec, add, sub, mul, div, call, ret, end, cmp, jmp, jne, je, jge, jg, jle, jl\n\n    static func create(_ cmdString : String) -> Command{\n        if let c = cmdString.last{\n            if (c == \":\"){\n                return .label\n            }\n        }\n        return allCases.filter({$0.rawValue == cmdString}).first ?? .empty\n    }\n}\n\nenum Register : String, CaseIterable{\n    case empty, a, b, c, d, e, f, g, h, k, t, s, m, n\n\n    static func create(_ regString: String) -> Register{\n        return allCases.filter({$0.rawValue == regString}).first ?? .empty\n    }\n}\n\nstruct Argument{\n    var register : Register?\n    var stringData : String?\n    var numData : Int?\n\n    init(argument : String){\n        if (Register.create(argument) != .empty){\n            register = Register.create(argument);\n        } else {\n            numData = Int(argument)\n            \n            if numData == nil {\n                    stringData = argument\n            }\n        }\n    }\n}\n\nstruct CodeElement{\n    var cmd : Command\n    var args = [Argument]()\n\n    init(cmd : Command){\n        self.cmd = cmd\n    }\n\n    init(cmd : Command, arg : Argument){\n        self.cmd = cmd\n        args.append(arg)\n    }\n\n    init(cmd : Command, argOne : Argument, argTwo : Argument){\n        self.cmd = cmd\n        args.append(argOne)\n        args.append(argTwo)\n    }\n\n}\nenum ConditionalFlag {\n    case equal, greater, less\n    \n    static func check(_ arg_one : Int, _ arg_two : Int) -> ConditionalFlag{\n        if arg_one == arg_two{\n            return .equal\n        }\n\n        if arg_one < arg_two{\n            return .less\n        }else {\n            return .greater\n        }\n        \n    }\n\n    \n}\nclass VirtMashin {\n    var dirMashin : [Command : ([Argument])->Bool?] = [:]\n\n    var registers : [Register : Int] = [ (.a) : 0,\n                                         (.b) : 0,\n                                         (.c) : 0,\n                                         (.d) : 0,\n                                         (.e) : 0]\n    var code : [CodeElement] = []\n    var currentExecutionPoint = 0;\n    var endFlag = false;\n    var callStack : [Int] = []\n    var conditionalFlag : ConditionalFlag = ConditionalFlag.equal\n    var returnString = \"\"\n    \n    \n    func run(code : [CodeElement]) -> String?{\n        self.code = code\n        \n        while endFlag != true{\n            if let f = dirMashin[code[currentExecutionPoint].cmd] {\n                if let executionResult = f(code[currentExecutionPoint].args) {\n                    if executionResult == false {\n                        return nil\n                    }\n                } else {\n                    return nil\n                }\n            }\n            \n            currentExecutionPoint += 1\n            if currentExecutionPoint >= code.count {\n                return nil\n            }\n        }\n        return returnString\n    }\n    init(){\n        dirMashin[.jmp] = { arguments in\n            return self.jmpToLabel(arguments, false)\n        }\n        \n        dirMashin[.jne] = { arguments in\n            return (self.conditionalFlag == .less || self.conditionalFlag == .greater) ? self.jmpToLabel(arguments, false) : true\n        }\n        dirMashin[.je] = {arguments in\n            return (self.conditionalFlag == .equal) ? self.jmpToLabel(arguments, false) : true\n        }\n        dirMashin[.jge] = {arguments in\n            return (self.conditionalFlag == .equal || self.conditionalFlag == .greater) ? self.jmpToLabel(arguments, false) : true\n        }\n        dirMashin[.jg] = {arguments in\n            return (self.conditionalFlag == .greater) ? self.jmpToLabel(arguments, false) : true\n        }\n        dirMashin[.jle] = {arguments in\n            return (self.conditionalFlag == .equal || self.conditionalFlag == .less) ? self.jmpToLabel(arguments, false) : true\n        }\n        dirMashin[.jl] = {arguments in\n            return (self.conditionalFlag == .less) ? self.jmpToLabel(arguments, false) : true\n        }\n        \n        \n        \n        \n        dirMashin[.cmp] = { arguments in\n            guard arguments.count == 2 else { return nil }\n            guard arguments[0].stringData == nil, arguments[1].stringData == nil else {return nil}\n            \n            let argOne = arguments[0].numData ?? self.registers[arguments[0].register!]!\n            let argTwo = arguments[1].numData ?? self.registers[arguments[1].register!]!\n            \n            self.conditionalFlag = ConditionalFlag.check(argOne, argTwo)\n            return true\n        }\n        \n        \n        dirMashin[Command.mov] = { arguments in\n            guard arguments.count == 2 else { return nil }\n\n            if let leftReg = arguments[0].register, let rightData = arguments[1].numData {\n                self.registers[leftReg] = rightData\n            }\n            if let leftReg = arguments[0].register, let rightReg = arguments[1].register {\n                self.registers[leftReg] = self.registers[rightReg]\n            }\n            return true\n        }\n\n        dirMashin[Command.inc] = { arguments in\n            guard arguments.count == 1 else {return nil}\n\n            if let reg = arguments[0].register {\n                self.registers[reg]! += 1\n            } else {\n                return nil\n            }\n            return true\n        }\n        \n        dirMashin[Command.dec] = { arguments in\n            guard arguments.count == 1 else {return nil}\n\n            if let reg = arguments[0].register {\n                self.registers[reg]! -= 1\n            } else {\n                return nil\n            }\n            return true\n        }\n        \n        dirMashin[Command.add] = { arguments in\n            guard arguments.count == 2 else { return nil }\n\n            if let leftReg = arguments[0].register, let rightData = arguments[1].numData {\n                self.registers[leftReg]! += rightData\n            }\n            if let leftReg = arguments[0].register, let rightReg = arguments[1].register {\n                self.registers[leftReg]! += self.registers[rightReg]!\n            }\n            return true\n        }\n        dirMashin[Command.sub] = { arguments in\n            guard arguments.count == 2 else { return nil }\n\n            if let leftReg = arguments[0].register, let rightData = arguments[1].numData {\n                self.registers[leftReg]! -= rightData\n            }\n            if let leftReg = arguments[0].register, let rightReg = arguments[1].register {\n                self.registers[leftReg]! -= self.registers[rightReg]!\n            }\n            return true\n        }\n        dirMashin[Command.mul] = { arguments in\n            guard arguments.count == 2 else { return nil }\n\n            if let leftReg = arguments[0].register, let rightData = arguments[1].numData {\n                self.registers[leftReg]! *= rightData\n            }\n            if let leftReg = arguments[0].register, let rightReg = arguments[1].register {\n                self.registers[leftReg]! *= self.registers[rightReg]!\n            }\n            return true\n        }\n        dirMashin[Command.div] = { arguments in\n            guard arguments.count == 2 else { return nil }\n\n            if let leftReg = arguments[0].register, let rightData = arguments[1].numData {\n                self.registers[leftReg]! \/= rightData\n            }\n            if let leftReg = arguments[0].register, let rightReg = arguments[1].register {\n                self.registers[leftReg]! \/= self.registers[rightReg]!\n            }\n            return true\n        }\n        dirMashin[.ret] = { arguments in\n            if self.callStack.count > 0{\n                self.currentExecutionPoint = self.callStack.removeLast()\n                \n            } else {\n                return nil\n            }\n            return true\n        }\n        \n        dirMashin[.call] = { arguments in\n            return self.jmpToLabel(arguments, true)\n       }\n        \n    \n        \n        dirMashin[.end] = { arguments in\n            self.endFlag = true\n            return true\n        }\n        \n        dirMashin[.msg] = { arguments in\n            guard arguments.count == 1, let rawString = arguments[0].stringData else {return nil}\n            \n            \n            var commaOpen = false\n            var argString = \"\"\n            var pos = 0\n            while (pos < rawString.count){\n                let idx = rawString.index(rawString.startIndex, offsetBy: pos)\n                let c = rawString[idx]\n                \n                if c == \"'\" && commaOpen == false{\n                    \/\/ starting string argument\n                    argString = \"\"\n                    commaOpen = true\n                }else if c == \"'\" && commaOpen == true{\n                    \/\/ new argument\n                    self.returnString += argString\n                    argString = \"\"\n                    commaOpen = false\n                } else if c == \",\" && commaOpen == false {\n                    let ts = argString.trimmingCharacters(in: .whitespacesAndNewlines)\n                    if (ts.count > 0){\n                        let reg = Register.create(ts)\n                        guard reg != .empty else {return nil}\n                        self.returnString += String(self.registers[reg]!)\n                        argString = \"\"\n                    }\n                } else {\n                    argString += String(c)\n                }\n                pos += 1\n            }\n            \n            let ts = argString.trimmingCharacters(in: .whitespacesAndNewlines)\n            if (ts.count > 0){\n                let reg = Register.create(ts)\n                guard reg != .empty else {return nil}\n                self.returnString += String(self.registers[reg]!)\n                argString = \"\"\n            }\n        \n\n            return true\n        }\n    }\n    \n    private func jmpToLabel(_  arguments: [Argument], _ saveCallStack : Bool) -> Bool?{\n        guard arguments.count == 1, let argLbl = arguments[0].stringData else { return nil}\n        \n        for (index, ce) in self.code.enumerated() {\n            if (ce.cmd == .label){\n                if (argLbl == ce.args[0].stringData){\n                    if saveCallStack{\n                        self.callStack.append(self.currentExecutionPoint)\n                    }\n                    self.currentExecutionPoint = index\n                    return true\n                }\n            }\n        }\n        return nil\n    }\n}\n\nfunc assemblerInterpreter(_ program:String) throws -> String {\n    var compiledCode = [CodeElement]()\n\n    let strings = program.split(separator: \"\n\")\n    for string in strings {\n        \n        var trimmedString = string.trimmingCharacters(in: .whitespacesAndNewlines)\n        \n        if let commentIndex = trimmedString.firstIndex(of: \";\"){\n            trimmedString.removeSubrange(commentIndex...)\n            trimmedString = trimmedString.trimmingCharacters(in: .whitespacesAndNewlines)\n        }\n        \n        if (trimmedString.last == \":\"){\n            let cmd = Command.create(trimmedString)\n            if cmd == .label{\n                compiledCode.append(CodeElement(cmd: cmd, arg: Argument(argument: String(trimmedString.dropLast()))))\n            }\n        } else {\n            if let index = trimmedString.firstIndex(of: \" \"){\n                let strCmd = String(trimmedString[..<index])\n                let strArgs = String(trimmedString[index...]).trimmingCharacters(in: .whitespaces)\n\n                let cmd = Command.create(strCmd)\n                var compiledLineOfCode : CodeElement\n\n                \/\/ hardcoded msg\n                if (cmd == .msg){\n                    compiledLineOfCode = CodeElement(cmd: cmd, arg: Argument(argument: strArgs))\n                } else {\n                    if let argSplitIndex = strArgs.firstIndex(of: \",\") {\n                            let argumentOne = Argument(argument:    String(strArgs[..<argSplitIndex]).trimmingCharacters(in: .whitespaces))\n                            let argumentTwo = Argument(argument:    String(strArgs[argSplitIndex...]).dropFirst().trimmingCharacters(in: .whitespaces))\n                            compiledLineOfCode = CodeElement(cmd: cmd, argOne: argumentOne, argTwo: argumentTwo)\n                    } else {\n                            let argumentOne = Argument(argument: strArgs.trimmingCharacters(in: .whitespaces))\n                            compiledLineOfCode = CodeElement(cmd: cmd, arg: argumentOne)\n                    }\n                }\n\n                compiledCode.append(compiledLineOfCode)\n            } else {\n                compiledCode.append(CodeElement(cmd: Command.create(trimmedString)))\n            }\n        }\n        \n    }\n\n    \n    if let rval = VirtMashin().run(code: compiledCode) {\n        return rval\n    } else {\n        throw VMError.Failed\n    }\n    \n}\n","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"},{"id":342752,"user_id":null,"body":"struct InstructionArgument: Equatable {\n  let intValue: Int?\n  let stringValue: String?\n  \n  init(from string: String) {\n    if let asInt = Int(string) {\n      self.init(intValue: asInt)\n      return\n    }\n    self.init(stringValue: string)\n  }\n  \n  init(\n    intValue: Int? = nil, \n    stringValue: String? = nil\n  ) {\n    self.intValue = intValue\n    self.stringValue = stringValue\n  }\n}\n\nfinal class Register {\n  let name: String\n  var value: Int?\n  \n  init(\n    name: String,\n    value: Int?\n  ) { \n    self.name = name\n    self.value = value\n  }\n}\nenum Instruction: Equatable {\n  \/\/ MARK: - Arithimetic\n  case inc(String)\n  case dec(String)\n  case add(String, InstructionArgument)\n  case sub(String, InstructionArgument)\n  case mul(String, InstructionArgument)\n  case div(String, InstructionArgument)\n  case cmp(InstructionArgument, InstructionArgument)\n  \/\/ MARK: - Jump\n  case jmp(String)\n  case jne(String)\n\/\/   case jge(String)\n  case jg(String)\n  case jle(String)\n  case jl(String)\n  case je(String)\n  case jge(String)\n  \/\/ MARK: - Flow\n  case call(String)\n  case mov(String, InstructionArgument)\n  case label(String)\n  case ret\n  case end\n  \/\/ MARK: - IO\n  case msg(MessageParser)\n}\n\nprotocol JumpDelegate: AnyObject {\n  func jump(to label: String)\n}\n\n\/\/ MARK: - Parsing\nstruct InstructionParser {\n  enum ParserError: Error {\n     case formatError\n     case instructionWithNoName\n     case instructionWithNoArgs\n   }\n  \n  func parse(_ str: String) throws -> Instruction {\n    guard let splitted = str\n      .components(separatedBy: \";\").first?\n      .components(separatedBy: \" \")\n      .filter({ $0 != \"\" })\n    else { throw ParserError.formatError }\n    \n    guard let instructionName = splitted.first\n    else { throw ParserError.instructionWithNoName }\n    \n    let rawArgs = splitted\n      .dropFirst()\n      .joined(separator: \" \")\n    let splittedArgs = rawArgs\n      .components(separatedBy: \", \")\n    \n    guard let firstArg = splittedArgs.first\n    else { throw ParserError.formatError }\n    switch instructionName {\n      case \"mov\": return .mov(firstArg, InstructionArgument(from: splitted.last!))\n      case \"inc\": return .inc(firstArg)\n      case \"dec\": return .dec(firstArg)\n      case \"mul\": return .mul(firstArg, InstructionArgument(from: splitted.last!))\n      case \"add\": return .add(firstArg, InstructionArgument(from: splitted.last!))\n      case \"sub\": return .sub(firstArg, InstructionArgument(from: splitted.last!))\n      case \"div\": return .div(firstArg, InstructionArgument(from: splitted.last!))\n      case \"call\": return .call(firstArg)\n      case \"end\": return .end\n      case \"ret\": return .ret\n      case \"msg\": return .msg(MessageParser(raw: rawArgs))\n      case \"cmp\": return .cmp(InstructionArgument(from: firstArg), InstructionArgument(from: splitted.last!))\n      case \"jmp\": return .jmp(firstArg)\n      case \"jne\": return .jne(firstArg)\n      case \"jl\" : return .jl(firstArg)\n      case \"jle\": return .jle(firstArg)\n      case \"jg\" : return .jg(firstArg)\n      case \"jge\": return .jge(firstArg)\n      case \"je\" : return .je(firstArg)\n      default: break \/\/ TODO throw error for unknown instruciton\n    }\n    if instructionName.isLabel() {\n      return .label(instructionName)\n    }\n    fatalError(\"Instruction not yet supported \\(instructionName)\")\n  }\n}\nstruct MessageParser: Equatable {\n  let raw: String\n  \n  func parse(registers: [Register]) -> String {\n    let placeholder = \"&*^#@!\"\n    return raw\n      .replacingOccurrences(of: \"', '\", with: placeholder)\n      .components(separatedBy: \", \")\n      .map { str in\n            \n            \n        if let register = registers.filter({ $0.name == str}).first,\n           let value = register.value {\n          return String(value)\n        }\n        return str.replacingOccurrences(of: \"'\", with: \"\")\n      }.joined(separator: \"\").replacingOccurrences(of: placeholder, with: \", \")\n  }\n}\n\n\/\/ MARK - Command execution\n\nfinal class Program: JumpDelegate {\n  \/\/ MARK: - Inner types\n  enum ProgramError: Error {\n    case programEndedWithNoEnd\n  }\n  \/\/ MARK: - Dependencies\n  private let instructions: [Instruction]\n  private let cpu = CPU()\n  \n  \/\/ MARK: - Properties\n  private var programCounter = 0 \n  private var programStack: [Int] = []\n  private var result: String = \"\"\n  \n  \/\/ MARK: - Initialization\n  init(instructions: [Instruction]) {\n    self.instructions = instructions\n    self.cpu.delegate = self\n  }\n  \n  \/\/ MARK: - Public API\n  func run() throws -> String {\n    while true {\n      defer { programCounter += 1}\n      popStackIfNeeded()\n      guard let instruction = getCurrentInstruction()\n      else { throw ProgramError.programEndedWithNoEnd }\n      if case .end = instruction {\n        return result\n      }\n      stackInstructionIfNeeded(instruction)\n      if let res = try cpu.execute(instruction: instruction) {\n        result =  res\n      }\n    }\n    throw ProgramError.programEndedWithNoEnd\n  }\n  \n  \/\/ MARK: - JumpDelegate\n   func jump(to label: String) {\n      guard let targetInstruction = instructions.filter({ \n              if case $0 = Instruction.label(label + \":\") { return true }\n              return false\n            }).first,\n            let index = instructions.firstIndex(of: targetInstruction)\n      else { return }\n      self.programCounter = index \n   }\n  \n  \/\/ MARK: - Stack managing\n  private func popStackIfNeeded() {\n    if getCurrentInstruction() == .ret,\n       let stacked = programStack.popLast()    \n    { self.programCounter = stacked }\n  }\n  \n  private func stackInstructionIfNeeded(_ instruction: Instruction) {\n    if case .call(let labelName) = instruction {\n      guard let targetInstruction = instructions.filter({ \n              if case $0 = Instruction.label(labelName + \":\") { return true }\n              return false\n            }).first,\n            let index = instructions.firstIndex(of: targetInstruction)\n      else { return }\n      self.programStack.append(programCounter + 1)\n      self.programCounter = index \n    }\n  }\n  \n  \/\/ MARK: - Helpers\n  private func getCurrentInstruction() -> Instruction?\n  { return instructions[safe: programCounter] }\n  \n  private func debug() {\n    print(\"** DEBUG **\n\", \"Program counter: \", programCounter, \"\n Program stack: \", programStack  )\n    cpu.debug()\n    print(\"************\")\n  }\n}\nfinal class CPU {\n  \/\/ MARK: - Inner types\n  enum ExecutionError: Error {\n    case invalidInstruction\n    case invalidArgument\n    case conditionalJumpWithNoCompare\n  }\n  \n  \/\/ MARK: - Dependencies\n  weak var delegate: JumpDelegate?\n  \n  \/\/ MARK: - Properties\n  private var registers: [Register] = []\n  private var cmpValues: (InstructionArgument, InstructionArgument)?\n  \n  \/\/ MARK: - Public API\n  func execute(instruction: Instruction) throws -> String? {\n    switch instruction {\n      \/\/ MARK: - Flow\n      case .mov(let registerName, let value):\n        mov( to: registerName, value: value)\n      case .cmp(let x, let y):\n        cmpValues = (x, y)\n      \/\/ MARK: - Arithimetic\n      case .inc(let registerName): \n        inc(registerName: registerName)\n      case .dec(let registerName): \n        dec(registerName: registerName)\n      case .add(let registerName, let value):\n        add(to: registerName, value: value)\n      case .sub(let registerName, let value):\n        sub(to: registerName, value: value)\n      case .mul(let registerName, let value):\n        mul(to: registerName, value: value)\n      case .div(let registerName, let value):\n        div(to: registerName, value: value)\n      case .msg(let parser):\n        return parser.parse(registers: self.registers)\n      case .jmp(let targetLabel):\n        try jmp(to: targetLabel)\n      case .jne(let targetLabel):\n        try jne(to: targetLabel)\n      case .jl(let targetLabel):\n        try jl(to: targetLabel)\n      case .jle(let targetLabel):\n        try jle(to: targetLabel)\n      case .jge(let targetLabel):\n        try jge(to: targetLabel)\n      case .jg(let targetLabel):\n        try jg(to: targetLabel)\n      case .je(let targetLabel):\n        try je(to: targetLabel)\n      case .call: break\n      case .label: break\n      case .ret: break\n      case .end: break\n    }\n    return nil\n  }\n  \n  \/\/ MARK: - Manipulation + arithimetic instructions\n  private func mov(to registerName: String, value: InstructionArgument) {\n    let destination = fetchRegisterAndCreateIfNeeded(named: registerName)\n    if let sourceRegisterName = value.stringValue,\n       let localRegister = registers.first(where: { $0.name == sourceRegisterName }){\n         destination.value = localRegister.value\n         return\n       }\n    if let value = value.intValue\n    { destination.value = value }\n  }\n  private func inc(registerName: String) {\n    if let register = fetchLocalRegister(registerName),\n       let rValue = register.value\n    { register.value = rValue + 1 }\n  }\n  private func dec(registerName: String) {\n    if let register = fetchLocalRegister(registerName),\n       let rValue = register.value\n    { register.value = rValue - 1 }\n  }\n  private func add(to registerName: String, value: InstructionArgument) {\n    let destination = fetchRegisterAndCreateIfNeeded(named: registerName)\n    if let sourceRegisterName = value.stringValue,\n       let localRegister = registers.first(where: { $0.name == sourceRegisterName }),\n       let numerator = destination.value,\n       let denominator = localRegister.value{\n         destination.value = numerator + denominator\n         return\n       }\n    if let value = value.intValue,\n       let numerator = destination.value\n    { destination.value = numerator + value }\n  }\n  private func sub(to registerName: String, value: InstructionArgument) {\n    let destination = fetchRegisterAndCreateIfNeeded(named: registerName)\n    if let sourceRegisterName = value.stringValue,\n       let localRegister = registers.first(where: { $0.name == sourceRegisterName }),\n       let numerator = destination.value,\n       let denominator = localRegister.value{\n         destination.value = numerator - denominator\n         return\n       }\n    if let value = value.intValue,\n       let numerator = destination.value\n    { destination.value = numerator - value }\n  }\n  private func mul(to registerName: String, value: InstructionArgument) {\n    let destination = fetchRegisterAndCreateIfNeeded(named: registerName)\n    if let sourceRegisterName = value.stringValue,\n       let localRegister = registers.first(where: { $0.name == sourceRegisterName }),\n       let numerator = destination.value,\n       let denominator = localRegister.value{\n         destination.value = numerator * denominator\n         return\n       }\n    if let value = value.intValue,\n       let numerator = destination.value\n    { destination.value = numerator * value }\n  }\n  private func div(to registerName: String, value: InstructionArgument) {\n    let destination = fetchRegisterAndCreateIfNeeded(named: registerName)\n    if let sourceRegisterName = value.stringValue,\n       let localRegister = registers.first(where: { $0.name == sourceRegisterName }),\n       let numerator = destination.value,\n       let denominator = localRegister.value{\n         destination.value = numerator \/ denominator\n         return\n       }\n    if let value = value.intValue,\n       let numerator = destination.value\n    { destination.value = numerator \/ value }\n  }\n  \n  \/\/ MARK: - Logical instructions\n\n  private func jmp(to label: String) throws {\n    delegate?.jump(to: label)\n  }\n  \n  private func jne(to label: String) throws {\n    try jumpIfNeeded(to: label) { $0 == $1 }\n  }\n  \n  private func jl(to label: String) throws {\n    try jumpIfNeeded(to: label) { $0 >= $1 }\n  }\n  \n  private func jle(to label: String) throws {\n    try jumpIfNeeded(to: label) { $0 > $1 }\n  }  \n  \n  private func jge(to label: String) throws {\n    try jumpIfNeeded(to: label) { $0 < $1 }\n  }\n  \n  private func jg(to label: String) throws {\n    try jumpIfNeeded(to: label) { $0 <= $1 }\n  }\n  private func je(to label: String) throws {\n    try jumpIfNeeded(to: label) { $0 != $1 }\n  }\n  private func jumpIfNeeded(to label: String, _ comparator: (Int, Int) -> Bool ) throws {\n    guard let (x, y) = cmpValues\n    else { throw ExecutionError.conditionalJumpWithNoCompare }\n    \n    if let xRegName = x.stringValue,\n       let yRegName = y.stringValue,\n       let xReg = fetchLocalRegister(xRegName),\n       let yReg = fetchLocalRegister(yRegName),\n       let xValue = xReg.value,\n       let yValue = yReg.value,\n       comparator(xValue, yValue) { return }\n        \n    \n    if let xReg = x.stringValue,\n       let reg = fetchLocalRegister(xReg),\n       let xValue = reg.value,\n       let yValue = y.intValue,\n       comparator(xValue, yValue) { return }\n    \n    if let yReg = y.stringValue,\n       let reg = fetchLocalRegister(yReg),\n       let yValue = reg.value,\n       let xValue = x.intValue,\n       comparator(xValue, yValue) { return }\n    \n    if let xValue = x.intValue,\n       let yValue = y.intValue,\n       comparator(xValue, yValue) { return }\n    delegate?.jump(to: label)\n  }\n  \n  \n  func debug() {\n    print(\"cmpValues\", cmpValues!)\n    printRegisters()\n  }\n  func printRegisters() {\n    registers.forEach { print(\"REGISTERS\", $0.name, $0.value ?? \"NO value\") }\n  }\n  \n  private func fetchLocalRegister(_ name: String) -> Register? \n  { return registers.first(where: { $0.name == name }) }\n  \n  private func fetchRegisterAndCreateIfNeeded(named: String) -> Register {\n    if let localRegister = registers.first(where: { $0.name == named })\n    { return localRegister }\n    let register = Register (\n      name: named,\n      value: nil\n    )\n    registers.append(register)\n    return register\n  }\n}\n\n\/\/ MARK: - Main\nfunc assemblerInterpreter(_ program: String) throws -> String {\n  let instructionParser = InstructionParser()\n  let rawInstructions = program.components(separatedBy: \"\n\").filter { $0 != \"\" }\n  let parsedInstructions = rawInstructions.compactMap { try? instructionParser.parse($0) }\n  let program = Program(instructions: parsedInstructions)\n  \n  return try program.run() \n}\n\n\/\/ MARK: - Extensions\nprotocol InstructionArgumentProtocol {}\nextension String: InstructionArgumentProtocol {}\nextension Int: InstructionArgumentProtocol {}\n\nextension Collection {\n    \/\/\/ Returns the element at the specified index if it is within bounds, otherwise nil.\n    subscript (safe index: Index) -> Element? {\n        return indices.contains(index) ? self[index] : nil\n    }\n}\nextension String {\n  func isLabel() -> Bool { return last == \":\" }\n}","lang_id":53,"is_control":0,"status":null,"variations":0,"best_practice":0,"clever":0,"comments":0,"created_at":"2022-12-30 18:39:43","updated_at":"2022-12-30 18:39:43"}]}